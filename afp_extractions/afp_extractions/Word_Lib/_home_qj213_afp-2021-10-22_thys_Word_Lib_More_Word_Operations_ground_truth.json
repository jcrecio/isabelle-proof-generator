{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/More_Word_Operations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma alignUp_unfold:\n  \\<open>alignUp w n = (w + mask n) AND NOT (mask n)\\<close>", "lemma word_ctz_le:\n  \"word_ctz (w :: ('a::len word)) \\<le> LENGTH('a)\"", "lemma word_ctz_less:\n  \"w \\<noteq> 0 \\<Longrightarrow> word_ctz (w :: ('a::len word)) < LENGTH('a)\"", "lemma take_bit_word_ctz_eq [simp]:\n  \\<open>take_bit LENGTH('a) (word_ctz w) = word_ctz w\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma word_ctz_not_minus_1:\n  \\<open>word_of_nat (word_ctz (w :: 'a :: len word)) \\<noteq> (- 1 :: 'a::len word)\\<close> if \\<open>1 < LENGTH('a)\\<close>", "lemma unat_of_nat_ctz_mw:\n  \"unat (of_nat (word_ctz (w :: 'a :: len word)) :: 'a :: len word) = word_ctz w\"", "lemma unat_of_nat_ctz_smw:\n  \"unat (of_nat (word_ctz (w :: 'a :: len word)) :: 'a :: len signed word) = word_ctz w\"", "lemma sign_extend_eq_signed_take_bit:\n  \\<open>sign_extend = signed_take_bit\\<close>", "lemma ptr_add_0 [simp]:\n  \"ptr_add ref 0 = ref \"", "lemma pop_count_0[simp]:\n  \"pop_count 0 = 0\"", "lemma pop_count_1[simp]:\n  \"pop_count 1 = 1\"", "lemma pop_count_0_imp_0:\n  \"(pop_count w = 0) = (w = 0)\"", "lemma word_log2_zero_eq [simp]:\n  \\<open>word_log2 0 = 0\\<close>", "lemma word_log2_unfold:\n  \\<open>word_log2 w = (if w = 0 then 0 else Max {n. bit w n})\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma word_log2_eqI:\n  \\<open>word_log2 w = n\\<close>\n  if \\<open>w \\<noteq> 0\\<close> \\<open>bit w n\\<close> \\<open>\\<And>m. bit w m \\<Longrightarrow> m \\<le> n\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma bit_word_log2:\n  \\<open>bit w (word_log2 w)\\<close> if \\<open>w \\<noteq> 0\\<close>", "lemma word_log2_maximum:\n  \\<open>n \\<le> word_log2 w\\<close> if \\<open>bit w n\\<close>", "lemma word_log2_nth_same:\n  \"w \\<noteq> 0 \\<Longrightarrow> w !! word_log2 w\"", "lemma word_log2_nth_not_set:\n  \"\\<lbrakk> word_log2 w < i ; i < size w \\<rbrakk> \\<Longrightarrow> \\<not> w !! i\"", "lemma word_log2_highest:\n  assumes a: \"w !! i\"\n  shows \"i \\<le> word_log2 w\"", "lemma word_log2_max:\n  \"word_log2 w < size w\"", "lemma word_clz_0[simp]:\n  \"word_clz (0::'a::len word) = LENGTH('a)\"", "lemma word_clz_minus_one[simp]:\n  \"word_clz (-1::'a::len word) = 0\"", "lemma is_aligned_alignUp[simp]:\n  \"is_aligned (alignUp p n) n\"", "lemma alignUp_le[simp]:\n  \"alignUp p n \\<le> p + 2 ^ n - 1\"", "lemma alignUp_idem:\n  fixes a :: \"'a::len word\"\n  assumes \"is_aligned a n\" \"n < LENGTH('a)\"\n  shows \"alignUp a n = a\"", "lemma alignUp_not_aligned_eq:\n  fixes a :: \"'a :: len word\"\n  assumes al: \"\\<not> is_aligned a n\"\n  and     sz: \"n < LENGTH('a)\"\n  shows   \"alignUp a n = (a div 2 ^ n + 1) * 2 ^ n\"", "lemma alignUp_ge:\n  fixes a :: \"'a :: len word\"\n  assumes sz: \"n < LENGTH('a)\"\n  and nowrap: \"alignUp a n \\<noteq> 0\"\n  shows \"a \\<le> alignUp a n\"", "lemma alignUp_le_greater_al:\n  fixes x :: \"'a :: len word\"\n  assumes le: \"a \\<le> x\"\n  and     sz: \"n < LENGTH('a)\"\n  and     al: \"is_aligned x n\"\n  shows   \"alignUp a n \\<le> x\"", "lemma alignUp_is_aligned_nz:\n  fixes a :: \"'a :: len word\"\n  assumes al: \"is_aligned x n\"\n  and     sz: \"n < LENGTH('a)\"\n  and     ax: \"a \\<le> x\"\n  and     az: \"a \\<noteq> 0\"\n  shows   \"alignUp (a::'a :: len word) n \\<noteq> 0\"", "lemma alignUp_ar_helper:\n  fixes a :: \"'a :: len word\"\n  assumes al: \"is_aligned x n\"\n  and     sz: \"n < LENGTH('a)\"\n  and    sub: \"{x..x + 2 ^ n - 1} \\<subseteq> {a..b}\"\n  and    anz: \"a \\<noteq> 0\"\n  shows \"a \\<le> alignUp a n \\<and> alignUp a n + 2 ^ n - 1 \\<le> b\"", "lemma alignUp_def2:\n  \"alignUp a sz = a + 2 ^ sz - 1 AND NOT (mask sz)\"", "lemma alignUp_def3:\n  \"alignUp a sz = 2^ sz + (a - 1 AND NOT (mask sz))\"", "lemma  alignUp_plus:\n  \"is_aligned w us \\<Longrightarrow> alignUp (w + a) us  = w + alignUp a us\"", "lemma alignUp_distance:\n  \"alignUp (q :: 'a :: len word) sz - q \\<le> mask sz\"", "lemma is_aligned_diff_neg_mask:\n  \"is_aligned p sz \\<Longrightarrow> (p - q AND NOT (mask sz)) = (p - ((alignUp q sz) AND NOT (mask sz)))\"", "lemma word_clz_max:\n  \"word_clz w \\<le> size (w::'a::len word)\"", "lemma word_clz_nonzero_max:\n  fixes w :: \"'a::len word\"\n  assumes nz: \"w \\<noteq> 0\"\n  shows \"word_clz w < size (w::'a::len word)\"", "lemma sign_extend_bitwise_if:\n  \"i < size w \\<Longrightarrow> sign_extend e w !! i \\<longleftrightarrow> (if i < e then w !! i else w !! e)\"", "lemma sign_extend_bitwise_if'  [word_eqI_simps]:\n  \\<open>i < LENGTH('a) \\<Longrightarrow> sign_extend e w !! i \\<longleftrightarrow> (if i < e then w !! i else w !! e)\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma sign_extend_bitwise_disj:\n  \"i < size w \\<Longrightarrow> sign_extend e w !! i \\<longleftrightarrow> i \\<le> e \\<and> w !! i \\<or> e \\<le> i \\<and> w !! e\"", "lemma sign_extend_bitwise_cases:\n  \"i < size w \\<Longrightarrow> sign_extend e w !! i \\<longleftrightarrow> (i \\<le> e \\<longrightarrow> w !! i) \\<and> (e \\<le> i \\<longrightarrow> w !! e)\"", "lemmas sign_extend_bitwise_disj' = sign_extend_bitwise_disj[simplified word_size]", "lemmas sign_extend_bitwise_cases' = sign_extend_bitwise_cases[simplified word_size]", "lemma sign_extend_def':\n  \"sign_extend n w = (if w !! n then w OR NOT (mask (Suc n)) else w AND mask (Suc n))\"", "lemma sign_extended_sign_extend:\n  \"sign_extended n (sign_extend n w)\"", "lemma sign_extended_iff_sign_extend:\n  \"sign_extended n w \\<longleftrightarrow> sign_extend n w = w\"", "lemma sign_extended_weaken:\n  \"sign_extended n w \\<Longrightarrow> n \\<le> m \\<Longrightarrow> sign_extended m w\"", "lemma sign_extend_sign_extend_eq:\n  \"sign_extend m (sign_extend n w) = sign_extend (min m n) w\"", "lemma sign_extended_high_bits:\n  \"\\<lbrakk> sign_extended e p; j < size p; e \\<le> i; i < j \\<rbrakk> \\<Longrightarrow> p !! i = p !! j\"", "lemma sign_extend_eq:\n  \"w AND mask (Suc n) = v AND mask (Suc n) \\<Longrightarrow> sign_extend n w = sign_extend n v\"", "lemma sign_extended_add:\n  assumes p: \"is_aligned p n\"\n  assumes f: \"f < 2 ^ n\"\n  assumes e: \"n \\<le> e\"\n  assumes \"sign_extended e p\"\n  shows \"sign_extended e (p + f)\"", "lemma sign_extended_neq_mask:\n  \"\\<lbrakk>sign_extended n ptr; m \\<le> n\\<rbrakk> \\<Longrightarrow> sign_extended n (ptr AND NOT (mask m))\"", "lemma limited_and_eq_0:\n  \"\\<lbrakk> limited_and x z; y AND NOT z = y \\<rbrakk> \\<Longrightarrow> x AND y = 0\"", "lemma limited_and_eq_id:\n  \"\\<lbrakk> limited_and x z; y AND z = z \\<rbrakk> \\<Longrightarrow> x AND y = x\"", "lemma lshift_limited_and:\n  \"limited_and x z \\<Longrightarrow> limited_and (x << n) (z << n)\"", "lemma rshift_limited_and:\n  \"limited_and x z \\<Longrightarrow> limited_and (x >> n) (z >> n)\"", "lemmas limited_and_simps1 = limited_and_eq_0 limited_and_eq_id", "lemmas is_aligned_limited_and\n    = is_aligned_neg_mask_eq[unfolded mask_eq_decr_exp, folded limited_and_def]", "lemmas limited_and_simps = limited_and_simps1\n       limited_and_simps1[OF is_aligned_limited_and]\n       limited_and_simps1[OF lshift_limited_and]\n       limited_and_simps1[OF rshift_limited_and]\n       limited_and_simps1[OF rshift_limited_and, OF is_aligned_limited_and]\n       not_one shiftl_shiftr1[unfolded word_size mask_eq_decr_exp]\n       shiftl_shiftr2[unfolded word_size mask_eq_decr_exp]", "lemma from_bool_eq:\n  \\<open>from_bool = of_bool\\<close>", "lemma from_bool_0:\n  \"(from_bool x = 0) = (\\<not> x)\"", "lemma from_bool_eq_if':\n  \"((if P then 1 else 0) = from_bool Q) = (P = Q)\"", "lemma to_bool_and_1:\n  \"to_bool (x AND 1) = (x !! 0)\"", "lemma to_bool_from_bool [simp]:\n  \"to_bool (from_bool r) = r\"", "lemma from_bool_neq_0 [simp]:\n  \"(from_bool b \\<noteq> 0) = b\"", "lemma from_bool_mask_simp [simp]:\n  \"(from_bool r :: 'a::len word) AND 1 = from_bool r\"", "lemma from_bool_1 [simp]:\n  \"(from_bool P = 1) = P\"", "lemma ge_0_from_bool [simp]:\n  \"(0 < from_bool P) = P\"", "lemma limited_and_from_bool:\n  \"limited_and (from_bool b) 1\"", "lemma to_bool_1 [simp]: \"to_bool 1\"", "lemma to_bool_0 [simp]: \"\\<not>to_bool 0\"", "lemma from_bool_eq_if:\n  \"(from_bool Q = (if P then 1 else 0)) = (P = Q)\"", "lemma to_bool_eq_0:\n  \"(\\<not> to_bool x) = (x = 0)\"", "lemma to_bool_neq_0:\n  \"(to_bool x) = (x \\<noteq> 0)\"", "lemma from_bool_all_helper:\n  \"(\\<forall>bool. from_bool bool = val \\<longrightarrow> P bool)\n      = ((\\<exists>bool. from_bool bool = val) \\<longrightarrow> P (val \\<noteq> 0))\"", "lemma fold_eq_0_to_bool:\n  \"(v = 0) = (\\<not> to_bool v)\"", "lemma from_bool_to_bool_iff:\n  \"w = from_bool b \\<longleftrightarrow> to_bool w = b \\<and> (w = 0 \\<or> w = 1)\"", "lemma from_bool_eqI:\n  \"from_bool x = from_bool y \\<Longrightarrow> x = y\"", "lemma neg_mask_in_mask_range:\n  \"is_aligned ptr bits \\<Longrightarrow> (ptr' AND NOT(mask bits) = ptr) = (ptr' \\<in> mask_range ptr bits)\"", "lemma aligned_offset_in_range:\n  \"\\<lbrakk> is_aligned (x :: 'a :: len word) m; y < 2 ^ m; is_aligned p n; n \\<ge> m; n < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> (x + y \\<in> {p .. p + mask n}) = (x \\<in> mask_range p n)\"", "lemma mask_range_to_bl':\n  \"\\<lbrakk> is_aligned (ptr :: 'a :: len word) bits; bits < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> mask_range ptr bits\n       = {x. take (LENGTH('a) - bits) (to_bl x) = take (LENGTH('a) - bits) (to_bl ptr)}\"", "lemma mask_range_to_bl:\n  \"is_aligned (ptr :: 'a :: len word) bits\n   \\<Longrightarrow> mask_range ptr bits\n        = {x. take (LENGTH('a) - bits) (to_bl x) = take (LENGTH('a) - bits) (to_bl ptr)}\"", "lemma aligned_mask_range_cases:\n  \"\\<lbrakk> is_aligned (p :: 'a :: len word) n; is_aligned (p' :: 'a :: len word) n' \\<rbrakk>\n   \\<Longrightarrow> mask_range p n \\<inter> mask_range p' n' = {} \\<or>\n       mask_range p n \\<subseteq> mask_range p' n' \\<or>\n       mask_range p n \\<supseteq> mask_range p' n'\"", "lemma aligned_mask_range_offset_subset:\n  assumes al: \"is_aligned (ptr :: 'a :: len word) sz\" and al': \"is_aligned x sz'\"\n  and szv: \"sz' \\<le> sz\"\n  and xsz: \"x < 2 ^ sz\"\n  shows \"mask_range (ptr+x) sz' \\<subseteq> mask_range ptr sz\"", "lemma aligned_mask_ranges_disjoint:\n  \"\\<lbrakk> is_aligned (p :: 'a :: len word) n; is_aligned (p' :: 'a :: len word) n';\n     p AND NOT(mask n') \\<noteq> p'; p' AND NOT(mask n) \\<noteq> p \\<rbrakk>\n   \\<Longrightarrow> mask_range p n \\<inter> mask_range p' n' = {}\"", "lemma aligned_mask_ranges_disjoint2:\n  \"\\<lbrakk> is_aligned p n; is_aligned ptr bits; n \\<ge> m; n < size p; m \\<le> bits;\n     (\\<forall>y < 2 ^ (n - m). p + (y << m) \\<notin> mask_range ptr bits) \\<rbrakk>\n   \\<Longrightarrow> mask_range p n \\<inter> mask_range ptr bits = {}\"", "lemma word_clz_sint_upper[simp]:\n  \"LENGTH('a) \\<ge> 3 \\<Longrightarrow> sint (of_nat (word_clz (w :: 'a :: len word)) :: 'a sword) \\<le> int (LENGTH('a))\"", "lemma word_clz_sint_lower[simp]:\n  \"LENGTH('a) \\<ge> 3\n   \\<Longrightarrow> - sint (of_nat (word_clz (w :: 'a :: len word)) :: 'a signed word) \\<le> int (LENGTH('a))\"", "lemma mask_range_subsetD:\n  \"\\<lbrakk> p' \\<in> mask_range p n; x' \\<in> mask_range p' n'; n' \\<le> n; is_aligned p n; is_aligned p' n' \\<rbrakk> \\<Longrightarrow>\n   x' \\<in> mask_range p n\"", "lemma nasty_split_lt:\n  \"\\<lbrakk> (x :: 'a:: len word) < 2 ^ (m - n); n \\<le> m; m < LENGTH('a::len) \\<rbrakk>\n     \\<Longrightarrow> x * 2 ^ n + (2 ^ n - 1) \\<le> 2 ^ m - 1\"", "lemma nasty_split_less:\n  \"\\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a::len); x < 2 ^ (nm - n)\\<rbrakk>\n   \\<Longrightarrow> (x :: 'a word) * 2 ^ n + (2 ^ m - 1) < 2 ^ nm\"", "lemma add_mult_in_mask_range:\n  \"\\<lbrakk> is_aligned (base :: 'a :: len word) n; n < LENGTH('a); bits \\<le> n; x < 2 ^ (n - bits) \\<rbrakk>\n   \\<Longrightarrow> base + x * 2^bits \\<in> mask_range base n\"", "lemma from_to_bool_last_bit:\n  \"from_bool (to_bool (x AND 1)) = x AND 1\"", "lemma sint_ctz:\n  \"LENGTH('a) > 2\n   \\<Longrightarrow> 0 \\<le> sint (of_nat (word_ctz (x :: 'a :: len word)) :: 'a signed word)\n        \\<and> sint (of_nat (word_ctz x) :: 'a signed word) \\<le> int (LENGTH('a))\"", "lemma unat_of_nat_word_log2:\n  \"LENGTH('a) < 2 ^ LENGTH('b)\n   \\<Longrightarrow> unat (of_nat (word_log2 (n :: 'a :: len word)) :: 'b :: len word) = word_log2 n\"", "lemma aligned_mask_diff:\n  \"\\<lbrakk> is_aligned (dest :: 'a :: len word) bits; is_aligned (ptr :: 'a :: len word) sz;\n     bits \\<le> sz; sz < LENGTH('a); dest < ptr \\<rbrakk>\n   \\<Longrightarrow> mask bits + dest < ptr\""], "translations": [["", "lemma alignUp_unfold:\n  \\<open>alignUp w n = (w + mask n) AND NOT (mask n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp w n = w + mask n AND NOT (mask n)", "by (simp add: alignUp_def mask_eq_exp_minus_1 add_mask_fold)"], ["", "(* standard notation for blocks of 2^n-1 words, usually aligned;\n   abbreviation so it simplifies directly *)"], ["", "abbreviation mask_range :: \"'a::len word \\<Rightarrow> nat \\<Rightarrow> 'a word set\" where\n  \"mask_range p n \\<equiv> {p .. p + mask n}\""], ["", "definition\n  w2byte :: \"'a :: len word \\<Rightarrow> 8 word\" where\n  \"w2byte \\<equiv> ucast\""], ["", "(* Count leading zeros  *)"], ["", "definition\n  word_clz :: \"'a::len word \\<Rightarrow> nat\"\nwhere\n  \"word_clz w \\<equiv> length (takeWhile Not (to_bl w))\""], ["", "(* Count trailing zeros  *)"], ["", "definition\n  word_ctz :: \"'a::len word \\<Rightarrow> nat\"\nwhere\n  \"word_ctz w \\<equiv> length (takeWhile Not (rev (to_bl w)))\""], ["", "lemma word_ctz_le:\n  \"word_ctz (w :: ('a::len word)) \\<le> LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_ctz w \\<le> LENGTH('a)", "apply (clarsimp simp: word_ctz_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (takeWhile Not (rev (to_bl w))) \\<le> LENGTH('a)", "using length_takeWhile_le"], ["proof (prove)\nusing this:\n  length (takeWhile ?P ?xs) \\<le> length ?xs\n\ngoal (1 subgoal):\n 1. length (takeWhile Not (rev (to_bl w))) \\<le> LENGTH('a)", "apply (rule order_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rev (to_bl w)) \\<le> LENGTH('a)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_ctz_less:\n  \"w \\<noteq> 0 \\<Longrightarrow> word_ctz (w :: ('a::len word)) < LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> word_ctz w < LENGTH('a)", "apply (clarsimp simp: word_ctz_def eq_zero_set_bl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<in> set (to_bl w) \\<Longrightarrow>\n    length (takeWhile Not (rev (to_bl w))) < LENGTH('a)", "using length_takeWhile_less"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>set ?xs. \\<not> ?P x \\<Longrightarrow>\n  length (takeWhile ?P ?xs) < length ?xs\n\ngoal (1 subgoal):\n 1. True \\<in> set (to_bl w) \\<Longrightarrow>\n    length (takeWhile Not (rev (to_bl w))) < LENGTH('a)", "apply (rule less_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. True \\<in> set (to_bl w) \\<Longrightarrow>\n    \\<exists>x\\<in>set (rev (to_bl w)). \\<not> \\<not> x\n 2. True \\<in> set (to_bl w) \\<Longrightarrow>\n    length (rev (to_bl w)) \\<le> LENGTH('a)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_bit_word_ctz_eq [simp]:\n  \\<open>take_bit LENGTH('a) (word_ctz w) = word_ctz w\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit LENGTH('a) (word_ctz w) = word_ctz w", "apply (simp add: take_bit_nat_eq_self_iff word_ctz_def to_bl_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (takeWhile Not (map (bit w) [0..<LENGTH('a)])) < 2 ^ LENGTH('a)", "using length_takeWhile_le"], ["proof (prove)\nusing this:\n  length (takeWhile ?P ?xs) \\<le> length ?xs\n\ngoal (1 subgoal):\n 1. length (takeWhile Not (map (bit w) [0..<LENGTH('a)])) < 2 ^ LENGTH('a)", "apply (rule le_less_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (bit w) [0..<LENGTH('a)]) < 2 ^ LENGTH('a)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_ctz_not_minus_1:\n  \\<open>word_of_nat (word_ctz (w :: 'a :: len word)) \\<noteq> (- 1 :: 'a::len word)\\<close> if \\<open>1 < LENGTH('a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_nat (word_ctz w) \\<noteq> - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. word_of_nat (word_ctz w) \\<noteq> - 1", "note word_ctz_le"], ["proof (state)\nthis:\n  word_ctz ?w \\<le> LENGTH(?'a)\n\ngoal (1 subgoal):\n 1. word_of_nat (word_ctz w) \\<noteq> - 1", "also"], ["proof (state)\nthis:\n  word_ctz ?w \\<le> LENGTH(?'a)\n\ngoal (1 subgoal):\n 1. word_of_nat (word_ctz w) \\<noteq> - 1", "from that"], ["proof (chain)\npicking this:\n  1 < LENGTH('a)", "have \\<open>LENGTH('a) < mask LENGTH('a)\\<close>"], ["proof (prove)\nusing this:\n  1 < LENGTH('a)\n\ngoal (1 subgoal):\n 1. LENGTH('a) < mask LENGTH('a)", "by (simp add: less_mask)"], ["proof (state)\nthis:\n  LENGTH('a) < mask LENGTH('a)\n\ngoal (1 subgoal):\n 1. word_of_nat (word_ctz w) \\<noteq> - 1", "finally"], ["proof (chain)\npicking this:\n  word_ctz ?w1 < mask LENGTH('a)", "have \\<open>word_ctz w < mask LENGTH('a)\\<close>"], ["proof (prove)\nusing this:\n  word_ctz ?w1 < mask LENGTH('a)\n\ngoal (1 subgoal):\n 1. word_ctz w < mask LENGTH('a)", "."], ["proof (state)\nthis:\n  word_ctz w < mask LENGTH('a)\n\ngoal (1 subgoal):\n 1. word_of_nat (word_ctz w) \\<noteq> - 1", "then"], ["proof (chain)\npicking this:\n  word_ctz w < mask LENGTH('a)", "have \\<open>word_of_nat (word_ctz w) < (word_of_nat (mask LENGTH('a)) :: 'a word)\\<close>"], ["proof (prove)\nusing this:\n  word_ctz w < mask LENGTH('a)\n\ngoal (1 subgoal):\n 1. word_of_nat (word_ctz w) < word_of_nat (mask LENGTH('a))", "by (simp add: of_nat_word_less_iff)"], ["proof (state)\nthis:\n  word_of_nat (word_ctz w) < word_of_nat (mask LENGTH('a))\n\ngoal (1 subgoal):\n 1. word_of_nat (word_ctz w) \\<noteq> - 1", "also"], ["proof (state)\nthis:\n  word_of_nat (word_ctz w) < word_of_nat (mask LENGTH('a))\n\ngoal (1 subgoal):\n 1. word_of_nat (word_ctz w) \\<noteq> - 1", "have \\<open>\\<dots> = - 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_nat (mask LENGTH('a)) = - 1", "by (rule bit_word_eqI) (simp add: bit_simps)"], ["proof (state)\nthis:\n  word_of_nat (mask LENGTH('a)) = - 1\n\ngoal (1 subgoal):\n 1. word_of_nat (word_ctz w) \\<noteq> - 1", "finally"], ["proof (chain)\npicking this:\n  word_of_nat (word_ctz w) < - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  word_of_nat (word_ctz w) < - 1\n\ngoal (1 subgoal):\n 1. word_of_nat (word_ctz w) \\<noteq> - 1", "by simp"], ["proof (state)\nthis:\n  word_of_nat (word_ctz w) \\<noteq> - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unat_of_nat_ctz_mw:\n  \"unat (of_nat (word_ctz (w :: 'a :: len word)) :: 'a :: len word) = word_ctz w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (word_of_nat (word_ctz w)) = word_ctz w", "by simp"], ["", "lemma unat_of_nat_ctz_smw:\n  \"unat (of_nat (word_ctz (w :: 'a :: len word)) :: 'a :: len signed word) = word_ctz w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (word_of_nat (word_ctz w)) = word_ctz w", "by simp"], ["", "definition\n  word_log2 :: \"'a::len word \\<Rightarrow> nat\"\nwhere\n  \"word_log2 (w::'a::len word) \\<equiv> size w - 1 - word_clz w\""], ["", "(* Bit population count. Equivalent of __builtin_popcount. *)"], ["", "definition\n  pop_count :: \"('a::len) word \\<Rightarrow> nat\"\nwhere\n  \"pop_count w \\<equiv> length (filter id (to_bl w))\""], ["", "(* Sign extension from bit n *)"], ["", "definition\n  sign_extend :: \"nat \\<Rightarrow> 'a::len word \\<Rightarrow> 'a word\"\nwhere\n  \"sign_extend n w \\<equiv> if w !! n then w OR NOT (mask n) else w AND mask n\""], ["", "lemma sign_extend_eq_signed_take_bit:\n  \\<open>sign_extend = signed_take_bit\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_extend = signed_take_bit", "proof (rule ext)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. sign_extend x xa = signed_take_bit x xa", "fix n and w :: \\<open>'a::len word\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. sign_extend x xa = signed_take_bit x xa", "show \\<open>sign_extend n w = signed_take_bit n w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_extend n w = signed_take_bit n w", "proof (rule bit_word_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow>\n       bit (sign_extend n w) na = bit (signed_take_bit n w) na", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow>\n       bit (sign_extend n w) na = bit (signed_take_bit n w) na", "assume \\<open>q < LENGTH('a)\\<close>"], ["proof (state)\nthis:\n  q < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       na < LENGTH('a) \\<Longrightarrow>\n       bit (sign_extend n w) na = bit (signed_take_bit n w) na", "then"], ["proof (chain)\npicking this:\n  q < LENGTH('a)", "show \\<open>bit (sign_extend n w) q \\<longleftrightarrow> bit (signed_take_bit n w) q\\<close>"], ["proof (prove)\nusing this:\n  q < LENGTH('a)\n\ngoal (1 subgoal):\n 1. bit (sign_extend n w) q = bit (signed_take_bit n w) q", "by (auto simp add: test_bit_eq_bit bit_signed_take_bit_iff\n        sign_extend_def bit_and_iff bit_or_iff bit_not_iff bit_mask_iff not_less\n        exp_eq_0_imp_not_bit not_le min_def)"], ["proof (state)\nthis:\n  bit (sign_extend n w) q = bit (signed_take_bit n w) q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign_extend n w = signed_take_bit n w\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  sign_extended :: \"nat \\<Rightarrow> 'a::len word \\<Rightarrow> bool\"\nwhere\n  \"sign_extended n w \\<equiv> \\<forall>i. n < i \\<longrightarrow> i < size w \\<longrightarrow> w !! i = w !! n\""], ["", "lemma ptr_add_0 [simp]:\n  \"ptr_add ref 0 = ref \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ptr_add ref 0 = ref", "unfolding ptr_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ref + word_of_nat 0 = ref", "by simp"], ["", "lemma pop_count_0[simp]:\n  \"pop_count 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pop_count 0 = 0", "by (clarsimp simp:pop_count_def)"], ["", "lemma pop_count_1[simp]:\n  \"pop_count 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pop_count 1 = 1", "by (clarsimp simp:pop_count_def to_bl_1)"], ["", "lemma pop_count_0_imp_0:\n  \"(pop_count w = 0) = (w = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pop_count w = 0) = (w = 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pop_count w = 0 \\<Longrightarrow> w = 0\n 2. w = 0 \\<Longrightarrow> pop_count w = 0", "apply (clarsimp simp:pop_count_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. filter id (to_bl w) = [] \\<Longrightarrow> w = 0\n 2. w = 0 \\<Longrightarrow> pop_count w = 0", "apply (subst (asm) filter_empty_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set (to_bl w). \\<not> id x \\<Longrightarrow> w = 0\n 2. w = 0 \\<Longrightarrow> pop_count w = 0", "apply (clarsimp simp:eq_zero_set_bl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set (to_bl w). \\<not> x;\n     True \\<in> set (to_bl w)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. w = 0 \\<Longrightarrow> pop_count w = 0", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. w = 0 \\<Longrightarrow> pop_count w = 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_log2_zero_eq [simp]:\n  \\<open>word_log2 0 = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_log2 0 = 0", "by (simp add: word_log2_def word_clz_def word_size)"], ["", "lemma word_log2_unfold:\n  \\<open>word_log2 w = (if w = 0 then 0 else Max {n. bit w n})\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_log2 w = (if w = 0 then 0 else Max {n. bit w n})", "proof (cases \\<open>w = 0\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow>\n    word_log2 w = (if w = 0 then 0 else Max {n. bit w n})\n 2. w \\<noteq> 0 \\<Longrightarrow>\n    word_log2 w = (if w = 0 then 0 else Max {n. bit w n})", "case True"], ["proof (state)\nthis:\n  w = 0\n\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow>\n    word_log2 w = (if w = 0 then 0 else Max {n. bit w n})\n 2. w \\<noteq> 0 \\<Longrightarrow>\n    word_log2 w = (if w = 0 then 0 else Max {n. bit w n})", "then"], ["proof (chain)\npicking this:\n  w = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  w = 0\n\ngoal (1 subgoal):\n 1. word_log2 w = (if w = 0 then 0 else Max {n. bit w n})", "by simp"], ["proof (state)\nthis:\n  word_log2 w = (if w = 0 then 0 else Max {n. bit w n})\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    word_log2 w = (if w = 0 then 0 else Max {n. bit w n})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    word_log2 w = (if w = 0 then 0 else Max {n. bit w n})", "case False"], ["proof (state)\nthis:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    word_log2 w = (if w = 0 then 0 else Max {n. bit w n})", "then"], ["proof (chain)\npicking this:\n  w \\<noteq> 0", "obtain r where \\<open>bit w r\\<close>"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>r. bit w r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp add: bit_eq_iff)"], ["proof (state)\nthis:\n  bit w r\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    word_log2 w = (if w = 0 then 0 else Max {n. bit w n})", "then"], ["proof (chain)\npicking this:\n  bit w r", "have \\<open>Max {m. bit w m} = LENGTH('a) - Suc (length\n    (takeWhile (Not \\<circ> bit w) (rev [0..<LENGTH('a)])))\\<close>"], ["proof (prove)\nusing this:\n  bit w r\n\ngoal (1 subgoal):\n 1. Max {m. bit w m} =\n    LENGTH('a) -\n    Suc (length (takeWhile (Not \\<circ> bit w) (rev [0..<LENGTH('a)])))", "by (subst Max_eq_length_takeWhile [of _ \\<open>LENGTH('a)\\<close>])\n      (auto simp add: bit_imp_le_length)"], ["proof (state)\nthis:\n  Max {m. bit w m} =\n  LENGTH('a) -\n  Suc (length (takeWhile (Not \\<circ> bit w) (rev [0..<LENGTH('a)])))\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    word_log2 w = (if w = 0 then 0 else Max {n. bit w n})", "then"], ["proof (chain)\npicking this:\n  Max {m. bit w m} =\n  LENGTH('a) -\n  Suc (length (takeWhile (Not \\<circ> bit w) (rev [0..<LENGTH('a)])))", "have \\<open>word_log2 w = Max {x. bit w x}\\<close>"], ["proof (prove)\nusing this:\n  Max {m. bit w m} =\n  LENGTH('a) -\n  Suc (length (takeWhile (Not \\<circ> bit w) (rev [0..<LENGTH('a)])))\n\ngoal (1 subgoal):\n 1. word_log2 w = Max {x. bit w x}", "by (simp add: word_log2_def word_clz_def word_size to_bl_unfold rev_map takeWhile_map)"], ["proof (state)\nthis:\n  word_log2 w = Max {x. bit w x}\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow>\n    word_log2 w = (if w = 0 then 0 else Max {n. bit w n})", "with \\<open>w \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  w \\<noteq> 0\n  word_log2 w = Max {x. bit w x}", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n  word_log2 w = Max {x. bit w x}\n\ngoal (1 subgoal):\n 1. word_log2 w = (if w = 0 then 0 else Max {n. bit w n})", "by simp"], ["proof (state)\nthis:\n  word_log2 w = (if w = 0 then 0 else Max {n. bit w n})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_log2_eqI:\n  \\<open>word_log2 w = n\\<close>\n  if \\<open>w \\<noteq> 0\\<close> \\<open>bit w n\\<close> \\<open>\\<And>m. bit w m \\<Longrightarrow> m \\<le> n\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_log2 w = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. word_log2 w = n", "from \\<open>w \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  w \\<noteq> 0", "have \\<open>word_log2 w = Max {n. bit w n}\\<close>"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. word_log2 w = Max {n. bit w n}", "by (simp add: word_log2_unfold)"], ["proof (state)\nthis:\n  word_log2 w = Max {n. bit w n}\n\ngoal (1 subgoal):\n 1. word_log2 w = n", "also"], ["proof (state)\nthis:\n  word_log2 w = Max {n. bit w n}\n\ngoal (1 subgoal):\n 1. word_log2 w = n", "have \\<open>Max {n. bit w n} = n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {n. bit w n} = n", "using that"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n  bit w n\n  bit w ?m \\<Longrightarrow> ?m \\<le> n\n\ngoal (1 subgoal):\n 1. Max {n. bit w n} = n", "by (auto intro: Max_eqI)"], ["proof (state)\nthis:\n  Max {n. bit w n} = n\n\ngoal (1 subgoal):\n 1. word_log2 w = n", "finally"], ["proof (chain)\npicking this:\n  word_log2 w = n", "show ?thesis"], ["proof (prove)\nusing this:\n  word_log2 w = n\n\ngoal (1 subgoal):\n 1. word_log2 w = n", "."], ["proof (state)\nthis:\n  word_log2 w = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_word_log2:\n  \\<open>bit w (word_log2 w)\\<close> if \\<open>w \\<noteq> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit w (word_log2 w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bit w (word_log2 w)", "from \\<open>w \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  w \\<noteq> 0", "have \\<open>\\<exists>r. bit w r\\<close>"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>r. bit w r", "by (simp add: bit_eq_iff)"], ["proof (state)\nthis:\n  \\<exists>r. bit w r\n\ngoal (1 subgoal):\n 1. bit w (word_log2 w)", "then"], ["proof (chain)\npicking this:\n  \\<exists>r. bit w r", "obtain r where \\<open>bit w r\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>r. bit w r\n\ngoal (1 subgoal):\n 1. (\\<And>r. bit w r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  bit w r\n\ngoal (1 subgoal):\n 1. bit w (word_log2 w)", "from \\<open>w \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  w \\<noteq> 0", "have \\<open>word_log2 w = Max {n. bit w n}\\<close>"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. word_log2 w = Max {n. bit w n}", "by (simp add: word_log2_unfold)"], ["proof (state)\nthis:\n  word_log2 w = Max {n. bit w n}\n\ngoal (1 subgoal):\n 1. bit w (word_log2 w)", "also"], ["proof (state)\nthis:\n  word_log2 w = Max {n. bit w n}\n\ngoal (1 subgoal):\n 1. bit w (word_log2 w)", "have \\<open>Max {n. bit w n} \\<in> {n. bit w n}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {n. bit w n} \\<in> {n. bit w n}", "using \\<open>bit w r\\<close>"], ["proof (prove)\nusing this:\n  bit w r\n\ngoal (1 subgoal):\n 1. Max {n. bit w n} \\<in> {n. bit w n}", "by (subst Max_in) auto"], ["proof (state)\nthis:\n  Max {n. bit w n} \\<in> {n. bit w n}\n\ngoal (1 subgoal):\n 1. bit w (word_log2 w)", "finally"], ["proof (chain)\npicking this:\n  word_log2 w \\<in> {n. bit w n}", "show ?thesis"], ["proof (prove)\nusing this:\n  word_log2 w \\<in> {n. bit w n}\n\ngoal (1 subgoal):\n 1. bit w (word_log2 w)", "by simp"], ["proof (state)\nthis:\n  bit w (word_log2 w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_log2_maximum:\n  \\<open>n \\<le> word_log2 w\\<close> if \\<open>bit w n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> word_log2 w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<le> word_log2 w", "have \\<open>n \\<le> Max {n. bit w n}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> Max {n. bit w n}", "using that"], ["proof (prove)\nusing this:\n  bit w n\n\ngoal (1 subgoal):\n 1. n \\<le> Max {n. bit w n}", "by (auto intro: Max_ge)"], ["proof (state)\nthis:\n  n \\<le> Max {n. bit w n}\n\ngoal (1 subgoal):\n 1. n \\<le> word_log2 w", "also"], ["proof (state)\nthis:\n  n \\<le> Max {n. bit w n}\n\ngoal (1 subgoal):\n 1. n \\<le> word_log2 w", "from that"], ["proof (chain)\npicking this:\n  bit w n", "have \\<open>w \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  bit w n\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<le> word_log2 w", "then"], ["proof (chain)\npicking this:\n  w \\<noteq> 0", "have \\<open>Max {n. bit w n} = word_log2 w\\<close>"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Max {n. bit w n} = word_log2 w", "by (simp add: word_log2_unfold)"], ["proof (state)\nthis:\n  Max {n. bit w n} = word_log2 w\n\ngoal (1 subgoal):\n 1. n \\<le> word_log2 w", "finally"], ["proof (chain)\npicking this:\n  n \\<le> word_log2 w", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> word_log2 w\n\ngoal (1 subgoal):\n 1. n \\<le> word_log2 w", "."], ["proof (state)\nthis:\n  n \\<le> word_log2 w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_log2_nth_same:\n  \"w \\<noteq> 0 \\<Longrightarrow> w !! word_log2 w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> w !! word_log2 w", "by (drule bit_word_log2) (simp add: test_bit_eq_bit)"], ["", "lemma word_log2_nth_not_set:\n  \"\\<lbrakk> word_log2 w < i ; i < size w \\<rbrakk> \\<Longrightarrow> \\<not> w !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>word_log2 w < i; i < size w\\<rbrakk>\n    \\<Longrightarrow> \\<not> w !! i", "using word_log2_maximum [of w i]"], ["proof (prove)\nusing this:\n  bit w i \\<Longrightarrow> i \\<le> word_log2 w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>word_log2 w < i; i < size w\\<rbrakk>\n    \\<Longrightarrow> \\<not> w !! i", "by (auto simp add: test_bit_eq_bit)"], ["", "lemma word_log2_highest:\n  assumes a: \"w !! i\"\n  shows \"i \\<le> word_log2 w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> word_log2 w", "using a"], ["proof (prove)\nusing this:\n  w !! i\n\ngoal (1 subgoal):\n 1. i \\<le> word_log2 w", "by (simp add: test_bit_eq_bit word_log2_maximum)"], ["", "lemma word_log2_max:\n  \"word_log2 w < size w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_log2 w < size w", "apply (cases \\<open>w = 0\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow> word_log2 w < size w\n 2. w \\<noteq> 0 \\<Longrightarrow> word_log2 w < size w", "apply (simp_all add: word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> word_log2 w < LENGTH('a)", "apply (drule bit_word_log2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit w (word_log2 w) \\<Longrightarrow> word_log2 w < LENGTH('a)", "apply (fact bit_imp_le_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_clz_0[simp]:\n  \"word_clz (0::'a::len word) = LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_clz 0 = LENGTH('a)", "unfolding word_clz_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (takeWhile Not (to_bl 0)) = LENGTH('a)", "by simp"], ["", "lemma word_clz_minus_one[simp]:\n  \"word_clz (-1::'a::len word) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_clz (- 1) = 0", "unfolding word_clz_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (takeWhile Not (to_bl (- 1))) = 0", "by simp"], ["", "lemma is_aligned_alignUp[simp]:\n  \"is_aligned (alignUp p n) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned (alignUp p n) n", "by (simp add: alignUp_def is_aligned_mask mask_eq_decr_exp word_bw_assocs)"], ["", "lemma alignUp_le[simp]:\n  \"alignUp p n \\<le> p + 2 ^ n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp p n \\<le> p + 2 ^ n - 1", "unfolding alignUp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p + 2 ^ n - 1 AND NOT (2 ^ n - 1) \\<le> p + 2 ^ n - 1", "by (rule word_and_le2)"], ["", "lemma alignUp_idem:\n  fixes a :: \"'a::len word\"\n  assumes \"is_aligned a n\" \"n < LENGTH('a)\"\n  shows \"alignUp a n = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp a n = a", "using assms"], ["proof (prove)\nusing this:\n  is_aligned a n\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. alignUp a n = a", "unfolding alignUp_def"], ["proof (prove)\nusing this:\n  is_aligned a n\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. a + 2 ^ n - 1 AND NOT (2 ^ n - 1) = a", "by (metis add_cancel_right_right add_diff_eq and_mask_eq_iff_le_mask mask_eq_decr_exp mask_out_add_aligned order_refl word_plus_and_or_coroll2)"], ["", "lemma alignUp_not_aligned_eq:\n  fixes a :: \"'a :: len word\"\n  assumes al: \"\\<not> is_aligned a n\"\n  and     sz: \"n < LENGTH('a)\"\n  shows   \"alignUp a n = (a div 2 ^ n + 1) * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp a n = (a div 2 ^ n + 1) * 2 ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. alignUp a n = (a div 2 ^ n + 1) * 2 ^ n", "have anz: \"a mod 2 ^ n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod 2 ^ n \\<noteq> 0", "by (rule not_aligned_mod_nz) fact+"], ["proof (state)\nthis:\n  a mod 2 ^ n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. alignUp a n = (a div 2 ^ n + 1) * 2 ^ n", "then"], ["proof (chain)\npicking this:\n  a mod 2 ^ n \\<noteq> 0", "have um: \"unat (a mod 2 ^ n - 1) div 2 ^ n = 0\""], ["proof (prove)\nusing this:\n  a mod 2 ^ n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. unat (a mod 2 ^ n - 1) div 2 ^ n = 0", "using sz"], ["proof (prove)\nusing this:\n  a mod 2 ^ n \\<noteq> 0\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (a mod 2 ^ n - 1) div 2 ^ n = 0", "by (meson Euclidean_Division.div_eq_0_iff le_m1_iff_lt measure_unat order_less_trans\n              unat_less_power word_less_sub_le word_mod_less_divisor)"], ["proof (state)\nthis:\n  unat (a mod 2 ^ n - 1) div 2 ^ n = 0\n\ngoal (1 subgoal):\n 1. alignUp a n = (a div 2 ^ n + 1) * 2 ^ n", "have \"a + 2 ^ n - 1 = (a div 2 ^ n) * 2 ^ n + (a mod 2 ^ n) + 2 ^ n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 2 ^ n - 1 = a div 2 ^ n * 2 ^ n + a mod 2 ^ n + 2 ^ n - 1", "by (simp add: word_mod_div_equality)"], ["proof (state)\nthis:\n  a + 2 ^ n - 1 = a div 2 ^ n * 2 ^ n + a mod 2 ^ n + 2 ^ n - 1\n\ngoal (1 subgoal):\n 1. alignUp a n = (a div 2 ^ n + 1) * 2 ^ n", "also"], ["proof (state)\nthis:\n  a + 2 ^ n - 1 = a div 2 ^ n * 2 ^ n + a mod 2 ^ n + 2 ^ n - 1\n\ngoal (1 subgoal):\n 1. alignUp a n = (a div 2 ^ n + 1) * 2 ^ n", "have \"\\<dots> = (a mod 2 ^ n - 1) + (a div 2 ^ n + 1) * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a div 2 ^ n * 2 ^ n + a mod 2 ^ n + 2 ^ n - 1 =\n    a mod 2 ^ n - 1 + (a div 2 ^ n + 1) * 2 ^ n", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  a div 2 ^ n * 2 ^ n + a mod 2 ^ n + 2 ^ n - 1 =\n  a mod 2 ^ n - 1 + (a div 2 ^ n + 1) * 2 ^ n\n\ngoal (1 subgoal):\n 1. alignUp a n = (a div 2 ^ n + 1) * 2 ^ n", "finally"], ["proof (chain)\npicking this:\n  a + 2 ^ n - 1 = a mod 2 ^ n - 1 + (a div 2 ^ n + 1) * 2 ^ n", "show \"alignUp a n = (a div 2 ^ n + 1) * 2 ^ n\""], ["proof (prove)\nusing this:\n  a + 2 ^ n - 1 = a mod 2 ^ n - 1 + (a div 2 ^ n + 1) * 2 ^ n\n\ngoal (1 subgoal):\n 1. alignUp a n = (a div 2 ^ n + 1) * 2 ^ n", "using sz"], ["proof (prove)\nusing this:\n  a + 2 ^ n - 1 = a mod 2 ^ n - 1 + (a div 2 ^ n + 1) * 2 ^ n\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. alignUp a n = (a div 2 ^ n + 1) * 2 ^ n", "unfolding alignUp_def"], ["proof (prove)\nusing this:\n  a + 2 ^ n - 1 = a mod 2 ^ n - 1 + (a div 2 ^ n + 1) * 2 ^ n\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. a + 2 ^ n - 1 AND NOT (2 ^ n - 1) = (a div 2 ^ n + 1) * 2 ^ n", "apply (subst mask_eq_decr_exp [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a + 2 ^ n - 1 = a mod 2 ^ n - 1 + (a div 2 ^ n + 1) * 2 ^ n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> a + 2 ^ n - 1 AND NOT (mask n) =\n                      (a div 2 ^ n + 1) * 2 ^ n", "apply (erule ssubst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    a mod 2 ^ n - 1 + (a div 2 ^ n + 1) * 2 ^ n AND NOT (mask n) =\n    (a div 2 ^ n + 1) * 2 ^ n", "apply (subst neg_mask_is_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    (a mod 2 ^ n - 1 + (a div 2 ^ n + 1) * 2 ^ n) div 2 ^ n * 2 ^ n =\n    (a div 2 ^ n + 1) * 2 ^ n", "apply (simp add: word_arith_nat_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     (unat\n       (a mod 2 ^ n - 1 + (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n) div\n      2 ^ n) *\n    2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply (subst unat_word_ariths(1) unat_word_ariths(2))+"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     ((unat (a mod 2 ^ n - 1) +\n       (unat (word_of_nat (unat a div 2 ^ n)) + unat 1) mod 2 ^ LENGTH('a) *\n       unat (2 ^ n) mod\n       2 ^ LENGTH('a)) mod\n      2 ^ LENGTH('a) div\n      2 ^ n) *\n    2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply (subst uno_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     ((unat (a mod 2 ^ n - 1) +\n       (unat a div 2 ^ n + unat 1) mod 2 ^ LENGTH('a) * unat (2 ^ n) mod\n       2 ^ LENGTH('a)) mod\n      2 ^ LENGTH('a) div\n      2 ^ n) *\n    2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply (subst unat_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     ((unat (a mod 2 ^ n - 1) +\n       (unat a div 2 ^ n + 1) mod 2 ^ LENGTH('a) * unat (2 ^ n) mod\n       2 ^ LENGTH('a)) mod\n      2 ^ LENGTH('a) div\n      2 ^ n) *\n    2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply (subst mod_add_right_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     ((unat (a mod 2 ^ n - 1) +\n       (unat a div 2 ^ n + 1) mod 2 ^ LENGTH('a) * unat (2 ^ n)) mod\n      2 ^ LENGTH('a) div\n      2 ^ n) *\n    2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     ((unat (a mod 2 ^ n - 1) +\n       Suc (unat a div 2 ^ n) mod 2 ^ LENGTH('a) * 2 ^ n) mod\n      2 ^ LENGTH('a) div\n      2 ^ n) *\n    2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply (subst power_mod_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     ((unat (a mod 2 ^ n - 1) +\n       Suc (unat a div 2 ^ n) mod 2 ^ LENGTH('a) * 2 ^ n) div\n      2 ^ n mod\n      2 ^ (LENGTH('a) - n)) *\n    2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply (subst div_mult_self1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < LENGTH('a) \\<Longrightarrow> 2 ^ n \\<noteq> 0\n 2. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     ((Suc (unat a div 2 ^ n) mod 2 ^ LENGTH('a) +\n       unat (a mod 2 ^ n - 1) div 2 ^ n) mod\n      2 ^ (LENGTH('a) - n)) *\n    2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     ((Suc (unat a div 2 ^ n) mod 2 ^ LENGTH('a) +\n       unat (a mod 2 ^ n - 1) div 2 ^ n) mod\n      2 ^ (LENGTH('a) - n)) *\n    2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply (subst um)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     ((Suc (unat a div 2 ^ n) mod 2 ^ LENGTH('a) + 0) mod\n      2 ^ (LENGTH('a) - n)) *\n    2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     (Suc (unat a div 2 ^ n) mod 2 ^ LENGTH('a) mod 2 ^ (LENGTH('a) - n)) *\n    2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply (subst mod_mod_power)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     (Suc (unat a div 2 ^ n) mod 2 ^ min LENGTH('a) (LENGTH('a) - n)) *\n    2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat (Suc (unat a div 2 ^ n) mod 2 ^ (LENGTH('a) - n)) * 2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply (subst word_unat_power, subst Abs_fnat_hom_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat (Suc (unat a div 2 ^ n) mod 2 ^ (LENGTH('a) - n) * 2 ^ n) =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply (subst mult_mod_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     (Suc (unat a div 2 ^ n) * 2 ^ n mod (2 ^ (LENGTH('a) - n) * 2 ^ n)) =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply (subst power_add [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    word_of_nat\n     (Suc (unat a div 2 ^ n) * 2 ^ n mod 2 ^ (LENGTH('a) - n + n)) =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    2 ^ n + word_of_nat (unat a div 2 ^ n) * 2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + 1) * 2 ^ n", "apply (subst Abs_fnat_hom_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    2 ^ n + word_of_nat (unat a div 2 ^ n) * 2 ^ n =\n    (word_of_nat (unat a div 2 ^ n) + word_of_nat (Suc 0)) * 2 ^ n", "apply (subst Abs_fnat_hom_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    2 ^ n + word_of_nat (unat a div 2 ^ n) * 2 ^ n =\n    word_of_nat (unat a div 2 ^ n + Suc 0) * 2 ^ n", "apply (subst word_unat_power, subst Abs_fnat_hom_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    2 ^ n + word_of_nat (unat a div 2 ^ n * 2 ^ n) =\n    word_of_nat (unat a div 2 ^ n + Suc 0) * 2 ^ n", "apply (subst word_unat.Rep_inverse[symmetric], subst Abs_fnat_hom_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a) \\<Longrightarrow>\n    2 ^ n + word_of_nat (unat a div 2 ^ n * 2 ^ n) =\n    word_of_nat ((unat a div 2 ^ n + Suc 0) * unat (2 ^ n))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  alignUp a n = (a div 2 ^ n + 1) * 2 ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alignUp_ge:\n  fixes a :: \"'a :: len word\"\n  assumes sz: \"n < LENGTH('a)\"\n  and nowrap: \"alignUp a n \\<noteq> 0\"\n  shows \"a \\<le> alignUp a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> alignUp a n", "proof (cases \"is_aligned a n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n\n 2. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "case True"], ["proof (state)\nthis:\n  is_aligned a n\n\ngoal (2 subgoals):\n 1. is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n\n 2. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "then"], ["proof (chain)\npicking this:\n  is_aligned a n", "show ?thesis"], ["proof (prove)\nusing this:\n  is_aligned a n\n\ngoal (1 subgoal):\n 1. a \\<le> alignUp a n", "using sz"], ["proof (prove)\nusing this:\n  is_aligned a n\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. a \\<le> alignUp a n", "by (subst alignUp_idem, simp_all)"], ["proof (state)\nthis:\n  a \\<le> alignUp a n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "case False"], ["proof (state)\nthis:\n  \\<not> is_aligned a n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "have lt0: \"unat a div 2 ^ n < 2 ^ (LENGTH('a) - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat a div 2 ^ n < 2 ^ (LENGTH('a) - n)", "using sz"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat a div 2 ^ n < 2 ^ (LENGTH('a) - n)", "by (metis shiftr_div_2n' word_shiftr_lt)"], ["proof (state)\nthis:\n  unat a div 2 ^ n < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "have\"2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)", "using sz"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)", "by (metis One_nat_def Suc_leI add.right_neutral add_Suc_right lt0 nat_le_power_trans nat_less_le)"], ["proof (state)\nthis:\n  2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "moreover"], ["proof (state)\nthis:\n  2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "have \"2 ^ n * (unat a div 2 ^ n + 1) \\<noteq> 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ n * (unat a div 2 ^ n + 1) \\<noteq> 2 ^ LENGTH('a)", "using nowrap sz"], ["proof (prove)\nusing this:\n  alignUp a n \\<noteq> 0\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ n * (unat a div 2 ^ n + 1) \\<noteq> 2 ^ LENGTH('a)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alignUp a n \\<noteq> 0; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n * (unat a div 2 ^ n + 1) \\<noteq> 2 ^ LENGTH('a)", "apply (erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a);\n     2 ^ n * (unat a div 2 ^ n + 1) = 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> alignUp a n = 0", "apply (subst alignUp_not_aligned_eq [OF False sz])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a);\n     2 ^ n * (unat a div 2 ^ n + 1) = 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (a div 2 ^ n + 1) * 2 ^ n = 0", "apply (subst unat_arith_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a);\n     2 ^ n * (unat a div 2 ^ n + 1) = 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat ((a div 2 ^ n + 1) * 2 ^ n) = unat 0", "apply (subst unat_word_ariths)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a);\n     2 ^ n * (unat a div 2 ^ n + 1) = 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (a div 2 ^ n + 1) * unat (2 ^ n) mod\n                      2 ^ LENGTH('a) =\n                      unat 0", "apply (subst unat_word_ariths)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a);\n     2 ^ n * (unat a div 2 ^ n + 1) = 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (unat (a div 2 ^ n) + unat 1) mod 2 ^ LENGTH('a) *\n                      unat (2 ^ n) mod\n                      2 ^ LENGTH('a) =\n                      unat 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a);\n     2 ^ n + 2 ^ n * (unat a div 2 ^ n) = 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> Suc (unat (a div 2 ^ n)) mod 2 ^ LENGTH('a) *\n                      2 ^ n mod\n                      2 ^ LENGTH('a) =\n                      0", "apply (subst mult_mod_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a);\n     2 ^ n + 2 ^ n * (unat a div 2 ^ n) = 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> Suc (unat (a div 2 ^ n)) * 2 ^ n mod\n                      (2 ^ LENGTH('a) * 2 ^ n) mod\n                      2 ^ LENGTH('a) =\n                      0", "apply (simp add: unat_div field_simps power_add[symmetric] mod_mod_power)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ n * (unat a div 2 ^ n + 1) \\<noteq> 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "ultimately"], ["proof (chain)\npicking this:\n  2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)\n  2 ^ n * (unat a div 2 ^ n + 1) \\<noteq> 2 ^ LENGTH('a)", "have lt: \"2 ^ n * (unat a div 2 ^ n + 1) < 2 ^ LENGTH('a)\""], ["proof (prove)\nusing this:\n  2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)\n  2 ^ n * (unat a div 2 ^ n + 1) \\<noteq> 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ n * (unat a div 2 ^ n + 1) < 2 ^ LENGTH('a)", "by simp"], ["proof (state)\nthis:\n  2 ^ n * (unat a div 2 ^ n + 1) < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "have \"a = a div 2 ^ n * 2 ^ n + a mod 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a div 2 ^ n * 2 ^ n + a mod 2 ^ n", "by (rule word_mod_div_equality [symmetric])"], ["proof (state)\nthis:\n  a = a div 2 ^ n * 2 ^ n + a mod 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "also"], ["proof (state)\nthis:\n  a = a div 2 ^ n * 2 ^ n + a mod 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "have \"\\<dots> < (a div 2 ^ n + 1) * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a div 2 ^ n * 2 ^ n + a mod 2 ^ n < (a div 2 ^ n + 1) * 2 ^ n", "using sz lt"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n  2 ^ n * (unat a div 2 ^ n + 1) < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. a div 2 ^ n * 2 ^ n + a mod 2 ^ n < (a div 2 ^ n + 1) * 2 ^ n", "apply (simp add: field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a);\n     2 ^ n + 2 ^ n * (unat a div 2 ^ n) < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> a mod 2 ^ n + 2 ^ n * (a div 2 ^ n)\n                      < 2 ^ n + 2 ^ n * (a div 2 ^ n)", "apply (rule word_add_less_mono1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < LENGTH('a);\n     2 ^ n + 2 ^ n * (unat a div 2 ^ n) < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> a mod 2 ^ n < 2 ^ n\n 2. \\<lbrakk>n < LENGTH('a);\n     2 ^ n + 2 ^ n * (unat a div 2 ^ n) < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ n) + unat (2 ^ n * (a div 2 ^ n))\n                      < 2 ^ LENGTH('a)", "apply (rule word_mod_less_divisor)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < LENGTH('a);\n     2 ^ n + 2 ^ n * (unat a div 2 ^ n) < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ n\n 2. \\<lbrakk>n < LENGTH('a);\n     2 ^ n + 2 ^ n * (unat a div 2 ^ n) < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ n) + unat (2 ^ n * (a div 2 ^ n))\n                      < 2 ^ LENGTH('a)", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a);\n     2 ^ n + 2 ^ n * (unat a div 2 ^ n) < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ n) + unat (2 ^ n * (a div 2 ^ n))\n                      < 2 ^ LENGTH('a)", "apply (subst unat_word_ariths)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < LENGTH('a);\n     2 ^ n + 2 ^ n * (unat a div 2 ^ n) < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ n) +\n                      unat (2 ^ n) * unat (a div 2 ^ n) mod 2 ^ LENGTH('a)\n                      < 2 ^ LENGTH('a)", "apply (simp add: unat_div)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a div 2 ^ n * 2 ^ n + a mod 2 ^ n < (a div 2 ^ n + 1) * 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "also"], ["proof (state)\nthis:\n  a div 2 ^ n * 2 ^ n + a mod 2 ^ n < (a div 2 ^ n + 1) * 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "have \"\\<dots> =  alignUp a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a div 2 ^ n + 1) * 2 ^ n = alignUp a n", "by (rule alignUp_not_aligned_eq [symmetric]) fact+"], ["proof (state)\nthis:\n  (a div 2 ^ n + 1) * 2 ^ n = alignUp a n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> a \\<le> alignUp a n", "finally"], ["proof (chain)\npicking this:\n  a < alignUp a n", "show ?thesis"], ["proof (prove)\nusing this:\n  a < alignUp a n\n\ngoal (1 subgoal):\n 1. a \\<le> alignUp a n", "by (rule order_less_imp_le)"], ["proof (state)\nthis:\n  a \\<le> alignUp a n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alignUp_le_greater_al:\n  fixes x :: \"'a :: len word\"\n  assumes le: \"a \\<le> x\"\n  and     sz: \"n < LENGTH('a)\"\n  and     al: \"is_aligned x n\"\n  shows   \"alignUp a n \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp a n \\<le> x", "proof (cases \"is_aligned a n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x\n 2. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x", "case True"], ["proof (state)\nthis:\n  is_aligned a n\n\ngoal (2 subgoals):\n 1. is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x\n 2. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x", "then"], ["proof (chain)\npicking this:\n  is_aligned a n", "show ?thesis"], ["proof (prove)\nusing this:\n  is_aligned a n\n\ngoal (1 subgoal):\n 1. alignUp a n \\<le> x", "using sz le"], ["proof (prove)\nusing this:\n  is_aligned a n\n  n < LENGTH('a)\n  a \\<le> x\n\ngoal (1 subgoal):\n 1. alignUp a n \\<le> x", "by (simp add: alignUp_idem)"], ["proof (state)\nthis:\n  alignUp a n \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x", "case False"], ["proof (state)\nthis:\n  \\<not> is_aligned a n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x", "then"], ["proof (chain)\npicking this:\n  \\<not> is_aligned a n", "have anz: \"a mod 2 ^ n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> is_aligned a n\n\ngoal (1 subgoal):\n 1. a mod 2 ^ n \\<noteq> 0", "by (rule not_aligned_mod_nz)"], ["proof (state)\nthis:\n  a mod 2 ^ n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x", "from al"], ["proof (chain)\npicking this:\n  is_aligned x n", "obtain k where xk: \"x = 2 ^ n * of_nat k\" and kv: \"k < 2 ^ (LENGTH('a) - n)\""], ["proof (prove)\nusing this:\n  is_aligned x n\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>x = 2 ^ n * word_of_nat k;\n         k < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: is_alignedE)"], ["proof (state)\nthis:\n  x = 2 ^ n * word_of_nat k\n  k < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x", "then"], ["proof (chain)\npicking this:\n  x = 2 ^ n * word_of_nat k\n  k < 2 ^ (LENGTH('a) - n)", "have kn: \"unat (of_nat k :: 'a word) * unat ((2::'a word) ^ n) < 2 ^ LENGTH('a)\""], ["proof (prove)\nusing this:\n  x = 2 ^ n * word_of_nat k\n  k < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. unat (word_of_nat k) * unat (2 ^ n) < 2 ^ LENGTH('a)", "using sz"], ["proof (prove)\nusing this:\n  x = 2 ^ n * word_of_nat k\n  k < 2 ^ (LENGTH('a) - n)\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (word_of_nat k) * unat (2 ^ n) < 2 ^ LENGTH('a)", "apply (subst unat_of_nat_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k < 2 ^ LENGTH('a)\n 2. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k * unat (2 ^ n) < 2 ^ LENGTH('a)", "apply (erule order_less_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (LENGTH('a) - n) \\<le> 2 ^ LENGTH('a)\n 2. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k * unat (2 ^ n) < 2 ^ LENGTH('a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k * unat (2 ^ n) < 2 ^ LENGTH('a)", "apply (subst mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ n) * k < 2 ^ LENGTH('a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n * k < 2 ^ LENGTH('a)", "apply (rule nat_less_power_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> k < 2 ^ (LENGTH('a) - n)\n 2. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> n \\<le> LENGTH('a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 2 ^ n * word_of_nat k; k < 2 ^ (LENGTH('a) - n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> n \\<le> LENGTH('a)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unat (word_of_nat k) * unat (2 ^ n) < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x", "have au: \"alignUp a n = (a div 2 ^ n + 1) * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp a n = (a div 2 ^ n + 1) * 2 ^ n", "by (rule alignUp_not_aligned_eq) fact+"], ["proof (state)\nthis:\n  alignUp a n = (a div 2 ^ n + 1) * 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x", "also"], ["proof (state)\nthis:\n  alignUp a n = (a div 2 ^ n + 1) * 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x", "have \"\\<dots> \\<le> of_nat k * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a div 2 ^ n + 1) * 2 ^ n \\<le> word_of_nat k * 2 ^ n", "proof (rule word_mult_le_mono1 [OF inc_le _ kn])"], ["proof (state)\ngoal (2 subgoals):\n 1. a div 2 ^ n < word_of_nat k\n 2. 0 < 2 ^ n", "show \"a div 2 ^ n < of_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "using kv xk le sz anz"], ["proof (prove)\nusing this:\n  k < 2 ^ (LENGTH('a) - n)\n  x = 2 ^ n * word_of_nat k\n  a \\<le> x\n  n < LENGTH('a)\n  a mod 2 ^ n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "by (simp add: alignUp_div_helper)"], ["proof (state)\nthis:\n  a div 2 ^ n < word_of_nat k\n\ngoal (1 subgoal):\n 1. 0 < 2 ^ n", "show \"(0:: 'a word) < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 2 ^ n", "using sz"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. 0 < 2 ^ n", "by (simp add: p2_gt_0 sz)"], ["proof (state)\nthis:\n  0 < 2 ^ n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a div 2 ^ n + 1) * 2 ^ n \\<le> word_of_nat k * 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<le> x", "finally"], ["proof (chain)\npicking this:\n  alignUp a n \\<le> word_of_nat k * 2 ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  alignUp a n \\<le> word_of_nat k * 2 ^ n\n\ngoal (1 subgoal):\n 1. alignUp a n \\<le> x", "using xk"], ["proof (prove)\nusing this:\n  alignUp a n \\<le> word_of_nat k * 2 ^ n\n  x = 2 ^ n * word_of_nat k\n\ngoal (1 subgoal):\n 1. alignUp a n \\<le> x", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  alignUp a n \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alignUp_is_aligned_nz:\n  fixes a :: \"'a :: len word\"\n  assumes al: \"is_aligned x n\"\n  and     sz: \"n < LENGTH('a)\"\n  and     ax: \"a \\<le> x\"\n  and     az: \"a \\<noteq> 0\"\n  shows   \"alignUp (a::'a :: len word) n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp a n \\<noteq> 0", "proof (cases \"is_aligned a n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0\n 2. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "case True"], ["proof (state)\nthis:\n  is_aligned a n\n\ngoal (2 subgoals):\n 1. is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0\n 2. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  is_aligned a n", "have \"alignUp a n = a\""], ["proof (prove)\nusing this:\n  is_aligned a n\n\ngoal (1 subgoal):\n 1. alignUp a n = a", "using sz"], ["proof (prove)\nusing this:\n  is_aligned a n\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. alignUp a n = a", "by (simp add: alignUp_idem)"], ["proof (state)\nthis:\n  alignUp a n = a\n\ngoal (2 subgoals):\n 1. is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0\n 2. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  alignUp a n = a", "show ?thesis"], ["proof (prove)\nusing this:\n  alignUp a n = a\n\ngoal (1 subgoal):\n 1. alignUp a n \\<noteq> 0", "using az"], ["proof (prove)\nusing this:\n  alignUp a n = a\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. alignUp a n \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  alignUp a n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "case False"], ["proof (state)\nthis:\n  \\<not> is_aligned a n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<not> is_aligned a n", "have anz: \"a mod 2 ^ n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> is_aligned a n\n\ngoal (1 subgoal):\n 1. a mod 2 ^ n \\<noteq> 0", "by (rule not_aligned_mod_nz)"], ["proof (state)\nthis:\n  a mod 2 ^ n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "{"], ["proof (state)\nthis:\n  a mod 2 ^ n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "assume asm: \"alignUp a n = 0\""], ["proof (state)\nthis:\n  alignUp a n = 0\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "have lt0: \"unat a div 2 ^ n < 2 ^ (LENGTH('a) - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat a div 2 ^ n < 2 ^ (LENGTH('a) - n)", "using sz"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat a div 2 ^ n < 2 ^ (LENGTH('a) - n)", "by (metis shiftr_div_2n' word_shiftr_lt)"], ["proof (state)\nthis:\n  unat a div 2 ^ n < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "have leq: \"2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)", "using sz"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)", "by (metis One_nat_def Suc_leI add.right_neutral add_Suc_right lt0 nat_le_power_trans\n                order_less_imp_le)"], ["proof (state)\nthis:\n  2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "from al"], ["proof (chain)\npicking this:\n  is_aligned x n", "obtain k where  kv: \"k < 2 ^ (LENGTH('a) - n)\" and xk: \"x = 2 ^ n * of_nat k\""], ["proof (prove)\nusing this:\n  is_aligned x n\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < 2 ^ (LENGTH('a) - n);\n         x = 2 ^ n * word_of_nat k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: is_alignedE)"], ["proof (state)\nthis:\n  k < 2 ^ (LENGTH('a) - n)\n  x = 2 ^ n * word_of_nat k\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  k < 2 ^ (LENGTH('a) - n)\n  x = 2 ^ n * word_of_nat k", "have \"a div 2 ^ n < of_nat k\""], ["proof (prove)\nusing this:\n  k < 2 ^ (LENGTH('a) - n)\n  x = 2 ^ n * word_of_nat k\n\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "using ax sz anz"], ["proof (prove)\nusing this:\n  k < 2 ^ (LENGTH('a) - n)\n  x = 2 ^ n * word_of_nat k\n  a \\<le> x\n  n < LENGTH('a)\n  a mod 2 ^ n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a div 2 ^ n < word_of_nat k", "by (rule alignUp_div_helper)"], ["proof (state)\nthis:\n  a div 2 ^ n < word_of_nat k\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  a div 2 ^ n < word_of_nat k", "have r: \"unat a div 2 ^ n < k\""], ["proof (prove)\nusing this:\n  a div 2 ^ n < word_of_nat k\n\ngoal (1 subgoal):\n 1. unat a div 2 ^ n < k", "using sz"], ["proof (prove)\nusing this:\n  a div 2 ^ n < word_of_nat k\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat a div 2 ^ n < k", "by (simp flip: drop_bit_eq_div unat_drop_bit_eq) (metis leI le_unat_uoi unat_mono)"], ["proof (state)\nthis:\n  unat a div 2 ^ n < k\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "have \"alignUp a n = (a div 2 ^ n + 1) * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp a n = (a div 2 ^ n + 1) * 2 ^ n", "by (rule alignUp_not_aligned_eq) fact+"], ["proof (state)\nthis:\n  alignUp a n = (a div 2 ^ n + 1) * 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  alignUp a n = (a div 2 ^ n + 1) * 2 ^ n", "have \"\\<dots> = 0\""], ["proof (prove)\nusing this:\n  alignUp a n = (a div 2 ^ n + 1) * 2 ^ n\n\ngoal (1 subgoal):\n 1. (a div 2 ^ n + 1) * 2 ^ n = 0", "using asm"], ["proof (prove)\nusing this:\n  alignUp a n = (a div 2 ^ n + 1) * 2 ^ n\n  alignUp a n = 0\n\ngoal (1 subgoal):\n 1. (a div 2 ^ n + 1) * 2 ^ n = 0", "by simp"], ["proof (state)\nthis:\n  (a div 2 ^ n + 1) * 2 ^ n = 0\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  (a div 2 ^ n + 1) * 2 ^ n = 0", "have \"2 ^ LENGTH('a) dvd 2 ^ n * (unat a div 2 ^ n + 1)\""], ["proof (prove)\nusing this:\n  (a div 2 ^ n + 1) * 2 ^ n = 0\n\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('a) dvd 2 ^ n * (unat a div 2 ^ n + 1)", "using sz"], ["proof (prove)\nusing this:\n  (a div 2 ^ n + 1) * 2 ^ n = 0\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('a) dvd 2 ^ n * (unat a div 2 ^ n + 1)", "by (simp add: unat_arith_simps ac_simps)\n                  (simp add: unat_word_ariths mod_simps mod_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  2 ^ LENGTH('a) dvd 2 ^ n * (unat a div 2 ^ n + 1)\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "with leq"], ["proof (chain)\npicking this:\n  2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)\n  2 ^ LENGTH('a) dvd 2 ^ n * (unat a div 2 ^ n + 1)", "have \"2 ^ n * (unat a div 2 ^ n + 1) = 2 ^ LENGTH('a)\""], ["proof (prove)\nusing this:\n  2 ^ n * (unat a div 2 ^ n + 1) \\<le> 2 ^ LENGTH('a)\n  2 ^ LENGTH('a) dvd 2 ^ n * (unat a div 2 ^ n + 1)\n\ngoal (1 subgoal):\n 1. 2 ^ n * (unat a div 2 ^ n + 1) = 2 ^ LENGTH('a)", "by (force elim!: le_SucE)"], ["proof (state)\nthis:\n  2 ^ n * (unat a div 2 ^ n + 1) = 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  2 ^ n * (unat a div 2 ^ n + 1) = 2 ^ LENGTH('a)", "have \"unat a div 2 ^ n = 2 ^ LENGTH('a) div 2 ^ n - 1\""], ["proof (prove)\nusing this:\n  2 ^ n * (unat a div 2 ^ n + 1) = 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat a div 2 ^ n = 2 ^ LENGTH('a) div 2 ^ n - 1", "by (metis (no_types, hide_lams) Groups.add_ac(2) add.right_neutral\n                add_diff_cancel_left' div_le_dividend div_mult_self4 gr_implies_not0\n                le_neq_implies_less power_eq_0_iff zero_neq_numeral)"], ["proof (state)\nthis:\n  unat a div 2 ^ n = 2 ^ LENGTH('a) div 2 ^ n - 1\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  unat a div 2 ^ n = 2 ^ LENGTH('a) div 2 ^ n - 1", "have \"unat a div 2 ^ n = 2 ^ (LENGTH('a) - n) - 1\""], ["proof (prove)\nusing this:\n  unat a div 2 ^ n = 2 ^ LENGTH('a) div 2 ^ n - 1\n\ngoal (1 subgoal):\n 1. unat a div 2 ^ n = 2 ^ (LENGTH('a) - n) - 1", "using sz"], ["proof (prove)\nusing this:\n  unat a div 2 ^ n = 2 ^ LENGTH('a) div 2 ^ n - 1\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat a div 2 ^ n = 2 ^ (LENGTH('a) - n) - 1", "by (simp add: power_sub)"], ["proof (state)\nthis:\n  unat a div 2 ^ n = 2 ^ (LENGTH('a) - n) - 1\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  unat a div 2 ^ n = 2 ^ (LENGTH('a) - n) - 1", "have \"2 ^ (LENGTH('a) - n) - 1 < k\""], ["proof (prove)\nusing this:\n  unat a div 2 ^ n = 2 ^ (LENGTH('a) - n) - 1\n\ngoal (1 subgoal):\n 1. 2 ^ (LENGTH('a) - n) - 1 < k", "using r"], ["proof (prove)\nusing this:\n  unat a div 2 ^ n = 2 ^ (LENGTH('a) - n) - 1\n  unat a div 2 ^ n < k\n\ngoal (1 subgoal):\n 1. 2 ^ (LENGTH('a) - n) - 1 < k", "by simp"], ["proof (state)\nthis:\n  2 ^ (LENGTH('a) - n) - 1 < k\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  2 ^ (LENGTH('a) - n) - 1 < k", "have False"], ["proof (prove)\nusing this:\n  2 ^ (LENGTH('a) - n) - 1 < k\n\ngoal (1 subgoal):\n 1. False", "using kv"], ["proof (prove)\nusing this:\n  2 ^ (LENGTH('a) - n) - 1 < k\n  k < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "}"], ["proof (state)\nthis:\n  alignUp a n = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> is_aligned a n \\<Longrightarrow> alignUp a n \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  alignUp a n = 0 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  alignUp a n = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. alignUp a n \\<noteq> 0", "by clarsimp"], ["proof (state)\nthis:\n  alignUp a n \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alignUp_ar_helper:\n  fixes a :: \"'a :: len word\"\n  assumes al: \"is_aligned x n\"\n  and     sz: \"n < LENGTH('a)\"\n  and    sub: \"{x..x + 2 ^ n - 1} \\<subseteq> {a..b}\"\n  and    anz: \"a \\<noteq> 0\"\n  shows \"a \\<le> alignUp a n \\<and> alignUp a n + 2 ^ n - 1 \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> alignUp a n \\<and> alignUp a n + 2 ^ n - 1 \\<le> b", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<le> alignUp a n\n 2. alignUp a n + 2 ^ n - 1 \\<le> b", "from al"], ["proof (chain)\npicking this:\n  is_aligned x n", "have xl: \"x \\<le> x + 2 ^ n - 1\""], ["proof (prove)\nusing this:\n  is_aligned x n\n\ngoal (1 subgoal):\n 1. x \\<le> x + 2 ^ n - 1", "by (simp add: is_aligned_no_overflow)"], ["proof (state)\nthis:\n  x \\<le> x + 2 ^ n - 1\n\ngoal (2 subgoals):\n 1. a \\<le> alignUp a n\n 2. alignUp a n + 2 ^ n - 1 \\<le> b", "from xl sub"], ["proof (chain)\npicking this:\n  x \\<le> x + 2 ^ n - 1\n  {x..x + 2 ^ n - 1} \\<subseteq> {a..b}", "have ax: \"a \\<le> x\""], ["proof (prove)\nusing this:\n  x \\<le> x + 2 ^ n - 1\n  {x..x + 2 ^ n - 1} \\<subseteq> {a..b}\n\ngoal (1 subgoal):\n 1. a \\<le> x", "by auto"], ["proof (state)\nthis:\n  a \\<le> x\n\ngoal (2 subgoals):\n 1. a \\<le> alignUp a n\n 2. alignUp a n + 2 ^ n - 1 \\<le> b", "show \"a \\<le> alignUp a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> alignUp a n", "proof (rule alignUp_ge)"], ["proof (state)\ngoal (2 subgoals):\n 1. n < LENGTH('a)\n 2. alignUp a n \\<noteq> 0", "show \"alignUp a n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp a n \\<noteq> 0", "using al sz ax anz"], ["proof (prove)\nusing this:\n  is_aligned x n\n  n < LENGTH('a)\n  a \\<le> x\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. alignUp a n \\<noteq> 0", "by (rule alignUp_is_aligned_nz)"], ["proof (state)\nthis:\n  alignUp a n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n < LENGTH('a)", "qed fact+"], ["proof (state)\nthis:\n  a \\<le> alignUp a n\n\ngoal (1 subgoal):\n 1. alignUp a n + 2 ^ n - 1 \\<le> b", "show \"alignUp a n + 2 ^ n - 1 \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp a n + 2 ^ n - 1 \\<le> b", "proof (rule order_trans)"], ["proof (state)\ngoal (2 subgoals):\n 1. alignUp a n + 2 ^ n - 1 \\<le> ?y\n 2. ?y \\<le> b", "from xl"], ["proof (chain)\npicking this:\n  x \\<le> x + 2 ^ n - 1", "show tp: \"x + 2 ^ n - 1 \\<le> b\""], ["proof (prove)\nusing this:\n  x \\<le> x + 2 ^ n - 1\n\ngoal (1 subgoal):\n 1. x + 2 ^ n - 1 \\<le> b", "using sub"], ["proof (prove)\nusing this:\n  x \\<le> x + 2 ^ n - 1\n  {x..x + 2 ^ n - 1} \\<subseteq> {a..b}\n\ngoal (1 subgoal):\n 1. x + 2 ^ n - 1 \\<le> b", "by auto"], ["proof (state)\nthis:\n  x + 2 ^ n - 1 \\<le> b\n\ngoal (1 subgoal):\n 1. alignUp a n + 2 ^ n - 1 \\<le> x + 2 ^ n - 1", "from ax"], ["proof (chain)\npicking this:\n  a \\<le> x", "have \"alignUp a n \\<le> x\""], ["proof (prove)\nusing this:\n  a \\<le> x\n\ngoal (1 subgoal):\n 1. alignUp a n \\<le> x", "by (rule alignUp_le_greater_al) fact+"], ["proof (state)\nthis:\n  alignUp a n \\<le> x\n\ngoal (1 subgoal):\n 1. alignUp a n + 2 ^ n - 1 \\<le> x + 2 ^ n - 1", "then"], ["proof (chain)\npicking this:\n  alignUp a n \\<le> x", "have \"alignUp a n + (2 ^ n - 1) \\<le> x + (2 ^ n - 1)\""], ["proof (prove)\nusing this:\n  alignUp a n \\<le> x\n\ngoal (1 subgoal):\n 1. alignUp a n + (2 ^ n - 1) \\<le> x + (2 ^ n - 1)", "using xl al is_aligned_no_overflow' olen_add_eqv word_plus_mcs_3"], ["proof (prove)\nusing this:\n  alignUp a n \\<le> x\n  x \\<le> x + 2 ^ n - 1\n  is_aligned x n\n  is_aligned ?p ?n \\<Longrightarrow> ?p \\<le> ?p + (2 ^ ?n - 1)\n  (?y \\<le> ?y + ?x) = (?x \\<le> ?y + ?x)\n  \\<lbrakk>?v \\<le> ?w; ?x \\<le> ?w + ?x\\<rbrakk>\n  \\<Longrightarrow> ?v + ?x \\<le> ?w + ?x\n\ngoal (1 subgoal):\n 1. alignUp a n + (2 ^ n - 1) \\<le> x + (2 ^ n - 1)", "by blast"], ["proof (state)\nthis:\n  alignUp a n + (2 ^ n - 1) \\<le> x + (2 ^ n - 1)\n\ngoal (1 subgoal):\n 1. alignUp a n + 2 ^ n - 1 \\<le> x + 2 ^ n - 1", "then"], ["proof (chain)\npicking this:\n  alignUp a n + (2 ^ n - 1) \\<le> x + (2 ^ n - 1)", "show \"alignUp a n + 2 ^ n - 1 \\<le> x + 2 ^ n - 1\""], ["proof (prove)\nusing this:\n  alignUp a n + (2 ^ n - 1) \\<le> x + (2 ^ n - 1)\n\ngoal (1 subgoal):\n 1. alignUp a n + 2 ^ n - 1 \\<le> x + 2 ^ n - 1", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  alignUp a n + 2 ^ n - 1 \\<le> x + 2 ^ n - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  alignUp a n + 2 ^ n - 1 \\<le> b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alignUp_def2:\n  \"alignUp a sz = a + 2 ^ sz - 1 AND NOT (mask sz)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp a sz = a + 2 ^ sz - 1 AND NOT (mask sz)", "by (simp add: alignUp_def flip: mask_eq_decr_exp)"], ["", "lemma alignUp_def3:\n  \"alignUp a sz = 2^ sz + (a - 1 AND NOT (mask sz))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp a sz = 2 ^ sz + (a - 1 AND NOT (mask sz))", "by (simp add: alignUp_def2 is_aligned_triv field_simps mask_out_add_aligned)"], ["", "lemma  alignUp_plus:\n  \"is_aligned w us \\<Longrightarrow> alignUp (w + a) us  = w + alignUp a us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned w us \\<Longrightarrow> alignUp (w + a) us = w + alignUp a us", "by (clarsimp simp: alignUp_def2 mask_out_add_aligned field_simps)"], ["", "lemma alignUp_distance:\n  \"alignUp (q :: 'a :: len word) sz - q \\<le> mask sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alignUp q sz - q \\<le> mask sz", "by (metis (no_types) add.commute add_diff_cancel_left alignUp_def2 diff_add_cancel\n                       mask_2pm1 subtract_mask(2) word_and_le1 word_sub_le_iff)"], ["", "lemma is_aligned_diff_neg_mask:\n  \"is_aligned p sz \\<Longrightarrow> (p - q AND NOT (mask sz)) = (p - ((alignUp q sz) AND NOT (mask sz)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned p sz \\<Longrightarrow>\n    p - q AND NOT (mask sz) = p - (alignUp q sz AND NOT (mask sz))", "apply (clarsimp simp only:word_and_le2 diff_conv_add_uminus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned p sz \\<Longrightarrow>\n    p + - q AND NOT (mask sz) = p + - (alignUp q sz AND NOT (mask sz))", "apply (subst mask_out_add_aligned[symmetric]; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned p sz \\<Longrightarrow>\n    - q AND NOT (mask sz) = - (alignUp q sz AND NOT (mask sz))", "apply (simp add: eq_neg_iff_add_eq_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned p sz \\<Longrightarrow>\n    (- q AND NOT (mask sz)) + (alignUp q sz AND NOT (mask sz)) = 0", "apply (subst add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned p sz \\<Longrightarrow>\n    (alignUp q sz AND NOT (mask sz)) + (- q AND NOT (mask sz)) = 0", "apply (simp add: alignUp_distance is_aligned_neg_mask_eq mask_out_add_aligned and_mask_eq_iff_le_mask flip: mask_eq_x_eq_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_clz_max:\n  \"word_clz w \\<le> size (w::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_clz w \\<le> size w", "unfolding word_clz_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (takeWhile Not (to_bl w)) \\<le> size w", "by (metis length_takeWhile_le word_size_bl)"], ["", "lemma word_clz_nonzero_max:\n  fixes w :: \"'a::len word\"\n  assumes nz: \"w \\<noteq> 0\"\n  shows \"word_clz w < size (w::'a::len word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_clz w < size w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. word_clz w < size w", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. word_clz w < size w", "assume a: \"word_clz w = size (w::'a::len word)\""], ["proof (state)\nthis:\n  word_clz w = size w\n\ngoal (1 subgoal):\n 1. word_clz w < size w", "hence \"length (takeWhile Not (to_bl w)) = length (to_bl w)\""], ["proof (prove)\nusing this:\n  word_clz w = size w\n\ngoal (1 subgoal):\n 1. length (takeWhile Not (to_bl w)) = length (to_bl w)", "by (simp add: word_clz_def word_size)"], ["proof (state)\nthis:\n  length (takeWhile Not (to_bl w)) = length (to_bl w)\n\ngoal (1 subgoal):\n 1. word_clz w < size w", "hence allj: \"\\<forall>j\\<in>set(to_bl w). \\<not> j\""], ["proof (prove)\nusing this:\n  length (takeWhile Not (to_bl w)) = length (to_bl w)\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>set (to_bl w). \\<not> j", "by (metis a length_takeWhile_less less_irrefl_nat word_clz_def)"], ["proof (state)\nthis:\n  \\<forall>j\\<in>set (to_bl w). \\<not> j\n\ngoal (1 subgoal):\n 1. word_clz w < size w", "hence \"to_bl w = replicate (length (to_bl w)) False\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<in>set (to_bl w). \\<not> j\n\ngoal (1 subgoal):\n 1. to_bl w = replicate (length (to_bl w)) False", "using eq_zero_set_bl nz"], ["proof (prove)\nusing this:\n  \\<forall>j\\<in>set (to_bl w). \\<not> j\n  (?w = 0) = (True \\<notin> set (to_bl ?w))\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. to_bl w = replicate (length (to_bl w)) False", "by fastforce"], ["proof (state)\nthis:\n  to_bl w = replicate (length (to_bl w)) False\n\ngoal (1 subgoal):\n 1. word_clz w < size w", "hence \"w = 0\""], ["proof (prove)\nusing this:\n  to_bl w = replicate (length (to_bl w)) False\n\ngoal (1 subgoal):\n 1. w = 0", "by (metis to_bl_0 word_bl.Rep_eqD word_bl_Rep')"], ["proof (state)\nthis:\n  w = 0\n\ngoal (1 subgoal):\n 1. word_clz w < size w", "with nz"], ["proof (chain)\npicking this:\n  w \\<noteq> 0\n  w = 0", "have False"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\n  w = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. word_clz w < size w", "}"], ["proof (state)\nthis:\n  word_clz w = size w \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. word_clz w < size w", "thus ?thesis"], ["proof (prove)\nusing this:\n  word_clz w = size w \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. word_clz w < size w", "using word_clz_max"], ["proof (prove)\nusing this:\n  word_clz w = size w \\<Longrightarrow> False\n  word_clz ?w \\<le> size ?w\n\ngoal (1 subgoal):\n 1. word_clz w < size w", "by (fastforce intro: le_neq_trans)"], ["proof (state)\nthis:\n  word_clz w < size w\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Sign extension from bit n. *)"], ["", "lemma sign_extend_bitwise_if:\n  \"i < size w \\<Longrightarrow> sign_extend e w !! i \\<longleftrightarrow> (if i < e then w !! i else w !! e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < size w \\<Longrightarrow>\n    sign_extend e w !! i = (if i < e then w !! i else w !! e)", "by (simp add: sign_extend_def neg_mask_test_bit word_size)"], ["", "lemma sign_extend_bitwise_if'  [word_eqI_simps]:\n  \\<open>i < LENGTH('a) \\<Longrightarrow> sign_extend e w !! i \\<longleftrightarrow> (if i < e then w !! i else w !! e)\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < LENGTH('a) \\<Longrightarrow>\n    sign_extend e w !! i = (if i < e then w !! i else w !! e)", "using sign_extend_bitwise_if [of i w e]"], ["proof (prove)\nusing this:\n  i < size w \\<Longrightarrow>\n  sign_extend e w !! i = (if i < e then w !! i else w !! e)\n\ngoal (1 subgoal):\n 1. i < LENGTH('a) \\<Longrightarrow>\n    sign_extend e w !! i = (if i < e then w !! i else w !! e)", "by (simp add: word_size)"], ["", "lemma sign_extend_bitwise_disj:\n  \"i < size w \\<Longrightarrow> sign_extend e w !! i \\<longleftrightarrow> i \\<le> e \\<and> w !! i \\<or> e \\<le> i \\<and> w !! e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < size w \\<Longrightarrow>\n    sign_extend e w !! i =\n    (i \\<le> e \\<and> w !! i \\<or> e \\<le> i \\<and> w !! e)", "by (auto simp: sign_extend_bitwise_if)"], ["", "lemma sign_extend_bitwise_cases:\n  \"i < size w \\<Longrightarrow> sign_extend e w !! i \\<longleftrightarrow> (i \\<le> e \\<longrightarrow> w !! i) \\<and> (e \\<le> i \\<longrightarrow> w !! e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < size w \\<Longrightarrow>\n    sign_extend e w !! i =\n    ((i \\<le> e \\<longrightarrow> w !! i) \\<and>\n     (e \\<le> i \\<longrightarrow> w !! e))", "by (auto simp: sign_extend_bitwise_if)"], ["", "lemmas sign_extend_bitwise_disj' = sign_extend_bitwise_disj[simplified word_size]"], ["", "lemmas sign_extend_bitwise_cases' = sign_extend_bitwise_cases[simplified word_size]"], ["", "(* Often, it is easier to reason about an operation which does not overwrite\n   the bit which determines which mask operation to apply. *)"], ["", "lemma sign_extend_def':\n  \"sign_extend n w = (if w !! n then w OR NOT (mask (Suc n)) else w AND mask (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_extend n w =\n    (if w !! n then w OR NOT (mask (Suc n)) else w AND mask (Suc n))", "by (rule bit_word_eqI) (auto simp add: bit_simps sign_extend_eq_signed_take_bit min_def test_bit_eq_bit less_Suc_eq_le)"], ["", "lemma sign_extended_sign_extend:\n  \"sign_extended n (sign_extend n w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_extended n (sign_extend n w)", "by (clarsimp simp: sign_extended_def word_size sign_extend_bitwise_if)"], ["", "lemma sign_extended_iff_sign_extend:\n  \"sign_extended n w \\<longleftrightarrow> sign_extend n w = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_extended n w = (sign_extend n w = w)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. sign_extended n w \\<Longrightarrow> sign_extend n w = w\n 2. sign_extend n w = w \\<Longrightarrow> sign_extended n w", "apply (auto simp add: bit_eq_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>sign_extended n w; bit (sign_extend n w) na\\<rbrakk>\n       \\<Longrightarrow> bit w na\n 2. \\<And>na.\n       \\<lbrakk>sign_extended n w; bit w na\\<rbrakk>\n       \\<Longrightarrow> bit (sign_extend n w) na\n 3. \\<forall>na. bit (sign_extend n w) na = bit w na \\<Longrightarrow>\n    sign_extended n w", "apply (simp_all add: bit_simps sign_extend_eq_signed_take_bit not_le min_def sign_extended_def test_bit_eq_bit word_size split: if_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i>n. i < LENGTH('a) \\<longrightarrow> bit w i;\n        n \\<le> na; na < LENGTH('a) \\<and> bit w n\\<rbrakk>\n       \\<Longrightarrow> bit w na\n 2. \\<And>na.\n       \\<lbrakk>\\<forall>i>n.\n                   i < LENGTH('a) \\<longrightarrow> bit w i = bit w n;\n        bit w na\\<rbrakk>\n       \\<Longrightarrow> (n \\<le> na \\<longrightarrow>\n                          na < LENGTH('a) \\<and> bit w n) \\<and>\n                         (na < n \\<longrightarrow> na < LENGTH('a))\n 3. \\<forall>na.\n       (na < n \\<or> (na < LENGTH('a) \\<and> bit w n) = bit w na) \\<and>\n       (na < n \\<longrightarrow>\n        (na < LENGTH('a) \\<and> bit w na) = bit w na) \\<Longrightarrow>\n    \\<forall>i>n. i < LENGTH('a) \\<longrightarrow> bit w i = bit w n", "using le_imp_less_or_eq"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x < ?y \\<or> ?x = ?y\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i>n. i < LENGTH('a) \\<longrightarrow> bit w i;\n        n \\<le> na; na < LENGTH('a) \\<and> bit w n\\<rbrakk>\n       \\<Longrightarrow> bit w na\n 2. \\<And>na.\n       \\<lbrakk>\\<forall>i>n.\n                   i < LENGTH('a) \\<longrightarrow> bit w i = bit w n;\n        bit w na\\<rbrakk>\n       \\<Longrightarrow> (n \\<le> na \\<longrightarrow>\n                          na < LENGTH('a) \\<and> bit w n) \\<and>\n                         (na < n \\<longrightarrow> na < LENGTH('a))\n 3. \\<forall>na.\n       (na < n \\<or> (na < LENGTH('a) \\<and> bit w n) = bit w na) \\<and>\n       (na < n \\<longrightarrow>\n        (na < LENGTH('a) \\<and> bit w na) = bit w na) \\<Longrightarrow>\n    \\<forall>i>n. i < LENGTH('a) \\<longrightarrow> bit w i = bit w n", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i>n.\n                   i < LENGTH('a) \\<longrightarrow> bit w i = bit w n;\n        bit w na\\<rbrakk>\n       \\<Longrightarrow> (n \\<le> na \\<longrightarrow>\n                          na < LENGTH('a) \\<and> bit w n) \\<and>\n                         (na < n \\<longrightarrow> na < LENGTH('a))\n 2. \\<forall>na.\n       (na < n \\<or> (na < LENGTH('a) \\<and> bit w n) = bit w na) \\<and>\n       (na < n \\<longrightarrow>\n        (na < LENGTH('a) \\<and> bit w na) = bit w na) \\<Longrightarrow>\n    \\<forall>i>n. i < LENGTH('a) \\<longrightarrow> bit w i = bit w n", "apply (metis bit_imp_le_length nat_less_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>na.\n       (na < n \\<or> (na < LENGTH('a) \\<and> bit w n) = bit w na) \\<and>\n       (na < n \\<longrightarrow>\n        (na < LENGTH('a) \\<and> bit w na) = bit w na) \\<Longrightarrow>\n    \\<forall>i>n. i < LENGTH('a) \\<longrightarrow> bit w i = bit w n", "apply (metis Suc_leI Suc_n_not_le_n le_trans nat_less_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sign_extended_weaken:\n  \"sign_extended n w \\<Longrightarrow> n \\<le> m \\<Longrightarrow> sign_extended m w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_extended n w; n \\<le> m\\<rbrakk>\n    \\<Longrightarrow> sign_extended m w", "unfolding sign_extended_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i>n. i < size w \\<longrightarrow> w !! i = w !! n;\n     n \\<le> m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i>m.\n                         i < size w \\<longrightarrow> w !! i = w !! m", "by (cases \"n < m\") auto"], ["", "lemma sign_extend_sign_extend_eq:\n  \"sign_extend m (sign_extend n w) = sign_extend (min m n) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_extend m (sign_extend n w) = sign_extend (min m n) w", "by (rule bit_word_eqI) (simp add: sign_extend_eq_signed_take_bit bit_simps)"], ["", "lemma sign_extended_high_bits:\n  \"\\<lbrakk> sign_extended e p; j < size p; e \\<le> i; i < j \\<rbrakk> \\<Longrightarrow> p !! i = p !! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_extended e p; j < size p; e \\<le> i; i < j\\<rbrakk>\n    \\<Longrightarrow> p !! i = p !! j", "by (drule (1) sign_extended_weaken; simp add: sign_extended_def)"], ["", "lemma sign_extend_eq:\n  \"w AND mask (Suc n) = v AND mask (Suc n) \\<Longrightarrow> sign_extend n w = sign_extend n v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w AND mask (Suc n) = v AND mask (Suc n) \\<Longrightarrow>\n    sign_extend n w = sign_extend n v", "by (simp flip: take_bit_eq_mask add: sign_extend_eq_signed_take_bit signed_take_bit_eq_iff_take_bit_eq)"], ["", "lemma sign_extended_add:\n  assumes p: \"is_aligned p n\"\n  assumes f: \"f < 2 ^ n\"\n  assumes e: \"n \\<le> e\"\n  assumes \"sign_extended e p\"\n  shows \"sign_extended e (p + f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_extended e (p + f)", "proof (cases \"e < size p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e < size p \\<Longrightarrow> sign_extended e (p + f)\n 2. \\<not> e < size p \\<Longrightarrow> sign_extended e (p + f)", "case True"], ["proof (state)\nthis:\n  e < size p\n\ngoal (2 subgoals):\n 1. e < size p \\<Longrightarrow> sign_extended e (p + f)\n 2. \\<not> e < size p \\<Longrightarrow> sign_extended e (p + f)", "note and_or = is_aligned_add_or[OF p f]"], ["proof (state)\nthis:\n  p + f = p OR f\n\ngoal (2 subgoals):\n 1. e < size p \\<Longrightarrow> sign_extended e (p + f)\n 2. \\<not> e < size p \\<Longrightarrow> sign_extended e (p + f)", "have \"\\<not> f !! e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> f !! e", "using True e less_2p_is_upper_bits_unset[THEN iffD1, OF f]"], ["proof (prove)\nusing this:\n  e < size p\n  n \\<le> e\n  n < LENGTH('a) \\<and>\n  (\\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> f !! n')\n\ngoal (1 subgoal):\n 1. \\<not> f !! e", "by (fastforce simp: word_size)"], ["proof (state)\nthis:\n  \\<not> f !! e\n\ngoal (2 subgoals):\n 1. e < size p \\<Longrightarrow> sign_extended e (p + f)\n 2. \\<not> e < size p \\<Longrightarrow> sign_extended e (p + f)", "hence i: \"(p + f) !! e = p !! e\""], ["proof (prove)\nusing this:\n  \\<not> f !! e\n\ngoal (1 subgoal):\n 1. (p + f) !! e = p !! e", "by (simp add: and_or)"], ["proof (state)\nthis:\n  (p + f) !! e = p !! e\n\ngoal (2 subgoals):\n 1. e < size p \\<Longrightarrow> sign_extended e (p + f)\n 2. \\<not> e < size p \\<Longrightarrow> sign_extended e (p + f)", "have fm: \"f AND mask e = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f AND mask e = f", "by (fastforce intro: subst[where P=\"\\<lambda>f. f AND mask e = f\", OF less_mask_eq[OF f]]\n                  simp: mask_twice e)"], ["proof (state)\nthis:\n  f AND mask e = f\n\ngoal (2 subgoals):\n 1. e < size p \\<Longrightarrow> sign_extended e (p + f)\n 2. \\<not> e < size p \\<Longrightarrow> sign_extended e (p + f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_extended e (p + f)", "using assms"], ["proof (prove)\nusing this:\n  is_aligned p n\n  f < 2 ^ n\n  n \\<le> e\n  sign_extended e p\n\ngoal (1 subgoal):\n 1. sign_extended e (p + f)", "apply (simp add: sign_extended_iff_sign_extend sign_extend_def i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; f < 2 ^ n; n \\<le> e;\n     (if p !! e then p OR NOT (mask e) else p AND mask e) = p\\<rbrakk>\n    \\<Longrightarrow> (p !! e \\<longrightarrow>\n                       p + f OR NOT (mask e) = p + f) \\<and>\n                      (\\<not> p !! e \\<longrightarrow>\n                       p + f AND mask e = p + f)", "apply (simp add: and_or word_bw_comms[of p f])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; f < 2 ^ n; n \\<le> e;\n     (if p !! e then p OR NOT (mask e) else p AND mask e) = p\\<rbrakk>\n    \\<Longrightarrow> (p !! e \\<longrightarrow>\n                       (f OR p) OR NOT (mask e) = f OR p) \\<and>\n                      (\\<not> p !! e \\<longrightarrow>\n                       (f OR p) AND mask e = f OR p)", "apply (clarsimp simp: word_ao_dist fm word_bw_assocs split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sign_extended e (p + f)\n\ngoal (1 subgoal):\n 1. \\<not> e < size p \\<Longrightarrow> sign_extended e (p + f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> e < size p \\<Longrightarrow> sign_extended e (p + f)", "case False"], ["proof (state)\nthis:\n  \\<not> e < size p\n\ngoal (1 subgoal):\n 1. \\<not> e < size p \\<Longrightarrow> sign_extended e (p + f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> e < size p\n\ngoal (1 subgoal):\n 1. sign_extended e (p + f)", "by (simp add: sign_extended_def word_size)"], ["proof (state)\nthis:\n  sign_extended e (p + f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_extended_neq_mask:\n  \"\\<lbrakk>sign_extended n ptr; m \\<le> n\\<rbrakk> \\<Longrightarrow> sign_extended n (ptr AND NOT (mask m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_extended n ptr; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> sign_extended n (ptr AND NOT (mask m))", "by (fastforce simp: sign_extended_def word_size neg_mask_test_bit)"], ["", "definition\n  \"limited_and (x :: 'a :: len word) y \\<longleftrightarrow> (x AND y = x)\""], ["", "lemma limited_and_eq_0:\n  \"\\<lbrakk> limited_and x z; y AND NOT z = y \\<rbrakk> \\<Longrightarrow> x AND y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>limited_and x z; y AND NOT z = y\\<rbrakk>\n    \\<Longrightarrow> x AND y = 0", "unfolding limited_and_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x AND z = x; y AND NOT z = y\\<rbrakk>\n    \\<Longrightarrow> x AND y = 0", "apply (subst arg_cong2[where f=\"(AND)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x AND z = x; y AND NOT z = y\\<rbrakk> \\<Longrightarrow> x = ?b\n 2. \\<lbrakk>x AND z = x; y AND NOT z = y\\<rbrakk> \\<Longrightarrow> y = ?d\n 3. \\<lbrakk>x AND z = x; y AND NOT z = y\\<rbrakk>\n    \\<Longrightarrow> ?b AND ?d = 0", "apply (erule sym)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x AND z = x; y AND NOT z = y\\<rbrakk>\n    \\<Longrightarrow> (x AND z) AND y AND NOT z = 0", "apply (simp(no_asm) add: word_bw_assocs word_bw_comms word_bw_lcs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma limited_and_eq_id:\n  \"\\<lbrakk> limited_and x z; y AND z = z \\<rbrakk> \\<Longrightarrow> x AND y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>limited_and x z; y AND z = z\\<rbrakk>\n    \\<Longrightarrow> x AND y = x", "unfolding limited_and_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x AND z = x; y AND z = z\\<rbrakk> \\<Longrightarrow> x AND y = x", "by (erule subst, fastforce simp: word_bw_lcs word_bw_assocs word_bw_comms)"], ["", "lemma lshift_limited_and:\n  \"limited_and x z \\<Longrightarrow> limited_and (x << n) (z << n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limited_and x z \\<Longrightarrow> limited_and (x << n) (z << n)", "unfolding limited_and_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND z = x \\<Longrightarrow> (x << n) AND (z << n) = x << n", "by (simp add: shiftl_over_and_dist[symmetric])"], ["", "lemma rshift_limited_and:\n  \"limited_and x z \\<Longrightarrow> limited_and (x >> n) (z >> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limited_and x z \\<Longrightarrow> limited_and (x >> n) (z >> n)", "unfolding limited_and_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND z = x \\<Longrightarrow> (x >> n) AND (z >> n) = x >> n", "by (simp add: shiftr_over_and_dist[symmetric])"], ["", "lemmas limited_and_simps1 = limited_and_eq_0 limited_and_eq_id"], ["", "lemmas is_aligned_limited_and\n    = is_aligned_neg_mask_eq[unfolded mask_eq_decr_exp, folded limited_and_def]"], ["", "lemmas limited_and_simps = limited_and_simps1\n       limited_and_simps1[OF is_aligned_limited_and]\n       limited_and_simps1[OF lshift_limited_and]\n       limited_and_simps1[OF rshift_limited_and]\n       limited_and_simps1[OF rshift_limited_and, OF is_aligned_limited_and]\n       not_one shiftl_shiftr1[unfolded word_size mask_eq_decr_exp]\n       shiftl_shiftr2[unfolded word_size mask_eq_decr_exp]"], ["", "definition\n  from_bool :: \"bool \\<Rightarrow> 'a::len word\" where\n  \"from_bool b \\<equiv> case b of True \\<Rightarrow> of_nat 1\n                         | False \\<Rightarrow> of_nat 0\""], ["", "lemma from_bool_eq:\n  \\<open>from_bool = of_bool\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. from_bool = of_bool", "by (simp add: fun_eq_iff from_bool_def)"], ["", "lemma from_bool_0:\n  \"(from_bool x = 0) = (\\<not> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (from_bool x = 0) = (\\<not> x)", "by (simp add: from_bool_def split: bool.split)"], ["", "lemma from_bool_eq_if':\n  \"((if P then 1 else 0) = from_bool Q) = (P = Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if P then 1 else 0) = from_bool Q) = (P = Q)", "by (cases Q) (simp_all add: from_bool_def)"], ["", "definition\n  to_bool :: \"'a::len word \\<Rightarrow> bool\" where\n  \"to_bool \\<equiv> (\\<noteq>) 0\""], ["", "lemma to_bool_and_1:\n  \"to_bool (x AND 1) = (x !! 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bool (x AND 1) = x !! 0", "by (simp add: test_bit_word_eq to_bool_def and_one_eq mod_2_eq_odd)"], ["", "lemma to_bool_from_bool [simp]:\n  \"to_bool (from_bool r) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bool (from_bool r) = r", "unfolding from_bool_def to_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<noteq>\n     (case r of True \\<Rightarrow> word_of_nat 1\n      | False \\<Rightarrow> word_of_nat 0)) =\n    r", "by (simp split: bool.splits)"], ["", "lemma from_bool_neq_0 [simp]:\n  \"(from_bool b \\<noteq> 0) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (from_bool b \\<noteq> 0) = b", "by (simp add: from_bool_def split: bool.splits)"], ["", "lemma from_bool_mask_simp [simp]:\n  \"(from_bool r :: 'a::len word) AND 1 = from_bool r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_bool r AND 1 = from_bool r", "unfolding from_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case r of True \\<Rightarrow> word_of_nat 1\n     | False \\<Rightarrow> word_of_nat 0) AND\n    1 =\n    (case r of True \\<Rightarrow> word_of_nat 1\n     | False \\<Rightarrow> word_of_nat 0)", "by (clarsimp split: bool.splits)"], ["", "lemma from_bool_1 [simp]:\n  \"(from_bool P = 1) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (from_bool P = 1) = P", "by (simp add: from_bool_def split: bool.splits)"], ["", "lemma ge_0_from_bool [simp]:\n  \"(0 < from_bool P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < from_bool P) = P", "by (simp add: from_bool_def split: bool.splits)"], ["", "lemma limited_and_from_bool:\n  \"limited_and (from_bool b) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limited_and (from_bool b) 1", "by (simp add: from_bool_def limited_and_def split: bool.split)"], ["", "lemma to_bool_1 [simp]: \"to_bool 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bool 1", "by (simp add: to_bool_def)"], ["", "lemma to_bool_0 [simp]: \"\\<not>to_bool 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> to_bool 0", "by (simp add: to_bool_def)"], ["", "lemma from_bool_eq_if:\n  \"(from_bool Q = (if P then 1 else 0)) = (P = Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (from_bool Q = (if P then 1 else 0)) = (P = Q)", "by (cases Q) (simp_all add: from_bool_def)"], ["", "lemma to_bool_eq_0:\n  \"(\\<not> to_bool x) = (x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> to_bool x) = (x = 0)", "by (simp add: to_bool_def)"], ["", "lemma to_bool_neq_0:\n  \"(to_bool x) = (x \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_bool x = (x \\<noteq> 0)", "by (simp add: to_bool_def)"], ["", "lemma from_bool_all_helper:\n  \"(\\<forall>bool. from_bool bool = val \\<longrightarrow> P bool)\n      = ((\\<exists>bool. from_bool bool = val) \\<longrightarrow> P (val \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>bool. from_bool bool = val \\<longrightarrow> P bool) =\n    ((\\<exists>bool. from_bool bool = val) \\<longrightarrow>\n     P (val \\<noteq> 0))", "by (auto simp: from_bool_0)"], ["", "lemma fold_eq_0_to_bool:\n  \"(v = 0) = (\\<not> to_bool v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v = 0) = (\\<not> to_bool v)", "by (simp add: to_bool_def)"], ["", "lemma from_bool_to_bool_iff:\n  \"w = from_bool b \\<longleftrightarrow> to_bool w = b \\<and> (w = 0 \\<or> w = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w = from_bool b) = (to_bool w = b \\<and> (w = 0 \\<or> w = 1))", "by (cases b) (auto simp: from_bool_def to_bool_def)"], ["", "lemma from_bool_eqI:\n  \"from_bool x = from_bool y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_bool x = from_bool y \\<Longrightarrow> x = y", "unfolding from_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of True \\<Rightarrow> word_of_nat 1\n     | False \\<Rightarrow> word_of_nat 0) =\n    (case y of True \\<Rightarrow> word_of_nat 1\n     | False \\<Rightarrow> word_of_nat 0) \\<Longrightarrow>\n    x = y", "by (auto split: bool.splits)"], ["", "lemma neg_mask_in_mask_range:\n  \"is_aligned ptr bits \\<Longrightarrow> (ptr' AND NOT(mask bits) = ptr) = (ptr' \\<in> mask_range ptr bits)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned ptr bits \\<Longrightarrow>\n    (ptr' AND NOT (mask bits) = ptr) = (ptr' \\<in> mask_range ptr bits)", "apply (erule is_aligned_get_word_bits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (ptr' AND NOT (mask bits) = ptr) =\n                      (ptr' \\<in> mask_range ptr bits)\n 2. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> bits\\<rbrakk>\n    \\<Longrightarrow> (ptr' AND NOT (mask bits) = ptr) =\n                      (ptr' \\<in> mask_range ptr bits)", "apply (rule iffI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n     ptr' AND NOT (mask bits) = ptr\\<rbrakk>\n    \\<Longrightarrow> ptr' \\<in> mask_range ptr bits\n 2. \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n     ptr' \\<in> mask_range ptr bits\\<rbrakk>\n    \\<Longrightarrow> ptr' AND NOT (mask bits) = ptr\n 3. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> bits\\<rbrakk>\n    \\<Longrightarrow> (ptr' AND NOT (mask bits) = ptr) =\n                      (ptr' \\<in> mask_range ptr bits)", "apply (drule sym)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n     ptr = ptr' AND NOT (mask bits)\\<rbrakk>\n    \\<Longrightarrow> ptr' \\<in> mask_range ptr bits\n 2. \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n     ptr' \\<in> mask_range ptr bits\\<rbrakk>\n    \\<Longrightarrow> ptr' AND NOT (mask bits) = ptr\n 3. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> bits\\<rbrakk>\n    \\<Longrightarrow> (ptr' AND NOT (mask bits) = ptr) =\n                      (ptr' \\<in> mask_range ptr bits)", "apply (simp add: word_and_le2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>bits < LENGTH('a); ptr = ptr' AND NOT (mask bits)\\<rbrakk>\n    \\<Longrightarrow> ptr' \\<le> (ptr' AND NOT (mask bits)) + mask bits\n 2. \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n     ptr' \\<in> mask_range ptr bits\\<rbrakk>\n    \\<Longrightarrow> ptr' AND NOT (mask bits) = ptr\n 3. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> bits\\<rbrakk>\n    \\<Longrightarrow> (ptr' AND NOT (mask bits) = ptr) =\n                      (ptr' \\<in> mask_range ptr bits)", "apply (subst word_plus_and_or_coroll, word_eqI_solve)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>bits < LENGTH('a); ptr = ptr' AND NOT (mask bits)\\<rbrakk>\n    \\<Longrightarrow> ptr' \\<le> ptr' AND NOT (mask bits) OR mask bits\n 2. \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n     ptr' \\<in> mask_range ptr bits\\<rbrakk>\n    \\<Longrightarrow> ptr' AND NOT (mask bits) = ptr\n 3. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> bits\\<rbrakk>\n    \\<Longrightarrow> (ptr' AND NOT (mask bits) = ptr) =\n                      (ptr' \\<in> mask_range ptr bits)", "apply (metis bit.disj_ac(2) bit.disj_conj_distrib2 le_word_or2 word_and_max word_or_not)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n     ptr' \\<in> mask_range ptr bits\\<rbrakk>\n    \\<Longrightarrow> ptr' AND NOT (mask bits) = ptr\n 2. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> bits\\<rbrakk>\n    \\<Longrightarrow> (ptr' AND NOT (mask bits) = ptr) =\n                      (ptr' \\<in> mask_range ptr bits)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> ptr';\n     ptr' \\<le> ptr + mask bits\\<rbrakk>\n    \\<Longrightarrow> ptr' AND NOT (mask bits) = ptr\n 2. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> bits\\<rbrakk>\n    \\<Longrightarrow> (ptr' AND NOT (mask bits) = ptr) =\n                      (ptr' \\<in> mask_range ptr bits)", "apply (smt add.right_neutral eq_iff is_aligned_neg_mask_eq mask_out_add_aligned neg_mask_mono_le\n              word_and_not)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> bits\\<rbrakk>\n    \\<Longrightarrow> (ptr' AND NOT (mask bits) = ptr) =\n                      (ptr' \\<in> mask_range ptr bits)", "apply (simp add: power_overflow mask_eq_decr_exp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aligned_offset_in_range:\n  \"\\<lbrakk> is_aligned (x :: 'a :: len word) m; y < 2 ^ m; is_aligned p n; n \\<ge> m; n < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> (x + y \\<in> {p .. p + mask n}) = (x \\<in> mask_range p n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x m; y < 2 ^ m; is_aligned p n; m \\<le> n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + y \\<in> mask_range p n) =\n                      (x \\<in> mask_range p n)", "apply (subst disjunctive_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>is_aligned x m; y < 2 ^ m; is_aligned p n; m \\<le> n;\n        n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> \\<not> bit x na \\<or> \\<not> bit y na\n 2. \\<lbrakk>is_aligned x m; y < 2 ^ m; is_aligned p n; m \\<le> n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x OR y \\<in> mask_range p n) =\n                      (x \\<in> mask_range p n)", "apply (simp add: bit_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>is_aligned x m; y < 2 ^ m; is_aligned p n; m \\<le> n;\n        n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit x na \\<longrightarrow> \\<not> bit y na\n 2. \\<lbrakk>is_aligned x m; y < 2 ^ m; is_aligned p n; m \\<le> n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x OR y \\<in> mask_range p n) =\n                      (x \\<in> mask_range p n)", "apply (erule is_alignedE')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na q.\n       \\<lbrakk>y < 2 ^ m; is_aligned p n; m \\<le> n; n < LENGTH('a);\n        x = push_bit m (word_of_nat q); q < 2 ^ (LENGTH('a) - m)\\<rbrakk>\n       \\<Longrightarrow> bit x na \\<longrightarrow> \\<not> bit y na\n 2. \\<lbrakk>is_aligned x m; y < 2 ^ m; is_aligned p n; m \\<le> n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x OR y \\<in> mask_range p n) =\n                      (x \\<in> mask_range p n)", "apply (auto simp add: bit_simps not_le)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na q.\n       \\<lbrakk>y < 2 ^ m; is_aligned p n; m \\<le> n; n < LENGTH('a);\n        x = push_bit m (word_of_nat q); q < 2 ^ (LENGTH('a) - m);\n        m \\<le> na; na < LENGTH('a); na - m < LENGTH('a); bit q (na - m);\n        bit y na\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>is_aligned x m; y < 2 ^ m; is_aligned p n; m \\<le> n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x OR y \\<in> mask_range p n) =\n                      (x \\<in> mask_range p n)", "apply (metis less_2p_is_upper_bits_unset test_bit_eq_bit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x m; y < 2 ^ m; is_aligned p n; m \\<le> n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x OR y \\<in> mask_range p n) =\n                      (x \\<in> mask_range p n)", "apply (simp only: is_aligned_add_or word_ao_dist flip: neg_mask_in_mask_range)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x m; y < 2 ^ m; is_aligned p n; m \\<le> n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x AND NOT (mask n) OR y AND NOT (mask n) = p) =\n                      (x AND NOT (mask n) = p)", "apply (subgoal_tac \\<open>y AND NOT (mask n) = 0\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x m; y < 2 ^ m; is_aligned p n; m \\<le> n;\n     n < LENGTH('a); y AND NOT (mask n) = 0\\<rbrakk>\n    \\<Longrightarrow> (x AND NOT (mask n) OR y AND NOT (mask n) = p) =\n                      (x AND NOT (mask n) = p)\n 2. \\<lbrakk>is_aligned x m; y < 2 ^ m; is_aligned p n; m \\<le> n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y AND NOT (mask n) = 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x m; y < 2 ^ m; is_aligned p n; m \\<le> n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y AND NOT (mask n) = 0", "apply (metis (full_types) is_aligned_mask is_aligned_neg_mask less_mask_eq word_bw_comms(1) word_bw_lcs(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_range_to_bl':\n  \"\\<lbrakk> is_aligned (ptr :: 'a :: len word) bits; bits < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> mask_range ptr bits\n       = {x. take (LENGTH('a) - bits) (to_bl x) = take (LENGTH('a) - bits) (to_bl ptr)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mask_range ptr bits =\n                      {x. take (LENGTH('a) - bits) (to_bl x) =\n                          take (LENGTH('a) - bits) (to_bl ptr)}", "apply (rule set_eqI, rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> mask_range ptr bits\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                                     take (LENGTH('a) - bits) (to_bl ptr)}\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> take (LENGTH('a) - bits) (to_bl x) =\n                         take (LENGTH('a) - bits) (to_bl ptr)\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply (subgoal_tac \"\\<exists>y. x = ptr + y \\<and> y < 2 ^ bits\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits;\n        \\<exists>y. x = ptr + y \\<and> y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> take (LENGTH('a) - bits) (to_bl x) =\n                         take (LENGTH('a) - bits) (to_bl ptr)\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. x = ptr + y \\<and> y < 2 ^ bits\n 3. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> ptr + y;\n        ptr + y \\<le> ptr + mask bits; y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> take (LENGTH('a) - bits) (to_bl (ptr + y)) =\n                         take (LENGTH('a) - bits) (to_bl ptr)\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. x = ptr + y \\<and> y < 2 ^ bits\n 3. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply (subst is_aligned_add_conv)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> ptr + y;\n        ptr + y \\<le> ptr + mask bits; y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> is_aligned ptr (?n15 y)\n 2. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> ptr + y;\n        ptr + y \\<le> ptr + mask bits; y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> y < 2 ^ ?n15 y\n 3. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> ptr + y;\n        ptr + y \\<le> ptr + mask bits; y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> take (LENGTH('a) - bits)\n                          (take (LENGTH('a) - ?n15 y) (to_bl ptr) @\n                           drop (LENGTH('a) - ?n15 y) (to_bl y)) =\n                         take (LENGTH('a) - bits) (to_bl ptr)\n 4. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. x = ptr + y \\<and> y < 2 ^ bits\n 5. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> ptr + y;\n        ptr + y \\<le> ptr + mask bits; y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> y < 2 ^ bits\n 2. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> ptr + y;\n        ptr + y \\<le> ptr + mask bits; y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> take (LENGTH('a) - bits)\n                          (take (LENGTH('a) - bits) (to_bl ptr) @\n                           drop (LENGTH('a) - bits) (to_bl y)) =\n                         take (LENGTH('a) - bits) (to_bl ptr)\n 3. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. x = ptr + y \\<and> y < 2 ^ bits\n 4. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> ptr + y;\n        ptr + y \\<le> ptr + mask bits; y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> take (LENGTH('a) - bits)\n                          (take (LENGTH('a) - bits) (to_bl ptr) @\n                           drop (LENGTH('a) - bits) (to_bl y)) =\n                         take (LENGTH('a) - bits) (to_bl ptr)\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. x = ptr + y \\<and> y < 2 ^ bits\n 3. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. x = ptr + y \\<and> y < 2 ^ bits\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply (rule_tac x=\"x - ptr\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> x = ptr + (x - ptr) \\<and> x - ptr < 2 ^ bits\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply (simp add: add_diff_eq[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> x - ptr < 2 ^ bits\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply (simp only: word_less_sub_le[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> x - ptr \\<le> 2 ^ bits - 1\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply (rule word_diff_ls')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> x \\<le> 2 ^ bits - 1 + ptr\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> ptr \\<le> x\n 3. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply (simp add: field_simps mask_eq_decr_exp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a); ptr \\<le> x;\n        x \\<le> ptr + mask bits\\<rbrakk>\n       \\<Longrightarrow> ptr \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\n                    take (LENGTH('a) - bits) (to_bl ptr)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mask_range ptr bits", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> ptr \\<le> x \\<and> x \\<le> ptr + mask bits", "apply (subgoal_tac \"\\<exists>y. y < 2 ^ bits \\<and> to_bl (ptr + y) = to_bl x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        \\<exists>y<2 ^ bits. to_bl (ptr + y) = to_bl x\\<rbrakk>\n       \\<Longrightarrow> ptr \\<le> x \\<and> x \\<le> ptr + mask bits\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y<2 ^ bits. to_bl (ptr + y) = to_bl x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl (ptr + y)) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> ptr \\<le> ptr + y \\<and>\n                         ptr + y \\<le> ptr + mask bits\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y<2 ^ bits. to_bl (ptr + y) = to_bl x", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl (ptr + y)) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> ptr \\<le> ptr + y\n 2. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl (ptr + y)) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> ptr + y \\<le> ptr + mask bits\n 3. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y<2 ^ bits. to_bl (ptr + y) = to_bl x", "apply (erule(1) is_aligned_no_wrap')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl (ptr + y)) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> ptr + y \\<le> ptr + mask bits\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y<2 ^ bits. to_bl (ptr + y) = to_bl x", "apply (simp only: add_diff_eq[symmetric] mask_eq_decr_exp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl (ptr + y)) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> ptr + y \\<le> ptr + (2 ^ bits - 1)\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y<2 ^ bits. to_bl (ptr + y) = to_bl x", "apply (rule word_plus_mono_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl (ptr + y)) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> y \\<le> 2 ^ bits - 1\n 2. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl (ptr + y)) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> ptr \\<le> ptr + (2 ^ bits - 1)\n 3. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y<2 ^ bits. to_bl (ptr + y) = to_bl x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl (ptr + y)) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> ptr \\<le> ptr + (2 ^ bits - 1)\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y<2 ^ bits. to_bl (ptr + y) = to_bl x", "apply (erule is_aligned_no_wrap')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl (ptr + y)) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        y < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> 2 ^ bits - 1 < 2 ^ bits\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y<2 ^ bits. to_bl (ptr + y) = to_bl x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y<2 ^ bits. to_bl (ptr + y) = to_bl x", "apply (rule_tac x=\"of_bl (drop (LENGTH('a) - bits) (to_bl x))\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> of_bl (drop (LENGTH('a) - bits) (to_bl x))\n                         < 2 ^ bits \\<and>\n                         to_bl\n                          (ptr +\n                           of_bl (drop (LENGTH('a) - bits) (to_bl x))) =\n                         to_bl x", "apply (rule context_conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> of_bl (drop (LENGTH('a) - bits) (to_bl x))\n                         < 2 ^ bits\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        of_bl (drop (LENGTH('a) - bits) (to_bl x)) < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> to_bl\n                          (ptr +\n                           of_bl (drop (LENGTH('a) - bits) (to_bl x))) =\n                         to_bl x", "apply (rule order_less_le_trans [OF of_bl_length])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> length (drop (LENGTH('a) - bits) (to_bl x))\n                         < LENGTH('a)\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (drop (LENGTH('a) - bits) (to_bl x))\n                         \\<le> 2 ^ bits\n 3. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        of_bl (drop (LENGTH('a) - bits) (to_bl x)) < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> to_bl\n                          (ptr +\n                           of_bl (drop (LENGTH('a) - bits) (to_bl x))) =\n                         to_bl x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ length (drop (LENGTH('a) - bits) (to_bl x))\n                         \\<le> 2 ^ bits\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        of_bl (drop (LENGTH('a) - bits) (to_bl x)) < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> to_bl\n                          (ptr +\n                           of_bl (drop (LENGTH('a) - bits) (to_bl x))) =\n                         to_bl x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        of_bl (drop (LENGTH('a) - bits) (to_bl x)) < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> to_bl\n                          (ptr +\n                           of_bl (drop (LENGTH('a) - bits) (to_bl x))) =\n                         to_bl x", "apply (subst is_aligned_add_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        of_bl (drop (LENGTH('a) - bits) (to_bl x)) < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> is_aligned ptr (?n46 x)\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        of_bl (drop (LENGTH('a) - bits) (to_bl x)) < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> of_bl (drop (LENGTH('a) - bits) (to_bl x))\n                         < 2 ^ ?n46 x\n 3. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        of_bl (drop (LENGTH('a) - bits) (to_bl x)) < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> take (LENGTH('a) - ?n46 x) (to_bl ptr) @\n                         drop (LENGTH('a) - ?n46 x)\n                          (to_bl\n                            (of_bl (drop (LENGTH('a) - bits) (to_bl x)))) =\n                         to_bl x", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        of_bl (drop (LENGTH('a) - bits) (to_bl x)) < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> of_bl (drop (LENGTH('a) - bits) (to_bl x))\n                         < 2 ^ bits\n 2. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        of_bl (drop (LENGTH('a) - bits) (to_bl x)) < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> take (LENGTH('a) - bits) (to_bl ptr) @\n                         drop (LENGTH('a) - bits)\n                          (to_bl\n                            (of_bl (drop (LENGTH('a) - bits) (to_bl x)))) =\n                         to_bl x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr);\n        of_bl (drop (LENGTH('a) - bits) (to_bl x)) < 2 ^ bits\\<rbrakk>\n       \\<Longrightarrow> take (LENGTH('a) - bits) (to_bl ptr) @\n                         drop (LENGTH('a) - bits)\n                          (to_bl\n                            (of_bl (drop (LENGTH('a) - bits) (to_bl x)))) =\n                         to_bl x", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a);\n        of_bl (drop (LENGTH('a) - bits) (to_bl x)) < 2 ^ bits;\n        take (LENGTH('a) - bits) (to_bl ptr) =\n        take (LENGTH('a) - bits) (to_bl x)\\<rbrakk>\n       \\<Longrightarrow> take (LENGTH('a) - bits) (to_bl ptr) @\n                         drop (LENGTH('a) - bits)\n                          (to_bl\n                            (of_bl (drop (LENGTH('a) - bits) (to_bl x)))) =\n                         to_bl x", "apply (simp add: word_rep_drop)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_range_to_bl:\n  \"is_aligned (ptr :: 'a :: len word) bits\n   \\<Longrightarrow> mask_range ptr bits\n        = {x. take (LENGTH('a) - bits) (to_bl x) = take (LENGTH('a) - bits) (to_bl ptr)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned ptr bits \\<Longrightarrow>\n    mask_range ptr bits =\n    {x. take (LENGTH('a) - bits) (to_bl x) =\n        take (LENGTH('a) - bits) (to_bl ptr)}", "apply (erule is_aligned_get_word_bits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr bits; bits < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mask_range ptr bits =\n                      {x. take (LENGTH('a) - bits) (to_bl x) =\n                          take (LENGTH('a) - bits) (to_bl ptr)}\n 2. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> bits\\<rbrakk>\n    \\<Longrightarrow> mask_range ptr bits =\n                      {x. take (LENGTH('a) - bits) (to_bl x) =\n                          take (LENGTH('a) - bits) (to_bl ptr)}", "apply (erule(1) mask_range_to_bl')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> bits\\<rbrakk>\n    \\<Longrightarrow> mask_range ptr bits =\n                      {x. take (LENGTH('a) - bits) (to_bl x) =\n                          take (LENGTH('a) - bits) (to_bl ptr)}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>ptr = 0; LENGTH('a) \\<le> bits\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> mask_range ptr bits) =\n                         (x \\<in> {x. take (LENGTH('a) - bits) (to_bl x) =\ntake (LENGTH('a) - bits) (to_bl ptr)})", "apply (simp add: power_overflow mask_eq_decr_exp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aligned_mask_range_cases:\n  \"\\<lbrakk> is_aligned (p :: 'a :: len word) n; is_aligned (p' :: 'a :: len word) n' \\<rbrakk>\n   \\<Longrightarrow> mask_range p n \\<inter> mask_range p' n' = {} \\<or>\n       mask_range p n \\<subseteq> mask_range p' n' \\<or>\n       mask_range p n \\<supseteq> mask_range p' n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; is_aligned p' n'\\<rbrakk>\n    \\<Longrightarrow> mask_range p n \\<inter> mask_range p' n' = {} \\<or>\n                      mask_range p n \\<subseteq> mask_range p' n' \\<or>\n                      mask_range p' n' \\<subseteq> mask_range p n", "apply (simp add: mask_range_to_bl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; is_aligned p' n'\\<rbrakk>\n    \\<Longrightarrow> {x. take (LENGTH('a) - n) (to_bl x) =\n                          take (LENGTH('a) - n) (to_bl p)} \\<inter>\n                      {x. take (LENGTH('a) - n') (to_bl x) =\n                          take (LENGTH('a) - n') (to_bl p')} =\n                      {} \\<or>\n                      {x. take (LENGTH('a) - n) (to_bl x) =\n                          take (LENGTH('a) - n) (to_bl p)}\n                      \\<subseteq> {x. take (LENGTH('a) - n') (to_bl x) =\ntake (LENGTH('a) - n') (to_bl p')} \\<or>\n                      {x. take (LENGTH('a) - n') (to_bl x) =\n                          take (LENGTH('a) - n') (to_bl p')}\n                      \\<subseteq> {x. take (LENGTH('a) - n) (to_bl x) =\ntake (LENGTH('a) - n) (to_bl p)}", "apply (rule Meson.disj_comm, rule disjCI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; is_aligned p' n';\n     {x. take (LENGTH('a) - n) (to_bl x) =\n         take (LENGTH('a) - n) (to_bl p)} \\<inter>\n     {x. take (LENGTH('a) - n') (to_bl x) =\n         take (LENGTH('a) - n') (to_bl p')} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> {x. take (LENGTH('a) - n) (to_bl x) =\n                          take (LENGTH('a) - n) (to_bl p)}\n                      \\<subseteq> {x. take (LENGTH('a) - n') (to_bl x) =\ntake (LENGTH('a) - n') (to_bl p')} \\<or>\n                      {x. take (LENGTH('a) - n') (to_bl x) =\n                          take (LENGTH('a) - n') (to_bl p')}\n                      \\<subseteq> {x. take (LENGTH('a) - n) (to_bl x) =\ntake (LENGTH('a) - n) (to_bl p)}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>is_aligned p n; is_aligned p' n';\n        take (LENGTH('a) - n') (to_bl x) =\n        take (LENGTH('a) - n') (to_bl p');\n        take (LENGTH('a) - n) (to_bl xa) = take (LENGTH('a) - n) (to_bl p);\n        take (LENGTH('a) - n) (to_bl x) \\<noteq>\n        take (LENGTH('a) - n) (to_bl p);\n        take (LENGTH('a) - n') (to_bl xa) \\<noteq>\n        take (LENGTH('a) - n') (to_bl p');\n        take (LENGTH('a) - n) (to_bl xb) = take (LENGTH('a) - n) (to_bl p);\n        take (LENGTH('a) - n') (to_bl xb) =\n        take (LENGTH('a) - n') (to_bl p')\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"(\\<exists>n''. LENGTH('a) - n = (LENGTH('a) - n') + n'')\n                    \\<or> (\\<exists>n''. LENGTH('a) - n' = (LENGTH('a) - n) + n'')\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>is_aligned p n; is_aligned p' n';\n        take (LENGTH('a) - n') (to_bl x) =\n        take (LENGTH('a) - n') (to_bl p');\n        take (LENGTH('a) - n) (to_bl xa) = take (LENGTH('a) - n) (to_bl p);\n        take (LENGTH('a) - n) (to_bl x) \\<noteq>\n        take (LENGTH('a) - n) (to_bl p);\n        take (LENGTH('a) - n') (to_bl xa) \\<noteq>\n        take (LENGTH('a) - n') (to_bl p');\n        take (LENGTH('a) - n) (to_bl xb) = take (LENGTH('a) - n) (to_bl p);\n        take (LENGTH('a) - n') (to_bl xb) =\n        take (LENGTH('a) - n') (to_bl p');\n        (\\<exists>n''. LENGTH('a) - n = LENGTH('a) - n' + n'') \\<or>\n        (\\<exists>n''. LENGTH('a) - n' = LENGTH('a) - n + n'')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x xa xb.\n       \\<lbrakk>is_aligned p n; is_aligned p' n';\n        take (LENGTH('a) - n') (to_bl x) =\n        take (LENGTH('a) - n') (to_bl p');\n        take (LENGTH('a) - n) (to_bl xa) = take (LENGTH('a) - n) (to_bl p);\n        take (LENGTH('a) - n) (to_bl x) \\<noteq>\n        take (LENGTH('a) - n) (to_bl p);\n        take (LENGTH('a) - n') (to_bl xa) \\<noteq>\n        take (LENGTH('a) - n') (to_bl p');\n        take (LENGTH('a) - n) (to_bl xb) = take (LENGTH('a) - n) (to_bl p);\n        take (LENGTH('a) - n') (to_bl xb) =\n        take (LENGTH('a) - n') (to_bl p')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n''.\n                             LENGTH('a) - n = LENGTH('a) - n' + n'') \\<or>\n                         (\\<exists>n''.\n                             LENGTH('a) - n' = LENGTH('a) - n + n'')", "apply (fastforce simp: take_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>is_aligned p n; is_aligned p' n';\n        take (LENGTH('a) - n') (to_bl x) =\n        take (LENGTH('a) - n') (to_bl p');\n        take (LENGTH('a) - n) (to_bl xa) = take (LENGTH('a) - n) (to_bl p);\n        take (LENGTH('a) - n) (to_bl x) \\<noteq>\n        take (LENGTH('a) - n) (to_bl p);\n        take (LENGTH('a) - n') (to_bl xa) \\<noteq>\n        take (LENGTH('a) - n') (to_bl p');\n        take (LENGTH('a) - n) (to_bl xb) = take (LENGTH('a) - n) (to_bl p);\n        take (LENGTH('a) - n') (to_bl xb) =\n        take (LENGTH('a) - n') (to_bl p')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n''.\n                             LENGTH('a) - n = LENGTH('a) - n' + n'') \\<or>\n                         (\\<exists>n''.\n                             LENGTH('a) - n' = LENGTH('a) - n + n'')", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aligned_mask_range_offset_subset:\n  assumes al: \"is_aligned (ptr :: 'a :: len word) sz\" and al': \"is_aligned x sz'\"\n  and szv: \"sz' \\<le> sz\"\n  and xsz: \"x < 2 ^ sz\"\n  shows \"mask_range (ptr+x) sz' \\<subseteq> mask_range ptr sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "using al"], ["proof (prove)\nusing this:\n  is_aligned ptr sz\n\ngoal (1 subgoal):\n 1. mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "proof (rule is_aligned_get_word_bits)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr sz; sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz\n 2. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "assume p0: \"ptr = 0\" and szv': \"LENGTH ('a) \\<le> sz\""], ["proof (state)\nthis:\n  ptr = 0\n  LENGTH('a) \\<le> sz\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr sz; sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz\n 2. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "then"], ["proof (chain)\npicking this:\n  ptr = 0\n  LENGTH('a) \\<le> sz", "have \"(2 ::'a word) ^ sz = 0\""], ["proof (prove)\nusing this:\n  ptr = 0\n  LENGTH('a) \\<le> sz\n\ngoal (1 subgoal):\n 1. 2 ^ sz = 0", "by simp"], ["proof (state)\nthis:\n  2 ^ sz = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr sz; sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz\n 2. \\<lbrakk>ptr = 0; LENGTH('a) \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "using p0"], ["proof (prove)\nusing this:\n  ptr = 0\n\ngoal (1 subgoal):\n 1. mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "by (simp add: \\<open>2 ^ sz = 0\\<close> mask_eq_decr_exp)"], ["proof (state)\nthis:\n  mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned ptr sz; sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned ptr sz; sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "assume szv': \"sz < LENGTH('a)\""], ["proof (state)\nthis:\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned ptr sz; sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "hence blah: \"2 ^ (sz - sz') < (2 :: nat) ^ LENGTH('a)\""], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ (sz - sz') < 2 ^ LENGTH('a)", "using szv"], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n  sz' \\<le> sz\n\ngoal (1 subgoal):\n 1. 2 ^ (sz - sz') < 2 ^ LENGTH('a)", "by auto"], ["proof (state)\nthis:\n  2 ^ (sz - sz') < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned ptr sz; sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "using szv szv'"], ["proof (prove)\nusing this:\n  sz' \\<le> sz\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sz' \\<le> sz; sz < LENGTH('a);\n     ptr + x \\<le> ptr + x + mask sz'\\<rbrakk>\n    \\<Longrightarrow> ptr \\<le> ptr + x\n 2. \\<lbrakk>sz' \\<le> sz; sz < LENGTH('a);\n     ptr + x \\<le> ptr + x + mask sz'\\<rbrakk>\n    \\<Longrightarrow> ptr + x + mask sz' \\<le> ptr + mask sz", "using al assms(4) is_aligned_no_wrap'"], ["proof (prove)\nusing this:\n  is_aligned ptr sz\n  x < 2 ^ sz\n  \\<lbrakk>is_aligned ?ptr ?sz; ?off < 2 ^ ?sz\\<rbrakk>\n  \\<Longrightarrow> ?ptr \\<le> ?ptr + ?off\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sz' \\<le> sz; sz < LENGTH('a);\n     ptr + x \\<le> ptr + x + mask sz'\\<rbrakk>\n    \\<Longrightarrow> ptr \\<le> ptr + x\n 2. \\<lbrakk>sz' \\<le> sz; sz < LENGTH('a);\n     ptr + x \\<le> ptr + x + mask sz'\\<rbrakk>\n    \\<Longrightarrow> ptr + x + mask sz' \\<le> ptr + mask sz", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sz' \\<le> sz; sz < LENGTH('a);\n     ptr + x \\<le> ptr + x + mask sz'\\<rbrakk>\n    \\<Longrightarrow> ptr + x + mask sz' \\<le> ptr + mask sz", "apply (simp only: flip: add_diff_eq add_mask_fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sz' \\<le> sz; sz < LENGTH('a);\n     ptr + x \\<le> ptr + x + (2 ^ sz' - 1)\\<rbrakk>\n    \\<Longrightarrow> ptr + x + (2 ^ sz' - 1) \\<le> ptr + (2 ^ sz - 1)", "apply (subst add.assoc, rule word_plus_mono_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sz' \\<le> sz; sz < LENGTH('a);\n     ptr + x \\<le> ptr + x + (2 ^ sz' - 1)\\<rbrakk>\n    \\<Longrightarrow> x + (2 ^ sz' - 1) \\<le> 2 ^ sz - 1\n 2. \\<lbrakk>sz' \\<le> sz; sz < LENGTH('a);\n     ptr + x \\<le> ptr + x + (2 ^ sz' - 1)\\<rbrakk>\n    \\<Longrightarrow> ptr \\<le> ptr + (2 ^ sz - 1)", "using al' is_aligned_add_less_t2n xsz"], ["proof (prove)\nusing this:\n  is_aligned x sz'\n  \\<lbrakk>is_aligned ?p ?n; ?d < 2 ^ ?n; ?n \\<le> ?m; ?p < 2 ^ ?m\\<rbrakk>\n  \\<Longrightarrow> ?p + ?d < 2 ^ ?m\n  x < 2 ^ sz\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sz' \\<le> sz; sz < LENGTH('a);\n     ptr + x \\<le> ptr + x + (2 ^ sz' - 1)\\<rbrakk>\n    \\<Longrightarrow> x + (2 ^ sz' - 1) \\<le> 2 ^ sz - 1\n 2. \\<lbrakk>sz' \\<le> sz; sz < LENGTH('a);\n     ptr + x \\<le> ptr + x + (2 ^ sz' - 1)\\<rbrakk>\n    \\<Longrightarrow> ptr \\<le> ptr + (2 ^ sz - 1)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sz' \\<le> sz; sz < LENGTH('a);\n     ptr + x \\<le> ptr + x + (2 ^ sz' - 1)\\<rbrakk>\n    \\<Longrightarrow> ptr \\<le> ptr + (2 ^ sz - 1)", "apply (simp add: field_simps szv al is_aligned_no_overflow)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mask_range (ptr + x) sz' \\<subseteq> mask_range ptr sz\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aligned_mask_ranges_disjoint:\n  \"\\<lbrakk> is_aligned (p :: 'a :: len word) n; is_aligned (p' :: 'a :: len word) n';\n     p AND NOT(mask n') \\<noteq> p'; p' AND NOT(mask n) \\<noteq> p \\<rbrakk>\n   \\<Longrightarrow> mask_range p n \\<inter> mask_range p' n' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; is_aligned p' n';\n     p AND NOT (mask n') \\<noteq> p';\n     p' AND NOT (mask n) \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> mask_range p n \\<inter> mask_range p' n' = {}", "using aligned_mask_range_cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_aligned ?p ?n; is_aligned ?p' ?n'\\<rbrakk>\n  \\<Longrightarrow> mask_range ?p ?n \\<inter> mask_range ?p' ?n' = {} \\<or>\n                    mask_range ?p ?n \\<subseteq> mask_range ?p' ?n' \\<or>\n                    mask_range ?p' ?n' \\<subseteq> mask_range ?p ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; is_aligned p' n';\n     p AND NOT (mask n') \\<noteq> p';\n     p' AND NOT (mask n) \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> mask_range p n \\<inter> mask_range p' n' = {}", "by (auto simp: neg_mask_in_mask_range)"], ["", "lemma aligned_mask_ranges_disjoint2:\n  \"\\<lbrakk> is_aligned p n; is_aligned ptr bits; n \\<ge> m; n < size p; m \\<le> bits;\n     (\\<forall>y < 2 ^ (n - m). p + (y << m) \\<notin> mask_range ptr bits) \\<rbrakk>\n   \\<Longrightarrow> mask_range p n \\<inter> mask_range ptr bits = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; is_aligned ptr bits; m \\<le> n; n < size p;\n     m \\<le> bits;\n     \\<forall>y<2 ^ (n - m).\n        p + (y << m) \\<notin> mask_range ptr bits\\<rbrakk>\n    \\<Longrightarrow> mask_range p n \\<inter> mask_range ptr bits = {}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned p n; is_aligned ptr bits; m \\<le> n; n < size p;\n        m \\<le> bits;\n        \\<forall>y<2 ^ (n - m). p + (y << m) \\<notin> mask_range ptr bits;\n        x \\<in> mask_range p n; x \\<in> mask_range ptr bits\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "apply (simp only: flip: neg_mask_in_mask_range)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned p n; is_aligned ptr bits; m \\<le> n; n < size p;\n        m \\<le> bits;\n        \\<forall>y<2 ^ (n - m).\n           p + (y << m) AND NOT (mask bits) \\<noteq> ptr;\n        x AND NOT (mask n) = p; x AND NOT (mask bits) = ptr\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "apply (drule_tac x=\"x AND mask n >> m\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_aligned p n; is_aligned ptr bits; m \\<le> n; n < size p;\n        m \\<le> bits; x AND NOT (mask n) = p; x AND NOT (mask bits) = ptr;\n        x AND mask n >> m < 2 ^ (n - m) \\<longrightarrow>\n        p + (x AND mask n >> m << m) AND NOT (mask bits) \\<noteq>\n        ptr\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "apply (clarsimp simp: and_mask_less_size wsst_TYs shiftr_less_t2n multiple_mask_trivia neg_mask_twice\n                        word_bw_assocs max_absorb2 shiftr_shiftl1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_clz_sint_upper[simp]:\n  \"LENGTH('a) \\<ge> 3 \\<Longrightarrow> sint (of_nat (word_clz (w :: 'a :: len word)) :: 'a sword) \\<le> int (LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> LENGTH('a) \\<Longrightarrow>\n    sint (word_of_nat (word_clz w)) \\<le> int LENGTH('a)", "using word_clz_max [of w]"], ["proof (prove)\nusing this:\n  word_clz w \\<le> size w\n\ngoal (1 subgoal):\n 1. 3 \\<le> LENGTH('a) \\<Longrightarrow>\n    sint (word_of_nat (word_clz w)) \\<le> int LENGTH('a)", "apply (simp add: word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> signed_take_bit (LENGTH('a) - Suc 0)\n                       (int (word_clz w))\n                      \\<le> int LENGTH('a)", "apply (subst signed_take_bit_int_eq_self)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - Suc 0)) \\<le> int (word_clz w)\n 2. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> int (word_clz w) < 2 ^ (LENGTH('a) - Suc 0)\n 3. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> int (word_clz w) \\<le> int LENGTH('a)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (LENGTH('a) - Suc 0)) \\<le> int (word_clz w)\n 2. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_clz w < 2 ^ (LENGTH('a) - Suc 0)", "apply (metis negative_zle of_nat_numeral semiring_1_class.of_nat_power)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_clz w < 2 ^ (LENGTH('a) - Suc 0)", "apply (drule small_powers_of_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>word_clz w \\<le> LENGTH('a);\n     LENGTH('a) < 2 ^ (LENGTH('a) - 1)\\<rbrakk>\n    \\<Longrightarrow> word_clz w < 2 ^ (LENGTH('a) - Suc 0)", "apply (erule le_less_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow>\n    LENGTH('a) < 2 ^ (LENGTH('a) - Suc 0)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_clz_sint_lower[simp]:\n  \"LENGTH('a) \\<ge> 3\n   \\<Longrightarrow> - sint (of_nat (word_clz (w :: 'a :: len word)) :: 'a signed word) \\<le> int (LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> LENGTH('a) \\<Longrightarrow>\n    - sint (word_of_nat (word_clz w)) \\<le> int LENGTH('a)", "apply (subst sint_eq_uint)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 3 \\<le> LENGTH('a) \\<Longrightarrow>\n    \\<not> msb (word_of_nat (word_clz w))\n 2. 3 \\<le> LENGTH('a) \\<Longrightarrow>\n    - uint (word_of_nat (word_clz w)) \\<le> int LENGTH('a)", "using word_clz_max [of w]"], ["proof (prove)\nusing this:\n  word_clz w \\<le> size w\n\ngoal (2 subgoals):\n 1. 3 \\<le> LENGTH('a) \\<Longrightarrow>\n    \\<not> msb (word_of_nat (word_clz w))\n 2. 3 \\<le> LENGTH('a) \\<Longrightarrow>\n    - uint (word_of_nat (word_clz w)) \\<le> int LENGTH('a)", "apply (simp_all add: word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> msb (word_of_nat (word_clz w))", "apply (rule not_msb_from_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_of_nat (word_clz w) < 2 ^ (LENGTH('a signed) - 1)", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> take_bit LENGTH('a) (word_clz w)\n                      < 2 ^ (LENGTH('a) - Suc 0)", "apply (subst take_bit_nat_eq_self)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_clz w < 2 ^ LENGTH('a)\n 2. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_clz w < 2 ^ (LENGTH('a) - Suc 0)", "apply (simp add: le_less_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>3 \\<le> LENGTH('a); word_clz w \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> word_clz w < 2 ^ (LENGTH('a) - Suc 0)", "apply (drule small_powers_of_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>word_clz w \\<le> LENGTH('a);\n     LENGTH('a) < 2 ^ (LENGTH('a) - 1)\\<rbrakk>\n    \\<Longrightarrow> word_clz w < 2 ^ (LENGTH('a) - Suc 0)", "apply (erule le_less_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) < 2 ^ (LENGTH('a) - 1) \\<Longrightarrow>\n    LENGTH('a) < 2 ^ (LENGTH('a) - Suc 0)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_range_subsetD:\n  \"\\<lbrakk> p' \\<in> mask_range p n; x' \\<in> mask_range p' n'; n' \\<le> n; is_aligned p n; is_aligned p' n' \\<rbrakk> \\<Longrightarrow>\n   x' \\<in> mask_range p n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p' \\<in> mask_range p n; x' \\<in> mask_range p' n'; n' \\<le> n;\n     is_aligned p n; is_aligned p' n'\\<rbrakk>\n    \\<Longrightarrow> x' \\<in> mask_range p n", "using aligned_mask_step"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n' \\<le> ?n; ?p' \\<le> ?p + mask ?n; is_aligned ?p ?n;\n   is_aligned ?p' ?n'\\<rbrakk>\n  \\<Longrightarrow> ?p' + mask ?n' \\<le> ?p + mask ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p' \\<in> mask_range p n; x' \\<in> mask_range p' n'; n' \\<le> n;\n     is_aligned p n; is_aligned p' n'\\<rbrakk>\n    \\<Longrightarrow> x' \\<in> mask_range p n", "by fastforce"], ["", "lemma nasty_split_lt:\n  \"\\<lbrakk> (x :: 'a:: len word) < 2 ^ (m - n); n \\<le> m; m < LENGTH('a::len) \\<rbrakk>\n     \\<Longrightarrow> x * 2 ^ n + (2 ^ n - 1) \\<le> 2 ^ m - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x * 2 ^ n + (2 ^ n - 1) \\<le> 2 ^ m - 1", "apply (simp only: add_diff_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x * 2 ^ n + 2 ^ n - 1 \\<le> 2 ^ m - 1", "apply (subst mult_1[symmetric], subst distrib_right[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> 2 ^ m - 1", "apply (rule word_sub_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n \\<le> 2 ^ m\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (rule order_trans)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n \\<le> ?y5\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> ?y5 \\<le> 2 ^ m\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 5. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (rule word_mult_le_mono1)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x + 1 \\<le> ?j8\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ n\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat ?j8 * unat (2 ^ n) < 2 ^ LENGTH('a)\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> ?j8 * 2 ^ n \\<le> 2 ^ m\n 5. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 6. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 7. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (rule inc_le)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x < ?j8\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ n\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat ?j8 * unat (2 ^ n) < 2 ^ LENGTH('a)\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> ?j8 * 2 ^ n \\<le> 2 ^ m\n 5. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 6. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 7. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply assumption"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 0 < 2 ^ n\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ (m - n)) * unat (2 ^ n) < 2 ^ LENGTH('a)\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (m - n) * 2 ^ n \\<le> 2 ^ m\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 5. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 6. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (subst word_neq_0_conv[symmetric])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n \\<noteq> 0\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ (m - n)) * unat (2 ^ n) < 2 ^ LENGTH('a)\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (m - n) * 2 ^ n \\<le> 2 ^ m\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 5. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 6. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (rule power_not_zero)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> n < LENGTH('a)\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ (m - n)) * unat (2 ^ n) < 2 ^ LENGTH('a)\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (m - n) * 2 ^ n \\<le> 2 ^ m\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 5. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 6. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ (m - n)) * unat (2 ^ n) < 2 ^ LENGTH('a)\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (m - n) * 2 ^ n \\<le> 2 ^ m\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 5. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (subst unat_power_lower, simp)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (m - n) * 2 ^ n < 2 ^ LENGTH('a)\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (m - n) * 2 ^ n \\<le> 2 ^ m\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 5. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (subst power_add[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (m - n + n) < 2 ^ LENGTH('a)\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (m - n) * 2 ^ n \\<le> 2 ^ m\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 5. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (rule power_strict_increasing)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m - n + n < LENGTH('a)\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 < 2\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (m - n) * 2 ^ n \\<le> 2 ^ m\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 5. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 6. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 < 2\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (m - n) * 2 ^ n \\<le> 2 ^ m\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 5. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (m - n) * 2 ^ n \\<le> 2 ^ m\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (subst power_add[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (m - n + n) \\<le> 2 ^ m\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n - 1 \\<le> (x + 1) * 2 ^ n\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (rule word_sub_1_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + 1) * 2 ^ n \\<noteq> 0\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (subst mult.commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n * (x + 1) \\<noteq> 0\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (subst shiftl_t2n[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x + 1 << n \\<noteq> 0\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (rule word_shift_nonzero)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x + 1 \\<le> 2 ^ ?m56\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> ?m56 + n < LENGTH('a)\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x + 1 \\<noteq> 0\n 4. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (erule inc_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m - n + n < LENGTH('a)\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x + 1 \\<noteq> 0\n 3. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x + 1 \\<noteq> 0\n 2. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (unat_arith)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply (drule word_power_less_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ (m - n); n \\<le> m; 2 ^ m - 1 < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nasty_split_less:\n  \"\\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a::len); x < 2 ^ (nm - n)\\<rbrakk>\n   \\<Longrightarrow> (x :: 'a word) * 2 ^ n + (2 ^ m - 1) < 2 ^ nm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x < 2 ^ (nm - n)\\<rbrakk>\n    \\<Longrightarrow> x * 2 ^ n + (2 ^ m - 1) < 2 ^ nm", "apply (simp only: word_less_sub_le[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x * 2 ^ n + (2 ^ m - 1) \\<le> 2 ^ nm - 1", "apply (rule order_trans [OF _ nasty_split_lt])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x * 2 ^ n + (2 ^ m - 1)\n                      \\<le> ?x27 * 2 ^ ?n27 + (2 ^ ?n27 - 1)\n 2. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> ?x27 < 2 ^ (nm - ?n27)\n 3. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> ?n27 \\<le> nm\n 4. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> nm < LENGTH('a)", "apply (rule word_plus_mono_right)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ n - 1\n 2. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x * 2 ^ n \\<le> x * 2 ^ n + (2 ^ n - 1)\n 3. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ (nm - n)\n 4. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> n \\<le> nm\n 5. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> nm < LENGTH('a)", "apply (rule word_sub_mono)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m \\<le> 2 ^ n\n 2. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 3. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m\n 4. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n - 1 \\<le> 2 ^ n\n 5. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x * 2 ^ n \\<le> x * 2 ^ n + (2 ^ n - 1)\n 6. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ (nm - n)\n 7. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> n \\<le> nm\n 8. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> nm < LENGTH('a)", "apply (simp add: word_le_nat_alt)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1\n 2. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m\n 3. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n - 1 \\<le> 2 ^ n\n 4. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x * 2 ^ n \\<le> x * 2 ^ n + (2 ^ n - 1)\n 5. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ (nm - n)\n 6. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> n \\<le> nm\n 7. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> nm < LENGTH('a)", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 2 ^ m - 1 \\<le> 2 ^ m\n 2. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n - 1 \\<le> 2 ^ n\n 3. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x * 2 ^ n \\<le> x * 2 ^ n + (2 ^ n - 1)\n 4. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ (nm - n)\n 5. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> n \\<le> nm\n 6. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> nm < LENGTH('a)", "apply (simp add: word_sub_1_le[OF power_not_zero])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n - 1 \\<le> 2 ^ n\n 2. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x * 2 ^ n \\<le> x * 2 ^ n + (2 ^ n - 1)\n 3. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ (nm - n)\n 4. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> n \\<le> nm\n 5. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> nm < LENGTH('a)", "apply (simp add: word_sub_1_le[OF power_not_zero])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x * 2 ^ n \\<le> x * 2 ^ n + (2 ^ n - 1)\n 2. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ (nm - n)\n 3. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> n \\<le> nm\n 4. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> nm < LENGTH('a)", "apply (rule is_aligned_no_wrap')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> is_aligned (x * 2 ^ n) ?sz41\n 2. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n - 1 < 2 ^ ?sz41\n 3. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ (nm - n)\n 4. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> n \\<le> nm\n 5. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> nm < LENGTH('a)", "apply (rule is_aligned_mult_triv2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n - 1 < 2 ^ n\n 2. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ (nm - n)\n 3. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> n \\<le> nm\n 4. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> nm < LENGTH('a)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ (nm - n)\n 2. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> n \\<le> nm\n 3. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> nm < LENGTH('a)", "apply (erule order_le_less_trans, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> n \\<le> nm\n 2. \\<lbrakk>m \\<le> n; n \\<le> nm; nm < LENGTH('a);\n     x \\<le> 2 ^ (nm - n) - 1\\<rbrakk>\n    \\<Longrightarrow> nm < LENGTH('a)", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma add_mult_in_mask_range:\n  \"\\<lbrakk> is_aligned (base :: 'a :: len word) n; n < LENGTH('a); bits \\<le> n; x < 2 ^ (n - bits) \\<rbrakk>\n   \\<Longrightarrow> base + x * 2^bits \\<in> mask_range base n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned base n; n < LENGTH('a); bits \\<le> n;\n     x < 2 ^ (n - bits)\\<rbrakk>\n    \\<Longrightarrow> base + x * 2 ^ bits \\<in> mask_range base n", "by (simp add: is_aligned_no_wrap' mask_2pm1 nasty_split_lt word_less_power_trans2\n                word_plus_mono_right)"], ["", "lemma from_to_bool_last_bit:\n  \"from_bool (to_bool (x AND 1)) = x AND 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_bool (to_bool (x AND 1)) = x AND 1", "by (metis from_bool_to_bool_iff word_and_1)"], ["", "lemma sint_ctz:\n  \"LENGTH('a) > 2\n   \\<Longrightarrow> 0 \\<le> sint (of_nat (word_ctz (x :: 'a :: len word)) :: 'a signed word)\n        \\<and> sint (of_nat (word_ctz x) :: 'a signed word) \\<le> int (LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < LENGTH('a) \\<Longrightarrow>\n    0 \\<le> sint (word_of_nat (word_ctz x)) \\<and>\n    sint (word_of_nat (word_ctz x)) \\<le> int LENGTH('a)", "apply (subgoal_tac \"LENGTH('a) < 2 ^ (LENGTH('a) - 1)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 < LENGTH('a); LENGTH('a) < 2 ^ (LENGTH('a) - 1)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> sint (word_of_nat (word_ctz x)) \\<and>\n                      sint (word_of_nat (word_ctz x)) \\<le> int LENGTH('a)\n 2. 2 < LENGTH('a) \\<Longrightarrow> LENGTH('a) < 2 ^ (LENGTH('a) - 1)", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>2 < LENGTH('a); LENGTH('a) < 2 ^ (LENGTH('a) - 1)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> sint (word_of_nat (word_ctz x))\n 2. \\<lbrakk>2 < LENGTH('a); LENGTH('a) < 2 ^ (LENGTH('a) - 1)\\<rbrakk>\n    \\<Longrightarrow> sint (word_of_nat (word_ctz x)) \\<le> int LENGTH('a)\n 3. 2 < LENGTH('a) \\<Longrightarrow> LENGTH('a) < 2 ^ (LENGTH('a) - 1)", "apply (metis len_signed order_le_less_trans sint_of_nat_ge_zero word_ctz_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 < LENGTH('a); LENGTH('a) < 2 ^ (LENGTH('a) - 1)\\<rbrakk>\n    \\<Longrightarrow> sint (word_of_nat (word_ctz x)) \\<le> int LENGTH('a)\n 2. 2 < LENGTH('a) \\<Longrightarrow> LENGTH('a) < 2 ^ (LENGTH('a) - 1)", "apply (metis int_eq_sint len_signed sint_of_nat_le word_ctz_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < LENGTH('a) \\<Longrightarrow> LENGTH('a) < 2 ^ (LENGTH('a) - 1)", "using small_powers_of_2 [of \\<open>LENGTH('a)\\<close>]"], ["proof (prove)\nusing this:\n  3 \\<le> LENGTH('a) \\<Longrightarrow> LENGTH('a) < 2 ^ (LENGTH('a) - 1)\n\ngoal (1 subgoal):\n 1. 2 < LENGTH('a) \\<Longrightarrow> LENGTH('a) < 2 ^ (LENGTH('a) - 1)", "by simp"], ["", "lemma unat_of_nat_word_log2:\n  \"LENGTH('a) < 2 ^ LENGTH('b)\n   \\<Longrightarrow> unat (of_nat (word_log2 (n :: 'a :: len word)) :: 'b :: len word) = word_log2 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) < 2 ^ LENGTH('b) \\<Longrightarrow>\n    unat (word_of_nat (word_log2 n)) = word_log2 n", "by (metis less_trans unat_of_nat_eq word_log2_max word_size)"], ["", "lemma aligned_mask_diff:\n  \"\\<lbrakk> is_aligned (dest :: 'a :: len word) bits; is_aligned (ptr :: 'a :: len word) sz;\n     bits \\<le> sz; sz < LENGTH('a); dest < ptr \\<rbrakk>\n   \\<Longrightarrow> mask bits + dest < ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr\\<rbrakk>\n    \\<Longrightarrow> mask bits + dest < ptr", "apply (frule_tac p' = ptr in aligned_mask_range_cases, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr;\n     mask_range dest bits \\<inter> mask_range ptr sz = {} \\<or>\n     mask_range dest bits \\<subseteq> mask_range ptr sz \\<or>\n     mask_range ptr sz \\<subseteq> mask_range dest bits\\<rbrakk>\n    \\<Longrightarrow> mask bits + dest < ptr", "apply (elim disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr;\n     mask_range dest bits \\<inter> mask_range ptr sz = {}\\<rbrakk>\n    \\<Longrightarrow> mask bits + dest < ptr\n 2. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr;\n     mask_range dest bits \\<subseteq> mask_range ptr sz\\<rbrakk>\n    \\<Longrightarrow> mask bits + dest < ptr\n 3. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr;\n     mask_range ptr sz \\<subseteq> mask_range dest bits\\<rbrakk>\n    \\<Longrightarrow> mask bits + dest < ptr", "apply (drule_tac is_aligned_no_overflow_mask, simp)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>bits \\<le> sz; sz < LENGTH('a); dest < ptr;\n     dest \\<le> ptr + mask sz \\<longrightarrow>\n     \\<not> ptr \\<le> dest + mask bits;\n     dest \\<le> dest + mask bits; ptr \\<le> ptr + mask sz\\<rbrakk>\n    \\<Longrightarrow> mask bits + dest < ptr\n 2. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr;\n     mask_range dest bits \\<subseteq> mask_range ptr sz\\<rbrakk>\n    \\<Longrightarrow> mask bits + dest < ptr\n 3. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr;\n     mask_range ptr sz \\<subseteq> mask_range dest bits\\<rbrakk>\n    \\<Longrightarrow> mask bits + dest < ptr", "apply (simp add: algebra_split_simps word_le_not_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr;\n     mask_range dest bits \\<subseteq> mask_range ptr sz\\<rbrakk>\n    \\<Longrightarrow> mask bits + dest < ptr\n 2. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr;\n     mask_range ptr sz \\<subseteq> mask_range dest bits\\<rbrakk>\n    \\<Longrightarrow> mask bits + dest < ptr", "apply (drule is_aligned_no_overflow_mask; fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr;\n     mask_range ptr sz \\<subseteq> mask_range dest bits\\<rbrakk>\n    \\<Longrightarrow> mask bits + dest < ptr", "apply (simp add: is_aligned_weaken algebra_split_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr;\n     ptr \\<le> ptr + mask sz \\<longrightarrow>\n     dest \\<le> ptr \\<and> ptr + mask sz \\<le> dest + mask bits\\<rbrakk>\n    \\<Longrightarrow> dest + mask bits < ptr", "apply (auto simp add: not_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr; ptr + mask sz < ptr\\<rbrakk>\n    \\<Longrightarrow> dest + mask bits < ptr\n 2. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr; dest \\<le> ptr;\n     ptr + mask sz \\<le> dest + mask bits\\<rbrakk>\n    \\<Longrightarrow> dest + mask bits < ptr", "using is_aligned_no_overflow_mask leD"], ["proof (prove)\nusing this:\n  is_aligned ?x ?n \\<Longrightarrow> ?x \\<le> ?x + mask ?n\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr; ptr + mask sz < ptr\\<rbrakk>\n    \\<Longrightarrow> dest + mask bits < ptr\n 2. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr; dest \\<le> ptr;\n     ptr + mask sz \\<le> dest + mask bits\\<rbrakk>\n    \\<Longrightarrow> dest + mask bits < ptr", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned dest bits; is_aligned ptr sz; bits \\<le> sz;\n     sz < LENGTH('a); dest < ptr; dest \\<le> ptr;\n     ptr + mask sz \\<le> dest + mask bits\\<rbrakk>\n    \\<Longrightarrow> dest + mask bits < ptr", "apply (meson aligned_add_mask_less_eq is_aligned_weaken le_less_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}