{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Enumeration_Word.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma length_word_enum: \"length (enum :: 'a :: len word list) = 2 ^ LENGTH('a)\"", "lemma fromEnum_unat[simp]: \"fromEnum (x :: 'a::len word) = unat x\"", "lemma toEnum_of_nat[simp]: \"n < 2 ^ LENGTH('a) \\<Longrightarrow> (toEnum n :: 'a :: len word) = of_nat n\"", "lemma maxBound_word:\n  \"(maxBound::'a::len word) = -1\"", "lemma minBound_word:\n  \"(minBound::'a::len word) = 0\"", "lemma maxBound_max_word:\n  \"(maxBound::'a::len word) = max_word\"", "lemma leq_maxBound [simp]:\n  \"(x::'a::len word) \\<le> maxBound\"", "lemma upto_enum_red':\n  assumes lt: \"1 \\<le> X\"\n  shows \"[(0::'a :: len word) .e. X - 1] =  map of_nat [0 ..< unat X]\"", "lemma upto_enum_red2:\n  assumes szv: \"sz < LENGTH('a :: len)\"\n  shows \"[(0:: 'a :: len word) .e. 2 ^ sz - 1] =\n  map of_nat [0 ..< 2 ^ sz]\"", "lemma upto_enum_step_red:\n  assumes szv: \"sz < LENGTH('a)\"\n  and   usszv: \"us \\<le> sz\"\n  shows \"[0 :: 'a :: len word , 2 ^ us .e. 2 ^ sz - 1] =\n  map (\\<lambda>x. of_nat x * 2 ^ us) [0 ..< 2 ^ (sz - us)]\"", "lemma upto_enum_word:\n  \"[x .e. y] = map of_nat [unat x ..< Suc (unat y)]\"", "lemma word_upto_Cons_eq:\n  \"x < y \\<Longrightarrow> [x::'a::len word .e. y] = x # [x + 1 .e. y]\"", "lemma distinct_enum_upto:\n  \"distinct [(0 :: 'a::len word) .e. b]\"", "lemma upto_enum_set_conv [simp]:\n  fixes a :: \"'a :: len word\"\n  shows \"set [a .e. b] = {x. a \\<le> x \\<and> x \\<le> b}\"", "lemma upto_enum_less:\n  assumes xin: \"x \\<in> set [(a::'a::len word).e.2 ^ n - 1]\"\n  and     nv:  \"n < LENGTH('a::len)\"\n  shows   \"x < 2 ^ n\"", "lemma upto_enum_len_less:\n  \"\\<lbrakk> n \\<le> length [a, b .e. c]; n \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> a \\<le> c\"", "lemma length_upto_enum_step:\n  fixes x :: \"'a :: len word\"\n  shows \"x \\<le> z \\<Longrightarrow> length [x , y .e. z] = (unat ((z - x) div (y - x))) + 1\"", "lemma map_length_unfold_one:\n  fixes x :: \"'a::len word\"\n  assumes xv: \"Suc (unat x) < 2 ^ LENGTH('a)\"\n  and     ax: \"a < x\"\n  shows   \"map f [a .e. x] = f a # map f [a + 1 .e. x]\"", "lemma upto_enum_set_conv2:\n  fixes a :: \"'a::len word\"\n  shows \"set [a .e. b] = {a .. b}\"", "lemma length_upto_enum [simp]:\n  fixes a :: \"'a :: len word\"\n  shows \"length [a .e. b] = Suc (unat b) - unat a\"", "lemma length_upto_enum_cases:\n  fixes a :: \"'a::len word\"\n  shows \"length [a .e. b] = (if a \\<le> b then Suc (unat b) - unat a else 0)\"", "lemma length_upto_enum_less_one:\n  \"\\<lbrakk>a \\<le> b; b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> length [a .e. b - 1] = unat (b - a)\"", "lemma drop_upto_enum:\n  \"drop (unat n) [0 .e. m] = [n .e. m]\"", "lemma distinct_enum_upto' [simp]:\n  \"distinct [a::'a::len word .e. b]\"", "lemma length_interval:\n  \"\\<lbrakk>set xs = {x. (a::'a::len word) \\<le> x \\<and> x \\<le> b}; distinct xs\\<rbrakk>\n  \\<Longrightarrow> length xs = Suc (unat b) - unat a\"", "lemma enum_word_div:\n  fixes v :: \"'a :: len word\" shows\n  \"\\<exists>xs ys. enum = xs @ [v] @ ys\n             \\<and> (\\<forall>x \\<in> set xs. x < v)\n             \\<and> (\\<forall>y \\<in> set ys. v < y)\""], "translations": [["", "lemma length_word_enum: \"length (enum :: 'a :: len word list) = 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length enum = 2 ^ LENGTH('a)", "by (simp add: enum_word_def)"], ["", "lemma fromEnum_unat[simp]: \"fromEnum (x :: 'a::len word) = unat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "have \"enum ! the_index enum x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum ! the_index enum x = x", "by (auto intro: nth_the_index)"], ["proof (state)\nthis:\n  enum ! the_index enum x = x\n\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "moreover"], ["proof (state)\nthis:\n  enum ! the_index enum x = x\n\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "have \"the_index enum x < length (enum::'a::len word list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_index enum x < length enum", "by (auto intro: the_index_bounded)"], ["proof (state)\nthis:\n  the_index enum x < length enum\n\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "moreover"], ["proof (state)\nthis:\n  the_index enum x < length enum\n\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "{"], ["proof (state)\nthis:\n  the_index enum x < length enum\n\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "assume \"of_nat y = x\""], ["proof (state)\nthis:\n  word_of_nat y = x\n\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "moreover"], ["proof (state)\nthis:\n  word_of_nat y = x\n\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "assume \"y < 2 ^ LENGTH('a)\""], ["proof (state)\nthis:\n  y < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "ultimately"], ["proof (chain)\npicking this:\n  word_of_nat y = x\n  y < 2 ^ LENGTH('a)", "have \"y = unat x\""], ["proof (prove)\nusing this:\n  word_of_nat y = x\n  y < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. y = unat x", "using of_nat_inverse"], ["proof (prove)\nusing this:\n  word_of_nat y = x\n  y < 2 ^ LENGTH('a)\n  \\<lbrakk>word_of_nat ?r = ?a; ?r < 2 ^ LENGTH(?'a)\\<rbrakk>\n  \\<Longrightarrow> unat ?a = ?r\n\ngoal (1 subgoal):\n 1. y = unat x", "by fastforce"], ["proof (state)\nthis:\n  y = unat x\n\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "}"], ["proof (state)\nthis:\n  \\<lbrakk>word_of_nat ?y2 = x; ?y2 < 2 ^ LENGTH('a)\\<rbrakk>\n  \\<Longrightarrow> ?y2 = unat x\n\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "ultimately"], ["proof (chain)\npicking this:\n  enum ! the_index enum x = x\n  the_index enum x < length enum\n  \\<lbrakk>word_of_nat ?y2 = x; ?y2 < 2 ^ LENGTH('a)\\<rbrakk>\n  \\<Longrightarrow> ?y2 = unat x", "show ?thesis"], ["proof (prove)\nusing this:\n  enum ! the_index enum x = x\n  the_index enum x < length enum\n  \\<lbrakk>word_of_nat ?y2 = x; ?y2 < 2 ^ LENGTH('a)\\<rbrakk>\n  \\<Longrightarrow> ?y2 = unat x\n\ngoal (1 subgoal):\n 1. fromEnum x = unat x", "by (simp add: fromEnum_def enum_word_def)"], ["proof (state)\nthis:\n  fromEnum x = unat x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma toEnum_of_nat[simp]: \"n < 2 ^ LENGTH('a) \\<Longrightarrow> (toEnum n :: 'a :: len word) = of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 2 ^ LENGTH('a) \\<Longrightarrow> toEnum n = word_of_nat n", "by (simp add: toEnum_def length_word_enum enum_word_def)"], ["", "instantiation word :: (len) enumeration_both\nbegin"], ["", "definition\n  enum_alt_word_def: \"enum_alt \\<equiv> alt_from_ord (enum :: ('a :: len) word list)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a word, enumeration_both_class)", "by (intro_classes, simp add: enum_alt_word_def)"], ["", "end"], ["", "definition\n  upto_enum_step :: \"('a :: len) word \\<Rightarrow> 'a word \\<Rightarrow> 'a word \\<Rightarrow> 'a word list\" (\"[_ , _ .e. _]\")\nwhere\n  \"upto_enum_step a b c \\<equiv>\n      if c < a then [] else map (\\<lambda>x. a + x * (b - a)) [0 .e. (c - a) div (b - a)]\""], ["", "(* in the wraparound case, bad things happen. *)"], ["", "lemma maxBound_word:\n  \"(maxBound::'a::len word) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxBound = - 1", "by (simp add: maxBound_def enum_word_def last_map of_nat_diff)"], ["", "lemma minBound_word:\n  \"(minBound::'a::len word) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minBound = 0", "by (simp add: minBound_def enum_word_def upt_conv_Cons)"], ["", "lemma maxBound_max_word:\n  \"(maxBound::'a::len word) = max_word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxBound = - 1", "by (fact maxBound_word)"], ["", "lemma leq_maxBound [simp]:\n  \"(x::'a::len word) \\<le> maxBound\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> maxBound", "by (simp add: maxBound_max_word)"], ["", "lemma upto_enum_red':\n  assumes lt: \"1 \\<le> X\"\n  shows \"[(0::'a :: len word) .e. X - 1] =  map of_nat [0 ..< unat X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0 .e. X - 1] = map word_of_nat [0..<unat X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [0 .e. X - 1] = map word_of_nat [0..<unat X]", "have lt': \"unat X < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat X < 2 ^ LENGTH('a)", "by (rule unat_lt2p)"], ["proof (state)\nthis:\n  unat X < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. [0 .e. X - 1] = map word_of_nat [0..<unat X]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. [0 .e. X - 1] = map word_of_nat [0..<unat X]", "apply (subst upto_enum_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map toEnum [fromEnum 0..<Suc (fromEnum (X - 1))] =\n    map word_of_nat [0..<unat X]", "apply (simp del: upt.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map toEnum [0..<Suc (unat (X - 1))] = map word_of_nat [0..<unat X]", "apply (subst Suc_unat_diff_1 [OF lt])"], ["proof (prove)\ngoal (1 subgoal):\n 1. map toEnum [0..<unat X] = map word_of_nat [0..<unat X]", "apply (rule map_cong [OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [0..<unat X] \\<Longrightarrow> toEnum x = word_of_nat x", "apply (rule toEnum_of_nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set [0..<unat X] \\<Longrightarrow> x < 2 ^ LENGTH('a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x < unat X \\<Longrightarrow> x < 2 ^ LENGTH('a)", "apply (erule order_less_trans [OF _ lt'])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  [0 .e. X - 1] = map word_of_nat [0..<unat X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upto_enum_red2:\n  assumes szv: \"sz < LENGTH('a :: len)\"\n  shows \"[(0:: 'a :: len word) .e. 2 ^ sz - 1] =\n  map of_nat [0 ..< 2 ^ sz]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0 .e. 2 ^ sz - 1] = map word_of_nat [0..<2 ^ sz]", "using szv"], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. [0 .e. 2 ^ sz - 1] = map word_of_nat [0..<2 ^ sz]", "apply (subst unat_power_lower[OF szv, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow>\n    [0 .e. 2 ^ sz - 1] = map word_of_nat [0..<unat (2 ^ sz)]", "apply (rule upto_enum_red')"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow> 1 \\<le> 2 ^ sz", "apply (subst word_le_nat_alt, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma upto_enum_step_red:\n  assumes szv: \"sz < LENGTH('a)\"\n  and   usszv: \"us \\<le> sz\"\n  shows \"[0 :: 'a :: len word , 2 ^ us .e. 2 ^ sz - 1] =\n  map (\\<lambda>x. of_nat x * 2 ^ us) [0 ..< 2 ^ (sz - us)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0 , 2 ^ us .e. 2 ^ sz - 1] =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "using szv"], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. [0 , 2 ^ us .e. 2 ^ sz - 1] =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "unfolding upto_enum_step_def"], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. (if 2 ^ sz - 1 < 0 then []\n     else map (\\<lambda>x. 0 + x * (2 ^ us - 0))\n           [0 .e. (2 ^ sz - 1 - 0) div (2 ^ us - 0)]) =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "apply (subst if_not_P)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> \\<not> 2 ^ sz - 1 < 0\n 2. sz < LENGTH('a) \\<Longrightarrow>\n    map (\\<lambda>x. 0 + x * (2 ^ us - 0))\n     [0 .e. (2 ^ sz - 1 - 0) div (2 ^ us - 0)] =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "apply (rule leD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> 0 \\<le> 2 ^ sz - 1\n 2. sz < LENGTH('a) \\<Longrightarrow>\n    map (\\<lambda>x. 0 + x * (2 ^ us - 0))\n     [0 .e. (2 ^ sz - 1 - 0) div (2 ^ us - 0)] =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "apply (subst word_le_nat_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> unat 0 \\<le> unat (2 ^ sz - 1)\n 2. sz < LENGTH('a) \\<Longrightarrow>\n    map (\\<lambda>x. 0 + x * (2 ^ us - 0))\n     [0 .e. (2 ^ sz - 1 - 0) div (2 ^ us - 0)] =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "apply (subst unat_minus_one)"], ["proof (prove)\ngoal (3 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> 2 ^ sz \\<noteq> 0\n 2. sz < LENGTH('a) \\<Longrightarrow> unat 0 \\<le> unat (2 ^ sz) - 1\n 3. sz < LENGTH('a) \\<Longrightarrow>\n    map (\\<lambda>x. 0 + x * (2 ^ us - 0))\n     [0 .e. (2 ^ sz - 1 - 0) div (2 ^ us - 0)] =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> unat 0 \\<le> unat (2 ^ sz) - 1\n 2. sz < LENGTH('a) \\<Longrightarrow>\n    map (\\<lambda>x. 0 + x * (2 ^ us - 0))\n     [0 .e. (2 ^ sz - 1 - 0) div (2 ^ us - 0)] =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow>\n    map (\\<lambda>x. 0 + x * (2 ^ us - 0))\n     [0 .e. (2 ^ sz - 1 - 0) div (2 ^ us - 0)] =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow>\n    map (\\<lambda>x. x * 2 ^ us) [0 .e. (2 ^ sz - 1) div 2 ^ us] =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "apply (subst upto_enum_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow>\n    map (\\<lambda>x. x * 2 ^ us)\n     (map toEnum [fromEnum 0..<Suc (fromEnum ((2 ^ sz - 1) div 2 ^ us))]) =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "apply (simp del: upt.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow>\n    map ((\\<lambda>x. x * 2 ^ us) \\<circ> toEnum)\n     [0..<Suc (unat ((2 ^ sz - 1) div 2 ^ us))] =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "apply (subst Suc_div_unat_helper [where 'a = 'a, OF szv usszv, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow>\n    map ((\\<lambda>x. x * 2 ^ us) \\<circ> toEnum) [0..<2 ^ (sz - us)] =\n    map (\\<lambda>x. word_of_nat x * 2 ^ us) [0..<2 ^ (sz - us)]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sz < LENGTH('a); x < 2 ^ (sz - us)\\<rbrakk>\n       \\<Longrightarrow> toEnum x * 2 ^ us = word_of_nat x * 2 ^ us", "apply (subst toEnum_of_nat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sz < LENGTH('a); x < 2 ^ (sz - us)\\<rbrakk>\n       \\<Longrightarrow> x < 2 ^ LENGTH('a)\n 2. \\<And>x.\n       \\<lbrakk>sz < LENGTH('a); x < 2 ^ (sz - us)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat x * 2 ^ us = word_of_nat x * 2 ^ us", "apply (erule order_less_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       sz < LENGTH('a) \\<Longrightarrow> 2 ^ (sz - us) < 2 ^ LENGTH('a)\n 2. \\<And>x.\n       \\<lbrakk>sz < LENGTH('a); x < 2 ^ (sz - us)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat x * 2 ^ us = word_of_nat x * 2 ^ us", "using szv"], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       sz < LENGTH('a) \\<Longrightarrow> 2 ^ (sz - us) < 2 ^ LENGTH('a)\n 2. \\<And>x.\n       \\<lbrakk>sz < LENGTH('a); x < 2 ^ (sz - us)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat x * 2 ^ us = word_of_nat x * 2 ^ us", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sz < LENGTH('a); x < 2 ^ (sz - us)\\<rbrakk>\n       \\<Longrightarrow> word_of_nat x * 2 ^ us = word_of_nat x * 2 ^ us", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma upto_enum_word:\n  \"[x .e. y] = map of_nat [unat x ..< Suc (unat y)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x .e. y] = map word_of_nat [unat x..<Suc (unat y)]", "apply (subst upto_enum_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map toEnum [fromEnum x..<Suc (fromEnum y)] =\n    map word_of_nat [unat x..<Suc (unat y)]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>unat x \\<le> unat y;\n        xa = unat y \\<or> unat x \\<le> xa \\<and> xa < unat y\\<rbrakk>\n       \\<Longrightarrow> toEnum xa = word_of_nat xa", "apply (subst toEnum_of_nat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>unat x \\<le> unat y;\n        xa = unat y \\<or> unat x \\<le> xa \\<and> xa < unat y\\<rbrakk>\n       \\<Longrightarrow> xa < 2 ^ LENGTH('a)\n 2. \\<And>xa.\n       \\<lbrakk>unat x \\<le> unat y;\n        xa = unat y \\<or> unat x \\<le> xa \\<and> xa < unat y\\<rbrakk>\n       \\<Longrightarrow> word_of_nat xa = word_of_nat xa", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>unat x \\<le> unat y;\n        xa = unat y \\<or> unat x \\<le> xa \\<and> xa < unat y\\<rbrakk>\n       \\<Longrightarrow> word_of_nat xa = word_of_nat xa\n 2. \\<And>xa.\n       \\<lbrakk>unat x \\<le> unat y;\n        xa = unat y \\<or> unat x \\<le> xa \\<and> xa < unat y\\<rbrakk>\n       \\<Longrightarrow> xa < 2 ^ LENGTH('a)", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>unat x \\<le> unat y;\n        xa = unat y \\<or> unat x \\<le> xa \\<and> xa < unat y\\<rbrakk>\n       \\<Longrightarrow> xa < 2 ^ LENGTH('a)", "apply (erule disjE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>unat x \\<le> unat y;\n        unat x \\<le> xa \\<and> xa < unat y\\<rbrakk>\n       \\<Longrightarrow> xa < 2 ^ LENGTH('a)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>unat x \\<le> xa; xa < unat y\\<rbrakk>\n       \\<Longrightarrow> xa < 2 ^ LENGTH('a)", "apply (erule order_less_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. unat x \\<le> xa \\<Longrightarrow> unat y < 2 ^ LENGTH('a)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_upto_Cons_eq:\n  \"x < y \\<Longrightarrow> [x::'a::len word .e. y] = x # [x + 1 .e. y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow> [x .e. y] = x # [x + 1 .e. y]", "apply (subst upto_enum_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow>\n    map toEnum [fromEnum x..<Suc (fromEnum y)] = x # [x + 1 .e. y]", "apply (subst upt_conv_Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> fromEnum x < Suc (fromEnum y)\n 2. x < y \\<Longrightarrow>\n    map toEnum (fromEnum x # [Suc (fromEnum x)..<Suc (fromEnum y)]) =\n    x # [x + 1 .e. y]", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> unat x < Suc (unat y)\n 2. x < y \\<Longrightarrow>\n    (Suc (unat x) \\<le> unat y \\<longrightarrow>\n     map toEnum [Suc (unat x)..<unat y] @ [y] = [x + 1 .e. y]) \\<and>\n    (\\<not> Suc (unat x) \\<le> unat y \\<longrightarrow> [] = [x + 1 .e. y])", "apply unat_arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow>\n    (Suc (unat x) \\<le> unat y \\<longrightarrow>\n     map toEnum [Suc (unat x)..<unat y] @ [y] = [x + 1 .e. y]) \\<and>\n    (\\<not> Suc (unat x) \\<le> unat y \\<longrightarrow> [] = [x + 1 .e. y])", "apply (simp only: list.map list.inject upto_enum_red to_from_enum simp_thms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow>\n    (Suc (unat x) \\<le> unat y \\<longrightarrow>\n     map toEnum [Suc (unat x)..<unat y] @ [y] =\n     map toEnum [fromEnum (x + 1)..<Suc (fromEnum y)]) \\<and>\n    (\\<not> Suc (unat x) \\<le> unat y \\<longrightarrow>\n     [] = map toEnum [fromEnum (x + 1)..<Suc (fromEnum y)])", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow>\n    (unat (x + 1) \\<le> unat y \\<longrightarrow>\n     (Suc (unat x) \\<le> unat y \\<longrightarrow>\n      map toEnum [Suc (unat x)..<unat y] =\n      map toEnum [unat (x + 1)..<unat y]) \\<and>\n     Suc (unat x) \\<le> unat y) \\<and>\n    (\\<not> unat (x + 1) \\<le> unat y \\<longrightarrow>\n     \\<not> Suc (unat x) \\<le> unat y)", "apply unat_arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_enum_upto:\n  \"distinct [(0 :: 'a::len word) .e. b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [0 .e. b]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct [0 .e. b]", "have \"\\<And>(b::'a word). [0 .e. b] = nths enum {..< Suc (fromEnum b)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. [0 .e. b] = nths enum {..<Suc (fromEnum b)}", "apply (subst upto_enum_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       map toEnum [fromEnum 0..<Suc (fromEnum b)] =\n       nths enum {..<Suc (fromEnum b)}", "apply (subst nths_upt_eq_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       map toEnum [fromEnum 0..<Suc (fromEnum b)] =\n       take (Suc (fromEnum b)) enum", "apply (subst enum_word_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       map toEnum [fromEnum 0..<Suc (fromEnum b)] =\n       take (Suc (fromEnum b)) (map word_of_nat [0..<2 ^ LENGTH('a)])", "apply (subst take_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       map toEnum [fromEnum 0..<Suc (fromEnum b)] =\n       map word_of_nat (take (Suc (fromEnum b)) [0..<2 ^ LENGTH('a)])", "apply (subst take_upt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. 0 + Suc (fromEnum b) \\<le> 2 ^ LENGTH('a)\n 2. \\<And>b.\n       map toEnum [fromEnum 0..<Suc (fromEnum b)] =\n       map word_of_nat [0..<0 + Suc (fromEnum b)]", "apply (simp only: add_0 fromEnum_unat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. Suc (unat b) \\<le> 2 ^ LENGTH('a)\n 2. \\<And>b.\n       map toEnum [fromEnum 0..<Suc (fromEnum b)] =\n       map word_of_nat [0..<0 + Suc (fromEnum b)]", "apply (rule order_trans [OF _ order_eq_refl])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b. Suc (unat b) \\<le> ?y5 b\n 2. \\<And>b. ?y5 b = 2 ^ LENGTH('a)\n 3. \\<And>b.\n       map toEnum [fromEnum 0..<Suc (fromEnum b)] =\n       map word_of_nat [0..<0 + Suc (fromEnum b)]", "apply (rule Suc_leI [OF unat_lt2p])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. 2 ^ LENGTH('a) = 2 ^ LENGTH('a)\n 2. \\<And>b.\n       map toEnum [fromEnum 0..<Suc (fromEnum b)] =\n       map word_of_nat [0..<0 + Suc (fromEnum b)]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       map toEnum [fromEnum 0..<Suc (fromEnum b)] =\n       map word_of_nat [0..<0 + Suc (fromEnum b)]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b x. x < unat b \\<Longrightarrow> toEnum x = word_of_nat x", "apply (rule toEnum_of_nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b x. x < unat b \\<Longrightarrow> x < 2 ^ LENGTH('a)", "apply (erule order_less_trans [OF _ unat_lt2p])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  [0 .e. ?b] = nths enum {..<Suc (fromEnum ?b)}\n\ngoal (1 subgoal):\n 1. distinct [0 .e. b]", "then"], ["proof (chain)\npicking this:\n  [0 .e. ?b] = nths enum {..<Suc (fromEnum ?b)}", "show ?thesis"], ["proof (prove)\nusing this:\n  [0 .e. ?b] = nths enum {..<Suc (fromEnum ?b)}\n\ngoal (1 subgoal):\n 1. distinct [0 .e. b]", "by (rule ssubst) (rule distinct_nthsI, simp)"], ["proof (state)\nthis:\n  distinct [0 .e. b]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upto_enum_set_conv [simp]:\n  fixes a :: \"'a :: len word\"\n  shows \"set [a .e. b] = {x. a \\<le> x \\<and> x \\<le> b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set [a .e. b] = {x. a \\<le> x \\<and> x \\<le> b}", "apply (subst upto_enum_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map toEnum [fromEnum a..<Suc (fromEnum b)]) =\n    {x. a \\<le> x \\<and> x \\<le> b}", "apply (subst set_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. toEnum ` set [fromEnum a..<Suc (fromEnum b)] =\n    {x. a \\<le> x \\<and> x \\<le> b}", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> set [fromEnum a..<Suc (fromEnum b)] \\<Longrightarrow>\n       a \\<le> toEnum xa\n 2. \\<And>x xa.\n       xa \\<in> set [fromEnum a..<Suc (fromEnum b)] \\<Longrightarrow>\n       toEnum xa \\<le> b\n 3. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toEnum `\n                                 set [fromEnum a..<Suc (fromEnum b)]", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       unat a \\<le> unat b \\<and>\n       (xa = unat b \\<or>\n        unat a \\<le> xa \\<and> xa < unat b) \\<Longrightarrow>\n       a \\<le> toEnum xa\n 2. \\<And>x xa.\n       xa \\<in> set [fromEnum a..<Suc (fromEnum b)] \\<Longrightarrow>\n       toEnum xa \\<le> b\n 3. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toEnum `\n                                 set [fromEnum a..<Suc (fromEnum b)]", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>unat a \\<le> unat b;\n        xa = unat b \\<or> unat a \\<le> xa \\<and> xa < unat b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> toEnum xa\n 2. \\<And>x xa.\n       xa \\<in> set [fromEnum a..<Suc (fromEnum b)] \\<Longrightarrow>\n       toEnum xa \\<le> b\n 3. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toEnum `\n                                 set [fromEnum a..<Suc (fromEnum b)]", "apply (erule disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>unat a \\<le> unat b; xa = unat b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> toEnum xa\n 2. \\<And>xa.\n       \\<lbrakk>unat a \\<le> unat b;\n        unat a \\<le> xa \\<and> xa < unat b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> toEnum xa\n 3. \\<And>x xa.\n       xa \\<in> set [fromEnum a..<Suc (fromEnum b)] \\<Longrightarrow>\n       toEnum xa \\<le> b\n 4. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toEnum `\n                                 set [fromEnum a..<Suc (fromEnum b)]", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>unat a \\<le> unat b; xa = unat b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b\n 2. \\<And>xa.\n       \\<lbrakk>unat a \\<le> unat b;\n        unat a \\<le> xa \\<and> xa < unat b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> toEnum xa\n 3. \\<And>x xa.\n       xa \\<in> set [fromEnum a..<Suc (fromEnum b)] \\<Longrightarrow>\n       toEnum xa \\<le> b\n 4. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toEnum `\n                                 set [fromEnum a..<Suc (fromEnum b)]", "apply (erule iffD2 [OF word_le_nat_alt])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>unat a \\<le> unat b;\n        unat a \\<le> xa \\<and> xa < unat b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> toEnum xa\n 2. \\<And>x xa.\n       xa \\<in> set [fromEnum a..<Suc (fromEnum b)] \\<Longrightarrow>\n       toEnum xa \\<le> b\n 3. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toEnum `\n                                 set [fromEnum a..<Suc (fromEnum b)]", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>unat a \\<le> xa; xa < unat b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> toEnum xa\n 2. \\<And>x xa.\n       xa \\<in> set [fromEnum a..<Suc (fromEnum b)] \\<Longrightarrow>\n       toEnum xa \\<le> b\n 3. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toEnum `\n                                 set [fromEnum a..<Suc (fromEnum b)]", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>unat a \\<le> xa; xa < unat b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> toEnum xa\n 2. \\<And>xa.\n       unat a \\<le> unat b \\<and>\n       (xa = unat b \\<or>\n        unat a \\<le> xa \\<and> xa < unat b) \\<Longrightarrow>\n       toEnum xa \\<le> b\n 3. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toEnum `\n                                 {x. unat a \\<le> unat b \\<and>\n                                     (x = unat b \\<or>\nunat a \\<le> x \\<and> x < unat b)}", "apply (metis le_unat_uoi nat_less_le toEnum_of_nat unsigned_less word_le_nat_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       unat a \\<le> unat b \\<and>\n       (xa = unat b \\<or>\n        unat a \\<le> xa \\<and> xa < unat b) \\<Longrightarrow>\n       toEnum xa \\<le> b\n 2. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toEnum `\n                                 {x. unat a \\<le> unat b \\<and>\n                                     (x = unat b \\<or>\nunat a \\<le> x \\<and> x < unat b)}", "apply (metis le_unat_uoi less_or_eq_imp_le toEnum_of_nat unsigned_less word_le_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toEnum `\n                                 {x. unat a \\<le> unat b \\<and>\n                                     (x = unat b \\<or>\nunat a \\<le> x \\<and> x < unat b)}", "apply (rule_tac x=\"fromEnum x\" in image_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> x = toEnum (fromEnum x)\n 2. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> fromEnum x\n                         \\<in> {x. unat a \\<le> unat b \\<and>\n                                   (x = unat b \\<or>\n                                    unat a \\<le> x \\<and> x < unat b)}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> fromEnum x\n                         \\<in> {x. unat a \\<le> unat b \\<and>\n                                   (x = unat b \\<or>\n                                    unat a \\<le> x \\<and> x < unat b)}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> unat a \\<le> unat b \\<and>\n                         (unat x = unat b \\<or>\n                          unat a \\<le> unat x \\<and> unat x < unat b)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>take_bit LENGTH('a) a \\<le> take_bit LENGTH('a) x;\n        take_bit LENGTH('a) x \\<le> take_bit LENGTH('a) b\\<rbrakk>\n       \\<Longrightarrow> (nat \\<circ> take_bit LENGTH('a)) a\n                         \\<le> (nat \\<circ> take_bit LENGTH('a)) b \\<and>\n                         ((nat \\<circ> take_bit LENGTH('a)) x =\n                          (nat \\<circ> take_bit LENGTH('a)) b \\<or>\n                          (nat \\<circ> take_bit LENGTH('a)) a\n                          \\<le> (nat \\<circ> take_bit LENGTH('a)) x \\<and>\n                          (nat \\<circ> take_bit LENGTH('a)) x\n                          < (nat \\<circ> take_bit LENGTH('a)) b)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma upto_enum_less:\n  assumes xin: \"x \\<in> set [(a::'a::len word).e.2 ^ n - 1]\"\n  and     nv:  \"n < LENGTH('a::len)\"\n  shows   \"x < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ n", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> x < 2 ^ n\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> x < 2 ^ n", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> x < 2 ^ n\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> x < 2 ^ n", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. x < 2 ^ n", "using xin"], ["proof (prove)\nusing this:\n  n = 0\n  x \\<in> set [a .e. 2 ^ n - 1]\n\ngoal (1 subgoal):\n 1. x < 2 ^ n", "by simp"], ["proof (state)\nthis:\n  x < 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> x < 2 ^ n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> x < 2 ^ n", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> x < 2 ^ n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ n", "using xin nv le_m1_iff_lt p2_gt_0"], ["proof (prove)\nusing this:\n  x \\<in> set [a .e. 2 ^ n - 1]\n  n < LENGTH('a)\n  (0 < ?x) = ((?y \\<le> ?x - 1) = (?y < ?x))\n  (0 < 2 ^ ?n) = (?n < LENGTH(?'a))\n\ngoal (1 subgoal):\n 1. x < 2 ^ n", "by auto"], ["proof (state)\nthis:\n  x < 2 ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upto_enum_len_less:\n  \"\\<lbrakk> n \\<le> length [a, b .e. c]; n \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> a \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length [a , b .e. c]; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> a \\<le> c", "unfolding upto_enum_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length\n                      (if c < a then []\n                       else map (\\<lambda>x. a + x * (b - a))\n                             [0 .e. (c - a) div (b - a)]);\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> a \\<le> c", "by (simp split: if_split_asm)"], ["", "lemma length_upto_enum_step:\n  fixes x :: \"'a :: len word\"\n  shows \"x \\<le> z \\<Longrightarrow> length [x , y .e. z] = (unat ((z - x) div (y - x))) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> z \\<Longrightarrow>\n    length [x , y .e. z] = unat ((z - x) div (y - x)) + 1", "unfolding upto_enum_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> z \\<Longrightarrow>\n    length\n     (if z < x then []\n      else map (\\<lambda>xa. x + xa * (y - x))\n            [0 .e. (z - x) div (y - x)]) =\n    unat ((z - x) div (y - x)) + 1", "by (simp add: upto_enum_red)"], ["", "lemma map_length_unfold_one:\n  fixes x :: \"'a::len word\"\n  assumes xv: \"Suc (unat x) < 2 ^ LENGTH('a)\"\n  and     ax: \"a < x\"\n  shows   \"map f [a .e. x] = f a # map f [a + 1 .e. x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [a .e. x] = f a # map f [a + 1 .e. x]", "by (subst word_upto_Cons_eq, auto, fact+)"], ["", "lemma upto_enum_set_conv2:\n  fixes a :: \"'a::len word\"\n  shows \"set [a .e. b] = {a .. b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set [a .e. b] = {a..b}", "by auto"], ["", "lemma length_upto_enum [simp]:\n  fixes a :: \"'a :: len word\"\n  shows \"length [a .e. b] = Suc (unat b) - unat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [a .e. b] = Suc (unat b) - unat a", "apply (simp add: word_le_nat_alt upto_enum_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat a \\<le> unat b \\<longrightarrow>\n    Suc (unat b - unat a) = Suc (unat b) - unat a", "apply (clarsimp simp: Suc_diff_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_upto_enum_cases:\n  fixes a :: \"'a::len word\"\n  shows \"length [a .e. b] = (if a \\<le> b then Suc (unat b) - unat a else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [a .e. b] = (if a \\<le> b then Suc (unat b) - unat a else 0)", "apply (case_tac \"a \\<le> b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    length [a .e. b] = (if a \\<le> b then Suc (unat b) - unat a else 0)\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    length [a .e. b] = (if a \\<le> b then Suc (unat b) - unat a else 0)", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow>\n    length [a .e. b] = (if a \\<le> b then Suc (unat b) - unat a else 0)", "apply (clarsimp simp: upto_enum_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> a \\<le> b; unat a \\<le> unat b\\<rbrakk>\n    \\<Longrightarrow> False", "apply unat_arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_upto_enum_less_one:\n  \"\\<lbrakk>a \\<le> b; b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> length [a .e. b - 1] = unat (b - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> length [a .e. b - 1] = unat (b - a)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat b - unat a = unat (b - a)", "apply (subst unat_sub[symmetric], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat (b - a) = unat (b - a)", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma drop_upto_enum:\n  \"drop (unat n) [0 .e. m] = [n .e. m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (unat n) [0 .e. m] = [n .e. m]", "apply (clarsimp simp: upto_enum_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat n \\<le> unat m \\<Longrightarrow>\n    drop (unat n) (map toEnum [0..<unat m]) = map toEnum [unat n..<unat m]", "apply (induct m, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>1 + m \\<noteq> 0;\n        unat n \\<le> unat m \\<Longrightarrow>\n        drop (unat n) (map toEnum [0..<unat m]) =\n        map toEnum [unat n..<unat m];\n        unat n \\<le> unat (1 + m)\\<rbrakk>\n       \\<Longrightarrow> drop (unat n) (map toEnum [0..<unat (1 + m)]) =\n                         map toEnum [unat n..<unat (1 + m)]", "by (metis drop_map drop_upt plus_nat.add_0)"], ["", "lemma distinct_enum_upto' [simp]:\n  \"distinct [a::'a::len word .e. b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [a .e. b]", "apply (subst drop_upto_enum [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (drop (unat a) [0 .e. b])", "apply (rule distinct_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [0 .e. b]", "apply (rule distinct_enum_upto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_interval:\n  \"\\<lbrakk>set xs = {x. (a::'a::len word) \\<le> x \\<and> x \\<le> b}; distinct xs\\<rbrakk>\n  \\<Longrightarrow> length xs = Suc (unat b) - unat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs\\<rbrakk>\n    \\<Longrightarrow> length xs = Suc (unat b) - unat a", "apply (frule distinct_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs;\n     card (set xs) = length xs\\<rbrakk>\n    \\<Longrightarrow> length xs = Suc (unat b) - unat a", "apply (subgoal_tac \"set xs = set [a .e. b]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs;\n     card (set xs) = length xs; set xs = set [a .e. b]\\<rbrakk>\n    \\<Longrightarrow> length xs = Suc (unat b) - unat a\n 2. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs;\n     card (set xs) = length xs\\<rbrakk>\n    \\<Longrightarrow> set xs = set [a .e. b]", "apply (cut_tac distinct_card [where xs=\"[a .e. b]\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs;\n     card (set xs) = length xs; set xs = set [a .e. b];\n     card (set [a .e. b]) = length [a .e. b]\\<rbrakk>\n    \\<Longrightarrow> length xs = Suc (unat b) - unat a\n 2. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs;\n     card (set xs) = length xs; set xs = set [a .e. b]\\<rbrakk>\n    \\<Longrightarrow> distinct [a .e. b]\n 3. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs;\n     card (set xs) = length xs\\<rbrakk>\n    \\<Longrightarrow> set xs = set [a .e. b]", "apply (subst (asm) length_upto_enum)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs;\n     card (set xs) = length xs; set xs = set [a .e. b];\n     card (set [a .e. b]) = Suc (unat b) - unat a\\<rbrakk>\n    \\<Longrightarrow> length xs = Suc (unat b) - unat a\n 2. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs;\n     card (set xs) = length xs; set xs = set [a .e. b]\\<rbrakk>\n    \\<Longrightarrow> distinct [a .e. b]\n 3. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs;\n     card (set xs) = length xs\\<rbrakk>\n    \\<Longrightarrow> set xs = set [a .e. b]", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs;\n     card (set xs) = length xs; set xs = set [a .e. b]\\<rbrakk>\n    \\<Longrightarrow> distinct [a .e. b]\n 2. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs;\n     card (set xs) = length xs\\<rbrakk>\n    \\<Longrightarrow> set xs = set [a .e. b]", "apply (rule distinct_enum_upto')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs = {x. a \\<le> x \\<and> x \\<le> b}; distinct xs;\n     card (set xs) = length xs\\<rbrakk>\n    \\<Longrightarrow> set xs = set [a .e. b]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma enum_word_div:\n  fixes v :: \"'a :: len word\" shows\n  \"\\<exists>xs ys. enum = xs @ [v] @ ys\n             \\<and> (\\<forall>x \\<in> set xs. x < v)\n             \\<and> (\\<forall>y \\<in> set ys. v < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       enum = xs @ [v] @ ys \\<and>\n       (\\<forall>x\\<in>set xs. x < v) \\<and> (\\<forall>y\\<in>set ys. v < y)", "apply (simp only: enum_word_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       map word_of_nat [0..<2 ^ LENGTH('a)] = xs @ [v] @ ys \\<and>\n       (\\<forall>x\\<in>set xs. x < v) \\<and> (\\<forall>y\\<in>set ys. v < y)", "apply (subst upt_add_eq_append'[where j=\"unat v\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ys xs. 0 \\<le> unat v\n 2. \\<And>ys xs. unat v \\<le> 2 ^ LENGTH('a)\n 3. \\<exists>xs ys.\n       map word_of_nat ([0..<unat v] @ [unat v..<2 ^ LENGTH('a)]) =\n       xs @ [v] @ ys \\<and>\n       (\\<forall>x\\<in>set xs. x < v) \\<and> Ball (set ys) ((<) v)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys xs. unat v \\<le> 2 ^ LENGTH('a)\n 2. \\<exists>xs ys.\n       map word_of_nat ([0..<unat v] @ [unat v..<2 ^ LENGTH('a)]) =\n       xs @ [v] @ ys \\<and>\n       (\\<forall>x\\<in>set xs. x < v) \\<and> Ball (set ys) ((<) v)", "apply (rule order_less_imp_le, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       map word_of_nat ([0..<unat v] @ [unat v..<2 ^ LENGTH('a)]) =\n       xs @ [v] @ ys \\<and>\n       (\\<forall>x\\<in>set xs. x < v) \\<and> Ball (set ys) ((<) v)", "apply (simp add: upt_conv_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       map word_of_nat [0..<unat v] @\n       v # map word_of_nat [Suc (unat v)..<2 ^ LENGTH('a)] =\n       xs @ v # ys \\<and>\n       (\\<forall>x\\<in>set xs. x < v) \\<and> (\\<forall>x\\<in>set ys. v < x)", "apply (intro exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. map word_of_nat [0..<unat v] @\n    v # map word_of_nat [Suc (unat v)..<2 ^ LENGTH('a)] =\n    ?xs4 @ v # ?ys5\n 2. \\<forall>x\\<in>set ?xs4. x < v\n 3. \\<forall>x\\<in>set ?ys5. v < x", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set (map word_of_nat [0..<unat v]). x < v\n 2. \\<forall>x\\<in>set (map word_of_nat [Suc (unat v)..<2 ^ LENGTH('a)]).\n       v < x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x < unat v \\<Longrightarrow> word_of_nat x < v\n 2. \\<forall>x\\<in>set (map word_of_nat [Suc (unat v)..<2 ^ LENGTH('a)]).\n       v < x", "apply (drule of_nat_mono_maybe[rotated, where 'a='a])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. unat v < 2 ^ LENGTH('a)\n 2. \\<And>x.\n       word_of_nat x < word_of_nat (unat v) \\<Longrightarrow>\n       word_of_nat x < v\n 3. \\<forall>x\\<in>set (map word_of_nat [Suc (unat v)..<2 ^ LENGTH('a)]).\n       v < x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       word_of_nat x < word_of_nat (unat v) \\<Longrightarrow>\n       word_of_nat x < v\n 2. \\<forall>x\\<in>set (map word_of_nat [Suc (unat v)..<2 ^ LENGTH('a)]).\n       v < x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map word_of_nat [Suc (unat v)..<2 ^ LENGTH('a)]).\n       v < x", "apply (clarsimp simp: Suc_le_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>unat v < x; x < 2 ^ LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> v < word_of_nat x", "apply (drule of_nat_mono_maybe[rotated, where 'a='a])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x < 2 ^ LENGTH('a) \\<Longrightarrow> x < 2 ^ LENGTH('a)\n 2. \\<And>x.\n       \\<lbrakk>x < 2 ^ LENGTH('a);\n        word_of_nat (unat v) < word_of_nat x\\<rbrakk>\n       \\<Longrightarrow> v < word_of_nat x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < 2 ^ LENGTH('a);\n        word_of_nat (unat v) < word_of_nat x\\<rbrakk>\n       \\<Longrightarrow> v < word_of_nat x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}