{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Bits_Int.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma bin_last_def:\n  \"bin_last w \\<longleftrightarrow> w mod 2 = 1\"", "lemma bin_last_numeral_simps [simp]:\n  \"\\<not> odd (0 :: int)\"\n  \"odd (1 :: int)\"\n  \"odd (- 1 :: int)\"\n  \"odd (Numeral1 :: int)\"\n  \"\\<not> odd (numeral (Num.Bit0 w) :: int)\"\n  \"odd (numeral (Num.Bit1 w) :: int)\"\n  \"\\<not> odd (- numeral (Num.Bit0 w) :: int)\"\n  \"odd (- numeral (Num.Bit1 w) :: int)\"", "lemma bin_rest_numeral_simps [simp]:\n  \"bin_rest 0 = 0\"\n  \"bin_rest 1 = 0\"\n  \"bin_rest (- 1) = - 1\"\n  \"bin_rest Numeral1 = 0\"\n  \"bin_rest (numeral (Num.Bit0 w)) = numeral w\"\n  \"bin_rest (numeral (Num.Bit1 w)) = numeral w\"\n  \"bin_rest (- numeral (Num.Bit0 w)) = - numeral w\"\n  \"bin_rest (- numeral (Num.Bit1 w)) = - numeral (w + Num.One)\"", "lemma bin_rl_eqI: \"\\<lbrakk>bin_rest x = bin_rest y; odd x = odd y\\<rbrakk> \\<Longrightarrow> x = y\"", "lemma [simp]:\n  shows bin_rest_lt0: \"bin_rest i < 0 \\<longleftrightarrow> i < 0\"\n  and  bin_rest_ge_0: \"bin_rest i \\<ge> 0 \\<longleftrightarrow> i \\<ge> 0\"", "lemma bin_rest_gt_0 [simp]: \"bin_rest x > 0 \\<longleftrightarrow> x > 1\"", "lemma bin_nth_eq_iff: \"bin_nth x = bin_nth y \\<longleftrightarrow> x = y\"", "lemma bin_eqI:\n  \"x = y\" if \"\\<And>n. bin_nth x n \\<longleftrightarrow> bin_nth y n\"", "lemma bin_eq_iff: \"x = y \\<longleftrightarrow> (\\<forall>n. bin_nth x n = bin_nth y n)\"", "lemma bin_nth_zero [simp]: \"\\<not> bin_nth 0 n\"", "lemma bin_nth_1 [simp]: \"bin_nth 1 n \\<longleftrightarrow> n = 0\"", "lemma bin_nth_minus1 [simp]: \"bin_nth (- 1) n\"", "lemma bin_nth_numeral: \"bin_rest x = y \\<Longrightarrow> bin_nth x (numeral n) = bin_nth y (pred_numeral n)\"", "lemmas bin_nth_numeral_simps [simp] =\n  bin_nth_numeral [OF bin_rest_numeral_simps(8)]", "lemmas bin_nth_simps =\n  bit_0 bit_Suc bin_nth_zero bin_nth_minus1\n  bin_nth_numeral_simps", "lemma nth_2p_bin: \"bin_nth (2 ^ n) m = (m = n)\" \\<comment> \\<open>for use when simplifying with \\<open>bin_nth_Bit\\<close>\\<close>", "lemma nth_rest_power_bin: \"bin_nth ((bin_rest ^^ k) w) n = bin_nth w (n + k)\"", "lemma bin_nth_numeral_unfold:\n  \"bin_nth (numeral (num.Bit0 x)) n \\<longleftrightarrow> n > 0 \\<and> bin_nth (numeral x) (n - 1)\"\n  \"bin_nth (numeral (num.Bit1 x)) n \\<longleftrightarrow> (n > 0 \\<longrightarrow> bin_nth (numeral x) (n - 1))\"", "lemma bin_sign_simps [simp]:\n  \"bin_sign 0 = 0\"\n  \"bin_sign 1 = 0\"\n  \"bin_sign (- 1) = - 1\"\n  \"bin_sign (numeral k) = 0\"\n  \"bin_sign (- numeral k) = -1\"", "lemma bin_sign_rest [simp]: \"bin_sign (bin_rest w) = bin_sign w\"", "lemma bintrunc_mod2p: \"bintrunc n w = w mod 2 ^ n\"", "lemma sbintrunc_mod2p: \"sbintrunc n w = (w + 2 ^ n) mod 2 ^ Suc n - 2 ^ n\"", "lemma sbintrunc_eq_take_bit:\n  \\<open>sbintrunc n k = take_bit (Suc n) (k + 2 ^ n) - 2 ^ n\\<close>", "lemma sign_bintr: \"bin_sign (bintrunc n w) = 0\"", "lemma bintrunc_n_0: \"bintrunc n 0 = 0\"", "lemma sbintrunc_n_0: \"sbintrunc n 0 = 0\"", "lemma sbintrunc_n_minus1: \"sbintrunc n (- 1) = -1\"", "lemma bintrunc_Suc_numeral:\n  \"bintrunc (Suc n) 1 = 1\"\n  \"bintrunc (Suc n) (- 1) = 1 + 2 * bintrunc n (- 1)\"\n  \"bintrunc (Suc n) (numeral (Num.Bit0 w)) = 2 * bintrunc n (numeral w)\"\n  \"bintrunc (Suc n) (numeral (Num.Bit1 w)) = 1 + 2 * bintrunc n (numeral w)\"\n  \"bintrunc (Suc n) (- numeral (Num.Bit0 w)) = 2 * bintrunc n (- numeral w)\"\n  \"bintrunc (Suc n) (- numeral (Num.Bit1 w)) = 1 + 2 * bintrunc n (- numeral (w + Num.One))\"", "lemma sbintrunc_0_numeral [simp]:\n  \"sbintrunc 0 1 = -1\"\n  \"sbintrunc 0 (numeral (Num.Bit0 w)) = 0\"\n  \"sbintrunc 0 (numeral (Num.Bit1 w)) = -1\"\n  \"sbintrunc 0 (- numeral (Num.Bit0 w)) = 0\"\n  \"sbintrunc 0 (- numeral (Num.Bit1 w)) = -1\"", "lemma sbintrunc_Suc_numeral:\n  \"sbintrunc (Suc n) 1 = 1\"\n  \"sbintrunc (Suc n) (numeral (Num.Bit0 w)) = 2 * sbintrunc n (numeral w)\"\n  \"sbintrunc (Suc n) (numeral (Num.Bit1 w)) = 1 + 2 * sbintrunc n (numeral w)\"\n  \"sbintrunc (Suc n) (- numeral (Num.Bit0 w)) = 2 * sbintrunc n (- numeral w)\"\n  \"sbintrunc (Suc n) (- numeral (Num.Bit1 w)) = 1 + 2 * sbintrunc n (- numeral (w + Num.One))\"", "lemma bin_sign_lem: \"(bin_sign (sbintrunc n bin) = -1) = bit bin n\"", "lemma nth_bintr: \"bin_nth (bintrunc m w) n \\<longleftrightarrow> n < m \\<and> bin_nth w n\"", "lemma nth_sbintr: \"bin_nth (sbintrunc m w) n = (if n < m then bin_nth w n else bin_nth w m)\"", "lemma bin_nth_Bit0:\n  \"bin_nth (numeral (Num.Bit0 w)) n \\<longleftrightarrow>\n    (\\<exists>m. n = Suc m \\<and> bin_nth (numeral w) m)\"", "lemma bin_nth_Bit1:\n  \"bin_nth (numeral (Num.Bit1 w)) n \\<longleftrightarrow>\n    n = 0 \\<or> (\\<exists>m. n = Suc m \\<and> bin_nth (numeral w) m)\"", "lemma bintrunc_bintrunc_l: \"n \\<le> m \\<Longrightarrow> bintrunc m (bintrunc n w) = bintrunc n w\"", "lemma sbintrunc_sbintrunc_l: \"n \\<le> m \\<Longrightarrow> sbintrunc m (sbintrunc n w) = sbintrunc n w\"", "lemma bintrunc_bintrunc_ge: \"n \\<le> m \\<Longrightarrow> bintrunc n (bintrunc m w) = bintrunc n w\"", "lemma bintrunc_bintrunc_min [simp]: \"bintrunc m (bintrunc n w) = bintrunc (min m n) w\"", "lemma sbintrunc_sbintrunc_min [simp]: \"sbintrunc m (sbintrunc n w) = sbintrunc (min m n) w\"", "lemmas sbintrunc_Suc_Pls =\n  signed_take_bit_Suc [where a=\"0::int\", simplified bin_last_numeral_simps bin_rest_numeral_simps]", "lemmas sbintrunc_Suc_Min =\n  signed_take_bit_Suc [where a=\"-1::int\", simplified bin_last_numeral_simps bin_rest_numeral_simps]", "lemmas sbintrunc_Sucs = sbintrunc_Suc_Pls sbintrunc_Suc_Min\n  sbintrunc_Suc_numeral", "lemmas sbintrunc_Pls =\n  signed_take_bit_0 [where a=\"0::int\", simplified bin_last_numeral_simps bin_rest_numeral_simps]", "lemmas sbintrunc_Min =\n  signed_take_bit_0 [where a=\"-1::int\", simplified bin_last_numeral_simps bin_rest_numeral_simps]", "lemmas sbintrunc_0_simps =\n  sbintrunc_Pls sbintrunc_Min", "lemmas sbintrunc_simps = sbintrunc_0_simps sbintrunc_Sucs", "lemma bintrunc_minus: \"0 < n \\<Longrightarrow> bintrunc (Suc (n - 1)) w = bintrunc n w\"", "lemma sbintrunc_minus: \"0 < n \\<Longrightarrow> sbintrunc (Suc (n - 1)) w = sbintrunc n w\"", "lemmas sbintrunc_minus_simps =\n  sbintrunc_Sucs [THEN [2] sbintrunc_minus [symmetric, THEN trans]]", "lemma sbintrunc_BIT_I:\n  \\<open>0 < n \\<Longrightarrow>\n  sbintrunc (n - 1) 0 = y \\<Longrightarrow>\n  sbintrunc n 0 = 2 * y\\<close>", "lemma sbintrunc_Suc_Is:\n  \\<open>sbintrunc n (- 1) = y \\<Longrightarrow>\n  sbintrunc (Suc n) (- 1) = 1 + 2 * y\\<close>", "lemma sbintrunc_Suc_lem: \"sbintrunc (Suc n) x = y \\<Longrightarrow> m = Suc n \\<Longrightarrow> sbintrunc m x = y\"", "lemmas sbintrunc_Suc_Ialts =\n  sbintrunc_Suc_Is [THEN sbintrunc_Suc_lem]", "lemma sbintrunc_bintrunc_lt: \"m > n \\<Longrightarrow> sbintrunc n (bintrunc m w) = sbintrunc n w\"", "lemma bintrunc_sbintrunc_le: \"m \\<le> Suc n \\<Longrightarrow> bintrunc m (sbintrunc n w) = bintrunc m w\"", "lemmas bintrunc_sbintrunc [simp] = order_refl [THEN bintrunc_sbintrunc_le]", "lemmas sbintrunc_bintrunc [simp] = lessI [THEN sbintrunc_bintrunc_lt]", "lemmas bintrunc_bintrunc [simp] = order_refl [THEN bintrunc_bintrunc_l]", "lemmas sbintrunc_sbintrunc [simp] = order_refl [THEN sbintrunc_sbintrunc_l]", "lemma bintrunc_sbintrunc' [simp]: \"0 < n \\<Longrightarrow> bintrunc n (sbintrunc (n - 1) w) = bintrunc n w\"", "lemma sbintrunc_bintrunc' [simp]: \"0 < n \\<Longrightarrow> sbintrunc (n - 1) (bintrunc n w) = sbintrunc (n - 1) w\"", "lemma bin_sbin_eq_iff: \"bintrunc (Suc n) x = bintrunc (Suc n) y \\<longleftrightarrow> sbintrunc n x = sbintrunc n y\"", "lemma bin_sbin_eq_iff':\n  \"0 < n \\<Longrightarrow> bintrunc n x = bintrunc n y \\<longleftrightarrow> sbintrunc (n - 1) x = sbintrunc (n - 1) y\"", "lemmas bintrunc_sbintruncS0 [simp] = bintrunc_sbintrunc' [unfolded One_nat_def]", "lemmas sbintrunc_bintruncS0 [simp] = sbintrunc_bintrunc' [unfolded One_nat_def]", "lemmas bintrunc_bintrunc_l' = le_add1 [THEN bintrunc_bintrunc_l]", "lemmas sbintrunc_sbintrunc_l' = le_add1 [THEN sbintrunc_sbintrunc_l]", "lemmas nat_non0_gr =\n  trans [OF iszero_def [THEN Not_eq_iff [THEN iffD2]] refl]", "lemma bintrunc_numeral:\n  \"bintrunc (numeral k) x = of_bool (odd x) + 2 * bintrunc (pred_numeral k) (x div 2)\"", "lemma sbintrunc_numeral:\n  \"sbintrunc (numeral k) x = of_bool (odd x) + 2 * sbintrunc (pred_numeral k) (x div 2)\"", "lemma bintrunc_numeral_simps [simp]:\n  \"bintrunc (numeral k) (numeral (Num.Bit0 w)) =\n    2 * bintrunc (pred_numeral k) (numeral w)\"\n  \"bintrunc (numeral k) (numeral (Num.Bit1 w)) =\n    1 + 2 * bintrunc (pred_numeral k) (numeral w)\"\n  \"bintrunc (numeral k) (- numeral (Num.Bit0 w)) =\n    2 * bintrunc (pred_numeral k) (- numeral w)\"\n  \"bintrunc (numeral k) (- numeral (Num.Bit1 w)) =\n    1 + 2 * bintrunc (pred_numeral k) (- numeral (w + Num.One))\"\n  \"bintrunc (numeral k) 1 = 1\"", "lemma sbintrunc_numeral_simps [simp]:\n  \"sbintrunc (numeral k) (numeral (Num.Bit0 w)) =\n    2 * sbintrunc (pred_numeral k) (numeral w)\"\n  \"sbintrunc (numeral k) (numeral (Num.Bit1 w)) =\n    1 + 2 * sbintrunc (pred_numeral k) (numeral w)\"\n  \"sbintrunc (numeral k) (- numeral (Num.Bit0 w)) =\n    2 * sbintrunc (pred_numeral k) (- numeral w)\"\n  \"sbintrunc (numeral k) (- numeral (Num.Bit1 w)) =\n    1 + 2 * sbintrunc (pred_numeral k) (- numeral (w + Num.One))\"\n  \"sbintrunc (numeral k) 1 = 1\"", "lemma no_bintr_alt1: \"bintrunc n = (\\<lambda>w. w mod 2 ^ n :: int)\"", "lemma range_bintrunc: \"range (bintrunc n) = {i. 0 \\<le> i \\<and> i < 2 ^ n}\"", "lemma no_sbintr_alt2: \"sbintrunc n = (\\<lambda>w. (w + 2 ^ n) mod 2 ^ Suc n - 2 ^ n :: int)\"", "lemma range_sbintrunc: \"range (sbintrunc n) = {i. - (2 ^ n) \\<le> i \\<and> i < 2 ^ n}\"", "lemma sbintrunc_inc:\n  \\<open>k + 2 ^ Suc n \\<le> sbintrunc n k\\<close> if \\<open>k < - (2 ^ n)\\<close>", "lemma sbintrunc_dec:\n  \\<open>sbintrunc n k \\<le> k - 2 ^ (Suc n)\\<close> if \\<open>k \\<ge> 2 ^ n\\<close>", "lemma bintr_ge0: \"0 \\<le> bintrunc n w\"", "lemma bintr_lt2p: \"bintrunc n w < 2 ^ n\"", "lemma bintr_Min: \"bintrunc n (- 1) = 2 ^ n - 1\"", "lemma sbintr_ge: \"- (2 ^ n) \\<le> sbintrunc n w\"", "lemma sbintr_lt: \"sbintrunc n w < 2 ^ n\"", "lemma sign_Pls_ge_0: \"bin_sign bin = 0 \\<longleftrightarrow> bin \\<ge> 0\"\n  for bin :: int", "lemma sign_Min_lt_0: \"bin_sign bin = -1 \\<longleftrightarrow> bin < 0\"\n  for bin :: int", "lemma bin_rest_trunc: \"bin_rest (bintrunc n bin) = bintrunc (n - 1) (bin_rest bin)\"", "lemma bin_rest_power_trunc:\n  \"(bin_rest ^^ k) (bintrunc n bin) = bintrunc (n - k) ((bin_rest ^^ k) bin)\"", "lemma bin_rest_trunc_i: \"bintrunc n (bin_rest bin) = bin_rest (bintrunc (Suc n) bin)\"", "lemma bin_rest_strunc: \"bin_rest (sbintrunc (Suc n) bin) = sbintrunc n (bin_rest bin)\"", "lemma bintrunc_rest [simp]: \"bintrunc n (bin_rest (bintrunc n bin)) = bin_rest (bintrunc n bin)\"", "lemma sbintrunc_rest [simp]: \"sbintrunc n (bin_rest (sbintrunc n bin)) = bin_rest (sbintrunc n bin)\"", "lemma bintrunc_rest': \"bintrunc n \\<circ> bin_rest \\<circ> bintrunc n = bin_rest \\<circ> bintrunc n\"", "lemma sbintrunc_rest': \"sbintrunc n \\<circ> bin_rest \\<circ> sbintrunc n = bin_rest \\<circ> sbintrunc n\"", "lemma rco_lem: \"f \\<circ> g \\<circ> f = g \\<circ> f \\<Longrightarrow> f \\<circ> (g \\<circ> f) ^^ n = g ^^ n \\<circ> f\"", "lemmas rco_bintr = bintrunc_rest'\n  [THEN rco_lem [THEN fun_cong], unfolded o_def]", "lemmas rco_sbintr = sbintrunc_rest'\n  [THEN rco_lem [THEN fun_cong], unfolded o_def]", "lemma [code]:\n  \"bin_split (Suc n) w = (let (w1, w2) = bin_split n (w div 2) in (w1, of_bool (odd w) + 2 * w2))\"\n  \"bin_split 0 w = (w, 0)\"", "lemma bin_cat_eq_push_bit_add_take_bit:\n  \\<open>bin_cat k n l = push_bit n k + take_bit n l\\<close>", "lemma bin_sign_cat: \"bin_sign (bin_cat x n y) = bin_sign x\"", "lemma bin_cat_assoc: \"bin_cat (bin_cat x m y) n z = bin_cat x (m + n) (bin_cat y n z)\"", "lemma bin_cat_assoc_sym: \"bin_cat x m (bin_cat y n z) = bin_cat (bin_cat x (m - n) y) (min m n) z\"", "lemma bin_rcat_eq_foldl:\n  \\<open>bin_rcat n = foldl (\\<lambda>u v. bin_cat u n v) 0\\<close>", "lemma bin_nth_cat:\n  \"bin_nth (bin_cat x k y) n =\n    (if n < k then bin_nth y n else bin_nth x (n - k))\"", "lemma bin_nth_drop_bit_iff:\n  \\<open>bin_nth (drop_bit n c) k \\<longleftrightarrow> bin_nth c (n + k)\\<close>", "lemma bin_nth_take_bit_iff:\n  \\<open>bin_nth (take_bit n c) k \\<longleftrightarrow> k < n \\<and> bin_nth c k\\<close>", "lemma bin_nth_split:\n  \"bin_split n c = (a, b) \\<Longrightarrow>\n    (\\<forall>k. bin_nth a k = bin_nth c (n + k)) \\<and>\n    (\\<forall>k. bin_nth b k = (k < n \\<and> bin_nth c k))\"", "lemma bin_cat_zero [simp]: \"bin_cat 0 n w = bintrunc n w\"", "lemma bintr_cat1: \"bintrunc (k + n) (bin_cat a n b) = bin_cat (bintrunc k a) n b\"", "lemma bintr_cat: \"bintrunc m (bin_cat a n b) =\n    bin_cat (bintrunc (m - n) a) n (bintrunc (min m n) b)\"", "lemma bintr_cat_same [simp]: \"bintrunc n (bin_cat a n b) = bintrunc n b\"", "lemma cat_bintr [simp]: \"bin_cat a n (bintrunc n b) = bin_cat a n b\"", "lemma split_bintrunc: \"bin_split n c = (a, b) \\<Longrightarrow> b = bintrunc n c\"", "lemma bin_cat_split: \"bin_split n w = (u, v) \\<Longrightarrow> w = bin_cat u n v\"", "lemma drop_bit_bin_cat_eq:\n  \\<open>drop_bit n (bin_cat v n w) = v\\<close>", "lemma take_bit_bin_cat_eq:\n  \\<open>take_bit n (bin_cat v n w) = take_bit n w\\<close>", "lemma bin_split_cat: \"bin_split n (bin_cat v n w) = (v, bintrunc n w)\"", "lemma bin_split_zero [simp]: \"bin_split n 0 = (0, 0)\"", "lemma bin_split_minus1 [simp]:\n  \"bin_split n (- 1) = (- 1, bintrunc n (- 1))\"", "lemma bin_split_trunc:\n  \"bin_split (min m n) c = (a, b) \\<Longrightarrow>\n    bin_split n (bintrunc m c) = (bintrunc (m - n) a, b)\"", "lemma bin_split_trunc1:\n  \"bin_split n c = (a, b) \\<Longrightarrow>\n    bin_split n (bintrunc m c) = (bintrunc (m - n) a, bintrunc m b)\"", "lemma bin_cat_num: \"bin_cat a n b = a * 2 ^ n + bintrunc n b\"", "lemma bin_split_num: \"bin_split n b = (b div 2 ^ n, b mod 2 ^ n)\"", "lemmas bin_rsplit_aux_simps = bin_rsplit_aux.simps bin_rsplitl_aux.simps", "lemmas rsplit_aux_simps = bin_rsplit_aux_simps", "lemmas th_if_simp1 = if_split [where P = \"(=) l\", THEN iffD1, THEN conjunct1, THEN mp] for l", "lemmas th_if_simp2 = if_split [where P = \"(=) l\", THEN iffD1, THEN conjunct2, THEN mp] for l", "lemmas rsplit_aux_simp1s = rsplit_aux_simps [THEN th_if_simp1]", "lemmas rsplit_aux_simp2ls = rsplit_aux_simps [THEN th_if_simp2]\n\\<comment> \\<open>these safe to \\<open>[simp add]\\<close> as require calculating \\<open>m - n\\<close>\\<close>", "lemmas bin_rsplit_aux_simp2s [simp] = rsplit_aux_simp2ls [unfolded Let_def]", "lemmas rbscl = bin_rsplit_aux_simp2s (2)", "lemmas rsplit_aux_0_simps [simp] =\n  rsplit_aux_simp1s [OF disjI1] rsplit_aux_simp1s [OF disjI2]", "lemma bin_rsplit_aux_append: \"bin_rsplit_aux n m c (bs @ cs) = bin_rsplit_aux n m c bs @ cs\"", "lemma bin_rsplitl_aux_append: \"bin_rsplitl_aux n m c (bs @ cs) = bin_rsplitl_aux n m c bs @ cs\"", "lemmas rsplit_aux_apps [where bs = \"[]\"] =\n  bin_rsplit_aux_append bin_rsplitl_aux_append", "lemmas rsplit_def_auxs = bin_rsplit_def bin_rsplitl_def", "lemmas rsplit_aux_alts = rsplit_aux_apps\n  [unfolded append_Nil rsplit_def_auxs [symmetric]]", "lemma bin_split_minus: \"0 < n \\<Longrightarrow> bin_split (Suc (n - 1)) w = bin_split n w\"", "lemma bin_split_pred_simp [simp]:\n  \"(0::nat) < numeral bin \\<Longrightarrow>\n    bin_split (numeral bin) w =\n      (let (w1, w2) = bin_split (numeral bin - 1) (bin_rest w)\n       in (w1, of_bool (odd w) + 2 * w2))\"", "lemma bin_rsplit_aux_simp_alt:\n  \"bin_rsplit_aux n m c bs =\n    (if m = 0 \\<or> n = 0 then bs\n     else let (a, b) = bin_split n c in bin_rsplit n (m - n, a) @ b # bs)\"", "lemmas bin_rsplit_simp_alt =\n  trans [OF bin_rsplit_def bin_rsplit_aux_simp_alt]", "lemmas bthrs = bin_rsplit_simp_alt [THEN [2] trans]", "lemma bin_rsplit_size_sign' [rule_format]:\n  \"n > 0 \\<Longrightarrow> rev sw = bin_rsplit n (nw, w) \\<Longrightarrow> \\<forall>v\\<in>set sw. bintrunc n v = v\"", "lemmas bin_rsplit_size_sign = bin_rsplit_size_sign' [OF asm_rl\n  rev_rev_ident [THEN trans] set_rev [THEN equalityD2 [THEN subsetD]]]", "lemma bin_nth_rsplit [rule_format] :\n  \"n > 0 \\<Longrightarrow> m < n \\<Longrightarrow>\n    \\<forall>w k nw.\n      rev sw = bin_rsplit n (nw, w) \\<longrightarrow>\n      k < size sw \\<longrightarrow> bin_nth (sw ! k) m = bin_nth w (k * n + m)\"", "lemma bin_rsplit_all: \"0 < nw \\<Longrightarrow> nw \\<le> n \\<Longrightarrow> bin_rsplit n (nw, w) = [bintrunc n w]\"", "lemma bin_rsplit_l [rule_format]:\n  \"\\<forall>bin. bin_rsplitl n (m, bin) = bin_rsplit n (m, bintrunc m bin)\"", "lemma bin_rsplit_rcat [rule_format]:\n  \"n > 0 \\<longrightarrow> bin_rsplit n (n * size ws, bin_rcat n ws) = map (bintrunc n) ws\"", "lemma bin_rsplit_aux_len_le [rule_format] :\n  \"\\<forall>ws m. n \\<noteq> 0 \\<longrightarrow> ws = bin_rsplit_aux n nw w bs \\<longrightarrow>\n    length ws \\<le> m \\<longleftrightarrow> nw + length bs * n \\<le> m * n\"", "lemma bin_rsplit_len_le: \"n \\<noteq> 0 \\<longrightarrow> ws = bin_rsplit n (nw, w) \\<longrightarrow> length ws \\<le> m \\<longleftrightarrow> nw \\<le> m * n\"", "lemma bin_rsplit_aux_len:\n  \"n \\<noteq> 0 \\<Longrightarrow> length (bin_rsplit_aux n nw w cs) = (nw + n - 1) div n + length cs\"", "lemma bin_rsplit_len: \"n \\<noteq> 0 \\<Longrightarrow> length (bin_rsplit n (nw, w)) = (nw + n - 1) div n\"", "lemma bin_rsplit_aux_len_indep:\n  \"n \\<noteq> 0 \\<Longrightarrow> length bs = length cs \\<Longrightarrow>\n    length (bin_rsplit_aux n nw v bs) =\n    length (bin_rsplit_aux n nw w cs)\"", "lemma bin_rsplit_len_indep:\n  \"n \\<noteq> 0 \\<Longrightarrow> length (bin_rsplit n (nw, v)) = length (bin_rsplit n (nw, w))\"", "lemma bin_nth_sc [simp]: \"bit (bin_sc n b w) n \\<longleftrightarrow> b\"", "lemma bin_sc_sc_same [simp]: \"bin_sc n c (bin_sc n b w) = bin_sc n c w\"", "lemma bin_sc_sc_diff: \"m \\<noteq> n \\<Longrightarrow> bin_sc m c (bin_sc n b w) = bin_sc n b (bin_sc m c w)\"", "lemma bin_nth_sc_gen: \"bin_nth (bin_sc n b w) m = (if m = n then b else bin_nth w m)\"", "lemma bin_sc_eq:\n  \\<open>bin_sc n False = unset_bit n\\<close>\n  \\<open>bin_sc n True = Bit_Operations.set_bit n\\<close>", "lemma bin_sc_nth [simp]: \"bin_sc n (bin_nth w n) w = w\"", "lemma bin_sign_sc [simp]: \"bin_sign (bin_sc n b w) = bin_sign w\"", "lemma bin_sc_bintr [simp]:\n  \"bintrunc m (bin_sc n x (bintrunc m w)) = bintrunc m (bin_sc n x w)\"", "lemma bin_clr_le: \"bin_sc n False w \\<le> w\"", "lemma bin_set_ge: \"bin_sc n True w \\<ge> w\"", "lemma bintr_bin_clr_le: \"bintrunc n (bin_sc m False w) \\<le> bintrunc n w\"", "lemma bintr_bin_set_ge: \"bintrunc n (bin_sc m True w) \\<ge> bintrunc n w\"", "lemma bin_sc_FP [simp]: \"bin_sc n False 0 = 0\"", "lemma bin_sc_TM [simp]: \"bin_sc n True (- 1) = - 1\"", "lemmas bin_sc_simps = bin_sc.Z bin_sc.Suc bin_sc_TM bin_sc_FP", "lemma bin_sc_minus: \"0 < n \\<Longrightarrow> bin_sc (Suc (n - 1)) b w = bin_sc n b w\"", "lemmas bin_sc_Suc_minus =\n  trans [OF bin_sc_minus [symmetric] bin_sc.Suc]", "lemma bin_sc_numeral [simp]:\n  \"bin_sc (numeral k) b w =\n    of_bool (odd w) + 2 * bin_sc (pred_numeral k) b (w div 2)\"", "lemmas bin_sc_minus_simps =\n  bin_sc_simps (2,3,4) [THEN [2] trans, OF bin_sc_minus [THEN sym]]", "lemma test_bit_int_def [iff]:\n  \"i !! n \\<longleftrightarrow> bin_nth i n\"", "lemma shiftl_int_def:\n  \"shiftl x n = x * 2 ^ n\" for x :: int", "lemma shiftr_int_def:\n  \"shiftr x n = x div 2 ^ n\" for x :: int", "lemmas int_not_def = not_int_def", "lemma int_not_simps [simp]:\n  \"NOT (0::int) = -1\"\n  \"NOT (1::int) = -2\"\n  \"NOT (- 1::int) = 0\"\n  \"NOT (numeral w::int) = - numeral (w + Num.One)\"\n  \"NOT (- numeral (Num.Bit0 w)::int) = numeral (Num.BitM w)\"\n  \"NOT (- numeral (Num.Bit1 w)::int) = numeral (Num.Bit0 w)\"", "lemma int_not_not: \"NOT (NOT x) = x\"\n  for x :: int", "lemma int_and_0 [simp]: \"0 AND x = 0\"\n  for x :: int", "lemma int_and_m1 [simp]: \"-1 AND x = x\"\n  for x :: int", "lemma int_or_zero [simp]: \"0 OR x = x\"\n  for x :: int", "lemma int_or_minus1 [simp]: \"-1 OR x = -1\"\n  for x :: int", "lemma int_xor_zero [simp]: \"0 XOR x = x\"\n  for x :: int", "lemma bin_rest_NOT [simp]: \"bin_rest (NOT x) = NOT (bin_rest x)\"", "lemma bin_last_NOT [simp]: \"bin_last (NOT x) \\<longleftrightarrow> \\<not> bin_last x\"", "lemma bin_rest_AND [simp]: \"bin_rest (x AND y) = bin_rest x AND bin_rest y\"", "lemma bin_last_AND [simp]: \"bin_last (x AND y) \\<longleftrightarrow> bin_last x \\<and> bin_last y\"", "lemma bin_rest_OR [simp]: \"bin_rest (x OR y) = bin_rest x OR bin_rest y\"", "lemma bin_last_OR [simp]: \"bin_last (x OR y) \\<longleftrightarrow> bin_last x \\<or> bin_last y\"", "lemma bin_rest_XOR [simp]: \"bin_rest (x XOR y) = bin_rest x XOR bin_rest y\"", "lemma bin_last_XOR [simp]: \"bin_last (x XOR y) \\<longleftrightarrow> (bin_last x \\<or> bin_last y) \\<and> \\<not> (bin_last x \\<and> bin_last y)\"", "lemma bin_nth_ops:\n  \"\\<And>x y. bin_nth (x AND y) n \\<longleftrightarrow> bin_nth x n \\<and> bin_nth y n\"\n  \"\\<And>x y. bin_nth (x OR y) n \\<longleftrightarrow> bin_nth x n \\<or> bin_nth y n\"\n  \"\\<And>x y. bin_nth (x XOR y) n \\<longleftrightarrow> bin_nth x n \\<noteq> bin_nth y n\"\n  \"\\<And>x. bin_nth (NOT x) n \\<longleftrightarrow> \\<not> bin_nth x n\"", "lemma int_xor_minus1 [simp]: \"-1 XOR x = NOT x\"\n  for x :: int", "lemma int_xor_extra_simps [simp]:\n  \"w XOR 0 = w\"\n  \"w XOR -1 = NOT w\"\n  for w :: int", "lemma int_or_extra_simps [simp]:\n  \"w OR 0 = w\"\n  \"w OR -1 = -1\"\n  for w :: int", "lemma int_and_extra_simps [simp]:\n  \"w AND 0 = 0\"\n  \"w AND -1 = w\"\n  for w :: int", "lemma bin_ops_comm:\n  fixes x y :: int\n  shows int_and_comm: \"x AND y = y AND x\"\n    and int_or_comm:  \"x OR y = y OR x\"\n    and int_xor_comm: \"x XOR y = y XOR x\"", "lemma bin_ops_same [simp]:\n  \"x AND x = x\"\n  \"x OR x = x\"\n  \"x XOR x = 0\"\n  for x :: int", "lemmas bin_log_esimps =\n  int_and_extra_simps  int_or_extra_simps  int_xor_extra_simps\n  int_and_0 int_and_m1 int_or_zero int_or_minus1 int_xor_zero int_xor_minus1", "lemma bbw_ao_absorb: \"x AND (y OR x) = x \\<and> x OR (y AND x) = x\"\n  for x y :: int", "lemma bbw_ao_absorbs_other:\n  \"x AND (x OR y) = x \\<and> (y AND x) OR x = x\"\n  \"(y OR x) AND x = x \\<and> x OR (x AND y) = x\"\n  \"(x OR y) AND x = x \\<and> (x AND y) OR x = x\"\n  for x y :: int", "lemmas bbw_ao_absorbs [simp] = bbw_ao_absorb bbw_ao_absorbs_other", "lemma int_xor_not: \"(NOT x) XOR y = NOT (x XOR y) \\<and> x XOR (NOT y) = NOT (x XOR y)\"\n  for x y :: int", "lemma int_and_assoc: \"(x AND y) AND z = x AND (y AND z)\"\n  for x y z :: int", "lemma int_or_assoc: \"(x OR y) OR z = x OR (y OR z)\"\n  for x y z :: int", "lemma int_xor_assoc: \"(x XOR y) XOR z = x XOR (y XOR z)\"\n  for x y z :: int", "lemmas bbw_assocs = int_and_assoc int_or_assoc int_xor_assoc", "lemma bbw_lcs [simp]:\n  \"y AND (x AND z) = x AND (y AND z)\"\n  \"y OR (x OR z) = x OR (y OR z)\"\n  \"y XOR (x XOR z) = x XOR (y XOR z)\"\n  for x y :: int", "lemma bbw_not_dist:\n  \"NOT (x OR y) = (NOT x) AND (NOT y)\"\n  \"NOT (x AND y) = (NOT x) OR (NOT y)\"\n  for x y :: int", "lemma bbw_oa_dist: \"(x AND y) OR z = (x OR z) AND (y OR z)\"\n  for x y z :: int", "lemma bbw_ao_dist: \"(x OR y) AND z = (x AND z) OR (y AND z)\"\n  for x y z :: int", "lemma bin_rest_neg_numeral_BitM [simp]:\n  \"bin_rest (- numeral (Num.BitM w)) = - numeral w\"", "lemma bin_last_neg_numeral_BitM [simp]:\n  \"bin_last (- numeral (Num.BitM w))\"", "lemma le_int_or: \"bin_sign y = 0 \\<Longrightarrow> x \\<le> x OR y\"\n  for x y :: int", "lemmas int_and_le =\n  xtrans(3) [OF bbw_ao_absorbs (2) [THEN conjunct2, symmetric] le_int_or]", "lemma bin_add_not: \"x + NOT x = (-1::int)\"", "lemma AND_mod: \"x AND (2 ^ n - 1) = x mod 2 ^ n\"\n  for x :: int", "lemma bin_trunc_ao:\n  \"bintrunc n x AND bintrunc n y = bintrunc n (x AND y)\"\n  \"bintrunc n x OR bintrunc n y = bintrunc n (x OR y)\"", "lemma bin_trunc_xor: \"bintrunc n (bintrunc n x XOR bintrunc n y) = bintrunc n (x XOR y)\"", "lemma bin_trunc_not: \"bintrunc n (NOT (bintrunc n x)) = bintrunc n (NOT x)\"", "lemma bintr_bintr_i: \"x = bintrunc n y \\<Longrightarrow> bintrunc n x = bintrunc n y\"", "lemmas bin_trunc_and = bin_trunc_ao(1) [THEN bintr_bintr_i]", "lemmas bin_trunc_or = bin_trunc_ao(2) [THEN bintr_bintr_i]", "lemma not_int_cmp_0 [simp]:\n  fixes i :: int shows\n  \"0 < NOT i \\<longleftrightarrow> i < -1\"\n  \"0 \\<le> NOT i \\<longleftrightarrow> i < 0\"\n  \"NOT i < 0 \\<longleftrightarrow> i \\<ge> 0\"\n  \"NOT i \\<le> 0 \\<longleftrightarrow> i \\<ge> -1\"", "lemma bbw_ao_dist2: \"(x :: int) AND (y OR z) = x AND y OR x AND z\"", "lemmas int_and_ac = bbw_lcs(1) int_and_comm int_and_assoc", "lemma int_nand_same [simp]: fixes x :: int shows \"x AND NOT x = 0\"", "lemma int_nand_same_middle: fixes x :: int shows \"x AND y AND NOT x = 0\"", "lemma and_xor_dist: fixes x :: int shows\n  \"x AND (y XOR z) = (x AND y) XOR (x AND z)\"", "lemma int_and_lt0 [simp]:\n  \\<open>x AND y < 0 \\<longleftrightarrow> x < 0 \\<and> y < 0\\<close> for x y :: int", "lemma int_and_ge0 [simp]:\n  \\<open>x AND y \\<ge> 0 \\<longleftrightarrow> x \\<ge> 0 \\<or> y \\<ge> 0\\<close> for x y :: int", "lemma int_and_1: fixes x :: int shows \"x AND 1 = x mod 2\"", "lemma int_1_and: fixes x :: int shows \"1 AND x = x mod 2\"", "lemma int_or_lt0 [simp]:\n  \\<open>x OR y < 0 \\<longleftrightarrow> x < 0 \\<or> y < 0\\<close> for x y :: int", "lemma int_or_ge0 [simp]:\n  \\<open>x OR y \\<ge> 0 \\<longleftrightarrow> x \\<ge> 0 \\<and> y \\<ge> 0\\<close> for x y :: int", "lemma int_xor_lt0 [simp]:\n  \\<open>x XOR y < 0 \\<longleftrightarrow> (x < 0) \\<noteq> (y < 0)\\<close> for x y :: int", "lemma int_xor_ge0 [simp]:\n  \\<open>x XOR y \\<ge> 0 \\<longleftrightarrow> (x \\<ge> 0 \\<longleftrightarrow> y \\<ge> 0)\\<close> for x y :: int", "lemma even_conv_AND:\n  \\<open>even i \\<longleftrightarrow> i AND 1 = 0\\<close> for i :: int", "lemma bin_last_conv_AND:\n  \"bin_last i \\<longleftrightarrow> i AND 1 \\<noteq> 0\"", "lemma bitval_bin_last:\n  \"of_bool (bin_last i) = i AND 1\"", "lemma bin_sign_and:\n  \"bin_sign (i AND j) = - (bin_sign i * bin_sign j)\"", "lemma int_not_neg_numeral: \"NOT (- numeral n) = (Num.sub n num.One :: int)\"", "lemma int_neg_numeral_pOne_conv_not: \"- numeral (n + num.One) = (NOT (numeral n) :: int)\"", "lemma int_shiftl_BIT: fixes x :: int\n  shows int_shiftl0 [simp]: \"x << 0 = x\"\n  and int_shiftl_Suc [simp]: \"x << Suc n = 2 * (x << n)\"", "lemma int_0_shiftl [simp]: \"0 << n = (0 :: int)\"", "lemma bin_last_shiftl: \"bin_last (x << n) \\<longleftrightarrow> n = 0 \\<and> bin_last x\"", "lemma bin_rest_shiftl: \"bin_rest (x << n) = (if n > 0 then x << (n - 1) else bin_rest x)\"", "lemma bin_nth_shiftl [simp]: \"bin_nth (x << n) m \\<longleftrightarrow> n \\<le> m \\<and> bin_nth x (m - n)\"", "lemma bin_last_shiftr: \"odd (x >> n) \\<longleftrightarrow> x !! n\" for x :: int", "lemma bin_rest_shiftr [simp]: \"bin_rest (x >> n) = x >> Suc n\"", "lemma bin_nth_shiftr [simp]: \"bin_nth (x >> n) m = bin_nth x (n + m)\"", "lemma bin_nth_conv_AND:\n  fixes x :: int shows\n  \"bin_nth x n \\<longleftrightarrow> x AND (1 << n) \\<noteq> 0\"", "lemma int_shiftl_numeral [simp]:\n  \"(numeral w :: int) << numeral w' = numeral (num.Bit0 w) << pred_numeral w'\"\n  \"(- numeral w :: int) << numeral w' = - numeral (num.Bit0 w) << pred_numeral w'\"", "lemma int_shiftl_One_numeral [simp]:\n  \"(1 :: int) << numeral w = 2 << pred_numeral w\"", "lemma shiftl_ge_0 [simp]: fixes i :: int shows \"i << n \\<ge> 0 \\<longleftrightarrow> i \\<ge> 0\"", "lemma shiftl_lt_0 [simp]: fixes i :: int shows \"i << n < 0 \\<longleftrightarrow> i < 0\"", "lemma int_shiftl_test_bit: \"(n << i :: int) !! m \\<longleftrightarrow> m \\<ge> i \\<and> n !! (m - i)\"", "lemma int_0shiftr [simp]: \"(0 :: int) >> x = 0\"", "lemma int_minus1_shiftr [simp]: \"(-1 :: int) >> x = -1\"", "lemma int_shiftr_ge_0 [simp]: fixes i :: int shows \"i >> n \\<ge> 0 \\<longleftrightarrow> i \\<ge> 0\"", "lemma int_shiftr_lt_0 [simp]: fixes i :: int shows \"i >> n < 0 \\<longleftrightarrow> i < 0\"", "lemma int_shiftr_numeral [simp]:\n  \"(1 :: int) >> numeral w' = 0\"\n  \"(numeral num.One :: int) >> numeral w' = 0\"\n  \"(numeral (num.Bit0 w) :: int) >> numeral w' = numeral w >> pred_numeral w'\"\n  \"(numeral (num.Bit1 w) :: int) >> numeral w' = numeral w >> pred_numeral w'\"\n  \"(- numeral (num.Bit0 w) :: int) >> numeral w' = - numeral w >> pred_numeral w'\"\n  \"(- numeral (num.Bit1 w) :: int) >> numeral w' = - numeral (Num.inc w) >> pred_numeral w'\"", "lemma int_shiftr_numeral_Suc0 [simp]:\n  \"(1 :: int) >> Suc 0 = 0\"\n  \"(numeral num.One :: int) >> Suc 0 = 0\"\n  \"(numeral (num.Bit0 w) :: int) >> Suc 0 = numeral w\"\n  \"(numeral (num.Bit1 w) :: int) >> Suc 0 = numeral w\"\n  \"(- numeral (num.Bit0 w) :: int) >> Suc 0 = - numeral w\"\n  \"(- numeral (num.Bit1 w) :: int) >> Suc 0 = - numeral (Num.inc w)\"", "lemma bin_nth_minus_p2:\n  assumes sign: \"bin_sign x = 0\"\n  and y: \"y = 1 << n\"\n  and m: \"m < n\"\n  and x: \"x < y\"\n  shows \"bin_nth (x - y) m = bin_nth x m\"", "lemma bin_clr_conv_NAND:\n  \"bin_sc n False i = i AND NOT (1 << n)\"", "lemma bin_set_conv_OR:\n  \"bin_sc n True i = i OR (1 << n)\"", "lemma word_rcat_eq:\n  \\<open>word_rcat ws = word_of_int (bin_rcat (LENGTH('a::len)) (map uint ws))\\<close>\n  for ws :: \\<open>'a::len word list\\<close>", "lemma sign_uint_Pls [simp]: \"bin_sign (uint x) = 0\"", "lemmas bin_log_bintrs = bin_trunc_not bin_trunc_xor bin_trunc_and bin_trunc_or\n\n\\<comment> \\<open>following definitions require both arithmetic and bit-wise word operations\\<close>\n\n\\<comment> \\<open>to get \\<open>word_no_log_defs\\<close> from \\<open>word_log_defs\\<close>, using \\<open>bin_log_bintrs\\<close>\\<close>", "lemmas wils1 = bin_log_bintrs [THEN word_of_int_eq_iff [THEN iffD2],\n  folded uint_word_of_int_eq, THEN eq_reflection]\n\n\\<comment> \\<open>the binary operations only\\<close>", "lemmas word_log_binary_defs =\n  word_and_def word_or_def word_xor_def", "lemma setBit_no [simp]: \"setBit (numeral bin) n = word_of_int (bin_sc n True (numeral bin))\"", "lemma clearBit_no [simp]:\n  \"clearBit (numeral bin) n = word_of_int (bin_sc n False (numeral bin))\"", "lemma eq_mod_iff: \"0 < n \\<Longrightarrow> b = b mod n \\<longleftrightarrow> 0 \\<le> b \\<and> b < n\"\n  for b n :: int", "lemma split_uint_lem: \"bin_split n (uint w) = (a, b) \\<Longrightarrow>\n    a = take_bit (LENGTH('a) - n) a \\<and> b = take_bit (LENGTH('a)) b\"\n  for w :: \"'a::len word\"", "lemma word_cat_hom:\n  \"LENGTH('a::len) \\<le> LENGTH('b::len) + LENGTH('c::len) \\<Longrightarrow>\n    (word_cat (word_of_int w :: 'b word) (b :: 'c word) :: 'a word) =\n    word_of_int (bin_cat w (size b) (uint b))\"", "lemma bintrunc_shiftl:\n  \"take_bit n (m << i) = take_bit (n - i) m << i\"\n  for m :: int", "lemma uint_shiftl:\n  \"uint (n << i) = take_bit (size n) (uint n << i)\"", "lemma bin_mask_conv_pow2:\n  \"mask n = 2 ^ n - (1 :: int)\"", "lemma bin_mask_ge0: \"mask n \\<ge> (0 :: int)\"", "lemma and_bin_mask_conv_mod: \"x AND mask n = x mod 2 ^ n\"\n  for x :: int", "lemma bin_mask_numeral:\n  \"mask (numeral n) = (1 :: int) + 2 * mask (pred_numeral n)\"", "lemma bin_nth_mask [simp]: \"bit (mask n :: int) i \\<longleftrightarrow> i < n\"", "lemma bin_sign_mask [simp]: \"bin_sign (mask n) = 0\"", "lemma bin_mask_p1_conv_shift: \"mask n + 1 = (1 :: int) << n\"", "lemma sbintrunc_eq_in_range:\n  \"(sbintrunc n x = x) = (x \\<in> range (sbintrunc n))\"\n  \"(x = sbintrunc n x) = (x \\<in> range (sbintrunc n))\"", "lemma sbintrunc_If:\n  \"- 3 * (2 ^ n) \\<le> x \\<and> x < 3 * (2 ^ n)\n    \\<Longrightarrow> sbintrunc n x = (if x < - (2 ^ n) then x + 2 * (2 ^ n)\n        else if x \\<ge> 2 ^ n then x - 2 * (2 ^ n) else x)\"", "lemma sint_range':\n  \\<open>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x \\<and> sint x < 2 ^ (LENGTH('a) - Suc 0)\\<close>\n  for x :: \\<open>'a::len word\\<close>", "lemma signed_arith_eq_checks_to_ord:\n  \"(sint a + sint b = sint (a + b ))\n    = ((a <=s a + b) = (0 <=s b))\"\n  \"(sint a - sint b = sint (a - b ))\n    = ((0 <=s a - b) = (b <=s a))\"\n  \"(- sint a = sint (- a)) = (0 <=s (- a) = (a <=s 0))\"", "lemma signed_mult_eq_checks_double_size:\n  assumes mult_le: \"(2 ^ (len_of TYPE ('a) - 1) + 1) ^ 2 \\<le> (2 :: int) ^ (len_of TYPE ('b) - 1)\"\n           and le: \"2 ^ (LENGTH('a) - 1) \\<le> (2 :: int) ^ (len_of TYPE ('b) - 1)\"\n  shows \"(sint (a :: 'a :: len word) * sint b = sint (a * b))\n       = (scast a * scast b = (scast (a * b) :: 'b :: len word))\""], "translations": [["", "lemma bin_last_def:\n  \"bin_last w \\<longleftrightarrow> w mod 2 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd w = (w mod 2 = 1)", "by (fact odd_iff_mod_2_eq_one)"], ["", "abbreviation (input) bin_rest :: \"int \\<Rightarrow> int\"\n  where \"bin_rest w \\<equiv> w div 2\""], ["", "lemma bin_last_numeral_simps [simp]:\n  \"\\<not> odd (0 :: int)\"\n  \"odd (1 :: int)\"\n  \"odd (- 1 :: int)\"\n  \"odd (Numeral1 :: int)\"\n  \"\\<not> odd (numeral (Num.Bit0 w) :: int)\"\n  \"odd (numeral (Num.Bit1 w) :: int)\"\n  \"\\<not> odd (- numeral (Num.Bit0 w) :: int)\"\n  \"odd (- numeral (Num.Bit1 w) :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<not> odd 0 &&& \\<not> is_unit 2) &&& odd (- 1) &&& odd Numeral1) &&&\n    (\\<not> odd (numeral (num.Bit0 w)) &&& odd (numeral (num.Bit1 w))) &&&\n    \\<not> odd (- numeral (num.Bit0 w)) &&& odd (- numeral (num.Bit1 w))", "by simp_all"], ["", "lemma bin_rest_numeral_simps [simp]:\n  \"bin_rest 0 = 0\"\n  \"bin_rest 1 = 0\"\n  \"bin_rest (- 1) = - 1\"\n  \"bin_rest Numeral1 = 0\"\n  \"bin_rest (numeral (Num.Bit0 w)) = numeral w\"\n  \"bin_rest (numeral (Num.Bit1 w)) = numeral w\"\n  \"bin_rest (- numeral (Num.Bit0 w)) = - numeral w\"\n  \"bin_rest (- numeral (Num.Bit1 w)) = - numeral (w + Num.One)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0 div 2 = 0 &&& 1 div 2 = 0) &&&\n     - 1 div 2 = - 1 &&& Numeral1 div 2 = 0) &&&\n    (numeral (num.Bit0 w) div 2 = numeral w &&&\n     numeral (num.Bit1 w) div 2 = numeral w) &&&\n    - numeral (num.Bit0 w) div 2 = - numeral w &&&\n    - numeral (num.Bit1 w) div 2 = - numeral (w + num.One)", "by simp_all"], ["", "lemma bin_rl_eqI: \"\\<lbrakk>bin_rest x = bin_rest y; odd x = odd y\\<rbrakk> \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x div 2 = y div 2; odd x = odd y\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (auto elim: oddE)"], ["", "lemma [simp]:\n  shows bin_rest_lt0: \"bin_rest i < 0 \\<longleftrightarrow> i < 0\"\n  and  bin_rest_ge_0: \"bin_rest i \\<ge> 0 \\<longleftrightarrow> i \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i div 2 < 0) = (i < 0) &&& (0 \\<le> i div 2) = (0 \\<le> i)", "by auto"], ["", "lemma bin_rest_gt_0 [simp]: \"bin_rest x > 0 \\<longleftrightarrow> x > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < x div 2) = (1 < x)", "by auto"], ["", "subsection \\<open>Bit projection\\<close>"], ["", "abbreviation (input) bin_nth :: \\<open>int \\<Rightarrow> nat \\<Rightarrow> bool\\<close>\n  where \\<open>bin_nth \\<equiv> bit\\<close>"], ["", "lemma bin_nth_eq_iff: \"bin_nth x = bin_nth y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bit x = bit y) = (x = y)", "by (simp add: bit_eq_iff fun_eq_iff)"], ["", "lemma bin_eqI:\n  \"x = y\" if \"\\<And>n. bin_nth x n \\<longleftrightarrow> bin_nth y n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using that bin_nth_eq_iff [of x y]"], ["proof (prove)\nusing this:\n  bit x ?n = bit y ?n\n  (bit x = bit y) = (x = y)\n\ngoal (1 subgoal):\n 1. x = y", "by (simp add: fun_eq_iff)"], ["", "lemma bin_eq_iff: \"x = y \\<longleftrightarrow> (\\<forall>n. bin_nth x n = bin_nth y n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) = (\\<forall>n. bit x n = bit y n)", "by (fact bit_eq_iff)"], ["", "lemma bin_nth_zero [simp]: \"\\<not> bin_nth 0 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bit 0 n", "by simp"], ["", "lemma bin_nth_1 [simp]: \"bin_nth 1 n \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit 1 n = (n = 0)", "by (cases n) (simp_all add: bit_Suc)"], ["", "lemma bin_nth_minus1 [simp]: \"bin_nth (- 1) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (- 1) n", "by (induction n) (simp_all add: bit_Suc)"], ["", "lemma bin_nth_numeral: \"bin_rest x = y \\<Longrightarrow> bin_nth x (numeral n) = bin_nth y (pred_numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x div 2 = y \\<Longrightarrow> bit x (numeral n) = bit y (pred_numeral n)", "by (simp add: numeral_eq_Suc bit_Suc)"], ["", "lemmas bin_nth_numeral_simps [simp] =\n  bin_nth_numeral [OF bin_rest_numeral_simps(8)]"], ["", "lemmas bin_nth_simps =\n  bit_0 bit_Suc bin_nth_zero bin_nth_minus1\n  bin_nth_numeral_simps"], ["", "lemma nth_2p_bin: \"bin_nth (2 ^ n) m = (m = n)\" \\<comment> \\<open>for use when simplifying with \\<open>bin_nth_Bit\\<close>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (2 ^ n) m = (m = n)", "by (auto simp add: bit_exp_iff)"], ["", "lemma nth_rest_power_bin: \"bin_nth ((bin_rest ^^ k) w) n = bin_nth w (n + k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (((\\<lambda>w. w div 2) ^^ k) w) n = bit w (n + k)", "apply (induct k arbitrary: n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. bit (((\\<lambda>w. w div 2) ^^ 0) w) n = bit w (n + 0)\n 2. \\<And>k n.\n       (\\<And>n.\n           bit (((\\<lambda>w. w div 2) ^^ k) w) n =\n           bit w (n + k)) \\<Longrightarrow>\n       bit (((\\<lambda>w. w div 2) ^^ Suc k) w) n = bit w (n + Suc k)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k n.\n       (\\<And>n.\n           bit (((\\<lambda>w. w div 2) ^^ k) w) n =\n           bit w (n + k)) \\<Longrightarrow>\n       bit (((\\<lambda>w. w div 2) ^^ Suc k) w) n = bit w (n + Suc k)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k n.\n       (\\<And>n.\n           bit (((\\<lambda>w. w div 2) ^^ k) w) n =\n           bit w (n + k)) \\<Longrightarrow>\n       bit (((\\<lambda>w. w div 2) ^^ k) w div 2) n = bit w (Suc (n + k))", "apply (simp only: bit_Suc [symmetric] add_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_nth_numeral_unfold:\n  \"bin_nth (numeral (num.Bit0 x)) n \\<longleftrightarrow> n > 0 \\<and> bin_nth (numeral x) (n - 1)\"\n  \"bin_nth (numeral (num.Bit1 x)) n \\<longleftrightarrow> (n > 0 \\<longrightarrow> bin_nth (numeral x) (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (numeral (num.Bit0 x)) n =\n    (0 < n \\<and> bit (numeral x) (n - 1)) &&&\n    bit (numeral (num.Bit1 x)) n =\n    (0 < n \\<longrightarrow> bit (numeral x) (n - 1))", "by (cases n; simp)+"], ["", "subsection \\<open>Truncating\\<close>"], ["", "definition bin_sign :: \"int \\<Rightarrow> int\"\n  where \"bin_sign k = (if k \\<ge> 0 then 0 else - 1)\""], ["", "lemma bin_sign_simps [simp]:\n  \"bin_sign 0 = 0\"\n  \"bin_sign 1 = 0\"\n  \"bin_sign (- 1) = - 1\"\n  \"bin_sign (numeral k) = 0\"\n  \"bin_sign (- numeral k) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bin_sign 0 = 0 &&& bin_sign 1 = 0) &&&\n    bin_sign (- 1) = - 1 &&&\n    bin_sign (numeral k) = 0 &&& bin_sign (- numeral k) = - 1", "by (simp_all add: bin_sign_def)"], ["", "lemma bin_sign_rest [simp]: \"bin_sign (bin_rest w) = bin_sign w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sign (w div 2) = bin_sign w", "by (simp add: bin_sign_def)"], ["", "abbreviation (input) bintrunc :: \\<open>nat \\<Rightarrow> int \\<Rightarrow> int\\<close>\n  where \\<open>bintrunc \\<equiv> take_bit\\<close>"], ["", "lemma bintrunc_mod2p: \"bintrunc n w = w mod 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n w = w mod 2 ^ n", "by (fact take_bit_eq_mod)"], ["", "abbreviation (input) sbintrunc :: \\<open>nat \\<Rightarrow> int \\<Rightarrow> int\\<close>\n  where \\<open>sbintrunc \\<equiv> signed_take_bit\\<close>"], ["", "abbreviation (input) norm_sint :: \\<open>nat \\<Rightarrow> int \\<Rightarrow> int\\<close>\n  where \\<open>norm_sint n \\<equiv> signed_take_bit (n - 1)\\<close>"], ["", "lemma sbintrunc_mod2p: \"sbintrunc n w = (w + 2 ^ n) mod 2 ^ Suc n - 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n w = (w + 2 ^ n) mod 2 ^ Suc n - 2 ^ n", "by (simp add: bintrunc_mod2p signed_take_bit_eq_take_bit_shift)"], ["", "lemma sbintrunc_eq_take_bit:\n  \\<open>sbintrunc n k = take_bit (Suc n) (k + 2 ^ n) - 2 ^ n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n k = take_bit (Suc n) (k + 2 ^ n) - 2 ^ n", "by (fact signed_take_bit_eq_take_bit_shift)"], ["", "lemma sign_bintr: \"bin_sign (bintrunc n w) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sign (take_bit n w) = 0", "by (simp add: bin_sign_def)"], ["", "lemma bintrunc_n_0: \"bintrunc n 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n 0 = 0", "by (fact take_bit_of_0)"], ["", "lemma sbintrunc_n_0: \"sbintrunc n 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n 0 = 0", "by (fact signed_take_bit_of_0)"], ["", "lemma sbintrunc_n_minus1: \"sbintrunc n (- 1) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n (- 1) = - 1", "by (fact signed_take_bit_of_minus_1)"], ["", "lemma bintrunc_Suc_numeral:\n  \"bintrunc (Suc n) 1 = 1\"\n  \"bintrunc (Suc n) (- 1) = 1 + 2 * bintrunc n (- 1)\"\n  \"bintrunc (Suc n) (numeral (Num.Bit0 w)) = 2 * bintrunc n (numeral w)\"\n  \"bintrunc (Suc n) (numeral (Num.Bit1 w)) = 1 + 2 * bintrunc n (numeral w)\"\n  \"bintrunc (Suc n) (- numeral (Num.Bit0 w)) = 2 * bintrunc n (- numeral w)\"\n  \"bintrunc (Suc n) (- numeral (Num.Bit1 w)) = 1 + 2 * bintrunc n (- numeral (w + Num.One))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take_bit (Suc n) 1 = 1 &&&\n     take_bit (Suc n) (- 1) = 1 + 2 * take_bit n (- 1) &&&\n     take_bit (Suc n) (numeral (num.Bit0 w)) =\n     2 * take_bit n (numeral w)) &&&\n    take_bit (Suc n) (numeral (num.Bit1 w)) =\n    1 + 2 * take_bit n (numeral w) &&&\n    take_bit (Suc n) (- numeral (num.Bit0 w)) =\n    2 * take_bit n (- numeral w) &&&\n    take_bit (Suc n) (- numeral (num.Bit1 w)) =\n    1 + 2 * take_bit n (- numeral (w + num.One))", "by (simp_all add: take_bit_Suc)"], ["", "lemma sbintrunc_0_numeral [simp]:\n  \"sbintrunc 0 1 = -1\"\n  \"sbintrunc 0 (numeral (Num.Bit0 w)) = 0\"\n  \"sbintrunc 0 (numeral (Num.Bit1 w)) = -1\"\n  \"sbintrunc 0 (- numeral (Num.Bit0 w)) = 0\"\n  \"sbintrunc 0 (- numeral (Num.Bit1 w)) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (signed_take_bit 0 1 = - 1 &&&\n     signed_take_bit 0 (numeral (num.Bit0 w)) = 0) &&&\n    signed_take_bit 0 (numeral (num.Bit1 w)) = - 1 &&&\n    signed_take_bit 0 (- numeral (num.Bit0 w)) = 0 &&&\n    signed_take_bit 0 (- numeral (num.Bit1 w)) = - 1", "by simp_all"], ["", "lemma sbintrunc_Suc_numeral:\n  \"sbintrunc (Suc n) 1 = 1\"\n  \"sbintrunc (Suc n) (numeral (Num.Bit0 w)) = 2 * sbintrunc n (numeral w)\"\n  \"sbintrunc (Suc n) (numeral (Num.Bit1 w)) = 1 + 2 * sbintrunc n (numeral w)\"\n  \"sbintrunc (Suc n) (- numeral (Num.Bit0 w)) = 2 * sbintrunc n (- numeral w)\"\n  \"sbintrunc (Suc n) (- numeral (Num.Bit1 w)) = 1 + 2 * sbintrunc n (- numeral (w + Num.One))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (signed_take_bit (Suc n) 1 = 1 &&&\n     signed_take_bit (Suc n) (numeral (num.Bit0 w)) =\n     2 * signed_take_bit n (numeral w)) &&&\n    signed_take_bit (Suc n) (numeral (num.Bit1 w)) =\n    1 + 2 * signed_take_bit n (numeral w) &&&\n    signed_take_bit (Suc n) (- numeral (num.Bit0 w)) =\n    2 * signed_take_bit n (- numeral w) &&&\n    signed_take_bit (Suc n) (- numeral (num.Bit1 w)) =\n    1 + 2 * signed_take_bit n (- numeral (w + num.One))", "by (simp_all add: signed_take_bit_Suc)"], ["", "lemma bin_sign_lem: \"(bin_sign (sbintrunc n bin) = -1) = bit bin n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bin_sign (signed_take_bit n bin) = - 1) = bit bin n", "by (simp add: bin_sign_def)"], ["", "lemma nth_bintr: \"bin_nth (bintrunc m w) n \\<longleftrightarrow> n < m \\<and> bin_nth w n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (take_bit m w) n = (n < m \\<and> bit w n)", "by (fact bit_take_bit_iff)"], ["", "lemma nth_sbintr: \"bin_nth (sbintrunc m w) n = (if n < m then bin_nth w n else bin_nth w m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (signed_take_bit m w) n = (if n < m then bit w n else bit w m)", "by (simp add: bit_signed_take_bit_iff min_def)"], ["", "lemma bin_nth_Bit0:\n  \"bin_nth (numeral (Num.Bit0 w)) n \\<longleftrightarrow>\n    (\\<exists>m. n = Suc m \\<and> bin_nth (numeral w) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (numeral (num.Bit0 w)) n =\n    (\\<exists>m. n = Suc m \\<and> bit (numeral w) m)", "using bit_double_iff [of \\<open>numeral w :: int\\<close> n]"], ["proof (prove)\nusing this:\n  bit (2 * numeral w) n =\n  (bit (numeral w) (n - 1) \\<and> n \\<noteq> 0 \\<and> 2 ^ n \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. bit (numeral (num.Bit0 w)) n =\n    (\\<exists>m. n = Suc m \\<and> bit (numeral w) m)", "by (auto intro: exI [of _ \\<open>n - 1\\<close>])"], ["", "lemma bin_nth_Bit1:\n  \"bin_nth (numeral (Num.Bit1 w)) n \\<longleftrightarrow>\n    n = 0 \\<or> (\\<exists>m. n = Suc m \\<and> bin_nth (numeral w) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (numeral (num.Bit1 w)) n =\n    (n = 0 \\<or> (\\<exists>m. n = Suc m \\<and> bit (numeral w) m))", "using even_bit_succ_iff [of \\<open>2 * numeral w :: int\\<close> n]\n    bit_double_iff [of \\<open>numeral w :: int\\<close> n]"], ["proof (prove)\nusing this:\n  even (2 * numeral w) \\<Longrightarrow>\n  bit (1 + 2 * numeral w) n = (bit (2 * numeral w) n \\<or> n = 0)\n  bit (2 * numeral w) n =\n  (bit (numeral w) (n - 1) \\<and> n \\<noteq> 0 \\<and> 2 ^ n \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. bit (numeral (num.Bit1 w)) n =\n    (n = 0 \\<or> (\\<exists>m. n = Suc m \\<and> bit (numeral w) m))", "by auto"], ["", "lemma bintrunc_bintrunc_l: \"n \\<le> m \\<Longrightarrow> bintrunc m (bintrunc n w) = bintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow> take_bit m (take_bit n w) = take_bit n w", "by simp"], ["", "lemma sbintrunc_sbintrunc_l: \"n \\<le> m \\<Longrightarrow> sbintrunc m (sbintrunc n w) = sbintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow>\n    signed_take_bit m (signed_take_bit n w) = signed_take_bit n w", "by (simp add: min_def)"], ["", "lemma bintrunc_bintrunc_ge: \"n \\<le> m \\<Longrightarrow> bintrunc n (bintrunc m w) = bintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow> take_bit n (take_bit m w) = take_bit n w", "by (rule bin_eqI) (auto simp: nth_bintr)"], ["", "lemma bintrunc_bintrunc_min [simp]: \"bintrunc m (bintrunc n w) = bintrunc (min m n) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit m (take_bit n w) = take_bit (min m n) w", "by (rule take_bit_take_bit)"], ["", "lemma sbintrunc_sbintrunc_min [simp]: \"sbintrunc m (sbintrunc n w) = sbintrunc (min m n) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit m (signed_take_bit n w) = signed_take_bit (min m n) w", "by (rule signed_take_bit_signed_take_bit)"], ["", "lemmas sbintrunc_Suc_Pls =\n  signed_take_bit_Suc [where a=\"0::int\", simplified bin_last_numeral_simps bin_rest_numeral_simps]"], ["", "lemmas sbintrunc_Suc_Min =\n  signed_take_bit_Suc [where a=\"-1::int\", simplified bin_last_numeral_simps bin_rest_numeral_simps]"], ["", "lemmas sbintrunc_Sucs = sbintrunc_Suc_Pls sbintrunc_Suc_Min\n  sbintrunc_Suc_numeral"], ["", "lemmas sbintrunc_Pls =\n  signed_take_bit_0 [where a=\"0::int\", simplified bin_last_numeral_simps bin_rest_numeral_simps]"], ["", "lemmas sbintrunc_Min =\n  signed_take_bit_0 [where a=\"-1::int\", simplified bin_last_numeral_simps bin_rest_numeral_simps]"], ["", "lemmas sbintrunc_0_simps =\n  sbintrunc_Pls sbintrunc_Min"], ["", "lemmas sbintrunc_simps = sbintrunc_0_simps sbintrunc_Sucs"], ["", "lemma bintrunc_minus: \"0 < n \\<Longrightarrow> bintrunc (Suc (n - 1)) w = bintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> take_bit (Suc (n - 1)) w = take_bit n w", "by auto"], ["", "lemma sbintrunc_minus: \"0 < n \\<Longrightarrow> sbintrunc (Suc (n - 1)) w = sbintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    signed_take_bit (Suc (n - 1)) w = signed_take_bit n w", "by auto"], ["", "lemmas sbintrunc_minus_simps =\n  sbintrunc_Sucs [THEN [2] sbintrunc_minus [symmetric, THEN trans]]"], ["", "lemma sbintrunc_BIT_I:\n  \\<open>0 < n \\<Longrightarrow>\n  sbintrunc (n - 1) 0 = y \\<Longrightarrow>\n  sbintrunc n 0 = 2 * y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; signed_take_bit (n - 1) 0 = y\\<rbrakk>\n    \\<Longrightarrow> signed_take_bit n 0 = 2 * y", "by simp"], ["", "lemma sbintrunc_Suc_Is:\n  \\<open>sbintrunc n (- 1) = y \\<Longrightarrow>\n  sbintrunc (Suc n) (- 1) = 1 + 2 * y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n (- 1) = y \\<Longrightarrow>\n    signed_take_bit (Suc n) (- 1) = 1 + 2 * y", "by auto"], ["", "lemma sbintrunc_Suc_lem: \"sbintrunc (Suc n) x = y \\<Longrightarrow> m = Suc n \\<Longrightarrow> sbintrunc m x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>signed_take_bit (Suc n) x = y; m = Suc n\\<rbrakk>\n    \\<Longrightarrow> signed_take_bit m x = y", "by (rule ssubst)"], ["", "lemmas sbintrunc_Suc_Ialts =\n  sbintrunc_Suc_Is [THEN sbintrunc_Suc_lem]"], ["", "lemma sbintrunc_bintrunc_lt: \"m > n \\<Longrightarrow> sbintrunc n (bintrunc m w) = sbintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < m \\<Longrightarrow>\n    signed_take_bit n (take_bit m w) = signed_take_bit n w", "by (rule bin_eqI) (auto simp: nth_sbintr nth_bintr)"], ["", "lemma bintrunc_sbintrunc_le: \"m \\<le> Suc n \\<Longrightarrow> bintrunc m (sbintrunc n w) = bintrunc m w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> Suc n \\<Longrightarrow>\n    take_bit m (signed_take_bit n w) = take_bit m w", "by (rule take_bit_signed_take_bit)"], ["", "lemmas bintrunc_sbintrunc [simp] = order_refl [THEN bintrunc_sbintrunc_le]"], ["", "lemmas sbintrunc_bintrunc [simp] = lessI [THEN sbintrunc_bintrunc_lt]"], ["", "lemmas bintrunc_bintrunc [simp] = order_refl [THEN bintrunc_bintrunc_l]"], ["", "lemmas sbintrunc_sbintrunc [simp] = order_refl [THEN sbintrunc_sbintrunc_l]"], ["", "lemma bintrunc_sbintrunc' [simp]: \"0 < n \\<Longrightarrow> bintrunc n (sbintrunc (n - 1) w) = bintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    take_bit n (signed_take_bit (n - 1) w) = take_bit n w", "by (cases n) simp_all"], ["", "lemma sbintrunc_bintrunc' [simp]: \"0 < n \\<Longrightarrow> sbintrunc (n - 1) (bintrunc n w) = sbintrunc (n - 1) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    signed_take_bit (n - 1) (take_bit n w) = signed_take_bit (n - 1) w", "by (cases n) simp_all"], ["", "lemma bin_sbin_eq_iff: \"bintrunc (Suc n) x = bintrunc (Suc n) y \\<longleftrightarrow> sbintrunc n x = sbintrunc n y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take_bit (Suc n) x = take_bit (Suc n) y) =\n    (signed_take_bit n x = signed_take_bit n y)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. take_bit (Suc n) x = take_bit (Suc n) y \\<Longrightarrow>\n    signed_take_bit n x = signed_take_bit n y\n 2. signed_take_bit n x = signed_take_bit n y \\<Longrightarrow>\n    take_bit (Suc n) x = take_bit (Suc n) y", "apply (rule box_equals [OF _ sbintrunc_bintrunc sbintrunc_bintrunc])"], ["proof (prove)\ngoal (2 subgoals):\n 1. take_bit (Suc n) x = take_bit (Suc n) y \\<Longrightarrow>\n    signed_take_bit n (take_bit (Suc n) x) =\n    signed_take_bit n (take_bit (Suc n) y)\n 2. signed_take_bit n x = signed_take_bit n y \\<Longrightarrow>\n    take_bit (Suc n) x = take_bit (Suc n) y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n x = signed_take_bit n y \\<Longrightarrow>\n    take_bit (Suc n) x = take_bit (Suc n) y", "apply (rule box_equals [OF _ bintrunc_sbintrunc bintrunc_sbintrunc])"], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n x = signed_take_bit n y \\<Longrightarrow>\n    take_bit (Suc n) (signed_take_bit n x) =\n    take_bit (Suc n) (signed_take_bit n y)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_sbin_eq_iff':\n  \"0 < n \\<Longrightarrow> bintrunc n x = bintrunc n y \\<longleftrightarrow> sbintrunc (n - 1) x = sbintrunc (n - 1) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    (take_bit n x = take_bit n y) =\n    (signed_take_bit (n - 1) x = signed_take_bit (n - 1) y)", "by (cases n) (simp_all add: bin_sbin_eq_iff)"], ["", "lemmas bintrunc_sbintruncS0 [simp] = bintrunc_sbintrunc' [unfolded One_nat_def]"], ["", "lemmas sbintrunc_bintruncS0 [simp] = sbintrunc_bintrunc' [unfolded One_nat_def]"], ["", "lemmas bintrunc_bintrunc_l' = le_add1 [THEN bintrunc_bintrunc_l]"], ["", "lemmas sbintrunc_sbintrunc_l' = le_add1 [THEN sbintrunc_sbintrunc_l]"], ["", "(* although bintrunc_minus_simps, if added to default simpset,\n  tends to get applied where it's not wanted in developing the theories,\n  we get a version for when the word length is given literally *)"], ["", "lemmas nat_non0_gr =\n  trans [OF iszero_def [THEN Not_eq_iff [THEN iffD2]] refl]"], ["", "lemma bintrunc_numeral:\n  \"bintrunc (numeral k) x = of_bool (odd x) + 2 * bintrunc (pred_numeral k) (x div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit (numeral k) x =\n    of_bool (odd x) + 2 * take_bit (pred_numeral k) (x div 2)", "by (simp add: numeral_eq_Suc take_bit_Suc mod_2_eq_odd)"], ["", "lemma sbintrunc_numeral:\n  \"sbintrunc (numeral k) x = of_bool (odd x) + 2 * sbintrunc (pred_numeral k) (x div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit (numeral k) x =\n    of_bool (odd x) + 2 * signed_take_bit (pred_numeral k) (x div 2)", "by (simp add: numeral_eq_Suc signed_take_bit_Suc mod2_eq_if)"], ["", "lemma bintrunc_numeral_simps [simp]:\n  \"bintrunc (numeral k) (numeral (Num.Bit0 w)) =\n    2 * bintrunc (pred_numeral k) (numeral w)\"\n  \"bintrunc (numeral k) (numeral (Num.Bit1 w)) =\n    1 + 2 * bintrunc (pred_numeral k) (numeral w)\"\n  \"bintrunc (numeral k) (- numeral (Num.Bit0 w)) =\n    2 * bintrunc (pred_numeral k) (- numeral w)\"\n  \"bintrunc (numeral k) (- numeral (Num.Bit1 w)) =\n    1 + 2 * bintrunc (pred_numeral k) (- numeral (w + Num.One))\"\n  \"bintrunc (numeral k) 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (take_bit (numeral k) (numeral (num.Bit0 w)) =\n     2 * take_bit (pred_numeral k) (numeral w) &&&\n     take_bit (numeral k) (numeral (num.Bit1 w)) =\n     1 + 2 * take_bit (pred_numeral k) (numeral w)) &&&\n    take_bit (numeral k) (- numeral (num.Bit0 w)) =\n    2 * take_bit (pred_numeral k) (- numeral w) &&&\n    take_bit (numeral k) (- numeral (num.Bit1 w)) =\n    1 + 2 * take_bit (pred_numeral k) (- numeral (w + num.One)) &&&\n    take_bit (numeral k) 1 = 1", "by (simp_all add: bintrunc_numeral)"], ["", "lemma sbintrunc_numeral_simps [simp]:\n  \"sbintrunc (numeral k) (numeral (Num.Bit0 w)) =\n    2 * sbintrunc (pred_numeral k) (numeral w)\"\n  \"sbintrunc (numeral k) (numeral (Num.Bit1 w)) =\n    1 + 2 * sbintrunc (pred_numeral k) (numeral w)\"\n  \"sbintrunc (numeral k) (- numeral (Num.Bit0 w)) =\n    2 * sbintrunc (pred_numeral k) (- numeral w)\"\n  \"sbintrunc (numeral k) (- numeral (Num.Bit1 w)) =\n    1 + 2 * sbintrunc (pred_numeral k) (- numeral (w + Num.One))\"\n  \"sbintrunc (numeral k) 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (signed_take_bit (numeral k) (numeral (num.Bit0 w)) =\n     2 * signed_take_bit (pred_numeral k) (numeral w) &&&\n     signed_take_bit (numeral k) (numeral (num.Bit1 w)) =\n     1 + 2 * signed_take_bit (pred_numeral k) (numeral w)) &&&\n    signed_take_bit (numeral k) (- numeral (num.Bit0 w)) =\n    2 * signed_take_bit (pred_numeral k) (- numeral w) &&&\n    signed_take_bit (numeral k) (- numeral (num.Bit1 w)) =\n    1 + 2 * signed_take_bit (pred_numeral k) (- numeral (w + num.One)) &&&\n    signed_take_bit (numeral k) 1 = 1", "by (simp_all add: sbintrunc_numeral)"], ["", "lemma no_bintr_alt1: \"bintrunc n = (\\<lambda>w. w mod 2 ^ n :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n = (\\<lambda>w. w mod 2 ^ n)", "by (rule ext) (rule bintrunc_mod2p)"], ["", "lemma range_bintrunc: \"range (bintrunc n) = {i. 0 \\<le> i \\<and> i < 2 ^ n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (take_bit n) = {i. 0 \\<le> i \\<and> i < 2 ^ n}", "by (auto simp add: take_bit_eq_mod image_iff) (metis mod_pos_pos_trivial)"], ["", "lemma no_sbintr_alt2: \"sbintrunc n = (\\<lambda>w. (w + 2 ^ n) mod 2 ^ Suc n - 2 ^ n :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n = (\\<lambda>w. (w + 2 ^ n) mod 2 ^ Suc n - 2 ^ n)", "by (rule ext) (simp add : sbintrunc_mod2p)"], ["", "lemma range_sbintrunc: \"range (sbintrunc n) = {i. - (2 ^ n) \\<le> i \\<and> i < 2 ^ n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (signed_take_bit n) = {i. - (2 ^ n) \\<le> i \\<and> i < 2 ^ n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. range (signed_take_bit n) = {i. - (2 ^ n) \\<le> i \\<and> i < 2 ^ n}", "have \\<open>surj (\\<lambda>k::int. k + 2 ^ n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. surj (\\<lambda>k. k + 2 ^ n)", "by (rule surjI [of _ \\<open>(\\<lambda>k. k - 2 ^ n)\\<close>]) simp"], ["proof (state)\nthis:\n  surj (\\<lambda>k. k + 2 ^ n)\n\ngoal (1 subgoal):\n 1. range (signed_take_bit n) = {i. - (2 ^ n) \\<le> i \\<and> i < 2 ^ n}", "moreover"], ["proof (state)\nthis:\n  surj (\\<lambda>k. k + 2 ^ n)\n\ngoal (1 subgoal):\n 1. range (signed_take_bit n) = {i. - (2 ^ n) \\<le> i \\<and> i < 2 ^ n}", "have \\<open>sbintrunc n = ((\\<lambda>k. k - 2 ^ n) \\<circ> take_bit (Suc n) \\<circ> (\\<lambda>k. k + 2 ^ n))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n =\n    (\\<lambda>k. k - 2 ^ n) \\<circ> take_bit (Suc n) \\<circ>\n    (\\<lambda>k. k + 2 ^ n)", "by (simp add: sbintrunc_eq_take_bit fun_eq_iff)"], ["proof (state)\nthis:\n  signed_take_bit n =\n  (\\<lambda>k. k - 2 ^ n) \\<circ> take_bit (Suc n) \\<circ>\n  (\\<lambda>k. k + 2 ^ n)\n\ngoal (1 subgoal):\n 1. range (signed_take_bit n) = {i. - (2 ^ n) \\<le> i \\<and> i < 2 ^ n}", "ultimately"], ["proof (chain)\npicking this:\n  surj (\\<lambda>k. k + 2 ^ n)\n  signed_take_bit n =\n  (\\<lambda>k. k - 2 ^ n) \\<circ> take_bit (Suc n) \\<circ>\n  (\\<lambda>k. k + 2 ^ n)", "show ?thesis"], ["proof (prove)\nusing this:\n  surj (\\<lambda>k. k + 2 ^ n)\n  signed_take_bit n =\n  (\\<lambda>k. k - 2 ^ n) \\<circ> take_bit (Suc n) \\<circ>\n  (\\<lambda>k. k + 2 ^ n)\n\ngoal (1 subgoal):\n 1. range (signed_take_bit n) = {i. - (2 ^ n) \\<le> i \\<and> i < 2 ^ n}", "apply (simp only: fun.set_map range_bintrunc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>surj (\\<lambda>k. k + 2 ^ n);\n     signed_take_bit n =\n     (\\<lambda>k. k - 2 ^ n) \\<circ> take_bit (Suc n) \\<circ>\n     (\\<lambda>k. k + 2 ^ n)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>k. k - 2 ^ n) `\n                      {i. 0 \\<le> i \\<and> i < 2 ^ Suc n} =\n                      {i. - (2 ^ n) \\<le> i \\<and> i < 2 ^ n}", "apply (auto simp add: image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>surj (\\<lambda>k. k + 2 ^ n);\n        signed_take_bit n =\n        (\\<lambda>k. k - 2 ^ n) \\<circ> take_bit (Suc n) \\<circ>\n        (\\<lambda>k. k + 2 ^ n);\n        - (2 ^ n) \\<le> x; x < 2 ^ n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<ge>0.\n                            xa < 2 * 2 ^ n \\<and> x = xa - 2 ^ n", "apply presburger"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  range (signed_take_bit n) = {i. - (2 ^ n) \\<le> i \\<and> i < 2 ^ n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sbintrunc_inc:\n  \\<open>k + 2 ^ Suc n \\<le> sbintrunc n k\\<close> if \\<open>k < - (2 ^ n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. k + 2 ^ Suc n \\<le> signed_take_bit n k", "using that"], ["proof (prove)\nusing this:\n  k < - (2 ^ n)\n\ngoal (1 subgoal):\n 1. k + 2 ^ Suc n \\<le> signed_take_bit n k", "by (fact signed_take_bit_int_greater_eq)"], ["", "lemma sbintrunc_dec:\n  \\<open>sbintrunc n k \\<le> k - 2 ^ (Suc n)\\<close> if \\<open>k \\<ge> 2 ^ n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n k \\<le> k - 2 ^ Suc n", "using that"], ["proof (prove)\nusing this:\n  2 ^ n \\<le> k\n\ngoal (1 subgoal):\n 1. signed_take_bit n k \\<le> k - 2 ^ Suc n", "by (fact signed_take_bit_int_less_eq)"], ["", "lemma bintr_ge0: \"0 \\<le> bintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> take_bit n w", "by (simp add: bintrunc_mod2p)"], ["", "lemma bintr_lt2p: \"bintrunc n w < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n w < 2 ^ n", "by (simp add: bintrunc_mod2p)"], ["", "lemma bintr_Min: \"bintrunc n (- 1) = 2 ^ n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n (- 1) = 2 ^ n - 1", "by (simp add: stable_imp_take_bit_eq)"], ["", "lemma sbintr_ge: \"- (2 ^ n) \\<le> sbintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ n) \\<le> signed_take_bit n w", "by (simp add: sbintrunc_mod2p)"], ["", "lemma sbintr_lt: \"sbintrunc n w < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n w < 2 ^ n", "by (simp add: sbintrunc_mod2p)"], ["", "lemma sign_Pls_ge_0: \"bin_sign bin = 0 \\<longleftrightarrow> bin \\<ge> 0\"\n  for bin :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (bin_sign bin = 0) = (0 \\<le> bin)", "by (simp add: bin_sign_def)"], ["", "lemma sign_Min_lt_0: \"bin_sign bin = -1 \\<longleftrightarrow> bin < 0\"\n  for bin :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (bin_sign bin = - 1) = (bin < 0)", "by (simp add: bin_sign_def)"], ["", "lemma bin_rest_trunc: \"bin_rest (bintrunc n bin) = bintrunc (n - 1) (bin_rest bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n bin div 2 = take_bit (n - 1) (bin div 2)", "by (simp add: take_bit_rec [of n bin])"], ["", "lemma bin_rest_power_trunc:\n  \"(bin_rest ^^ k) (bintrunc n bin) = bintrunc (n - k) ((bin_rest ^^ k) bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>w. w div 2) ^^ k) (take_bit n bin) =\n    take_bit (n - k) (((\\<lambda>w. w div 2) ^^ k) bin)", "by (induct k) (auto simp: bin_rest_trunc)"], ["", "lemma bin_rest_trunc_i: \"bintrunc n (bin_rest bin) = bin_rest (bintrunc (Suc n) bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n (bin div 2) = take_bit (Suc n) bin div 2", "by (auto simp add: take_bit_Suc)"], ["", "lemma bin_rest_strunc: \"bin_rest (sbintrunc (Suc n) bin) = sbintrunc n (bin_rest bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit (Suc n) bin div 2 = signed_take_bit n (bin div 2)", "by (simp add: signed_take_bit_Suc)"], ["", "lemma bintrunc_rest [simp]: \"bintrunc n (bin_rest (bintrunc n bin)) = bin_rest (bintrunc n bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n (take_bit n bin div 2) = take_bit n bin div 2", "by (induct n arbitrary: bin) (simp_all add: take_bit_Suc)"], ["", "lemma sbintrunc_rest [simp]: \"sbintrunc n (bin_rest (sbintrunc n bin)) = bin_rest (sbintrunc n bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n (signed_take_bit n bin div 2) =\n    signed_take_bit n bin div 2", "by (induct n arbitrary: bin) (simp_all add: signed_take_bit_Suc mod2_eq_if)"], ["", "lemma bintrunc_rest': \"bintrunc n \\<circ> bin_rest \\<circ> bintrunc n = bin_rest \\<circ> bintrunc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n \\<circ> (\\<lambda>w. w div 2) \\<circ> take_bit n =\n    (\\<lambda>w. w div 2) \\<circ> take_bit n", "by (rule ext) auto"], ["", "lemma sbintrunc_rest': \"sbintrunc n \\<circ> bin_rest \\<circ> sbintrunc n = bin_rest \\<circ> sbintrunc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit n \\<circ> (\\<lambda>w. w div 2) \\<circ>\n    signed_take_bit n =\n    (\\<lambda>w. w div 2) \\<circ> signed_take_bit n", "by (rule ext) auto"], ["", "lemma rco_lem: \"f \\<circ> g \\<circ> f = g \\<circ> f \\<Longrightarrow> f \\<circ> (g \\<circ> f) ^^ n = g ^^ n \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> g \\<circ> f = g \\<circ> f \\<Longrightarrow>\n    f \\<circ> (g \\<circ> f) ^^ n = g ^^ n \\<circ> f", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       f \\<circ> g \\<circ> f = g \\<circ> f \\<Longrightarrow>\n       (f \\<circ> (g \\<circ> f) ^^ n) x = (g ^^ n \\<circ> f) x", "apply (induct_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       f \\<circ> g \\<circ> f = g \\<circ> f \\<Longrightarrow>\n       (f \\<circ> (g \\<circ> f) ^^ 0) x = (g ^^ 0 \\<circ> f) x\n 2. \\<And>x n.\n       \\<lbrakk>f \\<circ> g \\<circ> f = g \\<circ> f;\n        (f \\<circ> (g \\<circ> f) ^^ n) x = (g ^^ n \\<circ> f) x\\<rbrakk>\n       \\<Longrightarrow> (f \\<circ> (g \\<circ> f) ^^ Suc n) x =\n                         (g ^^ Suc n \\<circ> f) x", "apply (simp_all (no_asm))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>f \\<circ> g \\<circ> f = g \\<circ> f;\n        (f \\<circ> (g \\<circ> f) ^^ n) x = (g ^^ n \\<circ> f) x\\<rbrakk>\n       \\<Longrightarrow> f (g (f (((\\<lambda>a. g (f a)) ^^ n) x))) =\n                         g ((g ^^ n) (f x))", "apply (drule fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>(f \\<circ> (g \\<circ> f) ^^ n) x = (g ^^ n \\<circ> f) x;\n        (f \\<circ> g \\<circ> f) (?x3 x n) = (g \\<circ> f) (?x3 x n)\\<rbrakk>\n       \\<Longrightarrow> f (g (f (((\\<lambda>a. g (f a)) ^^ n) x))) =\n                         g ((g ^^ n) (f x))", "apply (unfold o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>f (((\\<lambda>a. g (f a)) ^^ n) x) = (g ^^ n) (f x);\n        f (g (f (?x3 x n))) = g (f (?x3 x n))\\<rbrakk>\n       \\<Longrightarrow> f (g (f (((\\<lambda>a. g (f a)) ^^ n) x))) =\n                         g ((g ^^ n) (f x))", "apply (erule trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       f (((\\<lambda>a. g (f a)) ^^ n) x) = (g ^^ n) (f x) \\<Longrightarrow>\n       g (f (((\\<lambda>a. g (f a)) ^^ n) x)) = g ((g ^^ n) (f x))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas rco_bintr = bintrunc_rest'\n  [THEN rco_lem [THEN fun_cong], unfolded o_def]"], ["", "lemmas rco_sbintr = sbintrunc_rest'\n  [THEN rco_lem [THEN fun_cong], unfolded o_def]"], ["", "subsection \\<open>Splitting and concatenation\\<close>"], ["", "definition bin_split :: \\<open>nat \\<Rightarrow> int \\<Rightarrow> int \\<times> int\\<close>\n  where [simp]: \\<open>bin_split n k = (drop_bit n k, take_bit n k)\\<close>"], ["", "lemma [code]:\n  \"bin_split (Suc n) w = (let (w1, w2) = bin_split n (w div 2) in (w1, of_bool (odd w) + 2 * w2))\"\n  \"bin_split 0 w = (w, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_split (Suc n) w =\n    (let (w1, w2) = bin_split n (w div 2)\n     in (w1, of_bool (odd w) + 2 * w2)) &&&\n    bin_split 0 w = (w, 0)", "by (simp_all add: drop_bit_Suc take_bit_Suc mod_2_eq_odd)"], ["", "abbreviation (input) bin_cat :: \\<open>int \\<Rightarrow> nat \\<Rightarrow> int \\<Rightarrow> int\\<close>\n  where \\<open>bin_cat k n l \\<equiv> concat_bit n l k\\<close>"], ["", "lemma bin_cat_eq_push_bit_add_take_bit:\n  \\<open>bin_cat k n l = push_bit n k + take_bit n l\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat_bit n l k = push_bit n k + take_bit n l", "by (simp add: concat_bit_eq)"], ["", "lemma bin_sign_cat: \"bin_sign (bin_cat x n y) = bin_sign x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sign (concat_bit n y x) = bin_sign x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bin_sign (concat_bit n y x) = bin_sign x", "have \\<open>0 \\<le> x\\<close> if \\<open>0 \\<le> x * 2 ^ n + y mod 2 ^ n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> x", "have \\<open>y mod 2 ^ n < 2 ^ n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. y mod 2 ^ n < 2 ^ n", "using pos_mod_bound [of \\<open>2 ^ n\\<close> y]"], ["proof (prove)\nusing this:\n  0 < 2 ^ n \\<Longrightarrow> y mod 2 ^ n < 2 ^ n\n\ngoal (1 subgoal):\n 1. y mod 2 ^ n < 2 ^ n", "by simp"], ["proof (state)\nthis:\n  y mod 2 ^ n < 2 ^ n\n\ngoal (1 subgoal):\n 1. 0 \\<le> x", "then"], ["proof (chain)\npicking this:\n  y mod 2 ^ n < 2 ^ n", "have \\<open>\\<not> y mod 2 ^ n \\<ge> 2 ^ n\\<close>"], ["proof (prove)\nusing this:\n  y mod 2 ^ n < 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<not> 2 ^ n \\<le> y mod 2 ^ n", "by (simp add: less_le)"], ["proof (state)\nthis:\n  \\<not> 2 ^ n \\<le> y mod 2 ^ n\n\ngoal (1 subgoal):\n 1. 0 \\<le> x", "with that"], ["proof (chain)\npicking this:\n  0 \\<le> x * 2 ^ n + y mod 2 ^ n\n  \\<not> 2 ^ n \\<le> y mod 2 ^ n", "have \\<open>x \\<noteq> - 1\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> x * 2 ^ n + y mod 2 ^ n\n  \\<not> 2 ^ n \\<le> y mod 2 ^ n\n\ngoal (1 subgoal):\n 1. x \\<noteq> - 1", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> x", "have *: \\<open>- 1 \\<le> (- (y mod 2 ^ n)) div 2 ^ n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 \\<le> - (y mod 2 ^ n) div 2 ^ n", "by (simp add: zdiv_zminus1_eq_if)"], ["proof (state)\nthis:\n  - 1 \\<le> - (y mod 2 ^ n) div 2 ^ n\n\ngoal (1 subgoal):\n 1. 0 \\<le> x", "from that"], ["proof (chain)\npicking this:\n  0 \\<le> x * 2 ^ n + y mod 2 ^ n", "have \\<open>- (y mod 2 ^ n) \\<le> x * 2 ^ n\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> x * 2 ^ n + y mod 2 ^ n\n\ngoal (1 subgoal):\n 1. - (y mod 2 ^ n) \\<le> x * 2 ^ n", "by simp"], ["proof (state)\nthis:\n  - (y mod 2 ^ n) \\<le> x * 2 ^ n\n\ngoal (1 subgoal):\n 1. 0 \\<le> x", "then"], ["proof (chain)\npicking this:\n  - (y mod 2 ^ n) \\<le> x * 2 ^ n", "have \\<open>(- (y mod 2 ^ n)) div 2 ^ n \\<le> (x * 2 ^ n) div 2 ^ n\\<close>"], ["proof (prove)\nusing this:\n  - (y mod 2 ^ n) \\<le> x * 2 ^ n\n\ngoal (1 subgoal):\n 1. - (y mod 2 ^ n) div 2 ^ n \\<le> x * 2 ^ n div 2 ^ n", "using zdiv_mono1 zero_less_numeral zero_less_power"], ["proof (prove)\nusing this:\n  - (y mod 2 ^ n) \\<le> x * 2 ^ n\n  \\<lbrakk>?a \\<le> ?a'; 0 < ?b\\<rbrakk>\n  \\<Longrightarrow> ?a div ?b \\<le> ?a' div ?b\n  (0::?'a) < numeral ?n\n  (0::?'a) < ?a \\<Longrightarrow> (0::?'a) < ?a ^ ?n\n\ngoal (1 subgoal):\n 1. - (y mod 2 ^ n) div 2 ^ n \\<le> x * 2 ^ n div 2 ^ n", "by blast"], ["proof (state)\nthis:\n  - (y mod 2 ^ n) div 2 ^ n \\<le> x * 2 ^ n div 2 ^ n\n\ngoal (1 subgoal):\n 1. 0 \\<le> x", "with *"], ["proof (chain)\npicking this:\n  - 1 \\<le> - (y mod 2 ^ n) div 2 ^ n\n  - (y mod 2 ^ n) div 2 ^ n \\<le> x * 2 ^ n div 2 ^ n", "have \\<open>- 1 \\<le> x * 2 ^ n div 2 ^ n\\<close>"], ["proof (prove)\nusing this:\n  - 1 \\<le> - (y mod 2 ^ n) div 2 ^ n\n  - (y mod 2 ^ n) div 2 ^ n \\<le> x * 2 ^ n div 2 ^ n\n\ngoal (1 subgoal):\n 1. - 1 \\<le> x * 2 ^ n div 2 ^ n", "by simp"], ["proof (state)\nthis:\n  - 1 \\<le> x * 2 ^ n div 2 ^ n\n\ngoal (1 subgoal):\n 1. 0 \\<le> x", "with \\<open>x \\<noteq> - 1\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> - 1\n  - 1 \\<le> x * 2 ^ n div 2 ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> - 1\n  - 1 \\<le> x * 2 ^ n div 2 ^ n\n\ngoal (1 subgoal):\n 1. 0 \\<le> x", "by simp"], ["proof (state)\nthis:\n  0 \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> x * 2 ^ n + y mod 2 ^ n \\<Longrightarrow> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. bin_sign (concat_bit n y x) = bin_sign x", "then"], ["proof (chain)\npicking this:\n  0 \\<le> x * 2 ^ n + y mod 2 ^ n \\<Longrightarrow> 0 \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> x * 2 ^ n + y mod 2 ^ n \\<Longrightarrow> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. bin_sign (concat_bit n y x) = bin_sign x", "by (simp add: bin_sign_def not_le not_less bin_cat_eq_push_bit_add_take_bit push_bit_eq_mult take_bit_eq_mod)"], ["proof (state)\nthis:\n  bin_sign (concat_bit n y x) = bin_sign x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_cat_assoc: \"bin_cat (bin_cat x m y) n z = bin_cat x (m + n) (bin_cat y n z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat_bit n z (concat_bit m y x) =\n    concat_bit (m + n) (concat_bit n z y) x", "by (fact concat_bit_assoc)"], ["", "lemma bin_cat_assoc_sym: \"bin_cat x m (bin_cat y n z) = bin_cat (bin_cat x (m - n) y) (min m n) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat_bit m (concat_bit n z y) x =\n    concat_bit (min m n) z (concat_bit (m - n) y x)", "by (fact concat_bit_assoc_sym)"], ["", "definition bin_rcat :: \\<open>nat \\<Rightarrow> int list \\<Rightarrow> int\\<close>\n  where \\<open>bin_rcat n = horner_sum (take_bit n) (2 ^ n) \\<circ> rev\\<close>"], ["", "lemma bin_rcat_eq_foldl:\n  \\<open>bin_rcat n = foldl (\\<lambda>u v. bin_cat u n v) 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rcat n = foldl (\\<lambda>u v. concat_bit n v u) 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. bin_rcat n x = foldl (\\<lambda>u v. concat_bit n v u) 0 x", "fix ks :: \\<open>int list\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. bin_rcat n x = foldl (\\<lambda>u v. concat_bit n v u) 0 x", "show \\<open>bin_rcat n ks = foldl (\\<lambda>u v. bin_cat u n v) 0 ks\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rcat n ks = foldl (\\<lambda>u v. concat_bit n v u) 0 ks", "by (induction ks rule: rev_induct)\n      (simp_all add: bin_rcat_def concat_bit_eq push_bit_eq_mult)"], ["proof (state)\nthis:\n  bin_rcat n ks = foldl (\\<lambda>u v. concat_bit n v u) 0 ks\n\ngoal:\nNo subgoals!", "qed"], ["", "fun bin_rsplit_aux :: \"nat \\<Rightarrow> nat \\<Rightarrow> int \\<Rightarrow> int list \\<Rightarrow> int list\"\n  where \"bin_rsplit_aux n m c bs =\n    (if m = 0 \\<or> n = 0 then bs\n     else\n      let (a, b) = bin_split n c\n      in bin_rsplit_aux n (m - n) a (b # bs))\""], ["", "definition bin_rsplit :: \"nat \\<Rightarrow> nat \\<times> int \\<Rightarrow> int list\"\n  where \"bin_rsplit n w = bin_rsplit_aux n (fst w) (snd w) []\""], ["", "value \\<open>bin_rsplit 1705 (3, 88)\\<close>"], ["", "fun bin_rsplitl_aux :: \"nat \\<Rightarrow> nat \\<Rightarrow> int \\<Rightarrow> int list \\<Rightarrow> int list\"\n  where \"bin_rsplitl_aux n m c bs =\n    (if m = 0 \\<or> n = 0 then bs\n     else\n      let (a, b) = bin_split (min m n) c\n      in bin_rsplitl_aux n (m - n) a (b # bs))\""], ["", "definition bin_rsplitl :: \"nat \\<Rightarrow> nat \\<times> int \\<Rightarrow> int list\"\n  where \"bin_rsplitl n w = bin_rsplitl_aux n (fst w) (snd w) []\""], ["", "declare bin_rsplit_aux.simps [simp del]"], ["", "declare bin_rsplitl_aux.simps [simp del]"], ["", "lemma bin_nth_cat:\n  \"bin_nth (bin_cat x k y) n =\n    (if n < k then bin_nth y n else bin_nth x (n - k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (concat_bit k y x) n = (if n < k then bit y n else bit x (n - k))", "by (simp add: bit_concat_bit_iff)"], ["", "lemma bin_nth_drop_bit_iff:\n  \\<open>bin_nth (drop_bit n c) k \\<longleftrightarrow> bin_nth c (n + k)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (drop_bit n c) k = bit c (n + k)", "by (simp add: bit_drop_bit_eq)"], ["", "lemma bin_nth_take_bit_iff:\n  \\<open>bin_nth (take_bit n c) k \\<longleftrightarrow> k < n \\<and> bin_nth c k\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (take_bit n c) k = (k < n \\<and> bit c k)", "by (fact bit_take_bit_iff)"], ["", "lemma bin_nth_split:\n  \"bin_split n c = (a, b) \\<Longrightarrow>\n    (\\<forall>k. bin_nth a k = bin_nth c (n + k)) \\<and>\n    (\\<forall>k. bin_nth b k = (k < n \\<and> bin_nth c k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_split n c = (a, b) \\<Longrightarrow>\n    (\\<forall>k. bit a k = bit c (n + k)) \\<and>\n    (\\<forall>k. bit b k = (k < n \\<and> bit c k))", "by (auto simp add: bin_nth_drop_bit_iff bin_nth_take_bit_iff)"], ["", "lemma bin_cat_zero [simp]: \"bin_cat 0 n w = bintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat_bit n w 0 = take_bit n w", "by (simp add: bin_cat_eq_push_bit_add_take_bit)"], ["", "lemma bintr_cat1: \"bintrunc (k + n) (bin_cat a n b) = bin_cat (bintrunc k a) n b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit (k + n) (concat_bit n b a) = concat_bit n b (take_bit k a)", "by (metis bin_cat_assoc bin_cat_zero)"], ["", "lemma bintr_cat: \"bintrunc m (bin_cat a n b) =\n    bin_cat (bintrunc (m - n) a) n (bintrunc (min m n) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit m (concat_bit n b a) =\n    concat_bit n (take_bit (min m n) b) (take_bit (m - n) a)", "by (rule bin_eqI) (auto simp: bin_nth_cat nth_bintr)"], ["", "lemma bintr_cat_same [simp]: \"bintrunc n (bin_cat a n b) = bintrunc n b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n (concat_bit n b a) = take_bit n b", "by (auto simp add : bintr_cat)"], ["", "lemma cat_bintr [simp]: \"bin_cat a n (bintrunc n b) = bin_cat a n b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat_bit n (take_bit n b) a = concat_bit n b a", "by (simp add: bin_cat_eq_push_bit_add_take_bit)"], ["", "lemma split_bintrunc: \"bin_split n c = (a, b) \\<Longrightarrow> b = bintrunc n c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_split n c = (a, b) \\<Longrightarrow> b = take_bit n c", "by simp"], ["", "lemma bin_cat_split: \"bin_split n w = (u, v) \\<Longrightarrow> w = bin_cat u n v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_split n w = (u, v) \\<Longrightarrow> w = concat_bit n v u", "by (auto simp add: bin_cat_eq_push_bit_add_take_bit bits_ident)"], ["", "lemma drop_bit_bin_cat_eq:\n  \\<open>drop_bit n (bin_cat v n w) = v\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n (concat_bit n w v) = v", "by (rule bit_eqI) (simp add: bit_drop_bit_eq bit_concat_bit_iff)"], ["", "lemma take_bit_bin_cat_eq:\n  \\<open>take_bit n (bin_cat v n w) = take_bit n w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n (concat_bit n w v) = take_bit n w", "by (rule bit_eqI) (simp add: bit_concat_bit_iff)"], ["", "lemma bin_split_cat: \"bin_split n (bin_cat v n w) = (v, bintrunc n w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_split n (concat_bit n w v) = (v, take_bit n w)", "by (simp add: drop_bit_bin_cat_eq take_bit_bin_cat_eq)"], ["", "lemma bin_split_zero [simp]: \"bin_split n 0 = (0, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_split n 0 = (0, 0)", "by simp"], ["", "lemma bin_split_minus1 [simp]:\n  \"bin_split n (- 1) = (- 1, bintrunc n (- 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_split n (- 1) = (- 1, take_bit n (- 1))", "by simp"], ["", "lemma bin_split_trunc:\n  \"bin_split (min m n) c = (a, b) \\<Longrightarrow>\n    bin_split n (bintrunc m c) = (bintrunc (m - n) a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_split (min m n) c = (a, b) \\<Longrightarrow>\n    bin_split n (take_bit m c) = (take_bit (m - n) a, b)", "apply (induct n arbitrary: m b c, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m b c.\n       \\<lbrakk>\\<And>m b c.\n                   bin_split (min m n) c = (a, b) \\<Longrightarrow>\n                   bin_split n (take_bit m c) = (take_bit (m - n) a, b);\n        bin_split (min m (Suc n)) c = (a, b)\\<rbrakk>\n       \\<Longrightarrow> bin_split (Suc n) (take_bit m c) =\n                         (take_bit (m - Suc n) a, b)", "apply (simp add: bin_rest_trunc Let_def split: prod.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c.\n       \\<lbrakk>\\<And>m c.\n                   drop_bit (min m n) c = a \\<Longrightarrow>\n                   drop_bit n (take_bit m c) = take_bit (m - n) a \\<and>\n                   take_bit (min n m) c = take_bit (min m n) c;\n        drop_bit (min m (Suc n)) c = a\\<rbrakk>\n       \\<Longrightarrow> drop_bit (Suc n) (take_bit m c) =\n                         take_bit (m - Suc n) a \\<and>\n                         take_bit (min (Suc n) m) c =\n                         take_bit (min m (Suc n)) c", "apply (case_tac m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n m c.\n       \\<lbrakk>\\<And>m c.\n                   drop_bit (min m n) c = a \\<Longrightarrow>\n                   drop_bit n (take_bit m c) = take_bit (m - n) a \\<and>\n                   take_bit (min n m) c = take_bit (min m n) c;\n        drop_bit (min m (Suc n)) c = a; m = 0\\<rbrakk>\n       \\<Longrightarrow> drop_bit (Suc n) (take_bit m c) =\n                         take_bit (m - Suc n) a \\<and>\n                         take_bit (min (Suc n) m) c =\n                         take_bit (min m (Suc n)) c\n 2. \\<And>n m c nat.\n       \\<lbrakk>\\<And>m c.\n                   drop_bit (min m n) c = a \\<Longrightarrow>\n                   drop_bit n (take_bit m c) = take_bit (m - n) a \\<and>\n                   take_bit (min n m) c = take_bit (min m n) c;\n        drop_bit (min m (Suc n)) c = a; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop_bit (Suc n) (take_bit m c) =\n                         take_bit (m - Suc n) a \\<and>\n                         take_bit (min (Suc n) m) c =\n                         take_bit (min m (Suc n)) c", "apply (auto simp: Let_def drop_bit_Suc take_bit_Suc mod_2_eq_odd split: prod.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_split_trunc1:\n  \"bin_split n c = (a, b) \\<Longrightarrow>\n    bin_split n (bintrunc m c) = (bintrunc (m - n) a, bintrunc m b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_split n c = (a, b) \\<Longrightarrow>\n    bin_split n (take_bit m c) = (take_bit (m - n) a, take_bit m b)", "apply (induct n arbitrary: m b c, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m b c.\n       \\<lbrakk>\\<And>m b c.\n                   bin_split n c = (a, b) \\<Longrightarrow>\n                   bin_split n (take_bit m c) =\n                   (take_bit (m - n) a, take_bit m b);\n        bin_split (Suc n) c = (a, b)\\<rbrakk>\n       \\<Longrightarrow> bin_split (Suc n) (take_bit m c) =\n                         (take_bit (m - Suc n) a, take_bit m b)", "apply (simp add: bin_rest_trunc Let_def split: prod.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c.\n       \\<lbrakk>\\<And>m c.\n                   drop_bit n c = a \\<Longrightarrow>\n                   drop_bit n (take_bit m c) = take_bit (m - n) a \\<and>\n                   take_bit (min n m) c = take_bit (min m n) c;\n        drop_bit (Suc n) c = a\\<rbrakk>\n       \\<Longrightarrow> drop_bit (Suc n) (take_bit m c) =\n                         take_bit (m - Suc n) a \\<and>\n                         take_bit (min (Suc n) m) c =\n                         take_bit (min m (Suc n)) c", "apply (case_tac m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n m c.\n       \\<lbrakk>\\<And>m c.\n                   drop_bit n c = a \\<Longrightarrow>\n                   drop_bit n (take_bit m c) = take_bit (m - n) a \\<and>\n                   take_bit (min n m) c = take_bit (min m n) c;\n        drop_bit (Suc n) c = a; m = 0\\<rbrakk>\n       \\<Longrightarrow> drop_bit (Suc n) (take_bit m c) =\n                         take_bit (m - Suc n) a \\<and>\n                         take_bit (min (Suc n) m) c =\n                         take_bit (min m (Suc n)) c\n 2. \\<And>n m c nat.\n       \\<lbrakk>\\<And>m c.\n                   drop_bit n c = a \\<Longrightarrow>\n                   drop_bit n (take_bit m c) = take_bit (m - n) a \\<and>\n                   take_bit (min n m) c = take_bit (min m n) c;\n        drop_bit (Suc n) c = a; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop_bit (Suc n) (take_bit m c) =\n                         take_bit (m - Suc n) a \\<and>\n                         take_bit (min (Suc n) m) c =\n                         take_bit (min m (Suc n)) c", "apply (auto simp: Let_def drop_bit_Suc take_bit_Suc mod_2_eq_odd split: prod.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_cat_num: \"bin_cat a n b = a * 2 ^ n + bintrunc n b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat_bit n b a = a * 2 ^ n + take_bit n b", "by (simp add: bin_cat_eq_push_bit_add_take_bit push_bit_eq_mult)"], ["", "lemma bin_split_num: \"bin_split n b = (b div 2 ^ n, b mod 2 ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_split n b = (b div 2 ^ n, b mod 2 ^ n)", "by (simp add: drop_bit_eq_div take_bit_eq_mod)"], ["", "lemmas bin_rsplit_aux_simps = bin_rsplit_aux.simps bin_rsplitl_aux.simps"], ["", "lemmas rsplit_aux_simps = bin_rsplit_aux_simps"], ["", "lemmas th_if_simp1 = if_split [where P = \"(=) l\", THEN iffD1, THEN conjunct1, THEN mp] for l"], ["", "lemmas th_if_simp2 = if_split [where P = \"(=) l\", THEN iffD1, THEN conjunct2, THEN mp] for l"], ["", "lemmas rsplit_aux_simp1s = rsplit_aux_simps [THEN th_if_simp1]"], ["", "lemmas rsplit_aux_simp2ls = rsplit_aux_simps [THEN th_if_simp2]\n\\<comment> \\<open>these safe to \\<open>[simp add]\\<close> as require calculating \\<open>m - n\\<close>\\<close>"], ["", "lemmas bin_rsplit_aux_simp2s [simp] = rsplit_aux_simp2ls [unfolded Let_def]"], ["", "lemmas rbscl = bin_rsplit_aux_simp2s (2)"], ["", "lemmas rsplit_aux_0_simps [simp] =\n  rsplit_aux_simp1s [OF disjI1] rsplit_aux_simp1s [OF disjI2]"], ["", "lemma bin_rsplit_aux_append: \"bin_rsplit_aux n m c (bs @ cs) = bin_rsplit_aux n m c bs @ cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rsplit_aux n m c (bs @ cs) = bin_rsplit_aux n m c bs @ cs", "apply (induct n m c bs rule: bin_rsplit_aux.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs.\n       (\\<And>x xa y.\n           \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); x = bin_split n c;\n            (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> bin_rsplit_aux n (m - n) xa ((y # bs) @ cs) =\n                             bin_rsplit_aux n (m - n) xa (y # bs) @\n                             cs) \\<Longrightarrow>\n       bin_rsplit_aux n m c (bs @ cs) = bin_rsplit_aux n m c bs @ cs", "apply (subst bin_rsplit_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs.\n       (\\<And>x xa y.\n           \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); x = bin_split n c;\n            (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> bin_rsplit_aux n (m - n) xa ((y # bs) @ cs) =\n                             bin_rsplit_aux n (m - n) xa (y # bs) @\n                             cs) \\<Longrightarrow>\n       (if m = 0 \\<or> n = 0 then bs @ cs\n        else let (a, b) = bin_split n c\n             in bin_rsplit_aux n (m - n) a (b # bs @ cs)) =\n       bin_rsplit_aux n m c bs @ cs", "apply (subst bin_rsplit_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs.\n       (\\<And>x xa y.\n           \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); x = bin_split n c;\n            (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> bin_rsplit_aux n (m - n) xa ((y # bs) @ cs) =\n                             bin_rsplit_aux n (m - n) xa (y # bs) @\n                             cs) \\<Longrightarrow>\n       (if m = 0 \\<or> n = 0 then bs @ cs\n        else let (a, b) = bin_split n c\n             in if m - n = 0 \\<or> n = 0 then b # bs @ cs\n                else let (a, ba) = bin_split n a\n                     in bin_rsplit_aux n (m - n - n) a (ba # b # bs @ cs)) =\n       bin_rsplit_aux n m c bs @ cs", "apply (clarsimp split: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_rsplitl_aux_append: \"bin_rsplitl_aux n m c (bs @ cs) = bin_rsplitl_aux n m c bs @ cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rsplitl_aux n m c (bs @ cs) = bin_rsplitl_aux n m c bs @ cs", "apply (induct n m c bs rule: bin_rsplitl_aux.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs.\n       (\\<And>x xa y.\n           \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); x = bin_split (min m n) c;\n            (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> bin_rsplitl_aux n (m - n) xa ((y # bs) @ cs) =\n                             bin_rsplitl_aux n (m - n) xa (y # bs) @\n                             cs) \\<Longrightarrow>\n       bin_rsplitl_aux n m c (bs @ cs) = bin_rsplitl_aux n m c bs @ cs", "apply (subst bin_rsplitl_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs.\n       (\\<And>x xa y.\n           \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); x = bin_split (min m n) c;\n            (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> bin_rsplitl_aux n (m - n) xa ((y # bs) @ cs) =\n                             bin_rsplitl_aux n (m - n) xa (y # bs) @\n                             cs) \\<Longrightarrow>\n       (if m = 0 \\<or> n = 0 then bs @ cs\n        else let (a, b) = bin_split (min m n) c\n             in bin_rsplitl_aux n (m - n) a (b # bs @ cs)) =\n       bin_rsplitl_aux n m c bs @ cs", "apply (subst bin_rsplitl_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs.\n       (\\<And>x xa y.\n           \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); x = bin_split (min m n) c;\n            (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> bin_rsplitl_aux n (m - n) xa ((y # bs) @ cs) =\n                             bin_rsplitl_aux n (m - n) xa (y # bs) @\n                             cs) \\<Longrightarrow>\n       (if m = 0 \\<or> n = 0 then bs @ cs\n        else let (a, b) = bin_split (min m n) c\n             in if m - n = 0 \\<or> n = 0 then b # bs @ cs\n                else let (a, ba) = bin_split (min (m - n) n) a\n                     in bin_rsplitl_aux n (m - n - n) a\n                         (ba # b # bs @ cs)) =\n       bin_rsplitl_aux n m c bs @ cs", "apply (clarsimp split: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas rsplit_aux_apps [where bs = \"[]\"] =\n  bin_rsplit_aux_append bin_rsplitl_aux_append"], ["", "lemmas rsplit_def_auxs = bin_rsplit_def bin_rsplitl_def"], ["", "lemmas rsplit_aux_alts = rsplit_aux_apps\n  [unfolded append_Nil rsplit_def_auxs [symmetric]]"], ["", "lemma bin_split_minus: \"0 < n \\<Longrightarrow> bin_split (Suc (n - 1)) w = bin_split n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> bin_split (Suc (n - 1)) w = bin_split n w", "by auto"], ["", "lemma bin_split_pred_simp [simp]:\n  \"(0::nat) < numeral bin \\<Longrightarrow>\n    bin_split (numeral bin) w =\n      (let (w1, w2) = bin_split (numeral bin - 1) (bin_rest w)\n       in (w1, of_bool (odd w) + 2 * w2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < numeral bin \\<Longrightarrow>\n    bin_split (numeral bin) w =\n    (let (w1, w2) = bin_split (numeral bin - 1) (w div 2)\n     in (w1, of_bool (odd w) + 2 * w2))", "by (simp add: take_bit_rec drop_bit_rec mod_2_eq_odd)"], ["", "lemma bin_rsplit_aux_simp_alt:\n  \"bin_rsplit_aux n m c bs =\n    (if m = 0 \\<or> n = 0 then bs\n     else let (a, b) = bin_split n c in bin_rsplit n (m - n, a) @ b # bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rsplit_aux n m c bs =\n    (if m = 0 \\<or> n = 0 then bs\n     else let (a, b) = bin_split n c in bin_rsplit n (m - n, a) @ b # bs)", "apply (simp add: bin_rsplit_aux.simps [of n m c bs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<and> 0 < n \\<longrightarrow>\n    bin_rsplit_aux n (m - n) (drop_bit n c) (take_bit n c # bs) =\n    bin_rsplit n (m - n, drop_bit n c) @ take_bit n c # bs", "apply (subst rsplit_aux_alts)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<and> 0 < n \\<longrightarrow>\n    bin_rsplit_aux n (m - n) (drop_bit n c) [] @ take_bit n c # bs =\n    bin_rsplit n (m - n, drop_bit n c) @ take_bit n c # bs", "apply (simp add: bin_rsplit_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas bin_rsplit_simp_alt =\n  trans [OF bin_rsplit_def bin_rsplit_aux_simp_alt]"], ["", "lemmas bthrs = bin_rsplit_simp_alt [THEN [2] trans]"], ["", "lemma bin_rsplit_size_sign' [rule_format]:\n  \"n > 0 \\<Longrightarrow> rev sw = bin_rsplit n (nw, w) \\<Longrightarrow> \\<forall>v\\<in>set sw. bintrunc n v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; rev sw = bin_rsplit n (nw, w)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>set sw. take_bit n v = v", "apply (induct sw arbitrary: nw w)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nw w.\n       \\<lbrakk>0 < n; rev [] = bin_rsplit n (nw, w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set []. take_bit n v = v\n 2. \\<And>a sw nw w.\n       \\<lbrakk>\\<And>nw w.\n                   \\<lbrakk>0 < n; rev sw = bin_rsplit n (nw, w)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\\<in>set sw.\n  take_bit n v = v;\n        0 < n; rev (a # sw) = bin_rsplit n (nw, w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set (a # sw). take_bit n v = v", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a sw nw w.\n       \\<lbrakk>\\<And>nw w.\n                   \\<lbrakk>0 < n; rev sw = bin_rsplit n (nw, w)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>v\\<in>set sw.\n  take_bit n v = v;\n        0 < n; rev (a # sw) = bin_rsplit n (nw, w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set (a # sw). take_bit n v = v", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a sw nw w.\n       \\<lbrakk>\\<And>nw w.\n                   rev sw = bin_rsplit n (nw, w) \\<Longrightarrow>\n                   \\<forall>v\\<in>set sw. take_bit n v = v;\n        0 < n; rev sw @ [a] = bin_rsplit n (nw, w)\\<rbrakk>\n       \\<Longrightarrow> take_bit n a = a \\<and>\n                         (\\<forall>v\\<in>set sw. take_bit n v = v)", "apply (drule bthrs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a sw nw w.\n       \\<lbrakk>\\<And>nw w.\n                   rev sw = bin_rsplit n (nw, w) \\<Longrightarrow>\n                   \\<forall>v\\<in>set sw. take_bit n v = v;\n        0 < n;\n        rev sw @ [a] =\n        (if fst (nw, w) = 0 \\<or> n = 0 then []\n         else let (a, b) = bin_split n (snd (nw, w))\n              in bin_rsplit n (fst (nw, w) - n, a) @ [b])\\<rbrakk>\n       \\<Longrightarrow> take_bit n a = a \\<and>\n                         (\\<forall>v\\<in>set sw. take_bit n v = v)", "apply (simp (no_asm_use) add: Let_def split: prod.split_asm if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sw nw w.\n       \\<lbrakk>\\<And>nw w.\n                   rev sw = bin_rsplit n (nw, w) \\<Longrightarrow>\n                   \\<forall>v\\<in>set sw. take_bit n v = v;\n        0 < n; 0 < nw \\<and> 0 < n;\n        rev sw = bin_rsplit n (nw - n, drop_bit n w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set sw. take_bit n v = v", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sw nw w v.\n       \\<lbrakk>\\<And>nw w.\n                   rev sw = bin_rsplit n (nw, w) \\<Longrightarrow>\n                   \\<forall>v\\<in>set sw. take_bit n v = v;\n        0 < n; rev sw = bin_rsplit n (nw - n, drop_bit n w); v \\<in> set sw;\n        0 < nw; 0 < n\\<rbrakk>\n       \\<Longrightarrow> take_bit n v = v", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas bin_rsplit_size_sign = bin_rsplit_size_sign' [OF asm_rl\n  rev_rev_ident [THEN trans] set_rev [THEN equalityD2 [THEN subsetD]]]"], ["", "lemma bin_nth_rsplit [rule_format] :\n  \"n > 0 \\<Longrightarrow> m < n \\<Longrightarrow>\n    \\<forall>w k nw.\n      rev sw = bin_rsplit n (nw, w) \\<longrightarrow>\n      k < size sw \\<longrightarrow> bin_nth (sw ! k) m = bin_nth w (k * n + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; m < n\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w k nw.\n                         rev sw = bin_rsplit n (nw, w) \\<longrightarrow>\n                         k < length sw \\<longrightarrow>\n                         bit (sw ! k) m = bit w (k * n + m)", "apply (induct sw)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; m < n\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w k nw.\n                         rev [] = bin_rsplit n (nw, w) \\<longrightarrow>\n                         k < length [] \\<longrightarrow>\n                         bit ([] ! k) m = bit w (k * n + m)\n 2. \\<And>a sw.\n       \\<lbrakk>\\<lbrakk>0 < n; m < n\\<rbrakk>\n                \\<Longrightarrow> \\<forall>w k nw.\n                                     rev sw =\n                                     bin_rsplit n (nw, w) \\<longrightarrow>\n                                     k < length sw \\<longrightarrow>\n                                     bit (sw ! k) m = bit w (k * n + m);\n        0 < n; m < n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w k nw.\n                            rev (a # sw) =\n                            bin_rsplit n (nw, w) \\<longrightarrow>\n                            k < length (a # sw) \\<longrightarrow>\n                            bit ((a # sw) ! k) m = bit w (k * n + m)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a sw.\n       \\<lbrakk>\\<lbrakk>0 < n; m < n\\<rbrakk>\n                \\<Longrightarrow> \\<forall>w k nw.\n                                     rev sw =\n                                     bin_rsplit n (nw, w) \\<longrightarrow>\n                                     k < length sw \\<longrightarrow>\n                                     bit (sw ! k) m = bit w (k * n + m);\n        0 < n; m < n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w k nw.\n                            rev (a # sw) =\n                            bin_rsplit n (nw, w) \\<longrightarrow>\n                            k < length (a # sw) \\<longrightarrow>\n                            bit ((a # sw) ! k) m = bit w (k * n + m)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a sw w nw k.\n       \\<lbrakk>\\<forall>w.\n                   (\\<exists>nw.\n                       rev sw = bin_rsplit n (nw, w)) \\<longrightarrow>\n                   (\\<forall>k<length sw.\n                       bit (sw ! k) m = bit w (k * n + m));\n        m < n; rev sw @ [a] = bin_rsplit n (nw, w);\n        k < Suc (length sw)\\<rbrakk>\n       \\<Longrightarrow> bit ((a # sw) ! k) m = bit w (k * n + m)", "apply (drule bthrs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a sw w nw k.\n       \\<lbrakk>\\<forall>w.\n                   (\\<exists>nw.\n                       rev sw = bin_rsplit n (nw, w)) \\<longrightarrow>\n                   (\\<forall>k<length sw.\n                       bit (sw ! k) m = bit w (k * n + m));\n        m < n; k < Suc (length sw);\n        rev sw @ [a] =\n        (if fst (nw, w) = 0 \\<or> n = 0 then []\n         else let (a, b) = bin_split n (snd (nw, w))\n              in bin_rsplit n (fst (nw, w) - n, a) @ [b])\\<rbrakk>\n       \\<Longrightarrow> bit ((a # sw) ! k) m = bit w (k * n + m)", "apply (simp (no_asm_use) add: Let_def split: prod.split_asm if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sw w nw k.\n       \\<lbrakk>\\<forall>w.\n                   (\\<exists>nw.\n                       rev sw = bin_rsplit n (nw, w)) \\<longrightarrow>\n                   (\\<forall>k<length sw.\n                       bit (sw ! k) m = bit w (k * n + m));\n        m < n; k < Suc (length sw); 0 < nw \\<and> 0 < n;\n        rev sw = bin_rsplit n (nw - n, drop_bit n w)\\<rbrakk>\n       \\<Longrightarrow> bit ((take_bit n w # sw) ! k) m = bit w (k * n + m)", "apply (erule allE, erule impE, erule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sw w nw k.\n       \\<lbrakk>m < n; k < Suc (length sw); 0 < nw \\<and> 0 < n;\n        rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        \\<forall>k<length sw.\n           bit (sw ! k) m = bit (drop_bit n w) (k * n + m)\\<rbrakk>\n       \\<Longrightarrow> bit ((take_bit n w # sw) ! k) m = bit w (k * n + m)", "apply (case_tac k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sw w nw k.\n       \\<lbrakk>m < n; k < Suc (length sw); 0 < nw \\<and> 0 < n;\n        rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        \\<forall>k<length sw.\n           bit (sw ! k) m = bit (drop_bit n w) (k * n + m);\n        k = 0\\<rbrakk>\n       \\<Longrightarrow> bit ((take_bit n w # sw) ! k) m = bit w (k * n + m)\n 2. \\<And>sw w nw k nat.\n       \\<lbrakk>m < n; k < Suc (length sw); 0 < nw \\<and> 0 < n;\n        rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        \\<forall>k<length sw.\n           bit (sw ! k) m = bit (drop_bit n w) (k * n + m);\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> bit ((take_bit n w # sw) ! k) m = bit w (k * n + m)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sw w nw.\n       \\<lbrakk>m < n; 0 < nw; rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        \\<forall>k<length sw.\n           bit (sw ! k) m = bit (drop_bit n w) (k * n + m)\\<rbrakk>\n       \\<Longrightarrow> bit (take_bit n w) m = bit w m\n 2. \\<And>sw w nw k nat.\n       \\<lbrakk>m < n; k < Suc (length sw); 0 < nw \\<and> 0 < n;\n        rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        \\<forall>k<length sw.\n           bit (sw ! k) m = bit (drop_bit n w) (k * n + m);\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> bit ((take_bit n w # sw) ! k) m = bit w (k * n + m)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sw w nw k nat.\n       \\<lbrakk>m < n; k < Suc (length sw); 0 < nw \\<and> 0 < n;\n        rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        \\<forall>k<length sw.\n           bit (sw ! k) m = bit (drop_bit n w) (k * n + m);\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> bit ((take_bit n w # sw) ! k) m = bit w (k * n + m)\n 2. \\<And>sw w nw.\n       \\<lbrakk>m < n; 0 < nw; rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        \\<forall>k<length sw.\n           bit (sw ! k) m = bit (drop_bit n w) (k * n + m)\\<rbrakk>\n       \\<Longrightarrow> bit (take_bit n w) m = bit w m", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sw w nw nat.\n       \\<lbrakk>m < n; nat < length sw; 0 < nw;\n        rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        \\<forall>k<length sw.\n           bit (sw ! k) m = bit (drop_bit n w) (k * n + m)\\<rbrakk>\n       \\<Longrightarrow> bit (drop_bit n w) (nat * n + m) =\n                         bit w (n + nat * n + m)\n 2. \\<And>sw w nw.\n       \\<lbrakk>m < n; 0 < nw; rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        \\<forall>k<length sw.\n           bit (sw ! k) m = bit (drop_bit n w) (k * n + m)\\<rbrakk>\n       \\<Longrightarrow> bit (take_bit n w) m = bit w m", "apply (erule allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sw w nw nat.\n       \\<lbrakk>m < n; nat < length sw; 0 < nw;\n        rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        ?k40 sw w nw nat < length sw \\<longrightarrow>\n        bit (sw ! ?k40 sw w nw nat) m =\n        bit (drop_bit n w) (?k40 sw w nw nat * n + m)\\<rbrakk>\n       \\<Longrightarrow> bit (drop_bit n w) (nat * n + m) =\n                         bit w (n + nat * n + m)\n 2. \\<And>sw w nw.\n       \\<lbrakk>m < n; 0 < nw; rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        \\<forall>k<length sw.\n           bit (sw ! k) m = bit (drop_bit n w) (k * n + m)\\<rbrakk>\n       \\<Longrightarrow> bit (take_bit n w) m = bit w m", "apply (erule (1) impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sw w nw nat.\n       \\<lbrakk>m < n; nat < length sw; 0 < nw;\n        rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        bit (sw ! nat) m = bit (drop_bit n w) (nat * n + m)\\<rbrakk>\n       \\<Longrightarrow> bit (drop_bit n w) (nat * n + m) =\n                         bit w (n + nat * n + m)\n 2. \\<And>sw w nw.\n       \\<lbrakk>m < n; 0 < nw; rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        \\<forall>k<length sw.\n           bit (sw ! k) m = bit (drop_bit n w) (k * n + m)\\<rbrakk>\n       \\<Longrightarrow> bit (take_bit n w) m = bit w m", "apply (simp add: bit_drop_bit_eq ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sw w nw.\n       \\<lbrakk>m < n; 0 < nw; rev sw = bin_rsplit n (nw - n, drop_bit n w);\n        \\<forall>k<length sw.\n           bit (sw ! k) m = bit (drop_bit n w) (k * n + m)\\<rbrakk>\n       \\<Longrightarrow> bit (take_bit n w) m = bit w m", "apply (simp add: bit_take_bit_iff ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_rsplit_all: \"0 < nw \\<Longrightarrow> nw \\<le> n \\<Longrightarrow> bin_rsplit n (nw, w) = [bintrunc n w]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < nw; nw \\<le> n\\<rbrakk>\n    \\<Longrightarrow> bin_rsplit n (nw, w) = [take_bit n w]", "by (auto simp: bin_rsplit_def rsplit_aux_simp2ls split: prod.split dest!: split_bintrunc)"], ["", "lemma bin_rsplit_l [rule_format]:\n  \"\\<forall>bin. bin_rsplitl n (m, bin) = bin_rsplit n (m, bintrunc m bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>bin. bin_rsplitl n (m, bin) = bin_rsplit n (m, take_bit m bin)", "apply (rule_tac a = \"m\" in wf_less_than [THEN wf_induct])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> less_than \\<longrightarrow>\n          (\\<forall>bin.\n              bin_rsplitl n (y, bin) =\n              bin_rsplit n (y, take_bit y bin)) \\<Longrightarrow>\n       \\<forall>bin.\n          bin_rsplitl n (x, bin) = bin_rsplit n (x, take_bit x bin)", "apply (simp (no_asm) add: bin_rsplitl_def bin_rsplit_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> less_than \\<longrightarrow>\n          (\\<forall>bin.\n              bin_rsplitl n (y, bin) =\n              bin_rsplit n (y, take_bit y bin)) \\<Longrightarrow>\n       \\<forall>bin.\n          bin_rsplitl_aux n x bin [] =\n          bin_rsplit_aux n x (take_bit x bin) []", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x bin.\n       \\<forall>y.\n          (y, x) \\<in> less_than \\<longrightarrow>\n          (\\<forall>bin.\n              bin_rsplitl n (y, bin) =\n              bin_rsplit n (y, take_bit y bin)) \\<Longrightarrow>\n       bin_rsplitl_aux n x bin [] = bin_rsplit_aux n x (take_bit x bin) []", "apply (subst bin_rsplitl_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x bin.\n       \\<forall>y.\n          (y, x) \\<in> less_than \\<longrightarrow>\n          (\\<forall>bin.\n              bin_rsplitl n (y, bin) =\n              bin_rsplit n (y, take_bit y bin)) \\<Longrightarrow>\n       (if x = 0 \\<or> n = 0 then []\n        else let (a, b) = bin_split (min x n) bin\n             in bin_rsplitl_aux n (x - n) a [b]) =\n       bin_rsplit_aux n x (take_bit x bin) []", "apply (subst bin_rsplit_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x bin.\n       \\<forall>y.\n          (y, x) \\<in> less_than \\<longrightarrow>\n          (\\<forall>bin.\n              bin_rsplitl n (y, bin) =\n              bin_rsplit n (y, take_bit y bin)) \\<Longrightarrow>\n       (if x = 0 \\<or> n = 0 then []\n        else let (a, b) = bin_split (min x n) bin\n             in bin_rsplitl_aux n (x - n) a [b]) =\n       (if x = 0 \\<or> n = 0 then []\n        else let (a, b) = bin_split n (take_bit x bin)\n             in bin_rsplit_aux n (x - n) a [b])", "apply (clarsimp simp: Let_def split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x bin.\n       \\<lbrakk>\\<forall>y<x.\n                   \\<forall>bin.\n                      bin_rsplitl n (y, bin) =\n                      bin_rsplit n (y, take_bit y bin);\n        0 < x; 0 < n\\<rbrakk>\n       \\<Longrightarrow> bin_rsplitl_aux n (x - n) (drop_bit (min x n) bin)\n                          [take_bit (min x n) bin] =\n                         bin_rsplit_aux n (x - n)\n                          (drop_bit n (take_bit x bin))\n                          [take_bit (min n x) bin]", "apply (simp add: ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x bin.\n       \\<lbrakk>\\<forall>y<x.\n                   \\<forall>bin.\n                      bin_rsplitl n (y, bin) =\n                      bin_rsplit n (y, take_bit y bin);\n        0 < x; 0 < n\\<rbrakk>\n       \\<Longrightarrow> bin_rsplitl_aux n (x - n) (drop_bit (min x n) bin)\n                          [take_bit (min x n) bin] =\n                         bin_rsplit_aux n (x - n)\n                          (drop_bit n (take_bit x bin))\n                          [take_bit (min x n) bin]", "apply (subst rsplit_aux_alts(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x bin.\n       \\<lbrakk>\\<forall>y<x.\n                   \\<forall>bin.\n                      bin_rsplitl n (y, bin) =\n                      bin_rsplit n (y, take_bit y bin);\n        0 < x; 0 < n\\<rbrakk>\n       \\<Longrightarrow> bin_rsplitl_aux n (x - n) (drop_bit (min x n) bin)\n                          [take_bit (min x n) bin] =\n                         bin_rsplit_aux n (x - n)\n                          (drop_bit n (take_bit x bin)) [] @\n                         [take_bit (min x n) bin]", "apply (subst rsplit_aux_alts(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x bin.\n       \\<lbrakk>\\<forall>y<x.\n                   \\<forall>bin.\n                      bin_rsplitl n (y, bin) =\n                      bin_rsplit n (y, take_bit y bin);\n        0 < x; 0 < n\\<rbrakk>\n       \\<Longrightarrow> bin_rsplitl_aux n (x - n) (drop_bit (min x n) bin)\n                          [] @\n                         [take_bit (min x n) bin] =\n                         bin_rsplit_aux n (x - n)\n                          (drop_bit n (take_bit x bin)) [] @\n                         [take_bit (min x n) bin]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x bin.\n       \\<lbrakk>\\<forall>y<x.\n                   \\<forall>bin.\n                      bin_rsplitl n (y, bin) =\n                      bin_rsplit n (y, take_bit y bin);\n        0 < x; 0 < n\\<rbrakk>\n       \\<Longrightarrow> bin_rsplitl_aux n (x - n) (drop_bit (min x n) bin)\n                          [] =\n                         bin_rsplit_aux n (x - n)\n                          (drop_bit n (take_bit x bin)) []", "unfolding bin_rsplit_def bin_rsplitl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x bin.\n       \\<lbrakk>\\<forall>y<x.\n                   \\<forall>bin.\n                      bin_rsplitl_aux n (fst (y, bin)) (snd (y, bin)) [] =\n                      bin_rsplit_aux n (fst (y, take_bit y bin))\n                       (snd (y, take_bit y bin)) [];\n        0 < x; 0 < n\\<rbrakk>\n       \\<Longrightarrow> bin_rsplitl_aux n (x - n) (drop_bit (min x n) bin)\n                          [] =\n                         bin_rsplit_aux n (x - n)\n                          (drop_bit n (take_bit x bin)) []", "apply (simp add: drop_bit_take_bit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x bin.\n       \\<lbrakk>\\<forall>y<x.\n                   \\<forall>bin.\n                      bin_rsplitl_aux n y bin [] =\n                      bin_rsplit_aux n y (take_bit y bin) [];\n        0 < x; 0 < n\\<rbrakk>\n       \\<Longrightarrow> bin_rsplit_aux n (x - n)\n                          (take_bit (x - n) (drop_bit (min x n) bin)) [] =\n                         bin_rsplit_aux n (x - n)\n                          (take_bit (x - n) (drop_bit n bin)) []", "apply (case_tac \\<open>x < n\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x bin.\n       \\<lbrakk>\\<forall>y<x.\n                   \\<forall>bin.\n                      bin_rsplitl_aux n y bin [] =\n                      bin_rsplit_aux n y (take_bit y bin) [];\n        0 < x; 0 < n; x < n\\<rbrakk>\n       \\<Longrightarrow> bin_rsplit_aux n (x - n)\n                          (take_bit (x - n) (drop_bit (min x n) bin)) [] =\n                         bin_rsplit_aux n (x - n)\n                          (take_bit (x - n) (drop_bit n bin)) []\n 2. \\<And>x bin.\n       \\<lbrakk>\\<forall>y<x.\n                   \\<forall>bin.\n                      bin_rsplitl_aux n y bin [] =\n                      bin_rsplit_aux n y (take_bit y bin) [];\n        0 < x; 0 < n; \\<not> x < n\\<rbrakk>\n       \\<Longrightarrow> bin_rsplit_aux n (x - n)\n                          (take_bit (x - n) (drop_bit (min x n) bin)) [] =\n                         bin_rsplit_aux n (x - n)\n                          (take_bit (x - n) (drop_bit n bin)) []", "apply (simp_all add: not_less min_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_rsplit_rcat [rule_format]:\n  \"n > 0 \\<longrightarrow> bin_rsplit n (n * size ws, bin_rcat n ws) = map (bintrunc n) ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow>\n    bin_rsplit n (n * length ws, bin_rcat n ws) = map (take_bit n) ws", "apply (unfold bin_rsplit_def bin_rcat_eq_foldl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow>\n    bin_rsplit_aux n\n     (fst (n * length ws, foldl (\\<lambda>u v. concat_bit n v u) 0 ws))\n     (snd (n * length ws, foldl (\\<lambda>u v. concat_bit n v u) 0 ws)) [] =\n    map (take_bit n) ws", "apply (rule_tac xs = ws in rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < n \\<longrightarrow>\n    bin_rsplit_aux n\n     (fst (n * length [], foldl (\\<lambda>u v. concat_bit n v u) 0 []))\n     (snd (n * length [], foldl (\\<lambda>u v. concat_bit n v u) 0 [])) [] =\n    map (take_bit n) []\n 2. \\<And>x xs.\n       0 < n \\<longrightarrow>\n       bin_rsplit_aux n\n        (fst (n * length xs, foldl (\\<lambda>u v. concat_bit n v u) 0 xs))\n        (snd (n * length xs, foldl (\\<lambda>u v. concat_bit n v u) 0 xs))\n        [] =\n       map (take_bit n) xs \\<Longrightarrow>\n       0 < n \\<longrightarrow>\n       bin_rsplit_aux n\n        (fst (n * length (xs @ [x]),\n              foldl (\\<lambda>u v. concat_bit n v u) 0 (xs @ [x])))\n        (snd (n * length (xs @ [x]),\n              foldl (\\<lambda>u v. concat_bit n v u) 0 (xs @ [x])))\n        [] =\n       map (take_bit n) (xs @ [x])", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       0 < n \\<longrightarrow>\n       bin_rsplit_aux n\n        (fst (n * length xs, foldl (\\<lambda>u v. concat_bit n v u) 0 xs))\n        (snd (n * length xs, foldl (\\<lambda>u v. concat_bit n v u) 0 xs))\n        [] =\n       map (take_bit n) xs \\<Longrightarrow>\n       0 < n \\<longrightarrow>\n       bin_rsplit_aux n\n        (fst (n * length (xs @ [x]),\n              foldl (\\<lambda>u v. concat_bit n v u) 0 (xs @ [x])))\n        (snd (n * length (xs @ [x]),\n              foldl (\\<lambda>u v. concat_bit n v u) 0 (xs @ [x])))\n        [] =\n       map (take_bit n) (xs @ [x])", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>0 < n;\n        bin_rsplit_aux n (n * length xs)\n         (foldl (\\<lambda>u v. concat_bit n v u) 0 xs) [] =\n        map (take_bit n) xs\\<rbrakk>\n       \\<Longrightarrow> bin_rsplit_aux n (n * length xs)\n                          (drop_bit n\n                            (concat_bit n x\n                              (foldl (\\<lambda>u v. concat_bit n v u) 0\n                                xs)))\n                          [take_bit n x] =\n                         map (take_bit n) xs @ [take_bit n x]", "apply (subst rsplit_aux_alts)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>0 < n;\n        bin_rsplit_aux n (n * length xs)\n         (foldl (\\<lambda>u v. concat_bit n v u) 0 xs) [] =\n        map (take_bit n) xs\\<rbrakk>\n       \\<Longrightarrow> bin_rsplit_aux n (n * length xs)\n                          (drop_bit n\n                            (concat_bit n x\n                              (foldl (\\<lambda>u v. concat_bit n v u) 0\n                                xs)))\n                          [] @\n                         [take_bit n x] =\n                         map (take_bit n) xs @ [take_bit n x]", "apply (simp add: drop_bit_bin_cat_eq take_bit_bin_cat_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_rsplit_aux_len_le [rule_format] :\n  \"\\<forall>ws m. n \\<noteq> 0 \\<longrightarrow> ws = bin_rsplit_aux n nw w bs \\<longrightarrow>\n    length ws \\<le> m \\<longleftrightarrow> nw + length bs * n \\<le> m * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ws m.\n       n \\<noteq> 0 \\<longrightarrow>\n       ws = bin_rsplit_aux n nw w bs \\<longrightarrow>\n       (length ws \\<le> m) = (nw + length bs * n \\<le> m * n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>ws m.\n       n \\<noteq> 0 \\<longrightarrow>\n       ws = bin_rsplit_aux n nw w bs \\<longrightarrow>\n       (length ws \\<le> m) = (nw + length bs * n \\<le> m * n)", "have *: R\n    if d: \"i \\<le> j \\<or> m < j'\"\n    and R1: \"i * k \\<le> j * k \\<Longrightarrow> R\"\n    and R2: \"Suc m * k' \\<le> j' * k' \\<Longrightarrow> R\"\n    for i j j' k k' m :: nat and R"], ["proof (prove)\ngoal (1 subgoal):\n 1. R", "using d"], ["proof (prove)\nusing this:\n  i \\<le> j \\<or> m < j'\n\ngoal (1 subgoal):\n 1. R", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. i \\<le> j \\<Longrightarrow> R\n 2. m < j' \\<Longrightarrow> R", "apply (rule R1, erule mult_le_mono1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m < j' \\<Longrightarrow> R", "apply (rule R2, erule Suc_le_eq [THEN iffD2 [THEN mult_le_mono1]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> ?j \\<or> ?m < ?j';\n   ?i * ?k \\<le> ?j * ?k \\<Longrightarrow> ?R;\n   Suc ?m * ?k' \\<le> ?j' * ?k' \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. \\<forall>ws m.\n       n \\<noteq> 0 \\<longrightarrow>\n       ws = bin_rsplit_aux n nw w bs \\<longrightarrow>\n       (length ws \\<le> m) = (nw + length bs * n \\<le> m * n)", "have **: \"0 < sc \\<Longrightarrow> sc - n + (n + lb * n) \\<le> m * n \\<longleftrightarrow> sc + lb * n \\<le> m * n\"\n    for sc m n lb :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sc \\<Longrightarrow>\n    (sc - n + (n + lb * n) \\<le> m * n) = (sc + lb * n \\<le> m * n)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < sc; sc - n + (n + lb * n) \\<le> m * n\\<rbrakk>\n    \\<Longrightarrow> sc + lb * n \\<le> m * n\n 2. \\<lbrakk>0 < sc; sc + lb * n \\<le> m * n\\<rbrakk>\n    \\<Longrightarrow> sc - n + (n + lb * n) \\<le> m * n", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < sc; sc + lb * n \\<le> m * n\\<rbrakk>\n    \\<Longrightarrow> sc - n + (n + lb * n) \\<le> m * n", "apply (case_tac \"sc \\<ge> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < sc; sc + lb * n \\<le> m * n; n \\<le> sc\\<rbrakk>\n    \\<Longrightarrow> sc - n + (n + lb * n) \\<le> m * n\n 2. \\<lbrakk>0 < sc; sc + lb * n \\<le> m * n; \\<not> n \\<le> sc\\<rbrakk>\n    \\<Longrightarrow> sc - n + (n + lb * n) \\<le> m * n", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < sc; sc + lb * n \\<le> m * n; \\<not> n \\<le> sc\\<rbrakk>\n    \\<Longrightarrow> sc - n + (n + lb * n) \\<le> m * n", "apply (insert linorder_le_less_linear [of m lb])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < sc; sc + lb * n \\<le> m * n; \\<not> n \\<le> sc;\n     m \\<le> lb \\<or> lb < m\\<rbrakk>\n    \\<Longrightarrow> sc - n + (n + lb * n) \\<le> m * n", "apply (erule_tac k=n and k'=n in *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < sc; sc + lb * n \\<le> m * n; \\<not> n \\<le> sc;\n     m * n \\<le> lb * n\\<rbrakk>\n    \\<Longrightarrow> sc - n + (n + lb * n) \\<le> m * n\n 2. \\<lbrakk>0 < sc; sc + lb * n \\<le> m * n; \\<not> n \\<le> sc;\n     Suc lb * n \\<le> m * n\\<rbrakk>\n    \\<Longrightarrow> sc - n + (n + lb * n) \\<le> m * n", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < sc; sc + lb * n \\<le> m * n; \\<not> n \\<le> sc;\n     Suc lb * n \\<le> m * n\\<rbrakk>\n    \\<Longrightarrow> sc - n + (n + lb * n) \\<le> m * n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < ?sc \\<Longrightarrow>\n  (?sc - ?n + (?n + ?lb * ?n) \\<le> ?m * ?n) =\n  (?sc + ?lb * ?n \\<le> ?m * ?n)\n\ngoal (1 subgoal):\n 1. \\<forall>ws m.\n       n \\<noteq> 0 \\<longrightarrow>\n       ws = bin_rsplit_aux n nw w bs \\<longrightarrow>\n       (length ws \\<le> m) = (nw + length bs * n \\<le> m * n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ws m.\n       n \\<noteq> 0 \\<longrightarrow>\n       ws = bin_rsplit_aux n nw w bs \\<longrightarrow>\n       (length ws \\<le> m) = (nw + length bs * n \\<le> m * n)", "apply (induct n nw w bs rule: bin_rsplit_aux.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs.\n       (\\<And>x xa y.\n           \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); x = bin_split n c;\n            (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> \\<forall>ws ma.\n                                n \\<noteq> 0 \\<longrightarrow>\n                                ws =\n                                bin_rsplit_aux n (m - n) xa\n                                 (y # bs) \\<longrightarrow>\n                                (length ws \\<le> ma) =\n                                (m - n + length (y # bs) * n\n                                 \\<le> ma * n)) \\<Longrightarrow>\n       \\<forall>ws ma.\n          n \\<noteq> 0 \\<longrightarrow>\n          ws = bin_rsplit_aux n m c bs \\<longrightarrow>\n          (length ws \\<le> ma) = (m + length bs * n \\<le> ma * n)", "apply (subst bin_rsplit_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs.\n       (\\<And>x xa y.\n           \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); x = bin_split n c;\n            (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> \\<forall>ws ma.\n                                n \\<noteq> 0 \\<longrightarrow>\n                                ws =\n                                bin_rsplit_aux n (m - n) xa\n                                 (y # bs) \\<longrightarrow>\n                                (length ws \\<le> ma) =\n                                (m - n + length (y # bs) * n\n                                 \\<le> ma * n)) \\<Longrightarrow>\n       \\<forall>ws ma.\n          n \\<noteq> 0 \\<longrightarrow>\n          ws =\n          (if m = 0 \\<or> n = 0 then bs\n           else let (a, b) = bin_split n c\n                in bin_rsplit_aux n (m - n) a (b # bs)) \\<longrightarrow>\n          (length ws \\<le> ma) = (m + length bs * n \\<le> ma * n)", "apply (simp add: ** Let_def split: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>ws m.\n     n \\<noteq> 0 \\<longrightarrow>\n     ws = bin_rsplit_aux n nw w bs \\<longrightarrow>\n     (length ws \\<le> m) = (nw + length bs * n \\<le> m * n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_rsplit_len_le: \"n \\<noteq> 0 \\<longrightarrow> ws = bin_rsplit n (nw, w) \\<longrightarrow> length ws \\<le> m \\<longleftrightarrow> nw \\<le> m * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<longrightarrow>\n    ws = bin_rsplit n (nw, w) \\<longrightarrow>\n    (length ws \\<le> m) = (nw \\<le> m * n)", "by (auto simp: bin_rsplit_def bin_rsplit_aux_len_le)"], ["", "lemma bin_rsplit_aux_len:\n  \"n \\<noteq> 0 \\<Longrightarrow> length (bin_rsplit_aux n nw w cs) = (nw + n - 1) div n + length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    length (bin_rsplit_aux n nw w cs) = (nw + n - 1) div n + length cs", "apply (induct n nw w cs rule: bin_rsplit_aux.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); x = bin_split n c;\n                    (xa, y) = x; n \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> length\n(bin_rsplit_aux n (m - n) xa (y # bs)) =\n                                     (m - n + n - 1) div n +\n                                     length (y # bs);\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> length (bin_rsplit_aux n m c bs) =\n                         (m + n - 1) div n + length bs", "apply (subst bin_rsplit_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); x = bin_split n c;\n                    (xa, y) = x; n \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> length\n(bin_rsplit_aux n (m - n) xa (y # bs)) =\n                                     (m - n + n - 1) div n +\n                                     length (y # bs);\n        n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> length\n                          (if m = 0 \\<or> n = 0 then bs\n                           else let (a, b) = bin_split n c\n                                in bin_rsplit_aux n (m - n) a (b # bs)) =\n                         (m + n - 1) div n + length bs", "apply (clarsimp simp: Let_def split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs.\n       \\<lbrakk>\\<And>a xa.\n                   \\<lbrakk>a = drop_bit n c; xa = drop_bit n c\\<rbrakk>\n                   \\<Longrightarrow> length\n(bin_rsplit_aux n (m - n) (drop_bit n c) (take_bit n c # bs)) =\n                                     Suc\n((m - n + n - Suc 0) div n + length bs);\n        0 < n; 0 < m\\<rbrakk>\n       \\<Longrightarrow> Suc ((m - n + n - Suc 0) div n) =\n                         (m + n - Suc 0) div n", "apply (erule thin_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs.\n       \\<lbrakk>0 < n; 0 < m\\<rbrakk>\n       \\<Longrightarrow> Suc ((m - n + n - Suc 0) div n) =\n                         (m + n - Suc 0) div n", "apply (case_tac m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n m c bs.\n       \\<lbrakk>0 < n; 0 < m; m = 0\\<rbrakk>\n       \\<Longrightarrow> Suc ((m - n + n - Suc 0) div n) =\n                         (m + n - Suc 0) div n\n 2. \\<And>n m c bs nat.\n       \\<lbrakk>0 < n; 0 < m; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc ((m - n + n - Suc 0) div n) =\n                         (m + n - Suc 0) div n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m c bs nat.\n       \\<lbrakk>0 < n; 0 < m; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc ((m - n + n - Suc 0) div n) =\n                         (m + n - Suc 0) div n", "apply (case_tac \"m \\<le> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n m c bs nat.\n       \\<lbrakk>0 < n; 0 < m; m = Suc nat; m \\<le> n\\<rbrakk>\n       \\<Longrightarrow> Suc ((m - n + n - Suc 0) div n) =\n                         (m + n - Suc 0) div n\n 2. \\<And>n m c bs nat.\n       \\<lbrakk>0 < n; 0 < m; m = Suc nat; \\<not> m \\<le> n\\<rbrakk>\n       \\<Longrightarrow> Suc ((m - n + n - Suc 0) div n) =\n                         (m + n - Suc 0) div n", "apply (auto simp add: div_add_self2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_rsplit_len: \"n \\<noteq> 0 \\<Longrightarrow> length (bin_rsplit n (nw, w)) = (nw + n - 1) div n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    length (bin_rsplit n (nw, w)) = (nw + n - 1) div n", "by (auto simp: bin_rsplit_def bin_rsplit_aux_len)"], ["", "lemma bin_rsplit_aux_len_indep:\n  \"n \\<noteq> 0 \\<Longrightarrow> length bs = length cs \\<Longrightarrow>\n    length (bin_rsplit_aux n nw v bs) =\n    length (bin_rsplit_aux n nw w cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0; length bs = length cs\\<rbrakk>\n    \\<Longrightarrow> length (bin_rsplit_aux n nw v bs) =\n                      length (bin_rsplit_aux n nw w cs)", "proof (induct n nw w cs arbitrary: v bs rule: bin_rsplit_aux.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m c bs v bsa.\n       \\<lbrakk>\\<And>x xa y v bsa.\n                   \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); x = bin_split n c;\n                    (xa, y) = x; n \\<noteq> 0;\n                    length bsa = length (y # bs)\\<rbrakk>\n                   \\<Longrightarrow> length\n(bin_rsplit_aux n (m - n) v bsa) =\n                                     length\n(bin_rsplit_aux n (m - n) xa (y # bs));\n        n \\<noteq> 0; length bsa = length bs\\<rbrakk>\n       \\<Longrightarrow> length (bin_rsplit_aux n m v bsa) =\n                         length (bin_rsplit_aux n m c bs)", "case (1 n m w cs v bs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); ?x = bin_split n w; (?xa, ?y) = ?x;\n   n \\<noteq> 0; length ?bs = length (?y # cs)\\<rbrakk>\n  \\<Longrightarrow> length (bin_rsplit_aux n (m - n) ?v ?bs) =\n                    length (bin_rsplit_aux n (m - n) ?xa (?y # cs))\n  n \\<noteq> 0\n  length bs = length cs\n\ngoal (1 subgoal):\n 1. \\<And>n m c bs v bsa.\n       \\<lbrakk>\\<And>x xa y v bsa.\n                   \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); x = bin_split n c;\n                    (xa, y) = x; n \\<noteq> 0;\n                    length bsa = length (y # bs)\\<rbrakk>\n                   \\<Longrightarrow> length\n(bin_rsplit_aux n (m - n) v bsa) =\n                                     length\n(bin_rsplit_aux n (m - n) xa (y # bs));\n        n \\<noteq> 0; length bsa = length bs\\<rbrakk>\n       \\<Longrightarrow> length (bin_rsplit_aux n m v bsa) =\n                         length (bin_rsplit_aux n m c bs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)", "proof (cases \"m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)", "case True"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)", "with \\<open>length bs = length cs\\<close>"], ["proof (chain)\npicking this:\n  length bs = length cs\n  m = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  length bs = length cs\n  m = 0\n\ngoal (1 subgoal):\n 1. length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)", "by simp"], ["proof (state)\nthis:\n  length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)", "case False"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)", "from \"1.hyps\" [of \\<open>bin_split n w\\<close> \\<open>drop_bit n w\\<close> \\<open>take_bit n w\\<close>] \\<open>m \\<noteq> 0\\<close> \\<open>n \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); bin_split n w = bin_split n w;\n   (drop_bit n w, take_bit n w) = bin_split n w; n \\<noteq> 0;\n   length ?bs = length (take_bit n w # cs)\\<rbrakk>\n  \\<Longrightarrow> length (bin_rsplit_aux n (m - n) ?v ?bs) =\n                    length\n                     (bin_rsplit_aux n (m - n) (drop_bit n w)\n                       (take_bit n w # cs))\n  m \\<noteq> 0\n  n \\<noteq> 0", "have hyp: \"\\<And>v bs. length bs = Suc (length cs) \\<Longrightarrow>\n      length (bin_rsplit_aux n (m - n) v bs) =\n      length (bin_rsplit_aux n (m - n) (drop_bit n w) (take_bit n w # cs))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); bin_split n w = bin_split n w;\n   (drop_bit n w, take_bit n w) = bin_split n w; n \\<noteq> 0;\n   length ?bs = length (take_bit n w # cs)\\<rbrakk>\n  \\<Longrightarrow> length (bin_rsplit_aux n (m - n) ?v ?bs) =\n                    length\n                     (bin_rsplit_aux n (m - n) (drop_bit n w)\n                       (take_bit n w # cs))\n  m \\<noteq> 0\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>v bs.\n       length bs = Suc (length cs) \\<Longrightarrow>\n       length (bin_rsplit_aux n (m - n) v bs) =\n       length (bin_rsplit_aux n (m - n) (drop_bit n w) (take_bit n w # cs))", "using bin_rsplit_aux_len"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> (m = 0 \\<or> n = 0); bin_split n w = bin_split n w;\n   (drop_bit n w, take_bit n w) = bin_split n w; n \\<noteq> 0;\n   length ?bs = length (take_bit n w # cs)\\<rbrakk>\n  \\<Longrightarrow> length (bin_rsplit_aux n (m - n) ?v ?bs) =\n                    length\n                     (bin_rsplit_aux n (m - n) (drop_bit n w)\n                       (take_bit n w # cs))\n  m \\<noteq> 0\n  n \\<noteq> 0\n  ?n \\<noteq> 0 \\<Longrightarrow>\n  length (bin_rsplit_aux ?n ?nw ?w ?cs) = (?nw + ?n - 1) div ?n + length ?cs\n\ngoal (1 subgoal):\n 1. \\<And>v bs.\n       length bs = Suc (length cs) \\<Longrightarrow>\n       length (bin_rsplit_aux n (m - n) v bs) =\n       length (bin_rsplit_aux n (m - n) (drop_bit n w) (take_bit n w # cs))", "by fastforce"], ["proof (state)\nthis:\n  length ?bs = Suc (length cs) \\<Longrightarrow>\n  length (bin_rsplit_aux n (m - n) ?v ?bs) =\n  length (bin_rsplit_aux n (m - n) (drop_bit n w) (take_bit n w # cs))\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)", "from \\<open>length bs = length cs\\<close> \\<open>n \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  length bs = length cs\n  n \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  length bs = length cs\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)", "by (auto simp add: bin_rsplit_aux_simp_alt Let_def bin_rsplit_len split: prod.split)"], ["proof (state)\nthis:\n  length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bin_rsplit_aux n m v bs) = length (bin_rsplit_aux n m w cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_rsplit_len_indep:\n  \"n \\<noteq> 0 \\<Longrightarrow> length (bin_rsplit n (nw, v)) = length (bin_rsplit n (nw, w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    length (bin_rsplit n (nw, v)) = length (bin_rsplit n (nw, w))", "apply (unfold bin_rsplit_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    length (bin_rsplit_aux n (fst (nw, v)) (snd (nw, v)) []) =\n    length (bin_rsplit_aux n (fst (nw, w)) (snd (nw, w)) [])", "apply (simp (no_asm))"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    length (bin_rsplit_aux n nw v []) = length (bin_rsplit_aux n nw w [])", "apply (erule bin_rsplit_aux_len_indep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [] = length []", "apply (rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Logical operations\\<close>"], ["", "primrec bin_sc :: \"nat \\<Rightarrow> bool \\<Rightarrow> int \\<Rightarrow> int\"\n  where\n    Z: \"bin_sc 0 b w = of_bool b + 2 * bin_rest w\"\n  | Suc: \"bin_sc (Suc n) b w = of_bool (odd w) + 2 * bin_sc n b (w div 2)\""], ["", "lemma bin_nth_sc [simp]: \"bit (bin_sc n b w) n \\<longleftrightarrow> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (bin_sc n b w) n = b", "by (induction n arbitrary: w) (simp_all add: bit_Suc)"], ["", "lemma bin_sc_sc_same [simp]: \"bin_sc n c (bin_sc n b w) = bin_sc n c w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sc n c (bin_sc n b w) = bin_sc n c w", "by (induction n arbitrary: w) (simp_all add: bit_Suc)"], ["", "lemma bin_sc_sc_diff: \"m \\<noteq> n \\<Longrightarrow> bin_sc m c (bin_sc n b w) = bin_sc n b (bin_sc m c w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> n \\<Longrightarrow>\n    bin_sc m c (bin_sc n b w) = bin_sc n b (bin_sc m c w)", "apply (induct n arbitrary: w m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w m.\n       m \\<noteq> 0 \\<Longrightarrow>\n       bin_sc m c (bin_sc 0 b w) = bin_sc 0 b (bin_sc m c w)\n 2. \\<And>n w m.\n       \\<lbrakk>\\<And>w m.\n                   m \\<noteq> n \\<Longrightarrow>\n                   bin_sc m c (bin_sc n b w) = bin_sc n b (bin_sc m c w);\n        m \\<noteq> Suc n\\<rbrakk>\n       \\<Longrightarrow> bin_sc m c (bin_sc (Suc n) b w) =\n                         bin_sc (Suc n) b (bin_sc m c w)", "apply (case_tac [!] m)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>w m.\n       \\<lbrakk>m \\<noteq> 0; m = 0\\<rbrakk>\n       \\<Longrightarrow> bin_sc m c (bin_sc 0 b w) =\n                         bin_sc 0 b (bin_sc m c w)\n 2. \\<And>w m nat.\n       \\<lbrakk>m \\<noteq> 0; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> bin_sc m c (bin_sc 0 b w) =\n                         bin_sc 0 b (bin_sc m c w)\n 3. \\<And>n w m.\n       \\<lbrakk>\\<And>w m.\n                   m \\<noteq> n \\<Longrightarrow>\n                   bin_sc m c (bin_sc n b w) = bin_sc n b (bin_sc m c w);\n        m \\<noteq> Suc n; m = 0\\<rbrakk>\n       \\<Longrightarrow> bin_sc m c (bin_sc (Suc n) b w) =\n                         bin_sc (Suc n) b (bin_sc m c w)\n 4. \\<And>n w m nat.\n       \\<lbrakk>\\<And>w m.\n                   m \\<noteq> n \\<Longrightarrow>\n                   bin_sc m c (bin_sc n b w) = bin_sc n b (bin_sc m c w);\n        m \\<noteq> Suc n; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> bin_sc m c (bin_sc (Suc n) b w) =\n                         bin_sc (Suc n) b (bin_sc m c w)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_nth_sc_gen: \"bin_nth (bin_sc n b w) m = (if m = n then b else bin_nth w m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (bin_sc n b w) m = (if m = n then b else bit w m)", "apply (induct n arbitrary: w m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w m. bit (bin_sc 0 b w) m = (if m = 0 then b else bit w m)\n 2. \\<And>n w m.\n       (\\<And>w m.\n           bit (bin_sc n b w) m =\n           (if m = n then b else bit w m)) \\<Longrightarrow>\n       bit (bin_sc (Suc n) b w) m = (if m = Suc n then b else bit w m)", "apply (case_tac m; simp add: bit_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n w m.\n       (\\<And>w m.\n           bit (bin_sc n b w) m =\n           (if m = n then b else bit w m)) \\<Longrightarrow>\n       bit (bin_sc (Suc n) b w) m = (if m = Suc n then b else bit w m)", "apply (case_tac m; simp add: bit_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_sc_eq:\n  \\<open>bin_sc n False = unset_bit n\\<close>\n  \\<open>bin_sc n True = Bit_Operations.set_bit n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sc n False = unset_bit n &&& bin_sc n True = set_bit n", "by (simp_all add: fun_eq_iff bit_eq_iff)\n    (simp_all add: bin_nth_sc_gen bit_set_bit_iff bit_unset_bit_iff)"], ["", "lemma bin_sc_nth [simp]: \"bin_sc n (bin_nth w n) w = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sc n (bit w n) w = w", "by (rule bit_eqI) (simp add: bin_nth_sc_gen)"], ["", "lemma bin_sign_sc [simp]: \"bin_sign (bin_sc n b w) = bin_sign w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sign (bin_sc n b w) = bin_sign w", "proof (induction n arbitrary: w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w. bin_sign (bin_sc 0 b w) = bin_sign w\n 2. \\<And>n w.\n       (\\<And>w. bin_sign (bin_sc n b w) = bin_sign w) \\<Longrightarrow>\n       bin_sign (bin_sc (Suc n) b w) = bin_sign w", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>w. bin_sign (bin_sc 0 b w) = bin_sign w\n 2. \\<And>n w.\n       (\\<And>w. bin_sign (bin_sc n b w) = bin_sign w) \\<Longrightarrow>\n       bin_sign (bin_sc (Suc n) b w) = bin_sign w", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sign (bin_sc 0 b w) = bin_sign w", "by (auto simp add: bin_sign_def) (use bin_rest_ge_0 in fastforce)"], ["proof (state)\nthis:\n  bin_sign (bin_sc 0 b w) = bin_sign w\n\ngoal (1 subgoal):\n 1. \\<And>n w.\n       (\\<And>w. bin_sign (bin_sc n b w) = bin_sign w) \\<Longrightarrow>\n       bin_sign (bin_sc (Suc n) b w) = bin_sign w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n w.\n       (\\<And>w. bin_sign (bin_sc n b w) = bin_sign w) \\<Longrightarrow>\n       bin_sign (bin_sc (Suc n) b w) = bin_sign w", "case (Suc n)"], ["proof (state)\nthis:\n  bin_sign (bin_sc n b ?w) = bin_sign ?w\n\ngoal (1 subgoal):\n 1. \\<And>n w.\n       (\\<And>w. bin_sign (bin_sc n b w) = bin_sign w) \\<Longrightarrow>\n       bin_sign (bin_sc (Suc n) b w) = bin_sign w", "from Suc [of \\<open>w div 2\\<close>]"], ["proof (chain)\npicking this:\n  bin_sign (bin_sc n b (w div 2)) = bin_sign (w div 2)", "show ?case"], ["proof (prove)\nusing this:\n  bin_sign (bin_sc n b (w div 2)) = bin_sign (w div 2)\n\ngoal (1 subgoal):\n 1. bin_sign (bin_sc (Suc n) b w) = bin_sign w", "by (auto simp add: bin_sign_def split: if_splits)"], ["proof (state)\nthis:\n  bin_sign (bin_sc (Suc n) b w) = bin_sign w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_sc_bintr [simp]:\n  \"bintrunc m (bin_sc n x (bintrunc m w)) = bintrunc m (bin_sc n x w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit m (bin_sc n x (take_bit m w)) = take_bit m (bin_sc n x w)", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<Longrightarrow>\n    take_bit m (bin_sc n x (take_bit m w)) = take_bit m (bin_sc n x w)\n 2. \\<not> x \\<Longrightarrow>\n    take_bit m (bin_sc n x (take_bit m w)) = take_bit m (bin_sc n x w)", "apply (simp_all add: bin_sc_eq bit_eq_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<Longrightarrow>\n    \\<forall>na.\n       bit (take_bit m (set_bit n (take_bit m w))) na =\n       bit (take_bit m (set_bit n w)) na\n 2. \\<not> x \\<Longrightarrow>\n    \\<forall>na.\n       bit (take_bit m (unset_bit n (take_bit m w))) na =\n       bit (take_bit m (unset_bit n w)) na", "apply (auto simp add: bit_take_bit_iff bit_set_bit_iff bit_unset_bit_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bin_clr_le: \"bin_sc n False w \\<le> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sc n False w \\<le> w", "by (simp add: bin_sc_eq unset_bit_less_eq)"], ["", "lemma bin_set_ge: \"bin_sc n True w \\<ge> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<le> bin_sc n True w", "by (simp add: bin_sc_eq set_bit_greater_eq)"], ["", "lemma bintr_bin_clr_le: \"bintrunc n (bin_sc m False w) \\<le> bintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n (bin_sc m False w) \\<le> take_bit n w", "by (simp add: bin_sc_eq take_bit_unset_bit_eq unset_bit_less_eq)"], ["", "lemma bintr_bin_set_ge: \"bintrunc n (bin_sc m True w) \\<ge> bintrunc n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n w \\<le> take_bit n (bin_sc m True w)", "by (simp add: bin_sc_eq take_bit_set_bit_eq set_bit_greater_eq)"], ["", "lemma bin_sc_FP [simp]: \"bin_sc n False 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sc n False 0 = 0", "by (induct n) auto"], ["", "lemma bin_sc_TM [simp]: \"bin_sc n True (- 1) = - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sc n True (- 1) = - 1", "by (induct n) auto"], ["", "lemmas bin_sc_simps = bin_sc.Z bin_sc.Suc bin_sc_TM bin_sc_FP"], ["", "lemma bin_sc_minus: \"0 < n \\<Longrightarrow> bin_sc (Suc (n - 1)) b w = bin_sc n b w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> bin_sc (Suc (n - 1)) b w = bin_sc n b w", "by auto"], ["", "lemmas bin_sc_Suc_minus =\n  trans [OF bin_sc_minus [symmetric] bin_sc.Suc]"], ["", "lemma bin_sc_numeral [simp]:\n  \"bin_sc (numeral k) b w =\n    of_bool (odd w) + 2 * bin_sc (pred_numeral k) b (w div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sc (numeral k) b w =\n    of_bool (odd w) + 2 * bin_sc (pred_numeral k) b (w div 2)", "by (simp add: numeral_eq_Suc)"], ["", "lemmas bin_sc_minus_simps =\n  bin_sc_simps (2,3,4) [THEN [2] trans, OF bin_sc_minus [THEN sym]]"], ["", "instance int :: semiring_bit_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(int, semiring_bit_syntax_class)", ".."], ["", "lemma test_bit_int_def [iff]:\n  \"i !! n \\<longleftrightarrow> bin_nth i n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i !! n = bit i n", "by (simp add: test_bit_eq_bit)"], ["", "lemma shiftl_int_def:\n  \"shiftl x n = x * 2 ^ n\" for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. x << n = x * 2 ^ n", "by (simp add: push_bit_int_def shiftl_eq_push_bit)"], ["", "lemma shiftr_int_def:\n  \"shiftr x n = x div 2 ^ n\" for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. x >> n = x div 2 ^ n", "by (simp add: drop_bit_int_def shiftr_eq_drop_bit)"], ["", "subsubsection \\<open>Basic simplification rules\\<close>"], ["", "lemmas int_not_def = not_int_def"], ["", "lemma int_not_simps [simp]:\n  \"NOT (0::int) = -1\"\n  \"NOT (1::int) = -2\"\n  \"NOT (- 1::int) = 0\"\n  \"NOT (numeral w::int) = - numeral (w + Num.One)\"\n  \"NOT (- numeral (Num.Bit0 w)::int) = numeral (Num.BitM w)\"\n  \"NOT (- numeral (Num.Bit1 w)::int) = numeral (Num.Bit0 w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (NOT 0 = - 1 &&& NOT 1 = - 2 &&& NOT (- 1) = 0) &&&\n    NOT (numeral w) = - numeral (w + num.One) &&&\n    NOT (- numeral (num.Bit0 w)) = numeral (Num.BitM w) &&&\n    NOT (- numeral (num.Bit1 w)) = numeral (num.Bit0 w)", "by (simp_all add: not_int_def)"], ["", "lemma int_not_not: \"NOT (NOT x) = x\"\n  for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT (NOT x) = x", "by (fact bit.double_compl)"], ["", "lemma int_and_0 [simp]: \"0 AND x = 0\"\n  for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 AND x = 0", "by (fact bit.conj_zero_left)"], ["", "lemma int_and_m1 [simp]: \"-1 AND x = x\"\n  for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 AND x = x", "by (fact bit.conj_one_left)"], ["", "lemma int_or_zero [simp]: \"0 OR x = x\"\n  for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 OR x = x", "by (fact bit.disj_zero_left)"], ["", "lemma int_or_minus1 [simp]: \"-1 OR x = -1\"\n  for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 OR x = - 1", "by (fact bit.disj_one_left)"], ["", "lemma int_xor_zero [simp]: \"0 XOR x = x\"\n  for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 XOR x = x", "by (fact bit.xor_zero_left)"], ["", "subsubsection \\<open>Binary destructors\\<close>"], ["", "lemma bin_rest_NOT [simp]: \"bin_rest (NOT x) = NOT (bin_rest x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT x div 2 = NOT (x div 2)", "by (fact not_int_div_2)"], ["", "lemma bin_last_NOT [simp]: \"bin_last (NOT x) \\<longleftrightarrow> \\<not> bin_last x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (NOT x) = (\\<not> odd x)", "by simp"], ["", "lemma bin_rest_AND [simp]: \"bin_rest (x AND y) = bin_rest x AND bin_rest y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x AND y) div 2 = x div 2 AND y div 2", "by (subst and_int_rec) auto"], ["", "lemma bin_last_AND [simp]: \"bin_last (x AND y) \\<longleftrightarrow> bin_last x \\<and> bin_last y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (x AND y) = (odd x \\<and> odd y)", "by (subst and_int_rec) auto"], ["", "lemma bin_rest_OR [simp]: \"bin_rest (x OR y) = bin_rest x OR bin_rest y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x OR y) div 2 = x div 2 OR y div 2", "by (subst or_int_rec) auto"], ["", "lemma bin_last_OR [simp]: \"bin_last (x OR y) \\<longleftrightarrow> bin_last x \\<or> bin_last y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (x OR y) = (odd x \\<or> odd y)", "by (subst or_int_rec) auto"], ["", "lemma bin_rest_XOR [simp]: \"bin_rest (x XOR y) = bin_rest x XOR bin_rest y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x XOR y) div 2 = x div 2 XOR y div 2", "by (subst xor_int_rec) auto"], ["", "lemma bin_last_XOR [simp]: \"bin_last (x XOR y) \\<longleftrightarrow> (bin_last x \\<or> bin_last y) \\<and> \\<not> (bin_last x \\<and> bin_last y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (x XOR y) = ((odd x \\<or> odd y) \\<and> \\<not> (odd x \\<and> odd y))", "by (subst xor_int_rec) auto"], ["", "lemma bin_nth_ops:\n  \"\\<And>x y. bin_nth (x AND y) n \\<longleftrightarrow> bin_nth x n \\<and> bin_nth y n\"\n  \"\\<And>x y. bin_nth (x OR y) n \\<longleftrightarrow> bin_nth x n \\<or> bin_nth y n\"\n  \"\\<And>x y. bin_nth (x XOR y) n \\<longleftrightarrow> bin_nth x n \\<noteq> bin_nth y n\"\n  \"\\<And>x. bin_nth (NOT x) n \\<longleftrightarrow> \\<not> bin_nth x n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>x y. bit (x AND y) n = (bit x n \\<and> bit y n)) &&&\n     (\\<And>x y. bit (x OR y) n = (bit x n \\<or> bit y n))) &&&\n    (\\<And>x y. bit (x XOR y) n = (bit x n \\<noteq> bit y n)) &&&\n    (\\<And>x. bit (NOT x) n = (\\<not> bit x n))", "by (simp_all add: bit_and_iff bit_or_iff bit_xor_iff bit_not_iff)"], ["", "subsubsection \\<open>Derived properties\\<close>"], ["", "lemma int_xor_minus1 [simp]: \"-1 XOR x = NOT x\"\n  for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 XOR x = NOT x", "by (fact bit.xor_one_left)"], ["", "lemma int_xor_extra_simps [simp]:\n  \"w XOR 0 = w\"\n  \"w XOR -1 = NOT w\"\n  for w :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. w XOR 0 = w &&& w XOR - 1 = NOT w", "by simp_all"], ["", "lemma int_or_extra_simps [simp]:\n  \"w OR 0 = w\"\n  \"w OR -1 = -1\"\n  for w :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. w OR 0 = w &&& w OR - 1 = - 1", "by simp_all"], ["", "lemma int_and_extra_simps [simp]:\n  \"w AND 0 = 0\"\n  \"w AND -1 = w\"\n  for w :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. w AND 0 = 0 &&& w AND - 1 = w", "by simp_all"], ["", "text \\<open>Commutativity of the above.\\<close>"], ["", "lemma bin_ops_comm:\n  fixes x y :: int\n  shows int_and_comm: \"x AND y = y AND x\"\n    and int_or_comm:  \"x OR y = y OR x\"\n    and int_xor_comm: \"x XOR y = y XOR x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND y = y AND x &&& x OR y = y OR x &&& x XOR y = y XOR x", "by (simp_all add: ac_simps)"], ["", "lemma bin_ops_same [simp]:\n  \"x AND x = x\"\n  \"x OR x = x\"\n  \"x XOR x = 0\"\n  for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND x = x &&& x OR x = x &&& x XOR x = 0", "by simp_all"], ["", "lemmas bin_log_esimps =\n  int_and_extra_simps  int_or_extra_simps  int_xor_extra_simps\n  int_and_0 int_and_m1 int_or_zero int_or_minus1 int_xor_zero int_xor_minus1"], ["", "subsubsection \\<open>Basic properties of logical (bit-wise) operations\\<close>"], ["", "lemma bbw_ao_absorb: \"x AND (y OR x) = x \\<and> x OR (y AND x) = x\"\n  for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND (y OR x) = x \\<and> x OR y AND x = x", "by (auto simp add: bin_eq_iff bin_nth_ops)"], ["", "lemma bbw_ao_absorbs_other:\n  \"x AND (x OR y) = x \\<and> (y AND x) OR x = x\"\n  \"(y OR x) AND x = x \\<and> x OR (x AND y) = x\"\n  \"(x OR y) AND x = x \\<and> (x AND y) OR x = x\"\n  for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND (x OR y) = x \\<and> y AND x OR x = x &&&\n    (y OR x) AND x = x \\<and> x OR x AND y = x &&&\n    (x OR y) AND x = x \\<and> x AND y OR x = x", "by (auto simp add: bin_eq_iff bin_nth_ops)"], ["", "lemmas bbw_ao_absorbs [simp] = bbw_ao_absorb bbw_ao_absorbs_other"], ["", "lemma int_xor_not: \"(NOT x) XOR y = NOT (x XOR y) \\<and> x XOR (NOT y) = NOT (x XOR y)\"\n  for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT x XOR y = NOT (x XOR y) \\<and> x XOR NOT y = NOT (x XOR y)", "by (auto simp add: bin_eq_iff bin_nth_ops)"], ["", "lemma int_and_assoc: \"(x AND y) AND z = x AND (y AND z)\"\n  for x y z :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x AND y) AND z = x AND y AND z", "by (auto simp add: bin_eq_iff bin_nth_ops)"], ["", "lemma int_or_assoc: \"(x OR y) OR z = x OR (y OR z)\"\n  for x y z :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x OR y) OR z = x OR y OR z", "by (auto simp add: bin_eq_iff bin_nth_ops)"], ["", "lemma int_xor_assoc: \"(x XOR y) XOR z = x XOR (y XOR z)\"\n  for x y z :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x XOR y) XOR z = x XOR y XOR z", "by (auto simp add: bin_eq_iff bin_nth_ops)"], ["", "lemmas bbw_assocs = int_and_assoc int_or_assoc int_xor_assoc"], ["", "(* BH: Why are these declared as simp rules??? *)"], ["", "lemma bbw_lcs [simp]:\n  \"y AND (x AND z) = x AND (y AND z)\"\n  \"y OR (x OR z) = x OR (y OR z)\"\n  \"y XOR (x XOR z) = x XOR (y XOR z)\"\n  for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. y AND x AND z = x AND y AND z &&&\n    y OR x OR z = x OR y OR z &&& y XOR x XOR z = x XOR y XOR z", "by (auto simp add: bin_eq_iff bin_nth_ops)"], ["", "lemma bbw_not_dist:\n  \"NOT (x OR y) = (NOT x) AND (NOT y)\"\n  \"NOT (x AND y) = (NOT x) OR (NOT y)\"\n  for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT (x OR y) = NOT x AND NOT y &&& NOT (x AND y) = NOT x OR NOT y", "by (auto simp add: bin_eq_iff bin_nth_ops)"], ["", "lemma bbw_oa_dist: \"(x AND y) OR z = (x OR z) AND (y OR z)\"\n  for x y z :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND y OR z = (x OR z) AND (y OR z)", "by (auto simp add: bin_eq_iff bin_nth_ops)"], ["", "lemma bbw_ao_dist: \"(x OR y) AND z = (x AND z) OR (y AND z)\"\n  for x y z :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x OR y) AND z = x AND z OR y AND z", "by (auto simp add: bin_eq_iff bin_nth_ops)"], ["", "(*\nWhy were these declared simp???\ndeclare bin_ops_comm [simp] bbw_assocs [simp]\n*)"], ["", "subsubsection \\<open>Simplification with numerals\\<close>"], ["", "text \\<open>Cases for \\<open>0\\<close> and \\<open>-1\\<close> are already covered by other simp rules.\\<close>"], ["", "lemma bin_rest_neg_numeral_BitM [simp]:\n  \"bin_rest (- numeral (Num.BitM w)) = - numeral w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - numeral (Num.BitM w) div 2 = - numeral w", "by simp"], ["", "lemma bin_last_neg_numeral_BitM [simp]:\n  \"bin_last (- numeral (Num.BitM w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (- numeral (Num.BitM w))", "by simp"], ["", "subsubsection \\<open>Interactions with arithmetic\\<close>"], ["", "lemma le_int_or: \"bin_sign y = 0 \\<Longrightarrow> x \\<le> x OR y\"\n  for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sign y = 0 \\<Longrightarrow> x \\<le> x OR y", "by (simp add: bin_sign_def or_greater_eq split: if_splits)"], ["", "lemmas int_and_le =\n  xtrans(3) [OF bbw_ao_absorbs (2) [THEN conjunct2, symmetric] le_int_or]"], ["", "text \\<open>Interaction between bit-wise and arithmetic: good example of \\<open>bin_induction\\<close>.\\<close>"], ["", "lemma bin_add_not: \"x + NOT x = (-1::int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + NOT x = - 1", "by (simp add: not_int_def)"], ["", "lemma AND_mod: \"x AND (2 ^ n - 1) = x mod 2 ^ n\"\n  for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND 2 ^ n - 1 = x mod 2 ^ n", "by (simp flip: take_bit_eq_mod add: take_bit_eq_mask mask_eq_exp_minus_1)"], ["", "subsubsection \\<open>Truncating results of bit-wise operations\\<close>"], ["", "lemma bin_trunc_ao:\n  \"bintrunc n x AND bintrunc n y = bintrunc n (x AND y)\"\n  \"bintrunc n x OR bintrunc n y = bintrunc n (x OR y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n x AND take_bit n y = take_bit n (x AND y) &&&\n    take_bit n x OR take_bit n y = take_bit n (x OR y)", "by simp_all"], ["", "lemma bin_trunc_xor: \"bintrunc n (bintrunc n x XOR bintrunc n y) = bintrunc n (x XOR y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n (take_bit n x XOR take_bit n y) = take_bit n (x XOR y)", "by simp"], ["", "lemma bin_trunc_not: \"bintrunc n (NOT (bintrunc n x)) = bintrunc n (NOT x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n (NOT (take_bit n x)) = take_bit n (NOT x)", "by (fact take_bit_not_take_bit)"], ["", "text \\<open>Want theorems of the form of \\<open>bin_trunc_xor\\<close>.\\<close>"], ["", "lemma bintr_bintr_i: \"x = bintrunc n y \\<Longrightarrow> bintrunc n x = bintrunc n y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = take_bit n y \\<Longrightarrow> take_bit n x = take_bit n y", "by auto"], ["", "lemmas bin_trunc_and = bin_trunc_ao(1) [THEN bintr_bintr_i]"], ["", "lemmas bin_trunc_or = bin_trunc_ao(2) [THEN bintr_bintr_i]"], ["", "subsubsection \\<open>More lemmas\\<close>"], ["", "lemma not_int_cmp_0 [simp]:\n  fixes i :: int shows\n  \"0 < NOT i \\<longleftrightarrow> i < -1\"\n  \"0 \\<le> NOT i \\<longleftrightarrow> i < 0\"\n  \"NOT i < 0 \\<longleftrightarrow> i \\<ge> 0\"\n  \"NOT i \\<le> 0 \\<longleftrightarrow> i \\<ge> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0 < NOT i) = (i < - 1) &&& (0 \\<le> NOT i) = (i < 0)) &&&\n    (NOT i < 0) = (0 \\<le> i) &&& (NOT i \\<le> 0) = (- 1 \\<le> i)", "by(simp_all add: int_not_def) arith+"], ["", "lemma bbw_ao_dist2: \"(x :: int) AND (y OR z) = x AND y OR x AND z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND (y OR z) = x AND y OR x AND z", "by (fact bit.conj_disj_distrib)"], ["", "lemmas int_and_ac = bbw_lcs(1) int_and_comm int_and_assoc"], ["", "lemma int_nand_same [simp]: fixes x :: int shows \"x AND NOT x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND NOT x = 0", "by simp"], ["", "lemma int_nand_same_middle: fixes x :: int shows \"x AND y AND NOT x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND y AND NOT x = 0", "by (simp add: bit_eq_iff bit_and_iff bit_not_iff)"], ["", "lemma and_xor_dist: fixes x :: int shows\n  \"x AND (y XOR z) = (x AND y) XOR (x AND z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND (y XOR z) = x AND y XOR x AND z", "by (fact bit.conj_xor_distrib)"], ["", "lemma int_and_lt0 [simp]:\n  \\<open>x AND y < 0 \\<longleftrightarrow> x < 0 \\<and> y < 0\\<close> for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x AND y < 0) = (x < 0 \\<and> y < 0)", "by (fact and_negative_int_iff)"], ["", "lemma int_and_ge0 [simp]:\n  \\<open>x AND y \\<ge> 0 \\<longleftrightarrow> x \\<ge> 0 \\<or> y \\<ge> 0\\<close> for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> x AND y) = (0 \\<le> x \\<or> 0 \\<le> y)", "by (fact and_nonnegative_int_iff)"], ["", "lemma int_and_1: fixes x :: int shows \"x AND 1 = x mod 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND 1 = x mod 2", "by (fact and_one_eq)"], ["", "lemma int_1_and: fixes x :: int shows \"1 AND x = x mod 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 AND x = x mod 2", "by (fact one_and_eq)"], ["", "lemma int_or_lt0 [simp]:\n  \\<open>x OR y < 0 \\<longleftrightarrow> x < 0 \\<or> y < 0\\<close> for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x OR y < 0) = (x < 0 \\<or> y < 0)", "by (fact or_negative_int_iff)"], ["", "lemma int_or_ge0 [simp]:\n  \\<open>x OR y \\<ge> 0 \\<longleftrightarrow> x \\<ge> 0 \\<and> y \\<ge> 0\\<close> for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> x OR y) = (0 \\<le> x \\<and> 0 \\<le> y)", "by (fact or_nonnegative_int_iff)"], ["", "lemma int_xor_lt0 [simp]:\n  \\<open>x XOR y < 0 \\<longleftrightarrow> (x < 0) \\<noteq> (y < 0)\\<close> for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x XOR y < 0) = ((x < 0) \\<noteq> (y < 0))", "by (fact xor_negative_int_iff)"], ["", "lemma int_xor_ge0 [simp]:\n  \\<open>x XOR y \\<ge> 0 \\<longleftrightarrow> (x \\<ge> 0 \\<longleftrightarrow> y \\<ge> 0)\\<close> for x y :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> x XOR y) = ((0 \\<le> x) = (0 \\<le> y))", "by (fact xor_nonnegative_int_iff)"], ["", "lemma even_conv_AND:\n  \\<open>even i \\<longleftrightarrow> i AND 1 = 0\\<close> for i :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. even i = (i AND 1 = 0)", "by (simp add: and_one_eq mod2_eq_if)"], ["", "lemma bin_last_conv_AND:\n  \"bin_last i \\<longleftrightarrow> i AND 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd i = (i AND 1 \\<noteq> 0)", "by (simp add: and_one_eq mod2_eq_if)"], ["", "lemma bitval_bin_last:\n  \"of_bool (bin_last i) = i AND 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bool (odd i) = i AND 1", "by (simp add: and_one_eq mod2_eq_if)"], ["", "lemma bin_sign_and:\n  \"bin_sign (i AND j) = - (bin_sign i * bin_sign j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sign (i AND j) = - (bin_sign i * bin_sign j)", "by(simp add: bin_sign_def)"], ["", "lemma int_not_neg_numeral: \"NOT (- numeral n) = (Num.sub n num.One :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT (- numeral n) = neg_numeral_class.sub n num.One", "by(simp add: int_not_def)"], ["", "lemma int_neg_numeral_pOne_conv_not: \"- numeral (n + num.One) = (NOT (numeral n) :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - numeral (n + num.One) = NOT (numeral n)", "by(simp add: int_not_def)"], ["", "subsection \\<open>Setting and clearing bits\\<close>"], ["", "lemma int_shiftl_BIT: fixes x :: int\n  shows int_shiftl0 [simp]: \"x << 0 = x\"\n  and int_shiftl_Suc [simp]: \"x << Suc n = 2 * (x << n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x << 0 = x &&& x << Suc n = 2 * (x << n)", "by (auto simp add: shiftl_int_def)"], ["", "lemma int_0_shiftl [simp]: \"0 << n = (0 :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 << n = 0", "by(induct n) simp_all"], ["", "lemma bin_last_shiftl: \"bin_last (x << n) \\<longleftrightarrow> n = 0 \\<and> bin_last x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (x << n) = (n = 0 \\<and> odd x)", "by(cases n)(simp_all)"], ["", "lemma bin_rest_shiftl: \"bin_rest (x << n) = (if n > 0 then x << (n - 1) else bin_rest x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x << n) div 2 = (if 0 < n then x << n - 1 else x div 2)", "by(cases n)(simp_all)"], ["", "lemma bin_nth_shiftl [simp]: \"bin_nth (x << n) m \\<longleftrightarrow> n \\<le> m \\<and> bin_nth x (m - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (x << n) m = (n \\<le> m \\<and> bit x (m - n))", "by (simp add: bit_push_bit_iff_int shiftl_eq_push_bit)"], ["", "lemma bin_last_shiftr: \"odd (x >> n) \\<longleftrightarrow> x !! n\" for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (x >> n) = x !! n", "by (simp add: shiftr_eq_drop_bit bit_iff_odd_drop_bit)"], ["", "lemma bin_rest_shiftr [simp]: \"bin_rest (x >> n) = x >> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x >> n) div 2 = x >> Suc n", "by (simp add: bit_eq_iff shiftr_eq_drop_bit drop_bit_Suc bit_drop_bit_eq drop_bit_half)"], ["", "lemma bin_nth_shiftr [simp]: \"bin_nth (x >> n) m = bin_nth x (n + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (x >> n) m = bit x (n + m)", "by (simp add: shiftr_eq_drop_bit bit_drop_bit_eq)"], ["", "lemma bin_nth_conv_AND:\n  fixes x :: int shows\n  \"bin_nth x n \\<longleftrightarrow> x AND (1 << n) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n = (x AND (1 << n) \\<noteq> 0)", "by (simp add: bit_eq_iff)\n    (auto simp add: shiftl_eq_push_bit bit_and_iff bit_push_bit_iff bit_exp_iff)"], ["", "lemma int_shiftl_numeral [simp]:\n  \"(numeral w :: int) << numeral w' = numeral (num.Bit0 w) << pred_numeral w'\"\n  \"(- numeral w :: int) << numeral w' = - numeral (num.Bit0 w) << pred_numeral w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral w << numeral w' = numeral (num.Bit0 w) << pred_numeral w' &&&\n    - numeral w << numeral w' = - numeral (num.Bit0 w) << pred_numeral w'", "by(simp_all add: numeral_eq_Suc shiftl_int_def)\n  (metis add_One mult_inc semiring_norm(11) semiring_norm(13) semiring_norm(2) semiring_norm(6) semiring_norm(87))+"], ["", "lemma int_shiftl_One_numeral [simp]:\n  \"(1 :: int) << numeral w = 2 << pred_numeral w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 << numeral w = 2 << pred_numeral w", "using int_shiftl_numeral [of Num.One w]"], ["proof (prove)\nusing this:\n  Numeral1 << numeral w = 2 << pred_numeral w\n  - Numeral1 << numeral w = - 2 << pred_numeral w\n\ngoal (1 subgoal):\n 1. 1 << numeral w = 2 << pred_numeral w", "by simp"], ["", "lemma shiftl_ge_0 [simp]: fixes i :: int shows \"i << n \\<ge> 0 \\<longleftrightarrow> i \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> i << n) = (0 \\<le> i)", "by(induct n) simp_all"], ["", "lemma shiftl_lt_0 [simp]: fixes i :: int shows \"i << n < 0 \\<longleftrightarrow> i < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i << n < 0) = (i < 0)", "by (metis not_le shiftl_ge_0)"], ["", "lemma int_shiftl_test_bit: \"(n << i :: int) !! m \\<longleftrightarrow> m \\<ge> i \\<and> n !! (m - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n << i) !! m = (i \\<le> m \\<and> n !! (m - i))", "by simp"], ["", "lemma int_0shiftr [simp]: \"(0 :: int) >> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 >> x = 0", "by(simp add: shiftr_int_def)"], ["", "lemma int_minus1_shiftr [simp]: \"(-1 :: int) >> x = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 >> x = - 1", "by(simp add: shiftr_int_def div_eq_minus1)"], ["", "lemma int_shiftr_ge_0 [simp]: fixes i :: int shows \"i >> n \\<ge> 0 \\<longleftrightarrow> i \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> i >> n) = (0 \\<le> i)", "by (simp add: shiftr_eq_drop_bit)"], ["", "lemma int_shiftr_lt_0 [simp]: fixes i :: int shows \"i >> n < 0 \\<longleftrightarrow> i < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i >> n < 0) = (i < 0)", "by (metis int_shiftr_ge_0 not_less)"], ["", "lemma int_shiftr_numeral [simp]:\n  \"(1 :: int) >> numeral w' = 0\"\n  \"(numeral num.One :: int) >> numeral w' = 0\"\n  \"(numeral (num.Bit0 w) :: int) >> numeral w' = numeral w >> pred_numeral w'\"\n  \"(numeral (num.Bit1 w) :: int) >> numeral w' = numeral w >> pred_numeral w'\"\n  \"(- numeral (num.Bit0 w) :: int) >> numeral w' = - numeral w >> pred_numeral w'\"\n  \"(- numeral (num.Bit1 w) :: int) >> numeral w' = - numeral (Num.inc w) >> pred_numeral w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 >> numeral w' = 0 &&&\n     Numeral1 >> numeral w' = 0 &&&\n     numeral (num.Bit0 w) >> numeral w' = numeral w >> pred_numeral w') &&&\n    numeral (num.Bit1 w) >> numeral w' = numeral w >> pred_numeral w' &&&\n    - numeral (num.Bit0 w) >> numeral w' =\n    - numeral w >> pred_numeral w' &&&\n    - numeral (num.Bit1 w) >> numeral w' =\n    - numeral (Num.inc w) >> pred_numeral w'", "by (simp_all add: shiftr_eq_drop_bit numeral_eq_Suc add_One drop_bit_Suc)"], ["", "lemma int_shiftr_numeral_Suc0 [simp]:\n  \"(1 :: int) >> Suc 0 = 0\"\n  \"(numeral num.One :: int) >> Suc 0 = 0\"\n  \"(numeral (num.Bit0 w) :: int) >> Suc 0 = numeral w\"\n  \"(numeral (num.Bit1 w) :: int) >> Suc 0 = numeral w\"\n  \"(- numeral (num.Bit0 w) :: int) >> Suc 0 = - numeral w\"\n  \"(- numeral (num.Bit1 w) :: int) >> Suc 0 = - numeral (Num.inc w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 >> Suc 0 = 0 &&&\n     Numeral1 >> Suc 0 = 0 &&&\n     numeral (num.Bit0 w) >> Suc 0 = numeral w) &&&\n    numeral (num.Bit1 w) >> Suc 0 = numeral w &&&\n    - numeral (num.Bit0 w) >> Suc 0 = - numeral w &&&\n    - numeral (num.Bit1 w) >> Suc 0 = - numeral (Num.inc w)", "by (simp_all add: shiftr_eq_drop_bit drop_bit_Suc add_One)"], ["", "lemma bin_nth_minus_p2:\n  assumes sign: \"bin_sign x = 0\"\n  and y: \"y = 1 << n\"\n  and m: \"m < n\"\n  and x: \"x < y\"\n  shows \"bin_nth (x - y) m = bin_nth x m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (x - y) m = bit x m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bit (x - y) m = bit x m", "from sign y x"], ["proof (chain)\npicking this:\n  bin_sign x = 0\n  y = 1 << n\n  x < y", "have \\<open>x \\<ge> 0\\<close> and \\<open>y = 2 ^ n\\<close> and \\<open>x < 2 ^ n\\<close>"], ["proof (prove)\nusing this:\n  bin_sign x = 0\n  y = 1 << n\n  x < y\n\ngoal (1 subgoal):\n 1. 0 \\<le> x &&& y = 2 ^ n &&& x < 2 ^ n", "by (simp_all add: bin_sign_def shiftl_eq_push_bit push_bit_eq_mult split: if_splits)"], ["proof (state)\nthis:\n  0 \\<le> x\n  y = 2 ^ n\n  x < 2 ^ n\n\ngoal (1 subgoal):\n 1. bit (x - y) m = bit x m", "from \\<open>0 \\<le> x\\<close> \\<open>x < 2 ^ n\\<close> \\<open>m < n\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  x < 2 ^ n\n  m < n", "have \\<open>bit x m \\<longleftrightarrow> bit (x - 2 ^ n) m\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x < 2 ^ n\n  m < n\n\ngoal (1 subgoal):\n 1. bit x m = bit (x - 2 ^ n) m", "proof (induction m arbitrary: x n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x n.\n       \\<lbrakk>0 \\<le> x; x < 2 ^ n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> bit x 0 = bit (x - 2 ^ n) 0\n 2. \\<And>m x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>0 \\<le> x; x < 2 ^ n; m < n\\<rbrakk>\n                   \\<Longrightarrow> bit x m = bit (x - 2 ^ n) m;\n        0 \\<le> x; x < 2 ^ n; Suc m < n\\<rbrakk>\n       \\<Longrightarrow> bit x (Suc m) = bit (x - 2 ^ n) (Suc m)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> x\n  x < 2 ^ n\n  0 < n\n\ngoal (2 subgoals):\n 1. \\<And>x n.\n       \\<lbrakk>0 \\<le> x; x < 2 ^ n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> bit x 0 = bit (x - 2 ^ n) 0\n 2. \\<And>m x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>0 \\<le> x; x < 2 ^ n; m < n\\<rbrakk>\n                   \\<Longrightarrow> bit x m = bit (x - 2 ^ n) m;\n        0 \\<le> x; x < 2 ^ n; Suc m < n\\<rbrakk>\n       \\<Longrightarrow> bit x (Suc m) = bit (x - 2 ^ n) (Suc m)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  x < 2 ^ n\n  0 < n", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x < 2 ^ n\n  0 < n\n\ngoal (1 subgoal):\n 1. bit x 0 = bit (x - 2 ^ n) 0", "by simp"], ["proof (state)\nthis:\n  bit x 0 = bit (x - 2 ^ n) 0\n\ngoal (1 subgoal):\n 1. \\<And>m x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>0 \\<le> x; x < 2 ^ n; m < n\\<rbrakk>\n                   \\<Longrightarrow> bit x m = bit (x - 2 ^ n) m;\n        0 \\<le> x; x < 2 ^ n; Suc m < n\\<rbrakk>\n       \\<Longrightarrow> bit x (Suc m) = bit (x - 2 ^ n) (Suc m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>0 \\<le> x; x < 2 ^ n; m < n\\<rbrakk>\n                   \\<Longrightarrow> bit x m = bit (x - 2 ^ n) m;\n        0 \\<le> x; x < 2 ^ n; Suc m < n\\<rbrakk>\n       \\<Longrightarrow> bit x (Suc m) = bit (x - 2 ^ n) (Suc m)", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x; ?x < 2 ^ ?n; m < ?n\\<rbrakk>\n  \\<Longrightarrow> bit ?x m = bit (?x - 2 ^ ?n) m\n  0 \\<le> x\n  x < 2 ^ n\n  Suc m < n\n\ngoal (1 subgoal):\n 1. \\<And>m x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>0 \\<le> x; x < 2 ^ n; m < n\\<rbrakk>\n                   \\<Longrightarrow> bit x m = bit (x - 2 ^ n) m;\n        0 \\<le> x; x < 2 ^ n; Suc m < n\\<rbrakk>\n       \\<Longrightarrow> bit x (Suc m) = bit (x - 2 ^ n) (Suc m)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x; ?x < 2 ^ ?n; m < ?n\\<rbrakk>\n  \\<Longrightarrow> bit ?x m = bit (?x - 2 ^ ?n) m\n  0 \\<le> x\n  x < 2 ^ n\n  Suc m < n\n\ngoal (1 subgoal):\n 1. \\<And>m x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>0 \\<le> x; x < 2 ^ n; m < n\\<rbrakk>\n                   \\<Longrightarrow> bit x m = bit (x - 2 ^ n) m;\n        0 \\<le> x; x < 2 ^ n; Suc m < n\\<rbrakk>\n       \\<Longrightarrow> bit x (Suc m) = bit (x - 2 ^ n) (Suc m)", "define q where \\<open>q = n - 1\\<close>"], ["proof (state)\nthis:\n  q = n - 1\n\ngoal (1 subgoal):\n 1. \\<And>m x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>0 \\<le> x; x < 2 ^ n; m < n\\<rbrakk>\n                   \\<Longrightarrow> bit x m = bit (x - 2 ^ n) m;\n        0 \\<le> x; x < 2 ^ n; Suc m < n\\<rbrakk>\n       \\<Longrightarrow> bit x (Suc m) = bit (x - 2 ^ n) (Suc m)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?x; ?x < 2 ^ ?n; m < ?n\\<rbrakk>\n  \\<Longrightarrow> bit ?x m = bit (?x - 2 ^ ?n) m\n  0 \\<le> x\n  x < 2 ^ n\n  Suc m < n\n  q = n - 1", "have n: \\<open>n = Suc q\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x < 2 ^ ?n; m < ?n\\<rbrakk>\n  \\<Longrightarrow> bit ?x m = bit (?x - 2 ^ ?n) m\n  0 \\<le> x\n  x < 2 ^ n\n  Suc m < n\n  q = n - 1\n\ngoal (1 subgoal):\n 1. n = Suc q", "by simp"], ["proof (state)\nthis:\n  n = Suc q\n\ngoal (1 subgoal):\n 1. \\<And>m x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>0 \\<le> x; x < 2 ^ n; m < n\\<rbrakk>\n                   \\<Longrightarrow> bit x m = bit (x - 2 ^ n) m;\n        0 \\<le> x; x < 2 ^ n; Suc m < n\\<rbrakk>\n       \\<Longrightarrow> bit x (Suc m) = bit (x - 2 ^ n) (Suc m)", "have \\<open>(x - 2 ^ Suc q) div 2 = x div 2 - 2 ^ q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - 2 ^ Suc q) div 2 = x div 2 - 2 ^ q", "by simp"], ["proof (state)\nthis:\n  (x - 2 ^ Suc q) div 2 = x div 2 - 2 ^ q\n\ngoal (1 subgoal):\n 1. \\<And>m x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>0 \\<le> x; x < 2 ^ n; m < n\\<rbrakk>\n                   \\<Longrightarrow> bit x m = bit (x - 2 ^ n) m;\n        0 \\<le> x; x < 2 ^ n; Suc m < n\\<rbrakk>\n       \\<Longrightarrow> bit x (Suc m) = bit (x - 2 ^ n) (Suc m)", "moreover"], ["proof (state)\nthis:\n  (x - 2 ^ Suc q) div 2 = x div 2 - 2 ^ q\n\ngoal (1 subgoal):\n 1. \\<And>m x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>0 \\<le> x; x < 2 ^ n; m < n\\<rbrakk>\n                   \\<Longrightarrow> bit x m = bit (x - 2 ^ n) m;\n        0 \\<le> x; x < 2 ^ n; Suc m < n\\<rbrakk>\n       \\<Longrightarrow> bit x (Suc m) = bit (x - 2 ^ n) (Suc m)", "from Suc.IH [of \\<open>x div 2\\<close> q] Suc.prems"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> x div 2; x div 2 < 2 ^ q; m < q\\<rbrakk>\n  \\<Longrightarrow> bit (x div 2) m = bit (x div 2 - 2 ^ q) m\n  0 \\<le> x\n  x < 2 ^ n\n  Suc m < n", "have \\<open>bit (x div 2) m \\<longleftrightarrow> bit (x div 2 - 2 ^ q) m\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> x div 2; x div 2 < 2 ^ q; m < q\\<rbrakk>\n  \\<Longrightarrow> bit (x div 2) m = bit (x div 2 - 2 ^ q) m\n  0 \\<le> x\n  x < 2 ^ n\n  Suc m < n\n\ngoal (1 subgoal):\n 1. bit (x div 2) m = bit (x div 2 - 2 ^ q) m", "by (simp add: n)"], ["proof (state)\nthis:\n  bit (x div 2) m = bit (x div 2 - 2 ^ q) m\n\ngoal (1 subgoal):\n 1. \\<And>m x n.\n       \\<lbrakk>\\<And>x n.\n                   \\<lbrakk>0 \\<le> x; x < 2 ^ n; m < n\\<rbrakk>\n                   \\<Longrightarrow> bit x m = bit (x - 2 ^ n) m;\n        0 \\<le> x; x < 2 ^ n; Suc m < n\\<rbrakk>\n       \\<Longrightarrow> bit x (Suc m) = bit (x - 2 ^ n) (Suc m)", "ultimately"], ["proof (chain)\npicking this:\n  (x - 2 ^ Suc q) div 2 = x div 2 - 2 ^ q\n  bit (x div 2) m = bit (x div 2 - 2 ^ q) m", "show ?case"], ["proof (prove)\nusing this:\n  (x - 2 ^ Suc q) div 2 = x div 2 - 2 ^ q\n  bit (x div 2) m = bit (x div 2 - 2 ^ q) m\n\ngoal (1 subgoal):\n 1. bit x (Suc m) = bit (x - 2 ^ n) (Suc m)", "by (simp add: bit_Suc n)"], ["proof (state)\nthis:\n  bit x (Suc m) = bit (x - 2 ^ n) (Suc m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bit x m = bit (x - 2 ^ n) m\n\ngoal (1 subgoal):\n 1. bit (x - y) m = bit x m", "with \\<open>y = 2 ^ n\\<close>"], ["proof (chain)\npicking this:\n  y = 2 ^ n\n  bit x m = bit (x - 2 ^ n) m", "show ?thesis"], ["proof (prove)\nusing this:\n  y = 2 ^ n\n  bit x m = bit (x - 2 ^ n) m\n\ngoal (1 subgoal):\n 1. bit (x - y) m = bit x m", "by simp"], ["proof (state)\nthis:\n  bit (x - y) m = bit x m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_clr_conv_NAND:\n  \"bin_sc n False i = i AND NOT (1 << n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sc n False i = i AND NOT (1 << n)", "by (induct n arbitrary: i) (rule bin_rl_eqI; simp)+"], ["", "lemma bin_set_conv_OR:\n  \"bin_sc n True i = i OR (1 << n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sc n True i = i OR (1 << n)", "by (induct n arbitrary: i) (rule bin_rl_eqI; simp)+"], ["", "subsection \\<open>More lemmas on words\\<close>"], ["", "lemma word_rcat_eq:\n  \\<open>word_rcat ws = word_of_int (bin_rcat (LENGTH('a::len)) (map uint ws))\\<close>\n  for ws :: \\<open>'a::len word list\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_rcat ws = word_of_int (bin_rcat LENGTH('a) (map uint ws))", "apply (simp add: word_rcat_def bin_rcat_def rev_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_int (horner_sum uint (2 ^ LENGTH('a)) (rev ws)) =\n    word_of_int\n     (horner_sum (take_bit LENGTH('a)) (2 ^ LENGTH('a)) (map uint (rev ws)))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ws.\n       take_bit LENGTH('b)\n        (horner_sum (take_bit LENGTH('a)) (2 ^ LENGTH('a)) (rev ws)) =\n       take_bit LENGTH('b)\n        (horner_sum (take_bit LENGTH('a)) (2 ^ LENGTH('a))\n          (map (take_bit LENGTH('a)) (rev ws)))", "apply (simp add: horner_sum_foldr foldr_map comp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sign_uint_Pls [simp]: \"bin_sign (uint x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sign (uint x) = 0", "by (simp add: sign_Pls_ge_0)"], ["", "lemmas bin_log_bintrs = bin_trunc_not bin_trunc_xor bin_trunc_and bin_trunc_or\n\n\\<comment> \\<open>following definitions require both arithmetic and bit-wise word operations\\<close>\n\n\\<comment> \\<open>to get \\<open>word_no_log_defs\\<close> from \\<open>word_log_defs\\<close>, using \\<open>bin_log_bintrs\\<close>\\<close>"], ["", "lemmas wils1 = bin_log_bintrs [THEN word_of_int_eq_iff [THEN iffD2],\n  folded uint_word_of_int_eq, THEN eq_reflection]\n\n\\<comment> \\<open>the binary operations only\\<close>"], ["", "(* BH: why is this needed? *)"], ["", "lemmas word_log_binary_defs =\n  word_and_def word_or_def word_xor_def"], ["", "lemma setBit_no [simp]: \"setBit (numeral bin) n = word_of_int (bin_sc n True (numeral bin))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setBit (numeral bin) n = word_of_int (bin_sc n True (numeral bin))", "by transfer (simp add: bin_sc_eq)"], ["", "lemma clearBit_no [simp]:\n  \"clearBit (numeral bin) n = word_of_int (bin_sc n False (numeral bin))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clearBit (numeral bin) n = word_of_int (bin_sc n False (numeral bin))", "by transfer (simp add: bin_sc_eq)"], ["", "lemma eq_mod_iff: \"0 < n \\<Longrightarrow> b = b mod n \\<longleftrightarrow> 0 \\<le> b \\<and> b < n\"\n  for b n :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> (b = b mod n) = (0 \\<le> b \\<and> b < n)", "by auto (metis pos_mod_conj)+"], ["", "lemma split_uint_lem: \"bin_split n (uint w) = (a, b) \\<Longrightarrow>\n    a = take_bit (LENGTH('a) - n) a \\<and> b = take_bit (LENGTH('a)) b\"\n  for w :: \"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_split n (uint w) = (a, b) \\<Longrightarrow>\n    a = take_bit (LENGTH('a) - n) a \\<and> b = take_bit LENGTH('a) b", "by transfer (simp add: drop_bit_take_bit ac_simps)\n\n\\<comment> \\<open>limited hom result\\<close>"], ["", "lemma word_cat_hom:\n  \"LENGTH('a::len) \\<le> LENGTH('b::len) + LENGTH('c::len) \\<Longrightarrow>\n    (word_cat (word_of_int w :: 'b word) (b :: 'c word) :: 'a word) =\n    word_of_int (bin_cat w (size b) (uint b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> LENGTH('b) + LENGTH('c) \\<Longrightarrow>\n    word_cat (word_of_int w) b =\n    word_of_int (concat_bit (size b) (uint b) w)", "by transfer (simp add: take_bit_concat_bit_eq)"], ["", "lemma bintrunc_shiftl:\n  \"take_bit n (m << i) = take_bit (n - i) m << i\"\n  for m :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n (m << i) = take_bit (n - i) m << i", "by (rule bit_eqI) (auto simp add: bit_take_bit_iff)"], ["", "lemma uint_shiftl:\n  \"uint (n << i) = take_bit (size n) (uint n << i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint (n << i) = take_bit (size n) (uint n << i)", "by transfer (simp add: push_bit_take_bit shiftl_eq_push_bit)"], ["", "lemma bin_mask_conv_pow2:\n  \"mask n = 2 ^ n - (1 :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask n = 2 ^ n - 1", "by (fact mask_eq_exp_minus_1)"], ["", "lemma bin_mask_ge0: \"mask n \\<ge> (0 :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> mask n", "by (fact mask_nonnegative_int)"], ["", "lemma and_bin_mask_conv_mod: \"x AND mask n = x mod 2 ^ n\"\n  for x :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND mask n = x mod 2 ^ n", "by (simp flip: take_bit_eq_mod add: take_bit_eq_mask)"], ["", "lemma bin_mask_numeral:\n  \"mask (numeral n) = (1 :: int) + 2 * mask (pred_numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (numeral n) = 1 + 2 * mask (pred_numeral n)", "by (fact mask_numeral)"], ["", "lemma bin_nth_mask [simp]: \"bit (mask n :: int) i \\<longleftrightarrow> i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit (mask n) i = (i < n)", "by (simp add: bit_mask_iff)"], ["", "lemma bin_sign_mask [simp]: \"bin_sign (mask n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_sign (mask n) = 0", "by (simp add: bin_sign_def bin_mask_conv_pow2)"], ["", "lemma bin_mask_p1_conv_shift: \"mask n + 1 = (1 :: int) << n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask n + 1 = 1 << n", "by (simp add: bin_mask_conv_pow2 shiftl_int_def)"], ["", "lemma sbintrunc_eq_in_range:\n  \"(sbintrunc n x = x) = (x \\<in> range (sbintrunc n))\"\n  \"(x = sbintrunc n x) = (x \\<in> range (sbintrunc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (signed_take_bit n x = x) = (x \\<in> range (signed_take_bit n)) &&&\n    (x = signed_take_bit n x) = (x \\<in> range (signed_take_bit n))", "apply (simp_all add: image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (signed_take_bit n x = x) = (\\<exists>xa. x = signed_take_bit n xa)\n 2. (x = signed_take_bit n x) = (\\<exists>xa. x = signed_take_bit n xa)", "apply (metis sbintrunc_sbintrunc)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sbintrunc_If:\n  \"- 3 * (2 ^ n) \\<le> x \\<and> x < 3 * (2 ^ n)\n    \\<Longrightarrow> sbintrunc n x = (if x < - (2 ^ n) then x + 2 * (2 ^ n)\n        else if x \\<ge> 2 ^ n then x - 2 * (2 ^ n) else x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 3 * 2 ^ n \\<le> x \\<and> x < 3 * 2 ^ n \\<Longrightarrow>\n    signed_take_bit n x =\n    (if x < - (2 ^ n) then x + 2 * 2 ^ n\n     else if 2 ^ n \\<le> x then x - 2 * 2 ^ n else x)", "apply (simp add: no_sbintr_alt2, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>- (3 * 2 ^ n) \\<le> x; x < 3 * 2 ^ n; 2 ^ n \\<le> x\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n + (x + 2 ^ n) mod (2 * 2 ^ n) = x\n 2. \\<lbrakk>- (3 * 2 ^ n) \\<le> x; x < 3 * 2 ^ n; \\<not> 2 ^ n \\<le> x;\n     x < - (2 ^ n)\\<rbrakk>\n    \\<Longrightarrow> (x + 2 ^ n) mod (2 * 2 ^ n) = 3 * 2 ^ n + x", "apply (simp add: mod_pos_geq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- (3 * 2 ^ n) \\<le> x; x < 3 * 2 ^ n; \\<not> 2 ^ n \\<le> x;\n     x < - (2 ^ n)\\<rbrakk>\n    \\<Longrightarrow> (x + 2 ^ n) mod (2 * 2 ^ n) = 3 * 2 ^ n + x", "apply (subst mod_add_self1[symmetric], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sint_range':\n  \\<open>- (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x \\<and> sint x < 2 ^ (LENGTH('a) - Suc 0)\\<close>\n  for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x \\<and>\n    sint x < 2 ^ (LENGTH('a) - Suc 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       - (2 ^ (LENGTH('a) - Suc 0))\n       \\<le> signed_take_bit (LENGTH('a) - Suc 0) x \\<and>\n       signed_take_bit (LENGTH('a) - Suc 0) x < 2 ^ (LENGTH('a) - Suc 0)", "using sbintr_ge sbintr_lt"], ["proof (prove)\nusing this:\n  - (2 ^ ?n) \\<le> signed_take_bit ?n ?w\n  signed_take_bit ?n ?w < 2 ^ ?n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       - (2 ^ (LENGTH('a) - Suc 0))\n       \\<le> signed_take_bit (LENGTH('a) - Suc 0) x \\<and>\n       signed_take_bit (LENGTH('a) - Suc 0) x < 2 ^ (LENGTH('a) - Suc 0)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma signed_arith_eq_checks_to_ord:\n  \"(sint a + sint b = sint (a + b ))\n    = ((a <=s a + b) = (0 <=s b))\"\n  \"(sint a - sint b = sint (a - b ))\n    = ((0 <=s a - b) = (b <=s a))\"\n  \"(- sint a = sint (- a)) = (0 <=s (- a) = (a <=s 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sint a + sint b = sint (a + b)) = ((a \\<le>s a + b) = (0 \\<le>s b)) &&&\n    (sint a - sint b = sint (a - b)) = ((0 \\<le>s a - b) = (b \\<le>s a)) &&&\n    (- sint a = sint (- a)) = ((0 \\<le>s - a) = (a \\<le>s 0))", "using sint_range'[where x=a] sint_range'[where x=b]"], ["proof (prove)\nusing this:\n  - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint a \\<and>\n  sint a < 2 ^ (LENGTH('a) - Suc 0)\n  - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint b \\<and>\n  sint b < 2 ^ (LENGTH('a) - Suc 0)\n\ngoal (1 subgoal):\n 1. (sint a + sint b = sint (a + b)) = ((a \\<le>s a + b) = (0 \\<le>s b)) &&&\n    (sint a - sint b = sint (a - b)) = ((0 \\<le>s a - b) = (b \\<le>s a)) &&&\n    (- sint a = sint (- a)) = ((0 \\<le>s - a) = (a \\<le>s 0))", "by (simp_all add: sint_word_ariths word_sle_eq word_sless_alt sbintrunc_If)"], ["", "lemma signed_mult_eq_checks_double_size:\n  assumes mult_le: \"(2 ^ (len_of TYPE ('a) - 1) + 1) ^ 2 \\<le> (2 :: int) ^ (len_of TYPE ('b) - 1)\"\n           and le: \"2 ^ (LENGTH('a) - 1) \\<le> (2 :: int) ^ (len_of TYPE ('b) - 1)\"\n  shows \"(sint (a :: 'a :: len word) * sint b = sint (a * b))\n       = (scast a * scast b = (scast (a * b) :: 'b :: len word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sint a * sint b = sint (a * b)) = (scast a * scast b = scast (a * b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (sint a * sint b = sint (a * b)) = (scast a * scast b = scast (a * b))", "have P: \"sbintrunc (size a - 1) (sint a * sint b) \\<in> range (sbintrunc (size a - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_take_bit (size a - 1) (sint a * sint b)\n    \\<in> range (signed_take_bit (size a - 1))", "by simp"], ["proof (state)\nthis:\n  signed_take_bit (size a - 1) (sint a * sint b)\n  \\<in> range (signed_take_bit (size a - 1))\n\ngoal (1 subgoal):\n 1. (sint a * sint b = sint (a * b)) = (scast a * scast b = scast (a * b))", "have abs: \"!! x :: 'a word. abs (sint x) < 2 ^ (size a - 1) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<bar>sint x\\<bar> < 2 ^ (size a - 1) + 1", "apply (cut_tac x=x in sint_range')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       - (2 ^ (LENGTH('a) - Suc 0)) \\<le> sint x \\<and>\n       sint x < 2 ^ (LENGTH('a) - Suc 0) \\<Longrightarrow>\n       \\<bar>sint x\\<bar> < 2 ^ (size a - 1) + 1", "apply (simp add: abs_le_iff word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<bar>sint ?x\\<bar> < 2 ^ (size a - 1) + 1\n\ngoal (1 subgoal):\n 1. (sint a * sint b = sint (a * b)) = (scast a * scast b = scast (a * b))", "have abs_ab: \"abs (sint a * sint b) < 2 ^ (LENGTH('b) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>sint a * sint b\\<bar> < 2 ^ (LENGTH('b) - 1)", "using abs_mult_less[OF abs[where x=a] abs[where x=b]] mult_le"], ["proof (prove)\nusing this:\n  \\<bar>sint a\\<bar> * \\<bar>sint b\\<bar>\n  < (2 ^ (size a - 1) + 1) * (2 ^ (size a - 1) + 1)\n  (2 ^ (LENGTH('a) - 1) + 1)\\<^sup>2 \\<le> 2 ^ (LENGTH('b) - 1)\n\ngoal (1 subgoal):\n 1. \\<bar>sint a * sint b\\<bar> < 2 ^ (LENGTH('b) - 1)", "by (simp add: abs_mult power2_eq_square word_size)"], ["proof (state)\nthis:\n  \\<bar>sint a * sint b\\<bar> < 2 ^ (LENGTH('b) - 1)\n\ngoal (1 subgoal):\n 1. (sint a * sint b = sint (a * b)) = (scast a * scast b = scast (a * b))", "define r s where \\<open>r = LENGTH('a) - 1\\<close> \\<open>s = LENGTH('b) - 1\\<close>"], ["proof (state)\nthis:\n  r = LENGTH('a) - 1\n  s = LENGTH('b) - 1\n\ngoal (1 subgoal):\n 1. (sint a * sint b = sint (a * b)) = (scast a * scast b = scast (a * b))", "then"], ["proof (chain)\npicking this:\n  r = LENGTH('a) - 1\n  s = LENGTH('b) - 1", "have \\<open>LENGTH('a) = Suc r\\<close> \\<open>LENGTH('b) = Suc s\\<close>\n    \\<open>size a = Suc r\\<close> \\<open>size b = Suc r\\<close>"], ["proof (prove)\nusing this:\n  r = LENGTH('a) - 1\n  s = LENGTH('b) - 1\n\ngoal (1 subgoal):\n 1. (LENGTH('a) = Suc r &&& LENGTH('b) = Suc s) &&&\n    size a = Suc r &&& size b = Suc r", "by (simp_all add: word_size)"], ["proof (state)\nthis:\n  LENGTH('a) = Suc r\n  LENGTH('b) = Suc s\n  size a = Suc r\n  size b = Suc r\n\ngoal (1 subgoal):\n 1. (sint a * sint b = sint (a * b)) = (scast a * scast b = scast (a * b))", "then"], ["proof (chain)\npicking this:\n  LENGTH('a) = Suc r\n  LENGTH('b) = Suc s\n  size a = Suc r\n  size b = Suc r", "show ?thesis"], ["proof (prove)\nusing this:\n  LENGTH('a) = Suc r\n  LENGTH('b) = Suc s\n  size a = Suc r\n  size b = Suc r\n\ngoal (1 subgoal):\n 1. (sint a * sint b = sint (a * b)) = (scast a * scast b = scast (a * b))", "using P[unfolded range_sbintrunc] abs_ab le"], ["proof (prove)\nusing this:\n  LENGTH('a) = Suc r\n  LENGTH('b) = Suc s\n  size a = Suc r\n  size b = Suc r\n  signed_take_bit (size a - 1) (sint a * sint b)\n  \\<in> {i. - (2 ^ (size a - 1)) \\<le> i \\<and> i < 2 ^ (size a - 1)}\n  \\<bar>sint a * sint b\\<bar> < 2 ^ (LENGTH('b) - 1)\n  2 ^ (LENGTH('a) - 1) \\<le> 2 ^ (LENGTH('b) - 1)\n\ngoal (1 subgoal):\n 1. (sint a * sint b = sint (a * b)) = (scast a * scast b = scast (a * b))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LENGTH('a) = Suc r; LENGTH('b) = Suc s; size a = Suc r;\n     size b = Suc r; \\<bar>sint a * sint b\\<bar> < 2 ^ s; r \\<le> s;\n     - (2 ^ r) \\<le> signed_take_bit r (sint a * sint b);\n     signed_take_bit r (sint a * sint b) < 2 ^ r\\<rbrakk>\n    \\<Longrightarrow> (sint a * sint b = sint (a * b)) =\n                      (scast a * scast b = scast (a * b))", "apply (transfer fixing: r s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>LENGTH('a) = Suc r; LENGTH('b) = Suc s; LENGTH('a) = Suc r;\n        LENGTH('a) = Suc r;\n        \\<bar>signed_take_bit (LENGTH('a) - Suc 0) a *\n              signed_take_bit (LENGTH('a) - Suc 0) b\\<bar>\n        < 2 ^ s;\n        r \\<le> s;\n        - (2 ^ r)\n        \\<le> signed_take_bit r\n               (signed_take_bit (LENGTH('a) - Suc 0) a *\n                signed_take_bit (LENGTH('a) - Suc 0) b);\n        signed_take_bit r\n         (signed_take_bit (LENGTH('a) - Suc 0) a *\n          signed_take_bit (LENGTH('a) - Suc 0) b)\n        < 2 ^ r\\<rbrakk>\n       \\<Longrightarrow> (signed_take_bit (LENGTH('a) - Suc 0) a *\n                          signed_take_bit (LENGTH('a) - Suc 0) b =\n                          signed_take_bit (LENGTH('a) - Suc 0) (a * b)) =\n                         (take_bit LENGTH('b)\n                           (signed_take_bit (LENGTH('a) - Suc 0) a *\n                            signed_take_bit (LENGTH('a) - Suc 0) b) =\n                          take_bit LENGTH('b)\n                           (signed_take_bit (LENGTH('a) - Suc 0) (a * b)))", "apply (auto simp add: signed_take_bit_int_eq_self simp flip: signed_take_bit_eq_iff_take_bit_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (sint a * sint b = sint (a * b)) = (scast a * scast b = scast (a * b))\n\ngoal:\nNo subgoals!", "qed"], ["", "code_identifier\n  code_module Bits_Int \\<rightharpoonup>\n  (SML) Bit_Operations and (OCaml) Bit_Operations and (Haskell) Bit_Operations and (Scala) Bit_Operations"], ["", "end"]]}