{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Word_32.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma len32: \"len_of (x :: 32 itself) = 32\"", "lemma word_bits_conv[code]:\n  \"word_bits = 32\"", "lemma word_size_word_size_bits:\n  \"(word_size::nat) = 2 ^ word_size_bits\"", "lemma word_bits_word_size_conv:\n  \"word_bits = word_size * 8\"", "lemma ucast_8_32_inj:\n  \"inj (ucast ::  8 word \\<Rightarrow> 32 word)\"", "lemma upto_2_helper:\n  \"{0..<2 :: 32 word} = {0, 1}\"", "lemmas upper_bits_unset_is_l2p_32 = upper_bits_unset_is_l2p [where 'a=32, folded word_bits_def]", "lemmas le_2p_upper_bits_32 = le_2p_upper_bits [where 'a=32, folded word_bits_def]", "lemmas le2p_bits_unset_32 = le2p_bits_unset[where 'a=32, folded word_bits_def]", "lemma word_bits_len_of:\n  \"len_of TYPE (32) = word_bits\"", "lemmas unat_power_lower32' = unat_power_lower[where 'a=32]", "lemmas unat_power_lower32 [simp] = unat_power_lower32'[unfolded word_bits_len_of]", "lemmas word32_less_sub_le' = word_less_sub_le[where 'a = 32]", "lemmas word32_less_sub_le[simp] = word32_less_sub_le' [folded word_bits_def]", "lemma word_bits_size:\n  \"size (w::word32) = word_bits\"", "lemmas word32_power_less_1' = word_power_less_1[where 'a = 32]", "lemmas word32_power_less_1[simp] = word32_power_less_1'[folded word_bits_def]", "lemma of_nat32_0:\n  \"\\<lbrakk>of_nat n = (0::word32); n < 2 ^ word_bits\\<rbrakk> \\<Longrightarrow> n = 0\"", "lemma unat_mask_2_less_4:\n  \"unat (p && mask 2 :: word32) < 4\"", "lemmas unat_of_nat32' = unat_of_nat_eq[where 'a=32]", "lemmas unat_of_nat32 = unat_of_nat32'[unfolded word_bits_len_of]", "lemmas word_power_nonzero_32 = word_power_nonzero [where 'a=32, folded word_bits_def]", "lemmas unat_mult_simple = iffD1 [OF unat_mult_lem [where 'a = 32, unfolded word_bits_len_of]]", "lemmas div_power_helper_32 = div_power_helper [where 'a=32, folded word_bits_def]", "lemma n_less_word_bits:\n  \"(n < word_bits) = (n < 32)\"", "lemmas of_nat_less_pow_32 = of_nat_power [where 'a=32, folded word_bits_def]", "lemma lt_word_bits_lt_pow:\n  \"sz < word_bits \\<Longrightarrow> sz < 2 ^ word_bits\"", "lemma unat_less_word_bits:\n  fixes y :: word32\n  shows \"x < unat y \\<Longrightarrow> x < 2 ^ word_bits\"", "lemmas unat_mask_word32' = unat_mask[where 'a=32]", "lemmas unat_mask_word32 = unat_mask_word32'[folded word_bits_def]", "lemma unat_less_2p_word_bits:\n  \"unat (x :: 32 word) < 2 ^ word_bits\"", "lemma Suc_unat_mask_div:\n  \"Suc (unat (mask sz div word_size::word32)) = 2 ^ (min sz word_bits - 2)\"", "lemmas word32_minus_one_le' = word_minus_one_le[where 'a=32]", "lemmas word32_minus_one_le = word32_minus_one_le'[simplified]", "lemma ucast_not_helper:\n  fixes a::\"8 word\"\n  assumes a: \"a \\<noteq> 0xFF\"\n  shows \"ucast a \\<noteq> (0xFF::word32)\"", "lemma less_4_cases:\n  \"(x::word32) < 4 \\<Longrightarrow> x=0 \\<or> x=1 \\<or> x=2 \\<or> x=3\"", "lemma unat_ucast_8_32:\n  fixes x :: \"8 word\"\n  shows \"unat (ucast x :: word32) = unat x\"", "lemma if_then_1_else_0:\n  \"((if P then 1 else 0) = (0 :: word32)) = (\\<not> P)\"", "lemma if_then_0_else_1:\n  \"((if P then 0 else 1) = (0 :: word32)) = (P)\"", "lemmas if_then_simps = if_then_0_else_1 if_then_1_else_0", "lemma ucast_le_ucast_8_32:\n  \"(ucast x \\<le> (ucast y :: word32)) = (x \\<le> (y :: 8 word))\"", "lemma in_16_range:\n  \"0 \\<in> S \\<Longrightarrow> r \\<in> (\\<lambda>x. r + x * (16 :: word32)) ` S\"\n  \"n - 1 \\<in> S \\<Longrightarrow> (r + (16 * n - 16)) \\<in> (\\<lambda>x :: word32. r + x * 16) ` S\"", "lemma eq_2_32_0:\n  \"(2 ^ 32 :: word32) = 0\"", "lemma x_less_2_0_1:\n  fixes x :: word32 shows\n  \"x < 2 \\<Longrightarrow> x = 0 \\<or> x = 1\"", "lemmas mask_32_max_word  = max_word_mask [symmetric, where 'a=32, simplified]", "lemma of_nat32_n_less_equal_power_2:\n \"n < 32 \\<Longrightarrow> ((of_nat n)::32 word) < 2 ^ n\"", "lemma word_rsplit_0:\n  \"word_rsplit (0 :: word32) = [0, 0, 0, 0 :: 8 word]\"", "lemma unat_ucast_10_32 :\n  fixes x :: \"10 word\"\n  shows \"unat (ucast x :: word32) = unat x\"", "lemma bool_mask [simp]:\n  fixes x :: word32\n  shows \"(0 < x && 1) = (x && 1 = 1)\"", "lemma word32_bounds:\n  \"- (2 ^ (size (x :: word32) - 1)) = (-2147483648 :: int)\"\n  \"((2 ^ (size (x :: word32) - 1)) - 1) = (2147483647 :: int)\"\n  \"- (2 ^ (size (y :: 32 signed word) - 1)) = (-2147483648 :: int)\"\n  \"((2 ^ (size (y :: 32 signed word) - 1)) - 1) = (2147483647 :: int)\"", "lemma word_ge_min:\"sint (x::32 word) \\<ge> -2147483648\"", "lemmas signed_arith_ineq_checks_to_eq_word32'\n    = signed_arith_ineq_checks_to_eq[where 'a=32]\n      signed_arith_ineq_checks_to_eq[where 'a=\"32 signed\"]", "lemmas signed_arith_ineq_checks_to_eq_word32\n    = signed_arith_ineq_checks_to_eq_word32' [unfolded word32_bounds]", "lemmas signed_mult_eq_checks32_to_64'\n    = signed_mult_eq_checks_double_size[where 'a=32 and 'b=64]\n      signed_mult_eq_checks_double_size[where 'a=\"32 signed\" and 'b=64]", "lemmas signed_mult_eq_checks32_to_64 = signed_mult_eq_checks32_to_64'[simplified]", "lemmas sdiv_word32_max' = sdiv_word_max [where 'a=32] sdiv_word_max [where 'a=\"32 signed\"]", "lemmas sdiv_word32_max = sdiv_word32_max'[simplified word_size, simplified]", "lemmas sdiv_word32_min' = sdiv_word_min [where 'a=32] sdiv_word_min [where 'a=\"32 signed\"]", "lemmas sdiv_word32_min = sdiv_word32_min' [simplified word_size, simplified]", "lemmas sint32_of_int_eq' = sint_of_int_eq [where 'a=32]", "lemmas sint32_of_int_eq = sint32_of_int_eq' [simplified]", "lemma ucast_of_nats [simp]:\n  \"(ucast (of_nat x :: word32) :: sword32) = (of_nat x)\"\n  \"(ucast (of_nat x :: word32) :: 16 sword) = (of_nat x)\"\n  \"(ucast (of_nat x :: word32) :: 8 sword) = (of_nat x)\"\n  \"(ucast (of_nat x :: 16 word) :: 16 sword) = (of_nat x)\"\n  \"(ucast (of_nat x :: 16 word) :: 8 sword) = (of_nat x)\"\n  \"(ucast (of_nat x :: 8 word) :: 8 sword) = (of_nat x)\"", "lemmas signed_shift_guard_simpler_32'\n    = power_strict_increasing_iff[where b=\"2 :: nat\" and y=31]", "lemmas signed_shift_guard_simpler_32 = signed_shift_guard_simpler_32'[simplified]", "lemma word32_31_less:\n  \"31 < len_of TYPE (32 signed)\" \"31 > (0 :: nat)\"\n  \"31 < len_of TYPE (32)\" \"31 > (0 :: nat)\"", "lemmas signed_shift_guard_to_word_32\n    = signed_shift_guard_to_word[OF word32_31_less(1-2)]\n    signed_shift_guard_to_word[OF word32_31_less(3-4)]", "lemma le_step_down_word_3:\n  fixes x :: \"32 word\"\n  shows \"\\<lbrakk>x \\<le>  y; x \\<noteq> y; y < 2 ^ 32 - 1\\<rbrakk> \\<Longrightarrow> x \\<le> y - 1\"", "lemma shiftr_1:\n  \"(x::word32) >> 1 = 0 \\<Longrightarrow> x < 2\"", "lemma has_zero_byte:\n  \"~~ (((((v::word32) && 0x7f7f7f7f) + 0x7f7f7f7f) || v) || 0x7f7f7f7f) \\<noteq> 0\n    \\<Longrightarrow> v && 0xff000000 = 0 \\<or> v && 0xff0000 = 0 \\<or> v && 0xff00 = 0 \\<or> v && 0xff = 0\"", "lemma mask_step_down_32:\n  \\<open>\\<exists>x. mask x = b\\<close> if \\<open>b && 1 = 1\\<close>\n    and \\<open>\\<exists>x. x < 32 \\<and> mask x = b >> 1\\<close> for b :: \\<open>32word\\<close>", "lemma unat_of_int_32:\n  \"\\<lbrakk>i \\<ge> 0; i \\<le>2 ^ 31\\<rbrakk> \\<Longrightarrow> (unat ((of_int i)::sword32)) = nat i\"", "lemmas word_ctz_not_minus_1_32 = word_ctz_not_minus_1[where 'a=32, simplified]", "lemma cast_chunk_assemble_id_64[simp]:\n  \"(((ucast ((ucast (x::64 word))::32 word))::64 word) || (((ucast ((ucast (x >> 32))::32 word))::64 word) << 32)) = x\"", "lemma cast_chunk_assemble_id_64'[simp]:\n  \"(((ucast ((scast (x::64 word))::32 word))::64 word) || (((ucast ((scast (x >> 32))::32 word))::64 word) << 32)) = x\"", "lemma cast_down_u64: \"(scast::64 word \\<Rightarrow> 32 word) = (ucast::64 word \\<Rightarrow> 32 word)\"", "lemma cast_down_s64: \"(scast::64 sword \\<Rightarrow> 32 word) = (ucast::64 sword \\<Rightarrow> 32 word)\"", "lemma word32_and_max_simp:\n  \\<open>x AND 0xFFFFFFFF = x\\<close> for x :: \\<open>32 word\\<close>"], "translations": [["", "lemma len32: \"len_of (x :: 32 itself) = 32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len_of x = 32", "by simp"], ["", "type_synonym sword32 = \"32 sword\""], ["", "type_synonym machine_word_len = 32"], ["", "type_synonym machine_word = \"machine_word_len word\""], ["", "definition word_bits :: nat\nwhere\n  \"word_bits = LENGTH(machine_word_len)\""], ["", "text \\<open>The following two are numerals so they can be used as nats and words.\\<close>"], ["", "definition word_size_bits :: \"'a :: numeral\"\nwhere\n  \"word_size_bits = 2\""], ["", "definition word_size :: \"'a :: numeral\"\nwhere\n  \"word_size = 4\""], ["", "lemma word_bits_conv[code]:\n  \"word_bits = 32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_bits = 32", "unfolding word_bits_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH(32) = 32", "by simp"], ["", "lemma word_size_word_size_bits:\n  \"(word_size::nat) = 2 ^ word_size_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_size = 2 ^ word_size_bits", "unfolding word_size_def word_size_bits_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 = 2\\<^sup>2", "by simp"], ["", "lemma word_bits_word_size_conv:\n  \"word_bits = word_size * 8\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_bits = word_size * 8", "unfolding word_bits_def word_size_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH(32) = 4 * 8", "by simp"], ["", "lemma ucast_8_32_inj:\n  \"inj (ucast ::  8 word \\<Rightarrow> 32 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj UCAST(8 \\<rightarrow> 32)", "by (rule down_ucast_inj) (clarsimp simp: is_down_def target_size source_size)"], ["", "lemma upto_2_helper:\n  \"{0..<2 :: 32 word} = {0, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<2} = {0, 1}", "by (safe; simp) unat_arith"], ["", "lemmas upper_bits_unset_is_l2p_32 = upper_bits_unset_is_l2p [where 'a=32, folded word_bits_def]"], ["", "lemmas le_2p_upper_bits_32 = le_2p_upper_bits [where 'a=32, folded word_bits_def]"], ["", "lemmas le2p_bits_unset_32 = le2p_bits_unset[where 'a=32, folded word_bits_def]"], ["", "lemma word_bits_len_of:\n  \"len_of TYPE (32) = word_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH(32) = word_bits", "by (simp add: word_bits_conv)"], ["", "lemmas unat_power_lower32' = unat_power_lower[where 'a=32]"], ["", "lemmas unat_power_lower32 [simp] = unat_power_lower32'[unfolded word_bits_len_of]"], ["", "lemmas word32_less_sub_le' = word_less_sub_le[where 'a = 32]"], ["", "lemmas word32_less_sub_le[simp] = word32_less_sub_le' [folded word_bits_def]"], ["", "lemma word_bits_size:\n  \"size (w::word32) = word_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size w = word_bits", "by (simp add: word_bits_def word_size)"], ["", "lemmas word32_power_less_1' = word_power_less_1[where 'a = 32]"], ["", "lemmas word32_power_less_1[simp] = word32_power_less_1'[folded word_bits_def]"], ["", "lemma of_nat32_0:\n  \"\\<lbrakk>of_nat n = (0::word32); n < 2 ^ word_bits\\<rbrakk> \\<Longrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>word_of_nat n = 0; n < 2 ^ word_bits\\<rbrakk>\n    \\<Longrightarrow> n = 0", "by (erule of_nat_0, simp add: word_bits_def)"], ["", "lemma unat_mask_2_less_4:\n  \"unat (p && mask 2 :: word32) < 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (p && mask 2) < 4", "apply (rule unat_less_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p && mask 2 < word_of_nat 4", "apply (rule order_le_less_trans, rule word_and_le1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask 2 < word_of_nat 4", "apply (simp add: mask_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas unat_of_nat32' = unat_of_nat_eq[where 'a=32]"], ["", "lemmas unat_of_nat32 = unat_of_nat32'[unfolded word_bits_len_of]"], ["", "lemmas word_power_nonzero_32 = word_power_nonzero [where 'a=32, folded word_bits_def]"], ["", "lemmas unat_mult_simple = iffD1 [OF unat_mult_lem [where 'a = 32, unfolded word_bits_len_of]]"], ["", "lemmas div_power_helper_32 = div_power_helper [where 'a=32, folded word_bits_def]"], ["", "lemma n_less_word_bits:\n  \"(n < word_bits) = (n < 32)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n < word_bits) = (n < 32)", "by (simp add: word_bits_def)"], ["", "lemmas of_nat_less_pow_32 = of_nat_power [where 'a=32, folded word_bits_def]"], ["", "lemma lt_word_bits_lt_pow:\n  \"sz < word_bits \\<Longrightarrow> sz < 2 ^ word_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < word_bits \\<Longrightarrow> sz < 2 ^ word_bits", "by (simp add: word_bits_conv)"], ["", "lemma unat_less_word_bits:\n  fixes y :: word32\n  shows \"x < unat y \\<Longrightarrow> x < 2 ^ word_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < unat y \\<Longrightarrow> x < 2 ^ word_bits", "unfolding word_bits_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < unat y \\<Longrightarrow> x < 2 ^ LENGTH(32)", "by (rule order_less_trans [OF _ unat_lt2p])"], ["", "lemmas unat_mask_word32' = unat_mask[where 'a=32]"], ["", "lemmas unat_mask_word32 = unat_mask_word32'[folded word_bits_def]"], ["", "lemma unat_less_2p_word_bits:\n  \"unat (x :: 32 word) < 2 ^ word_bits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x < 2 ^ word_bits", "apply (simp only: word_bits_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x < 2 ^ LENGTH(32)", "apply (rule unat_lt2p)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Suc_unat_mask_div:\n  \"Suc (unat (mask sz div word_size::word32)) = 2 ^ (min sz word_bits - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 2)", "apply (case_tac \"sz < word_bits\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 2)\n 2. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 2)", "apply (case_tac \"2 \\<le> sz\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sz < word_bits; 2 \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> Suc (unat (mask sz div word_size)) =\n                      2 ^ (min sz word_bits - 2)\n 2. \\<lbrakk>sz < word_bits; \\<not> 2 \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> Suc (unat (mask sz div word_size)) =\n                      2 ^ (min sz word_bits - 2)\n 3. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 2)", "apply (clarsimp simp: word_size_def word_bits_def min_def mask_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sz < 32; 2 \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> Suc (unat ((2 ^ sz - 1) div 4)) = 2 ^ (sz - 2)\n 2. \\<lbrakk>sz < word_bits; \\<not> 2 \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> Suc (unat (mask sz div word_size)) =\n                      2 ^ (min sz word_bits - 2)\n 3. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 2)", "apply (drule (2) Suc_div_unat_helper\n           [where 'a=32 and sz=sz and us=2, simplified, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sz < word_bits; \\<not> 2 \\<le> sz\\<rbrakk>\n    \\<Longrightarrow> Suc (unat (mask sz div word_size)) =\n                      2 ^ (min sz word_bits - 2)\n 2. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 2)", "apply (simp add: not_le word_size_def word_bits_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < 2 \\<Longrightarrow> unat (mask sz div 4) = 0\n 2. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 2)", "apply (case_tac sz, simp add: unat_word_ariths)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>sz < 2; sz = Suc nat\\<rbrakk>\n       \\<Longrightarrow> unat (mask sz div 4) = 0\n 2. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 2)", "apply (case_tac nat, simp add: unat_word_ariths\n                                  unat_mask_word32 min_def word_bits_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat nata.\n       \\<lbrakk>sz < 2; sz = Suc nat; nat = Suc nata\\<rbrakk>\n       \\<Longrightarrow> unat (mask sz div 4) = 0\n 2. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sz < word_bits \\<Longrightarrow>\n    Suc (unat (mask sz div word_size)) = 2 ^ (min sz word_bits - 2)", "apply (simp add: unat_word_ariths\n                   unat_mask_word32 min_def word_bits_def word_size_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas word32_minus_one_le' = word_minus_one_le[where 'a=32]"], ["", "lemmas word32_minus_one_le = word32_minus_one_le'[simplified]"], ["", "lemma ucast_not_helper:\n  fixes a::\"8 word\"\n  assumes a: \"a \\<noteq> 0xFF\"\n  shows \"ucast a \\<noteq> (0xFF::word32)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST(8 \\<rightarrow> 32) a \\<noteq> 255", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. UCAST(8 \\<rightarrow> 32) a = 255 \\<Longrightarrow> False", "assume \"ucast a = (0xFF::word32)\""], ["proof (state)\nthis:\n  UCAST(8 \\<rightarrow> 32) a = 255\n\ngoal (1 subgoal):\n 1. UCAST(8 \\<rightarrow> 32) a = 255 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  UCAST(8 \\<rightarrow> 32) a = 255\n\ngoal (1 subgoal):\n 1. UCAST(8 \\<rightarrow> 32) a = 255 \\<Longrightarrow> False", "have \"(0xFF::word32) = ucast (0xFF::8 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 255 = UCAST(8 \\<rightarrow> 32) 255", "by simp"], ["proof (state)\nthis:\n  255 = UCAST(8 \\<rightarrow> 32) 255\n\ngoal (1 subgoal):\n 1. UCAST(8 \\<rightarrow> 32) a = 255 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  UCAST(8 \\<rightarrow> 32) a = UCAST(8 \\<rightarrow> 32) 255", "show False"], ["proof (prove)\nusing this:\n  UCAST(8 \\<rightarrow> 32) a = UCAST(8 \\<rightarrow> 32) 255\n\ngoal (1 subgoal):\n 1. False", "using a"], ["proof (prove)\nusing this:\n  UCAST(8 \\<rightarrow> 32) a = UCAST(8 \\<rightarrow> 32) 255\n  a \\<noteq> 255\n\ngoal (1 subgoal):\n 1. False", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>UCAST(8 \\<rightarrow> 32) a = UCAST(8 \\<rightarrow> 32) 255;\n     a \\<noteq> 255\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule up_ucast_inj, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 255; a = 255\\<rbrakk> \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_4_cases:\n  \"(x::word32) < 4 \\<Longrightarrow> x=0 \\<or> x=1 \\<or> x=2 \\<or> x=3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 4 \\<Longrightarrow> x = 0 \\<or> x = 1 \\<or> x = 2 \\<or> x = 3", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 4; x \\<noteq> 0; x \\<noteq> 1; x \\<noteq> 3\\<rbrakk>\n    \\<Longrightarrow> x = 2", "apply (drule word_less_cases, erule disjE, simp, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unat_ucast_8_32:\n  fixes x :: \"8 word\"\n  shows \"unat (ucast x :: word32) = unat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (UCAST(8 \\<rightarrow> 32) x) = unat x", "by transfer simp"], ["", "lemma if_then_1_else_0:\n  \"((if P then 1 else 0) = (0 :: word32)) = (\\<not> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if P then 1 else 0) = 0) = (\\<not> P)", "by simp"], ["", "lemma if_then_0_else_1:\n  \"((if P then 0 else 1) = (0 :: word32)) = (P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if P then 0 else 1) = 0) = P", "by simp"], ["", "lemmas if_then_simps = if_then_0_else_1 if_then_1_else_0"], ["", "lemma ucast_le_ucast_8_32:\n  \"(ucast x \\<le> (ucast y :: word32)) = (x \\<le> (y :: 8 word))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (UCAST(8 \\<rightarrow> 32) x \\<le> UCAST(8 \\<rightarrow> 32) y) =\n    (x \\<le> y)", "by (simp add: ucast_le_ucast)"], ["", "lemma in_16_range:\n  \"0 \\<in> S \\<Longrightarrow> r \\<in> (\\<lambda>x. r + x * (16 :: word32)) ` S\"\n  \"n - 1 \\<in> S \\<Longrightarrow> (r + (16 * n - 16)) \\<in> (\\<lambda>x :: word32. r + x * 16) ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<in> S \\<Longrightarrow> r \\<in> (\\<lambda>x. r + x * 16) ` S) &&&\n    (n - 1 \\<in> S \\<Longrightarrow>\n     r + (16 * n - 16) \\<in> (\\<lambda>x. r + x * 16) ` S)", "by (clarsimp simp: image_def elim!: bexI[rotated])+"], ["", "lemma eq_2_32_0:\n  \"(2 ^ 32 :: word32) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ 32 = 0", "by simp"], ["", "lemma x_less_2_0_1:\n  fixes x :: word32 shows\n  \"x < 2 \\<Longrightarrow> x = 0 \\<or> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 \\<Longrightarrow> x = 0 \\<or> x = 1", "by (rule x_less_2_0_1') auto"], ["", "lemmas mask_32_max_word  = max_word_mask [symmetric, where 'a=32, simplified]"], ["", "lemma of_nat32_n_less_equal_power_2:\n \"n < 32 \\<Longrightarrow> ((of_nat n)::32 word) < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 32 \\<Longrightarrow> word_of_nat n < 2 ^ n", "by (rule of_nat_n_less_equal_power_2, clarsimp simp: word_size)"], ["", "lemma word_rsplit_0:\n  \"word_rsplit (0 :: word32) = [0, 0, 0, 0 :: 8 word]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_rsplit 0 = [0, 0, 0, 0]", "by (simp add: word_rsplit_def bin_rsplit_def)"], ["", "lemma unat_ucast_10_32 :\n  fixes x :: \"10 word\"\n  shows \"unat (ucast x :: word32) = unat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (UCAST(10 \\<rightarrow> 32) x) = unat x", "by transfer simp"], ["", "lemma bool_mask [simp]:\n  fixes x :: word32\n  shows \"(0 < x && 1) = (x && 1 = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < x && 1) = (x && 1 = 1)", "by (rule bool_mask') auto"], ["", "lemma word32_bounds:\n  \"- (2 ^ (size (x :: word32) - 1)) = (-2147483648 :: int)\"\n  \"((2 ^ (size (x :: word32) - 1)) - 1) = (2147483647 :: int)\"\n  \"- (2 ^ (size (y :: 32 signed word) - 1)) = (-2147483648 :: int)\"\n  \"((2 ^ (size (y :: 32 signed word) - 1)) - 1) = (2147483647 :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (2 ^ (size x - 1)) = - 2147483648 &&&\n     2 ^ (size x - 1) - 1 = 2147483647) &&&\n    - (2 ^ (size y - 1)) = - 2147483648 &&&\n    2 ^ (size y - 1) - 1 = 2147483647", "by (simp_all add: word_size)"], ["", "lemma word_ge_min:\"sint (x::32 word) \\<ge> -2147483648\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 2147483648 \\<le> sint x", "by (metis sint_ge word32_bounds(1) word_size)"], ["", "lemmas signed_arith_ineq_checks_to_eq_word32'\n    = signed_arith_ineq_checks_to_eq[where 'a=32]\n      signed_arith_ineq_checks_to_eq[where 'a=\"32 signed\"]"], ["", "lemmas signed_arith_ineq_checks_to_eq_word32\n    = signed_arith_ineq_checks_to_eq_word32' [unfolded word32_bounds]"], ["", "lemmas signed_mult_eq_checks32_to_64'\n    = signed_mult_eq_checks_double_size[where 'a=32 and 'b=64]\n      signed_mult_eq_checks_double_size[where 'a=\"32 signed\" and 'b=64]"], ["", "lemmas signed_mult_eq_checks32_to_64 = signed_mult_eq_checks32_to_64'[simplified]"], ["", "lemmas sdiv_word32_max' = sdiv_word_max [where 'a=32] sdiv_word_max [where 'a=\"32 signed\"]"], ["", "lemmas sdiv_word32_max = sdiv_word32_max'[simplified word_size, simplified]"], ["", "lemmas sdiv_word32_min' = sdiv_word_min [where 'a=32] sdiv_word_min [where 'a=\"32 signed\"]"], ["", "lemmas sdiv_word32_min = sdiv_word32_min' [simplified word_size, simplified]"], ["", "lemmas sint32_of_int_eq' = sint_of_int_eq [where 'a=32]"], ["", "lemmas sint32_of_int_eq = sint32_of_int_eq' [simplified]"], ["", "lemma ucast_of_nats [simp]:\n  \"(ucast (of_nat x :: word32) :: sword32) = (of_nat x)\"\n  \"(ucast (of_nat x :: word32) :: 16 sword) = (of_nat x)\"\n  \"(ucast (of_nat x :: word32) :: 8 sword) = (of_nat x)\"\n  \"(ucast (of_nat x :: 16 word) :: 16 sword) = (of_nat x)\"\n  \"(ucast (of_nat x :: 16 word) :: 8 sword) = (of_nat x)\"\n  \"(ucast (of_nat x :: 8 word) :: 8 sword) = (of_nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (UCAST(32 \\<rightarrow> 32 signed) (word_of_nat x) = word_of_nat x &&&\n     UCAST(32 \\<rightarrow> 16 signed) (word_of_nat x) = word_of_nat x &&&\n     UCAST(32 \\<rightarrow> 8 signed) (word_of_nat x) = word_of_nat x) &&&\n    UCAST(16 \\<rightarrow> 16 signed) (word_of_nat x) = word_of_nat x &&&\n    UCAST(16 \\<rightarrow> 8 signed) (word_of_nat x) = word_of_nat x &&&\n    UCAST(8 \\<rightarrow> 8 signed) (word_of_nat x) = word_of_nat x", "by (simp_all add: of_nat_take_bit take_bit_word_eq_self)"], ["", "lemmas signed_shift_guard_simpler_32'\n    = power_strict_increasing_iff[where b=\"2 :: nat\" and y=31]"], ["", "lemmas signed_shift_guard_simpler_32 = signed_shift_guard_simpler_32'[simplified]"], ["", "lemma word32_31_less:\n  \"31 < len_of TYPE (32 signed)\" \"31 > (0 :: nat)\"\n  \"31 < len_of TYPE (32)\" \"31 > (0 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (31 < LENGTH(32 signed) &&& 0 < 31) &&& 31 < LENGTH(32) &&& 0 < 31", "by auto"], ["", "lemmas signed_shift_guard_to_word_32\n    = signed_shift_guard_to_word[OF word32_31_less(1-2)]\n    signed_shift_guard_to_word[OF word32_31_less(3-4)]"], ["", "lemma le_step_down_word_3:\n  fixes x :: \"32 word\"\n  shows \"\\<lbrakk>x \\<le>  y; x \\<noteq> y; y < 2 ^ 32 - 1\\<rbrakk> \\<Longrightarrow> x \\<le> y - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; x \\<noteq> y; y < 2 ^ 32 - 1\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 1", "by (rule le_step_down_word_2, assumption+)"], ["", "lemma shiftr_1:\n  \"(x::word32) >> 1 = 0 \\<Longrightarrow> x < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >> 1 = 0 \\<Longrightarrow> x < 2", "by transfer (simp add: take_bit_drop_bit drop_bit_Suc)"], ["", "lemma has_zero_byte:\n  \"~~ (((((v::word32) && 0x7f7f7f7f) + 0x7f7f7f7f) || v) || 0x7f7f7f7f) \\<noteq> 0\n    \\<Longrightarrow> v && 0xff000000 = 0 \\<or> v && 0xff0000 = 0 \\<or> v && 0xff00 = 0 \\<or> v && 0xff = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ~~ (((v && 2139062143) + 2139062143 || v) || 2139062143) \\<noteq>\n    0 \\<Longrightarrow>\n    v && 4278190080 = 0 \\<or>\n    v && 16711680 = 0 \\<or> v && 65280 = 0 \\<or> v && 255 = 0", "by word_bitwise auto"], ["", "lemma mask_step_down_32:\n  \\<open>\\<exists>x. mask x = b\\<close> if \\<open>b && 1 = 1\\<close>\n    and \\<open>\\<exists>x. x < 32 \\<and> mask x = b >> 1\\<close> for b :: \\<open>32word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "from \\<open>b && 1 = 1\\<close>"], ["proof (chain)\npicking this:\n  b && 1 = 1", "have \\<open>odd b\\<close>"], ["proof (prove)\nusing this:\n  b && 1 = 1\n\ngoal (1 subgoal):\n 1. odd b", "by (auto simp add: mod_2_eq_odd and_one_eq)"], ["proof (state)\nthis:\n  odd b\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "then"], ["proof (chain)\npicking this:\n  odd b", "have \\<open>b mod 2 = 1\\<close>"], ["proof (prove)\nusing this:\n  odd b\n\ngoal (1 subgoal):\n 1. b mod 2 = 1", "using odd_iff_mod_2_eq_one"], ["proof (prove)\nusing this:\n  odd b\n  odd ?a = (?a mod (2::?'a) = (1::?'a))\n\ngoal (1 subgoal):\n 1. b mod 2 = 1", "by blast"], ["proof (state)\nthis:\n  b mod 2 = 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "from \\<open>\\<exists>x. x < 32 \\<and> mask x = b >> 1\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>x<32. mask x = b >> 1", "obtain x where \\<open>x < 32\\<close> \\<open>mask x = b >> 1\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x<32. mask x = b >> 1\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x < 32; mask x = b >> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x < 32\n  mask x = b >> 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "then"], ["proof (chain)\npicking this:\n  x < 32\n  mask x = b >> 1", "have \\<open>mask x = b div 2\\<close>"], ["proof (prove)\nusing this:\n  x < 32\n  mask x = b >> 1\n\ngoal (1 subgoal):\n 1. mask x = b div 2", "using shiftr1_is_div_2 [of b]"], ["proof (prove)\nusing this:\n  x < 32\n  mask x = b >> 1\n  b >> 1 = b div 2\n\ngoal (1 subgoal):\n 1. mask x = b div 2", "by simp"], ["proof (state)\nthis:\n  mask x = b div 2\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "with \\<open>b mod 2 = 1\\<close>"], ["proof (chain)\npicking this:\n  b mod 2 = 1\n  mask x = b div 2", "have \\<open>2 * mask x + 1 = 2 * (b div 2) + b mod 2\\<close>"], ["proof (prove)\nusing this:\n  b mod 2 = 1\n  mask x = b div 2\n\ngoal (1 subgoal):\n 1. 2 * mask x + 1 = 2 * (b div 2) + b mod 2", "by (simp only:)"], ["proof (state)\nthis:\n  2 * mask x + 1 = 2 * (b div 2) + b mod 2\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "also"], ["proof (state)\nthis:\n  2 * mask x + 1 = 2 * (b div 2) + b mod 2\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "have \\<open>\\<dots> = b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (b div 2) + b mod 2 = b", "by (simp add: mult_div_mod_eq)"], ["proof (state)\nthis:\n  2 * (b div 2) + b mod 2 = b\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "finally"], ["proof (chain)\npicking this:\n  2 * mask x + 1 = b", "have \\<open>2 * mask x + 1 = b\\<close>"], ["proof (prove)\nusing this:\n  2 * mask x + 1 = b\n\ngoal (1 subgoal):\n 1. 2 * mask x + 1 = b", "."], ["proof (state)\nthis:\n  2 * mask x + 1 = b\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "moreover"], ["proof (state)\nthis:\n  2 * mask x + 1 = b\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "have \\<open>mask (Suc x) = 2 * mask x + (1 :: 'a::len word)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (Suc x) = 2 * mask x + 1", "by (simp add: mask_Suc_rec)"], ["proof (state)\nthis:\n  mask (Suc x) = 2 * mask x + 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "ultimately"], ["proof (chain)\npicking this:\n  2 * mask x + 1 = b\n  mask (Suc x) = 2 * mask x + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * mask x + 1 = b\n  mask (Suc x) = 2 * mask x + 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. mask x = b", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. mask x = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unat_of_int_32:\n  \"\\<lbrakk>i \\<ge> 0; i \\<le>2 ^ 31\\<rbrakk> \\<Longrightarrow> (unat ((of_int i)::sword32)) = nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> i; i \\<le> 2 ^ 31\\<rbrakk>\n    \\<Longrightarrow> unat (word_of_int i) = nat i", "unfolding unat_eq_nat_uint"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> i; i \\<le> 2 ^ 31\\<rbrakk>\n    \\<Longrightarrow> nat (uint (word_of_int i)) = nat i", "apply (subst eq_nat_nat_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> i; i \\<le> 2 ^ 31\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> uint (word_of_int i)\n 2. \\<lbrakk>0 \\<le> i; i \\<le> 2 ^ 31\\<rbrakk> \\<Longrightarrow> 0 \\<le> i\n 3. \\<lbrakk>0 \\<le> i; i \\<le> 2 ^ 31\\<rbrakk>\n    \\<Longrightarrow> uint (word_of_int i) = i", "apply (auto simp add: take_bit_int_eq_self)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas word_ctz_not_minus_1_32 = word_ctz_not_minus_1[where 'a=32, simplified]"], ["", "(* Helper for packing then unpacking a 64-bit variable. *)"], ["", "lemma cast_chunk_assemble_id_64[simp]:\n  \"(((ucast ((ucast (x::64 word))::32 word))::64 word) || (((ucast ((ucast (x >> 32))::32 word))::64 word) << 32)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST(32 \\<rightarrow> 64) (UCAST(64 \\<rightarrow> 32) x) ||\n    (UCAST(32 \\<rightarrow> 64) (UCAST(64 \\<rightarrow> 32) (x >> 32)) <<\n     32) =\n    x", "by (simp add:cast_chunk_assemble_id)"], ["", "(* Another variant of packing and unpacking a 64-bit variable. *)"], ["", "lemma cast_chunk_assemble_id_64'[simp]:\n  \"(((ucast ((scast (x::64 word))::32 word))::64 word) || (((ucast ((scast (x >> 32))::32 word))::64 word) << 32)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UCAST(32 \\<rightarrow> 64) (SCAST(64 \\<rightarrow> 32) x) ||\n    (UCAST(32 \\<rightarrow> 64) (SCAST(64 \\<rightarrow> 32) (x >> 32)) <<\n     32) =\n    x", "by (simp add:cast_chunk_scast_assemble_id)"], ["", "(* Specialisations of down_cast_same for adding to local simpsets. *)"], ["", "lemma cast_down_u64: \"(scast::64 word \\<Rightarrow> 32 word) = (ucast::64 word \\<Rightarrow> 32 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SCAST(64 \\<rightarrow> 32) = UCAST(64 \\<rightarrow> 32)", "by (subst down_cast_same[symmetric]; simp add:is_down)+"], ["", "lemma cast_down_s64: \"(scast::64 sword \\<Rightarrow> 32 word) = (ucast::64 sword \\<Rightarrow> 32 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SCAST(64 signed \\<rightarrow> 32) = UCAST(64 signed \\<rightarrow> 32)", "by (subst down_cast_same[symmetric]; simp add:is_down)"], ["", "lemma word32_and_max_simp:\n  \\<open>x AND 0xFFFFFFFF = x\\<close> for x :: \\<open>32 word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x && 4294967295 = x", "using word_and_full_mask_simp [of x]"], ["proof (prove)\nusing this:\n  x && mask LENGTH(32) = x\n\ngoal (1 subgoal):\n 1. x && 4294967295 = x", "by (simp add: numeral_eq_Suc mask_Suc_exp)"], ["", "end"]]}