{"file_name": "/home/qj213/afp-2021-10-22/thys/Word_Lib/Aligned.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Word_Lib", "problem_names": ["lemma is_aligned_iff_udvd:\n  \\<open>is_aligned w n \\<longleftrightarrow> 2 ^ n udvd w\\<close>", "lemma is_aligned_iff_take_bit_eq_0:\n  \\<open>is_aligned w n \\<longleftrightarrow> take_bit n w = 0\\<close>", "lemma is_aligned_iff_dvd_int:\n  \\<open>is_aligned ptr n \\<longleftrightarrow> 2 ^ n dvd uint ptr\\<close>", "lemma is_aligned_iff_dvd_nat:\n  \\<open>is_aligned ptr n \\<longleftrightarrow> 2 ^ n dvd unat ptr\\<close>", "lemma is_aligned_0 [simp]:\n  \\<open>is_aligned 0 n\\<close>", "lemma is_aligned_at_0 [simp]:\n  \\<open>is_aligned w 0\\<close>", "lemma is_aligned_beyond_length:\n  \\<open>is_aligned w n \\<longleftrightarrow> w = 0\\<close> if \\<open>LENGTH('a) \\<le> n\\<close> for w :: \\<open>'a::len word\\<close>", "lemma is_alignedI [intro?]:\n  \\<open>is_aligned x n\\<close> if \\<open>x = 2 ^ n * k\\<close> for x :: \\<open>'a::len word\\<close>", "lemma is_alignedE:\n  fixes w :: \\<open>'a::len word\\<close>\n  assumes \\<open>is_aligned w n\\<close>\n  obtains q where \\<open>w = 2 ^ n * word_of_nat q\\<close> \\<open>q < 2 ^ (LENGTH('a) - n)\\<close>", "lemma is_alignedE' [elim?]:\n  fixes w :: \\<open>'a::len word\\<close>\n  assumes \\<open>is_aligned w n\\<close>\n  obtains q where \\<open>w = push_bit n (word_of_nat q)\\<close> \\<open>q < 2 ^ (LENGTH('a) - n)\\<close>", "lemma is_aligned_mask:\n  \\<open>is_aligned w n \\<longleftrightarrow> w AND mask n = 0\\<close>", "lemma is_aligned_imp_not_bit:\n  \\<open>\\<not> bit w m\\<close> if \\<open>is_aligned w n\\<close> and \\<open>m < n\\<close>\n  for w :: \\<open>'a::len word\\<close>", "lemma is_aligned_weaken:\n  \"\\<lbrakk> is_aligned w x; x \\<ge> y \\<rbrakk> \\<Longrightarrow> is_aligned w y\"", "lemma is_alignedE_pre:\n  fixes w::\"'a::len word\"\n  assumes aligned: \"is_aligned w n\"\n  shows        rl: \"\\<exists>q. w = 2 ^ n * (of_nat q) \\<and> q < 2 ^ (LENGTH('a) - n)\"", "lemma aligned_add_aligned:\n  fixes x::\"'a::len word\"\n  assumes aligned1: \"is_aligned x n\"\n  and     aligned2: \"is_aligned y m\"\n  and           lt: \"m \\<le> n\"\n  shows   \"is_aligned (x + y) m\"", "lemma is_aligned_shift:\n  fixes k::\"'a::len word\"\n  shows \"is_aligned (k << m) m\"", "lemma word_mod_by_0: \"k mod (0::'a::len word) = k\"", "lemma aligned_mod_eq_0:\n  fixes p::\"'a::len word\"\n  assumes al: \"is_aligned p sz\"\n  shows   \"p mod 2 ^ sz = 0\"", "lemma is_aligned_triv: \"is_aligned (2 ^ n ::'a::len word) n\"", "lemma is_aligned_mult_triv1: \"is_aligned (2 ^ n * x  ::'a::len word) n\"", "lemma is_aligned_mult_triv2: \"is_aligned (x * 2 ^ n ::'a::len word) n\"", "lemma word_power_less_0_is_0:\n  fixes x :: \"'a::len word\"\n  shows \"x < a ^ 0 \\<Longrightarrow> x = 0\"", "lemma is_aligned_no_wrap:\n  fixes off :: \"'a::len word\"\n  fixes ptr :: \"'a::len word\"\n  assumes al: \"is_aligned ptr sz\"\n  and    off: \"off < 2 ^ sz\"\n  shows  \"unat ptr + unat off < 2 ^ LENGTH('a)\"", "lemma is_aligned_no_wrap':\n  fixes ptr :: \"'a::len word\"\n  assumes al: \"is_aligned ptr sz\"\n  and    off: \"off < 2 ^ sz\"\n  shows  \"ptr \\<le> ptr + off\"", "lemma is_aligned_no_overflow':\n  fixes p :: \"'a::len word\"\n  assumes al: \"is_aligned p n\"\n  shows \"p \\<le> p + (2 ^ n - 1)\"", "lemma is_aligned_no_overflow:\n  \"is_aligned ptr sz \\<Longrightarrow> ptr \\<le> ptr + 2^sz - 1\"", "lemma replicate_not_True:\n  \"\\<And>n. xs = replicate n False \\<Longrightarrow> True \\<notin> set xs\"", "lemma map_zip_replicate_False_xor:\n  \"n = length xs \\<Longrightarrow> map (\\<lambda>(x, y). x = (\\<not> y)) (zip xs (replicate n False)) = xs\"", "lemma drop_minus_lem:\n  \"\\<lbrakk> n \\<le> length xs; 0 < n; n' = length xs \\<rbrakk> \\<Longrightarrow> drop (n' - n) xs = rev xs ! (n - 1)  # drop (Suc (n' - n)) xs\"", "lemma drop_minus:\n  \"\\<lbrakk> n < length xs; n' = length xs \\<rbrakk> \\<Longrightarrow> drop (n' - Suc n) xs = rev xs ! n  # drop (n' - n) xs\"", "lemma aligned_add_xor:\n  \\<open>(x + 2 ^ n) XOR 2 ^ n = x\\<close>\n  if al: \\<open>is_aligned (x::'a::len word) n'\\<close> and le: \\<open>n < n'\\<close>", "lemma is_aligned_add_mult_multI:\n  fixes p :: \"'a::len word\"\n  shows \"\\<lbrakk>is_aligned p m; n \\<le> m; n' = n\\<rbrakk> \\<Longrightarrow> is_aligned (p + x * 2 ^ n * z) n'\"", "lemma is_aligned_add_multI:\n  fixes p :: \"'a::len word\"\n  shows \"\\<lbrakk>is_aligned p m; n \\<le> m; n' = n\\<rbrakk> \\<Longrightarrow> is_aligned (p + x * 2 ^ n) n'\"", "lemma is_aligned_no_wrap''':\n  fixes ptr :: \"'a::len word\"\n  shows\"\\<lbrakk> is_aligned ptr sz; sz < LENGTH('a); off < 2 ^ sz \\<rbrakk>\n         \\<Longrightarrow> unat ptr + off < 2 ^ LENGTH('a)\"", "lemma is_aligned_get_word_bits:\n  fixes p :: \"'a::len word\"\n  shows \"\\<lbrakk> is_aligned p n; \\<lbrakk> is_aligned p n; n < LENGTH('a) \\<rbrakk> \\<Longrightarrow> P;\n           \\<lbrakk> p = 0; n \\<ge> LENGTH('a) \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma aligned_small_is_0:\n  \"\\<lbrakk> is_aligned x n; x < 2 ^ n \\<rbrakk> \\<Longrightarrow> x = 0\"", "lemma aligned_at_least_t2n_diff:\n  \"\\<lbrakk>is_aligned x n; is_aligned y n; x < y\\<rbrakk> \\<Longrightarrow> x \\<le> y - 2 ^ n\"", "lemma is_aligned_no_overflow'':\n  \"\\<lbrakk>is_aligned x n; x + 2 ^ n \\<noteq> 0\\<rbrakk> \\<Longrightarrow> x \\<le> x + 2 ^ n\"", "lemma is_aligned_nth [word_eqI_simps]:\n  \"is_aligned p m = (\\<forall>n < m. \\<not>p !! n)\"", "lemma range_inter:\n  \"({a..b} \\<inter> {c..d} = {}) = (\\<forall>x. \\<not>(a \\<le> x \\<and> x \\<le> b \\<and> c \\<le> x \\<and> x \\<le> d))\"", "lemma aligned_inter_non_empty:\n  \"\\<lbrakk> {p..p + (2 ^ n - 1)} \\<inter> {p..p + 2 ^ m - 1} = {};\n     is_aligned p n; is_aligned p m\\<rbrakk> \\<Longrightarrow> False\"", "lemma not_aligned_mod_nz:\n  assumes al: \"\\<not> is_aligned a n\"\n  shows \"a mod 2 ^ n \\<noteq> 0\"", "lemma nat_add_offset_le:\n  fixes x :: nat\n  assumes yv: \"y \\<le> 2 ^ n\"\n  and     xv: \"x < 2 ^ m\"\n  and     mn: \"sz = m + n\"\n  shows   \"x * 2 ^ n + y \\<le> 2 ^ sz\"", "lemma is_aligned_no_wrap_le:\n  fixes ptr::\"'a::len word\"\n  assumes al: \"is_aligned ptr sz\"\n  and    szv: \"sz < LENGTH('a)\"\n  and    off: \"off \\<le> 2 ^ sz\"\n  shows  \"unat ptr + off \\<le> 2 ^ LENGTH('a)\"", "lemma is_aligned_neg_mask:\n  \"m \\<le> n \\<Longrightarrow> is_aligned (x AND NOT (mask n)) m\"", "lemma unat_minus:\n  \"unat (- (x :: 'a :: len word)) = (if x = 0 then 0 else 2 ^ size x - unat x)\"", "lemma is_aligned_minus:\n  \\<open>is_aligned (- p) n\\<close> if \\<open>is_aligned p n\\<close> for p :: \\<open>'a::len word\\<close>", "lemma add_mask_lower_bits:\n  \"\\<lbrakk>is_aligned (x :: 'a :: len word) n;\n    \\<forall>n' \\<ge> n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\\<rbrakk> \\<Longrightarrow> x + p AND NOT (mask n) = x\"", "lemma is_aligned_andI1:\n  \"is_aligned x n \\<Longrightarrow> is_aligned (x AND y) n\"", "lemma is_aligned_andI2:\n  \"is_aligned y n \\<Longrightarrow> is_aligned (x AND y) n\"", "lemma is_aligned_shiftl:\n  \"is_aligned w (n - m) \\<Longrightarrow> is_aligned (w << m) n\"", "lemma is_aligned_shiftr:\n  \"is_aligned w (n + m) \\<Longrightarrow> is_aligned (w >> m) n\"", "lemma is_aligned_shiftl_self:\n  \"is_aligned (p << n) n\"", "lemma is_aligned_neg_mask_eq:\n  \"is_aligned p n \\<Longrightarrow> p AND NOT (mask n) = p\"", "lemma is_aligned_shiftr_shiftl:\n  \"is_aligned w n \\<Longrightarrow> w >> n << n = w\"", "lemma aligned_shiftr_mask_shiftl:\n  \"is_aligned x n \\<Longrightarrow> ((x >> n) AND mask v) << n = x AND mask (v + n)\"", "lemma mask_zero:\n  \"is_aligned x a \\<Longrightarrow> x AND mask a = 0\"", "lemma is_aligned_neg_mask_eq_concrete:\n  \"\\<lbrakk> is_aligned p n; msk AND NOT (mask n) = NOT (mask n) \\<rbrakk>\n   \\<Longrightarrow> p AND msk = p\"", "lemma is_aligned_and_not_zero:\n  \"\\<lbrakk> is_aligned n k; n \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> 2 ^ k \\<le> n\"", "lemma is_aligned_and_2_to_k:\n  \"(n AND 2 ^ k - 1) = 0 \\<Longrightarrow> is_aligned (n :: 'a :: len word) k\"", "lemma is_aligned_power2:\n  \"b \\<le> a \\<Longrightarrow> is_aligned (2 ^ a) b\"", "lemma aligned_sub_aligned':\n  \"\\<lbrakk> is_aligned (a :: 'a :: len word) n; is_aligned b n; n < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> is_aligned (a - b) n\"", "lemma is_aligned_neg_mask_weaken:\n  \"\\<lbrakk> is_aligned p n; m \\<le> n \\<rbrakk> \\<Longrightarrow> p AND NOT (mask m) = p\"", "lemma is_aligned_neg_mask2 [simp]:\n  \"is_aligned (a AND NOT (mask n)) n\"", "lemma is_aligned_0':\n  \"is_aligned 0 n\"", "lemma aligned_add_offset_no_wrap:\n  fixes off :: \"('a::len) word\"\n  and     x :: \"'a word\"\n  assumes al: \"is_aligned x sz\"\n  and   offv: \"off < 2 ^ sz\"\n  shows  \"unat x + unat off < 2 ^ LENGTH('a)\"", "lemma aligned_add_offset_mod:\n  fixes x :: \"('a::len) word\"\n  assumes al: \"is_aligned x sz\"\n  and     kv: \"k < 2 ^ sz\"\n  shows   \"(x + k) mod 2 ^ sz = k\"", "lemma aligned_neq_into_no_overlap:\n  fixes x :: \"'a::len word\"\n  assumes neq: \"x \\<noteq> y\"\n  and     alx: \"is_aligned x sz\"\n  and     aly: \"is_aligned y sz\"\n  shows  \"{x .. x + (2 ^ sz - 1)} \\<inter> {y .. y + (2 ^ sz - 1)} = {}\"", "lemma is_aligned_add_helper:\n  \"\\<lbrakk> is_aligned p n; d < 2 ^ n \\<rbrakk>\n     \\<Longrightarrow> (p + d AND mask n = d) \\<and> (p + d AND (NOT (mask n)) = p)\"", "lemmas mask_inner_mask = mask_eqs(1)", "lemma mask_add_aligned:\n  \"is_aligned p n \\<Longrightarrow> (p + q) AND mask n = q AND mask n\"", "lemma mask_out_add_aligned:\n  assumes al: \"is_aligned p n\"\n  shows \"p + (q AND NOT (mask n)) = (p + q) AND NOT (mask n)\"", "lemma is_aligned_add_or:\n  \"\\<lbrakk>is_aligned p n; d < 2 ^ n\\<rbrakk> \\<Longrightarrow> p + d = p OR d\"", "lemma not_greatest_aligned:\n  \"\\<lbrakk> x < y; is_aligned x n; is_aligned y n \\<rbrakk> \\<Longrightarrow> x + 2 ^ n \\<noteq> 0\"", "lemma neg_mask_mono_le:\n  \"x \\<le> y \\<Longrightarrow> x AND NOT(mask n) \\<le> y AND NOT(mask n)\" for x :: \"'a :: len word\"", "lemma and_neg_mask_eq_iff_not_mask_le:\n  \"w AND NOT(mask n) = NOT(mask n) \\<longleftrightarrow> NOT(mask n) \\<le> w\"\n  for w :: \\<open>'a::len word\\<close>", "lemma neg_mask_le_high_bits [word_eqI_simps]:\n  \"NOT(mask n) \\<le> w \\<longleftrightarrow> (\\<forall>i \\<in> {n ..< size w}. w !! i)\"\n  for w :: \\<open>'a::len word\\<close>", "lemma is_aligned_add_less_t2n:\n  \"\\<lbrakk>is_aligned (p::'a::len word) n; d < 2^n; n \\<le> m; p < 2^m\\<rbrakk> \\<Longrightarrow> p + d < 2^m\"", "lemma aligned_offset_non_zero:\n  \"\\<lbrakk> is_aligned x n; y < 2 ^ n; x \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> x + y \\<noteq> 0\"", "lemma is_aligned_over_length:\n  \"\\<lbrakk> is_aligned p n; LENGTH('a) \\<le> n \\<rbrakk> \\<Longrightarrow> (p::'a::len word) = 0\"", "lemma is_aligned_no_overflow_mask:\n  \"is_aligned x n \\<Longrightarrow> x \\<le> x + mask n\"", "lemma aligned_mask_step:\n  \"\\<lbrakk> n' \\<le> n; p' \\<le> p + mask n; is_aligned p n; is_aligned p' n' \\<rbrakk> \\<Longrightarrow>\n   (p'::'a::len word) + mask n' \\<le> p + mask n\"", "lemma is_aligned_mask_offset_unat:\n  fixes off :: \"('a::len) word\"\n  and     x :: \"'a word\"\n  assumes al: \"is_aligned x sz\"\n  and   offv: \"off \\<le> mask sz\"\n  shows  \"unat x + unat off < 2 ^ LENGTH('a)\"", "lemma aligned_less_plus_1:\n  \"\\<lbrakk> is_aligned x n; n > 0 \\<rbrakk> \\<Longrightarrow> x < x + 1\"", "lemma aligned_add_offset_less:\n  \"\\<lbrakk>is_aligned x n; is_aligned y n; x < y; z < 2 ^ n\\<rbrakk> \\<Longrightarrow> x + z < y\"", "lemma gap_between_aligned:\n  \"\\<lbrakk>a < (b :: 'a ::len word); is_aligned a n; is_aligned b n; n < LENGTH('a) \\<rbrakk>\n  \\<Longrightarrow> a + (2^n - 1) < b\"", "lemma is_aligned_add_step_le:\n  \"\\<lbrakk> is_aligned (a::'a::len word) n; is_aligned b n; a < b; b \\<le> a + mask n \\<rbrakk> \\<Longrightarrow> False\"", "lemma aligned_add_mask_lessD:\n  \"\\<lbrakk> x + mask n < y; is_aligned x n \\<rbrakk> \\<Longrightarrow> x < y\" for y::\"'a::len word\"", "lemma aligned_add_mask_less_eq:\n  \"\\<lbrakk> is_aligned x n; is_aligned y n;  n < LENGTH('a) \\<rbrakk> \\<Longrightarrow> (x + mask n < y) = (x < y)\"\n  for y::\"'a::len word\"", "lemma is_aligned_diff:\n  fixes m :: \"'a::len word\"\n  assumes alm: \"is_aligned m s1\"\n  and     aln: \"is_aligned n s2\"\n  and    s2wb: \"s2 < LENGTH('a)\"\n  and      nm: \"m \\<in> {n .. n + (2 ^ s2 - 1)}\"\n  and    s1s2: \"s1 \\<le> s2\"\n  and     s10: \"0 < s1\" (* Probably can be folded into the proof \\<dots> *)\nshows  \"\\<exists>q. m - n = of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)\"", "lemma is_aligned_addD1:\n  assumes al1: \"is_aligned (x + y) n\"\n  and     al2: \"is_aligned (x::'a::len word) n\"\n  shows \"is_aligned y n\"", "lemmas is_aligned_addD2 =\n       is_aligned_addD1[OF subst[OF add.commute,\n                                 of \"%x. is_aligned x n\" for n]]", "lemma is_aligned_add:\n  \"\\<lbrakk>is_aligned p n; is_aligned q n\\<rbrakk> \\<Longrightarrow> is_aligned (p + q) n\"", "lemma aligned_shift:\n  \"\\<lbrakk>x < 2 ^ n; is_aligned (y :: 'a :: len word) n;n \\<le> LENGTH('a)\\<rbrakk>\n   \\<Longrightarrow> x + y >> n = y >> n\"", "lemma aligned_shift':\n  \"\\<lbrakk>x < 2 ^ n; is_aligned (y :: 'a :: len word) n;n \\<le> LENGTH('a)\\<rbrakk>\n   \\<Longrightarrow> y + x >> n = y >> n\"", "lemma and_neg_mask_plus_mask_mono: \"(p AND NOT (mask n)) + mask n \\<ge> p\"\n  for p :: \\<open>'a::len word\\<close>", "lemma word_neg_and_le:\n  \"ptr \\<le> (ptr AND NOT (mask n)) + (2 ^ n - 1)\"\n  for ptr :: \\<open>'a::len word\\<close>", "lemma is_aligned_sub_helper:\n  \"\\<lbrakk> is_aligned (p - d) n; d < 2 ^ n \\<rbrakk>\n     \\<Longrightarrow> (p AND mask n = d) \\<and> (p AND (NOT (mask n)) = p - d)\"", "lemma is_aligned_after_mask:\n  \"\\<lbrakk>is_aligned k m;m\\<le> n\\<rbrakk> \\<Longrightarrow> is_aligned (k AND mask n) m\"", "lemma and_mask_plus:\n  \"\\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n   \\<Longrightarrow> ptr + a AND mask n = (ptr AND mask n) + a\""], "translations": [["", "lemma is_aligned_iff_udvd:\n  \\<open>is_aligned w n \\<longleftrightarrow> 2 ^ n udvd w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned w n = (2 ^ n udvd w)", "by transfer (simp flip: take_bit_eq_0_iff add: min_def)"], ["", "lemma is_aligned_iff_take_bit_eq_0:\n  \\<open>is_aligned w n \\<longleftrightarrow> take_bit n w = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned w n = (take_bit n w = 0)", "by (simp add: is_aligned_iff_udvd take_bit_eq_0_iff exp_dvd_iff_exp_udvd)"], ["", "lemma is_aligned_iff_dvd_int:\n  \\<open>is_aligned ptr n \\<longleftrightarrow> 2 ^ n dvd uint ptr\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned ptr n = (2 ^ n dvd uint ptr)", "by transfer simp"], ["", "lemma is_aligned_iff_dvd_nat:\n  \\<open>is_aligned ptr n \\<longleftrightarrow> 2 ^ n dvd unat ptr\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned ptr n = (2 ^ n dvd unat ptr)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_aligned ptr n = (2 ^ n dvd unat ptr)", "have \\<open>unat ptr = nat \\<bar>uint ptr\\<bar>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ptr = nat \\<bar>uint ptr\\<bar>", "by transfer simp"], ["proof (state)\nthis:\n  unat ptr = nat \\<bar>uint ptr\\<bar>\n\ngoal (1 subgoal):\n 1. is_aligned ptr n = (2 ^ n dvd unat ptr)", "then"], ["proof (chain)\npicking this:\n  unat ptr = nat \\<bar>uint ptr\\<bar>", "have \\<open>2 ^ n dvd unat ptr \\<longleftrightarrow> 2 ^ n dvd uint ptr\\<close>"], ["proof (prove)\nusing this:\n  unat ptr = nat \\<bar>uint ptr\\<bar>\n\ngoal (1 subgoal):\n 1. (2 ^ n dvd unat ptr) = (2 ^ n dvd uint ptr)", "by (simp only: dvd_nat_abs_iff) simp"], ["proof (state)\nthis:\n  (2 ^ n dvd unat ptr) = (2 ^ n dvd uint ptr)\n\ngoal (1 subgoal):\n 1. is_aligned ptr n = (2 ^ n dvd unat ptr)", "then"], ["proof (chain)\npicking this:\n  (2 ^ n dvd unat ptr) = (2 ^ n dvd uint ptr)", "show ?thesis"], ["proof (prove)\nusing this:\n  (2 ^ n dvd unat ptr) = (2 ^ n dvd uint ptr)\n\ngoal (1 subgoal):\n 1. is_aligned ptr n = (2 ^ n dvd unat ptr)", "by (simp add: is_aligned_iff_dvd_int)"], ["proof (state)\nthis:\n  is_aligned ptr n = (2 ^ n dvd unat ptr)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_0 [simp]:\n  \\<open>is_aligned 0 n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned 0 n", "by transfer simp"], ["", "lemma is_aligned_at_0 [simp]:\n  \\<open>is_aligned w 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned w 0", "by transfer simp"], ["", "lemma is_aligned_beyond_length:\n  \\<open>is_aligned w n \\<longleftrightarrow> w = 0\\<close> if \\<open>LENGTH('a) \\<le> n\\<close> for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned w n = (w = 0)", "using that"], ["proof (prove)\nusing this:\n  LENGTH('a) \\<le> n\n\ngoal (1 subgoal):\n 1. is_aligned w n = (w = 0)", "apply (simp add: is_aligned_iff_udvd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LENGTH('a) \\<le> n \\<Longrightarrow> (2 ^ n udvd w) = (w = 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n w.\n       LENGTH('a) \\<le> n \\<Longrightarrow>\n       (take_bit LENGTH('a) (2 ^ n) dvd take_bit LENGTH('a) w) =\n       (take_bit LENGTH('a) w = take_bit LENGTH('a) 0)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_alignedI [intro?]:\n  \\<open>is_aligned x n\\<close> if \\<open>x = 2 ^ n * k\\<close> for x :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned x n", "proof (unfold is_aligned_iff_udvd)"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ n udvd x", "from that"], ["proof (chain)\npicking this:\n  x = 2 ^ n * k", "show \\<open>2 ^ n udvd x\\<close>"], ["proof (prove)\nusing this:\n  x = 2 ^ n * k\n\ngoal (1 subgoal):\n 1. 2 ^ n udvd x", "using dvd_triv_left exp_dvd_iff_exp_udvd"], ["proof (prove)\nusing this:\n  x = 2 ^ n * k\n  ?a dvd ?a * ?b\n  (2 ^ ?n dvd ?w) = (2 ^ ?n udvd ?w)\n\ngoal (1 subgoal):\n 1. 2 ^ n udvd x", "by blast"], ["proof (state)\nthis:\n  2 ^ n udvd x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_alignedE:\n  fixes w :: \\<open>'a::len word\\<close>\n  assumes \\<open>is_aligned w n\\<close>\n  obtains q where \\<open>w = 2 ^ n * word_of_nat q\\<close> \\<open>q < 2 ^ (LENGTH('a) - n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>w = 2 ^ n * word_of_nat q;\n         q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \\<open>n < LENGTH('a)\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> n < LENGTH('a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms"], ["proof (chain)\npicking this:\n  is_aligned w n\n  \\<not> n < LENGTH('a)", "have \\<open>w = 0\\<close>"], ["proof (prove)\nusing this:\n  is_aligned w n\n  \\<not> n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. w = 0", "by (simp add: is_aligned_beyond_length)"], ["proof (state)\nthis:\n  w = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with that [of 0]"], ["proof (chain)\npicking this:\n  \\<lbrakk>w = 2 ^ n * word_of_nat 0; 0 < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  w = 0", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>w = 2 ^ n * word_of_nat 0; 0 < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  w = 0\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "define m where \\<open>m = LENGTH('a) - n\\<close>"], ["proof (state)\nthis:\n  m = LENGTH('a) - n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  n < LENGTH('a)\n  m = LENGTH('a) - n", "have l: \\<open>LENGTH('a) = n + m\\<close> and \\<open>m \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n  m = LENGTH('a) - n\n\ngoal (1 subgoal):\n 1. LENGTH('a) = n + m &&& m \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  LENGTH('a) = n + m\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from \\<open>n < LENGTH('a)\\<close>"], ["proof (chain)\npicking this:\n  n < LENGTH('a)", "have *: \\<open>unat (2 ^ n :: 'a word) = 2 ^ n\\<close>"], ["proof (prove)\nusing this:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (2 ^ n) = 2 ^ n", "by transfer simp"], ["proof (state)\nthis:\n  unat (2 ^ n) = 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from assms"], ["proof (chain)\npicking this:\n  is_aligned w n", "have \\<open>2 ^ n udvd w\\<close>"], ["proof (prove)\nusing this:\n  is_aligned w n\n\ngoal (1 subgoal):\n 1. 2 ^ n udvd w", "by (simp add: is_aligned_iff_udvd)"], ["proof (state)\nthis:\n  2 ^ n udvd w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  2 ^ n udvd w", "obtain v :: \\<open>'a word\\<close>\n    where \\<open>unat w = unat (2 ^ n :: 'a word) * unat v\\<close>"], ["proof (prove)\nusing this:\n  2 ^ n udvd w\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        unat w = unat (2 ^ n) * unat v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  unat w = unat (2 ^ n) * unat v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  unat w = unat (2 ^ n) * unat v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "define q where \\<open>q = unat v\\<close>"], ["proof (state)\nthis:\n  q = unat v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  unat w = unat (2 ^ n) * unat v\n  q = unat v", "have unat_w: \\<open>unat w = 2 ^ n * q\\<close>"], ["proof (prove)\nusing this:\n  unat w = unat (2 ^ n) * unat v\n  q = unat v\n\ngoal (1 subgoal):\n 1. unat w = 2 ^ n * q", "by (simp add: *)"], ["proof (state)\nthis:\n  unat w = 2 ^ n * q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  unat w = 2 ^ n * q", "have \\<open>word_of_nat (unat w) = (word_of_nat (2 ^ n * q) :: 'a word)\\<close>"], ["proof (prove)\nusing this:\n  unat w = 2 ^ n * q\n\ngoal (1 subgoal):\n 1. word_of_nat (unat w) = word_of_nat (2 ^ n * q)", "by simp"], ["proof (state)\nthis:\n  word_of_nat (unat w) = word_of_nat (2 ^ n * q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  word_of_nat (unat w) = word_of_nat (2 ^ n * q)", "have w: \\<open>w = 2 ^ n * word_of_nat q\\<close>"], ["proof (prove)\nusing this:\n  word_of_nat (unat w) = word_of_nat (2 ^ n * q)\n\ngoal (1 subgoal):\n 1. w = 2 ^ n * word_of_nat q", "by simp"], ["proof (state)\nthis:\n  w = 2 ^ n * word_of_nat q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  w = 2 ^ n * word_of_nat q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \\<open>q < 2 ^ (LENGTH('a) - n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. q < 2 ^ (LENGTH('a) - n)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> q < 2 ^ (LENGTH('a) - n) \\<Longrightarrow> False", "assume \\<open>\\<not> q < 2 ^ (LENGTH('a) - n)\\<close>"], ["proof (state)\nthis:\n  \\<not> q < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. \\<not> q < 2 ^ (LENGTH('a) - n) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> q < 2 ^ (LENGTH('a) - n)", "have \\<open>2 ^ (LENGTH('a) - n) \\<le> q\\<close>"], ["proof (prove)\nusing this:\n  \\<not> q < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. 2 ^ (LENGTH('a) - n) \\<le> q", "by simp"], ["proof (state)\nthis:\n  2 ^ (LENGTH('a) - n) \\<le> q\n\ngoal (1 subgoal):\n 1. \\<not> q < 2 ^ (LENGTH('a) - n) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  2 ^ (LENGTH('a) - n) \\<le> q", "have \\<open>2 ^ LENGTH('a) \\<le> 2 ^ n * q\\<close>"], ["proof (prove)\nusing this:\n  2 ^ (LENGTH('a) - n) \\<le> q\n\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('a) \\<le> 2 ^ n * q", "by (simp add: l power_add)"], ["proof (state)\nthis:\n  2 ^ LENGTH('a) \\<le> 2 ^ n * q\n\ngoal (1 subgoal):\n 1. \\<not> q < 2 ^ (LENGTH('a) - n) \\<Longrightarrow> False", "with unat_w [symmetric]"], ["proof (chain)\npicking this:\n  2 ^ n * q = unat w\n  2 ^ LENGTH('a) \\<le> 2 ^ n * q", "show False"], ["proof (prove)\nusing this:\n  2 ^ n * q = unat w\n  2 ^ LENGTH('a) \\<le> 2 ^ n * q\n\ngoal (1 subgoal):\n 1. False", "by (metis le_antisym nat_less_le unsigned_less)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>w = 2 ^ n * word_of_nat q;\n                 q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  w = 2 ^ n * word_of_nat q\n  q < 2 ^ (LENGTH('a) - n)", "show thesis"], ["proof (prove)\nusing this:\n  w = 2 ^ n * word_of_nat q\n  q < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  w = 2 ^ n * word_of_nat q\n  q < 2 ^ (LENGTH('a) - n)\n  \\<lbrakk>w = 2 ^ n * word_of_nat ?q; ?q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_alignedE' [elim?]:\n  fixes w :: \\<open>'a::len word\\<close>\n  assumes \\<open>is_aligned w n\\<close>\n  obtains q where \\<open>w = push_bit n (word_of_nat q)\\<close> \\<open>q < 2 ^ (LENGTH('a) - n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>w = push_bit n (word_of_nat q);\n         q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>w = push_bit n (word_of_nat q);\n         q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  is_aligned w n", "obtain q where \\<open>w = 2 ^ n * word_of_nat q\\<close> \\<open>q < 2 ^ (LENGTH('a) - n)\\<close>"], ["proof (prove)\nusing this:\n  is_aligned w n\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>w = 2 ^ n * word_of_nat q;\n         q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_alignedE)"], ["proof (state)\nthis:\n  w = 2 ^ n * word_of_nat q\n  q < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>w = push_bit n (word_of_nat q);\n         q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  w = 2 ^ n * word_of_nat q\n  q < 2 ^ (LENGTH('a) - n)", "have \\<open>w = push_bit n (word_of_nat q)\\<close>"], ["proof (prove)\nusing this:\n  w = 2 ^ n * word_of_nat q\n  q < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. w = push_bit n (word_of_nat q)", "by (simp add: push_bit_eq_mult)"], ["proof (state)\nthis:\n  w = push_bit n (word_of_nat q)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>w = push_bit n (word_of_nat q);\n         q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  \\<lbrakk>w = push_bit n (word_of_nat ?q);\n   ?q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  w = push_bit n (word_of_nat q)", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>w = push_bit n (word_of_nat ?q);\n   ?q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  w = push_bit n (word_of_nat q)\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>q < 2 ^ (LENGTH('a) - n)\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>w = push_bit n (word_of_nat ?q);\n   ?q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  w = push_bit n (word_of_nat q)\n  q < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_mask:\n  \\<open>is_aligned w n \\<longleftrightarrow> w AND mask n = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned w n = (w AND mask n = 0)", "by (simp add: is_aligned_iff_take_bit_eq_0 take_bit_eq_mask)"], ["", "lemma is_aligned_imp_not_bit:\n  \\<open>\\<not> bit w m\\<close> if \\<open>is_aligned w n\\<close> and \\<open>m < n\\<close>\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bit w m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> bit w m", "from \\<open>is_aligned w n\\<close>"], ["proof (chain)\npicking this:\n  is_aligned w n", "obtain q where \\<open>w = push_bit n (word_of_nat q)\\<close> \\<open>q < 2 ^ (LENGTH('a) - n)\\<close>"], ["proof (prove)\nusing this:\n  is_aligned w n\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>w = push_bit n (word_of_nat q);\n         q < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  w = push_bit n (word_of_nat q)\n  q < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. \\<not> bit w m", "moreover"], ["proof (state)\nthis:\n  w = push_bit n (word_of_nat q)\n  q < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. \\<not> bit w m", "have \\<open>\\<not> bit (push_bit n (word_of_nat q :: 'a word)) m\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bit (push_bit n (word_of_nat q)) m", "using \\<open>m < n\\<close>"], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. \\<not> bit (push_bit n (word_of_nat q)) m", "by (simp add: bit_simps)"], ["proof (state)\nthis:\n  \\<not> bit (push_bit n (word_of_nat q)) m\n\ngoal (1 subgoal):\n 1. \\<not> bit w m", "ultimately"], ["proof (chain)\npicking this:\n  w = push_bit n (word_of_nat q)\n  q < 2 ^ (LENGTH('a) - n)\n  \\<not> bit (push_bit n (word_of_nat q)) m", "show ?thesis"], ["proof (prove)\nusing this:\n  w = push_bit n (word_of_nat q)\n  q < 2 ^ (LENGTH('a) - n)\n  \\<not> bit (push_bit n (word_of_nat q)) m\n\ngoal (1 subgoal):\n 1. \\<not> bit w m", "by simp"], ["proof (state)\nthis:\n  \\<not> bit w m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_weaken:\n  \"\\<lbrakk> is_aligned w x; x \\<ge> y \\<rbrakk> \\<Longrightarrow> is_aligned w y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned w x; y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> is_aligned w y", "unfolding is_aligned_iff_dvd_nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ x dvd unat w; y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> 2 ^ y dvd unat w", "by (erule dvd_trans [rotated]) (simp add: le_imp_power_dvd)"], ["", "lemma is_alignedE_pre:\n  fixes w::\"'a::len word\"\n  assumes aligned: \"is_aligned w n\"\n  shows        rl: \"\\<exists>q. w = 2 ^ n * (of_nat q) \\<and> q < 2 ^ (LENGTH('a) - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. w = 2 ^ n * word_of_nat q \\<and> q < 2 ^ (LENGTH('a) - n)", "using aligned is_alignedE"], ["proof (prove)\nusing this:\n  is_aligned w n\n  \\<lbrakk>is_aligned ?w ?n;\n   \\<And>q.\n      \\<lbrakk>?w = 2 ^ ?n * word_of_nat q;\n       q < 2 ^ (LENGTH(?'a) - ?n)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>q. w = 2 ^ n * word_of_nat q \\<and> q < 2 ^ (LENGTH('a) - n)", "by blast"], ["", "lemma aligned_add_aligned:\n  fixes x::\"'a::len word\"\n  assumes aligned1: \"is_aligned x n\"\n  and     aligned2: \"is_aligned y m\"\n  and           lt: \"m \\<le> n\"\n  shows   \"is_aligned (x + y) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned (x + y) m", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> is_aligned (x + y) m\n 2. \\<not> ?P \\<Longrightarrow> is_aligned (x + y) m", "assume nlt: \"n < LENGTH('a)\""], ["proof (state)\nthis:\n  n < LENGTH('a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> is_aligned (x + y) m\n 2. \\<not> ?P \\<Longrightarrow> is_aligned (x + y) m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned (x + y) m", "unfolding is_aligned_iff_dvd_nat dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. unat (x + y) = 2 ^ m * k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. unat (x + y) = 2 ^ m * k", "from aligned2"], ["proof (chain)\npicking this:\n  is_aligned y m", "obtain q2 where yv: \"y = 2 ^ m * of_nat q2\"\n      and q2v: \"q2 < 2 ^ (LENGTH('a) - m)\""], ["proof (prove)\nusing this:\n  is_aligned y m\n\ngoal (1 subgoal):\n 1. (\\<And>q2.\n        \\<lbrakk>y = 2 ^ m * word_of_nat q2;\n         q2 < 2 ^ (LENGTH('a) - m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: is_alignedE)"], ["proof (state)\nthis:\n  y = 2 ^ m * word_of_nat q2\n  q2 < 2 ^ (LENGTH('a) - m)\n\ngoal (1 subgoal):\n 1. \\<exists>k. unat (x + y) = 2 ^ m * k", "from lt"], ["proof (chain)\npicking this:\n  m \\<le> n", "obtain k where kv: \"m + k = n\""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>k. m + k = n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: le_iff_add)"], ["proof (state)\nthis:\n  m + k = n\n\ngoal (1 subgoal):\n 1. \\<exists>k. unat (x + y) = 2 ^ m * k", "with aligned1"], ["proof (chain)\npicking this:\n  is_aligned x n\n  m + k = n", "obtain q1 where xv: \"x = 2 ^ (m + k) * of_nat q1\"\n      and q1v: \"q1 < 2 ^ (LENGTH('a) - (m + k))\""], ["proof (prove)\nusing this:\n  is_aligned x n\n  m + k = n\n\ngoal (1 subgoal):\n 1. (\\<And>q1.\n        \\<lbrakk>x = 2 ^ (m + k) * word_of_nat q1;\n         q1 < 2 ^ (LENGTH('a) - (m + k))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: is_alignedE)"], ["proof (state)\nthis:\n  x = 2 ^ (m + k) * word_of_nat q1\n  q1 < 2 ^ (LENGTH('a) - (m + k))\n\ngoal (1 subgoal):\n 1. \\<exists>k. unat (x + y) = 2 ^ m * k", "have l1: \"2 ^ (m + k) * q1 < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (m + k) * q1 < 2 ^ LENGTH('a)", "by (rule nat_less_power_trans [OF q1v])\n         (subst kv, rule order_less_imp_le [OF nlt])"], ["proof (state)\nthis:\n  2 ^ (m + k) * q1 < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<exists>k. unat (x + y) = 2 ^ m * k", "have l2: \"2 ^ m * q2 < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ m * q2 < 2 ^ LENGTH('a)", "by (rule nat_less_power_trans [OF q2v],\n          rule order_less_imp_le [OF order_le_less_trans])\n         fact+"], ["proof (state)\nthis:\n  2 ^ m * q2 < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<exists>k. unat (x + y) = 2 ^ m * k", "have \"x = of_nat (2 ^ (m + k) *  q1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = word_of_nat (2 ^ (m + k) * q1)", "using xv"], ["proof (prove)\nusing this:\n  x = 2 ^ (m + k) * word_of_nat q1\n\ngoal (1 subgoal):\n 1. x = word_of_nat (2 ^ (m + k) * q1)", "by simp"], ["proof (state)\nthis:\n  x = word_of_nat (2 ^ (m + k) * q1)\n\ngoal (1 subgoal):\n 1. \\<exists>k. unat (x + y) = 2 ^ m * k", "moreover"], ["proof (state)\nthis:\n  x = word_of_nat (2 ^ (m + k) * q1)\n\ngoal (1 subgoal):\n 1. \\<exists>k. unat (x + y) = 2 ^ m * k", "have \"y = of_nat (2 ^ m * q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = word_of_nat (2 ^ m * q2)", "using yv"], ["proof (prove)\nusing this:\n  y = 2 ^ m * word_of_nat q2\n\ngoal (1 subgoal):\n 1. y = word_of_nat (2 ^ m * q2)", "by simp"], ["proof (state)\nthis:\n  y = word_of_nat (2 ^ m * q2)\n\ngoal (1 subgoal):\n 1. \\<exists>k. unat (x + y) = 2 ^ m * k", "ultimately"], ["proof (chain)\npicking this:\n  x = word_of_nat (2 ^ (m + k) * q1)\n  y = word_of_nat (2 ^ m * q2)", "have upls: \"unat x + unat y = 2 ^ m * (2 ^ k * q1 + q2)\""], ["proof (prove)\nusing this:\n  x = word_of_nat (2 ^ (m + k) * q1)\n  y = word_of_nat (2 ^ m * q2)\n\ngoal (1 subgoal):\n 1. unat x + unat y = 2 ^ m * (2 ^ k * q1 + q2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = word_of_nat (2 ^ (m + k) * q1);\n     y = word_of_nat (2 ^ m * q2)\\<rbrakk>\n    \\<Longrightarrow> unat x + unat y = 2 ^ m * (2 ^ k * q1 + q2)", "have f1: \"unat x = 2 ^ (m + k) * q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x = 2 ^ (m + k) * q1", "by (metis (no_types) \\<open>x = of_nat (2 ^ (m + k) * q1)\\<close> l1 nat_mod_lem word_unat.inverse_norm\n                             zero_less_numeral zero_less_power)"], ["proof (state)\nthis:\n  unat x = 2 ^ (m + k) * q1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = word_of_nat (2 ^ (m + k) * q1);\n     y = word_of_nat (2 ^ m * q2)\\<rbrakk>\n    \\<Longrightarrow> unat x + unat y = 2 ^ m * (2 ^ k * q1 + q2)", "have \"unat y = 2 ^ m * q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat y = 2 ^ m * q2", "by (metis (no_types) \\<open>y = of_nat (2 ^ m * q2)\\<close> l2 nat_mod_lem word_unat.inverse_norm\n                             zero_less_numeral zero_less_power)"], ["proof (state)\nthis:\n  unat y = 2 ^ m * q2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = word_of_nat (2 ^ (m + k) * q1);\n     y = word_of_nat (2 ^ m * q2)\\<rbrakk>\n    \\<Longrightarrow> unat x + unat y = 2 ^ m * (2 ^ k * q1 + q2)", "then"], ["proof (chain)\npicking this:\n  unat y = 2 ^ m * q2", "show ?thesis"], ["proof (prove)\nusing this:\n  unat y = 2 ^ m * q2\n\ngoal (1 subgoal):\n 1. unat x + unat y = 2 ^ m * (2 ^ k * q1 + q2)", "using f1"], ["proof (prove)\nusing this:\n  unat y = 2 ^ m * q2\n  unat x = 2 ^ (m + k) * q1\n\ngoal (1 subgoal):\n 1. unat x + unat y = 2 ^ m * (2 ^ k * q1 + q2)", "by (simp add: power_add semiring_normalization_rules(34))"], ["proof (state)\nthis:\n  unat x + unat y = 2 ^ m * (2 ^ k * q1 + q2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unat x + unat y = 2 ^ m * (2 ^ k * q1 + q2)\n\ngoal (1 subgoal):\n 1. \\<exists>k. unat (x + y) = 2 ^ m * k", "(* (2 ^ k * q1 + q2) *)"], ["proof (state)\nthis:\n  unat x + unat y = 2 ^ m * (2 ^ k * q1 + q2)\n\ngoal (1 subgoal):\n 1. \\<exists>k. unat (x + y) = 2 ^ m * k", "show \"\\<exists>d. unat (x + y) = 2 ^ m * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d. unat (x + y) = 2 ^ m * d", "proof (cases \"unat x + unat y < 2 ^ LENGTH('a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d\n 2. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "case True"], ["proof (state)\nthis:\n  unat x + unat y < 2 ^ LENGTH('a)\n\ngoal (2 subgoals):\n 1. unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d\n 2. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "have \"unat (x + y) = unat x + unat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (x + y) = unat x + unat y", "by (subst unat_plus_if', rule if_P) fact"], ["proof (state)\nthis:\n  unat (x + y) = unat x + unat y\n\ngoal (2 subgoals):\n 1. unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d\n 2. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "also"], ["proof (state)\nthis:\n  unat (x + y) = unat x + unat y\n\ngoal (2 subgoals):\n 1. unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d\n 2. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "have \"\\<dots> = 2 ^ m * (2 ^ k * q1 + q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x + unat y = 2 ^ m * (2 ^ k * q1 + q2)", "by (rule upls)"], ["proof (state)\nthis:\n  unat x + unat y = 2 ^ m * (2 ^ k * q1 + q2)\n\ngoal (2 subgoals):\n 1. unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d\n 2. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "finally"], ["proof (chain)\npicking this:\n  unat (x + y) = 2 ^ m * (2 ^ k * q1 + q2)", "show ?thesis"], ["proof (prove)\nusing this:\n  unat (x + y) = 2 ^ m * (2 ^ k * q1 + q2)\n\ngoal (1 subgoal):\n 1. \\<exists>d. unat (x + y) = 2 ^ m * d", ".."], ["proof (state)\nthis:\n  \\<exists>d. unat (x + y) = 2 ^ m * d\n\ngoal (1 subgoal):\n 1. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "case False"], ["proof (state)\nthis:\n  \\<not> unat x + unat y < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "then"], ["proof (chain)\npicking this:\n  \\<not> unat x + unat y < 2 ^ LENGTH('a)", "have \"unat (x + y) = (unat x + unat y) mod 2 ^ LENGTH('a)\""], ["proof (prove)\nusing this:\n  \\<not> unat x + unat y < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (x + y) = (unat x + unat y) mod 2 ^ LENGTH('a)", "by (subst unat_word_ariths(1)) simp"], ["proof (state)\nthis:\n  unat (x + y) = (unat x + unat y) mod 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "also"], ["proof (state)\nthis:\n  unat (x + y) = (unat x + unat y) mod 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "have \"\\<dots> = (2 ^ m * (2 ^ k * q1 + q2)) mod 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unat x + unat y) mod 2 ^ LENGTH('a) =\n    2 ^ m * (2 ^ k * q1 + q2) mod 2 ^ LENGTH('a)", "by (subst upls, rule refl)"], ["proof (state)\nthis:\n  (unat x + unat y) mod 2 ^ LENGTH('a) =\n  2 ^ m * (2 ^ k * q1 + q2) mod 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "also"], ["proof (state)\nthis:\n  (unat x + unat y) mod 2 ^ LENGTH('a) =\n  2 ^ m * (2 ^ k * q1 + q2) mod 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "have \"\\<dots> = 2 ^ m * ((2 ^ k * q1 +  q2) mod 2 ^ (LENGTH('a) - m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ m * (2 ^ k * q1 + q2) mod 2 ^ LENGTH('a) =\n    2 ^ m * ((2 ^ k * q1 + q2) mod 2 ^ (LENGTH('a) - m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ m * (2 ^ k * q1 + q2) mod 2 ^ LENGTH('a) =\n    2 ^ m * ((2 ^ k * q1 + q2) mod 2 ^ (LENGTH('a) - m))", "have \"m \\<le> len_of (TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> LENGTH('a)", "by (meson le_trans less_imp_le_nat lt nlt)"], ["proof (state)\nthis:\n  m \\<le> LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ m * (2 ^ k * q1 + q2) mod 2 ^ LENGTH('a) =\n    2 ^ m * ((2 ^ k * q1 + q2) mod 2 ^ (LENGTH('a) - m))", "then"], ["proof (chain)\npicking this:\n  m \\<le> LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<le> LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ m * (2 ^ k * q1 + q2) mod 2 ^ LENGTH('a) =\n    2 ^ m * ((2 ^ k * q1 + q2) mod 2 ^ (LENGTH('a) - m))", "by (metis mult_mod_right ordered_cancel_comm_monoid_diff_class.add_diff_inverse power_add)"], ["proof (state)\nthis:\n  2 ^ m * (2 ^ k * q1 + q2) mod 2 ^ LENGTH('a) =\n  2 ^ m * ((2 ^ k * q1 + q2) mod 2 ^ (LENGTH('a) - m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ m * (2 ^ k * q1 + q2) mod 2 ^ LENGTH('a) =\n  2 ^ m * ((2 ^ k * q1 + q2) mod 2 ^ (LENGTH('a) - m))\n\ngoal (1 subgoal):\n 1. \\<not> unat x + unat y < 2 ^ LENGTH('a) \\<Longrightarrow>\n    \\<exists>d. unat (x + y) = 2 ^ m * d", "finally"], ["proof (chain)\npicking this:\n  unat (x + y) = 2 ^ m * ((2 ^ k * q1 + q2) mod 2 ^ (LENGTH('a) - m))", "show ?thesis"], ["proof (prove)\nusing this:\n  unat (x + y) = 2 ^ m * ((2 ^ k * q1 + q2) mod 2 ^ (LENGTH('a) - m))\n\ngoal (1 subgoal):\n 1. \\<exists>d. unat (x + y) = 2 ^ m * d", ".."], ["proof (state)\nthis:\n  \\<exists>d. unat (x + y) = 2 ^ m * d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d. unat (x + y) = 2 ^ m * d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_aligned (x + y) m\n\ngoal (1 subgoal):\n 1. \\<not> n < LENGTH('a) \\<Longrightarrow> is_aligned (x + y) m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < LENGTH('a) \\<Longrightarrow> is_aligned (x + y) m", "assume \"\\<not> n < LENGTH('a)\""], ["proof (state)\nthis:\n  \\<not> n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> n < LENGTH('a) \\<Longrightarrow> is_aligned (x + y) m", "with assms"], ["proof (chain)\npicking this:\n  is_aligned x n\n  is_aligned y m\n  m \\<le> n\n  \\<not> n < LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_aligned x n\n  is_aligned y m\n  m \\<le> n\n  \\<not> n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. is_aligned (x + y) m", "by (simp add: is_aligned_mask not_less take_bit_eq_mod power_overflow word_arith_nat_defs(7) flip: take_bit_eq_mask)"], ["proof (state)\nthis:\n  is_aligned (x + y) m\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary aligned_sub_aligned:\n  \"\\<lbrakk>is_aligned (x::'a::len word) n; is_aligned y m; m \\<le> n\\<rbrakk>\n   \\<Longrightarrow> is_aligned (x - y) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; is_aligned y m; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> is_aligned (x - y) m", "apply (simp del: add_uminus_conv_diff add:diff_conv_add_uminus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; is_aligned y m; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> is_aligned (x + - y) m", "apply (erule aligned_add_aligned, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned y m; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> is_aligned (- y) m", "apply (erule is_alignedE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>m \\<le> n; y = 2 ^ m * word_of_nat q;\n        q < 2 ^ (LENGTH('a) - m)\\<rbrakk>\n       \\<Longrightarrow> is_aligned (- y) m", "apply (rule_tac k=\"- of_nat q\" in is_alignedI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>m \\<le> n; y = 2 ^ m * word_of_nat q;\n        q < 2 ^ (LENGTH('a) - m)\\<rbrakk>\n       \\<Longrightarrow> - y = 2 ^ m * - word_of_nat q", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_aligned_shift:\n  fixes k::\"'a::len word\"\n  shows \"is_aligned (k << m) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned (k << m) m", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> is_aligned (k << m) m\n 2. \\<not> ?P \\<Longrightarrow> is_aligned (k << m) m", "assume mv: \"m < LENGTH('a)\""], ["proof (state)\nthis:\n  m < LENGTH('a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> is_aligned (k << m) m\n 2. \\<not> ?P \\<Longrightarrow> is_aligned (k << m) m", "from mv"], ["proof (chain)\npicking this:\n  m < LENGTH('a)", "obtain q where mq: \"m + q = LENGTH('a)\" and \"0 < q\""], ["proof (prove)\nusing this:\n  m < LENGTH('a)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>m + q = LENGTH('a); 0 < q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: less_imp_add_positive)"], ["proof (state)\nthis:\n  m + q = LENGTH('a)\n  0 < q\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> is_aligned (k << m) m\n 2. \\<not> ?P \\<Longrightarrow> is_aligned (k << m) m", "have \"(2::nat) ^ m dvd unat (k << m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ m dvd unat (k << m)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. unat (k << m) = 2 ^ m * ?k", "have kv: \"(unat k div 2 ^ q) * 2 ^ q + unat k mod 2 ^ q = unat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat k div 2 ^ q * 2 ^ q + unat k mod 2 ^ q = unat k", "by (rule div_mult_mod_eq)"], ["proof (state)\nthis:\n  unat k div 2 ^ q * 2 ^ q + unat k mod 2 ^ q = unat k\n\ngoal (1 subgoal):\n 1. unat (k << m) = 2 ^ m * ?k", "have \"unat (k << m) = unat (2 ^ m * k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (k << m) = unat (2 ^ m * k)", "by (simp add: shiftl_t2n)"], ["proof (state)\nthis:\n  unat (k << m) = unat (2 ^ m * k)\n\ngoal (1 subgoal):\n 1. unat (k << m) = 2 ^ m * ?k", "also"], ["proof (state)\nthis:\n  unat (k << m) = unat (2 ^ m * k)\n\ngoal (1 subgoal):\n 1. unat (k << m) = 2 ^ m * ?k", "have \"\\<dots> = (2 ^ m * unat k) mod (2 ^ LENGTH('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (2 ^ m * k) = 2 ^ m * unat k mod 2 ^ LENGTH('a)", "using mv"], ["proof (prove)\nusing this:\n  m < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (2 ^ m * k) = 2 ^ m * unat k mod 2 ^ LENGTH('a)", "by (simp add: unat_word_ariths(2))"], ["proof (state)\nthis:\n  unat (2 ^ m * k) = 2 ^ m * unat k mod 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (k << m) = 2 ^ m * ?k", "also"], ["proof (state)\nthis:\n  unat (2 ^ m * k) = 2 ^ m * unat k mod 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (k << m) = 2 ^ m * ?k", "have \"\\<dots> = 2 ^ m * (unat k mod 2 ^ q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ m * unat k mod 2 ^ LENGTH('a) = 2 ^ m * (unat k mod 2 ^ q)", "by (subst mq [symmetric], subst power_add, subst mod_mult2_eq) simp"], ["proof (state)\nthis:\n  2 ^ m * unat k mod 2 ^ LENGTH('a) = 2 ^ m * (unat k mod 2 ^ q)\n\ngoal (1 subgoal):\n 1. unat (k << m) = 2 ^ m * ?k", "finally"], ["proof (chain)\npicking this:\n  unat (k << m) = 2 ^ m * (unat k mod 2 ^ q)", "show \"unat (k << m) = 2 ^ m * (unat k mod 2 ^ q)\""], ["proof (prove)\nusing this:\n  unat (k << m) = 2 ^ m * (unat k mod 2 ^ q)\n\ngoal (1 subgoal):\n 1. unat (k << m) = 2 ^ m * (unat k mod 2 ^ q)", "."], ["proof (state)\nthis:\n  unat (k << m) = 2 ^ m * (unat k mod 2 ^ q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ m dvd unat (k << m)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> is_aligned (k << m) m\n 2. \\<not> ?P \\<Longrightarrow> is_aligned (k << m) m", "then"], ["proof (chain)\npicking this:\n  2 ^ m dvd unat (k << m)", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ m dvd unat (k << m)\n\ngoal (1 subgoal):\n 1. is_aligned (k << m) m", "by (unfold is_aligned_iff_dvd_nat)"], ["proof (state)\nthis:\n  is_aligned (k << m) m\n\ngoal (1 subgoal):\n 1. \\<not> m < LENGTH('a) \\<Longrightarrow> is_aligned (k << m) m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> m < LENGTH('a) \\<Longrightarrow> is_aligned (k << m) m", "assume \"\\<not> m < LENGTH('a)\""], ["proof (state)\nthis:\n  \\<not> m < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> m < LENGTH('a) \\<Longrightarrow> is_aligned (k << m) m", "then"], ["proof (chain)\npicking this:\n  \\<not> m < LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> m < LENGTH('a)\n\ngoal (1 subgoal):\n 1. is_aligned (k << m) m", "by (simp add: not_less power_overflow is_aligned_mask shiftl_zero_size word_size)"], ["proof (state)\nthis:\n  is_aligned (k << m) m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma word_mod_by_0: \"k mod (0::'a::len word) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k mod 0 = k", "by (simp add: word_arith_nat_mod)"], ["", "lemma aligned_mod_eq_0:\n  fixes p::\"'a::len word\"\n  assumes al: \"is_aligned p sz\"\n  shows   \"p mod 2 ^ sz = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p mod 2 ^ sz = 0", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> p mod 2 ^ sz = 0\n 2. \\<not> ?P \\<Longrightarrow> p mod 2 ^ sz = 0", "assume szv: \"sz < LENGTH('a)\""], ["proof (state)\nthis:\n  sz < LENGTH('a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> p mod 2 ^ sz = 0\n 2. \\<not> ?P \\<Longrightarrow> p mod 2 ^ sz = 0", "with al"], ["proof (chain)\npicking this:\n  is_aligned p sz\n  sz < LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_aligned p sz\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. p mod 2 ^ sz = 0", "unfolding is_aligned_iff_dvd_nat"], ["proof (prove)\nusing this:\n  2 ^ sz dvd unat p\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. p mod 2 ^ sz = 0", "by (simp add: and_mask_dvd_nat p2_gt_0 word_mod_2p_is_mask)"], ["proof (state)\nthis:\n  p mod 2 ^ sz = 0\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow> p mod 2 ^ sz = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow> p mod 2 ^ sz = 0", "assume \"\\<not> sz < LENGTH('a)\""], ["proof (state)\nthis:\n  \\<not> sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow> p mod 2 ^ sz = 0", "with al"], ["proof (chain)\npicking this:\n  is_aligned p sz\n  \\<not> sz < LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_aligned p sz\n  \\<not> sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. p mod 2 ^ sz = 0", "by (simp add: is_aligned_mask flip: take_bit_eq_mask take_bit_eq_mod)"], ["proof (state)\nthis:\n  p mod 2 ^ sz = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_triv: \"is_aligned (2 ^ n ::'a::len word) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned (2 ^ n) n", "by (rule is_alignedI [where k = 1], simp)"], ["", "lemma is_aligned_mult_triv1: \"is_aligned (2 ^ n * x  ::'a::len word) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned (2 ^ n * x) n", "by (rule is_alignedI [OF refl])"], ["", "lemma is_aligned_mult_triv2: \"is_aligned (x * 2 ^ n ::'a::len word) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned (x * 2 ^ n) n", "by (subst mult.commute, simp add: is_aligned_mult_triv1)"], ["", "lemma word_power_less_0_is_0:\n  fixes x :: \"'a::len word\"\n  shows \"x < a ^ 0 \\<Longrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < a ^ 0 \\<Longrightarrow> x = 0", "by simp"], ["", "lemma is_aligned_no_wrap:\n  fixes off :: \"'a::len word\"\n  fixes ptr :: \"'a::len word\"\n  assumes al: \"is_aligned ptr sz\"\n  and    off: \"off < 2 ^ sz\"\n  shows  \"unat ptr + unat off < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "have szv: \"sz < LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a)", "using off p2_gt_0 word_neq_0_conv"], ["proof (prove)\nusing this:\n  off < 2 ^ sz\n  (0 < 2 ^ ?n) = (?n < LENGTH(?'a))\n  (?w \\<noteq> 0) = (0 < ?w)\n\ngoal (1 subgoal):\n 1. sz < LENGTH('a)", "by fastforce"], ["proof (state)\nthis:\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "from al"], ["proof (chain)\npicking this:\n  is_aligned ptr sz", "obtain q where ptrq: \"ptr = 2 ^ sz * of_nat q\" and\n    qv: \"q < 2 ^ (LENGTH('a) - sz)\""], ["proof (prove)\nusing this:\n  is_aligned ptr sz\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>ptr = 2 ^ sz * word_of_nat q;\n         q < 2 ^ (LENGTH('a) - sz)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: is_alignedE)"], ["proof (state)\nthis:\n  ptr = 2 ^ sz * word_of_nat q\n  q < 2 ^ (LENGTH('a) - sz)\n\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "proof (cases \"sz = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sz = 0 \\<Longrightarrow> unat ptr + unat off < 2 ^ LENGTH('a)\n 2. sz \\<noteq> 0 \\<Longrightarrow> unat ptr + unat off < 2 ^ LENGTH('a)", "case True"], ["proof (state)\nthis:\n  sz = 0\n\ngoal (2 subgoals):\n 1. sz = 0 \\<Longrightarrow> unat ptr + unat off < 2 ^ LENGTH('a)\n 2. sz \\<noteq> 0 \\<Longrightarrow> unat ptr + unat off < 2 ^ LENGTH('a)", "then"], ["proof (chain)\npicking this:\n  sz = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  sz = 0\n\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "using off ptrq qv"], ["proof (prove)\nusing this:\n  sz = 0\n  off < 2 ^ sz\n  ptr = 2 ^ sz * word_of_nat q\n  q < 2 ^ (LENGTH('a) - sz)\n\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "by simp"], ["proof (state)\nthis:\n  unat ptr + unat off < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. sz \\<noteq> 0 \\<Longrightarrow> unat ptr + unat off < 2 ^ LENGTH('a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sz \\<noteq> 0 \\<Longrightarrow> unat ptr + unat off < 2 ^ LENGTH('a)", "case False"], ["proof (state)\nthis:\n  sz \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sz \\<noteq> 0 \\<Longrightarrow> unat ptr + unat off < 2 ^ LENGTH('a)", "then"], ["proof (chain)\npicking this:\n  sz \\<noteq> 0", "have sne: \"0 < sz\""], ["proof (prove)\nusing this:\n  sz \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < sz", ".."], ["proof (state)\nthis:\n  0 < sz\n\ngoal (1 subgoal):\n 1. sz \\<noteq> 0 \\<Longrightarrow> unat ptr + unat off < 2 ^ LENGTH('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "have uq: \"unat (of_nat q ::'a::len word) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (word_of_nat q) = q", "apply (subst unat_of_nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q mod 2 ^ LENGTH('a) = q", "apply (rule mod_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q < 2 ^ LENGTH('a)", "apply (rule order_less_trans [OF qv])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (LENGTH('a) - sz) < 2 ^ LENGTH('a)", "apply (rule power_strict_increasing [OF diff_less [OF sne]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < LENGTH('a)\n 2. 1 < 2", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unat (word_of_nat q) = q\n\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "have uptr: \"unat ptr = 2 ^ sz * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ptr = 2 ^ sz * q", "apply (subst ptrq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (2 ^ sz * word_of_nat q) = 2 ^ sz * q", "apply (subst iffD1 [OF unat_mult_lem])"], ["proof (prove)\ngoal (2 subgoals):\n 1. unat (2 ^ sz) * unat (word_of_nat q) < 2 ^ LENGTH('a)\n 2. unat (2 ^ sz) * unat (word_of_nat q) = 2 ^ sz * q", "apply (subst unat_power_lower [OF szv])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 2 ^ sz * unat (word_of_nat q) < 2 ^ LENGTH('a)\n 2. unat (2 ^ sz) * unat (word_of_nat q) = 2 ^ sz * q", "apply (subst uq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 2 ^ sz * q < 2 ^ LENGTH('a)\n 2. unat (2 ^ sz) * unat (word_of_nat q) = 2 ^ sz * q", "apply (rule nat_less_power_trans [OF qv order_less_imp_le [OF szv]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (2 ^ sz) * unat (word_of_nat q) = 2 ^ sz * q", "apply (subst uq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (2 ^ sz) * q = 2 ^ sz * q", "apply (subst unat_power_lower [OF szv])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ sz * q = 2 ^ sz * q", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unat ptr = 2 ^ sz * q\n\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "show \"unat ptr + unat off < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "using szv"], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat ptr + unat off < 2 ^ LENGTH('a)", "apply (subst uptr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow> 2 ^ sz * q + unat off < 2 ^ LENGTH('a)", "apply (subst mult.commute, rule nat_add_offset_less [OF _ qv])"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> unat off < 2 ^ sz\n 2. sz < LENGTH('a) \\<Longrightarrow> LENGTH('a) = LENGTH('a) - sz + sz", "apply (rule order_less_le_trans [OF unat_mono [OF off] order_eq_refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> unat (2 ^ sz) = 2 ^ sz\n 2. sz < LENGTH('a) \\<Longrightarrow> LENGTH('a) = LENGTH('a) - sz + sz", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unat ptr + unat off < 2 ^ LENGTH('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unat ptr + unat off < 2 ^ LENGTH('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unat ptr + unat off < 2 ^ LENGTH('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_no_wrap':\n  fixes ptr :: \"'a::len word\"\n  assumes al: \"is_aligned ptr sz\"\n  and    off: \"off < 2 ^ sz\"\n  shows  \"ptr \\<le> ptr + off\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ptr \\<le> ptr + off", "by (subst no_plus_overflow_unat_size, subst word_size, rule is_aligned_no_wrap) fact+"], ["", "lemma is_aligned_no_overflow':\n  fixes p :: \"'a::len word\"\n  assumes al: \"is_aligned p n\"\n  shows \"p \\<le> p + (2 ^ n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> p + (2 ^ n - 1)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> p \\<le> p + (2 ^ n - 1)\n 2. \\<not> ?P \\<Longrightarrow> p \\<le> p + (2 ^ n - 1)", "assume \"n<LENGTH('a)\""], ["proof (state)\nthis:\n  n < LENGTH('a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> p \\<le> p + (2 ^ n - 1)\n 2. \\<not> ?P \\<Longrightarrow> p \\<le> p + (2 ^ n - 1)", "with al"], ["proof (chain)\npicking this:\n  is_aligned p n\n  n < LENGTH('a)", "have \"2^n - (1::'a::len word) < 2^n\""], ["proof (prove)\nusing this:\n  is_aligned p n\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ n - 1 < 2 ^ n", "by (simp add: word_less_nat_alt unat_sub_if_size)"], ["proof (state)\nthis:\n  2 ^ n - 1 < 2 ^ n\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> p \\<le> p + (2 ^ n - 1)\n 2. \\<not> ?P \\<Longrightarrow> p \\<le> p + (2 ^ n - 1)", "with al"], ["proof (chain)\npicking this:\n  is_aligned p n\n  2 ^ n - 1 < 2 ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  is_aligned p n\n  2 ^ n - 1 < 2 ^ n\n\ngoal (1 subgoal):\n 1. p \\<le> p + (2 ^ n - 1)", "by (rule is_aligned_no_wrap')"], ["proof (state)\nthis:\n  p \\<le> p + (2 ^ n - 1)\n\ngoal (1 subgoal):\n 1. \\<not> n < LENGTH('a) \\<Longrightarrow> p \\<le> p + (2 ^ n - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < LENGTH('a) \\<Longrightarrow> p \\<le> p + (2 ^ n - 1)", "assume \"\\<not> n<LENGTH('a)\""], ["proof (state)\nthis:\n  \\<not> n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> n < LENGTH('a) \\<Longrightarrow> p \\<le> p + (2 ^ n - 1)", "with al"], ["proof (chain)\npicking this:\n  is_aligned p n\n  \\<not> n < LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_aligned p n\n  \\<not> n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. p \\<le> p + (2 ^ n - 1)", "by (simp add: not_less power_overflow is_aligned_mask mask_2pm1)"], ["proof (state)\nthis:\n  p \\<le> p + (2 ^ n - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_no_overflow:\n  \"is_aligned ptr sz \\<Longrightarrow> ptr \\<le> ptr + 2^sz - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned ptr sz \\<Longrightarrow> ptr \\<le> ptr + 2 ^ sz - 1", "by (drule is_aligned_no_overflow') (simp add: field_simps)"], ["", "lemma replicate_not_True:\n  \"\\<And>n. xs = replicate n False \\<Longrightarrow> True \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. xs = replicate n False \\<Longrightarrow> True \\<notin> set xs", "by (induct xs) auto"], ["", "lemma map_zip_replicate_False_xor:\n  \"n = length xs \\<Longrightarrow> map (\\<lambda>(x, y). x = (\\<not> y)) (zip xs (replicate n False)) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = length xs \\<Longrightarrow>\n    map2 (\\<lambda>x y. x = (\\<not> y)) xs (replicate n False) = xs", "by (induct xs arbitrary: n, auto)"], ["", "lemma drop_minus_lem:\n  \"\\<lbrakk> n \\<le> length xs; 0 < n; n' = length xs \\<rbrakk> \\<Longrightarrow> drop (n' - n) xs = rev xs ! (n - 1)  # drop (Suc (n' - n)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length xs; 0 < n; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> drop (n' - n) xs =\n                      rev xs ! (n - 1) # drop (Suc (n' - n)) xs", "proof (induct xs arbitrary: n n')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>n \\<le> length []; 0 < n; n' = length []\\<rbrakk>\n       \\<Longrightarrow> drop (n' - n) [] =\n                         rev [] ! (n - 1) # drop (Suc (n' - n)) []\n 2. \\<And>a xs n n'.\n       \\<lbrakk>\\<And>n n'.\n                   \\<lbrakk>n \\<le> length xs; 0 < n;\n                    n' = length xs\\<rbrakk>\n                   \\<Longrightarrow> drop (n' - n) xs =\n                                     rev xs ! (n - 1) #\n                                     drop (Suc (n' - n)) xs;\n        n \\<le> length (a # xs); 0 < n; n' = length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> drop (n' - n) (a # xs) =\n                         rev (a # xs) ! (n - 1) #\n                         drop (Suc (n' - n)) (a # xs)", "case Nil"], ["proof (state)\nthis:\n  n \\<le> length []\n  0 < n\n  n' = length []\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>n \\<le> length []; 0 < n; n' = length []\\<rbrakk>\n       \\<Longrightarrow> drop (n' - n) [] =\n                         rev [] ! (n - 1) # drop (Suc (n' - n)) []\n 2. \\<And>a xs n n'.\n       \\<lbrakk>\\<And>n n'.\n                   \\<lbrakk>n \\<le> length xs; 0 < n;\n                    n' = length xs\\<rbrakk>\n                   \\<Longrightarrow> drop (n' - n) xs =\n                                     rev xs ! (n - 1) #\n                                     drop (Suc (n' - n)) xs;\n        n \\<le> length (a # xs); 0 < n; n' = length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> drop (n' - n) (a # xs) =\n                         rev (a # xs) ! (n - 1) #\n                         drop (Suc (n' - n)) (a # xs)", "then"], ["proof (chain)\npicking this:\n  n \\<le> length []\n  0 < n\n  n' = length []", "show ?case"], ["proof (prove)\nusing this:\n  n \\<le> length []\n  0 < n\n  n' = length []\n\ngoal (1 subgoal):\n 1. drop (n' - n) [] = rev [] ! (n - 1) # drop (Suc (n' - n)) []", "by simp"], ["proof (state)\nthis:\n  drop (n' - n) [] = rev [] ! (n - 1) # drop (Suc (n' - n)) []\n\ngoal (1 subgoal):\n 1. \\<And>a xs n n'.\n       \\<lbrakk>\\<And>n n'.\n                   \\<lbrakk>n \\<le> length xs; 0 < n;\n                    n' = length xs\\<rbrakk>\n                   \\<Longrightarrow> drop (n' - n) xs =\n                                     rev xs ! (n - 1) #\n                                     drop (Suc (n' - n)) xs;\n        n \\<le> length (a # xs); 0 < n; n' = length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> drop (n' - n) (a # xs) =\n                         rev (a # xs) ! (n - 1) #\n                         drop (Suc (n' - n)) (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs n n'.\n       \\<lbrakk>\\<And>n n'.\n                   \\<lbrakk>n \\<le> length xs; 0 < n;\n                    n' = length xs\\<rbrakk>\n                   \\<Longrightarrow> drop (n' - n) xs =\n                                     rev xs ! (n - 1) #\n                                     drop (Suc (n' - n)) xs;\n        n \\<le> length (a # xs); 0 < n; n' = length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> drop (n' - n) (a # xs) =\n                         rev (a # xs) ! (n - 1) #\n                         drop (Suc (n' - n)) (a # xs)", "case (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>?n \\<le> length ys; 0 < ?n; ?n' = length ys\\<rbrakk>\n  \\<Longrightarrow> drop (?n' - ?n) ys =\n                    rev ys ! (?n - 1) # drop (Suc (?n' - ?n)) ys\n  n \\<le> length (y # ys)\n  0 < n\n  n' = length (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs n n'.\n       \\<lbrakk>\\<And>n n'.\n                   \\<lbrakk>n \\<le> length xs; 0 < n;\n                    n' = length xs\\<rbrakk>\n                   \\<Longrightarrow> drop (n' - n) xs =\n                                     rev xs ! (n - 1) #\n                                     drop (Suc (n' - n)) xs;\n        n \\<le> length (a # xs); 0 < n; n' = length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> drop (n' - n) (a # xs) =\n                         rev (a # xs) ! (n - 1) #\n                         drop (Suc (n' - n)) (a # xs)", "from Cons.prems"], ["proof (chain)\npicking this:\n  n \\<le> length (y # ys)\n  0 < n\n  n' = length (y # ys)", "show ?case"], ["proof (prove)\nusing this:\n  n \\<le> length (y # ys)\n  0 < n\n  n' = length (y # ys)\n\ngoal (1 subgoal):\n 1. drop (n' - n) (y # ys) =\n    rev (y # ys) ! (n - 1) # drop (Suc (n' - n)) (y # ys)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> Suc (length ys); 0 < n; n' = Suc (length ys)\\<rbrakk>\n    \\<Longrightarrow> drop (Suc (length ys) - n) (y # ys) =\n                      (rev ys @ [y]) ! (n - Suc 0) #\n                      drop (Suc (length ys) - n) ys", "apply (cases \"n = Suc (length ys)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> Suc (length ys); 0 < n; n' = Suc (length ys);\n     n = Suc (length ys)\\<rbrakk>\n    \\<Longrightarrow> drop (Suc (length ys) - n) (y # ys) =\n                      (rev ys @ [y]) ! (n - Suc 0) #\n                      drop (Suc (length ys) - n) ys\n 2. \\<lbrakk>n \\<le> Suc (length ys); 0 < n; n' = Suc (length ys);\n     n \\<noteq> Suc (length ys)\\<rbrakk>\n    \\<Longrightarrow> drop (Suc (length ys) - n) (y # ys) =\n                      (rev ys @ [y]) ! (n - Suc 0) #\n                      drop (Suc (length ys) - n) ys", "apply (simp add: nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> Suc (length ys); 0 < n; n' = Suc (length ys);\n     n \\<noteq> Suc (length ys)\\<rbrakk>\n    \\<Longrightarrow> drop (Suc (length ys) - n) (y # ys) =\n                      (rev ys @ [y]) ! (n - Suc 0) #\n                      drop (Suc (length ys) - n) ys", "apply (simp add: Suc_diff_le Cons.hyps nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> Suc (length ys); 0 < n; n' = Suc (length ys);\n     n \\<noteq> Suc (length ys)\\<rbrakk>\n    \\<Longrightarrow> \\<not> n - Suc 0 < length ys \\<longrightarrow>\n                      rev ys ! 0 = y", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> Suc (length ys); 0 < n; n' = Suc (length ys);\n     n \\<noteq> Suc (length ys); \\<not> n - Suc 0 < length ys\\<rbrakk>\n    \\<Longrightarrow> rev ys ! 0 = y", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  drop (n' - n) (y # ys) =\n  rev (y # ys) ! (n - 1) # drop (Suc (n' - n)) (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma drop_minus:\n  \"\\<lbrakk> n < length xs; n' = length xs \\<rbrakk> \\<Longrightarrow> drop (n' - Suc n) xs = rev xs ! n  # drop (n' - n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length xs; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> drop (n' - Suc n) xs = rev xs ! n # drop (n' - n) xs", "apply (subst drop_minus_lem)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>n < length xs; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> Suc n \\<le> length xs\n 2. \\<lbrakk>n < length xs; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> 0 < Suc n\n 3. \\<lbrakk>n < length xs; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> n' = length xs\n 4. \\<lbrakk>n < length xs; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> rev xs ! (Suc n - 1) # drop (Suc (n' - Suc n)) xs =\n                      rev xs ! n # drop (n' - n) xs", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n < length xs; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> 0 < Suc n\n 2. \\<lbrakk>n < length xs; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> n' = length xs\n 3. \\<lbrakk>n < length xs; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> rev xs ! (Suc n - 1) # drop (Suc (n' - Suc n)) xs =\n                      rev xs ! n # drop (n' - n) xs", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length xs; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> n' = length xs\n 2. \\<lbrakk>n < length xs; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> rev xs ! (Suc n - 1) # drop (Suc (n' - Suc n)) xs =\n                      rev xs ! n # drop (n' - n) xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length xs; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> rev xs ! (Suc n - 1) # drop (Suc (n' - Suc n)) xs =\n                      rev xs ! n # drop (n' - n) xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length xs; n' = length xs\\<rbrakk>\n    \\<Longrightarrow> drop (Suc (length xs - Suc n)) xs =\n                      drop (length xs - n) xs", "apply (cases \"length xs\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>n < length xs; n' = length xs; length xs = Suc nat\\<rbrakk>\n       \\<Longrightarrow> drop (Suc (length xs - Suc n)) xs =\n                         drop (length xs - n) xs", "apply (simp add: Suc_diff_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aligned_add_xor:\n  \\<open>(x + 2 ^ n) XOR 2 ^ n = x\\<close>\n  if al: \\<open>is_aligned (x::'a::len word) n'\\<close> and le: \\<open>n < n'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + 2 ^ n XOR 2 ^ n = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x + 2 ^ n XOR 2 ^ n = x", "have \\<open>\\<not> bit x n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bit x n", "using that"], ["proof (prove)\nusing this:\n  is_aligned x n'\n  n < n'\n\ngoal (1 subgoal):\n 1. \\<not> bit x n", "by (rule is_aligned_imp_not_bit)"], ["proof (state)\nthis:\n  \\<not> bit x n\n\ngoal (1 subgoal):\n 1. x + 2 ^ n XOR 2 ^ n = x", "then"], ["proof (chain)\npicking this:\n  \\<not> bit x n", "have \\<open>x + 2 ^ n = x OR 2 ^ n\\<close>"], ["proof (prove)\nusing this:\n  \\<not> bit x n\n\ngoal (1 subgoal):\n 1. x + 2 ^ n = x OR 2 ^ n", "by (subst disjunctive_add) (auto simp add: bit_simps disjunctive_add)"], ["proof (state)\nthis:\n  x + 2 ^ n = x OR 2 ^ n\n\ngoal (1 subgoal):\n 1. x + 2 ^ n XOR 2 ^ n = x", "moreover"], ["proof (state)\nthis:\n  x + 2 ^ n = x OR 2 ^ n\n\ngoal (1 subgoal):\n 1. x + 2 ^ n XOR 2 ^ n = x", "have \\<open>(x OR 2 ^ n) XOR 2 ^ n = x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x OR 2 ^ n) XOR 2 ^ n = x", "by (rule bit_word_eqI) (auto simp add: bit_simps \\<open>\\<not> bit x n\\<close>)"], ["proof (state)\nthis:\n  (x OR 2 ^ n) XOR 2 ^ n = x\n\ngoal (1 subgoal):\n 1. x + 2 ^ n XOR 2 ^ n = x", "ultimately"], ["proof (chain)\npicking this:\n  x + 2 ^ n = x OR 2 ^ n\n  (x OR 2 ^ n) XOR 2 ^ n = x", "show ?thesis"], ["proof (prove)\nusing this:\n  x + 2 ^ n = x OR 2 ^ n\n  (x OR 2 ^ n) XOR 2 ^ n = x\n\ngoal (1 subgoal):\n 1. x + 2 ^ n XOR 2 ^ n = x", "by simp"], ["proof (state)\nthis:\n  x + 2 ^ n XOR 2 ^ n = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_add_mult_multI:\n  fixes p :: \"'a::len word\"\n  shows \"\\<lbrakk>is_aligned p m; n \\<le> m; n' = n\\<rbrakk> \\<Longrightarrow> is_aligned (p + x * 2 ^ n * z) n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p m; n \\<le> m; n' = n\\<rbrakk>\n    \\<Longrightarrow> is_aligned (p + x * 2 ^ n * z) n'", "apply (erule aligned_add_aligned)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> m; n' = n\\<rbrakk>\n    \\<Longrightarrow> is_aligned (x * 2 ^ n * z) n'\n 2. \\<lbrakk>n \\<le> m; n' = n\\<rbrakk> \\<Longrightarrow> n' \\<le> m", "apply (auto intro: is_alignedI [where k=\"x*z\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_aligned_add_multI:\n  fixes p :: \"'a::len word\"\n  shows \"\\<lbrakk>is_aligned p m; n \\<le> m; n' = n\\<rbrakk> \\<Longrightarrow> is_aligned (p + x * 2 ^ n) n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p m; n \\<le> m; n' = n\\<rbrakk>\n    \\<Longrightarrow> is_aligned (p + x * 2 ^ n) n'", "apply (erule aligned_add_aligned)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> m; n' = n\\<rbrakk>\n    \\<Longrightarrow> is_aligned (x * 2 ^ n) n'\n 2. \\<lbrakk>n \\<le> m; n' = n\\<rbrakk> \\<Longrightarrow> n' \\<le> m", "apply (auto intro: is_alignedI [where k=\"x\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_aligned_no_wrap''':\n  fixes ptr :: \"'a::len word\"\n  shows\"\\<lbrakk> is_aligned ptr sz; sz < LENGTH('a); off < 2 ^ sz \\<rbrakk>\n         \\<Longrightarrow> unat ptr + off < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned ptr sz; sz < LENGTH('a); off < 2 ^ sz\\<rbrakk>\n    \\<Longrightarrow> unat ptr + off < 2 ^ LENGTH('a)", "apply (drule is_aligned_no_wrap[where off=\"of_nat off\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sz < LENGTH('a); off < 2 ^ sz\\<rbrakk>\n    \\<Longrightarrow> word_of_nat off < 2 ^ sz\n 2. \\<lbrakk>sz < LENGTH('a); off < 2 ^ sz;\n     unat ptr + unat (word_of_nat off) < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat ptr + off < 2 ^ LENGTH('a)", "apply (simp add: word_less_nat_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sz < LENGTH('a); off < 2 ^ sz\\<rbrakk>\n    \\<Longrightarrow> take_bit LENGTH('a) off < 2 ^ sz\n 2. \\<lbrakk>sz < LENGTH('a); off < 2 ^ sz;\n     unat ptr + unat (word_of_nat off) < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat ptr + off < 2 ^ LENGTH('a)", "apply (erule order_le_less_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> take_bit LENGTH('a) off \\<le> off\n 2. \\<lbrakk>sz < LENGTH('a); off < 2 ^ sz;\n     unat ptr + unat (word_of_nat off) < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat ptr + off < 2 ^ LENGTH('a)", "apply (simp add: take_bit_eq_mod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sz < LENGTH('a); off < 2 ^ sz;\n     unat ptr + unat (word_of_nat off) < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat ptr + off < 2 ^ LENGTH('a)", "apply (subst(asm) unat_of_nat_len)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sz < LENGTH('a); off < 2 ^ sz\\<rbrakk>\n    \\<Longrightarrow> off < 2 ^ LENGTH('a)\n 2. \\<lbrakk>sz < LENGTH('a); off < 2 ^ sz;\n     unat ptr + off < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat ptr + off < 2 ^ LENGTH('a)", "apply (erule order_less_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> 2 ^ sz < 2 ^ LENGTH('a)\n 2. \\<lbrakk>sz < LENGTH('a); off < 2 ^ sz;\n     unat ptr + off < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat ptr + off < 2 ^ LENGTH('a)", "apply (erule power_strict_increasing)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 < 2\n 2. \\<lbrakk>sz < LENGTH('a); off < 2 ^ sz;\n     unat ptr + off < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat ptr + off < 2 ^ LENGTH('a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sz < LENGTH('a); off < 2 ^ sz;\n     unat ptr + off < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat ptr + off < 2 ^ LENGTH('a)", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_aligned_get_word_bits:\n  fixes p :: \"'a::len word\"\n  shows \"\\<lbrakk> is_aligned p n; \\<lbrakk> is_aligned p n; n < LENGTH('a) \\<rbrakk> \\<Longrightarrow> P;\n           \\<lbrakk> p = 0; n \\<ge> LENGTH('a) \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n;\n     \\<lbrakk>is_aligned p n; n < LENGTH('a)\\<rbrakk> \\<Longrightarrow> P;\n     \\<lbrakk>p = 0; LENGTH('a) \\<le> n\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (cases \"n < LENGTH('a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned p n;\n     \\<lbrakk>is_aligned p n; n < LENGTH('a)\\<rbrakk> \\<Longrightarrow> P;\n     \\<lbrakk>p = 0; LENGTH('a) \\<le> n\\<rbrakk> \\<Longrightarrow> P;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>is_aligned p n;\n     \\<lbrakk>is_aligned p n; n < LENGTH('a)\\<rbrakk> \\<Longrightarrow> P;\n     \\<lbrakk>p = 0; LENGTH('a) \\<le> n\\<rbrakk> \\<Longrightarrow> P;\n     \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> P", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n;\n     \\<lbrakk>is_aligned p n; n < LENGTH('a)\\<rbrakk> \\<Longrightarrow> P;\n     \\<lbrakk>p = 0; LENGTH('a) \\<le> n\\<rbrakk> \\<Longrightarrow> P;\n     \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> P", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; p = 0 \\<Longrightarrow> P;\n     \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> P", "apply (erule meta_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p = 0", "apply (simp add: is_aligned_mask power_add power_overflow not_less\n    flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>take_bit n p = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> p = 0", "apply (metis take_bit_length_eq take_bit_of_0 take_bit_tightened)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aligned_small_is_0:\n  \"\\<lbrakk> is_aligned x n; x < 2 ^ n \\<rbrakk> \\<Longrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; x < 2 ^ n\\<rbrakk> \\<Longrightarrow> x = 0", "by (simp add: is_aligned_mask less_mask_eq)"], ["", "corollary is_aligned_less_sz:\n  \"\\<lbrakk>is_aligned a sz; a \\<noteq> 0\\<rbrakk> \\<Longrightarrow> \\<not> a < 2 ^ sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a sz; a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<not> a < 2 ^ sz", "by (rule notI, drule(1) aligned_small_is_0, erule(1) notE)"], ["", "lemma aligned_at_least_t2n_diff:\n  \"\\<lbrakk>is_aligned x n; is_aligned y n; x < y\\<rbrakk> \\<Longrightarrow> x \\<le> y - 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; is_aligned y n; x < y\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 2 ^ n", "apply (erule is_aligned_get_word_bits[where p=y])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; x < y; is_aligned y n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 2 ^ n\n 2. \\<lbrakk>is_aligned x n; x < y; y = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 2 ^ n", "apply (rule ccontr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; x < y; is_aligned y n; n < LENGTH('a);\n     \\<not> x \\<le> y - 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>is_aligned x n; x < y; y = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 2 ^ n", "apply (clarsimp simp: linorder_not_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; x < y; is_aligned y n; n < LENGTH('a);\n     y - 2 ^ n < x\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>is_aligned x n; x < y; y = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 2 ^ n", "apply (subgoal_tac \"y - x = 0\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned x n; x < y; is_aligned y n; n < LENGTH('a);\n     y - 2 ^ n < x; y - x = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>is_aligned x n; x < y; is_aligned y n; n < LENGTH('a);\n     y - 2 ^ n < x\\<rbrakk>\n    \\<Longrightarrow> y - x = 0\n 3. \\<lbrakk>is_aligned x n; x < y; y = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 2 ^ n", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; x < y; is_aligned y n; n < LENGTH('a);\n     y - 2 ^ n < x\\<rbrakk>\n    \\<Longrightarrow> y - x = 0\n 2. \\<lbrakk>is_aligned x n; x < y; y = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 2 ^ n", "apply (rule aligned_small_is_0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned x n; x < y; is_aligned y n; n < LENGTH('a);\n     y - 2 ^ n < x\\<rbrakk>\n    \\<Longrightarrow> is_aligned (y - x) ?n8\n 2. \\<lbrakk>is_aligned x n; x < y; is_aligned y n; n < LENGTH('a);\n     y - 2 ^ n < x\\<rbrakk>\n    \\<Longrightarrow> y - x < 2 ^ ?n8\n 3. \\<lbrakk>is_aligned x n; x < y; y = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 2 ^ n", "apply (erule(1) aligned_sub_aligned)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned x n; x < y; n < LENGTH('a); y - 2 ^ n < x\\<rbrakk>\n    \\<Longrightarrow> n \\<le> n\n 2. \\<lbrakk>is_aligned x n; x < y; is_aligned y n; n < LENGTH('a);\n     y - 2 ^ n < x\\<rbrakk>\n    \\<Longrightarrow> y - x < 2 ^ n\n 3. \\<lbrakk>is_aligned x n; x < y; y = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 2 ^ n", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; x < y; is_aligned y n; n < LENGTH('a);\n     y - 2 ^ n < x\\<rbrakk>\n    \\<Longrightarrow> y - x < 2 ^ n\n 2. \\<lbrakk>is_aligned x n; x < y; y = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 2 ^ n", "apply unat_arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; x < y; y = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y - 2 ^ n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_aligned_no_overflow'':\n  \"\\<lbrakk>is_aligned x n; x + 2 ^ n \\<noteq> 0\\<rbrakk> \\<Longrightarrow> x \\<le> x + 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; x + 2 ^ n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + 2 ^ n", "apply (frule is_aligned_no_overflow')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; x + 2 ^ n \\<noteq> 0;\n     x \\<le> x + (2 ^ n - 1)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + 2 ^ n", "apply (erule order_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; x + 2 ^ n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x + (2 ^ n - 1) \\<le> x + 2 ^ n", "apply (simp add: field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; x + 2 ^ n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x + 2 ^ n - 1 \\<le> x + 2 ^ n", "apply (erule word_sub_1_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_aligned_nth [word_eqI_simps]:\n  \"is_aligned p m = (\\<forall>n < m. \\<not>p !! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned p m = (\\<forall>n<m. \\<not> p !! n)", "apply (clarsimp simp: is_aligned_mask bang_eq word_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n<m. p !! n \\<longrightarrow> \\<not> n < LENGTH('a)) =\n    (\\<forall>n<m. \\<not> p !! n)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>n<m.\n       p !! n \\<longrightarrow> \\<not> n < LENGTH('a) \\<Longrightarrow>\n    \\<forall>n<m. \\<not> p !! n\n 2. \\<forall>n<m. \\<not> p !! n \\<Longrightarrow>\n    \\<forall>n<m. p !! n \\<longrightarrow> \\<not> n < LENGTH('a)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n<m.\n                   p !! n \\<longrightarrow> \\<not> n < LENGTH('a);\n        n < m; p !! n\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>n<m. \\<not> p !! n \\<Longrightarrow>\n    \\<forall>n<m. p !! n \\<longrightarrow> \\<not> n < LENGTH('a)", "apply (case_tac \"n < size p\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n<m.\n                   p !! n \\<longrightarrow> \\<not> n < LENGTH('a);\n        n < m; p !! n; n < size p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>n<m.\n                   p !! n \\<longrightarrow> \\<not> n < LENGTH('a);\n        n < m; p !! n; \\<not> n < size p\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<forall>n<m. \\<not> p !! n \\<Longrightarrow>\n    \\<forall>n<m. p !! n \\<longrightarrow> \\<not> n < LENGTH('a)", "apply (simp add: word_size)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n<m.\n                   p !! n \\<longrightarrow> \\<not> n < LENGTH('a);\n        n < m; p !! n; \\<not> n < size p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>n<m. \\<not> p !! n \\<Longrightarrow>\n    \\<forall>n<m. p !! n \\<longrightarrow> \\<not> n < LENGTH('a)", "apply (drule test_bit_size)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n<m.\n                   p !! n \\<longrightarrow> \\<not> n < LENGTH('a);\n        n < m; \\<not> n < size p; n < size p\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>n<m. \\<not> p !! n \\<Longrightarrow>\n    \\<forall>n<m. p !! n \\<longrightarrow> \\<not> n < LENGTH('a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<m. \\<not> p !! n \\<Longrightarrow>\n    \\<forall>n<m. p !! n \\<longrightarrow> \\<not> n < LENGTH('a)", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma range_inter:\n  \"({a..b} \\<inter> {c..d} = {}) = (\\<forall>x. \\<not>(a \\<le> x \\<and> x \\<le> b \\<and> c \\<le> x \\<and> x \\<le> d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a..b} \\<inter> {c..d} = {}) =\n    (\\<forall>x.\n        \\<not> (a \\<le> x \\<and>\n                x \\<le> b \\<and> c \\<le> x \\<and> x \\<le> d))", "by auto"], ["", "lemma aligned_inter_non_empty:\n  \"\\<lbrakk> {p..p + (2 ^ n - 1)} \\<inter> {p..p + 2 ^ m - 1} = {};\n     is_aligned p n; is_aligned p m\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{p..p + (2 ^ n - 1)} \\<inter> {p..p + 2 ^ m - 1} = {};\n     is_aligned p n; is_aligned p m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (clarsimp simp only: range_inter)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                \\<not> (p \\<le> x \\<and>\n                        x \\<le> p + (2 ^ n - 1) \\<and>\n                        p \\<le> x \\<and> x \\<le> p + 2 ^ m - 1);\n     is_aligned p n; is_aligned p m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule_tac x=p in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; is_aligned p m;\n     \\<not> (p \\<le> p \\<and>\n             p \\<le> p + (2 ^ n - 1) \\<and>\n             p \\<le> p \\<and> p \\<le> p + 2 ^ m - 1)\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; is_aligned p m;\n     p \\<le> p + (2 ^ n - 1) \\<longrightarrow>\n     \\<not> p \\<le> p + 2 ^ m - 1\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned p n; is_aligned p m\\<rbrakk>\n    \\<Longrightarrow> p \\<le> p + (2 ^ n - 1)\n 2. \\<lbrakk>is_aligned p n; is_aligned p m;\n     \\<not> p \\<le> p + 2 ^ m - 1\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule is_aligned_no_overflow')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; is_aligned p m;\n     \\<not> p \\<le> p + 2 ^ m - 1\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule notE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; is_aligned p m\\<rbrakk>\n    \\<Longrightarrow> p \\<le> p + 2 ^ m - 1", "apply (erule is_aligned_no_overflow)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_aligned_mod_nz:\n  assumes al: \"\\<not> is_aligned a n\"\n  shows \"a mod 2 ^ n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod 2 ^ n \\<noteq> 0", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> a mod 2 ^ n \\<noteq> 0 \\<Longrightarrow> False", "using al"], ["proof (prove)\nusing this:\n  \\<not> is_aligned a n\n\ngoal (1 subgoal):\n 1. \\<not> a mod 2 ^ n \\<noteq> 0 \\<Longrightarrow> False", "apply (rule notE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> a mod 2 ^ n \\<noteq> 0 \\<Longrightarrow> is_aligned a n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod 2 ^ n = 0 \\<Longrightarrow> is_aligned a n", "apply (rule is_alignedI [of _ _ \\<open>a div 2 ^ n\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod 2 ^ n = 0 \\<Longrightarrow> a = 2 ^ n * (a div 2 ^ n)", "apply (metis add.right_neutral mult.commute word_mod_div_equality)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nat_add_offset_le:\n  fixes x :: nat\n  assumes yv: \"y \\<le> 2 ^ n\"\n  and     xv: \"x < 2 ^ m\"\n  and     mn: \"sz = m + n\"\n  shows   \"x * 2 ^ n + y \\<le> 2 ^ sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 2 ^ n + y \\<le> 2 ^ sz", "proof (subst mn)"], ["proof (state)\ngoal (1 subgoal):\n 1. x * 2 ^ n + y \\<le> 2 ^ (m + n)", "from yv"], ["proof (chain)\npicking this:\n  y \\<le> 2 ^ n", "obtain qy where \"y + qy = 2 ^ n\""], ["proof (prove)\nusing this:\n  y \\<le> 2 ^ n\n\ngoal (1 subgoal):\n 1. (\\<And>qy. y + qy = 2 ^ n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: le_iff_add)"], ["proof (state)\nthis:\n  y + qy = 2 ^ n\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y \\<le> 2 ^ (m + n)", "have \"x * 2 ^ n + y \\<le> x * 2 ^ n + 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 2 ^ n + y \\<le> x * 2 ^ n + 2 ^ n", "using yv xv"], ["proof (prove)\nusing this:\n  y \\<le> 2 ^ n\n  x < 2 ^ m\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y \\<le> x * 2 ^ n + 2 ^ n", "by simp"], ["proof (state)\nthis:\n  x * 2 ^ n + y \\<le> x * 2 ^ n + 2 ^ n\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y \\<le> 2 ^ (m + n)", "also"], ["proof (state)\nthis:\n  x * 2 ^ n + y \\<le> x * 2 ^ n + 2 ^ n\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y \\<le> 2 ^ (m + n)", "have \"\\<dots> = (x + 1) * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 2 ^ n + 2 ^ n = (x + 1) * 2 ^ n", "by simp"], ["proof (state)\nthis:\n  x * 2 ^ n + 2 ^ n = (x + 1) * 2 ^ n\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y \\<le> 2 ^ (m + n)", "also"], ["proof (state)\nthis:\n  x * 2 ^ n + 2 ^ n = (x + 1) * 2 ^ n\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y \\<le> 2 ^ (m + n)", "have \"\\<dots> \\<le> 2 ^ (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + 1) * 2 ^ n \\<le> 2 ^ (m + n)", "using xv"], ["proof (prove)\nusing this:\n  x < 2 ^ m\n\ngoal (1 subgoal):\n 1. (x + 1) * 2 ^ n \\<le> 2 ^ (m + n)", "by (subst power_add) (rule mult_le_mono1, simp)"], ["proof (state)\nthis:\n  (x + 1) * 2 ^ n \\<le> 2 ^ (m + n)\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y \\<le> 2 ^ (m + n)", "finally"], ["proof (chain)\npicking this:\n  x * 2 ^ n + y \\<le> 2 ^ (m + n)", "show \"x * 2 ^ n + y \\<le> 2 ^ (m + n)\""], ["proof (prove)\nusing this:\n  x * 2 ^ n + y \\<le> 2 ^ (m + n)\n\ngoal (1 subgoal):\n 1. x * 2 ^ n + y \\<le> 2 ^ (m + n)", "."], ["proof (state)\nthis:\n  x * 2 ^ n + y \\<le> 2 ^ (m + n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_no_wrap_le:\n  fixes ptr::\"'a::len word\"\n  assumes al: \"is_aligned ptr sz\"\n  and    szv: \"sz < LENGTH('a)\"\n  and    off: \"off \\<le> 2 ^ sz\"\n  shows  \"unat ptr + off \\<le> 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ptr + off \\<le> 2 ^ LENGTH('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unat ptr + off \\<le> 2 ^ LENGTH('a)", "from al"], ["proof (chain)\npicking this:\n  is_aligned ptr sz", "obtain q where ptrq: \"ptr = 2 ^ sz * of_nat q\" and\n    qv: \"q < 2 ^ (LENGTH('a) - sz)\""], ["proof (prove)\nusing this:\n  is_aligned ptr sz\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>ptr = 2 ^ sz * word_of_nat q;\n         q < 2 ^ (LENGTH('a) - sz)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: is_alignedE)"], ["proof (state)\nthis:\n  ptr = 2 ^ sz * word_of_nat q\n  q < 2 ^ (LENGTH('a) - sz)\n\ngoal (1 subgoal):\n 1. unat ptr + off \\<le> 2 ^ LENGTH('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ptr + off \\<le> 2 ^ LENGTH('a)", "proof (cases \"sz = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sz = 0 \\<Longrightarrow> unat ptr + off \\<le> 2 ^ LENGTH('a)\n 2. sz \\<noteq> 0 \\<Longrightarrow> unat ptr + off \\<le> 2 ^ LENGTH('a)", "case True"], ["proof (state)\nthis:\n  sz = 0\n\ngoal (2 subgoals):\n 1. sz = 0 \\<Longrightarrow> unat ptr + off \\<le> 2 ^ LENGTH('a)\n 2. sz \\<noteq> 0 \\<Longrightarrow> unat ptr + off \\<le> 2 ^ LENGTH('a)", "then"], ["proof (chain)\npicking this:\n  sz = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  sz = 0\n\ngoal (1 subgoal):\n 1. unat ptr + off \\<le> 2 ^ LENGTH('a)", "using off ptrq qv"], ["proof (prove)\nusing this:\n  sz = 0\n  off \\<le> 2 ^ sz\n  ptr = 2 ^ sz * word_of_nat q\n  q < 2 ^ (LENGTH('a) - sz)\n\ngoal (1 subgoal):\n 1. unat ptr + off \\<le> 2 ^ LENGTH('a)", "by (auto simp add: le_Suc_eq Suc_le_eq) (simp add: le_less)"], ["proof (state)\nthis:\n  unat ptr + off \\<le> 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. sz \\<noteq> 0 \\<Longrightarrow> unat ptr + off \\<le> 2 ^ LENGTH('a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sz \\<noteq> 0 \\<Longrightarrow> unat ptr + off \\<le> 2 ^ LENGTH('a)", "case False"], ["proof (state)\nthis:\n  sz \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sz \\<noteq> 0 \\<Longrightarrow> unat ptr + off \\<le> 2 ^ LENGTH('a)", "then"], ["proof (chain)\npicking this:\n  sz \\<noteq> 0", "have sne: \"0 < sz\""], ["proof (prove)\nusing this:\n  sz \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < sz", ".."], ["proof (state)\nthis:\n  0 < sz\n\ngoal (1 subgoal):\n 1. sz \\<noteq> 0 \\<Longrightarrow> unat ptr + off \\<le> 2 ^ LENGTH('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ptr + off \\<le> 2 ^ LENGTH('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unat ptr + off \\<le> 2 ^ LENGTH('a)", "have uq: \"unat (of_nat q :: 'a word) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (word_of_nat q) = q", "apply (subst unat_of_nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q mod 2 ^ LENGTH('a) = q", "apply (rule mod_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q < 2 ^ LENGTH('a)", "apply (rule order_less_trans [OF qv])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (LENGTH('a) - sz) < 2 ^ LENGTH('a)", "apply (rule power_strict_increasing [OF diff_less [OF sne]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < LENGTH('a)\n 2. 1 < 2", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unat (word_of_nat q) = q\n\ngoal (1 subgoal):\n 1. unat ptr + off \\<le> 2 ^ LENGTH('a)", "have uptr: \"unat ptr = 2 ^ sz * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ptr = 2 ^ sz * q", "apply (subst ptrq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (2 ^ sz * word_of_nat q) = 2 ^ sz * q", "apply (subst iffD1 [OF unat_mult_lem])"], ["proof (prove)\ngoal (2 subgoals):\n 1. unat (2 ^ sz) * unat (word_of_nat q) < 2 ^ LENGTH('a)\n 2. unat (2 ^ sz) * unat (word_of_nat q) = 2 ^ sz * q", "apply (subst unat_power_lower [OF szv])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 2 ^ sz * unat (word_of_nat q) < 2 ^ LENGTH('a)\n 2. unat (2 ^ sz) * unat (word_of_nat q) = 2 ^ sz * q", "apply (subst uq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 2 ^ sz * q < 2 ^ LENGTH('a)\n 2. unat (2 ^ sz) * unat (word_of_nat q) = 2 ^ sz * q", "apply (rule nat_less_power_trans [OF qv order_less_imp_le [OF szv]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (2 ^ sz) * unat (word_of_nat q) = 2 ^ sz * q", "apply (subst uq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (2 ^ sz) * q = 2 ^ sz * q", "apply (subst unat_power_lower [OF szv])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ sz * q = 2 ^ sz * q", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unat ptr = 2 ^ sz * q\n\ngoal (1 subgoal):\n 1. unat ptr + off \\<le> 2 ^ LENGTH('a)", "show \"unat ptr + off \\<le> 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat ptr + off \\<le> 2 ^ LENGTH('a)", "using szv"], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat ptr + off \\<le> 2 ^ LENGTH('a)", "apply (subst uptr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow> 2 ^ sz * q + off \\<le> 2 ^ LENGTH('a)", "apply (subst mult.commute, rule nat_add_offset_le [OF off qv])"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow> LENGTH('a) = LENGTH('a) - sz + sz", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unat ptr + off \\<le> 2 ^ LENGTH('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unat ptr + off \\<le> 2 ^ LENGTH('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unat ptr + off \\<le> 2 ^ LENGTH('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_neg_mask:\n  \"m \\<le> n \\<Longrightarrow> is_aligned (x AND NOT (mask n)) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> is_aligned (x AND NOT (mask n)) m", "by (metis and_not_mask is_aligned_shift is_aligned_weaken)"], ["", "lemma unat_minus:\n  \"unat (- (x :: 'a :: len word)) = (if x = 0 then 0 else 2 ^ size x - unat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (- x) = (if x = 0 then 0 else 2 ^ size x - unat x)", "using unat_sub_if_size[where x=\"2 ^ size x\" and y=x]"], ["proof (prove)\nusing this:\n  unat (2 ^ size x - x) =\n  (if unat x \\<le> unat (2 ^ size x) then unat (2 ^ size x) - unat x\n   else unat (2 ^ size x) + 2 ^ size (2 ^ size x) - unat x)\n\ngoal (1 subgoal):\n 1. unat (- x) = (if x = 0 then 0 else 2 ^ size x - unat x)", "by (simp add: unat_eq_0 word_size)"], ["", "lemma is_aligned_minus:\n  \\<open>is_aligned (- p) n\\<close> if \\<open>is_aligned p n\\<close> for p :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned (- p) n", "using that"], ["proof (prove)\nusing this:\n  is_aligned p n\n\ngoal (1 subgoal):\n 1. is_aligned (- p) n", "apply (cases \\<open>n < LENGTH('a)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned p n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned (- p) n\n 2. \\<lbrakk>is_aligned p n; \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned (- p) n", "apply (simp_all add: not_less is_aligned_beyond_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned (- p) n", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p n.\n       \\<lbrakk>2 ^ n dvd take_bit LENGTH('a) p; n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ n dvd take_bit LENGTH('a) (- p)", "apply (simp flip: take_bit_eq_0_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p n.\n       \\<lbrakk>take_bit n p = 0; n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> take_bit n (- p) = 0", "apply (subst take_bit_minus [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p n.\n       \\<lbrakk>take_bit n p = 0; n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> take_bit n (- take_bit n p) = 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma add_mask_lower_bits:\n  \"\\<lbrakk>is_aligned (x :: 'a :: len word) n;\n    \\<forall>n' \\<ge> n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\\<rbrakk> \\<Longrightarrow> x + p AND NOT (mask n) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n;\n     \\<forall>n'\\<ge>n.\n        n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\\<rbrakk>\n    \\<Longrightarrow> x + p AND NOT (mask n) = x", "apply (subst word_plus_and_or_coroll)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n;\n     \\<forall>n'\\<ge>n.\n        n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\\<rbrakk>\n    \\<Longrightarrow> x AND p = 0\n 2. \\<lbrakk>is_aligned x n;\n     \\<forall>n'\\<ge>n.\n        n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\\<rbrakk>\n    \\<Longrightarrow> (x OR p) AND NOT (mask n) = x", "apply (rule word_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>is_aligned x n;\n        \\<forall>n'\\<ge>n.\n           n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\\<rbrakk>\n       \\<Longrightarrow> na < size (x AND p) \\<longrightarrow>\n                         (x AND p) !! na = 0 !! na\n 2. \\<lbrakk>is_aligned x n;\n     \\<forall>n'\\<ge>n.\n        n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\\<rbrakk>\n    \\<Longrightarrow> (x OR p) AND NOT (mask n) = x", "apply (clarsimp simp: word_size is_aligned_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>na<n. \\<not> x !! na;\n        \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n';\n        na < LENGTH('a); x !! na; p !! na\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>is_aligned x n;\n     \\<forall>n'\\<ge>n.\n        n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\\<rbrakk>\n    \\<Longrightarrow> (x OR p) AND NOT (mask n) = x", "apply (erule_tac x=na in allE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>na < LENGTH('a); x !! na; p !! na;\n        na < n \\<longrightarrow> \\<not> x !! na;\n        n \\<le> na \\<longrightarrow>\n        na < LENGTH('a) \\<longrightarrow> \\<not> p !! na\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>is_aligned x n;\n     \\<forall>n'\\<ge>n.\n        n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\\<rbrakk>\n    \\<Longrightarrow> (x OR p) AND NOT (mask n) = x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n;\n     \\<forall>n'\\<ge>n.\n        n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n'\\<rbrakk>\n    \\<Longrightarrow> (x OR p) AND NOT (mask n) = x", "apply (rule bit_word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>is_aligned x n;\n        \\<forall>n'\\<ge>n. n' < LENGTH('a) \\<longrightarrow> \\<not> p !! n';\n        na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit ((x OR p) AND NOT (mask n)) na = bit x na", "apply (auto simp add: bit_simps not_less test_bit_eq_bit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>is_aligned x n;\n        \\<forall>n'\\<ge>n.\n           n' < LENGTH('a) \\<longrightarrow> \\<not> bit p n';\n        na < LENGTH('a); bit x na\\<rbrakk>\n       \\<Longrightarrow> n \\<le> na", "apply (metis is_aligned_nth not_le test_bit_eq_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_aligned_andI1:\n  \"is_aligned x n \\<Longrightarrow> is_aligned (x AND y) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned x n \\<Longrightarrow> is_aligned (x AND y) n", "by (simp add: is_aligned_nth)"], ["", "lemma is_aligned_andI2:\n  \"is_aligned y n \\<Longrightarrow> is_aligned (x AND y) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned y n \\<Longrightarrow> is_aligned (x AND y) n", "by (simp add: is_aligned_nth)"], ["", "lemma is_aligned_shiftl:\n  \"is_aligned w (n - m) \\<Longrightarrow> is_aligned (w << m) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned w (n - m) \\<Longrightarrow> is_aligned (w << m) n", "by (simp add: is_aligned_nth nth_shiftl)"], ["", "lemma is_aligned_shiftr:\n  \"is_aligned w (n + m) \\<Longrightarrow> is_aligned (w >> m) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned w (n + m) \\<Longrightarrow> is_aligned (w >> m) n", "by (simp add: is_aligned_nth nth_shiftr)"], ["", "lemma is_aligned_shiftl_self:\n  \"is_aligned (p << n) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned (p << n) n", "by (rule is_aligned_shift)"], ["", "lemma is_aligned_neg_mask_eq:\n  \"is_aligned p n \\<Longrightarrow> p AND NOT (mask n) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned p n \\<Longrightarrow> p AND NOT (mask n) = p", "by (metis add.left_neutral is_aligned_mask word_plus_and_or_coroll2)"], ["", "lemma is_aligned_shiftr_shiftl:\n  \"is_aligned w n \\<Longrightarrow> w >> n << n = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned w n \\<Longrightarrow> w >> n << n = w", "by (metis and_not_mask is_aligned_neg_mask_eq)"], ["", "lemma aligned_shiftr_mask_shiftl:\n  \"is_aligned x n \\<Longrightarrow> ((x >> n) AND mask v) << n = x AND mask (v + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned x n \\<Longrightarrow>\n    (x >> n) AND mask v << n = x AND mask (v + n)", "apply (rule word_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       is_aligned x n \\<Longrightarrow>\n       na < size ((x >> n) AND mask v << n) \\<longrightarrow>\n       ((x >> n) AND mask v << n) !! na = (x AND mask (v + n)) !! na", "apply (simp add: word_size nth_shiftl nth_shiftr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       is_aligned x n \\<Longrightarrow>\n       na < LENGTH('a) \\<longrightarrow>\n       (n \\<le> na \\<and>\n        x !! (na - n + n) \\<and> na - n < v \\<and> na - n < LENGTH('a)) =\n       (x !! na \\<and> na < v + n)", "apply (subgoal_tac \"\\<forall>m. x !! m \\<longrightarrow> m \\<ge> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>is_aligned x n;\n        \\<forall>m. x !! m \\<longrightarrow> n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> na < LENGTH('a) \\<longrightarrow>\n                         (n \\<le> na \\<and>\n                          x !! (na - n + n) \\<and>\n                          na - n < v \\<and> na - n < LENGTH('a)) =\n                         (x !! na \\<and> na < v + n)\n 2. \\<And>na.\n       is_aligned x n \\<Longrightarrow>\n       \\<forall>m. x !! m \\<longrightarrow> n \\<le> m", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       is_aligned x n \\<Longrightarrow>\n       \\<forall>m. x !! m \\<longrightarrow> n \\<le> m", "apply (clarsimp simp: is_aligned_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>x AND mask n = 0; x !! m\\<rbrakk>\n       \\<Longrightarrow> n \\<le> m", "apply (drule_tac x=m in word_eqD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>x !! m; (x AND mask n) !! m = 0 !! m\\<rbrakk>\n       \\<Longrightarrow> n \\<le> m", "apply (frule test_bit_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>x !! m; (x AND mask n) !! m = 0 !! m; m < size x\\<rbrakk>\n       \\<Longrightarrow> n \\<le> m", "apply (simp add: word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_zero:\n  \"is_aligned x a \\<Longrightarrow> x AND mask a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned x a \\<Longrightarrow> x AND mask a = 0", "by (metis is_aligned_mask)"], ["", "lemma is_aligned_neg_mask_eq_concrete:\n  \"\\<lbrakk> is_aligned p n; msk AND NOT (mask n) = NOT (mask n) \\<rbrakk>\n   \\<Longrightarrow> p AND msk = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; msk AND NOT (mask n) = NOT (mask n)\\<rbrakk>\n    \\<Longrightarrow> p AND msk = p", "by (metis word_bw_assocs(1) word_bw_comms(1) is_aligned_neg_mask_eq)"], ["", "lemma is_aligned_and_not_zero:\n  \"\\<lbrakk> is_aligned n k; n \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> 2 ^ k \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned n k; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 2 ^ k \\<le> n", "using is_aligned_less_sz leI"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_aligned ?a ?sz; ?a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?a < 2 ^ ?sz\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned n k; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 2 ^ k \\<le> n", "by blast"], ["", "lemma is_aligned_and_2_to_k:\n  \"(n AND 2 ^ k - 1) = 0 \\<Longrightarrow> is_aligned (n :: 'a :: len word) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n AND 2 ^ k - 1 = 0 \\<Longrightarrow> is_aligned n k", "by (simp add: is_aligned_mask mask_eq_decr_exp)"], ["", "lemma is_aligned_power2:\n  \"b \\<le> a \\<Longrightarrow> is_aligned (2 ^ a) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a \\<Longrightarrow> is_aligned (2 ^ a) b", "by (metis is_aligned_triv is_aligned_weaken)"], ["", "lemma aligned_sub_aligned':\n  \"\\<lbrakk> is_aligned (a :: 'a :: len word) n; is_aligned b n; n < LENGTH('a) \\<rbrakk>\n   \\<Longrightarrow> is_aligned (a - b) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; is_aligned b n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned (a - b) n", "by (simp add: aligned_sub_aligned)"], ["", "lemma is_aligned_neg_mask_weaken:\n  \"\\<lbrakk> is_aligned p n; m \\<le> n \\<rbrakk> \\<Longrightarrow> p AND NOT (mask m) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> p AND NOT (mask m) = p", "using is_aligned_neg_mask_eq is_aligned_weaken"], ["proof (prove)\nusing this:\n  is_aligned ?p ?n \\<Longrightarrow> ?p AND NOT (mask ?n) = ?p\n  \\<lbrakk>is_aligned ?w ?x; ?y \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> is_aligned ?w ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> p AND NOT (mask m) = p", "by blast"], ["", "lemma is_aligned_neg_mask2 [simp]:\n  \"is_aligned (a AND NOT (mask n)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned (a AND NOT (mask n)) n", "by (simp add: and_not_mask is_aligned_shift)"], ["", "lemma is_aligned_0':\n  \"is_aligned 0 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned 0 n", "by (fact is_aligned_0)"], ["", "lemma aligned_add_offset_no_wrap:\n  fixes off :: \"('a::len) word\"\n  and     x :: \"'a word\"\n  assumes al: \"is_aligned x sz\"\n  and   offv: \"off < 2 ^ sz\"\n  shows  \"unat x + unat off < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x + unat off < 2 ^ LENGTH('a)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)\n 2. \\<not> ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)", "assume szv: \"sz < LENGTH('a)\""], ["proof (state)\nthis:\n  sz < LENGTH('a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)\n 2. \\<not> ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)", "from al"], ["proof (chain)\npicking this:\n  is_aligned x sz", "obtain k where xv: \"x = 2 ^ sz * (of_nat k)\"\n    and kl: \"k < 2 ^ (LENGTH('a) - sz)\""], ["proof (prove)\nusing this:\n  is_aligned x sz\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>x = 2 ^ sz * word_of_nat k;\n         k < 2 ^ (LENGTH('a) - sz)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: is_alignedE)"], ["proof (state)\nthis:\n  x = 2 ^ sz * word_of_nat k\n  k < 2 ^ (LENGTH('a) - sz)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)\n 2. \\<not> ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x + unat off < 2 ^ LENGTH('a)", "using szv"], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat x + unat off < 2 ^ LENGTH('a)", "apply (subst xv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow>\n    unat (2 ^ sz * word_of_nat k) + unat off < 2 ^ LENGTH('a)", "apply (subst unat_mult_power_lem[OF kl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow> 2 ^ sz * k + unat off < 2 ^ LENGTH('a)", "apply (subst mult.commute, rule nat_add_offset_less)"], ["proof (prove)\ngoal (3 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> unat off < 2 ^ sz\n 2. sz < LENGTH('a) \\<Longrightarrow> k < 2 ^ ?m1\n 3. sz < LENGTH('a) \\<Longrightarrow> LENGTH('a) = ?m1 + sz", "apply (rule less_le_trans[OF unat_mono[OF offv, simplified]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> unat (2 ^ sz) \\<le> 2 ^ sz\n 2. sz < LENGTH('a) \\<Longrightarrow> k < 2 ^ ?m1\n 3. sz < LENGTH('a) \\<Longrightarrow> LENGTH('a) = ?m1 + sz", "apply (erule eq_imp_le[OF unat_power_lower])"], ["proof (prove)\ngoal (2 subgoals):\n 1. sz < LENGTH('a) \\<Longrightarrow> k < 2 ^ ?m1\n 2. sz < LENGTH('a) \\<Longrightarrow> LENGTH('a) = ?m1 + sz", "apply (rule kl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sz < LENGTH('a) \\<Longrightarrow> LENGTH('a) = LENGTH('a) - sz + sz", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unat x + unat off < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    unat x + unat off < 2 ^ LENGTH('a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    unat x + unat off < 2 ^ LENGTH('a)", "assume \"\\<not> sz < LENGTH('a)\""], ["proof (state)\nthis:\n  \\<not> sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    unat x + unat off < 2 ^ LENGTH('a)", "with offv"], ["proof (chain)\npicking this:\n  off < 2 ^ sz\n  \\<not> sz < LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  off < 2 ^ sz\n  \\<not> sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat x + unat off < 2 ^ LENGTH('a)", "by (simp add: not_less power_overflow )"], ["proof (state)\nthis:\n  unat x + unat off < 2 ^ LENGTH('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aligned_add_offset_mod:\n  fixes x :: \"('a::len) word\"\n  assumes al: \"is_aligned x sz\"\n  and     kv: \"k < 2 ^ sz\"\n  shows   \"(x + k) mod 2 ^ sz = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + k) mod 2 ^ sz = k", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (x + k) mod 2 ^ sz = k\n 2. \\<not> ?P \\<Longrightarrow> (x + k) mod 2 ^ sz = k", "assume szv: \"sz < LENGTH('a)\""], ["proof (state)\nthis:\n  sz < LENGTH('a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (x + k) mod 2 ^ sz = k\n 2. \\<not> ?P \\<Longrightarrow> (x + k) mod 2 ^ sz = k", "have ux: \"unat x + unat k < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x + unat k < 2 ^ LENGTH('a)", "by (rule aligned_add_offset_no_wrap) fact+"], ["proof (state)\nthis:\n  unat x + unat k < 2 ^ LENGTH('a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (x + k) mod 2 ^ sz = k\n 2. \\<not> ?P \\<Longrightarrow> (x + k) mod 2 ^ sz = k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + k) mod 2 ^ sz = k", "using al szv"], ["proof (prove)\nusing this:\n  is_aligned x sz\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x + k) mod 2 ^ sz = k", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x sz; sz < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + k) mod 2 ^ sz = k", "apply (erule is_alignedE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>sz < LENGTH('a); x = 2 ^ sz * word_of_nat q;\n        q < 2 ^ (LENGTH('a) - sz)\\<rbrakk>\n       \\<Longrightarrow> (x + k) mod 2 ^ sz = k", "apply (subst word_unat.Rep_inject [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>sz < LENGTH('a); x = 2 ^ sz * word_of_nat q;\n        q < 2 ^ (LENGTH('a) - sz)\\<rbrakk>\n       \\<Longrightarrow> unat ((x + k) mod 2 ^ sz) = unat k", "apply (subst unat_mod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>sz < LENGTH('a); x = 2 ^ sz * word_of_nat q;\n        q < 2 ^ (LENGTH('a) - sz)\\<rbrakk>\n       \\<Longrightarrow> unat (x + k) mod unat (2 ^ sz) = unat k", "apply (subst iffD1 [OF unat_add_lem], rule ux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>sz < LENGTH('a); x = 2 ^ sz * word_of_nat q;\n        q < 2 ^ (LENGTH('a) - sz)\\<rbrakk>\n       \\<Longrightarrow> (unat x + unat k) mod unat (2 ^ sz) = unat k", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>sz < LENGTH('a); x = 2 ^ sz * word_of_nat q;\n        q < 2 ^ (LENGTH('a) - sz)\\<rbrakk>\n       \\<Longrightarrow> (unat (2 ^ sz * word_of_nat q) + unat k) mod\n                         2 ^ sz =\n                         unat k", "apply (subst unat_mult_power_lem, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>sz < LENGTH('a); x = 2 ^ sz * word_of_nat q;\n        q < 2 ^ (LENGTH('a) - sz)\\<rbrakk>\n       \\<Longrightarrow> (2 ^ sz * q + unat k) mod 2 ^ sz = unat k", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>sz < LENGTH('a); x = 2 ^ sz * word_of_nat q;\n        q < 2 ^ (LENGTH('a) - sz)\\<rbrakk>\n       \\<Longrightarrow> unat k mod 2 ^ sz = unat k", "apply (rule mod_less[OF less_le_trans[OF unat_mono], OF kv])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>sz < LENGTH('a); x = 2 ^ sz * word_of_nat q;\n        q < 2 ^ (LENGTH('a) - sz)\\<rbrakk>\n       \\<Longrightarrow> unat (2 ^ sz) \\<le> 2 ^ sz", "apply (erule eq_imp_le[OF unat_power_lower])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (x + k) mod 2 ^ sz = k\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow> (x + k) mod 2 ^ sz = k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow> (x + k) mod 2 ^ sz = k", "assume \"\\<not> sz < LENGTH('a)\""], ["proof (state)\nthis:\n  \\<not> sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow> (x + k) mod 2 ^ sz = k", "with al"], ["proof (chain)\npicking this:\n  is_aligned x sz\n  \\<not> sz < LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_aligned x sz\n  \\<not> sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. (x + k) mod 2 ^ sz = k", "by (simp add: not_less power_overflow is_aligned_mask mask_eq_decr_exp\n                  word_mod_by_0)"], ["proof (state)\nthis:\n  (x + k) mod 2 ^ sz = k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aligned_neq_into_no_overlap:\n  fixes x :: \"'a::len word\"\n  assumes neq: \"x \\<noteq> y\"\n  and     alx: \"is_aligned x sz\"\n  and     aly: \"is_aligned y sz\"\n  shows  \"{x .. x + (2 ^ sz - 1)} \\<inter> {y .. y + (2 ^ sz - 1)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}\n 2. \\<not> ?P \\<Longrightarrow>\n    {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}", "assume szv: \"sz < LENGTH('a)\""], ["proof (state)\nthis:\n  sz < LENGTH('a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}\n 2. \\<not> ?P \\<Longrightarrow>\n    {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}", "proof (rule equals0I, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>x \\<le> ya; y \\<le> ya; ya \\<le> x + (2 ^ sz - 1);\n        ya \\<le> y + (2 ^ sz - 1)\\<rbrakk>\n       \\<Longrightarrow> False", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>x \\<le> ya; y \\<le> ya; ya \\<le> x + (2 ^ sz - 1);\n        ya \\<le> y + (2 ^ sz - 1)\\<rbrakk>\n       \\<Longrightarrow> False", "assume xb: \"x \\<le> z\" and xt: \"z \\<le> x + (2 ^ sz - 1)\"\n      and yb: \"y \\<le> z\" and yt: \"z \\<le> y + (2 ^ sz - 1)\""], ["proof (state)\nthis:\n  x \\<le> z\n  z \\<le> x + (2 ^ sz - 1)\n  y \\<le> z\n  z \\<le> y + (2 ^ sz - 1)\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>x \\<le> ya; y \\<le> ya; ya \\<le> x + (2 ^ sz - 1);\n        ya \\<le> y + (2 ^ sz - 1)\\<rbrakk>\n       \\<Longrightarrow> False", "have rl: \"\\<And>(p::'a word) k w. \\<lbrakk>uint p + uint k < 2 ^ LENGTH('a); w = p + k; w \\<le> p + (2 ^ sz - 1) \\<rbrakk>\n      \\<Longrightarrow> k < 2 ^ sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p k w.\n       \\<lbrakk>uint p + uint k < 2 ^ LENGTH('a); w = p + k;\n        w \\<le> p + (2 ^ sz - 1)\\<rbrakk>\n       \\<Longrightarrow> k < 2 ^ sz", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p k w.\n       \\<lbrakk>uint p + uint k < 2 ^ LENGTH('a); w = p + k;\n        w \\<le> p + (2 ^ sz - 1)\\<rbrakk>\n       \\<Longrightarrow> k < 2 ^ sz", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p k w.\n       \\<lbrakk>uint p + uint k < 2 ^ LENGTH('a); w = p + k;\n        p + k \\<le> p + (2 ^ sz - 1)\\<rbrakk>\n       \\<Longrightarrow> k < 2 ^ sz", "apply (subst (asm) add.commute, subst (asm) add.commute, drule word_plus_mcs_4)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p k w.\n       \\<lbrakk>uint p + uint k < 2 ^ LENGTH('a); w = p + k\\<rbrakk>\n       \\<Longrightarrow> p \\<le> k + p\n 2. \\<And>p k w.\n       \\<lbrakk>uint p + uint k < 2 ^ LENGTH('a); w = p + k;\n        k \\<le> 2 ^ sz - 1\\<rbrakk>\n       \\<Longrightarrow> k < 2 ^ sz", "apply (subst add.commute, subst no_plus_overflow_uint_size)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p k w.\n       \\<lbrakk>uint p + uint k < 2 ^ LENGTH('a); w = p + k\\<rbrakk>\n       \\<Longrightarrow> uint p + uint k < 2 ^ size p\n 2. \\<And>p k w.\n       \\<lbrakk>uint p + uint k < 2 ^ LENGTH('a); w = p + k;\n        k \\<le> 2 ^ sz - 1\\<rbrakk>\n       \\<Longrightarrow> k < 2 ^ sz", "apply transfer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p k w.\n       \\<lbrakk>take_bit LENGTH('a) p + take_bit LENGTH('a) k\n                < 2 ^ LENGTH('a);\n        take_bit LENGTH('a) w = take_bit LENGTH('a) (p + k)\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) p + take_bit LENGTH('a) k\n                         < 2 ^ LENGTH('a)\n 2. \\<And>p k w.\n       \\<lbrakk>uint p + uint k < 2 ^ LENGTH('a); w = p + k;\n        k \\<le> 2 ^ sz - 1\\<rbrakk>\n       \\<Longrightarrow> k < 2 ^ sz", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p k w.\n       \\<lbrakk>uint p + uint k < 2 ^ LENGTH('a); w = p + k;\n        k \\<le> 2 ^ sz - 1\\<rbrakk>\n       \\<Longrightarrow> k < 2 ^ sz", "apply (auto simp add: le_less power_2_ge_iff szv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p k.\n       \\<lbrakk>uint p + uint k < 2 ^ LENGTH('a); k < 2 ^ sz - 1\\<rbrakk>\n       \\<Longrightarrow> k < 2 ^ sz", "apply (metis le_less_trans mask_eq_decr_exp mask_lt_2pn order_less_imp_le szv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>uint ?p + uint ?k < 2 ^ LENGTH('a); ?w = ?p + ?k;\n   ?w \\<le> ?p + (2 ^ sz - 1)\\<rbrakk>\n  \\<Longrightarrow> ?k < 2 ^ sz\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>x \\<le> ya; y \\<le> ya; ya \\<le> x + (2 ^ sz - 1);\n        ya \\<le> y + (2 ^ sz - 1)\\<rbrakk>\n       \\<Longrightarrow> False", "from xb"], ["proof (chain)\npicking this:\n  x \\<le> z", "obtain kx where\n      kx: \"z = x + kx\" and\n      kxl: \"uint x + uint kx < 2 ^ LENGTH('a)\""], ["proof (prove)\nusing this:\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. (\\<And>kx.\n        \\<lbrakk>z = x + kx; uint x + uint kx < 2 ^ LENGTH('a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp dest!: word_le_exists')"], ["proof (state)\nthis:\n  z = x + kx\n  uint x + uint kx < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>x \\<le> ya; y \\<le> ya; ya \\<le> x + (2 ^ sz - 1);\n        ya \\<le> y + (2 ^ sz - 1)\\<rbrakk>\n       \\<Longrightarrow> False", "from yb"], ["proof (chain)\npicking this:\n  y \\<le> z", "obtain ky where\n      ky: \"z = y + ky\" and\n      kyl: \"uint y + uint ky < 2 ^ LENGTH('a)\""], ["proof (prove)\nusing this:\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. (\\<And>ky.\n        \\<lbrakk>z = y + ky; uint y + uint ky < 2 ^ LENGTH('a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp dest!: word_le_exists')"], ["proof (state)\nthis:\n  z = y + ky\n  uint y + uint ky < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>x \\<le> ya; y \\<le> ya; ya \\<le> x + (2 ^ sz - 1);\n        ya \\<le> y + (2 ^ sz - 1)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "have \"kx = z mod 2 ^ sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kx = z mod 2 ^ sz", "proof (subst kx, rule sym, rule aligned_add_offset_mod)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_aligned x sz\n 2. kx < 2 ^ sz", "show \"kx < 2 ^ sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kx < 2 ^ sz", "by (rule rl) fact+"], ["proof (state)\nthis:\n  kx < 2 ^ sz\n\ngoal (1 subgoal):\n 1. is_aligned x sz", "qed fact+"], ["proof (state)\nthis:\n  kx = z mod 2 ^ sz\n\ngoal (1 subgoal):\n 1. x = y", "also"], ["proof (state)\nthis:\n  kx = z mod 2 ^ sz\n\ngoal (1 subgoal):\n 1. x = y", "have \"\\<dots> = ky\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z mod 2 ^ sz = ky", "proof (subst ky, rule aligned_add_offset_mod)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_aligned y sz\n 2. ky < 2 ^ sz", "show \"ky < 2 ^ sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ky < 2 ^ sz", "using kyl ky yt"], ["proof (prove)\nusing this:\n  uint y + uint ky < 2 ^ LENGTH('a)\n  z = y + ky\n  z \\<le> y + (2 ^ sz - 1)\n\ngoal (1 subgoal):\n 1. ky < 2 ^ sz", "by (rule rl)"], ["proof (state)\nthis:\n  ky < 2 ^ sz\n\ngoal (1 subgoal):\n 1. is_aligned y sz", "qed fact+"], ["proof (state)\nthis:\n  z mod 2 ^ sz = ky\n\ngoal (1 subgoal):\n 1. x = y", "finally"], ["proof (chain)\npicking this:\n  kx = ky", "have kxky: \"kx = ky\""], ["proof (prove)\nusing this:\n  kx = ky\n\ngoal (1 subgoal):\n 1. kx = ky", "."], ["proof (state)\nthis:\n  kx = ky\n\ngoal (1 subgoal):\n 1. x = y", "moreover"], ["proof (state)\nthis:\n  kx = ky\n\ngoal (1 subgoal):\n 1. x = y", "have \"x + kx = y + ky\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + kx = y + ky", "by (simp add: kx [symmetric] ky [symmetric])"], ["proof (state)\nthis:\n  x + kx = y + ky\n\ngoal (1 subgoal):\n 1. x = y", "ultimately"], ["proof (chain)\npicking this:\n  kx = ky\n  x + kx = y + ky", "show ?thesis"], ["proof (prove)\nusing this:\n  kx = ky\n  x + kx = y + ky\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>x \\<le> ya; y \\<le> ya; ya \\<le> x + (2 ^ sz - 1);\n        ya \\<le> y + (2 ^ sz - 1)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x = y", "show False"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. False", "using neq"], ["proof (prove)\nusing this:\n  x = y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}", "assume \"\\<not> sz < LENGTH('a)\""], ["proof (state)\nthis:\n  \\<not> sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}", "with neq alx aly"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  is_aligned x sz\n  is_aligned y sz\n  \\<not> sz < LENGTH('a)", "have False"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  is_aligned x sz\n  is_aligned y sz\n  \\<not> sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: is_aligned_mask mask_eq_decr_exp power_overflow)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}", ".."], ["proof (state)\nthis:\n  {x..x + (2 ^ sz - 1)} \\<inter> {y..y + (2 ^ sz - 1)} = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_add_helper:\n  \"\\<lbrakk> is_aligned p n; d < 2 ^ n \\<rbrakk>\n     \\<Longrightarrow> (p + d AND mask n = d) \\<and> (p + d AND (NOT (mask n)) = p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; d < 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> p + d AND mask n = d \\<and> p + d AND NOT (mask n) = p", "apply (subst (asm) is_aligned_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p AND mask n = 0; d < 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> p + d AND mask n = d \\<and> p + d AND NOT (mask n) = p", "apply (drule less_mask_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p AND mask n = 0; d AND mask n = d\\<rbrakk>\n    \\<Longrightarrow> p + d AND mask n = d \\<and> p + d AND NOT (mask n) = p", "apply (rule context_conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p AND mask n = 0; d AND mask n = d\\<rbrakk>\n    \\<Longrightarrow> p + d AND mask n = d\n 2. \\<lbrakk>p AND mask n = 0; d AND mask n = d;\n     p + d AND mask n = d\\<rbrakk>\n    \\<Longrightarrow> p + d AND NOT (mask n) = p", "apply (subst word_plus_and_or_coroll)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>p AND mask n = 0; d AND mask n = d\\<rbrakk>\n    \\<Longrightarrow> p AND d = 0\n 2. \\<lbrakk>p AND mask n = 0; d AND mask n = d\\<rbrakk>\n    \\<Longrightarrow> (p OR d) AND mask n = d\n 3. \\<lbrakk>p AND mask n = 0; d AND mask n = d;\n     p + d AND mask n = d\\<rbrakk>\n    \\<Longrightarrow> p + d AND NOT (mask n) = p", "apply (simp_all flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>take_bit n p = 0; take_bit n d = d\\<rbrakk>\n    \\<Longrightarrow> p AND d = 0\n 2. \\<lbrakk>take_bit n p = 0; take_bit n d = d;\n     take_bit n (p + d) = d\\<rbrakk>\n    \\<Longrightarrow> p + d AND NOT (mask n) = p", "apply (metis take_bit_eq_mask word_bw_lcs(1) word_log_esimps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>take_bit n p = 0; take_bit n d = d;\n     take_bit n (p + d) = d\\<rbrakk>\n    \\<Longrightarrow> p + d AND NOT (mask n) = p", "apply (metis add.commute add_left_imp_eq take_bit_eq_mask word_plus_and_or_coroll2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas mask_inner_mask = mask_eqs(1)"], ["", "lemma mask_add_aligned:\n  \"is_aligned p n \\<Longrightarrow> (p + q) AND mask n = q AND mask n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned p n \\<Longrightarrow> p + q AND mask n = q AND mask n", "apply (simp add: is_aligned_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p AND mask n = 0 \\<Longrightarrow> p + q AND mask n = q AND mask n", "apply (subst mask_inner_mask [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. p AND mask n = 0 \\<Longrightarrow>\n    (p AND mask n) + q AND mask n = q AND mask n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mask_out_add_aligned:\n  assumes al: \"is_aligned p n\"\n  shows \"p + (q AND NOT (mask n)) = (p + q) AND NOT (mask n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p + (q AND NOT (mask n)) = p + q AND NOT (mask n)", "using mask_add_aligned [OF al]"], ["proof (prove)\nusing this:\n  p + ?q AND mask n = ?q AND mask n\n\ngoal (1 subgoal):\n 1. p + (q AND NOT (mask n)) = p + q AND NOT (mask n)", "by (simp add: mask_out_sub_mask)"], ["", "lemma is_aligned_add_or:\n  \"\\<lbrakk>is_aligned p n; d < 2 ^ n\\<rbrakk> \\<Longrightarrow> p + d = p OR d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; d < 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> p + d = p OR d", "apply (subst disjunctive_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>is_aligned p n; d < 2 ^ n\\<rbrakk>\n       \\<Longrightarrow> \\<not> bit p na \\<or> \\<not> bit d na\n 2. \\<lbrakk>is_aligned p n; d < 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> p OR d = p OR d", "apply (simp_all add: is_aligned_iff_take_bit_eq_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>take_bit n p = 0; d < 2 ^ n\\<rbrakk>\n       \\<Longrightarrow> bit p na \\<longrightarrow> \\<not> bit d na", "apply (simp add: bit_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>na. \\<not> bit (take_bit n p) na;\n        d < 2 ^ n\\<rbrakk>\n       \\<Longrightarrow> bit p na \\<longrightarrow> \\<not> bit d na", "apply (auto simp add: bit_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>na<n. \\<not> bit p na; d < 2 ^ n; bit p na;\n        bit d na\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>na<n. \\<not> bit p na; d < 2 ^ n; bit p m;\n     bit d m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases \\<open>m < n\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>na<n. \\<not> bit p na; d < 2 ^ n; bit p m; bit d m;\n     m < n\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<forall>na<n. \\<not> bit p na; d < 2 ^ n; bit p m; bit d m;\n     \\<not> m < n\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto simp add: not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>na<n. \\<not> bit p na; d < 2 ^ n; bit p m; bit d m;\n     n \\<le> m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis bit_take_bit_iff less_mask_eq take_bit_eq_mask)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_greatest_aligned:\n  \"\\<lbrakk> x < y; is_aligned x n; is_aligned y n \\<rbrakk> \\<Longrightarrow> x + 2 ^ n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; is_aligned x n; is_aligned y n\\<rbrakk>\n    \\<Longrightarrow> x + 2 ^ n \\<noteq> 0", "by (metis NOT_mask add_diff_cancel_right' diff_0 is_aligned_neg_mask_eq not_le word_and_le1)"], ["", "lemma neg_mask_mono_le:\n  \"x \\<le> y \\<Longrightarrow> x AND NOT(mask n) \\<le> y AND NOT(mask n)\" for x :: \"'a :: len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x AND NOT (mask n) \\<le> y AND NOT (mask n)", "proof (rule ccontr, simp add: linorder_not_le, cases \"n < LENGTH('a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> n < LENGTH('a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     \\<not> n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> n < LENGTH('a)", "show \"y AND NOT(mask n) < x AND NOT(mask n) \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  \\<not> n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. y AND NOT (mask n) < x AND NOT (mask n) \\<Longrightarrow> False", "by (simp add: mask_eq_decr_exp linorder_not_less power_overflow)"], ["proof (state)\nthis:\n  y AND NOT (mask n) < x AND NOT (mask n) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "assume a: \"x \\<le> y\" and b: \"y AND NOT(mask n) < x AND NOT(mask n)\""], ["proof (state)\nthis:\n  x \\<le> y\n  y AND NOT (mask n) < x AND NOT (mask n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "have word_bits: \"n < LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < LENGTH('a)", "by fact"], ["proof (state)\nthis:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "have \"y \\<le> (y AND NOT(mask n)) + (y AND mask n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> (y AND NOT (mask n)) + (y AND mask n)", "by (simp add: word_plus_and_or_coroll2 add.commute)"], ["proof (state)\nthis:\n  y \\<le> (y AND NOT (mask n)) + (y AND mask n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  y \\<le> (y AND NOT (mask n)) + (y AND mask n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<dots> \\<le> (y AND NOT(mask n)) + 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y AND NOT (mask n)) + (y AND mask n) \\<le> (y AND NOT (mask n)) + 2 ^ n", "apply (rule word_plus_mono_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y AND mask n \\<le> 2 ^ n\n 2. y AND NOT (mask n) \\<le> (y AND NOT (mask n)) + 2 ^ n", "apply (rule order_less_imp_le, rule and_mask_less_size)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < size y\n 2. y AND NOT (mask n) \\<le> (y AND NOT (mask n)) + 2 ^ n", "apply (simp add: word_size word_bits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y AND NOT (mask n) \\<le> (y AND NOT (mask n)) + 2 ^ n", "apply (rule is_aligned_no_overflow'', simp add: is_aligned_neg_mask word_bits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y AND NOT (mask n)) + 2 ^ n \\<noteq> 0", "apply (rule not_greatest_aligned, rule b; simp add: is_aligned_neg_mask)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (y AND NOT (mask n)) + (y AND mask n) \\<le> (y AND NOT (mask n)) + 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (y AND NOT (mask n)) + (y AND mask n) \\<le> (y AND NOT (mask n)) + 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<dots> \\<le> x AND NOT(mask n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y AND NOT (mask n)) + 2 ^ n \\<le> x AND NOT (mask n)", "using b"], ["proof (prove)\nusing this:\n  y AND NOT (mask n) < x AND NOT (mask n)\n\ngoal (1 subgoal):\n 1. (y AND NOT (mask n)) + 2 ^ n \\<le> x AND NOT (mask n)", "apply (subst add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y AND NOT (mask n) < x AND NOT (mask n) \\<Longrightarrow>\n    2 ^ n + (y AND NOT (mask n)) \\<le> x AND NOT (mask n)", "apply (rule le_plus)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y AND NOT (mask n) < x AND NOT (mask n) \\<Longrightarrow>\n    y AND NOT (mask n) \\<le> (x AND NOT (mask n)) - 2 ^ n\n 2. y AND NOT (mask n) < x AND NOT (mask n) \\<Longrightarrow>\n    2 ^ n \\<le> x AND NOT (mask n)", "apply (rule aligned_at_least_t2n_diff; simp add: is_aligned_neg_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y AND NOT (mask n) < x AND NOT (mask n) \\<Longrightarrow>\n    2 ^ n \\<le> x AND NOT (mask n)", "apply (rule ccontr, simp add: linorder_not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y AND NOT (mask n) < x AND NOT (mask n);\n     x AND NOT (mask n) < 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule aligned_small_is_0[rotated]; simp add: is_aligned_neg_mask)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (y AND NOT (mask n)) + 2 ^ n \\<le> x AND NOT (mask n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (y AND NOT (mask n)) + 2 ^ n \\<le> x AND NOT (mask n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<dots> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND NOT (mask n) \\<le> x", "by (rule word_and_le2)"], ["proof (state)\nthis:\n  x AND NOT (mask n) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  x AND NOT (mask n) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "have \"x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y", "by fact"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y AND NOT (mask n) < x AND NOT (mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  y = x", "show \"False\""], ["proof (prove)\nusing this:\n  y = x\n\ngoal (1 subgoal):\n 1. False", "using b"], ["proof (prove)\nusing this:\n  y = x\n  y AND NOT (mask n) < x AND NOT (mask n)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma and_neg_mask_eq_iff_not_mask_le:\n  \"w AND NOT(mask n) = NOT(mask n) \\<longleftrightarrow> NOT(mask n) \\<le> w\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w AND NOT (mask n) = NOT (mask n)) = (NOT (mask n) \\<le> w)", "by (metis eq_iff neg_mask_mono_le word_and_le1 word_and_le2 word_bw_same(1))"], ["", "lemma neg_mask_le_high_bits [word_eqI_simps]:\n  \"NOT(mask n) \\<le> w \\<longleftrightarrow> (\\<forall>i \\<in> {n ..< size w}. w !! i)\"\n  for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (NOT (mask n) \\<le> w) = (\\<forall>i\\<in>{n..<size w}. w !! i)", "by (auto simp: word_size and_neg_mask_eq_iff_not_mask_le[symmetric] word_eq_iff neg_mask_test_bit)"], ["", "lemma is_aligned_add_less_t2n:\n  \"\\<lbrakk>is_aligned (p::'a::len word) n; d < 2^n; n \\<le> m; p < 2^m\\<rbrakk> \\<Longrightarrow> p + d < 2^m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> p + d < 2 ^ m", "apply (case_tac \"m < LENGTH('a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p + d < 2 ^ m\n 2. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p + d < 2 ^ m", "apply (subst mask_eq_iff_w2p[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m < size (p + d)\n 2. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p + d AND mask m = p + d\n 3. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p + d < 2 ^ m", "apply (simp add: word_size)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p + d AND mask m = p + d\n 2. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p + d < 2 ^ m", "apply (simp add: is_aligned_add_or word_ao_dist less_mask_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p OR d AND mask m = p OR d\n 2. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p + d < 2 ^ m", "apply (subst less_mask_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> d < 2 ^ m\n 2. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p OR d = p OR d\n 3. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p + d < 2 ^ m", "apply (erule order_less_le_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned p n; n \\<le> m; p < 2 ^ m; m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n \\<le> 2 ^ m\n 2. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p OR d = p OR d\n 3. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p + d < 2 ^ m", "apply (erule(1) two_power_increasing)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p OR d = p OR d\n 2. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p + d < 2 ^ m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; d < 2 ^ n; n \\<le> m; p < 2 ^ m;\n     \\<not> m < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p + d < 2 ^ m", "apply (simp add: power_overflow)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aligned_offset_non_zero:\n  \"\\<lbrakk> is_aligned x n; y < 2 ^ n; x \\<noteq> 0 \\<rbrakk> \\<Longrightarrow> x + y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; y < 2 ^ n; x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x + y \\<noteq> 0", "apply (cases \"y = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; y < 2 ^ n; x \\<noteq> 0; y = 0\\<rbrakk>\n    \\<Longrightarrow> x + y \\<noteq> 0\n 2. \\<lbrakk>is_aligned x n; y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x + y \\<noteq> 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x + y \\<noteq> 0", "apply (subst word_neq_0_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < x + y", "apply (subst gt0_iff_gem1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x + y - 1 < x + y", "apply (erule is_aligned_get_word_bits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x + y - 1 < x + y\n 2. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; x = 0;\n     LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x + y - 1 < x + y", "apply (subst field_simps[symmetric], subst plus_le_left_cancel_nowrap)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + (y - 1)\n 2. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + y\n 3. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y - 1 < y\n 4. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; x = 0;\n     LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x + y - 1 < x + y", "apply (rule is_aligned_no_wrap')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned x ?sz8\n 2. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y - 1 < 2 ^ ?sz8\n 3. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + y\n 4. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y - 1 < y\n 5. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; x = 0;\n     LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x + y - 1 < x + y", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y - 1 < 2 ^ n\n 2. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + y\n 3. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y - 1 < y\n 4. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; x = 0;\n     LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x + y - 1 < x + y", "apply (rule word_leq_le_minus_one)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y \\<le> 2 ^ n\n 2. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y \\<noteq> 0\n 3. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + y\n 4. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y - 1 < y\n 5. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; x = 0;\n     LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x + y - 1 < x + y", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y \\<noteq> 0\n 2. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + y\n 3. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y - 1 < y\n 4. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; x = 0;\n     LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x + y - 1 < x + y", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + y\n 2. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y - 1 < y\n 3. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; x = 0;\n     LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x + y - 1 < x + y", "apply (erule (1) is_aligned_no_wrap')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; is_aligned x n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y - 1 < y\n 2. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; x = 0;\n     LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x + y - 1 < x + y", "apply (simp add: gt0_iff_gem1 [symmetric] word_neq_0_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < 2 ^ n; x \\<noteq> 0; y \\<noteq> 0; x = 0;\n     LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> x + y - 1 < x + y", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_aligned_over_length:\n  \"\\<lbrakk> is_aligned p n; LENGTH('a) \\<le> n \\<rbrakk> \\<Longrightarrow> (p::'a::len word) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> p = 0", "by (simp add: is_aligned_mask mask_over_length)"], ["", "lemma is_aligned_no_overflow_mask:\n  \"is_aligned x n \\<Longrightarrow> x \\<le> x + mask n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned x n \\<Longrightarrow> x \\<le> x + mask n", "by (simp add: mask_eq_decr_exp) (erule is_aligned_no_overflow')"], ["", "lemma aligned_mask_step:\n  \"\\<lbrakk> n' \\<le> n; p' \\<le> p + mask n; is_aligned p n; is_aligned p' n' \\<rbrakk> \\<Longrightarrow>\n   (p'::'a::len word) + mask n' \\<le> p + mask n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n' \\<le> n; p' \\<le> p + mask n; is_aligned p n;\n     is_aligned p' n'\\<rbrakk>\n    \\<Longrightarrow> p' + mask n' \\<le> p + mask n", "apply (cases \"LENGTH('a) \\<le> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n' \\<le> n; p' \\<le> p + mask n; is_aligned p n;\n     is_aligned p' n'; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> p' + mask n' \\<le> p + mask n\n 2. \\<lbrakk>n' \\<le> n; p' \\<le> p + mask n; is_aligned p n;\n     is_aligned p' n'; \\<not> LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> p' + mask n' \\<le> p + mask n", "apply (frule (1) is_aligned_over_length)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n' \\<le> n; p' \\<le> p + mask n; is_aligned p n;\n     is_aligned p' n'; LENGTH('a) \\<le> n; p = 0\\<rbrakk>\n    \\<Longrightarrow> p' + mask n' \\<le> p + mask n\n 2. \\<lbrakk>n' \\<le> n; p' \\<le> p + mask n; is_aligned p n;\n     is_aligned p' n'; \\<not> LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> p' + mask n' \\<le> p + mask n", "apply (drule mask_over_length)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n' \\<le> n; p' \\<le> p + mask n; is_aligned p n;\n     is_aligned p' n'; p = 0; mask n = - 1\\<rbrakk>\n    \\<Longrightarrow> p' + mask n' \\<le> p + mask n\n 2. \\<lbrakk>n' \\<le> n; p' \\<le> p + mask n; is_aligned p n;\n     is_aligned p' n'; \\<not> LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> p' + mask n' \\<le> p + mask n", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n' \\<le> n; p' \\<le> p + mask n; is_aligned p n;\n     is_aligned p' n'; \\<not> LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> p' + mask n' \\<le> p + mask n", "apply (simp add: not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n' \\<le> n; p' \\<le> p + mask n; is_aligned p n;\n     is_aligned p' n'; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> p' + mask n' \\<le> p + mask n", "apply (simp add: word_le_nat_alt unat_plus_simple)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n' \\<le> n; unat p' \\<le> unat (p + mask n); is_aligned p n;\n     is_aligned p' n'; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat (p' + mask n') \\<le> unat (p + mask n)", "apply (subst unat_plus_simple[THEN iffD1], erule is_aligned_no_overflow_mask)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n' \\<le> n; unat p' \\<le> unat (p + mask n); is_aligned p n;\n     is_aligned p' n'; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat p' + unat (mask n') \\<le> unat p + unat (mask n)", "apply (subst (asm) unat_plus_simple[THEN iffD1], erule is_aligned_no_overflow_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n' \\<le> n; unat p' \\<le> unat p + unat (mask n);\n     is_aligned p n; is_aligned p' n'; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat p' + unat (mask n') \\<le> unat p + unat (mask n)", "apply (clarsimp simp: dvd_def is_aligned_iff_dvd_nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k ka.\n       \\<lbrakk>n' \\<le> n; 2 ^ n' * ka \\<le> 2 ^ n * k + unat (mask n);\n        n < LENGTH('a); unat p = 2 ^ n * k; unat p' = 2 ^ n' * ka\\<rbrakk>\n       \\<Longrightarrow> 2 ^ n' * ka + unat (mask n')\n                         \\<le> 2 ^ n * k + unat (mask n)", "apply (rename_tac k k')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k k'.\n       \\<lbrakk>n' \\<le> n; 2 ^ n' * k' \\<le> 2 ^ n * k + unat (mask n);\n        n < LENGTH('a); unat p = 2 ^ n * k; unat p' = 2 ^ n' * k'\\<rbrakk>\n       \\<Longrightarrow> 2 ^ n' * k' + unat (mask n')\n                         \\<le> 2 ^ n * k + unat (mask n)", "apply (thin_tac \"unat p = x\" for p x)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k k'.\n       \\<lbrakk>n' \\<le> n; 2 ^ n' * k' \\<le> 2 ^ n * k + unat (mask n);\n        n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ n' * k' + unat (mask n')\n                         \\<le> 2 ^ n * k + unat (mask n)", "apply (subst Suc_le_mono[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k k'.\n       \\<lbrakk>n' \\<le> n; 2 ^ n' * k' \\<le> 2 ^ n * k + unat (mask n);\n        n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> Suc (2 ^ n' * k' + unat (mask n'))\n                         \\<le> Suc (2 ^ n * k + unat (mask n))", "apply (simp only: Suc_2p_unat_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k k'.\n       \\<lbrakk>n' \\<le> n; 2 ^ n' * k' \\<le> 2 ^ n * k + unat (mask n);\n        n < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ n' * (k' + 1) \\<le> 2 ^ n * (k + 1)", "apply (drule le_imp_less_Suc, subst (asm) Suc_2p_unat_mask, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k k'.\n       \\<lbrakk>n' \\<le> n; n < LENGTH('a);\n        2 ^ n' * k' < 2 ^ n * (k + 1)\\<rbrakk>\n       \\<Longrightarrow> 2 ^ n' * (k' + 1) \\<le> 2 ^ n * (k + 1)", "apply (erule (1) power_2_mult_step_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_aligned_mask_offset_unat:\n  fixes off :: \"('a::len) word\"\n  and     x :: \"'a word\"\n  assumes al: \"is_aligned x sz\"\n  and   offv: \"off \\<le> mask sz\"\n  shows  \"unat x + unat off < 2 ^ LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x + unat off < 2 ^ LENGTH('a)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)\n 2. \\<not> ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)", "assume szv: \"sz < LENGTH('a)\""], ["proof (state)\nthis:\n  sz < LENGTH('a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)\n 2. \\<not> ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)", "from al"], ["proof (chain)\npicking this:\n  is_aligned x sz", "obtain k where xv: \"x = 2 ^ sz * (of_nat k)\"\n    and kl: \"k < 2 ^ (LENGTH('a) - sz)\""], ["proof (prove)\nusing this:\n  is_aligned x sz\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>x = 2 ^ sz * word_of_nat k;\n         k < 2 ^ (LENGTH('a) - sz)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: is_alignedE)"], ["proof (state)\nthis:\n  x = 2 ^ sz * word_of_nat k\n  k < 2 ^ (LENGTH('a) - sz)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)\n 2. \\<not> ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)", "from offv szv"], ["proof (chain)\npicking this:\n  off \\<le> mask sz\n  sz < LENGTH('a)", "have offv': \"unat off < 2 ^ sz\""], ["proof (prove)\nusing this:\n  off \\<le> mask sz\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat off < 2 ^ sz", "by (simp add: mask_2pm1 unat_less_power)"], ["proof (state)\nthis:\n  unat off < 2 ^ sz\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)\n 2. \\<not> ?P \\<Longrightarrow> unat x + unat off < 2 ^ LENGTH('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x + unat off < 2 ^ LENGTH('a)", "using szv"], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat x + unat off < 2 ^ LENGTH('a)", "using al is_aligned_no_wrap''' offv'"], ["proof (prove)\nusing this:\n  sz < LENGTH('a)\n  is_aligned x sz\n  \\<lbrakk>is_aligned ?ptr ?sz; ?sz < LENGTH(?'a); ?off < 2 ^ ?sz\\<rbrakk>\n  \\<Longrightarrow> unat ?ptr + ?off < 2 ^ LENGTH(?'a)\n  unat off < 2 ^ sz\n\ngoal (1 subgoal):\n 1. unat x + unat off < 2 ^ LENGTH('a)", "by blast"], ["proof (state)\nthis:\n  unat x + unat off < 2 ^ LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    unat x + unat off < 2 ^ LENGTH('a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    unat x + unat off < 2 ^ LENGTH('a)", "assume \"\\<not> sz < LENGTH('a)\""], ["proof (state)\nthis:\n  \\<not> sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    unat x + unat off < 2 ^ LENGTH('a)", "with al"], ["proof (chain)\npicking this:\n  is_aligned x sz\n  \\<not> sz < LENGTH('a)", "have \"x = 0\""], ["proof (prove)\nusing this:\n  is_aligned x sz\n  \\<not> sz < LENGTH('a)\n\ngoal (1 subgoal):\n 1. x = 0", "by (meson is_aligned_get_word_bits)"], ["proof (state)\nthis:\n  x = 0\n\ngoal (1 subgoal):\n 1. \\<not> sz < LENGTH('a) \\<Longrightarrow>\n    unat x + unat off < 2 ^ LENGTH('a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. unat x + unat off < 2 ^ LENGTH('a)", "by simp"], ["proof (state)\nthis:\n  unat x + unat off < 2 ^ LENGTH('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aligned_less_plus_1:\n  \"\\<lbrakk> is_aligned x n; n > 0 \\<rbrakk> \\<Longrightarrow> x < x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; 0 < n\\<rbrakk> \\<Longrightarrow> x < x + 1", "apply (rule plus_one_helper2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; 0 < n\\<rbrakk> \\<Longrightarrow> x \\<le> x\n 2. \\<lbrakk>is_aligned x n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> x + 1 \\<noteq> 0", "apply (rule order_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> x + 1 \\<noteq> 0", "apply (clarsimp simp: field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; 0 < n; 1 + x = 0\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule arg_cong[where f=\"\\<lambda>x. x - 1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; 0 < n; 1 + x - 1 = 0 - 1\\<rbrakk>\n    \\<Longrightarrow> False", "apply (clarsimp simp: is_aligned_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mask n = 0; 0 < n; x = - 1\\<rbrakk> \\<Longrightarrow> False", "apply (drule word_eqD[where x=0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; x = - 1; mask n !! 0 = 0 !! 0\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aligned_add_offset_less:\n  \"\\<lbrakk>is_aligned x n; is_aligned y n; x < y; z < 2 ^ n\\<rbrakk> \\<Longrightarrow> x + z < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; is_aligned y n; x < y; z < 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (cases \"y = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; is_aligned y n; x < y; z < 2 ^ n;\n     y = 0\\<rbrakk>\n    \\<Longrightarrow> x + z < y\n 2. \\<lbrakk>is_aligned x n; is_aligned y n; x < y; z < 2 ^ n;\n     y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; is_aligned y n; x < y; z < 2 ^ n;\n     y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (erule is_aligned_get_word_bits[where p=y], simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; x < y; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (cases \"z = 0\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; x < y; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (drule(2) aligned_at_least_t2n_diff[rotated -1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; x \\<le> y - 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (drule plus_one_helper2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> y - 2 ^ n + 1 \\<noteq> 0\n 2. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; x < y - 2 ^ n + 1\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (rule less_is_non_zero_p1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> y - 2 ^ n < ?k12\n 2. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; x < y - 2 ^ n + 1\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (rule aligned_less_plus_1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> is_aligned (y - 2 ^ n) ?n14\n 2. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < ?n14\n 3. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; x < y - 2 ^ n + 1\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (erule aligned_sub_aligned[OF _ _ order_refl],\n           simp_all add: is_aligned_triv)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < n\n 2. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; x < y - 2 ^ n + 1\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (cases n, simp_all)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; x < y - 2 ^ n + 1\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (simp only: trans[OF diff_add_eq diff_diff_eq2[symmetric]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; x < y - (2 ^ n - 1)\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (drule word_less_add_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n - 1 \\<le> y\n 2. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; x + (2 ^ n - 1) < y\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (rule ccontr, simp add: linorder_not_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; y < 2 ^ n - 1\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; x + (2 ^ n - 1) < y\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (drule aligned_small_is_0, erule order_less_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; n < LENGTH('a);\n     z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 2 ^ n - 1 < 2 ^ n\n 2. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; n < LENGTH('a);\n     z \\<noteq> 0; y < 2 ^ n - 1; y = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; x + (2 ^ n - 1) < y\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (clarsimp simp: power_overflow)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; n < LENGTH('a);\n     z \\<noteq> 0; y < 2 ^ n - 1; y = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; x + (2 ^ n - 1) < y\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0; x + (2 ^ n - 1) < y\\<rbrakk>\n    \\<Longrightarrow> x + z < y", "apply (erule order_le_less_trans[rotated],\n         rule word_plus_mono_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> z \\<le> 2 ^ n - 1\n 2. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + (2 ^ n - 1)", "apply (erule word_le_minus_one_leq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; z < 2 ^ n; y \\<noteq> 0; is_aligned y n;\n     n < LENGTH('a); z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x + (2 ^ n - 1)", "apply (simp add: is_aligned_no_wrap' is_aligned_no_overflow field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gap_between_aligned:\n  \"\\<lbrakk>a < (b :: 'a ::len word); is_aligned a n; is_aligned b n; n < LENGTH('a) \\<rbrakk>\n  \\<Longrightarrow> a + (2^n - 1) < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < b; is_aligned a n; is_aligned b n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> a + (2 ^ n - 1) < b", "by (simp add: aligned_add_offset_less)"], ["", "lemma is_aligned_add_step_le:\n  \"\\<lbrakk> is_aligned (a::'a::len word) n; is_aligned b n; a < b; b \\<le> a + mask n \\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; is_aligned b n; a < b;\n     b \\<le> a + mask n\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp flip: not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; is_aligned b n; \\<not> b \\<le> a;\n     b \\<le> a + mask n\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule notE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; is_aligned b n; b \\<le> a + mask n\\<rbrakk>\n    \\<Longrightarrow> b \\<le> a", "apply (cases \"LENGTH('a) \\<le> n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned a n; is_aligned b n; b \\<le> a + mask n;\n     LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> b \\<le> a\n 2. \\<lbrakk>is_aligned a n; is_aligned b n; b \\<le> a + mask n;\n     \\<not> LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> b \\<le> a", "apply (drule (1) is_aligned_over_length)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<le> a + mask n; LENGTH('a) \\<le> n; a = 0; b = 0\\<rbrakk>\n    \\<Longrightarrow> b \\<le> a\n 2. \\<lbrakk>is_aligned a n; is_aligned b n; b \\<le> a + mask n;\n     \\<not> LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> b \\<le> a", "apply (drule mask_over_length)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<le> a + mask n; a = 0; b = 0; mask n = - 1\\<rbrakk>\n    \\<Longrightarrow> b \\<le> a\n 2. \\<lbrakk>is_aligned a n; is_aligned b n; b \\<le> a + mask n;\n     \\<not> LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> b \\<le> a", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; is_aligned b n; b \\<le> a + mask n;\n     \\<not> LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> b \\<le> a", "apply (clarsimp simp: word_le_nat_alt not_less not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; is_aligned b n; unat b \\<le> unat (a + mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat b \\<le> unat a", "apply (subst (asm) unat_plus_simple[THEN iffD1], erule is_aligned_no_overflow_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; is_aligned b n;\n     unat b \\<le> unat a + unat (mask n); n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat b \\<le> unat a", "apply (subst (asm) unat_add_lem' [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < LENGTH('a); is_aligned a n; is_aligned b n\\<rbrakk>\n    \\<Longrightarrow> unat a + unat (mask n) < 2 ^ LENGTH('a)\n 2. \\<lbrakk>is_aligned a n; is_aligned b n; unat b \\<le> unat (a + mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat b \\<le> unat a", "apply (simp add: is_aligned_mask_offset_unat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned a n; is_aligned b n; unat b \\<le> unat (a + mask n);\n     n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> unat b \\<le> unat a", "apply (metis gap_between_aligned linorder_not_less mask_eq_decr_exp unat_arith_simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aligned_add_mask_lessD:\n  \"\\<lbrakk> x + mask n < y; is_aligned x n \\<rbrakk> \\<Longrightarrow> x < y\" for y::\"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x + mask n < y; is_aligned x n\\<rbrakk> \\<Longrightarrow> x < y", "by (metis is_aligned_no_overflow' mask_2pm1 order_le_less_trans)"], ["", "lemma aligned_add_mask_less_eq:\n  \"\\<lbrakk> is_aligned x n; is_aligned y n;  n < LENGTH('a) \\<rbrakk> \\<Longrightarrow> (x + mask n < y) = (x < y)\"\n  for y::\"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; is_aligned y n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + mask n < y) = (x < y)", "using aligned_add_mask_lessD is_aligned_add_step_le word_le_not_less"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x + mask ?n < ?y; is_aligned ?x ?n\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y\n  \\<lbrakk>is_aligned ?a ?n; is_aligned ?b ?n; ?a < ?b;\n   ?b \\<le> ?a + mask ?n\\<rbrakk>\n  \\<Longrightarrow> False\n  (?b \\<le> ?a) = (\\<not> ?a < ?b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; is_aligned y n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> (x + mask n < y) = (x < y)", "by blast"], ["", "lemma is_aligned_diff:\n  fixes m :: \"'a::len word\"\n  assumes alm: \"is_aligned m s1\"\n  and     aln: \"is_aligned n s2\"\n  and    s2wb: \"s2 < LENGTH('a)\"\n  and      nm: \"m \\<in> {n .. n + (2 ^ s2 - 1)}\"\n  and    s1s2: \"s1 \\<le> s2\"\n  and     s10: \"0 < s1\" (* Probably can be folded into the proof \\<dots> *)\nshows  \"\\<exists>q. m - n = of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "have rl: \"\\<And>m s. \\<lbrakk> m < 2 ^ (LENGTH('a) - s); s < LENGTH('a) \\<rbrakk> \\<Longrightarrow> unat ((2::'a word) ^ s * of_nat m) = 2 ^ s * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m s.\n       \\<lbrakk>m < 2 ^ (LENGTH('a) - s); s < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> unat (2 ^ s * word_of_nat m) = 2 ^ s * m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m s.\n       \\<lbrakk>m < 2 ^ (LENGTH('a) - s); s < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> unat (2 ^ s * word_of_nat m) = 2 ^ s * m", "fix m :: nat and  s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m s.\n       \\<lbrakk>m < 2 ^ (LENGTH('a) - s); s < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> unat (2 ^ s * word_of_nat m) = 2 ^ s * m", "assume m: \"m < 2 ^ (LENGTH('a) - s)\" and s: \"s < LENGTH('a)\""], ["proof (state)\nthis:\n  m < 2 ^ (LENGTH('a) - s)\n  s < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<And>m s.\n       \\<lbrakk>m < 2 ^ (LENGTH('a) - s); s < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> unat (2 ^ s * word_of_nat m) = 2 ^ s * m", "then"], ["proof (chain)\npicking this:\n  m < 2 ^ (LENGTH('a) - s)\n  s < LENGTH('a)", "have \"unat ((of_nat m) :: 'a word) = m\""], ["proof (prove)\nusing this:\n  m < 2 ^ (LENGTH('a) - s)\n  s < LENGTH('a)\n\ngoal (1 subgoal):\n 1. unat (word_of_nat m) = m", "apply (subst unat_of_nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < 2 ^ (LENGTH('a) - s); s < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m mod 2 ^ LENGTH('a) = m", "apply (subst mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m < 2 ^ (LENGTH('a) - s); s < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m < 2 ^ LENGTH('a)\n 2. \\<lbrakk>m < 2 ^ (LENGTH('a) - s); s < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m = m", "apply (erule order_less_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s < LENGTH('a) \\<Longrightarrow>\n    2 ^ (LENGTH('a) - s) \\<le> 2 ^ LENGTH('a)\n 2. \\<lbrakk>m < 2 ^ (LENGTH('a) - s); s < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m = m", "apply (rule power_increasing)"], ["proof (prove)\ngoal (3 subgoals):\n 1. s < LENGTH('a) \\<Longrightarrow> LENGTH('a) - s \\<le> LENGTH('a)\n 2. s < LENGTH('a) \\<Longrightarrow> 1 \\<le> 2\n 3. \\<lbrakk>m < 2 ^ (LENGTH('a) - s); s < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> m = m", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unat (word_of_nat m) = m\n\ngoal (1 subgoal):\n 1. \\<And>m s.\n       \\<lbrakk>m < 2 ^ (LENGTH('a) - s); s < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> unat (2 ^ s * word_of_nat m) = 2 ^ s * m", "then"], ["proof (chain)\npicking this:\n  unat (word_of_nat m) = m", "show \"?thesis m s\""], ["proof (prove)\nusing this:\n  unat (word_of_nat m) = m\n\ngoal (1 subgoal):\n 1. unat (2 ^ s * word_of_nat m) = 2 ^ s * m", "using s m"], ["proof (prove)\nusing this:\n  unat (word_of_nat m) = m\n  s < LENGTH('a)\n  m < 2 ^ (LENGTH('a) - s)\n\ngoal (1 subgoal):\n 1. unat (2 ^ s * word_of_nat m) = 2 ^ s * m", "apply (subst iffD1 [OF unat_mult_lem])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>unat (word_of_nat m) = m; s < LENGTH('a);\n     m < 2 ^ (LENGTH('a) - s)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ s) * unat (word_of_nat m) < 2 ^ LENGTH('a)\n 2. \\<lbrakk>unat (word_of_nat m) = m; s < LENGTH('a);\n     m < 2 ^ (LENGTH('a) - s)\\<rbrakk>\n    \\<Longrightarrow> unat (2 ^ s) * unat (word_of_nat m) = 2 ^ s * m", "apply (simp add: nat_less_power_trans)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unat (2 ^ s * word_of_nat m) = 2 ^ s * m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?m < 2 ^ (LENGTH('a) - ?s); ?s < LENGTH('a)\\<rbrakk>\n  \\<Longrightarrow> unat (2 ^ ?s * word_of_nat ?m) = 2 ^ ?s * ?m\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "have s1wb: \"s1 < LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 < LENGTH('a)", "using s2wb s1s2"], ["proof (prove)\nusing this:\n  s2 < LENGTH('a)\n  s1 \\<le> s2\n\ngoal (1 subgoal):\n 1. s1 < LENGTH('a)", "by simp"], ["proof (state)\nthis:\n  s1 < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "from alm"], ["proof (chain)\npicking this:\n  is_aligned m s1", "obtain mq where mmq: \"m = 2 ^ s1 * of_nat mq\" and mq: \"mq < 2 ^ (LENGTH('a) - s1)\""], ["proof (prove)\nusing this:\n  is_aligned m s1\n\ngoal (1 subgoal):\n 1. (\\<And>mq.\n        \\<lbrakk>m = 2 ^ s1 * word_of_nat mq;\n         mq < 2 ^ (LENGTH('a) - s1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: is_alignedE simp: field_simps)"], ["proof (state)\nthis:\n  m = 2 ^ s1 * word_of_nat mq\n  mq < 2 ^ (LENGTH('a) - s1)\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "from aln"], ["proof (chain)\npicking this:\n  is_aligned n s2", "obtain nq where nnq: \"n = 2 ^ s2 * of_nat nq\" and nq: \"nq < 2 ^ (LENGTH('a) - s2)\""], ["proof (prove)\nusing this:\n  is_aligned n s2\n\ngoal (1 subgoal):\n 1. (\\<And>nq.\n        \\<lbrakk>n = 2 ^ s2 * word_of_nat nq;\n         nq < 2 ^ (LENGTH('a) - s2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: is_alignedE simp: field_simps)"], ["proof (state)\nthis:\n  n = 2 ^ s2 * word_of_nat nq\n  nq < 2 ^ (LENGTH('a) - s2)\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "from s1s2"], ["proof (chain)\npicking this:\n  s1 \\<le> s2", "obtain sq where sq: \"s2 = s1 + sq\""], ["proof (prove)\nusing this:\n  s1 \\<le> s2\n\ngoal (1 subgoal):\n 1. (\\<And>sq. s2 = s1 + sq \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: le_iff_add)"], ["proof (state)\nthis:\n  s2 = s1 + sq\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "note us1 = rl [OF mq s1wb]"], ["proof (state)\nthis:\n  unat (2 ^ s1 * word_of_nat mq) = 2 ^ s1 * mq\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "note us2 = rl [OF nq s2wb]"], ["proof (state)\nthis:\n  unat (2 ^ s2 * word_of_nat nq) = 2 ^ s2 * nq\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "from nm"], ["proof (chain)\npicking this:\n  m \\<in> {n..n + (2 ^ s2 - 1)}", "have \"n \\<le> m\""], ["proof (prove)\nusing this:\n  m \\<in> {n..n + (2 ^ s2 - 1)}\n\ngoal (1 subgoal):\n 1. n \\<le> m", "by clarsimp"], ["proof (state)\nthis:\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "then"], ["proof (chain)\npicking this:\n  n \\<le> m", "have \"(2::'a word) ^ s2 * of_nat nq \\<le> 2 ^ s1 * of_nat mq\""], ["proof (prove)\nusing this:\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. 2 ^ s2 * word_of_nat nq \\<le> 2 ^ s1 * word_of_nat mq", "using nnq mmq"], ["proof (prove)\nusing this:\n  n \\<le> m\n  n = 2 ^ s2 * word_of_nat nq\n  m = 2 ^ s1 * word_of_nat mq\n\ngoal (1 subgoal):\n 1. 2 ^ s2 * word_of_nat nq \\<le> 2 ^ s1 * word_of_nat mq", "by simp"], ["proof (state)\nthis:\n  2 ^ s2 * word_of_nat nq \\<le> 2 ^ s1 * word_of_nat mq\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "then"], ["proof (chain)\npicking this:\n  2 ^ s2 * word_of_nat nq \\<le> 2 ^ s1 * word_of_nat mq", "have \"2 ^ s2 * nq \\<le> 2 ^ s1 * mq\""], ["proof (prove)\nusing this:\n  2 ^ s2 * word_of_nat nq \\<le> 2 ^ s1 * word_of_nat mq\n\ngoal (1 subgoal):\n 1. 2 ^ s2 * nq \\<le> 2 ^ s1 * mq", "using s1wb s2wb"], ["proof (prove)\nusing this:\n  2 ^ s2 * word_of_nat nq \\<le> 2 ^ s1 * word_of_nat mq\n  s1 < LENGTH('a)\n  s2 < LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ s2 * nq \\<le> 2 ^ s1 * mq", "by (simp add: word_le_nat_alt us1 us2)"], ["proof (state)\nthis:\n  2 ^ s2 * nq \\<le> 2 ^ s1 * mq\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "then"], ["proof (chain)\npicking this:\n  2 ^ s2 * nq \\<le> 2 ^ s1 * mq", "have nqmq: \"2 ^ sq * nq \\<le> mq\""], ["proof (prove)\nusing this:\n  2 ^ s2 * nq \\<le> 2 ^ s1 * mq\n\ngoal (1 subgoal):\n 1. 2 ^ sq * nq \\<le> mq", "using sq"], ["proof (prove)\nusing this:\n  2 ^ s2 * nq \\<le> 2 ^ s1 * mq\n  s2 = s1 + sq\n\ngoal (1 subgoal):\n 1. 2 ^ sq * nq \\<le> mq", "by (simp add: power_add)"], ["proof (state)\nthis:\n  2 ^ sq * nq \\<le> mq\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "have \"m - n = 2 ^ s1 * of_nat mq - 2 ^ s2 * of_nat nq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m - n = 2 ^ s1 * word_of_nat mq - 2 ^ s2 * word_of_nat nq", "using mmq nnq"], ["proof (prove)\nusing this:\n  m = 2 ^ s1 * word_of_nat mq\n  n = 2 ^ s2 * word_of_nat nq\n\ngoal (1 subgoal):\n 1. m - n = 2 ^ s1 * word_of_nat mq - 2 ^ s2 * word_of_nat nq", "by simp"], ["proof (state)\nthis:\n  m - n = 2 ^ s1 * word_of_nat mq - 2 ^ s2 * word_of_nat nq\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "also"], ["proof (state)\nthis:\n  m - n = 2 ^ s1 * word_of_nat mq - 2 ^ s2 * word_of_nat nq\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "have \"\\<dots> = 2 ^ s1 * of_nat mq - 2 ^ s1 * 2 ^ sq * of_nat nq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ s1 * word_of_nat mq - 2 ^ s2 * word_of_nat nq =\n    2 ^ s1 * word_of_nat mq - 2 ^ s1 * 2 ^ sq * word_of_nat nq", "using sq"], ["proof (prove)\nusing this:\n  s2 = s1 + sq\n\ngoal (1 subgoal):\n 1. 2 ^ s1 * word_of_nat mq - 2 ^ s2 * word_of_nat nq =\n    2 ^ s1 * word_of_nat mq - 2 ^ s1 * 2 ^ sq * word_of_nat nq", "by (simp add: power_add)"], ["proof (state)\nthis:\n  2 ^ s1 * word_of_nat mq - 2 ^ s2 * word_of_nat nq =\n  2 ^ s1 * word_of_nat mq - 2 ^ s1 * 2 ^ sq * word_of_nat nq\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "also"], ["proof (state)\nthis:\n  2 ^ s1 * word_of_nat mq - 2 ^ s2 * word_of_nat nq =\n  2 ^ s1 * word_of_nat mq - 2 ^ s1 * 2 ^ sq * word_of_nat nq\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "have \"\\<dots> = 2 ^ s1 * (of_nat mq - 2 ^ sq * of_nat nq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ s1 * word_of_nat mq - 2 ^ s1 * 2 ^ sq * word_of_nat nq =\n    2 ^ s1 * (word_of_nat mq - 2 ^ sq * word_of_nat nq)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  2 ^ s1 * word_of_nat mq - 2 ^ s1 * 2 ^ sq * word_of_nat nq =\n  2 ^ s1 * (word_of_nat mq - 2 ^ sq * word_of_nat nq)\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "also"], ["proof (state)\nthis:\n  2 ^ s1 * word_of_nat mq - 2 ^ s1 * 2 ^ sq * word_of_nat nq =\n  2 ^ s1 * (word_of_nat mq - 2 ^ sq * word_of_nat nq)\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "have \"\\<dots> = 2 ^ s1 * of_nat (mq - 2 ^ sq * nq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ s1 * (word_of_nat mq - 2 ^ sq * word_of_nat nq) =\n    2 ^ s1 * word_of_nat (mq - 2 ^ sq * nq)", "using s1wb s2wb us1 us2 nqmq"], ["proof (prove)\nusing this:\n  s1 < LENGTH('a)\n  s2 < LENGTH('a)\n  unat (2 ^ s1 * word_of_nat mq) = 2 ^ s1 * mq\n  unat (2 ^ s2 * word_of_nat nq) = 2 ^ s2 * nq\n  2 ^ sq * nq \\<le> mq\n\ngoal (1 subgoal):\n 1. 2 ^ s1 * (word_of_nat mq - 2 ^ sq * word_of_nat nq) =\n    2 ^ s1 * word_of_nat (mq - 2 ^ sq * nq)", "by (simp add: of_nat_diff)"], ["proof (state)\nthis:\n  2 ^ s1 * (word_of_nat mq - 2 ^ sq * word_of_nat nq) =\n  2 ^ s1 * word_of_nat (mq - 2 ^ sq * nq)\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "finally"], ["proof (chain)\npicking this:\n  m - n = 2 ^ s1 * word_of_nat (mq - 2 ^ sq * nq)", "have mn: \"m - n = of_nat (mq - 2 ^ sq * nq) * 2 ^ s1\""], ["proof (prove)\nusing this:\n  m - n = 2 ^ s1 * word_of_nat (mq - 2 ^ sq * nq)\n\ngoal (1 subgoal):\n 1. m - n = word_of_nat (mq - 2 ^ sq * nq) * 2 ^ s1", "by simp"], ["proof (state)\nthis:\n  m - n = word_of_nat (mq - 2 ^ sq * nq) * 2 ^ s1\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "moreover"], ["proof (state)\nthis:\n  m - n = word_of_nat (mq - 2 ^ sq * nq) * 2 ^ s1\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "from nm"], ["proof (chain)\npicking this:\n  m \\<in> {n..n + (2 ^ s2 - 1)}", "have \"m - n \\<le> 2 ^ s2 - 1\""], ["proof (prove)\nusing this:\n  m \\<in> {n..n + (2 ^ s2 - 1)}\n\ngoal (1 subgoal):\n 1. m - n \\<le> 2 ^ s2 - 1", "by - (rule word_diff_ls', (simp add: field_simps)+)"], ["proof (state)\nthis:\n  m - n \\<le> 2 ^ s2 - 1\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "then"], ["proof (chain)\npicking this:\n  m - n \\<le> 2 ^ s2 - 1", "have \"(2::'a word) ^ s1 * of_nat (mq - 2 ^ sq * nq) < 2 ^ s2\""], ["proof (prove)\nusing this:\n  m - n \\<le> 2 ^ s2 - 1\n\ngoal (1 subgoal):\n 1. 2 ^ s1 * word_of_nat (mq - 2 ^ sq * nq) < 2 ^ s2", "using mn s2wb"], ["proof (prove)\nusing this:\n  m - n \\<le> 2 ^ s2 - 1\n  m - n = word_of_nat (mq - 2 ^ sq * nq) * 2 ^ s1\n  s2 < LENGTH('a)\n\ngoal (1 subgoal):\n 1. 2 ^ s1 * word_of_nat (mq - 2 ^ sq * nq) < 2 ^ s2", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  2 ^ s1 * word_of_nat (mq - 2 ^ sq * nq) < 2 ^ s2\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "then"], ["proof (chain)\npicking this:\n  2 ^ s1 * word_of_nat (mq - 2 ^ sq * nq) < 2 ^ s2", "have \"of_nat (mq - 2 ^ sq * nq) < (2::'a word) ^ (s2 - s1)\""], ["proof (prove)\nusing this:\n  2 ^ s1 * word_of_nat (mq - 2 ^ sq * nq) < 2 ^ s2\n\ngoal (1 subgoal):\n 1. word_of_nat (mq - 2 ^ sq * nq) < 2 ^ (s2 - s1)", "proof (rule word_power_less_diff)"], ["proof (state)\ngoal (1 subgoal):\n 1. word_of_nat (mq - 2 ^ sq * nq) < 2 ^ (LENGTH('a) - s1)", "have mm: \"mq - 2 ^ sq * nq < 2 ^ (LENGTH('a) - s1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mq - 2 ^ sq * nq < 2 ^ (LENGTH('a) - s1)", "using mq"], ["proof (prove)\nusing this:\n  mq < 2 ^ (LENGTH('a) - s1)\n\ngoal (1 subgoal):\n 1. mq - 2 ^ sq * nq < 2 ^ (LENGTH('a) - s1)", "by simp"], ["proof (state)\nthis:\n  mq - 2 ^ sq * nq < 2 ^ (LENGTH('a) - s1)\n\ngoal (1 subgoal):\n 1. word_of_nat (mq - 2 ^ sq * nq) < 2 ^ (LENGTH('a) - s1)", "moreover"], ["proof (state)\nthis:\n  mq - 2 ^ sq * nq < 2 ^ (LENGTH('a) - s1)\n\ngoal (1 subgoal):\n 1. word_of_nat (mq - 2 ^ sq * nq) < 2 ^ (LENGTH('a) - s1)", "from s10"], ["proof (chain)\npicking this:\n  0 < s1", "have \"LENGTH('a) - s1 < LENGTH('a)\""], ["proof (prove)\nusing this:\n  0 < s1\n\ngoal (1 subgoal):\n 1. LENGTH('a) - s1 < LENGTH('a)", "by (rule diff_less, simp)"], ["proof (state)\nthis:\n  LENGTH('a) - s1 < LENGTH('a)\n\ngoal (1 subgoal):\n 1. word_of_nat (mq - 2 ^ sq * nq) < 2 ^ (LENGTH('a) - s1)", "ultimately"], ["proof (chain)\npicking this:\n  mq - 2 ^ sq * nq < 2 ^ (LENGTH('a) - s1)\n  LENGTH('a) - s1 < LENGTH('a)", "show \"of_nat (mq - 2 ^ sq * nq) < (2::'a word) ^ (LENGTH('a) - s1)\""], ["proof (prove)\nusing this:\n  mq - 2 ^ sq * nq < 2 ^ (LENGTH('a) - s1)\n  LENGTH('a) - s1 < LENGTH('a)\n\ngoal (1 subgoal):\n 1. word_of_nat (mq - 2 ^ sq * nq) < 2 ^ (LENGTH('a) - s1)", "using take_bit_nat_less_self_iff [of \\<open>LENGTH('a)\\<close> \\<open>mq - 2 ^ sq * nq\\<close>]"], ["proof (prove)\nusing this:\n  mq - 2 ^ sq * nq < 2 ^ (LENGTH('a) - s1)\n  LENGTH('a) - s1 < LENGTH('a)\n  (take_bit LENGTH('a) (mq - 2 ^ sq * nq) < mq - 2 ^ sq * nq) =\n  (2 ^ LENGTH('a) \\<le> mq - 2 ^ sq * nq)\n\ngoal (1 subgoal):\n 1. word_of_nat (mq - 2 ^ sq * nq) < 2 ^ (LENGTH('a) - s1)", "apply (auto simp add: word_less_nat_alt not_le not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mq - 2 ^ sq * nq < 2 ^ (LENGTH('a) - s1);\n     LENGTH('a) - s1 < LENGTH('a);\n     mq - 2 ^ sq * nq \\<le> take_bit LENGTH('a) (mq - 2 ^ sq * nq);\n     mq - 2 ^ sq * nq < 2 ^ LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> take_bit LENGTH('a) (mq - 2 ^ sq * nq)\n                      < 2 ^ (LENGTH('a) - s1)", "apply (metis take_bit_nat_eq_self_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  word_of_nat (mq - 2 ^ sq * nq) < 2 ^ (LENGTH('a) - s1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  word_of_nat (mq - 2 ^ sq * nq) < 2 ^ (s2 - s1)\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "then"], ["proof (chain)\npicking this:\n  word_of_nat (mq - 2 ^ sq * nq) < 2 ^ (s2 - s1)", "have \"mq - 2 ^ sq * nq < 2 ^ (s2 - s1)\""], ["proof (prove)\nusing this:\n  word_of_nat (mq - 2 ^ sq * nq) < 2 ^ (s2 - s1)\n\ngoal (1 subgoal):\n 1. mq - 2 ^ sq * nq < 2 ^ (s2 - s1)", "using mq s2wb"], ["proof (prove)\nusing this:\n  word_of_nat (mq - 2 ^ sq * nq) < 2 ^ (s2 - s1)\n  mq < 2 ^ (LENGTH('a) - s1)\n  s2 < LENGTH('a)\n\ngoal (1 subgoal):\n 1. mq - 2 ^ sq * nq < 2 ^ (s2 - s1)", "apply (simp add: word_less_nat_alt take_bit_eq_mod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(mq - 2 ^ sq * nq) mod 2 ^ LENGTH('a) < 2 ^ (s2 - s1);\n     mq < 2 ^ (LENGTH('a) - s1); s2 < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mq - 2 ^ sq * nq < 2 ^ (s2 - s1)", "apply (subst (asm) mod_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mq < 2 ^ (LENGTH('a) - s1); s2 < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mq - 2 ^ sq * nq < 2 ^ LENGTH('a)\n 2. \\<lbrakk>mq - 2 ^ sq * nq < 2 ^ (s2 - s1); mq < 2 ^ (LENGTH('a) - s1);\n     s2 < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mq - 2 ^ sq * nq < 2 ^ (s2 - s1)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mq < 2 ^ (LENGTH('a) - s1); s2 < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mq - 2 ^ sq * nq < 2 ^ LENGTH('a)", "apply (rule order_le_less_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mq < 2 ^ (LENGTH('a) - s1); s2 < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mq - 2 ^ sq * nq \\<le> ?y71\n 2. \\<lbrakk>mq < 2 ^ (LENGTH('a) - s1); s2 < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> ?y71 < 2 ^ LENGTH('a)", "apply (rule diff_le_self)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mq < 2 ^ (LENGTH('a) - s1); s2 < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> mq < 2 ^ LENGTH('a)", "apply (erule order_less_le_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s2 < LENGTH('a) \\<Longrightarrow>\n    2 ^ (LENGTH('a) - s1) \\<le> 2 ^ LENGTH('a)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mq - 2 ^ sq * nq < 2 ^ (s2 - s1)\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "ultimately"], ["proof (chain)\npicking this:\n  m - n = word_of_nat (mq - 2 ^ sq * nq) * 2 ^ s1\n  mq - 2 ^ sq * nq < 2 ^ (s2 - s1)", "show ?thesis"], ["proof (prove)\nusing this:\n  m - n = word_of_nat (mq - 2 ^ sq * nq) * 2 ^ s1\n  mq - 2 ^ sq * nq < 2 ^ (s2 - s1)\n\ngoal (1 subgoal):\n 1. \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. m - n = word_of_nat q * 2 ^ s1 \\<and> q < 2 ^ (s2 - s1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_aligned_addD1:\n  assumes al1: \"is_aligned (x + y) n\"\n  and     al2: \"is_aligned (x::'a::len word) n\"\n  shows \"is_aligned y n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned y n", "using al2"], ["proof (prove)\nusing this:\n  is_aligned x n\n\ngoal (1 subgoal):\n 1. is_aligned y n", "proof (rule is_aligned_get_word_bits)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned y n\n 2. \\<lbrakk>x = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> is_aligned y n", "assume \"x = 0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned x n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned y n\n 2. \\<lbrakk>x = 0; LENGTH('a) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> is_aligned y n", "then"], ["proof (chain)\npicking this:\n  x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. is_aligned y n", "using al1"], ["proof (prove)\nusing this:\n  x = 0\n  is_aligned (x + y) n\n\ngoal (1 subgoal):\n 1. is_aligned y n", "by simp"], ["proof (state)\nthis:\n  is_aligned y n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned y n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned y n", "assume nv: \"n < LENGTH('a)\""], ["proof (state)\nthis:\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned y n", "from al1"], ["proof (chain)\npicking this:\n  is_aligned (x + y) n", "obtain q1\n    where xy: \"x + y = 2 ^ n * of_nat q1\" and \"q1 < 2 ^ (LENGTH('a) - n)\""], ["proof (prove)\nusing this:\n  is_aligned (x + y) n\n\ngoal (1 subgoal):\n 1. (\\<And>q1.\n        \\<lbrakk>x + y = 2 ^ n * word_of_nat q1;\n         q1 < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_alignedE)"], ["proof (state)\nthis:\n  x + y = 2 ^ n * word_of_nat q1\n  q1 < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned y n", "moreover"], ["proof (state)\nthis:\n  x + y = 2 ^ n * word_of_nat q1\n  q1 < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned y n", "from al2"], ["proof (chain)\npicking this:\n  is_aligned x n", "obtain q2\n    where x: \"x = 2 ^ n * of_nat q2\" and \"q2 < 2 ^ (LENGTH('a) - n)\""], ["proof (prove)\nusing this:\n  is_aligned x n\n\ngoal (1 subgoal):\n 1. (\\<And>q2.\n        \\<lbrakk>x = 2 ^ n * word_of_nat q2;\n         q2 < 2 ^ (LENGTH('a) - n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_alignedE)"], ["proof (state)\nthis:\n  x = 2 ^ n * word_of_nat q2\n  q2 < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned y n", "ultimately"], ["proof (chain)\npicking this:\n  x + y = 2 ^ n * word_of_nat q1\n  q1 < 2 ^ (LENGTH('a) - n)\n  x = 2 ^ n * word_of_nat q2\n  q2 < 2 ^ (LENGTH('a) - n)", "have \"y = 2 ^ n * (of_nat q1 - of_nat q2)\""], ["proof (prove)\nusing this:\n  x + y = 2 ^ n * word_of_nat q1\n  q1 < 2 ^ (LENGTH('a) - n)\n  x = 2 ^ n * word_of_nat q2\n  q2 < 2 ^ (LENGTH('a) - n)\n\ngoal (1 subgoal):\n 1. y = 2 ^ n * (word_of_nat q1 - word_of_nat q2)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  y = 2 ^ n * (word_of_nat q1 - word_of_nat q2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned x n; n < LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> is_aligned y n", "then"], ["proof (chain)\npicking this:\n  y = 2 ^ n * (word_of_nat q1 - word_of_nat q2)", "show ?thesis"], ["proof (prove)\nusing this:\n  y = 2 ^ n * (word_of_nat q1 - word_of_nat q2)\n\ngoal (1 subgoal):\n 1. is_aligned y n", "using nv"], ["proof (prove)\nusing this:\n  y = 2 ^ n * (word_of_nat q1 - word_of_nat q2)\n  n < LENGTH('a)\n\ngoal (1 subgoal):\n 1. is_aligned y n", "by (simp add: is_aligned_mult_triv1)"], ["proof (state)\nthis:\n  is_aligned y n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas is_aligned_addD2 =\n       is_aligned_addD1[OF subst[OF add.commute,\n                                 of \"%x. is_aligned x n\" for n]]"], ["", "lemma is_aligned_add:\n  \"\\<lbrakk>is_aligned p n; is_aligned q n\\<rbrakk> \\<Longrightarrow> is_aligned (p + q) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned p n; is_aligned q n\\<rbrakk>\n    \\<Longrightarrow> is_aligned (p + q) n", "by (simp add: is_aligned_mask mask_add_aligned)"], ["", "lemma aligned_shift:\n  \"\\<lbrakk>x < 2 ^ n; is_aligned (y :: 'a :: len word) n;n \\<le> LENGTH('a)\\<rbrakk>\n   \\<Longrightarrow> x + y >> n = y >> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ n; is_aligned y n; n \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> x + y >> n = y >> n", "apply (subst word_plus_and_or_coroll; rule bit_word_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>x < 2 ^ n; is_aligned y n; n \\<le> LENGTH('a);\n        na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit (x AND y) na = bit 0 na\n 2. \\<And>na.\n       \\<lbrakk>x < 2 ^ n; is_aligned y n; n \\<le> LENGTH('a);\n        na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit (x OR y >> n) na = bit (y >> n) na", "apply (auto simp add: bit_simps is_aligned_nth test_bit_eq_bit)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>x < 2 ^ n; \\<forall>na<n. \\<not> bit y na;\n        n \\<le> LENGTH('a); na < LENGTH('a); bit x na; bit y na\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>na.\n       \\<lbrakk>x < 2 ^ n; \\<forall>na<n. \\<not> bit y na;\n        n \\<le> LENGTH('a); na < LENGTH('a); bit x (n + na)\\<rbrakk>\n       \\<Longrightarrow> bit y (n + na)", "apply (metis less_2p_is_upper_bits_unset not_le test_bit_word_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>x < 2 ^ n; \\<forall>na<n. \\<not> bit y na;\n        n \\<le> LENGTH('a); na < LENGTH('a); bit x (n + na)\\<rbrakk>\n       \\<Longrightarrow> bit y (n + na)", "apply (metis le_add1 less_2p_is_upper_bits_unset test_bit_bin test_bit_word_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma aligned_shift':\n  \"\\<lbrakk>x < 2 ^ n; is_aligned (y :: 'a :: len word) n;n \\<le> LENGTH('a)\\<rbrakk>\n   \\<Longrightarrow> y + x >> n = y >> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 2 ^ n; is_aligned y n; n \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> y + x >> n = y >> n", "apply (subst word_plus_and_or_coroll; rule bit_word_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>x < 2 ^ n; is_aligned y n; n \\<le> LENGTH('a);\n        na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit (y AND x) na = bit 0 na\n 2. \\<And>na.\n       \\<lbrakk>x < 2 ^ n; is_aligned y n; n \\<le> LENGTH('a);\n        na < LENGTH('a)\\<rbrakk>\n       \\<Longrightarrow> bit (y OR x >> n) na = bit (y >> n) na", "apply (auto simp add: bit_simps is_aligned_nth test_bit_eq_bit)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>x < 2 ^ n; \\<forall>na<n. \\<not> bit y na;\n        n \\<le> LENGTH('a); na < LENGTH('a); bit y na; bit x na\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>na.\n       \\<lbrakk>x < 2 ^ n; \\<forall>na<n. \\<not> bit y na;\n        n \\<le> LENGTH('a); na < LENGTH('a); bit x (n + na)\\<rbrakk>\n       \\<Longrightarrow> bit y (n + na)", "apply (metis less_2p_is_upper_bits_unset not_le test_bit_eq_bit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>x < 2 ^ n; \\<forall>na<n. \\<not> bit y na;\n        n \\<le> LENGTH('a); na < LENGTH('a); bit x (n + na)\\<rbrakk>\n       \\<Longrightarrow> bit y (n + na)", "apply (metis bit_imp_le_length le_add1 less_2p_is_upper_bits_unset test_bit_eq_bit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma and_neg_mask_plus_mask_mono: \"(p AND NOT (mask n)) + mask n \\<ge> p\"\n  for p :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> (p AND NOT (mask n)) + mask n", "apply (rule word_le_minus_cancel[where x = \"p AND NOT (mask n)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. p - (p AND NOT (mask n))\n    \\<le> (p AND NOT (mask n)) + mask n - (p AND NOT (mask n))\n 2. p AND NOT (mask n) \\<le> (p AND NOT (mask n)) + mask n", "apply (clarsimp simp: subtract_mask)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p AND mask n \\<le> mask n\n 2. p AND NOT (mask n) \\<le> (p AND NOT (mask n)) + mask n", "using word_and_le1[where a = \"mask n\" and y = p]"], ["proof (prove)\nusing this:\n  p AND mask n \\<le> mask n\n\ngoal (2 subgoals):\n 1. p AND mask n \\<le> mask n\n 2. p AND NOT (mask n) \\<le> (p AND NOT (mask n)) + mask n", "apply (clarsimp simp: mask_eq_decr_exp word_le_less_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p AND NOT (mask n) \\<le> (p AND NOT (mask n)) + mask n", "apply (rule is_aligned_no_overflow'[folded mask_2pm1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_aligned (p AND NOT (mask n)) n", "apply (clarsimp simp: is_aligned_neg_mask)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma word_neg_and_le:\n  \"ptr \\<le> (ptr AND NOT (mask n)) + (2 ^ n - 1)\"\n  for ptr :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ptr \\<le> (ptr AND NOT (mask n)) + (2 ^ n - 1)", "by (simp add: and_neg_mask_plus_mask_mono mask_2pm1[symmetric])"], ["", "lemma is_aligned_sub_helper:\n  \"\\<lbrakk> is_aligned (p - d) n; d < 2 ^ n \\<rbrakk>\n     \\<Longrightarrow> (p AND mask n = d) \\<and> (p AND (NOT (mask n)) = p - d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned (p - d) n; d < 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> p AND mask n = d \\<and> p AND NOT (mask n) = p - d", "by (drule(1) is_aligned_add_helper, simp)"], ["", "lemma is_aligned_after_mask:\n  \"\\<lbrakk>is_aligned k m;m\\<le> n\\<rbrakk> \\<Longrightarrow> is_aligned (k AND mask n) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned k m; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> is_aligned (k AND mask n) m", "by (rule is_aligned_andI1)"], ["", "lemma and_mask_plus:\n  \"\\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n   \\<Longrightarrow> ptr + a AND mask n = (ptr AND mask n) + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> ptr + a AND mask n = (ptr AND mask n) + a", "apply (rule mask_eqI[where n = m])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND mask m =\n                      (ptr AND mask n) + a AND mask m\n 2. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr AND mask n) + a AND NOT (mask m)", "apply (simp add:mask_twice min_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> ptr + a AND mask m = (ptr AND mask n) + a AND mask m\n 2. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr AND mask n) + a AND NOT (mask m)", "apply (simp add:is_aligned_add_helper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> a = (ptr AND mask n) + a AND mask m\n 2. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr AND mask n) + a AND NOT (mask m)", "apply (subst is_aligned_add_helper[THEN conjunct1])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> is_aligned (ptr AND mask n) m\n 2. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> a < 2 ^ m\n 3. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> a = a\n 4. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr AND mask n) + a AND NOT (mask m)", "apply (erule is_aligned_after_mask)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>m \\<le> n; a < 2 ^ m\\<rbrakk> \\<Longrightarrow> m \\<le> n\n 2. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> a < 2 ^ m\n 3. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> a = a\n 4. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr AND mask n) + a AND NOT (mask m)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> a < 2 ^ m\n 2. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> a = a\n 3. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr AND mask n) + a AND NOT (mask m)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> a = a\n 2. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr AND mask n) + a AND NOT (mask m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr AND mask n) + a AND NOT (mask m)", "apply (subgoal_tac \"(ptr + a AND mask n) AND NOT (mask m)\n     = (ptr + a AND NOT (mask m) ) AND mask n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m;\n     (ptr + a AND mask n) AND NOT (mask m) =\n     (ptr + a AND NOT (mask m)) AND mask n\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr AND mask n) + a AND NOT (mask m)\n 2. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr + a AND NOT (mask m)) AND mask n", "apply (simp add:is_aligned_add_helper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m;\n     (ptr + a AND mask n) AND NOT (mask m) = ptr AND mask n\\<rbrakk>\n    \\<Longrightarrow> ptr AND mask n = (ptr AND mask n) + a AND NOT (mask m)\n 2. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr + a AND NOT (mask m)) AND mask n", "apply (subst is_aligned_add_helper[THEN conjunct2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m;\n     (ptr + a AND mask n) AND NOT (mask m) = ptr AND mask n\\<rbrakk>\n    \\<Longrightarrow> is_aligned (ptr AND mask n) m\n 2. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m;\n     (ptr + a AND mask n) AND NOT (mask m) = ptr AND mask n\\<rbrakk>\n    \\<Longrightarrow> a < 2 ^ m\n 3. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m;\n     (ptr + a AND mask n) AND NOT (mask m) = ptr AND mask n\\<rbrakk>\n    \\<Longrightarrow> ptr AND mask n = ptr AND mask n\n 4. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr + a AND NOT (mask m)) AND mask n", "apply (simp add:is_aligned_after_mask)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m;\n     (ptr + a AND mask n) AND NOT (mask m) = ptr AND mask n\\<rbrakk>\n    \\<Longrightarrow> a < 2 ^ m\n 2. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m;\n     (ptr + a AND mask n) AND NOT (mask m) = ptr AND mask n\\<rbrakk>\n    \\<Longrightarrow> ptr AND mask n = ptr AND mask n\n 3. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr + a AND NOT (mask m)) AND mask n", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m;\n     (ptr + a AND mask n) AND NOT (mask m) = ptr AND mask n\\<rbrakk>\n    \\<Longrightarrow> ptr AND mask n = ptr AND mask n\n 2. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr + a AND NOT (mask m)) AND mask n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_aligned ptr m; m \\<le> n; a < 2 ^ m\\<rbrakk>\n    \\<Longrightarrow> (ptr + a AND mask n) AND NOT (mask m) =\n                      (ptr + a AND NOT (mask m)) AND mask n", "apply (simp add:word_bw_comms word_bw_lcs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}