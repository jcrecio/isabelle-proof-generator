{"file_name": "/home/qj213/afp-2021-10-22/thys/Poincare_Disc/Poincare_Lines.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Poincare_Disc", "problem_names": ["lemma is_poincare_line_mk_circline:\n  assumes \"(A, B, C, D) \\<in> hermitean_nonzero\"\n  shows \"is_poincare_line (mk_circline A B C D) \\<longleftrightarrow> (cmod B)\\<^sup>2 > (cmod A)\\<^sup>2 \\<and> A = D\"", "lemma is_poincare_line_iff:\n  shows \"is_poincare_line H \\<longleftrightarrow> circline_type H = -1 \\<and> perpendicular H unit_circle\"", "lemma is_poincare_line_x_axis [simp]:\n  shows \"is_poincare_line x_axis\"", "lemma not_is_poincare_line_unit_circle [simp]:\n  shows \"\\<not> is_poincare_line unit_circle\"", "lemma is_poincare_line_inverse_point:\n  assumes \"is_poincare_line H\" \"u \\<in> circline_set H\"\n  shows \"inversion u \\<in> circline_set H\"", "lemma circline_inversion_poincare_line:\n  assumes \"is_poincare_line H\"\n  shows \"circline_inversion H = H\"", "lemma is_poincare_line_trough_zero_trough_infty [simp]:\n  assumes \"is_poincare_line l\" and \"0\\<^sub>h \\<in> circline_set l\"\n  shows \"\\<infinity>\\<^sub>h \\<in> circline_set l\"", "lemma is_poincare_line_trough_zero_is_line:\n  assumes \"is_poincare_line l\" and \"0\\<^sub>h \\<in> circline_set l\"\n  shows \"is_line l\"", "lemma is_poincare_line_not_trough_zero_not_trough_infty [simp]:\n  assumes \"is_poincare_line l\"\n  assumes \"0\\<^sub>h \\<notin> circline_set l\"\n  shows \"\\<infinity>\\<^sub>h \\<notin> circline_set l\"", "lemma is_poincare_line_not_trough_zero_is_circle:\n  assumes \"is_poincare_line l\" \"0\\<^sub>h \\<notin> circline_set l\"\n  shows \"is_circle l\"", "lemma ex_is_poincare_line_points':\n  assumes i12: \"i1 \\<in> circline_set H \\<inter> unit_circle_set\"\n               \"i2 \\<in> circline_set H \\<inter> unit_circle_set\"\n               \"i1 \\<noteq> i2\"\n  assumes a: \"a \\<in> circline_set H\" \"a \\<notin> unit_circle_set\"\n  shows \"\\<exists> b. b \\<noteq> i1 \\<and> b \\<noteq> i2 \\<and> b \\<noteq> a \\<and> b \\<noteq> inversion a \\<and> b \\<in> circline_set H\"", "lemma ex_is_poincare_line_points:\n  assumes \"is_poincare_line H\"\n  shows \"\\<exists> u v. u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<and> u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H\"", "lemma unique_is_poincare_line:\n  assumes in_disc: \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\"\n  assumes pl: \"is_poincare_line l1\" \"is_poincare_line l2\"\n  assumes on_l: \"{u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\"\n  shows \"l1 = l2\"", "lemma unique_is_poincare_line_general:\n  assumes different: \"u \\<noteq> v\" \"u \\<noteq> inversion v\"\n  assumes pl: \"is_poincare_line l1\" \"is_poincare_line l2\"\n  assumes on_l: \"{u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\"\n  shows  \"l1 = l2\"", "lemma is_poincare_line_0_real_is_x_axis:\n  assumes \"is_poincare_line l\" \"0\\<^sub>h \\<in> circline_set l\"\n    \"x \\<in> circline_set l \\<inter> circline_set x_axis\" \"x \\<noteq> 0\\<^sub>h\" \"x \\<noteq> \\<infinity>\\<^sub>h\"\n  shows \"l = x_axis\"", "lemma is_poincare_line_0_imag_is_y_axis:\n  assumes \"is_poincare_line l\" \"0\\<^sub>h \\<in> circline_set l\"\n    \"y \\<in> circline_set l \\<inter> circline_set y_axis\" \"y \\<noteq> 0\\<^sub>h\" \"y \\<noteq> \\<infinity>\\<^sub>h\"\n  shows \"l = y_axis\"", "lemma unit_circle_fix_preserve_is_poincare_line [simp]:\n  assumes \"unit_circle_fix M\" \"is_poincare_line H\"\n  shows \"is_poincare_line (moebius_circline M H)\"", "lemma unit_circle_fix_preserve_is_poincare_line_iff [simp]:\n  assumes \"unit_circle_fix M\"\n  shows \"is_poincare_line (moebius_circline M H) \\<longleftrightarrow> is_poincare_line H\"", "lemma unit_disc_fix_preserve_poincare_collinear [simp]:\n  assumes \"unit_circle_fix M\" \"poincare_collinear A\"\n  shows \"poincare_collinear (moebius_pt M ` A)\"", "lemma unit_disc_fix_preserve_poincare_collinear_iff [simp]:\n  assumes \"unit_circle_fix M\"\n  shows \"poincare_collinear (moebius_pt M ` A) \\<longleftrightarrow> poincare_collinear A\"", "lemma unit_disc_fix_preserve_poincare_collinear3 [simp]:\n  assumes \"unit_disc_fix M\"\n  shows \"poincare_collinear {moebius_pt M u, moebius_pt M v, moebius_pt M w} \\<longleftrightarrow>\n         poincare_collinear {u, v, w}\"", "lemma is_poincare_line_conjugate_circline [simp]:\n  assumes \"is_poincare_line H\"\n  shows \"is_poincare_line (conjugate_circline H)\"", "lemma is_poincare_line_conjugate_circline_iff [simp]:\n  shows \"is_poincare_line (conjugate_circline H) \\<longleftrightarrow> is_poincare_line H\"", "lemma conjugate_preserve_poincare_collinear [simp]:\n  assumes \"poincare_collinear A\"\n  shows \"poincare_collinear (conjugate ` A)\"", "lemma conjugate_conjugate [simp]: \"conjugate ` conjugate ` A = A\"", "lemma conjugate_preserve_poincare_collinear_iff [simp]:\n  shows \"poincare_collinear (conjugate ` A) \\<longleftrightarrow> poincare_collinear A\"", "lemma ex_unit_disc_fix_is_poincare_line_to_x_axis:\n  assumes \"is_poincare_line l\"\n  shows  \"\\<exists> M. unit_disc_fix M \\<and> moebius_circline M l = x_axis\"", "lemma wlog_line_x_axis:\n  assumes is_line: \"is_poincare_line H\"\n  assumes x_axis: \"P x_axis\"\n  assumes preserves: \"\\<And> M. \\<lbrakk>unit_disc_fix M; P (moebius_circline M H)\\<rbrakk> \\<Longrightarrow> P H\"\n  shows \"P H\"", "lemma mk_poincare_line_cmat_zero_iff:\n  \"mk_poincare_line_cmat A B = mat_zero \\<longleftrightarrow> A = 0 \\<and> B = 0\"", "lemma mk_poincare_line_cmat_hermitean\n  [simp]:  \"hermitean (mk_poincare_line_cmat A B)\"", "lemma mk_poincare_line_cmat_scale:\n  \"cor k *\\<^sub>s\\<^sub>m mk_poincare_line_cmat A B = mk_poincare_line_cmat (k * A) (k * B)\"", "lemma poincare_line_cvec_cmat_AeqD:\n  assumes \"poincare_line_cvec_cmat z w = (A, B, C, D)\"\n  shows \"A = D\"", "lemma poincare_line_cvec_cmat_hermitean [simp]: \n  shows \"hermitean (poincare_line_cvec_cmat z w)\"", "lemma poincare_line_cvec_cmat_nonzero [simp]:\n  assumes \"z \\<noteq> vec_zero\" \"w \\<noteq> vec_zero\"\n  shows  \"poincare_line_cvec_cmat z w \\<noteq> mat_zero\"", "lemma poincare_line_non_homogenous:\n  assumes \"u \\<noteq> \\<infinity>\\<^sub>h\" \"v \\<noteq> \\<infinity>\\<^sub>h\" \"u \\<noteq> v\" \"u \\<noteq> inversion v\"\n  shows \"let u' = to_complex u;  v' = to_complex v;\n             A = \\<i> * (u' * cnj v' - v' * cnj u');\n             B = \\<i> * (v' * ((cmod u')\\<^sup>2 + 1) - u' * ((cmod v')\\<^sup>2 + 1))\n          in poincare_line u v = mk_circline A B (cnj B) A\"", "lemma poincare_line [simp]:\n  assumes \"z \\<noteq> w\"\n  shows \"on_circline (poincare_line z w) z\"\n        \"on_circline (poincare_line z w) w\"", "lemma poincare_line_circline_set [simp]:\n  assumes \"z \\<noteq> w\"\n  shows \"z \\<in> circline_set (poincare_line z w)\"\n        \"w \\<in> circline_set (poincare_line z w)\"", "lemma poincare_line_type:\n  assumes \"z \\<noteq> w\"\n  shows \"circline_type (poincare_line z w) = -1\"", "lemma is_poincare_line_poincare_line [simp]:\n  assumes \"z \\<noteq> w\"\n  shows \"is_poincare_line (poincare_line z w)\"", "lemma poincare_line_inversion:\n  assumes \"z \\<noteq> w\"\n  shows \"on_circline (poincare_line z w) (inversion z)\"\n        \"on_circline (poincare_line z w) (inversion w)\"", "lemma poincare_line_inversion_full:\n  assumes \"u \\<noteq> v\"\n  assumes \"on_circline (poincare_line u v) x\"\n  shows \"on_circline (poincare_line u v) (inversion x)\"", "lemma ex_poincare_line_one_point:\n  shows \"\\<exists> l. is_poincare_line l \\<and> z \\<in> circline_set l\"", "lemma poincare_collinear_singleton [simp]:\n  assumes \"u \\<in> unit_disc\"\n  shows \"poincare_collinear {u}\"", "lemma ex_poincare_line_two_points:\n  assumes \"z \\<noteq> w\"\n  shows \"\\<exists> l. is_poincare_line l \\<and> z \\<in> circline_set l \\<and> w \\<in> circline_set l\"", "lemma poincare_collinear_doubleton [simp]:\n  assumes \"u \\<in> unit_disc\" \"v \\<in> unit_disc\"\n  shows \"poincare_collinear {u, v}\"", "lemma unique_poincare_line:\n  assumes in_disc: \"u \\<noteq> v\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\"\n  assumes on_l: \"u \\<in> circline_set l\" \"v \\<in> circline_set l\" \"is_poincare_line l\"\n  shows \"l = poincare_line u v\"", "lemma unique_poincare_line_general:\n  assumes in_disc: \"u \\<noteq> v\" \"u \\<noteq> inversion v\"\n  assumes on_l: \"u \\<in> circline_set l\" \"v \\<in> circline_set l\" \"is_poincare_line l\"\n  shows \"l = poincare_line u v\"", "lemma ex1_poincare_line:\n  assumes \"u \\<noteq> v\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\"\n  shows \"\\<exists>! l. is_poincare_line l \\<and> u \\<in> circline_set l \\<and> v \\<in> circline_set l\"", "lemma ex1_poincare_line_general:\n  assumes \"u \\<noteq> v\" \"u \\<noteq> inversion v\"\n  shows \"\\<exists>! l. is_poincare_line l \\<and> u \\<in> circline_set l \\<and> v \\<in> circline_set l\"", "lemma poincare_line_sym:\n  assumes \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\"\n  shows \"poincare_line u v = poincare_line v u\"", "lemma poincare_line_sym_general:\n  assumes \"u \\<noteq> v\" \"u \\<noteq> inversion v\"\n  shows \"poincare_line u v = poincare_line v u\"", "lemma ex_poincare_line_points:\n  assumes \"is_poincare_line H\"\n  shows \"\\<exists> u v. u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<and> u \\<noteq> v \\<and> H = poincare_line u v\"", "lemma poincare_line_0_real_is_x_axis:\n  assumes \"x \\<in> circline_set x_axis\" \"x \\<noteq> 0\\<^sub>h\" \"x \\<noteq> \\<infinity>\\<^sub>h\"\n  shows \"poincare_line 0\\<^sub>h x = x_axis\"", "lemma poincare_line_0_imag_is_y_axis:\n  assumes \"y \\<in> circline_set y_axis\" \"y \\<noteq> 0\\<^sub>h\" \"y \\<noteq> \\<infinity>\\<^sub>h\"\n  shows \"poincare_line 0\\<^sub>h y = y_axis\"", "lemma poincare_line_x_axis:\n  assumes \"x \\<in> unit_disc\" \"y \\<in> unit_disc\" \"x \\<in> circline_set x_axis\" \"y \\<in> circline_set x_axis\" \"x \\<noteq> y\"\n  shows \"poincare_line x y = x_axis\"", "lemma poincare_line_minus_one_one [simp]: \n  shows \"poincare_line (of_complex (-1)) (of_complex 1) = x_axis\"", "lemma unit_disc_fix_preserve_poincare_line [simp]:\n  assumes \"unit_disc_fix M\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\"\n  shows \"poincare_line (moebius_pt M u) (moebius_pt M v) = moebius_circline M (poincare_line u v)\"", "lemma conjugate_preserve_poincare_line [simp]:\n  assumes \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\"\n  shows \"poincare_line (conjugate u) (conjugate v) = conjugate_circline (poincare_line u v)\"", "lemma poincare_collinear3_poincare_line_general:\n  assumes \"poincare_collinear {a, a1, a2}\" \"a1 \\<noteq> a2\" \"a1 \\<noteq> inversion a2\"\n  shows \"a \\<in> circline_set (poincare_line a1 a2)\"", "lemma poincare_line_poincare_collinear3_general:\n  assumes \"a \\<in> circline_set (poincare_line a1 a2)\" \"a1 \\<noteq> a2\"\n  shows \"poincare_collinear {a, a1, a2}\"", "lemma poincare_collinear3_poincare_lines_equal_general:\n  assumes \"poincare_collinear {a, a1, a2}\" \"a \\<noteq> a1\" \"a \\<noteq> a2\" \"a \\<noteq> inversion a1\" \"a \\<noteq> inversion a2\"\n  shows \"poincare_line a a1 = poincare_line a a2\"", "lemma poincare_collinear_zero_iff:\n  assumes \"of_complex y' \\<in> unit_disc\" and \"of_complex z' \\<in> unit_disc\" and\n          \"y' \\<noteq> z'\" and \"y' \\<noteq> 0\" and \"z' \\<noteq> 0\"\n  shows \"poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'} \\<longleftrightarrow>\n         y'*cnj z' = cnj y'*z'\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma poincare_collinear_zero_polar_form:\n  assumes \"poincare_collinear {0\\<^sub>h, of_complex x, of_complex y}\" and\n          \"x \\<noteq> 0\" and \"y \\<noteq> 0\" and \"of_complex x \\<in> unit_disc\" and \"of_complex y \\<in> unit_disc\"\n  shows \"\\<exists> \\<phi> rx ry. x = cor rx * cis \\<phi> \\<and> y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0\""], "translations": [["", "lemma is_poincare_line_mk_circline:\n  assumes \"(A, B, C, D) \\<in> hermitean_nonzero\"\n  shows \"is_poincare_line (mk_circline A B C D) \\<longleftrightarrow> (cmod B)\\<^sup>2 > (cmod A)\\<^sup>2 \\<and> A = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line (mk_circline A B C D) =\n    ((cmod A)\\<^sup>2 < (cmod B)\\<^sup>2 \\<and> A = D)", "using assms"], ["proof (prove)\nusing this:\n  (A, B, C, D) \\<in> hermitean_nonzero\n\ngoal (1 subgoal):\n 1. is_poincare_line (mk_circline A B C D) =\n    ((cmod A)\\<^sup>2 < (cmod B)\\<^sup>2 \\<and> A = D)", "by (transfer, transfer, auto simp add: Let_def)"], ["", "text\\<open>Abstract characterisation of @{term is_poincare_line} predicate: H-lines in the Poincar\\'e\nmodel are real circlines (circlines with the negative determinant) perpendicular to the unit\ncircle.\\<close>"], ["", "lemma is_poincare_line_iff:\n  shows \"is_poincare_line H \\<longleftrightarrow> circline_type H = -1 \\<and> perpendicular H unit_circle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line H =\n    (circline_type H = - 1 \\<and> perpendicular H unit_circle)", "unfolding perpendicular_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line H =\n    (circline_type H = - 1 \\<and>\n     cos_angle (of_circline H) (of_circline unit_circle) = 0)", "proof (simp, transfer, transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>H.\n       hermitean H \\<and> H \\<noteq> mat_zero \\<Longrightarrow>\n       is_poincare_line_cmat H =\n       (circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0)", "fix H"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>H.\n       hermitean H \\<and> H \\<noteq> mat_zero \\<Longrightarrow>\n       is_poincare_line_cmat H =\n       (circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0)", "assume hh: \"hermitean H \\<and> H \\<noteq> mat_zero\""], ["proof (state)\nthis:\n  hermitean H \\<and> H \\<noteq> mat_zero\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       hermitean H \\<and> H \\<noteq> mat_zero \\<Longrightarrow>\n       is_poincare_line_cmat H =\n       (circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0)", "obtain A B C D where *: \"H = (A, B, C, D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A B C D.\n        H = (A, B, C, D) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases H, auto)"], ["proof (state)\nthis:\n  H = (A, B, C, D)\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       hermitean H \\<and> H \\<noteq> mat_zero \\<Longrightarrow>\n       is_poincare_line_cmat H =\n       (circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0)", "have **: \"is_real A\" \"is_real D\" \"C = cnj B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real A &&& is_real D &&& C = cnj B", "using hh * hermitean_elems"], ["proof (prove)\nusing this:\n  hermitean H \\<and> H \\<noteq> mat_zero\n  H = (A, B, C, D)\n  hermitean (?A, ?B, ?C, ?D) \\<Longrightarrow> is_real ?A\n  hermitean (?A, ?B, ?C, ?D) \\<Longrightarrow> is_real ?D\n  hermitean (?A, ?B, ?C, ?D) \\<Longrightarrow> ?B = cnj ?C\n  hermitean (?A, ?B, ?C, ?D) \\<Longrightarrow> cnj ?B = ?C\n\ngoal (1 subgoal):\n 1. is_real A &&& is_real D &&& C = cnj B", "by auto"], ["proof (state)\nthis:\n  is_real A\n  is_real D\n  C = cnj B\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       hermitean H \\<and> H \\<noteq> mat_zero \\<Longrightarrow>\n       is_poincare_line_cmat H =\n       (circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0)", "hence \"(Re A = Re D \\<and> cmod A * cmod A < cmod B * cmod B) =\n         (Re A * Re D < Re B * Re B + Im B * Im B \\<and> (Re D = Re A \\<or> Re A * Re D = Re B * Re B + Im B * Im B))\""], ["proof (prove)\nusing this:\n  is_real A\n  is_real D\n  C = cnj B\n\ngoal (1 subgoal):\n 1. (Re A = Re D \\<and> cmod A * cmod A < cmod B * cmod B) =\n    (Re A * Re D < Re B * Re B + Im B * Im B \\<and>\n     (Re D = Re A \\<or> Re A * Re D = Re B * Re B + Im B * Im B))", "using *"], ["proof (prove)\nusing this:\n  is_real A\n  is_real D\n  C = cnj B\n  H = (A, B, C, D)\n\ngoal (1 subgoal):\n 1. (Re A = Re D \\<and> cmod A * cmod A < cmod B * cmod B) =\n    (Re A * Re D < Re B * Re B + Im B * Im B \\<and>\n     (Re D = Re A \\<or> Re A * Re D = Re B * Re B + Im B * Im B))", "by (smt cmod_power2 power2_eq_square zero_power2)+"], ["proof (state)\nthis:\n  (Re A = Re D \\<and> cmod A * cmod A < cmod B * cmod B) =\n  (Re A * Re D < Re B * Re B + Im B * Im B \\<and>\n   (Re D = Re A \\<or> Re A * Re D = Re B * Re B + Im B * Im B))\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       hermitean H \\<and> H \\<noteq> mat_zero \\<Longrightarrow>\n       is_poincare_line_cmat H =\n       (circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0)", "thus \"is_poincare_line_cmat H \\<longleftrightarrow>\n         circline_type_cmat H = - 1 \\<and> cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0\""], ["proof (prove)\nusing this:\n  (Re A = Re D \\<and> cmod A * cmod A < cmod B * cmod B) =\n  (Re A * Re D < Re B * Re B + Im B * Im B \\<and>\n   (Re D = Re A \\<or> Re A * Re D = Re B * Re B + Im B * Im B))\n\ngoal (1 subgoal):\n 1. is_poincare_line_cmat H =\n    (circline_type_cmat H = - 1 \\<and>\n     cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0)", "using * **"], ["proof (prove)\nusing this:\n  (Re A = Re D \\<and> cmod A * cmod A < cmod B * cmod B) =\n  (Re A * Re D < Re B * Re B + Im B * Im B \\<and>\n   (Re D = Re A \\<or> Re A * Re D = Re B * Re B + Im B * Im B))\n  H = (A, B, C, D)\n  is_real A\n  is_real D\n  C = cnj B\n\ngoal (1 subgoal):\n 1. is_poincare_line_cmat H =\n    (circline_type_cmat H = - 1 \\<and>\n     cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0)", "by (auto simp add: sgn_1_neg complex_eq_if_Re_eq cmod_square power2_eq_square simp del: pos_oriented_cmat_def)"], ["proof (state)\nthis:\n  is_poincare_line_cmat H =\n  (circline_type_cmat H = - 1 \\<and>\n   cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The @{term x_axis} is an h-line.\\<close>"], ["", "lemma is_poincare_line_x_axis [simp]:\n  shows \"is_poincare_line x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line x_axis", "by (transfer, transfer) (auto simp add: hermitean_def mat_adj_def mat_cnj_def)"], ["", "text\\<open>The @{term unit_circle} is not an h-line.\\<close>"], ["", "lemma not_is_poincare_line_unit_circle [simp]:\n  shows \"\\<not> is_poincare_line unit_circle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_poincare_line unit_circle", "by (transfer, transfer, simp)"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsubsection \\<open>Collinear points\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "text\\<open>Points are collinear if they all belong to an h-line. \\<close>"], ["", "definition poincare_collinear :: \"complex_homo set \\<Rightarrow> bool\" where\n  \"poincare_collinear S \\<longleftrightarrow> (\\<exists> p. is_poincare_line p \\<and> S \\<subseteq> circline_set p)\""], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsubsection \\<open>H-lines and inversion\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "text\\<open>Every h-line in the Poincar\\'e model contains the inverse (wrt.~the unit circle) of each of its\npoints (note that at most one of them belongs to the unit disc).\\<close>"], ["", "lemma is_poincare_line_inverse_point:\n  assumes \"is_poincare_line H\" \"u \\<in> circline_set H\"\n  shows \"inversion u \\<in> circline_set H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion u \\<in> circline_set H", "using assms"], ["proof (prove)\nusing this:\n  is_poincare_line H\n  u \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. inversion u \\<in> circline_set H", "unfolding is_poincare_line_iff circline_set_def perpendicular_def inversion_def"], ["proof (prove)\nusing this:\n  circline_type H = - 1 \\<and>\n  cos_angle (of_circline H) (of_circline unit_circle) = 0\n  u \\<in> Collect (on_circline H)\n\ngoal (1 subgoal):\n 1. (conjugate \\<circ> reciprocal) u \\<in> Collect (on_circline H)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>circline_type H = - 1 \\<and>\n             cos_angle (of_circline H) ounit_circle = 0;\n     on_circline H u\\<rbrakk>\n    \\<Longrightarrow> on_circline H (conjugate (reciprocal u))", "proof (transfer, transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>H u.\n       \\<lbrakk>hermitean H \\<and> H \\<noteq> mat_zero; u \\<noteq> vec_zero;\n        circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0;\n        on_circline_cmat_cvec H u\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec H\n                          (conjugate_cvec (reciprocal_cvec u))", "fix u H"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>H u.\n       \\<lbrakk>hermitean H \\<and> H \\<noteq> mat_zero; u \\<noteq> vec_zero;\n        circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0;\n        on_circline_cmat_cvec H u\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec H\n                          (conjugate_cvec (reciprocal_cvec u))", "assume hh: \"hermitean H \\<and> H \\<noteq> mat_zero\" \"u \\<noteq> vec_zero\" and\n         aa: \"circline_type_cmat H = - 1 \\<and> cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0\" \"on_circline_cmat_cvec H u\""], ["proof (state)\nthis:\n  hermitean H \\<and> H \\<noteq> mat_zero\n  u \\<noteq> vec_zero\n  circline_type_cmat H = - 1 \\<and>\n  cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0\n  on_circline_cmat_cvec H u\n\ngoal (1 subgoal):\n 1. \\<And>H u.\n       \\<lbrakk>hermitean H \\<and> H \\<noteq> mat_zero; u \\<noteq> vec_zero;\n        circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0;\n        on_circline_cmat_cvec H u\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec H\n                          (conjugate_cvec (reciprocal_cvec u))", "obtain A B C D u1 u2 where *: \"H = (A, B, C, D)\" \"u = (u1, u2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A B C D u1 u2.\n        \\<lbrakk>H = (A, B, C, D); u = (u1, u2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases H, cases u, auto)"], ["proof (state)\nthis:\n  H = (A, B, C, D)\n  u = (u1, u2)\n\ngoal (1 subgoal):\n 1. \\<And>H u.\n       \\<lbrakk>hermitean H \\<and> H \\<noteq> mat_zero; u \\<noteq> vec_zero;\n        circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0;\n        on_circline_cmat_cvec H u\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec H\n                          (conjugate_cvec (reciprocal_cvec u))", "have \"is_real A\" \"is_real D\" \"C = cnj B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real A &&& is_real D &&& C = cnj B", "using * hh hermitean_elems"], ["proof (prove)\nusing this:\n  H = (A, B, C, D)\n  u = (u1, u2)\n  hermitean H \\<and> H \\<noteq> mat_zero\n  u \\<noteq> vec_zero\n  hermitean (?A, ?B, ?C, ?D) \\<Longrightarrow> is_real ?A\n  hermitean (?A, ?B, ?C, ?D) \\<Longrightarrow> is_real ?D\n  hermitean (?A, ?B, ?C, ?D) \\<Longrightarrow> ?B = cnj ?C\n  hermitean (?A, ?B, ?C, ?D) \\<Longrightarrow> cnj ?B = ?C\n\ngoal (1 subgoal):\n 1. is_real A &&& is_real D &&& C = cnj B", "by auto"], ["proof (state)\nthis:\n  is_real A\n  is_real D\n  C = cnj B\n\ngoal (1 subgoal):\n 1. \\<And>H u.\n       \\<lbrakk>hermitean H \\<and> H \\<noteq> mat_zero; u \\<noteq> vec_zero;\n        circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0;\n        on_circline_cmat_cvec H u\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec H\n                          (conjugate_cvec (reciprocal_cvec u))", "moreover"], ["proof (state)\nthis:\n  is_real A\n  is_real D\n  C = cnj B\n\ngoal (1 subgoal):\n 1. \\<And>H u.\n       \\<lbrakk>hermitean H \\<and> H \\<noteq> mat_zero; u \\<noteq> vec_zero;\n        circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0;\n        on_circline_cmat_cvec H u\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec H\n                          (conjugate_cvec (reciprocal_cvec u))", "have \"A = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = D", "using aa(1) * \\<open>is_real A\\<close> \\<open>is_real D\\<close>"], ["proof (prove)\nusing this:\n  circline_type_cmat H = - 1 \\<and>\n  cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0\n  H = (A, B, C, D)\n  u = (u1, u2)\n  is_real A\n  is_real D\n\ngoal (1 subgoal):\n 1. A = D", "by (auto simp del: pos_oriented_cmat_def simp add: complex.expand split: if_split_asm)"], ["proof (state)\nthis:\n  A = D\n\ngoal (1 subgoal):\n 1. \\<And>H u.\n       \\<lbrakk>hermitean H \\<and> H \\<noteq> mat_zero; u \\<noteq> vec_zero;\n        circline_type_cmat H = - 1 \\<and>\n        cos_angle_cmat (of_circline_cmat H) unit_circle_cmat = 0;\n        on_circline_cmat_cvec H u\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec H\n                          (conjugate_cvec (reciprocal_cvec u))", "thus \"on_circline_cmat_cvec H (conjugate_cvec (reciprocal_cvec u))\""], ["proof (prove)\nusing this:\n  A = D\n\ngoal (1 subgoal):\n 1. on_circline_cmat_cvec H (conjugate_cvec (reciprocal_cvec u))", "using aa(2) *"], ["proof (prove)\nusing this:\n  A = D\n  on_circline_cmat_cvec H u\n  H = (A, B, C, D)\n  u = (u1, u2)\n\ngoal (1 subgoal):\n 1. on_circline_cmat_cvec H (conjugate_cvec (reciprocal_cvec u))", "by (simp add: vec_cnj_def field_simps)"], ["proof (state)\nthis:\n  on_circline_cmat_cvec H (conjugate_cvec (reciprocal_cvec u))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Every h-line in the Poincar\\'e model and is invariant under unit circle inversion.\\<close>"], ["", "lemma circline_inversion_poincare_line:\n  assumes \"is_poincare_line H\"\n  shows \"circline_inversion H = H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circline_inversion H = H", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. circline_inversion H = H", "obtain u v w where *: \"u \\<noteq> v\" \"v \\<noteq> w\" \"u \\<noteq> w\" \"{u, v, w} \\<subseteq> circline_set H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v w.\n        \\<lbrakk>u \\<noteq> v; v \\<noteq> w; u \\<noteq> w;\n         {u, v, w} \\<subseteq> circline_set H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms is_poincare_line_iff[of H]"], ["proof (prove)\nusing this:\n  is_poincare_line H\n  is_poincare_line H =\n  (circline_type H = - 1 \\<and> perpendicular H unit_circle)\n\ngoal (1 subgoal):\n 1. (\\<And>u v w.\n        \\<lbrakk>u \\<noteq> v; v \\<noteq> w; u \\<noteq> w;\n         {u, v, w} \\<subseteq> circline_set H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using circline_type_neg_card_gt3[of H]"], ["proof (prove)\nusing this:\n  is_poincare_line H\n  is_poincare_line H =\n  (circline_type H = - 1 \\<and> perpendicular H unit_circle)\n  circline_type H < 0 \\<Longrightarrow>\n  \\<exists>A B C.\n     A \\<noteq> B \\<and>\n     A \\<noteq> C \\<and>\n     B \\<noteq> C \\<and> {A, B, C} \\<subseteq> circline_set H\n\ngoal (1 subgoal):\n 1. (\\<And>u v w.\n        \\<lbrakk>u \\<noteq> v; v \\<noteq> w; u \\<noteq> w;\n         {u, v, w} \\<subseteq> circline_set H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> v\n  v \\<noteq> w\n  u \\<noteq> w\n  {u, v, w} \\<subseteq> circline_set H\n\ngoal (1 subgoal):\n 1. circline_inversion H = H", "hence \"{inversion u, inversion v, inversion w} \\<subseteq> circline_set (circline_inversion H)\"\n        \"{inversion u, inversion v, inversion w} \\<subseteq> circline_set H\""], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  v \\<noteq> w\n  u \\<noteq> w\n  {u, v, w} \\<subseteq> circline_set H\n\ngoal (1 subgoal):\n 1. {inversion u, inversion v, inversion w}\n    \\<subseteq> circline_set (circline_inversion H) &&&\n    {inversion u, inversion v, inversion w} \\<subseteq> circline_set H", "using is_poincare_line_inverse_point[OF assms]"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  v \\<noteq> w\n  u \\<noteq> w\n  {u, v, w} \\<subseteq> circline_set H\n  ?u \\<in> circline_set H \\<Longrightarrow>\n  inversion ?u \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. {inversion u, inversion v, inversion w}\n    \\<subseteq> circline_set (circline_inversion H) &&&\n    {inversion u, inversion v, inversion w} \\<subseteq> circline_set H", "by auto"], ["proof (state)\nthis:\n  {inversion u, inversion v, inversion w}\n  \\<subseteq> circline_set (circline_inversion H)\n  {inversion u, inversion v, inversion w} \\<subseteq> circline_set H\n\ngoal (1 subgoal):\n 1. circline_inversion H = H", "thus ?thesis"], ["proof (prove)\nusing this:\n  {inversion u, inversion v, inversion w}\n  \\<subseteq> circline_set (circline_inversion H)\n  {inversion u, inversion v, inversion w} \\<subseteq> circline_set H\n\ngoal (1 subgoal):\n 1. circline_inversion H = H", "using * unique_circline_set[of \"inversion u\" \"inversion v\" \"inversion w\"]"], ["proof (prove)\nusing this:\n  {inversion u, inversion v, inversion w}\n  \\<subseteq> circline_set (circline_inversion H)\n  {inversion u, inversion v, inversion w} \\<subseteq> circline_set H\n  u \\<noteq> v\n  v \\<noteq> w\n  u \\<noteq> w\n  {u, v, w} \\<subseteq> circline_set H\n  \\<lbrakk>inversion u \\<noteq> inversion v;\n   inversion u \\<noteq> inversion w;\n   inversion v \\<noteq> inversion w\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       inversion u \\<in> circline_set H \\<and>\n                       inversion v \\<in> circline_set H \\<and>\n                       inversion w \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. circline_inversion H = H", "by (metis insert_subset inversion_involution)"], ["proof (state)\nthis:\n  circline_inversion H = H\n\ngoal:\nNo subgoals!", "qed"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsubsection \\<open>Classification of h-lines into Euclidean segments and circles\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "text\\<open>If an h-line contains zero, than it also contains infinity (the inverse point of zero) and is by\ndefinition an Euclidean line.\\<close>"], ["", "lemma is_poincare_line_trough_zero_trough_infty [simp]:\n  assumes \"is_poincare_line l\" and \"0\\<^sub>h \\<in> circline_set l\"\n  shows \"\\<infinity>\\<^sub>h \\<in> circline_set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity>\\<^sub>h \\<in> circline_set l", "using is_poincare_line_inverse_point[OF assms]"], ["proof (prove)\nusing this:\n  inversion 0\\<^sub>h \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. \\<infinity>\\<^sub>h \\<in> circline_set l", "by simp"], ["", "lemma is_poincare_line_trough_zero_is_line:\n  assumes \"is_poincare_line l\" and \"0\\<^sub>h \\<in> circline_set l\"\n  shows \"is_line l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_line l", "using assms"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  0\\<^sub>h \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. is_line l", "using inf_in_circline_set is_poincare_line_trough_zero_trough_infty"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  0\\<^sub>h \\<in> circline_set l\n  (\\<infinity>\\<^sub>h \\<in> circline_set ?H) = is_line ?H\n  \\<lbrakk>is_poincare_line ?l; 0\\<^sub>h \\<in> circline_set ?l\\<rbrakk>\n  \\<Longrightarrow> \\<infinity>\\<^sub>h \\<in> circline_set ?l\n\ngoal (1 subgoal):\n 1. is_line l", "by blast"], ["", "text\\<open>If an h-line does not contain zero, than it also does not contain infinity (the inverse point of\nzero) and is by definition an Euclidean circle.\\<close>"], ["", "lemma is_poincare_line_not_trough_zero_not_trough_infty [simp]:\n  assumes \"is_poincare_line l\"\n  assumes \"0\\<^sub>h \\<notin> circline_set l\"\n  shows \"\\<infinity>\\<^sub>h \\<notin> circline_set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity>\\<^sub>h \\<notin> circline_set l", "using assms"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  0\\<^sub>h \\<notin> circline_set l\n\ngoal (1 subgoal):\n 1. \\<infinity>\\<^sub>h \\<notin> circline_set l", "using is_poincare_line_inverse_point[OF assms(1), of \"\\<infinity>\\<^sub>h\"]"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  0\\<^sub>h \\<notin> circline_set l\n  \\<infinity>\\<^sub>h \\<in> circline_set l \\<Longrightarrow>\n  inversion \\<infinity>\\<^sub>h \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. \\<infinity>\\<^sub>h \\<notin> circline_set l", "by auto"], ["", "lemma is_poincare_line_not_trough_zero_is_circle:\n  assumes \"is_poincare_line l\" \"0\\<^sub>h \\<notin> circline_set l\"\n  shows \"is_circle l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_circle l", "using assms"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  0\\<^sub>h \\<notin> circline_set l\n\ngoal (1 subgoal):\n 1. is_circle l", "using inf_in_circline_set is_poincare_line_not_trough_zero_not_trough_infty"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  0\\<^sub>h \\<notin> circline_set l\n  (\\<infinity>\\<^sub>h \\<in> circline_set ?H) = is_line ?H\n  \\<lbrakk>is_poincare_line ?l; 0\\<^sub>h \\<notin> circline_set ?l\\<rbrakk>\n  \\<Longrightarrow> \\<infinity>\\<^sub>h \\<notin> circline_set ?l\n\ngoal (1 subgoal):\n 1. is_circle l", "by auto"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsubsection\\<open>Points on h-line\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "text\\<open>Each h-line in the Poincar\\'e model contains at least two different points within the unit\ndisc.\\<close>"], ["", "text\\<open>First we prove an auxiliary lemma.\\<close>"], ["", "lemma ex_is_poincare_line_points':\n  assumes i12: \"i1 \\<in> circline_set H \\<inter> unit_circle_set\"\n               \"i2 \\<in> circline_set H \\<inter> unit_circle_set\"\n               \"i1 \\<noteq> i2\"\n  assumes a: \"a \\<in> circline_set H\" \"a \\<notin> unit_circle_set\"\n  shows \"\\<exists> b. b \\<noteq> i1 \\<and> b \\<noteq> i2 \\<and> b \\<noteq> a \\<and> b \\<noteq> inversion a \\<and> b \\<in> circline_set H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<noteq> i1 \\<and>\n       b \\<noteq> i2 \\<and>\n       b \\<noteq> a \\<and>\n       b \\<noteq> inversion a \\<and> b \\<in> circline_set H", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<noteq> i1 \\<and>\n       b \\<noteq> i2 \\<and>\n       b \\<noteq> a \\<and>\n       b \\<noteq> inversion a \\<and> b \\<in> circline_set H", "have \"inversion a \\<notin> unit_circle_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion a \\<notin> unit_circle_set", "using \\<open>a \\<notin> unit_circle_set\\<close>"], ["proof (prove)\nusing this:\n  a \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. inversion a \\<notin> unit_circle_set", "unfolding unit_circle_set_def circline_set_def"], ["proof (prove)\nusing this:\n  a \\<notin> Collect (on_circline unit_circle)\n\ngoal (1 subgoal):\n 1. inversion a \\<notin> Collect (on_circline unit_circle)", "by (metis inversion_id_iff_on_unit_circle inversion_involution mem_Collect_eq)"], ["proof (state)\nthis:\n  inversion a \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<noteq> i1 \\<and>\n       b \\<noteq> i2 \\<and>\n       b \\<noteq> a \\<and>\n       b \\<noteq> inversion a \\<and> b \\<in> circline_set H", "have \"a \\<noteq> inversion a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> inversion a", "using \\<open>a \\<notin> unit_circle_set\\<close> inversion_id_iff_on_unit_circle[of a]"], ["proof (prove)\nusing this:\n  a \\<notin> unit_circle_set\n  (inversion a = a) = on_circline unit_circle a\n\ngoal (1 subgoal):\n 1. a \\<noteq> inversion a", "unfolding unit_circle_set_def circline_set_def"], ["proof (prove)\nusing this:\n  a \\<notin> Collect (on_circline unit_circle)\n  (inversion a = a) = on_circline unit_circle a\n\ngoal (1 subgoal):\n 1. a \\<noteq> inversion a", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> inversion a\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<noteq> i1 \\<and>\n       b \\<noteq> i2 \\<and>\n       b \\<noteq> a \\<and>\n       b \\<noteq> inversion a \\<and> b \\<in> circline_set H", "have \"a \\<noteq> i1\" \"a \\<noteq> i2\" \"inversion a \\<noteq> i1\" \"inversion a \\<noteq> i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<noteq> i1 &&& a \\<noteq> i2) &&&\n    inversion a \\<noteq> i1 &&& inversion a \\<noteq> i2", "using assms \\<open>inversion a \\<notin> unit_circle_set\\<close>"], ["proof (prove)\nusing this:\n  i1 \\<in> circline_set H \\<inter> unit_circle_set\n  i2 \\<in> circline_set H \\<inter> unit_circle_set\n  i1 \\<noteq> i2\n  a \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  inversion a \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. (a \\<noteq> i1 &&& a \\<noteq> i2) &&&\n    inversion a \\<noteq> i1 &&& inversion a \\<noteq> i2", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> i1\n  a \\<noteq> i2\n  inversion a \\<noteq> i1\n  inversion a \\<noteq> i2\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<noteq> i1 \\<and>\n       b \\<noteq> i2 \\<and>\n       b \\<noteq> a \\<and>\n       b \\<noteq> inversion a \\<and> b \\<in> circline_set H", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> i1\n  a \\<noteq> i2\n  inversion a \\<noteq> i1\n  inversion a \\<noteq> i2", "obtain b where cr2: \"cross_ratio b i1 a i2 = of_complex 2\""], ["proof (prove)\nusing this:\n  a \\<noteq> i1\n  a \\<noteq> i2\n  inversion a \\<noteq> i1\n  inversion a \\<noteq> i2\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        cross_ratio b i1 a i2 = of_complex 2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>i1 \\<noteq> i2\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> i1\n  a \\<noteq> i2\n  inversion a \\<noteq> i1\n  inversion a \\<noteq> i2\n  i1 \\<noteq> i2\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        cross_ratio b i1 a i2 = of_complex 2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_cross_ratio[of i1 a i2]"], ["proof (prove)\nusing this:\n  a \\<noteq> i1\n  a \\<noteq> i2\n  inversion a \\<noteq> i1\n  inversion a \\<noteq> i2\n  i1 \\<noteq> i2\n  \\<lbrakk>i1 \\<noteq> a; i1 \\<noteq> i2; a \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. cross_ratio z i1 a i2 = ?c\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        cross_ratio b i1 a i2 = of_complex 2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cross_ratio b i1 a i2 = of_complex 2\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<noteq> i1 \\<and>\n       b \\<noteq> i2 \\<and>\n       b \\<noteq> a \\<and>\n       b \\<noteq> inversion a \\<and> b \\<in> circline_set H", "have distinct_b: \"b \\<noteq> i1\" \"b \\<noteq> i2\" \"b \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> i1 &&& b \\<noteq> i2 &&& b \\<noteq> a", "using \\<open>i1 \\<noteq> i2\\<close> \\<open>a \\<noteq> i1\\<close> \\<open>a \\<noteq> i2\\<close>"], ["proof (prove)\nusing this:\n  i1 \\<noteq> i2\n  a \\<noteq> i1\n  a \\<noteq> i2\n\ngoal (1 subgoal):\n 1. b \\<noteq> i1 &&& b \\<noteq> i2 &&& b \\<noteq> a", "using ex1_cross_ratio[of i1 a i2]"], ["proof (prove)\nusing this:\n  i1 \\<noteq> i2\n  a \\<noteq> i1\n  a \\<noteq> i2\n  \\<lbrakk>i1 \\<noteq> a; i1 \\<noteq> i2; a \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!z. cross_ratio z i1 a i2 = ?c\n\ngoal (1 subgoal):\n 1. b \\<noteq> i1 &&& b \\<noteq> i2 &&& b \\<noteq> a", "using cross_ratio_0[of i1 a i2] cross_ratio_1[of i1 a i2] cross_ratio_inf[of i1 i2 a]"], ["proof (prove)\nusing this:\n  i1 \\<noteq> i2\n  a \\<noteq> i1\n  a \\<noteq> i2\n  \\<lbrakk>i1 \\<noteq> a; i1 \\<noteq> i2; a \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!z. cross_ratio z i1 a i2 = ?c\n  \\<lbrakk>i1 \\<noteq> a; i1 \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> cross_ratio i1 i1 a i2 = 0\\<^sub>h\n  \\<lbrakk>i1 \\<noteq> a; a \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> cross_ratio a i1 a i2 = 1\\<^sub>h\n  \\<lbrakk>i1 \\<noteq> i2; a \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> cross_ratio i2 i1 a i2 = \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. b \\<noteq> i1 &&& b \\<noteq> i2 &&& b \\<noteq> a", "using cr2"], ["proof (prove)\nusing this:\n  i1 \\<noteq> i2\n  a \\<noteq> i1\n  a \\<noteq> i2\n  \\<lbrakk>i1 \\<noteq> a; i1 \\<noteq> i2; a \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!z. cross_ratio z i1 a i2 = ?c\n  \\<lbrakk>i1 \\<noteq> a; i1 \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> cross_ratio i1 i1 a i2 = 0\\<^sub>h\n  \\<lbrakk>i1 \\<noteq> a; a \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> cross_ratio a i1 a i2 = 1\\<^sub>h\n  \\<lbrakk>i1 \\<noteq> i2; a \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> cross_ratio i2 i1 a i2 = \\<infinity>\\<^sub>h\n  cross_ratio b i1 a i2 = of_complex 2\n\ngoal (1 subgoal):\n 1. b \\<noteq> i1 &&& b \\<noteq> i2 &&& b \\<noteq> a", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> i1\n  b \\<noteq> i2\n  b \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<noteq> i1 \\<and>\n       b \\<noteq> i2 \\<and>\n       b \\<noteq> a \\<and>\n       b \\<noteq> inversion a \\<and> b \\<in> circline_set H", "hence \"b \\<in> circline_set H\""], ["proof (prove)\nusing this:\n  b \\<noteq> i1\n  b \\<noteq> i2\n  b \\<noteq> a\n\ngoal (1 subgoal):\n 1. b \\<in> circline_set H", "using assms four_points_on_circline_iff_cross_ratio_real[of b i1 a i2] cr2"], ["proof (prove)\nusing this:\n  b \\<noteq> i1\n  b \\<noteq> i2\n  b \\<noteq> a\n  i1 \\<in> circline_set H \\<inter> unit_circle_set\n  i2 \\<in> circline_set H \\<inter> unit_circle_set\n  i1 \\<noteq> i2\n  a \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  distinct [b, i1, a, i2] \\<Longrightarrow>\n  is_real (to_complex (cross_ratio b i1 a i2)) =\n  (\\<exists>H. {b, i1, a, i2} \\<subseteq> circline_set H)\n  cross_ratio b i1 a i2 = of_complex 2\n\ngoal (1 subgoal):\n 1. b \\<in> circline_set H", "using unique_circline_set[of i1 i2 a]"], ["proof (prove)\nusing this:\n  b \\<noteq> i1\n  b \\<noteq> i2\n  b \\<noteq> a\n  i1 \\<in> circline_set H \\<inter> unit_circle_set\n  i2 \\<in> circline_set H \\<inter> unit_circle_set\n  i1 \\<noteq> i2\n  a \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  distinct [b, i1, a, i2] \\<Longrightarrow>\n  is_real (to_complex (cross_ratio b i1 a i2)) =\n  (\\<exists>H. {b, i1, a, i2} \\<subseteq> circline_set H)\n  cross_ratio b i1 a i2 = of_complex 2\n  \\<lbrakk>i1 \\<noteq> i2; i1 \\<noteq> a; i2 \\<noteq> a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       i1 \\<in> circline_set H \\<and>\n                       i2 \\<in> circline_set H \\<and> a \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. b \\<in> circline_set H", "by auto"], ["proof (state)\nthis:\n  b \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<noteq> i1 \\<and>\n       b \\<noteq> i2 \\<and>\n       b \\<noteq> a \\<and>\n       b \\<noteq> inversion a \\<and> b \\<in> circline_set H", "moreover"], ["proof (state)\nthis:\n  b \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<noteq> i1 \\<and>\n       b \\<noteq> i2 \\<and>\n       b \\<noteq> a \\<and>\n       b \\<noteq> inversion a \\<and> b \\<in> circline_set H", "have \"b \\<noteq> inversion a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> inversion a", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b \\<noteq> inversion a \\<Longrightarrow> False", "assume *: \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> b \\<noteq> inversion a\n\ngoal (1 subgoal):\n 1. \\<not> b \\<noteq> inversion a \\<Longrightarrow> False", "have \"inversion i1 = i1\" \"inversion i2 = i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion i1 = i1 &&& inversion i2 = i2", "using i12"], ["proof (prove)\nusing this:\n  i1 \\<in> circline_set H \\<inter> unit_circle_set\n  i2 \\<in> circline_set H \\<inter> unit_circle_set\n  i1 \\<noteq> i2\n\ngoal (1 subgoal):\n 1. inversion i1 = i1 &&& inversion i2 = i2", "unfolding unit_circle_set_def"], ["proof (prove)\nusing this:\n  i1 \\<in> circline_set H \\<inter> circline_set unit_circle\n  i2 \\<in> circline_set H \\<inter> circline_set unit_circle\n  i1 \\<noteq> i2\n\ngoal (1 subgoal):\n 1. inversion i1 = i1 &&& inversion i2 = i2", "by auto"], ["proof (state)\nthis:\n  inversion i1 = i1\n  inversion i2 = i2\n\ngoal (1 subgoal):\n 1. \\<not> b \\<noteq> inversion a \\<Longrightarrow> False", "hence \"cross_ratio (inversion a) i1 a i2 = cross_ratio a i1 (inversion a) i2\""], ["proof (prove)\nusing this:\n  inversion i1 = i1\n  inversion i2 = i2\n\ngoal (1 subgoal):\n 1. cross_ratio (inversion a) i1 a i2 = cross_ratio a i1 (inversion a) i2", "using * cross_ratio_inversion[of i1 a i2 b] \\<open>a \\<noteq> i1\\<close> \\<open>a \\<noteq> i2\\<close> \\<open>i1 \\<noteq> i2\\<close> \\<open>b \\<noteq> i1\\<close>"], ["proof (prove)\nusing this:\n  inversion i1 = i1\n  inversion i2 = i2\n  \\<not> b \\<noteq> inversion a\n  \\<lbrakk>i1 \\<noteq> a; a \\<noteq> i2; i1 \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> cross_ratio (inversion b) (inversion i1) (inversion a)\n                     (inversion i2) =\n                    conjugate (cross_ratio b i1 a i2)\n  a \\<noteq> i1\n  a \\<noteq> i2\n  i1 \\<noteq> i2\n  b \\<noteq> i1\n\ngoal (1 subgoal):\n 1. cross_ratio (inversion a) i1 a i2 = cross_ratio a i1 (inversion a) i2", "using four_points_on_circline_iff_cross_ratio_real[of b i1 a i2]"], ["proof (prove)\nusing this:\n  inversion i1 = i1\n  inversion i2 = i2\n  \\<not> b \\<noteq> inversion a\n  \\<lbrakk>i1 \\<noteq> a; a \\<noteq> i2; i1 \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> cross_ratio (inversion b) (inversion i1) (inversion a)\n                     (inversion i2) =\n                    conjugate (cross_ratio b i1 a i2)\n  a \\<noteq> i1\n  a \\<noteq> i2\n  i1 \\<noteq> i2\n  b \\<noteq> i1\n  distinct [b, i1, a, i2] \\<Longrightarrow>\n  is_real (to_complex (cross_ratio b i1 a i2)) =\n  (\\<exists>H. {b, i1, a, i2} \\<subseteq> circline_set H)\n\ngoal (1 subgoal):\n 1. cross_ratio (inversion a) i1 a i2 = cross_ratio a i1 (inversion a) i2", "using i12 distinct_b conjugate_id_iff[of \"cross_ratio b i1 a i2\"]"], ["proof (prove)\nusing this:\n  inversion i1 = i1\n  inversion i2 = i2\n  \\<not> b \\<noteq> inversion a\n  \\<lbrakk>i1 \\<noteq> a; a \\<noteq> i2; i1 \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> cross_ratio (inversion b) (inversion i1) (inversion a)\n                     (inversion i2) =\n                    conjugate (cross_ratio b i1 a i2)\n  a \\<noteq> i1\n  a \\<noteq> i2\n  i1 \\<noteq> i2\n  b \\<noteq> i1\n  distinct [b, i1, a, i2] \\<Longrightarrow>\n  is_real (to_complex (cross_ratio b i1 a i2)) =\n  (\\<exists>H. {b, i1, a, i2} \\<subseteq> circline_set H)\n  i1 \\<in> circline_set H \\<inter> unit_circle_set\n  i2 \\<in> circline_set H \\<inter> unit_circle_set\n  i1 \\<noteq> i2\n  b \\<noteq> i1\n  b \\<noteq> i2\n  b \\<noteq> a\n  (conjugate (cross_ratio b i1 a i2) = cross_ratio b i1 a i2) =\n  (is_real (to_complex (cross_ratio b i1 a i2)) \\<or>\n   cross_ratio b i1 a i2 = \\<infinity>\\<^sub>h)\n\ngoal (1 subgoal):\n 1. cross_ratio (inversion a) i1 a i2 = cross_ratio a i1 (inversion a) i2", "using i12 a \\<open>b \\<in> circline_set H\\<close>"], ["proof (prove)\nusing this:\n  inversion i1 = i1\n  inversion i2 = i2\n  \\<not> b \\<noteq> inversion a\n  \\<lbrakk>i1 \\<noteq> a; a \\<noteq> i2; i1 \\<noteq> i2\\<rbrakk>\n  \\<Longrightarrow> cross_ratio (inversion b) (inversion i1) (inversion a)\n                     (inversion i2) =\n                    conjugate (cross_ratio b i1 a i2)\n  a \\<noteq> i1\n  a \\<noteq> i2\n  i1 \\<noteq> i2\n  b \\<noteq> i1\n  distinct [b, i1, a, i2] \\<Longrightarrow>\n  is_real (to_complex (cross_ratio b i1 a i2)) =\n  (\\<exists>H. {b, i1, a, i2} \\<subseteq> circline_set H)\n  i1 \\<in> circline_set H \\<inter> unit_circle_set\n  i2 \\<in> circline_set H \\<inter> unit_circle_set\n  i1 \\<noteq> i2\n  b \\<noteq> i1\n  b \\<noteq> i2\n  b \\<noteq> a\n  (conjugate (cross_ratio b i1 a i2) = cross_ratio b i1 a i2) =\n  (is_real (to_complex (cross_ratio b i1 a i2)) \\<or>\n   cross_ratio b i1 a i2 = \\<infinity>\\<^sub>h)\n  i1 \\<in> circline_set H \\<inter> unit_circle_set\n  i2 \\<in> circline_set H \\<inter> unit_circle_set\n  i1 \\<noteq> i2\n  a \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  b \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. cross_ratio (inversion a) i1 a i2 = cross_ratio a i1 (inversion a) i2", "by auto"], ["proof (state)\nthis:\n  cross_ratio (inversion a) i1 a i2 = cross_ratio a i1 (inversion a) i2\n\ngoal (1 subgoal):\n 1. \\<not> b \\<noteq> inversion a \\<Longrightarrow> False", "hence \"cross_ratio (inversion a) i1 a i2 \\<noteq> of_complex 2\""], ["proof (prove)\nusing this:\n  cross_ratio (inversion a) i1 a i2 = cross_ratio a i1 (inversion a) i2\n\ngoal (1 subgoal):\n 1. cross_ratio (inversion a) i1 a i2 \\<noteq> of_complex 2", "using cross_ratio_commute_13[of \"inversion a\" i1 a i2]"], ["proof (prove)\nusing this:\n  cross_ratio (inversion a) i1 a i2 = cross_ratio a i1 (inversion a) i2\n  cross_ratio (inversion a) i1 a i2 =\n  reciprocal (cross_ratio a i1 (inversion a) i2)\n\ngoal (1 subgoal):\n 1. cross_ratio (inversion a) i1 a i2 \\<noteq> of_complex 2", "using reciprocal_id_iff"], ["proof (prove)\nusing this:\n  cross_ratio (inversion a) i1 a i2 = cross_ratio a i1 (inversion a) i2\n  cross_ratio (inversion a) i1 a i2 =\n  reciprocal (cross_ratio a i1 (inversion a) i2)\n  (reciprocal ?z = ?z) = (?z = of_complex 1 \\<or> ?z = of_complex (- 1))\n\ngoal (1 subgoal):\n 1. cross_ratio (inversion a) i1 a i2 \\<noteq> of_complex 2", "using of_complex_inj"], ["proof (prove)\nusing this:\n  cross_ratio (inversion a) i1 a i2 = cross_ratio a i1 (inversion a) i2\n  cross_ratio (inversion a) i1 a i2 =\n  reciprocal (cross_ratio a i1 (inversion a) i2)\n  (reciprocal ?z = ?z) = (?z = of_complex 1 \\<or> ?z = of_complex (- 1))\n  of_complex ?x = of_complex ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. cross_ratio (inversion a) i1 a i2 \\<noteq> of_complex 2", "by force"], ["proof (state)\nthis:\n  cross_ratio (inversion a) i1 a i2 \\<noteq> of_complex 2\n\ngoal (1 subgoal):\n 1. \\<not> b \\<noteq> inversion a \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  cross_ratio (inversion a) i1 a i2 \\<noteq> of_complex 2\n\ngoal (1 subgoal):\n 1. False", "using * cr2"], ["proof (prove)\nusing this:\n  cross_ratio (inversion a) i1 a i2 \\<noteq> of_complex 2\n  \\<not> b \\<noteq> inversion a\n  cross_ratio b i1 a i2 = of_complex 2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<noteq> inversion a\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<noteq> i1 \\<and>\n       b \\<noteq> i2 \\<and>\n       b \\<noteq> a \\<and>\n       b \\<noteq> inversion a \\<and> b \\<in> circline_set H", "ultimately"], ["proof (chain)\npicking this:\n  b \\<in> circline_set H\n  b \\<noteq> inversion a", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> circline_set H\n  b \\<noteq> inversion a\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<noteq> i1 \\<and>\n       b \\<noteq> i2 \\<and>\n       b \\<noteq> a \\<and>\n       b \\<noteq> inversion a \\<and> b \\<in> circline_set H", "using assms \\<open>b \\<noteq> i1\\<close> \\<open>b \\<noteq> i2\\<close> \\<open>b \\<noteq> a\\<close>"], ["proof (prove)\nusing this:\n  b \\<in> circline_set H\n  b \\<noteq> inversion a\n  i1 \\<in> circline_set H \\<inter> unit_circle_set\n  i2 \\<in> circline_set H \\<inter> unit_circle_set\n  i1 \\<noteq> i2\n  a \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  b \\<noteq> i1\n  b \\<noteq> i2\n  b \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<noteq> i1 \\<and>\n       b \\<noteq> i2 \\<and>\n       b \\<noteq> a \\<and>\n       b \\<noteq> inversion a \\<and> b \\<in> circline_set H", "by auto"], ["proof (state)\nthis:\n  \\<exists>b.\n     b \\<noteq> i1 \\<and>\n     b \\<noteq> i2 \\<and>\n     b \\<noteq> a \\<and>\n     b \\<noteq> inversion a \\<and> b \\<in> circline_set H\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Now we can prove the statement.\\<close>"], ["", "lemma ex_is_poincare_line_points:\n  assumes \"is_poincare_line H\"\n  shows \"\\<exists> u v. u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<and> u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "obtain u v w where *: \"u \\<noteq> v\" \"v \\<noteq> w\" \"u \\<noteq> w\" \"{u, v, w} \\<subseteq> circline_set H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v w.\n        \\<lbrakk>u \\<noteq> v; v \\<noteq> w; u \\<noteq> w;\n         {u, v, w} \\<subseteq> circline_set H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms is_poincare_line_iff[of H]"], ["proof (prove)\nusing this:\n  is_poincare_line H\n  is_poincare_line H =\n  (circline_type H = - 1 \\<and> perpendicular H unit_circle)\n\ngoal (1 subgoal):\n 1. (\\<And>u v w.\n        \\<lbrakk>u \\<noteq> v; v \\<noteq> w; u \\<noteq> w;\n         {u, v, w} \\<subseteq> circline_set H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using circline_type_neg_card_gt3[of H]"], ["proof (prove)\nusing this:\n  is_poincare_line H\n  is_poincare_line H =\n  (circline_type H = - 1 \\<and> perpendicular H unit_circle)\n  circline_type H < 0 \\<Longrightarrow>\n  \\<exists>A B C.\n     A \\<noteq> B \\<and>\n     A \\<noteq> C \\<and>\n     B \\<noteq> C \\<and> {A, B, C} \\<subseteq> circline_set H\n\ngoal (1 subgoal):\n 1. (\\<And>u v w.\n        \\<lbrakk>u \\<noteq> v; v \\<noteq> w; u \\<noteq> w;\n         {u, v, w} \\<subseteq> circline_set H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> v\n  v \\<noteq> w\n  u \\<noteq> w\n  {u, v, w} \\<subseteq> circline_set H\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "have \"\\<not> {u, v, w} \\<subseteq> unit_circle_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> {u, v, w} \\<subseteq> unit_circle_set", "using unique_circline_set[of u v w] *"], ["proof (prove)\nusing this:\n  \\<lbrakk>u \\<noteq> v; u \\<noteq> w; v \\<noteq> w\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       u \\<in> circline_set H \\<and>\n                       v \\<in> circline_set H \\<and> w \\<in> circline_set H\n  u \\<noteq> v\n  v \\<noteq> w\n  u \\<noteq> w\n  {u, v, w} \\<subseteq> circline_set H\n\ngoal (1 subgoal):\n 1. \\<not> {u, v, w} \\<subseteq> unit_circle_set", "by (metis assms insert_subset not_is_poincare_line_unit_circle unit_circle_set_def)"], ["proof (state)\nthis:\n  \\<not> {u, v, w} \\<subseteq> unit_circle_set\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "hence \"H \\<noteq> unit_circle\""], ["proof (prove)\nusing this:\n  \\<not> {u, v, w} \\<subseteq> unit_circle_set\n\ngoal (1 subgoal):\n 1. H \\<noteq> unit_circle", "unfolding unit_circle_set_def"], ["proof (prove)\nusing this:\n  \\<not> {u, v, w} \\<subseteq> circline_set unit_circle\n\ngoal (1 subgoal):\n 1. H \\<noteq> unit_circle", "using *"], ["proof (prove)\nusing this:\n  \\<not> {u, v, w} \\<subseteq> circline_set unit_circle\n  u \\<noteq> v\n  v \\<noteq> w\n  u \\<noteq> w\n  {u, v, w} \\<subseteq> circline_set H\n\ngoal (1 subgoal):\n 1. H \\<noteq> unit_circle", "by auto"], ["proof (state)\nthis:\n  H \\<noteq> unit_circle\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "proof (cases \"(u \\<in> unit_disc \\<and> v \\<in> unit_disc) \\<or>\n                (u \\<in> unit_disc \\<and> w \\<in> unit_disc) \\<or>\n                (v \\<in> unit_disc \\<and> w \\<in> unit_disc)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n    u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n    v \\<in> unit_disc \\<and> w \\<in> unit_disc \\<Longrightarrow>\n    \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H\n 2. \\<not> (u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n            u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n            v \\<in> unit_disc \\<and> w \\<in> unit_disc) \\<Longrightarrow>\n    \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "case True"], ["proof (state)\nthis:\n  u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n  u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n  v \\<in> unit_disc \\<and> w \\<in> unit_disc\n\ngoal (2 subgoals):\n 1. u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n    u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n    v \\<in> unit_disc \\<and> w \\<in> unit_disc \\<Longrightarrow>\n    \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H\n 2. \\<not> (u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n            u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n            v \\<in> unit_disc \\<and> w \\<in> unit_disc) \\<Longrightarrow>\n    \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "thus ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n  u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n  v \\<in> unit_disc \\<and> w \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "using *"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n  u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n  v \\<in> unit_disc \\<and> w \\<in> unit_disc\n  u \\<noteq> v\n  v \\<noteq> w\n  u \\<noteq> w\n  {u, v, w} \\<subseteq> circline_set H\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "by auto"], ["proof (state)\nthis:\n  \\<exists>u v.\n     u \\<in> unit_disc \\<and>\n     v \\<in> unit_disc \\<and>\n     u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H\n\ngoal (1 subgoal):\n 1. \\<not> (u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n            u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n            v \\<in> unit_disc \\<and> w \\<in> unit_disc) \\<Longrightarrow>\n    \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n            u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n            v \\<in> unit_disc \\<and> w \\<in> unit_disc) \\<Longrightarrow>\n    \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "case False"], ["proof (state)\nthis:\n  \\<not> (u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n          u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n          v \\<in> unit_disc \\<and> w \\<in> unit_disc)\n\ngoal (1 subgoal):\n 1. \\<not> (u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n            u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n            v \\<in> unit_disc \\<and> w \\<in> unit_disc) \\<Longrightarrow>\n    \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "have \"\\<exists> a b. a \\<noteq> b \\<and> a \\<noteq> inversion b \\<and> a \\<in> circline_set H \\<and> b \\<in> circline_set H \\<and> a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "proof (cases \"(u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set) \\<or>\n                  (u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set) \\<or>\n                  (v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n    u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n    v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n 2. \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n            u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n            v \\<in> unit_circle_set \\<and>\n            w \\<in> unit_circle_set) \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "case True"], ["proof (state)\nthis:\n  u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n  u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n  v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set\n\ngoal (2 subgoals):\n 1. u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n    u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n    v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n 2. \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n            u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n            v \\<in> unit_circle_set \\<and>\n            w \\<in> unit_circle_set) \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "then"], ["proof (chain)\npicking this:\n  u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n  u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n  v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set", "obtain i1 i2 a where *:\n        \"i1 \\<in> unit_circle_set \\<inter> circline_set H\" \"i2 \\<in> unit_circle_set \\<inter> circline_set H\" \n        \"a \\<in> circline_set H\" \"a \\<notin> unit_circle_set\"\n        \"i1 \\<noteq> i2\" \"i1 \\<noteq> a\" \"i2 \\<noteq> a\""], ["proof (prove)\nusing this:\n  u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n  u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n  v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set\n\ngoal (1 subgoal):\n 1. (\\<And>i1 i2 a.\n        \\<lbrakk>i1 \\<in> unit_circle_set \\<inter> circline_set H;\n         i2 \\<in> unit_circle_set \\<inter> circline_set H;\n         a \\<in> circline_set H; a \\<notin> unit_circle_set; i1 \\<noteq> i2;\n         i1 \\<noteq> a; i2 \\<noteq> a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using * \\<open>\\<not> {u, v, w} \\<subseteq> unit_circle_set\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n  u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n  v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set\n  u \\<noteq> v\n  v \\<noteq> w\n  u \\<noteq> w\n  {u, v, w} \\<subseteq> circline_set H\n  \\<not> {u, v, w} \\<subseteq> unit_circle_set\n\ngoal (1 subgoal):\n 1. (\\<And>i1 i2 a.\n        \\<lbrakk>i1 \\<in> unit_circle_set \\<inter> circline_set H;\n         i2 \\<in> unit_circle_set \\<inter> circline_set H;\n         a \\<in> circline_set H; a \\<notin> unit_circle_set; i1 \\<noteq> i2;\n         i1 \\<noteq> a; i2 \\<noteq> a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i1 \\<in> unit_circle_set \\<inter> circline_set H\n  i2 \\<in> unit_circle_set \\<inter> circline_set H\n  a \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  i1 \\<noteq> i2\n  i1 \\<noteq> a\n  i2 \\<noteq> a\n\ngoal (2 subgoals):\n 1. u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n    u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n    v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n 2. \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n            u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n            v \\<in> unit_circle_set \\<and>\n            w \\<in> unit_circle_set) \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "then"], ["proof (chain)\npicking this:\n  i1 \\<in> unit_circle_set \\<inter> circline_set H\n  i2 \\<in> unit_circle_set \\<inter> circline_set H\n  a \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  i1 \\<noteq> i2\n  i1 \\<noteq> a\n  i2 \\<noteq> a", "obtain b where \"b \\<in> circline_set H\" \"b \\<noteq> i1\" \"b \\<noteq> i2\" \"b \\<noteq> a\" \"b \\<noteq> inversion a\""], ["proof (prove)\nusing this:\n  i1 \\<in> unit_circle_set \\<inter> circline_set H\n  i2 \\<in> unit_circle_set \\<inter> circline_set H\n  a \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  i1 \\<noteq> i2\n  i1 \\<noteq> a\n  i2 \\<noteq> a\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> circline_set H; b \\<noteq> i1; b \\<noteq> i2;\n         b \\<noteq> a; b \\<noteq> inversion a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_is_poincare_line_points'[of i1 H i2 a]"], ["proof (prove)\nusing this:\n  i1 \\<in> unit_circle_set \\<inter> circline_set H\n  i2 \\<in> unit_circle_set \\<inter> circline_set H\n  a \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  i1 \\<noteq> i2\n  i1 \\<noteq> a\n  i2 \\<noteq> a\n  \\<lbrakk>i1 \\<in> circline_set H \\<inter> unit_circle_set;\n   i2 \\<in> circline_set H \\<inter> unit_circle_set; i1 \\<noteq> i2;\n   a \\<in> circline_set H; a \\<notin> unit_circle_set\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       b \\<noteq> i1 \\<and>\n                       b \\<noteq> i2 \\<and>\n                       b \\<noteq> a \\<and>\n                       b \\<noteq> inversion a \\<and> b \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> circline_set H; b \\<noteq> i1; b \\<noteq> i2;\n         b \\<noteq> a; b \\<noteq> inversion a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b \\<in> circline_set H\n  b \\<noteq> i1\n  b \\<noteq> i2\n  b \\<noteq> a\n  b \\<noteq> inversion a\n\ngoal (2 subgoals):\n 1. u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n    u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n    v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n 2. \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n            u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n            v \\<in> unit_circle_set \\<and>\n            w \\<in> unit_circle_set) \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "hence \"b \\<notin> unit_circle_set\""], ["proof (prove)\nusing this:\n  b \\<in> circline_set H\n  b \\<noteq> i1\n  b \\<noteq> i2\n  b \\<noteq> a\n  b \\<noteq> inversion a\n\ngoal (1 subgoal):\n 1. b \\<notin> unit_circle_set", "using * \\<open>H \\<noteq> unit_circle\\<close> unique_circline_set[of i1 i2 b]"], ["proof (prove)\nusing this:\n  b \\<in> circline_set H\n  b \\<noteq> i1\n  b \\<noteq> i2\n  b \\<noteq> a\n  b \\<noteq> inversion a\n  i1 \\<in> unit_circle_set \\<inter> circline_set H\n  i2 \\<in> unit_circle_set \\<inter> circline_set H\n  a \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  i1 \\<noteq> i2\n  i1 \\<noteq> a\n  i2 \\<noteq> a\n  H \\<noteq> unit_circle\n  \\<lbrakk>i1 \\<noteq> i2; i1 \\<noteq> b; i2 \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       i1 \\<in> circline_set H \\<and>\n                       i2 \\<in> circline_set H \\<and> b \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. b \\<notin> unit_circle_set", "unfolding unit_circle_set_def"], ["proof (prove)\nusing this:\n  b \\<in> circline_set H\n  b \\<noteq> i1\n  b \\<noteq> i2\n  b \\<noteq> a\n  b \\<noteq> inversion a\n  i1 \\<in> circline_set unit_circle \\<inter> circline_set H\n  i2 \\<in> circline_set unit_circle \\<inter> circline_set H\n  a \\<in> circline_set H\n  a \\<notin> circline_set unit_circle\n  i1 \\<noteq> i2\n  i1 \\<noteq> a\n  i2 \\<noteq> a\n  H \\<noteq> unit_circle\n  \\<lbrakk>i1 \\<noteq> i2; i1 \\<noteq> b; i2 \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       i1 \\<in> circline_set H \\<and>\n                       i2 \\<in> circline_set H \\<and> b \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. b \\<notin> circline_set unit_circle", "by auto"], ["proof (state)\nthis:\n  b \\<notin> unit_circle_set\n\ngoal (2 subgoals):\n 1. u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n    u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n    v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n 2. \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n            u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n            v \\<in> unit_circle_set \\<and>\n            w \\<in> unit_circle_set) \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "using * \\<open>b \\<in> circline_set H\\<close> \\<open>b \\<noteq> a\\<close> \\<open>b \\<noteq> inversion a\\<close>"], ["proof (prove)\nusing this:\n  b \\<notin> unit_circle_set\n  i1 \\<in> unit_circle_set \\<inter> circline_set H\n  i2 \\<in> unit_circle_set \\<inter> circline_set H\n  a \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  i1 \\<noteq> i2\n  i1 \\<noteq> a\n  i2 \\<noteq> a\n  b \\<in> circline_set H\n  b \\<noteq> a\n  b \\<noteq> inversion a\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "by auto"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> b \\<and>\n     a \\<noteq> inversion b \\<and>\n     a \\<in> circline_set H \\<and>\n     b \\<in> circline_set H \\<and>\n     a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n            u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n            v \\<in> unit_circle_set \\<and>\n            w \\<in> unit_circle_set) \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n            u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n            v \\<in> unit_circle_set \\<and>\n            w \\<in> unit_circle_set) \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "case False"], ["proof (state)\nthis:\n  \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n          u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n          v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set)\n\ngoal (1 subgoal):\n 1. \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n            u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n            v \\<in> unit_circle_set \\<and>\n            w \\<in> unit_circle_set) \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "then"], ["proof (chain)\npicking this:\n  \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n          u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n          v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set)", "obtain f g h where\n        *: \"f \\<noteq> g\" \"f \\<in> circline_set H\" \"f \\<notin> unit_circle_set\"  \n                    \"g \\<in> circline_set H\" \"g \\<notin> unit_circle_set\"\n                    \"h \\<in> circline_set H\" \"h \\<noteq> f\" \"h \\<noteq> g\""], ["proof (prove)\nusing this:\n  \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n          u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n          v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set)\n\ngoal (1 subgoal):\n 1. (\\<And>f g h.\n        \\<lbrakk>f \\<noteq> g; f \\<in> circline_set H;\n         f \\<notin> unit_circle_set; g \\<in> circline_set H;\n         g \\<notin> unit_circle_set; h \\<in> circline_set H; h \\<noteq> f;\n         h \\<noteq> g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using *"], ["proof (prove)\nusing this:\n  \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n          u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n          v \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set)\n  u \\<noteq> v\n  v \\<noteq> w\n  u \\<noteq> w\n  {u, v, w} \\<subseteq> circline_set H\n\ngoal (1 subgoal):\n 1. (\\<And>f g h.\n        \\<lbrakk>f \\<noteq> g; f \\<in> circline_set H;\n         f \\<notin> unit_circle_set; g \\<in> circline_set H;\n         g \\<notin> unit_circle_set; h \\<in> circline_set H; h \\<noteq> f;\n         h \\<noteq> g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> g\n  f \\<in> circline_set H\n  f \\<notin> unit_circle_set\n  g \\<in> circline_set H\n  g \\<notin> unit_circle_set\n  h \\<in> circline_set H\n  h \\<noteq> f\n  h \\<noteq> g\n\ngoal (1 subgoal):\n 1. \\<not> (u \\<in> unit_circle_set \\<and> v \\<in> unit_circle_set \\<or>\n            u \\<in> unit_circle_set \\<and> w \\<in> unit_circle_set \\<or>\n            v \\<in> unit_circle_set \\<and>\n            w \\<in> unit_circle_set) \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "proof (cases \"f = inversion g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = inversion g \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n 2. f \\<noteq> inversion g \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "case False"], ["proof (state)\nthis:\n  f \\<noteq> inversion g\n\ngoal (2 subgoals):\n 1. f = inversion g \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n 2. f \\<noteq> inversion g \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "thus ?thesis"], ["proof (prove)\nusing this:\n  f \\<noteq> inversion g\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "using *"], ["proof (prove)\nusing this:\n  f \\<noteq> inversion g\n  f \\<noteq> g\n  f \\<in> circline_set H\n  f \\<notin> unit_circle_set\n  g \\<in> circline_set H\n  g \\<notin> unit_circle_set\n  h \\<in> circline_set H\n  h \\<noteq> f\n  h \\<noteq> g\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "by auto"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> b \\<and>\n     a \\<noteq> inversion b \\<and>\n     a \\<in> circline_set H \\<and>\n     b \\<in> circline_set H \\<and>\n     a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. f = inversion g \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f = inversion g \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "case True"], ["proof (state)\nthis:\n  f = inversion g\n\ngoal (1 subgoal):\n 1. f = inversion g \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "proof (cases \"h \\<in> unit_circle_set\")"], ["proof (state)\ngoal (2 subgoals):\n 1. h \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n 2. h \\<notin> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "case False"], ["proof (state)\nthis:\n  h \\<notin> unit_circle_set\n\ngoal (2 subgoals):\n 1. h \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n 2. h \\<notin> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "thus ?thesis"], ["proof (prove)\nusing this:\n  h \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "using * \\<open>f = inversion g\\<close>"], ["proof (prove)\nusing this:\n  h \\<notin> unit_circle_set\n  f \\<noteq> g\n  f \\<in> circline_set H\n  f \\<notin> unit_circle_set\n  g \\<in> circline_set H\n  g \\<notin> unit_circle_set\n  h \\<in> circline_set H\n  h \\<noteq> f\n  h \\<noteq> g\n  f = inversion g\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "by auto"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> b \\<and>\n     a \\<noteq> inversion b \\<and>\n     a \\<in> circline_set H \\<and>\n     b \\<in> circline_set H \\<and>\n     a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. h \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. h \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "case True"], ["proof (state)\nthis:\n  h \\<in> unit_circle_set\n\ngoal (1 subgoal):\n 1. h \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "obtain m where cr2: \"cross_ratio m h f g = of_complex 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        cross_ratio m h f g = of_complex 2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_cross_ratio[of h f g] * \\<open>f \\<noteq> g\\<close> \\<open>h \\<noteq> f\\<close> \\<open>h \\<noteq> g\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>h \\<noteq> f; h \\<noteq> g; f \\<noteq> g\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. cross_ratio z h f g = ?c\n  f \\<noteq> g\n  f \\<in> circline_set H\n  f \\<notin> unit_circle_set\n  g \\<in> circline_set H\n  g \\<notin> unit_circle_set\n  h \\<in> circline_set H\n  h \\<noteq> f\n  h \\<noteq> g\n  f \\<noteq> g\n  h \\<noteq> f\n  h \\<noteq> g\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        cross_ratio m h f g = of_complex 2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cross_ratio m h f g = of_complex 2\n\ngoal (1 subgoal):\n 1. h \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "hence \"m \\<noteq> h\" \"m \\<noteq> f\" \"m \\<noteq> g\""], ["proof (prove)\nusing this:\n  cross_ratio m h f g = of_complex 2\n\ngoal (1 subgoal):\n 1. m \\<noteq> h &&& m \\<noteq> f &&& m \\<noteq> g", "using \\<open>h \\<noteq> f\\<close> \\<open>h \\<noteq> g\\<close> \\<open>f \\<noteq> g\\<close>"], ["proof (prove)\nusing this:\n  cross_ratio m h f g = of_complex 2\n  h \\<noteq> f\n  h \\<noteq> g\n  f \\<noteq> g\n\ngoal (1 subgoal):\n 1. m \\<noteq> h &&& m \\<noteq> f &&& m \\<noteq> g", "using ex1_cross_ratio[of h f g]"], ["proof (prove)\nusing this:\n  cross_ratio m h f g = of_complex 2\n  h \\<noteq> f\n  h \\<noteq> g\n  f \\<noteq> g\n  \\<lbrakk>h \\<noteq> f; h \\<noteq> g; f \\<noteq> g\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!z. cross_ratio z h f g = ?c\n\ngoal (1 subgoal):\n 1. m \\<noteq> h &&& m \\<noteq> f &&& m \\<noteq> g", "using cross_ratio_0[of h f g] cross_ratio_1[of h f g] cross_ratio_inf[of h g f]"], ["proof (prove)\nusing this:\n  cross_ratio m h f g = of_complex 2\n  h \\<noteq> f\n  h \\<noteq> g\n  f \\<noteq> g\n  \\<lbrakk>h \\<noteq> f; h \\<noteq> g; f \\<noteq> g\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!z. cross_ratio z h f g = ?c\n  \\<lbrakk>h \\<noteq> f; h \\<noteq> g\\<rbrakk>\n  \\<Longrightarrow> cross_ratio h h f g = 0\\<^sub>h\n  \\<lbrakk>h \\<noteq> f; f \\<noteq> g\\<rbrakk>\n  \\<Longrightarrow> cross_ratio f h f g = 1\\<^sub>h\n  \\<lbrakk>h \\<noteq> g; f \\<noteq> g\\<rbrakk>\n  \\<Longrightarrow> cross_ratio g h f g = \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. m \\<noteq> h &&& m \\<noteq> f &&& m \\<noteq> g", "using cr2"], ["proof (prove)\nusing this:\n  cross_ratio m h f g = of_complex 2\n  h \\<noteq> f\n  h \\<noteq> g\n  f \\<noteq> g\n  \\<lbrakk>h \\<noteq> f; h \\<noteq> g; f \\<noteq> g\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!z. cross_ratio z h f g = ?c\n  \\<lbrakk>h \\<noteq> f; h \\<noteq> g\\<rbrakk>\n  \\<Longrightarrow> cross_ratio h h f g = 0\\<^sub>h\n  \\<lbrakk>h \\<noteq> f; f \\<noteq> g\\<rbrakk>\n  \\<Longrightarrow> cross_ratio f h f g = 1\\<^sub>h\n  \\<lbrakk>h \\<noteq> g; f \\<noteq> g\\<rbrakk>\n  \\<Longrightarrow> cross_ratio g h f g = \\<infinity>\\<^sub>h\n  cross_ratio m h f g = of_complex 2\n\ngoal (1 subgoal):\n 1. m \\<noteq> h &&& m \\<noteq> f &&& m \\<noteq> g", "by auto"], ["proof (state)\nthis:\n  m \\<noteq> h\n  m \\<noteq> f\n  m \\<noteq> g\n\ngoal (1 subgoal):\n 1. h \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "hence \"m \\<in> circline_set H\""], ["proof (prove)\nusing this:\n  m \\<noteq> h\n  m \\<noteq> f\n  m \\<noteq> g\n\ngoal (1 subgoal):\n 1. m \\<in> circline_set H", "using four_points_on_circline_iff_cross_ratio_real[of m h f g] cr2"], ["proof (prove)\nusing this:\n  m \\<noteq> h\n  m \\<noteq> f\n  m \\<noteq> g\n  distinct [m, h, f, g] \\<Longrightarrow>\n  is_real (to_complex (cross_ratio m h f g)) =\n  (\\<exists>H. {m, h, f, g} \\<subseteq> circline_set H)\n  cross_ratio m h f g = of_complex 2\n\ngoal (1 subgoal):\n 1. m \\<in> circline_set H", "using \\<open>h \\<noteq> f\\<close> \\<open>h \\<noteq> g\\<close> \\<open>f \\<noteq> g\\<close> *"], ["proof (prove)\nusing this:\n  m \\<noteq> h\n  m \\<noteq> f\n  m \\<noteq> g\n  distinct [m, h, f, g] \\<Longrightarrow>\n  is_real (to_complex (cross_ratio m h f g)) =\n  (\\<exists>H. {m, h, f, g} \\<subseteq> circline_set H)\n  cross_ratio m h f g = of_complex 2\n  h \\<noteq> f\n  h \\<noteq> g\n  f \\<noteq> g\n  f \\<noteq> g\n  f \\<in> circline_set H\n  f \\<notin> unit_circle_set\n  g \\<in> circline_set H\n  g \\<notin> unit_circle_set\n  h \\<in> circline_set H\n  h \\<noteq> f\n  h \\<noteq> g\n\ngoal (1 subgoal):\n 1. m \\<in> circline_set H", "using unique_circline_set[of h f g]"], ["proof (prove)\nusing this:\n  m \\<noteq> h\n  m \\<noteq> f\n  m \\<noteq> g\n  distinct [m, h, f, g] \\<Longrightarrow>\n  is_real (to_complex (cross_ratio m h f g)) =\n  (\\<exists>H. {m, h, f, g} \\<subseteq> circline_set H)\n  cross_ratio m h f g = of_complex 2\n  h \\<noteq> f\n  h \\<noteq> g\n  f \\<noteq> g\n  f \\<noteq> g\n  f \\<in> circline_set H\n  f \\<notin> unit_circle_set\n  g \\<in> circline_set H\n  g \\<notin> unit_circle_set\n  h \\<in> circline_set H\n  h \\<noteq> f\n  h \\<noteq> g\n  \\<lbrakk>h \\<noteq> f; h \\<noteq> g; f \\<noteq> g\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       h \\<in> circline_set H \\<and>\n                       f \\<in> circline_set H \\<and> g \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. m \\<in> circline_set H", "by auto"], ["proof (state)\nthis:\n  m \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. h \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "proof (cases \"m \\<in> unit_circle_set\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n 2. m \\<notin> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "case False"], ["proof (state)\nthis:\n  m \\<notin> unit_circle_set\n\ngoal (2 subgoals):\n 1. m \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n 2. m \\<notin> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "thus ?thesis"], ["proof (prove)\nusing this:\n  m \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "using \\<open>m \\<noteq> f\\<close> \\<open>m \\<noteq> g\\<close> \\<open>f = inversion g\\<close> * \\<open>m \\<in> circline_set H\\<close>"], ["proof (prove)\nusing this:\n  m \\<notin> unit_circle_set\n  m \\<noteq> f\n  m \\<noteq> g\n  f = inversion g\n  f \\<noteq> g\n  f \\<in> circline_set H\n  f \\<notin> unit_circle_set\n  g \\<in> circline_set H\n  g \\<notin> unit_circle_set\n  h \\<in> circline_set H\n  h \\<noteq> f\n  h \\<noteq> g\n  m \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "by auto"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> b \\<and>\n     a \\<noteq> inversion b \\<and>\n     a \\<in> circline_set H \\<and>\n     b \\<in> circline_set H \\<and>\n     a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. m \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "case True"], ["proof (state)\nthis:\n  m \\<in> unit_circle_set\n\ngoal (1 subgoal):\n 1. m \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "then"], ["proof (chain)\npicking this:\n  m \\<in> unit_circle_set", "obtain n where \"n \\<noteq> h\" \"n \\<noteq> m\" \"n \\<noteq> f\" \"n \\<noteq> inversion f\" \"n \\<in> circline_set H\""], ["proof (prove)\nusing this:\n  m \\<in> unit_circle_set\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n \\<noteq> h; n \\<noteq> m; n \\<noteq> f;\n         n \\<noteq> inversion f; n \\<in> circline_set H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_is_poincare_line_points'[of h H m f] * \\<open>m \\<in> circline_set H\\<close> \\<open>h \\<in> unit_circle_set\\<close> \\<open>m \\<noteq> h\\<close>"], ["proof (prove)\nusing this:\n  m \\<in> unit_circle_set\n  \\<lbrakk>h \\<in> circline_set H \\<inter> unit_circle_set;\n   m \\<in> circline_set H \\<inter> unit_circle_set; h \\<noteq> m;\n   f \\<in> circline_set H; f \\<notin> unit_circle_set\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       b \\<noteq> h \\<and>\n                       b \\<noteq> m \\<and>\n                       b \\<noteq> f \\<and>\n                       b \\<noteq> inversion f \\<and> b \\<in> circline_set H\n  f \\<noteq> g\n  f \\<in> circline_set H\n  f \\<notin> unit_circle_set\n  g \\<in> circline_set H\n  g \\<notin> unit_circle_set\n  h \\<in> circline_set H\n  h \\<noteq> f\n  h \\<noteq> g\n  m \\<in> circline_set H\n  h \\<in> unit_circle_set\n  m \\<noteq> h\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n \\<noteq> h; n \\<noteq> m; n \\<noteq> f;\n         n \\<noteq> inversion f; n \\<in> circline_set H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> h\n  n \\<noteq> m\n  n \\<noteq> f\n  n \\<noteq> inversion f\n  n \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. m \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "hence \"n \\<notin> unit_circle_set\""], ["proof (prove)\nusing this:\n  n \\<noteq> h\n  n \\<noteq> m\n  n \\<noteq> f\n  n \\<noteq> inversion f\n  n \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. n \\<notin> unit_circle_set", "using * \\<open>H \\<noteq> unit_circle\\<close> unique_circline_set[of m n h]"], ["proof (prove)\nusing this:\n  n \\<noteq> h\n  n \\<noteq> m\n  n \\<noteq> f\n  n \\<noteq> inversion f\n  n \\<in> circline_set H\n  f \\<noteq> g\n  f \\<in> circline_set H\n  f \\<notin> unit_circle_set\n  g \\<in> circline_set H\n  g \\<notin> unit_circle_set\n  h \\<in> circline_set H\n  h \\<noteq> f\n  h \\<noteq> g\n  H \\<noteq> unit_circle\n  \\<lbrakk>m \\<noteq> n; m \\<noteq> h; n \\<noteq> h\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       m \\<in> circline_set H \\<and>\n                       n \\<in> circline_set H \\<and> h \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. n \\<notin> unit_circle_set", "using \\<open>m \\<noteq> h\\<close> \\<open>m \\<in> unit_circle_set\\<close> \\<open>h \\<in> unit_circle_set\\<close> \\<open>m \\<in> circline_set H\\<close>"], ["proof (prove)\nusing this:\n  n \\<noteq> h\n  n \\<noteq> m\n  n \\<noteq> f\n  n \\<noteq> inversion f\n  n \\<in> circline_set H\n  f \\<noteq> g\n  f \\<in> circline_set H\n  f \\<notin> unit_circle_set\n  g \\<in> circline_set H\n  g \\<notin> unit_circle_set\n  h \\<in> circline_set H\n  h \\<noteq> f\n  h \\<noteq> g\n  H \\<noteq> unit_circle\n  \\<lbrakk>m \\<noteq> n; m \\<noteq> h; n \\<noteq> h\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       m \\<in> circline_set H \\<and>\n                       n \\<in> circline_set H \\<and> h \\<in> circline_set H\n  m \\<noteq> h\n  m \\<in> unit_circle_set\n  h \\<in> unit_circle_set\n  m \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. n \\<notin> unit_circle_set", "unfolding unit_circle_set_def"], ["proof (prove)\nusing this:\n  n \\<noteq> h\n  n \\<noteq> m\n  n \\<noteq> f\n  n \\<noteq> inversion f\n  n \\<in> circline_set H\n  f \\<noteq> g\n  f \\<in> circline_set H\n  f \\<notin> circline_set unit_circle\n  g \\<in> circline_set H\n  g \\<notin> circline_set unit_circle\n  h \\<in> circline_set H\n  h \\<noteq> f\n  h \\<noteq> g\n  H \\<noteq> unit_circle\n  \\<lbrakk>m \\<noteq> n; m \\<noteq> h; n \\<noteq> h\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       m \\<in> circline_set H \\<and>\n                       n \\<in> circline_set H \\<and> h \\<in> circline_set H\n  m \\<noteq> h\n  m \\<in> circline_set unit_circle\n  h \\<in> circline_set unit_circle\n  m \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. n \\<notin> circline_set unit_circle", "by auto"], ["proof (state)\nthis:\n  n \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. m \\<in> unit_circle_set \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "using * \\<open>n \\<in> circline_set H\\<close> \\<open>n \\<noteq> f\\<close> \\<open>n \\<noteq> inversion f\\<close>"], ["proof (prove)\nusing this:\n  n \\<notin> unit_circle_set\n  f \\<noteq> g\n  f \\<in> circline_set H\n  f \\<notin> unit_circle_set\n  g \\<in> circline_set H\n  g \\<notin> unit_circle_set\n  h \\<in> circline_set H\n  h \\<noteq> f\n  h \\<noteq> g\n  n \\<in> circline_set H\n  n \\<noteq> f\n  n \\<noteq> inversion f\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       a \\<noteq> inversion b \\<and>\n       a \\<in> circline_set H \\<and>\n       b \\<in> circline_set H \\<and>\n       a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "by auto"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> b \\<and>\n     a \\<noteq> inversion b \\<and>\n     a \\<in> circline_set H \\<and>\n     b \\<in> circline_set H \\<and>\n     a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> b \\<and>\n     a \\<noteq> inversion b \\<and>\n     a \\<in> circline_set H \\<and>\n     b \\<in> circline_set H \\<and>\n     a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> b \\<and>\n     a \\<noteq> inversion b \\<and>\n     a \\<in> circline_set H \\<and>\n     b \\<in> circline_set H \\<and>\n     a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> b \\<and>\n     a \\<noteq> inversion b \\<and>\n     a \\<in> circline_set H \\<and>\n     b \\<in> circline_set H \\<and>\n     a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> b \\<and>\n     a \\<noteq> inversion b \\<and>\n     a \\<in> circline_set H \\<and>\n     b \\<in> circline_set H \\<and>\n     a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. \\<not> (u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n            u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n            v \\<in> unit_disc \\<and> w \\<in> unit_disc) \\<Longrightarrow>\n    \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "then"], ["proof (chain)\npicking this:\n  \\<exists>a b.\n     a \\<noteq> b \\<and>\n     a \\<noteq> inversion b \\<and>\n     a \\<in> circline_set H \\<and>\n     b \\<in> circline_set H \\<and>\n     a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set", "obtain a b where ab: \"a \\<noteq> b\" \"a \\<noteq> inversion b\" \"a \\<in> circline_set H\" \"b \\<in> circline_set H\" \"a \\<notin> unit_circle_set\" \"b \\<notin> unit_circle_set\""], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     a \\<noteq> b \\<and>\n     a \\<noteq> inversion b \\<and>\n     a \\<in> circline_set H \\<and>\n     b \\<in> circline_set H \\<and>\n     a \\<notin> unit_circle_set \\<and> b \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<noteq> b; a \\<noteq> inversion b;\n         a \\<in> circline_set H; b \\<in> circline_set H;\n         a \\<notin> unit_circle_set; b \\<notin> unit_circle_set\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<noteq> b\n  a \\<noteq> inversion b\n  a \\<in> circline_set H\n  b \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  b \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. \\<not> (u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n            u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n            v \\<in> unit_disc \\<and> w \\<in> unit_disc) \\<Longrightarrow>\n    \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "have \"\\<forall> x. x \\<in> circline_set H \\<and> x \\<notin> unit_circle_set \\<longrightarrow> (\\<exists> x'. x' \\<in> circline_set H \\<inter> unit_disc \\<and> (x' = x \\<or> x' = inversion x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> circline_set H \\<and>\n       x \\<notin> unit_circle_set \\<longrightarrow>\n       (\\<exists>x'.\n           x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n           (x' = x \\<or> x' = inversion x))", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> circline_set H; x \\<notin> unit_circle_set\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            x' \\<in> circline_set H \\<inter>\n                                     unit_disc \\<and>\n                            (x' = x \\<or> x' = inversion x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> circline_set H; x \\<notin> unit_circle_set\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            x' \\<in> circline_set H \\<inter>\n                                     unit_disc \\<and>\n                            (x' = x \\<or> x' = inversion x)", "assume x: \"x \\<in> circline_set H\" \"x \\<notin> unit_circle_set\""], ["proof (state)\nthis:\n  x \\<in> circline_set H\n  x \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> circline_set H; x \\<notin> unit_circle_set\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            x' \\<in> circline_set H \\<inter>\n                                     unit_disc \\<and>\n                            (x' = x \\<or> x' = inversion x)", "show \"\\<exists> x'. x' \\<in> circline_set H \\<inter> unit_disc \\<and> (x' = x \\<or> x' = inversion x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)", "proof (cases \"x \\<in> unit_disc\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> unit_disc \\<Longrightarrow>\n    \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)\n 2. x \\<notin> unit_disc \\<Longrightarrow>\n    \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)", "case True"], ["proof (state)\nthis:\n  x \\<in> unit_disc\n\ngoal (2 subgoals):\n 1. x \\<in> unit_disc \\<Longrightarrow>\n    \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)\n 2. x \\<notin> unit_disc \\<Longrightarrow>\n    \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> unit_disc\n  x \\<in> circline_set H\n  x \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x'.\n     x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n     (x' = x \\<or> x' = inversion x)\n\ngoal (1 subgoal):\n 1. x \\<notin> unit_disc \\<Longrightarrow>\n    \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> unit_disc \\<Longrightarrow>\n    \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)", "case False"], ["proof (state)\nthis:\n  x \\<notin> unit_disc\n\ngoal (1 subgoal):\n 1. x \\<notin> unit_disc \\<Longrightarrow>\n    \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)", "hence \"x \\<in> unit_disc_compl\""], ["proof (prove)\nusing this:\n  x \\<notin> unit_disc\n\ngoal (1 subgoal):\n 1. x \\<in> unit_disc_compl", "using x  in_on_out_univ[of \"ounit_circle\"]"], ["proof (prove)\nusing this:\n  x \\<notin> unit_disc\n  x \\<in> circline_set H\n  x \\<notin> unit_circle_set\n  disc ounit_circle \\<union> disc_compl ounit_circle \\<union>\n  ocircline_set ounit_circle =\n  UNIV\n\ngoal (1 subgoal):\n 1. x \\<in> unit_disc_compl", "unfolding unit_circle_set_def unit_disc_def unit_disc_compl_def"], ["proof (prove)\nusing this:\n  x \\<notin> disc ounit_circle\n  x \\<in> circline_set H\n  x \\<notin> circline_set unit_circle\n  disc ounit_circle \\<union> disc_compl ounit_circle \\<union>\n  ocircline_set ounit_circle =\n  UNIV\n\ngoal (1 subgoal):\n 1. x \\<in> disc_compl ounit_circle", "by auto"], ["proof (state)\nthis:\n  x \\<in> unit_disc_compl\n\ngoal (1 subgoal):\n 1. x \\<notin> unit_disc \\<Longrightarrow>\n    \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)", "hence \"inversion x \\<in> unit_disc\""], ["proof (prove)\nusing this:\n  x \\<in> unit_disc_compl\n\ngoal (1 subgoal):\n 1. inversion x \\<in> unit_disc", "using inversion_unit_disc_compl"], ["proof (prove)\nusing this:\n  x \\<in> unit_disc_compl\n  inversion ` unit_disc_compl = unit_disc\n\ngoal (1 subgoal):\n 1. inversion x \\<in> unit_disc", "by blast"], ["proof (state)\nthis:\n  inversion x \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. x \\<notin> unit_disc \\<Longrightarrow>\n    \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  inversion x \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)", "using is_poincare_line_inverse_point[OF assms, of x] x"], ["proof (prove)\nusing this:\n  inversion x \\<in> unit_disc\n  x \\<in> circline_set H \\<Longrightarrow> inversion x \\<in> circline_set H\n  x \\<in> circline_set H\n  x \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n       (x' = x \\<or> x' = inversion x)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x'.\n     x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n     (x' = x \\<or> x' = inversion x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x'.\n     x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n     (x' = x \\<or> x' = inversion x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in> circline_set H \\<and>\n     x \\<notin> unit_circle_set \\<longrightarrow>\n     (\\<exists>x'.\n         x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n         (x' = x \\<or> x' = inversion x))\n\ngoal (1 subgoal):\n 1. \\<not> (u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n            u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n            v \\<in> unit_disc \\<and> w \\<in> unit_disc) \\<Longrightarrow>\n    \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in> circline_set H \\<and>\n     x \\<notin> unit_circle_set \\<longrightarrow>\n     (\\<exists>x'.\n         x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n         (x' = x \\<or> x' = inversion x))", "obtain a' b' where \n      *: \"a' \\<in> circline_set H\" \"a' \\<in> unit_disc\" \"b' \\<in> circline_set H\" \"b' \\<in> unit_disc\" and\n      **: \"a' = a \\<or> a' = inversion a\" \"b' = b \\<or> b' = inversion b\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> circline_set H \\<and>\n     x \\<notin> unit_circle_set \\<longrightarrow>\n     (\\<exists>x'.\n         x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n         (x' = x \\<or> x' = inversion x))\n\ngoal (1 subgoal):\n 1. (\\<And>a' b'.\n        \\<lbrakk>a' \\<in> circline_set H; a' \\<in> unit_disc;\n         b' \\<in> circline_set H; b' \\<in> unit_disc;\n         a' = a \\<or> a' = inversion a;\n         b' = b \\<or> b' = inversion b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ab"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> circline_set H \\<and>\n     x \\<notin> unit_circle_set \\<longrightarrow>\n     (\\<exists>x'.\n         x' \\<in> circline_set H \\<inter> unit_disc \\<and>\n         (x' = x \\<or> x' = inversion x))\n  a \\<noteq> b\n  a \\<noteq> inversion b\n  a \\<in> circline_set H\n  b \\<in> circline_set H\n  a \\<notin> unit_circle_set\n  b \\<notin> unit_circle_set\n\ngoal (1 subgoal):\n 1. (\\<And>a' b'.\n        \\<lbrakk>a' \\<in> circline_set H; a' \\<in> unit_disc;\n         b' \\<in> circline_set H; b' \\<in> unit_disc;\n         a' = a \\<or> a' = inversion a;\n         b' = b \\<or> b' = inversion b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a' \\<in> circline_set H\n  a' \\<in> unit_disc\n  b' \\<in> circline_set H\n  b' \\<in> unit_disc\n  a' = a \\<or> a' = inversion a\n  b' = b \\<or> b' = inversion b\n\ngoal (1 subgoal):\n 1. \\<not> (u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n            u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n            v \\<in> unit_disc \\<and> w \\<in> unit_disc) \\<Longrightarrow>\n    \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "have \"a' \\<noteq> b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<noteq> b'", "using \\<open>a \\<noteq> b\\<close> \\<open>a \\<noteq> inversion b\\<close> ** *"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  a \\<noteq> inversion b\n  a' = a \\<or> a' = inversion a\n  b' = b \\<or> b' = inversion b\n  a' \\<in> circline_set H\n  a' \\<in> unit_disc\n  b' \\<in> circline_set H\n  b' \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. a' \\<noteq> b'", "by (metis inversion_involution)"], ["proof (state)\nthis:\n  a' \\<noteq> b'\n\ngoal (1 subgoal):\n 1. \\<not> (u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<or>\n            u \\<in> unit_disc \\<and> w \\<in> unit_disc \\<or>\n            v \\<in> unit_disc \\<and> w \\<in> unit_disc) \\<Longrightarrow>\n    \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "thus ?thesis"], ["proof (prove)\nusing this:\n  a' \\<noteq> b'\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "using *"], ["proof (prove)\nusing this:\n  a' \\<noteq> b'\n  a' \\<in> circline_set H\n  a' \\<in> unit_disc\n  b' \\<in> circline_set H\n  b' \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and>\n       u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H", "by auto"], ["proof (state)\nthis:\n  \\<exists>u v.\n     u \\<in> unit_disc \\<and>\n     v \\<in> unit_disc \\<and>\n     u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u v.\n     u \\<in> unit_disc \\<and>\n     v \\<in> unit_disc \\<and>\n     u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set H\n\ngoal:\nNo subgoals!", "qed"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsubsection \\<open>H-line uniqueness\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "text\\<open>There is no more than one h-line that contains two different h-points (in the disc).\\<close>"], ["", "lemma unique_is_poincare_line:\n  assumes in_disc: \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\"\n  assumes pl: \"is_poincare_line l1\" \"is_poincare_line l2\"\n  assumes on_l: \"{u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\"\n  shows \"l1 = l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l1 = l2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. l1 = l2", "have \"u \\<noteq> inversion u\" \"v \\<noteq> inversion u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> inversion u &&& v \\<noteq> inversion u", "using in_disc"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. u \\<noteq> inversion u &&& v \\<noteq> inversion u", "using inversion_noteq_unit_disc[of u v]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n  \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> inversion u \\<noteq> v\n\ngoal (1 subgoal):\n 1. u \\<noteq> inversion u &&& v \\<noteq> inversion u", "using inversion_noteq_unit_disc[of u u]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n  \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> inversion u \\<noteq> v\n  \\<lbrakk>u \\<in> unit_disc; u \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> inversion u \\<noteq> u\n\ngoal (1 subgoal):\n 1. u \\<noteq> inversion u &&& v \\<noteq> inversion u", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> inversion u\n  v \\<noteq> inversion u\n\ngoal (1 subgoal):\n 1. l1 = l2", "thus ?thesis"], ["proof (prove)\nusing this:\n  u \\<noteq> inversion u\n  v \\<noteq> inversion u\n\ngoal (1 subgoal):\n 1. l1 = l2", "using on_l"], ["proof (prove)\nusing this:\n  u \\<noteq> inversion u\n  v \\<noteq> inversion u\n  {u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\n\ngoal (1 subgoal):\n 1. l1 = l2", "using unique_circline_set[of u \"inversion u\" \"v\"] \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  u \\<noteq> inversion u\n  v \\<noteq> inversion u\n  {u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\n  \\<lbrakk>u \\<noteq> inversion u; u \\<noteq> v;\n   inversion u \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       u \\<in> circline_set H \\<and>\n                       inversion u \\<in> circline_set H \\<and>\n                       v \\<in> circline_set H\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. l1 = l2", "using is_poincare_line_inverse_point[of l1 u]"], ["proof (prove)\nusing this:\n  u \\<noteq> inversion u\n  v \\<noteq> inversion u\n  {u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\n  \\<lbrakk>u \\<noteq> inversion u; u \\<noteq> v;\n   inversion u \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       u \\<in> circline_set H \\<and>\n                       inversion u \\<in> circline_set H \\<and>\n                       v \\<in> circline_set H\n  u \\<noteq> v\n  \\<lbrakk>is_poincare_line l1; u \\<in> circline_set l1\\<rbrakk>\n  \\<Longrightarrow> inversion u \\<in> circline_set l1\n\ngoal (1 subgoal):\n 1. l1 = l2", "using is_poincare_line_inverse_point[of l2 u]"], ["proof (prove)\nusing this:\n  u \\<noteq> inversion u\n  v \\<noteq> inversion u\n  {u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\n  \\<lbrakk>u \\<noteq> inversion u; u \\<noteq> v;\n   inversion u \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       u \\<in> circline_set H \\<and>\n                       inversion u \\<in> circline_set H \\<and>\n                       v \\<in> circline_set H\n  u \\<noteq> v\n  \\<lbrakk>is_poincare_line l1; u \\<in> circline_set l1\\<rbrakk>\n  \\<Longrightarrow> inversion u \\<in> circline_set l1\n  \\<lbrakk>is_poincare_line l2; u \\<in> circline_set l2\\<rbrakk>\n  \\<Longrightarrow> inversion u \\<in> circline_set l2\n\ngoal (1 subgoal):\n 1. l1 = l2", "using pl"], ["proof (prove)\nusing this:\n  u \\<noteq> inversion u\n  v \\<noteq> inversion u\n  {u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\n  \\<lbrakk>u \\<noteq> inversion u; u \\<noteq> v;\n   inversion u \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       u \\<in> circline_set H \\<and>\n                       inversion u \\<in> circline_set H \\<and>\n                       v \\<in> circline_set H\n  u \\<noteq> v\n  \\<lbrakk>is_poincare_line l1; u \\<in> circline_set l1\\<rbrakk>\n  \\<Longrightarrow> inversion u \\<in> circline_set l1\n  \\<lbrakk>is_poincare_line l2; u \\<in> circline_set l2\\<rbrakk>\n  \\<Longrightarrow> inversion u \\<in> circline_set l2\n  is_poincare_line l1\n  is_poincare_line l2\n\ngoal (1 subgoal):\n 1. l1 = l2", "by auto"], ["proof (state)\nthis:\n  l1 = l2\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>For the rest of our formalization it is often useful to consider points on h-lines that are not\nwithin the unit disc. Many lemmas in the rest of this section will have such generalizations.\\<close>"], ["", "text\\<open>There is no more than one h-line that contains two different and not mutually inverse points\n(not necessary in the unit disc).\\<close>"], ["", "lemma unique_is_poincare_line_general:\n  assumes different: \"u \\<noteq> v\" \"u \\<noteq> inversion v\"\n  assumes pl: \"is_poincare_line l1\" \"is_poincare_line l2\"\n  assumes on_l: \"{u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\"\n  shows  \"l1 = l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l1 = l2", "proof (cases \"u \\<noteq> inversion u\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<noteq> inversion u \\<Longrightarrow> l1 = l2\n 2. \\<not> u \\<noteq> inversion u \\<Longrightarrow> l1 = l2", "case True"], ["proof (state)\nthis:\n  u \\<noteq> inversion u\n\ngoal (2 subgoals):\n 1. u \\<noteq> inversion u \\<Longrightarrow> l1 = l2\n 2. \\<not> u \\<noteq> inversion u \\<Longrightarrow> l1 = l2", "thus ?thesis"], ["proof (prove)\nusing this:\n  u \\<noteq> inversion u\n\ngoal (1 subgoal):\n 1. l1 = l2", "using unique_circline_set[of u \"inversion u\" \"v\"]"], ["proof (prove)\nusing this:\n  u \\<noteq> inversion u\n  \\<lbrakk>u \\<noteq> inversion u; u \\<noteq> v;\n   inversion u \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       u \\<in> circline_set H \\<and>\n                       inversion u \\<in> circline_set H \\<and>\n                       v \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. l1 = l2", "using assms"], ["proof (prove)\nusing this:\n  u \\<noteq> inversion u\n  \\<lbrakk>u \\<noteq> inversion u; u \\<noteq> v;\n   inversion u \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       u \\<in> circline_set H \\<and>\n                       inversion u \\<in> circline_set H \\<and>\n                       v \\<in> circline_set H\n  u \\<noteq> v\n  u \\<noteq> inversion v\n  is_poincare_line l1\n  is_poincare_line l2\n  {u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\n\ngoal (1 subgoal):\n 1. l1 = l2", "using is_poincare_line_inverse_point"], ["proof (prove)\nusing this:\n  u \\<noteq> inversion u\n  \\<lbrakk>u \\<noteq> inversion u; u \\<noteq> v;\n   inversion u \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       u \\<in> circline_set H \\<and>\n                       inversion u \\<in> circline_set H \\<and>\n                       v \\<in> circline_set H\n  u \\<noteq> v\n  u \\<noteq> inversion v\n  is_poincare_line l1\n  is_poincare_line l2\n  {u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\n  \\<lbrakk>is_poincare_line ?H; ?u \\<in> circline_set ?H\\<rbrakk>\n  \\<Longrightarrow> inversion ?u \\<in> circline_set ?H\n\ngoal (1 subgoal):\n 1. l1 = l2", "by force"], ["proof (state)\nthis:\n  l1 = l2\n\ngoal (1 subgoal):\n 1. \\<not> u \\<noteq> inversion u \\<Longrightarrow> l1 = l2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> u \\<noteq> inversion u \\<Longrightarrow> l1 = l2", "case False"], ["proof (state)\nthis:\n  \\<not> u \\<noteq> inversion u\n\ngoal (1 subgoal):\n 1. \\<not> u \\<noteq> inversion u \\<Longrightarrow> l1 = l2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. l1 = l2", "proof (cases \"v \\<noteq> inversion v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<noteq> inversion v \\<Longrightarrow> l1 = l2\n 2. \\<not> v \\<noteq> inversion v \\<Longrightarrow> l1 = l2", "case True"], ["proof (state)\nthis:\n  v \\<noteq> inversion v\n\ngoal (2 subgoals):\n 1. v \\<noteq> inversion v \\<Longrightarrow> l1 = l2\n 2. \\<not> v \\<noteq> inversion v \\<Longrightarrow> l1 = l2", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<noteq> inversion v\n\ngoal (1 subgoal):\n 1. l1 = l2", "using unique_circline_set[of u \"inversion v\" \"v\"]"], ["proof (prove)\nusing this:\n  v \\<noteq> inversion v\n  \\<lbrakk>u \\<noteq> inversion v; u \\<noteq> v;\n   inversion v \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       u \\<in> circline_set H \\<and>\n                       inversion v \\<in> circline_set H \\<and>\n                       v \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. l1 = l2", "using assms"], ["proof (prove)\nusing this:\n  v \\<noteq> inversion v\n  \\<lbrakk>u \\<noteq> inversion v; u \\<noteq> v;\n   inversion v \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       u \\<in> circline_set H \\<and>\n                       inversion v \\<in> circline_set H \\<and>\n                       v \\<in> circline_set H\n  u \\<noteq> v\n  u \\<noteq> inversion v\n  is_poincare_line l1\n  is_poincare_line l2\n  {u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\n\ngoal (1 subgoal):\n 1. l1 = l2", "using is_poincare_line_inverse_point"], ["proof (prove)\nusing this:\n  v \\<noteq> inversion v\n  \\<lbrakk>u \\<noteq> inversion v; u \\<noteq> v;\n   inversion v \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       u \\<in> circline_set H \\<and>\n                       inversion v \\<in> circline_set H \\<and>\n                       v \\<in> circline_set H\n  u \\<noteq> v\n  u \\<noteq> inversion v\n  is_poincare_line l1\n  is_poincare_line l2\n  {u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\n  \\<lbrakk>is_poincare_line ?H; ?u \\<in> circline_set ?H\\<rbrakk>\n  \\<Longrightarrow> inversion ?u \\<in> circline_set ?H\n\ngoal (1 subgoal):\n 1. l1 = l2", "by force"], ["proof (state)\nthis:\n  l1 = l2\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> inversion v \\<Longrightarrow> l1 = l2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> inversion v \\<Longrightarrow> l1 = l2", "case False"], ["proof (state)\nthis:\n  \\<not> v \\<noteq> inversion v\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> inversion v \\<Longrightarrow> l1 = l2", "have \"on_circline unit_circle u\" \"on_circline unit_circle v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. on_circline unit_circle u &&& on_circline unit_circle v", "using \\<open>\\<not> u \\<noteq> inversion u\\<close> \\<open>\\<not> v \\<noteq> inversion v\\<close>"], ["proof (prove)\nusing this:\n  \\<not> u \\<noteq> inversion u\n  \\<not> v \\<noteq> inversion v\n\ngoal (1 subgoal):\n 1. on_circline unit_circle u &&& on_circline unit_circle v", "using inversion_id_iff_on_unit_circle"], ["proof (prove)\nusing this:\n  \\<not> u \\<noteq> inversion u\n  \\<not> v \\<noteq> inversion v\n  (inversion ?a = ?a) = on_circline unit_circle ?a\n\ngoal (1 subgoal):\n 1. on_circline unit_circle u &&& on_circline unit_circle v", "by fastforce+"], ["proof (state)\nthis:\n  on_circline unit_circle u\n  on_circline unit_circle v\n\ngoal (1 subgoal):\n 1. \\<not> v \\<noteq> inversion v \\<Longrightarrow> l1 = l2", "thus ?thesis"], ["proof (prove)\nusing this:\n  on_circline unit_circle u\n  on_circline unit_circle v\n\ngoal (1 subgoal):\n 1. l1 = l2", "using pl on_l \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  on_circline unit_circle u\n  on_circline unit_circle v\n  is_poincare_line l1\n  is_poincare_line l2\n  {u, v} \\<subseteq> circline_set l1 \\<inter> circline_set l2\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. l1 = l2", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  on_circline unit_circle u\n  on_circline unit_circle v\n  is_poincare_line l1\n  is_poincare_line l2\n  {u, v}\n  \\<subseteq> Collect (on_circline l1) \\<inter> Collect (on_circline l2)\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. l1 = l2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>on_circline unit_circle u; on_circline unit_circle v;\n     is_poincare_line l1; is_poincare_line l2;\n     on_circline l1 u \\<and>\n     on_circline l1 v \\<and> on_circline l2 u \\<and> on_circline l2 v;\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> l1 = l2", "proof (transfer, transfer, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "fix u1 u2 v1 v2 A1 B1 C1 D1 A2 B2 C2 D2 :: complex"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "let ?u = \"(u1, u2)\" and ?v = \"(v1, v2)\" and  ?H1 = \"(A1, B1, C1, D1)\" and ?H2 = \"(A2, B2, C2, D2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "assume *: \"?u \\<noteq> vec_zero\" \"?v \\<noteq> vec_zero\"\n        \"on_circline_cmat_cvec unit_circle_cmat ?u\" \"on_circline_cmat_cvec unit_circle_cmat ?v\" \n        \"is_poincare_line_cmat ?H1\" \"is_poincare_line_cmat ?H2\"\n        \"hermitean ?H1\" \"?H1 \\<noteq> mat_zero\" \"hermitean ?H2\" \"?H2 \\<noteq> mat_zero\"\n        \"on_circline_cmat_cvec ?H1 ?u\" \"on_circline_cmat_cvec ?H1 ?v\"\n        \"on_circline_cmat_cvec ?H2 ?u\" \"on_circline_cmat_cvec ?H2 ?v\"\n        \"\\<not> (u1, u2) \\<approx>\\<^sub>v (v1, v2)\""], ["proof (state)\nthis:\n  (u1, u2) \\<noteq> vec_zero\n  (v1, v2) \\<noteq> vec_zero\n  on_circline_cmat_cvec unit_circle_cmat (u1, u2)\n  on_circline_cmat_cvec unit_circle_cmat (v1, v2)\n  is_poincare_line_cmat (A1, B1, C1, D1)\n  is_poincare_line_cmat (A2, B2, C2, D2)\n  hermitean (A1, B1, C1, D1)\n  (A1, B1, C1, D1) \\<noteq> mat_zero\n  hermitean (A2, B2, C2, D2)\n  (A2, B2, C2, D2) \\<noteq> mat_zero\n  on_circline_cmat_cvec (A1, B1, C1, D1) (u1, u2)\n  on_circline_cmat_cvec (A1, B1, C1, D1) (v1, v2)\n  on_circline_cmat_cvec (A2, B2, C2, D2) (u1, u2)\n  on_circline_cmat_cvec (A2, B2, C2, D2) (v1, v2)\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (v1, v2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "have **: \"A1 = D1\" \"A2 = D2\" \"C1 = cnj B1\" \"C2 = cnj B2\" \"is_real A1\" \"is_real A2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A1 = D1 &&& A2 = D2 &&& C1 = cnj B1) &&&\n    C2 = cnj B2 &&& is_real A1 &&& is_real A2", "using \\<open>is_poincare_line_cmat ?H1\\<close> \\<open>is_poincare_line_cmat ?H2\\<close>"], ["proof (prove)\nusing this:\n  is_poincare_line_cmat (A1, B1, C1, D1)\n  is_poincare_line_cmat (A2, B2, C2, D2)\n\ngoal (1 subgoal):\n 1. (A1 = D1 &&& A2 = D2 &&& C1 = cnj B1) &&&\n    C2 = cnj B2 &&& is_real A1 &&& is_real A2", "using \\<open>hermitean ?H1\\<close> \\<open>?H1 \\<noteq> mat_zero\\<close> \\<open>hermitean ?H2\\<close> \\<open>?H2 \\<noteq> mat_zero\\<close>"], ["proof (prove)\nusing this:\n  is_poincare_line_cmat (A1, B1, C1, D1)\n  is_poincare_line_cmat (A2, B2, C2, D2)\n  hermitean (A1, B1, C1, D1)\n  (A1, B1, C1, D1) \\<noteq> mat_zero\n  hermitean (A2, B2, C2, D2)\n  (A2, B2, C2, D2) \\<noteq> mat_zero\n\ngoal (1 subgoal):\n 1. (A1 = D1 &&& A2 = D2 &&& C1 = cnj B1) &&&\n    C2 = cnj B2 &&& is_real A1 &&& is_real A2", "using hermitean_elems"], ["proof (prove)\nusing this:\n  is_poincare_line_cmat (A1, B1, C1, D1)\n  is_poincare_line_cmat (A2, B2, C2, D2)\n  hermitean (A1, B1, C1, D1)\n  (A1, B1, C1, D1) \\<noteq> mat_zero\n  hermitean (A2, B2, C2, D2)\n  (A2, B2, C2, D2) \\<noteq> mat_zero\n  hermitean (?A, ?B, ?C, ?D) \\<Longrightarrow> is_real ?A\n  hermitean (?A, ?B, ?C, ?D) \\<Longrightarrow> is_real ?D\n  hermitean (?A, ?B, ?C, ?D) \\<Longrightarrow> ?B = cnj ?C\n  hermitean (?A, ?B, ?C, ?D) \\<Longrightarrow> cnj ?B = ?C\n\ngoal (1 subgoal):\n 1. (A1 = D1 &&& A2 = D2 &&& C1 = cnj B1) &&&\n    C2 = cnj B2 &&& is_real A1 &&& is_real A2", "by auto"], ["proof (state)\nthis:\n  A1 = D1\n  A2 = D2\n  C1 = cnj B1\n  C2 = cnj B2\n  is_real A1\n  is_real A2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "have uv: \"u1 \\<noteq> 0\" \"u2 \\<noteq> 0\" \"v1 \\<noteq> 0\" \"v2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u1 \\<noteq> 0 &&& u2 \\<noteq> 0) &&& v1 \\<noteq> 0 &&& v2 \\<noteq> 0", "using *(1-4)"], ["proof (prove)\nusing this:\n  (u1, u2) \\<noteq> vec_zero\n  (v1, v2) \\<noteq> vec_zero\n  on_circline_cmat_cvec unit_circle_cmat (u1, u2)\n  on_circline_cmat_cvec unit_circle_cmat (v1, v2)\n\ngoal (1 subgoal):\n 1. (u1 \\<noteq> 0 &&& u2 \\<noteq> 0) &&& v1 \\<noteq> 0 &&& v2 \\<noteq> 0", "by (auto simp add: vec_cnj_def)"], ["proof (state)\nthis:\n  u1 \\<noteq> 0\n  u2 \\<noteq> 0\n  v1 \\<noteq> 0\n  v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "have u: \"cor ((Re (u1/u2))\\<^sup>2) + cor ((Im (u1/u2))\\<^sup>2) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) = 1", "using \\<open>on_circline_cmat_cvec unit_circle_cmat ?u\\<close> uv"], ["proof (prove)\nusing this:\n  on_circline_cmat_cvec unit_circle_cmat (u1, u2)\n  u1 \\<noteq> 0\n  u2 \\<noteq> 0\n  v1 \\<noteq> 0\n  v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) = 1", "apply (subst cor_add[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>on_circline_cmat_cvec unit_circle_cmat (u1, u2); u1 \\<noteq> 0;\n     u2 \\<noteq> 0; v1 \\<noteq> 0; v2 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cor ((Re (u1 / u2))\\<^sup>2 +\n                           (Im (u1 / u2))\\<^sup>2) =\n                      1", "apply (subst complex_mult_cnj[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>on_circline_cmat_cvec unit_circle_cmat (u1, u2); u1 \\<noteq> 0;\n     u2 \\<noteq> 0; v1 \\<noteq> 0; v2 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> u1 / u2 * cnj (u1 / u2) = 1", "apply (simp add: vec_cnj_def mult.commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "have v: \"cor ((Re (v1/v2))\\<^sup>2) + cor ((Im (v1/v2))\\<^sup>2) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) = 1", "using \\<open>on_circline_cmat_cvec unit_circle_cmat ?v\\<close> uv"], ["proof (prove)\nusing this:\n  on_circline_cmat_cvec unit_circle_cmat (v1, v2)\n  u1 \\<noteq> 0\n  u2 \\<noteq> 0\n  v1 \\<noteq> 0\n  v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) = 1", "apply (subst cor_add[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>on_circline_cmat_cvec unit_circle_cmat (v1, v2); u1 \\<noteq> 0;\n     u2 \\<noteq> 0; v1 \\<noteq> 0; v2 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cor ((Re (v1 / v2))\\<^sup>2 +\n                           (Im (v1 / v2))\\<^sup>2) =\n                      1", "apply (subst complex_mult_cnj[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>on_circline_cmat_cvec unit_circle_cmat (v1, v2); u1 \\<noteq> 0;\n     u2 \\<noteq> 0; v1 \\<noteq> 0; v2 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> v1 / v2 * cnj (v1 / v2) = 1", "apply (simp add: vec_cnj_def mult.commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "have \n        \"A1 * (cor ((Re (u1/u2))\\<^sup>2) + cor ((Im (u1/u2))\\<^sup>2) + 1) + cor (Re B1) * cor(2 * Re (u1/u2)) + cor (Im B1) * cor(2 * Im (u1/u2)) = 0\"\n        \"A2 * (cor ((Re (u1/u2))\\<^sup>2) + cor ((Im (u1/u2))\\<^sup>2) + 1) + cor (Re B2) * cor(2 * Re (u1/u2)) + cor (Im B2) * cor(2 * Im (u1/u2)) = 0\"\n        \"A1 * (cor ((Re (v1/v2))\\<^sup>2) + cor ((Im (v1/v2))\\<^sup>2) + 1) + cor (Re B1) * cor(2 * Re (v1/v2)) + cor (Im B1) * cor(2 * Im (v1/v2)) = 0\"\n        \"A2 * (cor ((Re (v1/v2))\\<^sup>2) + cor ((Im (v1/v2))\\<^sup>2) + 1) + cor (Re B2) * cor(2 * Re (v1/v2)) + cor (Im B2) * cor(2 * Im (v1/v2)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A1 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B1) * cor (2 * Re (u1 / u2)) +\n     cor (Im B1) * cor (2 * Im (u1 / u2)) =\n     0 &&&\n     A2 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B2) * cor (2 * Re (u1 / u2)) +\n     cor (Im B2) * cor (2 * Im (u1 / u2)) =\n     0) &&&\n    A1 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B1) * cor (2 * Re (v1 / v2)) +\n    cor (Im B1) * cor (2 * Im (v1 / v2)) =\n    0 &&&\n    A2 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B2) * cor (2 * Re (v1 / v2)) +\n    cor (Im B2) * cor (2 * Im (v1 / v2)) =\n    0", "using circline_equation_quadratic_equation[of A1 \"u1/u2\" B1 D1 \"Re (u1/u2)\" \"Im (u1 / u2)\" \"Re B1\" \"Im B1\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>circline_equation A1 B1 (cnj B1) D1 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B1 = Re B1;\n   Im B1 = Im B1\\<rbrakk>\n  \\<Longrightarrow> A1 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A1 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B1 * Re (u1 / u2)) +\n                    cor (2 * Im B1 * Im (u1 / u2)) +\n                    D1 =\n                    0\n\ngoal (1 subgoal):\n 1. (A1 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B1) * cor (2 * Re (u1 / u2)) +\n     cor (Im B1) * cor (2 * Im (u1 / u2)) =\n     0 &&&\n     A2 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B2) * cor (2 * Re (u1 / u2)) +\n     cor (Im B2) * cor (2 * Im (u1 / u2)) =\n     0) &&&\n    A1 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B1) * cor (2 * Re (v1 / v2)) +\n    cor (Im B1) * cor (2 * Im (v1 / v2)) =\n    0 &&&\n    A2 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B2) * cor (2 * Re (v1 / v2)) +\n    cor (Im B2) * cor (2 * Im (v1 / v2)) =\n    0", "using circline_equation_quadratic_equation[of A2 \"u1/u2\" B2 D2 \"Re (u1/u2)\" \"Im (u1 / u2)\" \"Re B2\" \"Im B2\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>circline_equation A1 B1 (cnj B1) D1 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B1 = Re B1;\n   Im B1 = Im B1\\<rbrakk>\n  \\<Longrightarrow> A1 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A1 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B1 * Re (u1 / u2)) +\n                    cor (2 * Im B1 * Im (u1 / u2)) +\n                    D1 =\n                    0\n  \\<lbrakk>circline_equation A2 B2 (cnj B2) D2 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B2 = Re B2;\n   Im B2 = Im B2\\<rbrakk>\n  \\<Longrightarrow> A2 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A2 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B2 * Re (u1 / u2)) +\n                    cor (2 * Im B2 * Im (u1 / u2)) +\n                    D2 =\n                    0\n\ngoal (1 subgoal):\n 1. (A1 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B1) * cor (2 * Re (u1 / u2)) +\n     cor (Im B1) * cor (2 * Im (u1 / u2)) =\n     0 &&&\n     A2 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B2) * cor (2 * Re (u1 / u2)) +\n     cor (Im B2) * cor (2 * Im (u1 / u2)) =\n     0) &&&\n    A1 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B1) * cor (2 * Re (v1 / v2)) +\n    cor (Im B1) * cor (2 * Im (v1 / v2)) =\n    0 &&&\n    A2 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B2) * cor (2 * Re (v1 / v2)) +\n    cor (Im B2) * cor (2 * Im (v1 / v2)) =\n    0", "using circline_equation_quadratic_equation[of A1 \"v1/v2\" B1 D1 \"Re (v1/v2)\" \"Im (v1 / v2)\" \"Re B1\" \"Im B1\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>circline_equation A1 B1 (cnj B1) D1 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B1 = Re B1;\n   Im B1 = Im B1\\<rbrakk>\n  \\<Longrightarrow> A1 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A1 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B1 * Re (u1 / u2)) +\n                    cor (2 * Im B1 * Im (u1 / u2)) +\n                    D1 =\n                    0\n  \\<lbrakk>circline_equation A2 B2 (cnj B2) D2 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B2 = Re B2;\n   Im B2 = Im B2\\<rbrakk>\n  \\<Longrightarrow> A2 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A2 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B2 * Re (u1 / u2)) +\n                    cor (2 * Im B2 * Im (u1 / u2)) +\n                    D2 =\n                    0\n  \\<lbrakk>circline_equation A1 B1 (cnj B1) D1 (v1 / v2) 1;\n   Re (v1 / v2) = Re (v1 / v2); Im (v1 / v2) = Im (v1 / v2); Re B1 = Re B1;\n   Im B1 = Im B1\\<rbrakk>\n  \\<Longrightarrow> A1 * cor ((Re (v1 / v2))\\<^sup>2) +\n                    A1 * cor ((Im (v1 / v2))\\<^sup>2) +\n                    cor (2 * Re B1 * Re (v1 / v2)) +\n                    cor (2 * Im B1 * Im (v1 / v2)) +\n                    D1 =\n                    0\n\ngoal (1 subgoal):\n 1. (A1 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B1) * cor (2 * Re (u1 / u2)) +\n     cor (Im B1) * cor (2 * Im (u1 / u2)) =\n     0 &&&\n     A2 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B2) * cor (2 * Re (u1 / u2)) +\n     cor (Im B2) * cor (2 * Im (u1 / u2)) =\n     0) &&&\n    A1 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B1) * cor (2 * Re (v1 / v2)) +\n    cor (Im B1) * cor (2 * Im (v1 / v2)) =\n    0 &&&\n    A2 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B2) * cor (2 * Re (v1 / v2)) +\n    cor (Im B2) * cor (2 * Im (v1 / v2)) =\n    0", "using circline_equation_quadratic_equation[of A2 \"v1/v2\" B2 D2 \"Re (v1/v2)\" \"Im (v1 / v2)\" \"Re B2\" \"Im B2\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>circline_equation A1 B1 (cnj B1) D1 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B1 = Re B1;\n   Im B1 = Im B1\\<rbrakk>\n  \\<Longrightarrow> A1 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A1 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B1 * Re (u1 / u2)) +\n                    cor (2 * Im B1 * Im (u1 / u2)) +\n                    D1 =\n                    0\n  \\<lbrakk>circline_equation A2 B2 (cnj B2) D2 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B2 = Re B2;\n   Im B2 = Im B2\\<rbrakk>\n  \\<Longrightarrow> A2 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A2 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B2 * Re (u1 / u2)) +\n                    cor (2 * Im B2 * Im (u1 / u2)) +\n                    D2 =\n                    0\n  \\<lbrakk>circline_equation A1 B1 (cnj B1) D1 (v1 / v2) 1;\n   Re (v1 / v2) = Re (v1 / v2); Im (v1 / v2) = Im (v1 / v2); Re B1 = Re B1;\n   Im B1 = Im B1\\<rbrakk>\n  \\<Longrightarrow> A1 * cor ((Re (v1 / v2))\\<^sup>2) +\n                    A1 * cor ((Im (v1 / v2))\\<^sup>2) +\n                    cor (2 * Re B1 * Re (v1 / v2)) +\n                    cor (2 * Im B1 * Im (v1 / v2)) +\n                    D1 =\n                    0\n  \\<lbrakk>circline_equation A2 B2 (cnj B2) D2 (v1 / v2) 1;\n   Re (v1 / v2) = Re (v1 / v2); Im (v1 / v2) = Im (v1 / v2); Re B2 = Re B2;\n   Im B2 = Im B2\\<rbrakk>\n  \\<Longrightarrow> A2 * cor ((Re (v1 / v2))\\<^sup>2) +\n                    A2 * cor ((Im (v1 / v2))\\<^sup>2) +\n                    cor (2 * Re B2 * Re (v1 / v2)) +\n                    cor (2 * Im B2 * Im (v1 / v2)) +\n                    D2 =\n                    0\n\ngoal (1 subgoal):\n 1. (A1 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B1) * cor (2 * Re (u1 / u2)) +\n     cor (Im B1) * cor (2 * Im (u1 / u2)) =\n     0 &&&\n     A2 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B2) * cor (2 * Re (u1 / u2)) +\n     cor (Im B2) * cor (2 * Im (u1 / u2)) =\n     0) &&&\n    A1 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B1) * cor (2 * Re (v1 / v2)) +\n    cor (Im B1) * cor (2 * Im (v1 / v2)) =\n    0 &&&\n    A2 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B2) * cor (2 * Re (v1 / v2)) +\n    cor (Im B2) * cor (2 * Im (v1 / v2)) =\n    0", "using \\<open>on_circline_cmat_cvec ?H1 ?u\\<close> \\<open>on_circline_cmat_cvec ?H2 ?u\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>circline_equation A1 B1 (cnj B1) D1 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B1 = Re B1;\n   Im B1 = Im B1\\<rbrakk>\n  \\<Longrightarrow> A1 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A1 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B1 * Re (u1 / u2)) +\n                    cor (2 * Im B1 * Im (u1 / u2)) +\n                    D1 =\n                    0\n  \\<lbrakk>circline_equation A2 B2 (cnj B2) D2 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B2 = Re B2;\n   Im B2 = Im B2\\<rbrakk>\n  \\<Longrightarrow> A2 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A2 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B2 * Re (u1 / u2)) +\n                    cor (2 * Im B2 * Im (u1 / u2)) +\n                    D2 =\n                    0\n  \\<lbrakk>circline_equation A1 B1 (cnj B1) D1 (v1 / v2) 1;\n   Re (v1 / v2) = Re (v1 / v2); Im (v1 / v2) = Im (v1 / v2); Re B1 = Re B1;\n   Im B1 = Im B1\\<rbrakk>\n  \\<Longrightarrow> A1 * cor ((Re (v1 / v2))\\<^sup>2) +\n                    A1 * cor ((Im (v1 / v2))\\<^sup>2) +\n                    cor (2 * Re B1 * Re (v1 / v2)) +\n                    cor (2 * Im B1 * Im (v1 / v2)) +\n                    D1 =\n                    0\n  \\<lbrakk>circline_equation A2 B2 (cnj B2) D2 (v1 / v2) 1;\n   Re (v1 / v2) = Re (v1 / v2); Im (v1 / v2) = Im (v1 / v2); Re B2 = Re B2;\n   Im B2 = Im B2\\<rbrakk>\n  \\<Longrightarrow> A2 * cor ((Re (v1 / v2))\\<^sup>2) +\n                    A2 * cor ((Im (v1 / v2))\\<^sup>2) +\n                    cor (2 * Re B2 * Re (v1 / v2)) +\n                    cor (2 * Im B2 * Im (v1 / v2)) +\n                    D2 =\n                    0\n  on_circline_cmat_cvec (A1, B1, C1, D1) (u1, u2)\n  on_circline_cmat_cvec (A2, B2, C2, D2) (u1, u2)\n\ngoal (1 subgoal):\n 1. (A1 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B1) * cor (2 * Re (u1 / u2)) +\n     cor (Im B1) * cor (2 * Im (u1 / u2)) =\n     0 &&&\n     A2 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B2) * cor (2 * Re (u1 / u2)) +\n     cor (Im B2) * cor (2 * Im (u1 / u2)) =\n     0) &&&\n    A1 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B1) * cor (2 * Re (v1 / v2)) +\n    cor (Im B1) * cor (2 * Im (v1 / v2)) =\n    0 &&&\n    A2 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B2) * cor (2 * Re (v1 / v2)) +\n    cor (Im B2) * cor (2 * Im (v1 / v2)) =\n    0", "using \\<open>on_circline_cmat_cvec ?H1 ?v\\<close> \\<open>on_circline_cmat_cvec ?H2 ?v\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>circline_equation A1 B1 (cnj B1) D1 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B1 = Re B1;\n   Im B1 = Im B1\\<rbrakk>\n  \\<Longrightarrow> A1 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A1 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B1 * Re (u1 / u2)) +\n                    cor (2 * Im B1 * Im (u1 / u2)) +\n                    D1 =\n                    0\n  \\<lbrakk>circline_equation A2 B2 (cnj B2) D2 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B2 = Re B2;\n   Im B2 = Im B2\\<rbrakk>\n  \\<Longrightarrow> A2 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A2 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B2 * Re (u1 / u2)) +\n                    cor (2 * Im B2 * Im (u1 / u2)) +\n                    D2 =\n                    0\n  \\<lbrakk>circline_equation A1 B1 (cnj B1) D1 (v1 / v2) 1;\n   Re (v1 / v2) = Re (v1 / v2); Im (v1 / v2) = Im (v1 / v2); Re B1 = Re B1;\n   Im B1 = Im B1\\<rbrakk>\n  \\<Longrightarrow> A1 * cor ((Re (v1 / v2))\\<^sup>2) +\n                    A1 * cor ((Im (v1 / v2))\\<^sup>2) +\n                    cor (2 * Re B1 * Re (v1 / v2)) +\n                    cor (2 * Im B1 * Im (v1 / v2)) +\n                    D1 =\n                    0\n  \\<lbrakk>circline_equation A2 B2 (cnj B2) D2 (v1 / v2) 1;\n   Re (v1 / v2) = Re (v1 / v2); Im (v1 / v2) = Im (v1 / v2); Re B2 = Re B2;\n   Im B2 = Im B2\\<rbrakk>\n  \\<Longrightarrow> A2 * cor ((Re (v1 / v2))\\<^sup>2) +\n                    A2 * cor ((Im (v1 / v2))\\<^sup>2) +\n                    cor (2 * Re B2 * Re (v1 / v2)) +\n                    cor (2 * Im B2 * Im (v1 / v2)) +\n                    D2 =\n                    0\n  on_circline_cmat_cvec (A1, B1, C1, D1) (u1, u2)\n  on_circline_cmat_cvec (A2, B2, C2, D2) (u1, u2)\n  on_circline_cmat_cvec (A1, B1, C1, D1) (v1, v2)\n  on_circline_cmat_cvec (A2, B2, C2, D2) (v1, v2)\n\ngoal (1 subgoal):\n 1. (A1 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B1) * cor (2 * Re (u1 / u2)) +\n     cor (Im B1) * cor (2 * Im (u1 / u2)) =\n     0 &&&\n     A2 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B2) * cor (2 * Re (u1 / u2)) +\n     cor (Im B2) * cor (2 * Im (u1 / u2)) =\n     0) &&&\n    A1 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B1) * cor (2 * Re (v1 / v2)) +\n    cor (Im B1) * cor (2 * Im (v1 / v2)) =\n    0 &&&\n    A2 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B2) * cor (2 * Re (v1 / v2)) +\n    cor (Im B2) * cor (2 * Im (v1 / v2)) =\n    0", "using ** uv"], ["proof (prove)\nusing this:\n  \\<lbrakk>circline_equation A1 B1 (cnj B1) D1 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B1 = Re B1;\n   Im B1 = Im B1\\<rbrakk>\n  \\<Longrightarrow> A1 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A1 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B1 * Re (u1 / u2)) +\n                    cor (2 * Im B1 * Im (u1 / u2)) +\n                    D1 =\n                    0\n  \\<lbrakk>circline_equation A2 B2 (cnj B2) D2 (u1 / u2) 1;\n   Re (u1 / u2) = Re (u1 / u2); Im (u1 / u2) = Im (u1 / u2); Re B2 = Re B2;\n   Im B2 = Im B2\\<rbrakk>\n  \\<Longrightarrow> A2 * cor ((Re (u1 / u2))\\<^sup>2) +\n                    A2 * cor ((Im (u1 / u2))\\<^sup>2) +\n                    cor (2 * Re B2 * Re (u1 / u2)) +\n                    cor (2 * Im B2 * Im (u1 / u2)) +\n                    D2 =\n                    0\n  \\<lbrakk>circline_equation A1 B1 (cnj B1) D1 (v1 / v2) 1;\n   Re (v1 / v2) = Re (v1 / v2); Im (v1 / v2) = Im (v1 / v2); Re B1 = Re B1;\n   Im B1 = Im B1\\<rbrakk>\n  \\<Longrightarrow> A1 * cor ((Re (v1 / v2))\\<^sup>2) +\n                    A1 * cor ((Im (v1 / v2))\\<^sup>2) +\n                    cor (2 * Re B1 * Re (v1 / v2)) +\n                    cor (2 * Im B1 * Im (v1 / v2)) +\n                    D1 =\n                    0\n  \\<lbrakk>circline_equation A2 B2 (cnj B2) D2 (v1 / v2) 1;\n   Re (v1 / v2) = Re (v1 / v2); Im (v1 / v2) = Im (v1 / v2); Re B2 = Re B2;\n   Im B2 = Im B2\\<rbrakk>\n  \\<Longrightarrow> A2 * cor ((Re (v1 / v2))\\<^sup>2) +\n                    A2 * cor ((Im (v1 / v2))\\<^sup>2) +\n                    cor (2 * Re B2 * Re (v1 / v2)) +\n                    cor (2 * Im B2 * Im (v1 / v2)) +\n                    D2 =\n                    0\n  on_circline_cmat_cvec (A1, B1, C1, D1) (u1, u2)\n  on_circline_cmat_cvec (A2, B2, C2, D2) (u1, u2)\n  on_circline_cmat_cvec (A1, B1, C1, D1) (v1, v2)\n  on_circline_cmat_cvec (A2, B2, C2, D2) (v1, v2)\n  A1 = D1\n  A2 = D2\n  C1 = cnj B1\n  C2 = cnj B2\n  is_real A1\n  is_real A2\n  u1 \\<noteq> 0\n  u2 \\<noteq> 0\n  v1 \\<noteq> 0\n  v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (A1 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B1) * cor (2 * Re (u1 / u2)) +\n     cor (Im B1) * cor (2 * Im (u1 / u2)) =\n     0 &&&\n     A2 *\n     (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n     cor (Re B2) * cor (2 * Re (u1 / u2)) +\n     cor (Im B2) * cor (2 * Im (u1 / u2)) =\n     0) &&&\n    A1 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B1) * cor (2 * Re (v1 / v2)) +\n    cor (Im B1) * cor (2 * Im (v1 / v2)) =\n    0 &&&\n    A2 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n    cor (Re B2) * cor (2 * Re (v1 / v2)) +\n    cor (Im B2) * cor (2 * Im (v1 / v2)) =\n    0", "by (simp_all add: vec_cnj_def field_simps)"], ["proof (state)\nthis:\n  A1 * (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n  cor (Re B1) * cor (2 * Re (u1 / u2)) +\n  cor (Im B1) * cor (2 * Im (u1 / u2)) =\n  0\n  A2 * (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n  cor (Re B2) * cor (2 * Re (u1 / u2)) +\n  cor (Im B2) * cor (2 * Im (u1 / u2)) =\n  0\n  A1 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n  cor (Re B1) * cor (2 * Re (v1 / v2)) +\n  cor (Im B1) * cor (2 * Im (v1 / v2)) =\n  0\n  A2 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n  cor (Re B2) * cor (2 * Re (v1 / v2)) +\n  cor (Im B2) * cor (2 * Im (v1 / v2)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "hence\n        \"A1 + cor (Re B1) * cor(Re (u1/u2)) + cor (Im B1) * cor(Im (u1/u2)) = 0\"\n        \"A1 + cor (Re B1) * cor(Re (v1/v2)) + cor (Im B1) * cor(Im (v1/v2)) = 0\"\n        \"A2 + cor (Re B2) * cor(Re (u1/u2)) + cor (Im B2) * cor(Im (u1/u2)) = 0\"\n        \"A2 + cor (Re B2) * cor(Re (v1/v2)) + cor (Im B2) * cor(Im (v1/v2)) = 0\""], ["proof (prove)\nusing this:\n  A1 * (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n  cor (Re B1) * cor (2 * Re (u1 / u2)) +\n  cor (Im B1) * cor (2 * Im (u1 / u2)) =\n  0\n  A2 * (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n  cor (Re B2) * cor (2 * Re (u1 / u2)) +\n  cor (Im B2) * cor (2 * Im (u1 / u2)) =\n  0\n  A1 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n  cor (Re B1) * cor (2 * Re (v1 / v2)) +\n  cor (Im B1) * cor (2 * Im (v1 / v2)) =\n  0\n  A2 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n  cor (Re B2) * cor (2 * Re (v1 / v2)) +\n  cor (Im B2) * cor (2 * Im (v1 / v2)) =\n  0\n\ngoal (1 subgoal):\n 1. (A1 + cor (Re B1) * cor (Re (u1 / u2)) +\n     cor (Im B1) * cor (Im (u1 / u2)) =\n     0 &&&\n     A1 + cor (Re B1) * cor (Re (v1 / v2)) +\n     cor (Im B1) * cor (Im (v1 / v2)) =\n     0) &&&\n    A2 + cor (Re B2) * cor (Re (u1 / u2)) +\n    cor (Im B2) * cor (Im (u1 / u2)) =\n    0 &&&\n    A2 + cor (Re B2) * cor (Re (v1 / v2)) +\n    cor (Im B2) * cor (Im (v1 / v2)) =\n    0", "using u v"], ["proof (prove)\nusing this:\n  A1 * (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n  cor (Re B1) * cor (2 * Re (u1 / u2)) +\n  cor (Im B1) * cor (2 * Im (u1 / u2)) =\n  0\n  A2 * (cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) + 1) +\n  cor (Re B2) * cor (2 * Re (u1 / u2)) +\n  cor (Im B2) * cor (2 * Im (u1 / u2)) =\n  0\n  A1 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n  cor (Re B1) * cor (2 * Re (v1 / v2)) +\n  cor (Im B1) * cor (2 * Im (v1 / v2)) =\n  0\n  A2 * (cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) + 1) +\n  cor (Re B2) * cor (2 * Re (v1 / v2)) +\n  cor (Im B2) * cor (2 * Im (v1 / v2)) =\n  0\n  cor ((Re (u1 / u2))\\<^sup>2) + cor ((Im (u1 / u2))\\<^sup>2) = 1\n  cor ((Re (v1 / v2))\\<^sup>2) + cor ((Im (v1 / v2))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. (A1 + cor (Re B1) * cor (Re (u1 / u2)) +\n     cor (Im B1) * cor (Im (u1 / u2)) =\n     0 &&&\n     A1 + cor (Re B1) * cor (Re (v1 / v2)) +\n     cor (Im B1) * cor (Im (v1 / v2)) =\n     0) &&&\n    A2 + cor (Re B2) * cor (Re (u1 / u2)) +\n    cor (Im B2) * cor (Im (u1 / u2)) =\n    0 &&&\n    A2 + cor (Re B2) * cor (Re (v1 / v2)) +\n    cor (Im B2) * cor (Im (v1 / v2)) =\n    0", "by simp_all algebra+"], ["proof (state)\nthis:\n  A1 + cor (Re B1) * cor (Re (u1 / u2)) + cor (Im B1) * cor (Im (u1 / u2)) =\n  0\n  A1 + cor (Re B1) * cor (Re (v1 / v2)) + cor (Im B1) * cor (Im (v1 / v2)) =\n  0\n  A2 + cor (Re B2) * cor (Re (u1 / u2)) + cor (Im B2) * cor (Im (u1 / u2)) =\n  0\n  A2 + cor (Re B2) * cor (Re (v1 / v2)) + cor (Im B2) * cor (Im (v1 / v2)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "hence \n        \"cor (Re A1 + Re B1 * Re (u1/u2) + Im B1 * Im (u1/u2)) = 0\"\n        \"cor (Re A2 + Re B2 * Re (u1/u2) + Im B2 * Im (u1/u2)) = 0\"\n        \"cor (Re A1 + Re B1 * Re (v1/v2) + Im B1 * Im (v1/v2)) = 0\"\n        \"cor (Re A2 + Re B2 * Re (v1/v2) + Im B2 * Im (v1/v2)) = 0\""], ["proof (prove)\nusing this:\n  A1 + cor (Re B1) * cor (Re (u1 / u2)) + cor (Im B1) * cor (Im (u1 / u2)) =\n  0\n  A1 + cor (Re B1) * cor (Re (v1 / v2)) + cor (Im B1) * cor (Im (v1 / v2)) =\n  0\n  A2 + cor (Re B2) * cor (Re (u1 / u2)) + cor (Im B2) * cor (Im (u1 / u2)) =\n  0\n  A2 + cor (Re B2) * cor (Re (v1 / v2)) + cor (Im B2) * cor (Im (v1 / v2)) =\n  0\n\ngoal (1 subgoal):\n 1. (cor (Re A1 + Re B1 * Re (u1 / u2) + Im B1 * Im (u1 / u2)) = 0 &&&\n     cor (Re A2 + Re B2 * Re (u1 / u2) + Im B2 * Im (u1 / u2)) = 0) &&&\n    cor (Re A1 + Re B1 * Re (v1 / v2) + Im B1 * Im (v1 / v2)) = 0 &&&\n    cor (Re A2 + Re B2 * Re (v1 / v2) + Im B2 * Im (v1 / v2)) = 0", "using \\<open>is_real A1\\<close> \\<open>is_real A2\\<close>"], ["proof (prove)\nusing this:\n  A1 + cor (Re B1) * cor (Re (u1 / u2)) + cor (Im B1) * cor (Im (u1 / u2)) =\n  0\n  A1 + cor (Re B1) * cor (Re (v1 / v2)) + cor (Im B1) * cor (Im (v1 / v2)) =\n  0\n  A2 + cor (Re B2) * cor (Re (u1 / u2)) + cor (Im B2) * cor (Im (u1 / u2)) =\n  0\n  A2 + cor (Re B2) * cor (Re (v1 / v2)) + cor (Im B2) * cor (Im (v1 / v2)) =\n  0\n  is_real A1\n  is_real A2\n\ngoal (1 subgoal):\n 1. (cor (Re A1 + Re B1 * Re (u1 / u2) + Im B1 * Im (u1 / u2)) = 0 &&&\n     cor (Re A2 + Re B2 * Re (u1 / u2) + Im B2 * Im (u1 / u2)) = 0) &&&\n    cor (Re A1 + Re B1 * Re (v1 / v2) + Im B1 * Im (v1 / v2)) = 0 &&&\n    cor (Re A2 + Re B2 * Re (v1 / v2) + Im B2 * Im (v1 / v2)) = 0", "by simp_all"], ["proof (state)\nthis:\n  cor (Re A1 + Re B1 * Re (u1 / u2) + Im B1 * Im (u1 / u2)) = 0\n  cor (Re A2 + Re B2 * Re (u1 / u2) + Im B2 * Im (u1 / u2)) = 0\n  cor (Re A1 + Re B1 * Re (v1 / v2) + Im B1 * Im (v1 / v2)) = 0\n  cor (Re A2 + Re B2 * Re (v1 / v2) + Im B2 * Im (v1 / v2)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "hence \n        \"Re A1 + Re B1 * Re (u1/u2) + Im B1 * Im (u1/u2) = 0\"\n        \"Re A1 + Re B1 * Re (v1/v2) + Im B1 * Im (v1/v2) = 0\"\n        \"Re A2 + Re B2 * Re (u1/u2) + Im B2 * Im (u1/u2) = 0\"\n        \"Re A2 + Re B2 * Re (v1/v2) + Im B2 * Im (v1/v2) = 0\""], ["proof (prove)\nusing this:\n  cor (Re A1 + Re B1 * Re (u1 / u2) + Im B1 * Im (u1 / u2)) = 0\n  cor (Re A2 + Re B2 * Re (u1 / u2) + Im B2 * Im (u1 / u2)) = 0\n  cor (Re A1 + Re B1 * Re (v1 / v2) + Im B1 * Im (v1 / v2)) = 0\n  cor (Re A2 + Re B2 * Re (v1 / v2) + Im B2 * Im (v1 / v2)) = 0\n\ngoal (1 subgoal):\n 1. (Re A1 + Re B1 * Re (u1 / u2) + Im B1 * Im (u1 / u2) = 0 &&&\n     Re A1 + Re B1 * Re (v1 / v2) + Im B1 * Im (v1 / v2) = 0) &&&\n    Re A2 + Re B2 * Re (u1 / u2) + Im B2 * Im (u1 / u2) = 0 &&&\n    Re A2 + Re B2 * Re (v1 / v2) + Im B2 * Im (v1 / v2) = 0", "using of_real_eq_0_iff"], ["proof (prove)\nusing this:\n  cor (Re A1 + Re B1 * Re (u1 / u2) + Im B1 * Im (u1 / u2)) = 0\n  cor (Re A2 + Re B2 * Re (u1 / u2) + Im B2 * Im (u1 / u2)) = 0\n  cor (Re A1 + Re B1 * Re (v1 / v2) + Im B1 * Im (v1 / v2)) = 0\n  cor (Re A2 + Re B2 * Re (v1 / v2) + Im B2 * Im (v1 / v2)) = 0\n  (of_real ?x = (0::?'a)) = (?x = 0)\n\ngoal (1 subgoal):\n 1. (Re A1 + Re B1 * Re (u1 / u2) + Im B1 * Im (u1 / u2) = 0 &&&\n     Re A1 + Re B1 * Re (v1 / v2) + Im B1 * Im (v1 / v2) = 0) &&&\n    Re A2 + Re B2 * Re (u1 / u2) + Im B2 * Im (u1 / u2) = 0 &&&\n    Re A2 + Re B2 * Re (v1 / v2) + Im B2 * Im (v1 / v2) = 0", "by blast+"], ["proof (state)\nthis:\n  Re A1 + Re B1 * Re (u1 / u2) + Im B1 * Im (u1 / u2) = 0\n  Re A1 + Re B1 * Re (v1 / v2) + Im B1 * Im (v1 / v2) = 0\n  Re A2 + Re B2 * Re (u1 / u2) + Im B2 * Im (u1 / u2) = 0\n  Re A2 + Re B2 * Re (v1 / v2) + Im B2 * Im (v1 / v2) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "moreover"], ["proof (state)\nthis:\n  Re A1 + Re B1 * Re (u1 / u2) + Im B1 * Im (u1 / u2) = 0\n  Re A1 + Re B1 * Re (v1 / v2) + Im B1 * Im (v1 / v2) = 0\n  Re A2 + Re B2 * Re (u1 / u2) + Im B2 * Im (u1 / u2) = 0\n  Re A2 + Re B2 * Re (v1 / v2) + Im B2 * Im (v1 / v2) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "have \"Re(u1/u2) \\<noteq> Re(v1/v2) \\<or> Im(u1/u2) \\<noteq> Im(v1/v2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (u1 / u2) \\<noteq> Re (v1 / v2) \\<or>\n    Im (u1 / u2) \\<noteq> Im (v1 / v2)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (Re (u1 / u2) \\<noteq> Re (v1 / v2) \\<or>\n            Im (u1 / u2) \\<noteq> Im (v1 / v2)) \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (Re (u1 / u2) \\<noteq> Re (v1 / v2) \\<or>\n          Im (u1 / u2) \\<noteq> Im (v1 / v2))\n\ngoal (1 subgoal):\n 1. \\<not> (Re (u1 / u2) \\<noteq> Re (v1 / v2) \\<or>\n            Im (u1 / u2) \\<noteq> Im (v1 / v2)) \\<Longrightarrow>\n    False", "hence \"u1/u2 = v1/v2\""], ["proof (prove)\nusing this:\n  \\<not> (Re (u1 / u2) \\<noteq> Re (v1 / v2) \\<or>\n          Im (u1 / u2) \\<noteq> Im (v1 / v2))\n\ngoal (1 subgoal):\n 1. u1 / u2 = v1 / v2", "using complex_eqI"], ["proof (prove)\nusing this:\n  \\<not> (Re (u1 / u2) \\<noteq> Re (v1 / v2) \\<or>\n          Im (u1 / u2) \\<noteq> Im (v1 / v2))\n  \\<lbrakk>Re ?x = Re ?y; Im ?x = Im ?y\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. u1 / u2 = v1 / v2", "by blast"], ["proof (state)\nthis:\n  u1 / u2 = v1 / v2\n\ngoal (1 subgoal):\n 1. \\<not> (Re (u1 / u2) \\<noteq> Re (v1 / v2) \\<or>\n            Im (u1 / u2) \\<noteq> Im (v1 / v2)) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  u1 / u2 = v1 / v2\n\ngoal (1 subgoal):\n 1. False", "using uv \\<open>\\<not> (u1, u2) \\<approx>\\<^sub>v (v1, v2)\\<close>"], ["proof (prove)\nusing this:\n  u1 / u2 = v1 / v2\n  u1 \\<noteq> 0\n  u2 \\<noteq> 0\n  v1 \\<noteq> 0\n  v2 \\<noteq> 0\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (v1, v2)\n\ngoal (1 subgoal):\n 1. False", "using \"*\"(1) \"*\"(2) complex_cvec_eq_mix[OF *(1) *(2)]"], ["proof (prove)\nusing this:\n  u1 / u2 = v1 / v2\n  u1 \\<noteq> 0\n  u2 \\<noteq> 0\n  v1 \\<noteq> 0\n  v2 \\<noteq> 0\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (v1, v2)\n  (u1, u2) \\<noteq> vec_zero\n  (v1, v2) \\<noteq> vec_zero\n  ((u1, u2) \\<approx>\\<^sub>v (v1, v2)) = (u1 * v2 = u2 * v1)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (u1 / u2) \\<noteq> Re (v1 / v2) \\<or>\n  Im (u1 / u2) \\<noteq> Im (v1 / v2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "moreover"], ["proof (state)\nthis:\n  Re (u1 / u2) \\<noteq> Re (v1 / v2) \\<or>\n  Im (u1 / u2) \\<noteq> Im (v1 / v2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "have \"Re A1 \\<noteq> 0 \\<or> Re B1 \\<noteq> 0 \\<or> Im B1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re A1 \\<noteq> 0 \\<or> Re B1 \\<noteq> 0 \\<or> Im B1 \\<noteq> 0", "using \\<open>?H1 \\<noteq> mat_zero\\<close> **"], ["proof (prove)\nusing this:\n  (A1, B1, C1, D1) \\<noteq> mat_zero\n  A1 = D1\n  A2 = D2\n  C1 = cnj B1\n  C2 = cnj B2\n  is_real A1\n  is_real A2\n\ngoal (1 subgoal):\n 1. Re A1 \\<noteq> 0 \\<or> Re B1 \\<noteq> 0 \\<or> Im B1 \\<noteq> 0", "by (metis complex_cnj_zero complex_of_real_Re mat_zero_def of_real_0)"], ["proof (state)\nthis:\n  Re A1 \\<noteq> 0 \\<or> Re B1 \\<noteq> 0 \\<or> Im B1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "ultimately"], ["proof (chain)\npicking this:\n  Re A1 + Re B1 * Re (u1 / u2) + Im B1 * Im (u1 / u2) = 0\n  Re A1 + Re B1 * Re (v1 / v2) + Im B1 * Im (v1 / v2) = 0\n  Re A2 + Re B2 * Re (u1 / u2) + Im B2 * Im (u1 / u2) = 0\n  Re A2 + Re B2 * Re (v1 / v2) + Im B2 * Im (v1 / v2) = 0\n  Re (u1 / u2) \\<noteq> Re (v1 / v2) \\<or>\n  Im (u1 / u2) \\<noteq> Im (v1 / v2)\n  Re A1 \\<noteq> 0 \\<or> Re B1 \\<noteq> 0 \\<or> Im B1 \\<noteq> 0", "obtain k where\n        k: \"Re A2 = k * Re A1\" \"Re B2 = k * Re B1\" \"Im B2 = k * Im B1\""], ["proof (prove)\nusing this:\n  Re A1 + Re B1 * Re (u1 / u2) + Im B1 * Im (u1 / u2) = 0\n  Re A1 + Re B1 * Re (v1 / v2) + Im B1 * Im (v1 / v2) = 0\n  Re A2 + Re B2 * Re (u1 / u2) + Im B2 * Im (u1 / u2) = 0\n  Re A2 + Re B2 * Re (v1 / v2) + Im B2 * Im (v1 / v2) = 0\n  Re (u1 / u2) \\<noteq> Re (v1 / v2) \\<or>\n  Im (u1 / u2) \\<noteq> Im (v1 / v2)\n  Re A1 \\<noteq> 0 \\<or> Re B1 \\<noteq> 0 \\<or> Im B1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>Re A2 = k * Re A1; Re B2 = k * Re B1;\n         Im B2 = k * Im B1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using linear_system_homogenous_3_2[of \"\\<lambda>x y z. 1 * x + Re (u1 / u2) * y + Im (u1 / u2) * z\" 1 \"Re (u1/u2)\" \"Im (u1/u2)\" \n                                              \"\\<lambda>x y z. 1 * x + Re (v1 / v2) * y + Im (v1 / v2) * z\" 1 \"Re (v1/v2)\" \"Im (v1/v2)\"\n                                              \"Re A2\" \"Re B2\" \"Im B2\" \"Re A1\" \"Re B1\" \"Im B1\"]"], ["proof (prove)\nusing this:\n  Re A1 + Re B1 * Re (u1 / u2) + Im B1 * Im (u1 / u2) = 0\n  Re A1 + Re B1 * Re (v1 / v2) + Im B1 * Im (v1 / v2) = 0\n  Re A2 + Re B2 * Re (u1 / u2) + Im B2 * Im (u1 / u2) = 0\n  Re A2 + Re B2 * Re (v1 / v2) + Im B2 * Im (v1 / v2) = 0\n  Re (u1 / u2) \\<noteq> Re (v1 / v2) \\<or>\n  Im (u1 / u2) \\<noteq> Im (v1 / v2)\n  Re A1 \\<noteq> 0 \\<or> Re B1 \\<noteq> 0 \\<or> Im B1 \\<noteq> 0\n  \\<lbrakk>(\\<lambda>x y z. 1 * x + Re (u1 / u2) * y + Im (u1 / u2) * z) =\n           (\\<lambda>x y z. 1 * x + Re (u1 / u2) * y + Im (u1 / u2) * z);\n   (\\<lambda>x y z. 1 * x + Re (v1 / v2) * y + Im (v1 / v2) * z) =\n   (\\<lambda>x y z. 1 * x + Re (v1 / v2) * y + Im (v1 / v2) * z);\n   1 * Re A2 + Re (u1 / u2) * Re B2 + Im (u1 / u2) * Im B2 = 0;\n   1 * Re A2 + Re (v1 / v2) * Re B2 + Im (v1 / v2) * Im B2 = 0;\n   1 * Re A1 + Re (u1 / u2) * Re B1 + Im (u1 / u2) * Im B1 = 0;\n   1 * Re A1 + Re (v1 / v2) * Re B1 + Im (v1 / v2) * Im B1 = 0;\n   Re A1 \\<noteq> 0 \\<or> Re B1 \\<noteq> 0 \\<or> Im B1 \\<noteq> 0;\n   det2 1 (Re (u1 / u2)) 1 (Re (v1 / v2)) \\<noteq> 0 \\<or>\n   det2 1 (Im (u1 / u2)) 1 (Im (v1 / v2)) \\<noteq> 0 \\<or>\n   det2 (Re (u1 / u2)) (Im (u1 / u2)) (Re (v1 / v2)) (Im (v1 / v2)) \\<noteq>\n   0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k.\n                       Re A2 = k * Re A1 \\<and>\n                       Re B2 = k * Re B1 \\<and> Im B2 = k * Im B1\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>Re A2 = k * Re A1; Re B2 = k * Re B1;\n         Im B2 = k * Im B1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  Re A2 = k * Re A1\n  Re B2 = k * Re B1\n  Im B2 = k * Im B1\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "have \"Re A2 \\<noteq> 0 \\<or> Re B2 \\<noteq> 0 \\<or> Im B2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re A2 \\<noteq> 0 \\<or> Re B2 \\<noteq> 0 \\<or> Im B2 \\<noteq> 0", "using \\<open>?H2 \\<noteq> mat_zero\\<close> **"], ["proof (prove)\nusing this:\n  (A2, B2, C2, D2) \\<noteq> mat_zero\n  A1 = D1\n  A2 = D2\n  C1 = cnj B1\n  C2 = cnj B2\n  is_real A1\n  is_real A2\n\ngoal (1 subgoal):\n 1. Re A2 \\<noteq> 0 \\<or> Re B2 \\<noteq> 0 \\<or> Im B2 \\<noteq> 0", "by (metis complex_cnj_zero complex_of_real_Re mat_zero_def of_real_0)"], ["proof (state)\nthis:\n  Re A2 \\<noteq> 0 \\<or> Re B2 \\<noteq> 0 \\<or> Im B2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "hence \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Re A2 \\<noteq> 0 \\<or> Re B2 \\<noteq> 0 \\<or> Im B2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "using k"], ["proof (prove)\nusing this:\n  Re A2 \\<noteq> 0 \\<or> Re B2 \\<noteq> 0 \\<or> Im B2 \\<noteq> 0\n  Re A2 = k * Re A1\n  Re B2 = k * Re B1\n  Im B2 = k * Im B1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab ac ad bb ae af ag bc.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        on_circline_cmat_cvec unit_circle_cmat (a, b);\n        on_circline_cmat_cvec unit_circle_cmat (aa, ba);\n        is_poincare_line_cmat (ab, ac, ad, bb);\n        is_poincare_line_cmat (ae, af, ag, bc);\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        hermitean (ab, ac, ad, bb); (ab, ac, ad, bb) \\<noteq> mat_zero;\n        hermitean (ae, af, ag, bc); (ae, af, ag, bc) \\<noteq> mat_zero;\n        on_circline_cmat_cvec (ab, ac, ad, bb) (a, b);\n        on_circline_cmat_cvec (ab, ac, ad, bb) (aa, ba);\n        on_circline_cmat_cvec (ae, af, ag, bc) (a, b);\n        on_circline_cmat_cvec (ae, af, ag, bc) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat (ab, ac, ad, bb) (ae, af, ag, bc)", "show \"circline_eq_cmat ?H1 ?H2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circline_eq_cmat (A1, B1, C1, D1) (A2, B2, C2, D2)", "using ** k \\<open>k \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  A1 = D1\n  A2 = D2\n  C1 = cnj B1\n  C2 = cnj B2\n  is_real A1\n  is_real A2\n  Re A2 = k * Re A1\n  Re B2 = k * Re B1\n  Im B2 = k * Im B1\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (A1, B1, C1, D1) (A2, B2, C2, D2)", "by (auto simp add: vec_cnj_def) (rule_tac x=\"k\" in exI, auto simp add: complex.expand)"], ["proof (state)\nthis:\n  circline_eq_cmat (A1, B1, C1, D1) (A2, B2, C2, D2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l1 = l2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l1 = l2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The only h-line that goes trough zero and a non-zero point on the x-axis is the x-axis.\\<close>"], ["", "lemma is_poincare_line_0_real_is_x_axis:\n  assumes \"is_poincare_line l\" \"0\\<^sub>h \\<in> circline_set l\"\n    \"x \\<in> circline_set l \\<inter> circline_set x_axis\" \"x \\<noteq> 0\\<^sub>h\" \"x \\<noteq> \\<infinity>\\<^sub>h\"\n  shows \"l = x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = x_axis", "using assms"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  0\\<^sub>h \\<in> circline_set l\n  x \\<in> circline_set l \\<inter> circline_set x_axis\n  x \\<noteq> 0\\<^sub>h\n  x \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. l = x_axis", "using is_poincare_line_trough_zero_trough_infty[OF assms(1-2)]"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  0\\<^sub>h \\<in> circline_set l\n  x \\<in> circline_set l \\<inter> circline_set x_axis\n  x \\<noteq> 0\\<^sub>h\n  x \\<noteq> \\<infinity>\\<^sub>h\n  \\<infinity>\\<^sub>h \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. l = x_axis", "using unique_circline_set[of x \"0\\<^sub>h\" \"\\<infinity>\\<^sub>h\"]"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  0\\<^sub>h \\<in> circline_set l\n  x \\<in> circline_set l \\<inter> circline_set x_axis\n  x \\<noteq> 0\\<^sub>h\n  x \\<noteq> \\<infinity>\\<^sub>h\n  \\<infinity>\\<^sub>h \\<in> circline_set l\n  \\<lbrakk>x \\<noteq> 0\\<^sub>h; x \\<noteq> \\<infinity>\\<^sub>h;\n   0\\<^sub>h \\<noteq> \\<infinity>\\<^sub>h\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       x \\<in> circline_set H \\<and>\n                       0\\<^sub>h \\<in> circline_set H \\<and>\n                       \\<infinity>\\<^sub>h \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. l = x_axis", "by auto"], ["", "text \\<open>The only h-line that goes trough zero and a non-zero point on the y-axis is the y-axis.\\<close>"], ["", "lemma is_poincare_line_0_imag_is_y_axis:\n  assumes \"is_poincare_line l\" \"0\\<^sub>h \\<in> circline_set l\"\n    \"y \\<in> circline_set l \\<inter> circline_set y_axis\" \"y \\<noteq> 0\\<^sub>h\" \"y \\<noteq> \\<infinity>\\<^sub>h\"\n  shows \"l = y_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = y_axis", "using assms"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  0\\<^sub>h \\<in> circline_set l\n  y \\<in> circline_set l \\<inter> circline_set y_axis\n  y \\<noteq> 0\\<^sub>h\n  y \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. l = y_axis", "using is_poincare_line_trough_zero_trough_infty[OF assms(1-2)]"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  0\\<^sub>h \\<in> circline_set l\n  y \\<in> circline_set l \\<inter> circline_set y_axis\n  y \\<noteq> 0\\<^sub>h\n  y \\<noteq> \\<infinity>\\<^sub>h\n  \\<infinity>\\<^sub>h \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. l = y_axis", "using unique_circline_set[of y \"0\\<^sub>h\" \"\\<infinity>\\<^sub>h\"]"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  0\\<^sub>h \\<in> circline_set l\n  y \\<in> circline_set l \\<inter> circline_set y_axis\n  y \\<noteq> 0\\<^sub>h\n  y \\<noteq> \\<infinity>\\<^sub>h\n  \\<infinity>\\<^sub>h \\<in> circline_set l\n  \\<lbrakk>y \\<noteq> 0\\<^sub>h; y \\<noteq> \\<infinity>\\<^sub>h;\n   0\\<^sub>h \\<noteq> \\<infinity>\\<^sub>h\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!H.\n                       y \\<in> circline_set H \\<and>\n                       0\\<^sub>h \\<in> circline_set H \\<and>\n                       \\<infinity>\\<^sub>h \\<in> circline_set H\n\ngoal (1 subgoal):\n 1. l = y_axis", "by auto"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsubsection\\<open>H-isometries preserve h-lines\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "text\\<open>\\emph{H-isometries} are defined as homographies (actions of M?bius transformations) and\nantihomographies (compositions of actions of M?bius transformations with conjugation) that fix the\nunit disc (map it onto itself). They also map h-lines onto h-lines\\<close>"], ["", "text\\<open>We prove a bit more general lemma that states that all M?bius transformations that fix the\nunit circle (not necessary the unit disc) map h-lines onto h-lines\\<close>"], ["", "lemma unit_circle_fix_preserve_is_poincare_line [simp]:\n  assumes \"unit_circle_fix M\" \"is_poincare_line H\"\n  shows \"is_poincare_line (moebius_circline M H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line (moebius_circline M H)", "using assms"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  is_poincare_line H\n\ngoal (1 subgoal):\n 1. is_poincare_line (moebius_circline M H)", "unfolding is_poincare_line_iff"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  circline_type H = - 1 \\<and> perpendicular H unit_circle\n\ngoal (1 subgoal):\n 1. circline_type (moebius_circline M H) = - 1 \\<and>\n    perpendicular (moebius_circline M H) unit_circle", "proof (safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>unit_circle_fix M; circline_type H = - 1;\n     perpendicular H unit_circle\\<rbrakk>\n    \\<Longrightarrow> circline_type (moebius_circline M H) = - 1\n 2. \\<lbrakk>unit_circle_fix M; circline_type H = - 1;\n     perpendicular H unit_circle\\<rbrakk>\n    \\<Longrightarrow> perpendicular (moebius_circline M H) unit_circle", "let ?H' = \"moebius_ocircline M (of_circline H)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>unit_circle_fix M; circline_type H = - 1;\n     perpendicular H unit_circle\\<rbrakk>\n    \\<Longrightarrow> circline_type (moebius_circline M H) = - 1\n 2. \\<lbrakk>unit_circle_fix M; circline_type H = - 1;\n     perpendicular H unit_circle\\<rbrakk>\n    \\<Longrightarrow> perpendicular (moebius_circline M H) unit_circle", "let ?U' = \"moebius_ocircline M ounit_circle\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>unit_circle_fix M; circline_type H = - 1;\n     perpendicular H unit_circle\\<rbrakk>\n    \\<Longrightarrow> circline_type (moebius_circline M H) = - 1\n 2. \\<lbrakk>unit_circle_fix M; circline_type H = - 1;\n     perpendicular H unit_circle\\<rbrakk>\n    \\<Longrightarrow> perpendicular (moebius_circline M H) unit_circle", "assume ++: \"unit_circle_fix M\" \"perpendicular H unit_circle\""], ["proof (state)\nthis:\n  unit_circle_fix M\n  perpendicular H unit_circle\n\ngoal (2 subgoals):\n 1. \\<lbrakk>unit_circle_fix M; circline_type H = - 1;\n     perpendicular H unit_circle\\<rbrakk>\n    \\<Longrightarrow> circline_type (moebius_circline M H) = - 1\n 2. \\<lbrakk>unit_circle_fix M; circline_type H = - 1;\n     perpendicular H unit_circle\\<rbrakk>\n    \\<Longrightarrow> perpendicular (moebius_circline M H) unit_circle", "have ounit: \"ounit_circle = moebius_ocircline M ounit_circle \\<or>\n               ounit_circle = moebius_ocircline M (opposite_ocircline ounit_circle)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ounit_circle = moebius_ocircline M ounit_circle \\<or>\n    ounit_circle = moebius_ocircline M (opposite_ocircline ounit_circle)", "using ++(1) unit_circle_fix_iff[of M]"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  unit_circle_fix M = (moebius_circline M unit_circle = unit_circle)\n\ngoal (1 subgoal):\n 1. ounit_circle = moebius_ocircline M ounit_circle \\<or>\n    ounit_circle = moebius_ocircline M (opposite_ocircline ounit_circle)", "by (simp add: inj_of_ocircline moebius_circline_ocircline)"], ["proof (state)\nthis:\n  ounit_circle = moebius_ocircline M ounit_circle \\<or>\n  ounit_circle = moebius_ocircline M (opposite_ocircline ounit_circle)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>unit_circle_fix M; circline_type H = - 1;\n     perpendicular H unit_circle\\<rbrakk>\n    \\<Longrightarrow> circline_type (moebius_circline M H) = - 1\n 2. \\<lbrakk>unit_circle_fix M; circline_type H = - 1;\n     perpendicular H unit_circle\\<rbrakk>\n    \\<Longrightarrow> perpendicular (moebius_circline M H) unit_circle", "show \"perpendicular (moebius_circline M H) unit_circle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perpendicular (moebius_circline M H) unit_circle", "proof (cases \"pos_oriented ?H'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pos_oriented (moebius_ocircline M (of_circline H)) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle\n 2. \\<not> pos_oriented\n            (moebius_ocircline M (of_circline H)) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "case True"], ["proof (state)\nthis:\n  pos_oriented (moebius_ocircline M (of_circline H))\n\ngoal (2 subgoals):\n 1. pos_oriented (moebius_ocircline M (of_circline H)) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle\n 2. \\<not> pos_oriented\n            (moebius_ocircline M (of_circline H)) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "hence *: \"of_circline (of_ocircline ?H') = ?H'\""], ["proof (prove)\nusing this:\n  pos_oriented (moebius_ocircline M (of_circline H))\n\ngoal (1 subgoal):\n 1. of_circline (of_ocircline (moebius_ocircline M (of_circline H))) =\n    moebius_ocircline M (of_circline H)", "using of_circline_of_ocircline_pos_oriented"], ["proof (prove)\nusing this:\n  pos_oriented (moebius_ocircline M (of_circline H))\n  pos_oriented ?H \\<Longrightarrow> of_circline (of_ocircline ?H) = ?H\n\ngoal (1 subgoal):\n 1. of_circline (of_ocircline (moebius_ocircline M (of_circline H))) =\n    moebius_ocircline M (of_circline H)", "by blast"], ["proof (state)\nthis:\n  of_circline (of_ocircline (moebius_ocircline M (of_circline H))) =\n  moebius_ocircline M (of_circline H)\n\ngoal (2 subgoals):\n 1. pos_oriented (moebius_ocircline M (of_circline H)) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle\n 2. \\<not> pos_oriented\n            (moebius_ocircline M (of_circline H)) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "from ounit"], ["proof (chain)\npicking this:\n  ounit_circle = moebius_ocircline M ounit_circle \\<or>\n  ounit_circle = moebius_ocircline M (opposite_ocircline ounit_circle)", "show ?thesis"], ["proof (prove)\nusing this:\n  ounit_circle = moebius_ocircline M ounit_circle \\<or>\n  ounit_circle = moebius_ocircline M (opposite_ocircline ounit_circle)\n\ngoal (1 subgoal):\n 1. perpendicular (moebius_circline M H) unit_circle", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ounit_circle = moebius_ocircline M ounit_circle \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle\n 2. ounit_circle =\n    moebius_ocircline M (opposite_ocircline ounit_circle) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "assume **: \"ounit_circle = moebius_ocircline M ounit_circle\""], ["proof (state)\nthis:\n  ounit_circle = moebius_ocircline M ounit_circle\n\ngoal (2 subgoals):\n 1. ounit_circle = moebius_ocircline M ounit_circle \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle\n 2. ounit_circle =\n    moebius_ocircline M (opposite_ocircline ounit_circle) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. perpendicular (moebius_circline M H) unit_circle", "using ++"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  perpendicular H unit_circle\n\ngoal (1 subgoal):\n 1. perpendicular (moebius_circline M H) unit_circle", "unfolding perpendicular_def"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  cos_angle (of_circline H) (of_circline unit_circle) = 0\n\ngoal (1 subgoal):\n 1. cos_angle (of_circline (moebius_circline M H))\n     (of_circline unit_circle) =\n    0", "by (simp, subst moebius_circline_ocircline, subst *, subst **) simp"], ["proof (state)\nthis:\n  perpendicular (moebius_circline M H) unit_circle\n\ngoal (1 subgoal):\n 1. ounit_circle =\n    moebius_ocircline M (opposite_ocircline ounit_circle) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ounit_circle =\n    moebius_ocircline M (opposite_ocircline ounit_circle) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "assume **: \"ounit_circle = moebius_ocircline M (opposite_ocircline ounit_circle)\""], ["proof (state)\nthis:\n  ounit_circle = moebius_ocircline M (opposite_ocircline ounit_circle)\n\ngoal (1 subgoal):\n 1. ounit_circle =\n    moebius_ocircline M (opposite_ocircline ounit_circle) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. perpendicular (moebius_circline M H) unit_circle", "using ++"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  perpendicular H unit_circle\n\ngoal (1 subgoal):\n 1. perpendicular (moebius_circline M H) unit_circle", "unfolding perpendicular_def"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  cos_angle (of_circline H) (of_circline unit_circle) = 0\n\ngoal (1 subgoal):\n 1. cos_angle (of_circline (moebius_circline M H))\n     (of_circline unit_circle) =\n    0", "by (simp, subst moebius_circline_ocircline, subst *, subst **) simp"], ["proof (state)\nthis:\n  perpendicular (moebius_circline M H) unit_circle\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  perpendicular (moebius_circline M H) unit_circle\n\ngoal (1 subgoal):\n 1. \\<not> pos_oriented\n            (moebius_ocircline M (of_circline H)) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> pos_oriented\n            (moebius_ocircline M (of_circline H)) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "case False"], ["proof (state)\nthis:\n  \\<not> pos_oriented (moebius_ocircline M (of_circline H))\n\ngoal (1 subgoal):\n 1. \\<not> pos_oriented\n            (moebius_ocircline M (of_circline H)) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "hence *: \"of_circline (of_ocircline ?H') = opposite_ocircline ?H'\""], ["proof (prove)\nusing this:\n  \\<not> pos_oriented (moebius_ocircline M (of_circline H))\n\ngoal (1 subgoal):\n 1. of_circline (of_ocircline (moebius_ocircline M (of_circline H))) =\n    opposite_ocircline (moebius_ocircline M (of_circline H))", "by (metis of_circline_of_ocircline pos_oriented_of_circline)"], ["proof (state)\nthis:\n  of_circline (of_ocircline (moebius_ocircline M (of_circline H))) =\n  opposite_ocircline (moebius_ocircline M (of_circline H))\n\ngoal (1 subgoal):\n 1. \\<not> pos_oriented\n            (moebius_ocircline M (of_circline H)) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "from ounit"], ["proof (chain)\npicking this:\n  ounit_circle = moebius_ocircline M ounit_circle \\<or>\n  ounit_circle = moebius_ocircline M (opposite_ocircline ounit_circle)", "show ?thesis"], ["proof (prove)\nusing this:\n  ounit_circle = moebius_ocircline M ounit_circle \\<or>\n  ounit_circle = moebius_ocircline M (opposite_ocircline ounit_circle)\n\ngoal (1 subgoal):\n 1. perpendicular (moebius_circline M H) unit_circle", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ounit_circle = moebius_ocircline M ounit_circle \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle\n 2. ounit_circle =\n    moebius_ocircline M (opposite_ocircline ounit_circle) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "assume **: \"ounit_circle = moebius_ocircline M ounit_circle\""], ["proof (state)\nthis:\n  ounit_circle = moebius_ocircline M ounit_circle\n\ngoal (2 subgoals):\n 1. ounit_circle = moebius_ocircline M ounit_circle \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle\n 2. ounit_circle =\n    moebius_ocircline M (opposite_ocircline ounit_circle) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. perpendicular (moebius_circline M H) unit_circle", "using ++"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  perpendicular H unit_circle\n\ngoal (1 subgoal):\n 1. perpendicular (moebius_circline M H) unit_circle", "unfolding perpendicular_def"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  cos_angle (of_circline H) (of_circline unit_circle) = 0\n\ngoal (1 subgoal):\n 1. cos_angle (of_circline (moebius_circline M H))\n     (of_circline unit_circle) =\n    0", "by (simp, subst moebius_circline_ocircline, subst *, subst **) simp"], ["proof (state)\nthis:\n  perpendicular (moebius_circline M H) unit_circle\n\ngoal (1 subgoal):\n 1. ounit_circle =\n    moebius_ocircline M (opposite_ocircline ounit_circle) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ounit_circle =\n    moebius_ocircline M (opposite_ocircline ounit_circle) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "assume **: \"ounit_circle = moebius_ocircline M (opposite_ocircline ounit_circle)\""], ["proof (state)\nthis:\n  ounit_circle = moebius_ocircline M (opposite_ocircline ounit_circle)\n\ngoal (1 subgoal):\n 1. ounit_circle =\n    moebius_ocircline M (opposite_ocircline ounit_circle) \\<Longrightarrow>\n    perpendicular (moebius_circline M H) unit_circle", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. perpendicular (moebius_circline M H) unit_circle", "using ++"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  perpendicular H unit_circle\n\ngoal (1 subgoal):\n 1. perpendicular (moebius_circline M H) unit_circle", "unfolding perpendicular_def"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  cos_angle (of_circline H) (of_circline unit_circle) = 0\n\ngoal (1 subgoal):\n 1. cos_angle (of_circline (moebius_circline M H))\n     (of_circline unit_circle) =\n    0", "by (simp, subst moebius_circline_ocircline, subst *, subst **) simp"], ["proof (state)\nthis:\n  perpendicular (moebius_circline M H) unit_circle\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  perpendicular (moebius_circline M H) unit_circle\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  perpendicular (moebius_circline M H) unit_circle\n\ngoal (1 subgoal):\n 1. \\<lbrakk>unit_circle_fix M; circline_type H = - 1;\n     perpendicular H unit_circle\\<rbrakk>\n    \\<Longrightarrow> circline_type (moebius_circline M H) = - 1", "qed simp"], ["", "lemma unit_circle_fix_preserve_is_poincare_line_iff [simp]:\n  assumes \"unit_circle_fix M\"\n  shows \"is_poincare_line (moebius_circline M H) \\<longleftrightarrow> is_poincare_line H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line (moebius_circline M H) = is_poincare_line H", "using assms"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n\ngoal (1 subgoal):\n 1. is_poincare_line (moebius_circline M H) = is_poincare_line H", "using unit_circle_fix_preserve_is_poincare_line[of M H]"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  \\<lbrakk>unit_circle_fix M; is_poincare_line H\\<rbrakk>\n  \\<Longrightarrow> is_poincare_line (moebius_circline M H)\n\ngoal (1 subgoal):\n 1. is_poincare_line (moebius_circline M H) = is_poincare_line H", "using unit_circle_fix_preserve_is_poincare_line[of \"moebius_inv M\" \"moebius_circline M H\"]"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  \\<lbrakk>unit_circle_fix M; is_poincare_line H\\<rbrakk>\n  \\<Longrightarrow> is_poincare_line (moebius_circline M H)\n  \\<lbrakk>unit_circle_fix (moebius_inv M);\n   is_poincare_line (moebius_circline M H)\\<rbrakk>\n  \\<Longrightarrow> is_poincare_line\n                     (moebius_circline (moebius_inv M)\n                       (moebius_circline M H))\n\ngoal (1 subgoal):\n 1. is_poincare_line (moebius_circline M H) = is_poincare_line H", "by (auto simp del: unit_circle_fix_preserve_is_poincare_line)"], ["", "text\\<open>Since h-lines are preserved by transformations that fix the unit circle, so is collinearity.\\<close>"], ["", "lemma unit_disc_fix_preserve_poincare_collinear [simp]:\n  assumes \"unit_circle_fix M\" \"poincare_collinear A\"\n  shows \"poincare_collinear (moebius_pt M ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_collinear (moebius_pt M ` A)", "using assms"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  poincare_collinear A\n\ngoal (1 subgoal):\n 1. poincare_collinear (moebius_pt M ` A)", "unfolding poincare_collinear_def"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  \\<exists>p. is_poincare_line p \\<and> A \\<subseteq> circline_set p\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       is_poincare_line p \\<and> moebius_pt M ` A \\<subseteq> circline_set p", "by (auto, rule_tac x=\"moebius_circline M p\" in exI, auto)"], ["", "lemma unit_disc_fix_preserve_poincare_collinear_iff [simp]:\n  assumes \"unit_circle_fix M\"\n  shows \"poincare_collinear (moebius_pt M ` A) \\<longleftrightarrow> poincare_collinear A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_collinear (moebius_pt M ` A) = poincare_collinear A", "using assms"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n\ngoal (1 subgoal):\n 1. poincare_collinear (moebius_pt M ` A) = poincare_collinear A", "using unit_disc_fix_preserve_poincare_collinear[of M A]"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  \\<lbrakk>unit_circle_fix M; poincare_collinear A\\<rbrakk>\n  \\<Longrightarrow> poincare_collinear (moebius_pt M ` A)\n\ngoal (1 subgoal):\n 1. poincare_collinear (moebius_pt M ` A) = poincare_collinear A", "using unit_disc_fix_preserve_poincare_collinear[of \"moebius_inv M\" \"moebius_pt M ` A\"]"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  \\<lbrakk>unit_circle_fix M; poincare_collinear A\\<rbrakk>\n  \\<Longrightarrow> poincare_collinear (moebius_pt M ` A)\n  \\<lbrakk>unit_circle_fix (moebius_inv M);\n   poincare_collinear (moebius_pt M ` A)\\<rbrakk>\n  \\<Longrightarrow> poincare_collinear\n                     (moebius_pt (moebius_inv M) ` moebius_pt M ` A)\n\ngoal (1 subgoal):\n 1. poincare_collinear (moebius_pt M ` A) = poincare_collinear A", "by (auto simp del: unit_disc_fix_preserve_poincare_collinear)"], ["", "lemma unit_disc_fix_preserve_poincare_collinear3 [simp]:\n  assumes \"unit_disc_fix M\"\n  shows \"poincare_collinear {moebius_pt M u, moebius_pt M v, moebius_pt M w} \\<longleftrightarrow>\n         poincare_collinear {u, v, w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_collinear {moebius_pt M u, moebius_pt M v, moebius_pt M w} =\n    poincare_collinear {u, v, w}", "using assms unit_disc_fix_preserve_poincare_collinear_iff[of M \"{u, v, w}\"]"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  unit_circle_fix M \\<Longrightarrow>\n  poincare_collinear (moebius_pt M ` {u, v, w}) =\n  poincare_collinear {u, v, w}\n\ngoal (1 subgoal):\n 1. poincare_collinear {moebius_pt M u, moebius_pt M v, moebius_pt M w} =\n    poincare_collinear {u, v, w}", "by simp"], ["", "text\\<open>Conjugation is also an h-isometry and it preserves h-lines.\\<close>"], ["", "lemma is_poincare_line_conjugate_circline [simp]:\n  assumes \"is_poincare_line H\"\n  shows \"is_poincare_line (conjugate_circline H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line (conjugate_circline H)", "using assms"], ["proof (prove)\nusing this:\n  is_poincare_line H\n\ngoal (1 subgoal):\n 1. is_poincare_line (conjugate_circline H)", "by (transfer, transfer, auto simp add: mat_cnj_def hermitean_def mat_adj_def)"], ["", "lemma is_poincare_line_conjugate_circline_iff [simp]:\n  shows \"is_poincare_line (conjugate_circline H) \\<longleftrightarrow> is_poincare_line H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line (conjugate_circline H) = is_poincare_line H", "using is_poincare_line_conjugate_circline[of \"conjugate_circline H\"]"], ["proof (prove)\nusing this:\n  is_poincare_line (conjugate_circline H) \\<Longrightarrow>\n  is_poincare_line (conjugate_circline (conjugate_circline H))\n\ngoal (1 subgoal):\n 1. is_poincare_line (conjugate_circline H) = is_poincare_line H", "by auto"], ["", "text\\<open>Since h-lines are preserved by conjugation, so is collinearity.\\<close>"], ["", "lemma conjugate_preserve_poincare_collinear [simp]:\n  assumes \"poincare_collinear A\"\n  shows \"poincare_collinear (conjugate ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_collinear (conjugate ` A)", "using assms"], ["proof (prove)\nusing this:\n  poincare_collinear A\n\ngoal (1 subgoal):\n 1. poincare_collinear (conjugate ` A)", "unfolding poincare_collinear_def"], ["proof (prove)\nusing this:\n  \\<exists>p. is_poincare_line p \\<and> A \\<subseteq> circline_set p\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       is_poincare_line p \\<and> conjugate ` A \\<subseteq> circline_set p", "by auto (rule_tac x=\"conjugate_circline p\" in exI, auto)"], ["", "lemma conjugate_conjugate [simp]: \"conjugate ` conjugate ` A = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate ` conjugate ` A = A", "by (auto simp add: image_iff)"], ["", "lemma conjugate_preserve_poincare_collinear_iff [simp]:\n  shows \"poincare_collinear (conjugate ` A) \\<longleftrightarrow> poincare_collinear A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_collinear (conjugate ` A) = poincare_collinear A", "using conjugate_preserve_poincare_collinear[of \"A\"]"], ["proof (prove)\nusing this:\n  poincare_collinear A \\<Longrightarrow> poincare_collinear (conjugate ` A)\n\ngoal (1 subgoal):\n 1. poincare_collinear (conjugate ` A) = poincare_collinear A", "using conjugate_preserve_poincare_collinear[of \"conjugate ` A\"]"], ["proof (prove)\nusing this:\n  poincare_collinear A \\<Longrightarrow> poincare_collinear (conjugate ` A)\n  poincare_collinear (conjugate ` A) \\<Longrightarrow>\n  poincare_collinear (conjugate ` conjugate ` A)\n\ngoal (1 subgoal):\n 1. poincare_collinear (conjugate ` A) = poincare_collinear A", "by (auto simp del: conjugate_preserve_poincare_collinear)"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsubsection\\<open>Mapping h-lines to x-axis\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "text\\<open>Each h-line in the Poincar\\'e model can be mapped onto the x-axis (by a unit-disc preserving\nM?bius transformation).\\<close>"], ["", "lemma ex_unit_disc_fix_is_poincare_line_to_x_axis:\n  assumes \"is_poincare_line l\"\n  shows  \"\\<exists> M. unit_disc_fix M \\<and> moebius_circline M l = x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "from assms"], ["proof (chain)\npicking this:\n  is_poincare_line l", "obtain u v where \"u \\<noteq> v\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" and \"{u, v} \\<subseteq> circline_set l\""], ["proof (prove)\nusing this:\n  is_poincare_line l\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<noteq> v; u \\<in> unit_disc; v \\<in> unit_disc;\n         {u, v} \\<subseteq> circline_set l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_is_poincare_line_points"], ["proof (prove)\nusing this:\n  is_poincare_line l\n  is_poincare_line ?H \\<Longrightarrow>\n  \\<exists>u v.\n     u \\<in> unit_disc \\<and>\n     v \\<in> unit_disc \\<and>\n     u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set ?H\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<noteq> v; u \\<in> unit_disc; v \\<in> unit_disc;\n         {u, v} \\<subseteq> circline_set l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u \\<noteq> v\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  {u, v} \\<subseteq> circline_set l\n\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "then"], ["proof (chain)\npicking this:\n  u \\<noteq> v\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  {u, v} \\<subseteq> circline_set l", "obtain M where *: \"unit_disc_fix M\" \"moebius_pt M u = 0\\<^sub>h\" \"moebius_pt M v \\<in> positive_x_axis\""], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  {u, v} \\<subseteq> circline_set l\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>unit_disc_fix M; moebius_pt M u = 0\\<^sub>h;\n         moebius_pt M v \\<in> positive_x_axis\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_unit_disc_fix_to_zero_positive_x_axis[of u v]"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  {u, v} \\<subseteq> circline_set l\n  \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc; u \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M.\n                       unit_disc_fix M \\<and>\n                       moebius_pt M u = 0\\<^sub>h \\<and>\n                       moebius_pt M v \\<in> positive_x_axis\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>unit_disc_fix M; moebius_pt M u = 0\\<^sub>h;\n         moebius_pt M v \\<in> positive_x_axis\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unit_disc_fix M\n  moebius_pt M u = 0\\<^sub>h\n  moebius_pt M v \\<in> positive_x_axis\n\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "moreover"], ["proof (state)\nthis:\n  unit_disc_fix M\n  moebius_pt M u = 0\\<^sub>h\n  moebius_pt M v \\<in> positive_x_axis\n\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "hence \"{0\\<^sub>h, moebius_pt M v} \\<subseteq> circline_set x_axis\""], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  moebius_pt M u = 0\\<^sub>h\n  moebius_pt M v \\<in> positive_x_axis\n\ngoal (1 subgoal):\n 1. {0\\<^sub>h, moebius_pt M v} \\<subseteq> circline_set x_axis", "unfolding positive_x_axis_def"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  moebius_pt M u = 0\\<^sub>h\n  moebius_pt M v\n  \\<in> {z \\<in> circline_set x_axis.\n         z \\<noteq> \\<infinity>\\<^sub>h \\<and> 0 < Re (to_complex z)}\n\ngoal (1 subgoal):\n 1. {0\\<^sub>h, moebius_pt M v} \\<subseteq> circline_set x_axis", "by auto"], ["proof (state)\nthis:\n  {0\\<^sub>h, moebius_pt M v} \\<subseteq> circline_set x_axis\n\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "moreover"], ["proof (state)\nthis:\n  {0\\<^sub>h, moebius_pt M v} \\<subseteq> circline_set x_axis\n\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "have \"moebius_pt M v \\<noteq> 0\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt M v \\<noteq> 0\\<^sub>h", "using \\<open>u \\<noteq> v\\<close> *"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  unit_disc_fix M\n  moebius_pt M u = 0\\<^sub>h\n  moebius_pt M v \\<in> positive_x_axis\n\ngoal (1 subgoal):\n 1. moebius_pt M v \\<noteq> 0\\<^sub>h", "by (metis moebius_pt_neq_I)"], ["proof (state)\nthis:\n  moebius_pt M v \\<noteq> 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "moreover"], ["proof (state)\nthis:\n  moebius_pt M v \\<noteq> 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "have \"moebius_pt M v \\<noteq> \\<infinity>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt M v \\<noteq> \\<infinity>\\<^sub>h", "using \\<open>unit_disc_fix M\\<close> \\<open>v \\<in> unit_disc\\<close>"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt M v \\<noteq> \\<infinity>\\<^sub>h", "using unit_disc_fix_discI"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  v \\<in> unit_disc\n  \\<lbrakk>unit_disc_fix ?M; ?u \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> moebius_pt ?M ?u \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt M v \\<noteq> \\<infinity>\\<^sub>h", "by fastforce"], ["proof (state)\nthis:\n  moebius_pt M v \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "ultimately"], ["proof (chain)\npicking this:\n  unit_disc_fix M\n  moebius_pt M u = 0\\<^sub>h\n  moebius_pt M v \\<in> positive_x_axis\n  {0\\<^sub>h, moebius_pt M v} \\<subseteq> circline_set x_axis\n  moebius_pt M v \\<noteq> 0\\<^sub>h\n  moebius_pt M v \\<noteq> \\<infinity>\\<^sub>h", "show ?thesis"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  moebius_pt M u = 0\\<^sub>h\n  moebius_pt M v \\<in> positive_x_axis\n  {0\\<^sub>h, moebius_pt M v} \\<subseteq> circline_set x_axis\n  moebius_pt M v \\<noteq> 0\\<^sub>h\n  moebius_pt M v \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "using \\<open>is_poincare_line l\\<close> \\<open>{u, v} \\<subseteq> circline_set l\\<close> \\<open>unit_disc_fix M\\<close>"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  moebius_pt M u = 0\\<^sub>h\n  moebius_pt M v \\<in> positive_x_axis\n  {0\\<^sub>h, moebius_pt M v} \\<subseteq> circline_set x_axis\n  moebius_pt M v \\<noteq> 0\\<^sub>h\n  moebius_pt M v \\<noteq> \\<infinity>\\<^sub>h\n  is_poincare_line l\n  {u, v} \\<subseteq> circline_set l\n  unit_disc_fix M\n\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "using is_poincare_line_0_real_is_x_axis[of \"moebius_circline M l\" \"moebius_pt M v\"]"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  moebius_pt M u = 0\\<^sub>h\n  moebius_pt M v \\<in> positive_x_axis\n  {0\\<^sub>h, moebius_pt M v} \\<subseteq> circline_set x_axis\n  moebius_pt M v \\<noteq> 0\\<^sub>h\n  moebius_pt M v \\<noteq> \\<infinity>\\<^sub>h\n  is_poincare_line l\n  {u, v} \\<subseteq> circline_set l\n  unit_disc_fix M\n  \\<lbrakk>is_poincare_line (moebius_circline M l);\n   0\\<^sub>h \\<in> circline_set (moebius_circline M l);\n   moebius_pt M v\n   \\<in> circline_set (moebius_circline M l) \\<inter> circline_set x_axis;\n   moebius_pt M v \\<noteq> 0\\<^sub>h;\n   moebius_pt M v \\<noteq> \\<infinity>\\<^sub>h\\<rbrakk>\n  \\<Longrightarrow> moebius_circline M l = x_axis\n\ngoal (1 subgoal):\n 1. \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis", "by (rule_tac x=\"M\" in exI, force)"], ["proof (state)\nthis:\n  \\<exists>M. unit_disc_fix M \\<and> moebius_circline M l = x_axis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>When proving facts about h-lines, without loss of generality it can be assumed that h-line is\nthe x-axis (if the property being proved is invariant under M?bius transformations that fix the\nunit disc).\\<close>"], ["", "lemma wlog_line_x_axis:\n  assumes is_line: \"is_poincare_line H\"\n  assumes x_axis: \"P x_axis\"\n  assumes preserves: \"\\<And> M. \\<lbrakk>unit_disc_fix M; P (moebius_circline M H)\\<rbrakk> \\<Longrightarrow> P H\"\n  shows \"P H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P H", "using assms"], ["proof (prove)\nusing this:\n  is_poincare_line H\n  P x_axis\n  \\<lbrakk>unit_disc_fix ?M; P (moebius_circline ?M H)\\<rbrakk>\n  \\<Longrightarrow> P H\n\ngoal (1 subgoal):\n 1. P H", "using ex_unit_disc_fix_is_poincare_line_to_x_axis[of H]"], ["proof (prove)\nusing this:\n  is_poincare_line H\n  P x_axis\n  \\<lbrakk>unit_disc_fix ?M; P (moebius_circline ?M H)\\<rbrakk>\n  \\<Longrightarrow> P H\n  is_poincare_line H \\<Longrightarrow>\n  \\<exists>M. unit_disc_fix M \\<and> moebius_circline M H = x_axis\n\ngoal (1 subgoal):\n 1. P H", "by auto"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsection\\<open>Construction of the h-line between the two given points\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "text\\<open>Next we show how to construct the (unique) h-line between the two given points in the Poincar\\'e model\\<close>"], ["", "text\\<open>\nGeometrically, h-line can be constructed by finding the inverse point of one of the two points and \nby constructing the circle (or line) trough it and the two given points.\n\nAlgebraically, for two given points $u$ and $v$ in $\\mathbb{C}$, the h-line matrix coefficients can\nbe $A = i\\cdot(u\\overline{v}-v\\overline{u})$ and $B = i\\cdot(v(|u|^2+1) - u(|v|^2+1))$.\n\nWe need to extend this to homogenous coordinates. There are several degenerate cases.\n\n - If $\\{z, w\\} = \\{0_h, \\infty_h\\}$ then there is no unique h-line (any line trough zero is an h-line).\n\n - If z and w are mutually inverse, then the construction fails (both geometric and algebraic).\n\n - If z and w are different points on the unit circle, then the standard construction fails (only geometric).\n\n - None of this problematic cases occur when z and w are inside the unit disc.\n\nWe express the construction algebraically, and construct the Hermitean circline matrix for the two\npoints given in homogenous coordinates. It works correctly in all cases except when the two points\nare the same or are mutually inverse.\n\\<close>"], ["", "definition mk_poincare_line_cmat :: \"real \\<Rightarrow> complex \\<Rightarrow> complex_mat\" where\n  [simp]: \"mk_poincare_line_cmat A B = (cor A, B, cnj B, cor A)\""], ["", "lemma mk_poincare_line_cmat_zero_iff:\n  \"mk_poincare_line_cmat A B = mat_zero \\<longleftrightarrow> A = 0 \\<and> B = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_poincare_line_cmat A B = mat_zero) = (A = 0 \\<and> B = 0)", "by auto"], ["", "lemma mk_poincare_line_cmat_hermitean\n  [simp]:  \"hermitean (mk_poincare_line_cmat A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitean (mk_poincare_line_cmat A B)", "by simp"], ["", "lemma mk_poincare_line_cmat_scale:\n  \"cor k *\\<^sub>s\\<^sub>m mk_poincare_line_cmat A B = mk_poincare_line_cmat (k * A) (k * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor k *\\<^sub>s\\<^sub>m mk_poincare_line_cmat A B =\n    mk_poincare_line_cmat (k * A) (cor k * B)", "by simp"], ["", "definition poincare_line_cvec_cmat :: \"complex_vec \\<Rightarrow> complex_vec \\<Rightarrow> complex_mat\" where\n  [simp]: \"poincare_line_cvec_cmat z w =\n            (let (z1, z2) = z;\n                 (w1, w2) = w;\n                 nom = w1*cnj w2*(z1*cnj z1 + z2*cnj z2) - z1*cnj z2*(w1*cnj w1 + w2*cnj w2);\n                 den = z1*cnj z2*cnj w1*w2 - w1*cnj w2*cnj z1*z2\n              in if den \\<noteq> 0 then\n                    mk_poincare_line_cmat (Re(\\<i>*den)) (\\<i>*nom)\n                 else if z1*cnj z2 \\<noteq> 0 then\n                    mk_poincare_line_cmat 0 (\\<i>*z1*cnj z2)\n                 else if w1*cnj w2 \\<noteq> 0 then\n                    mk_poincare_line_cmat 0 (\\<i>*w1*cnj w2)\n                 else\n                    mk_poincare_line_cmat 0 \\<i>)\""], ["", "lemma poincare_line_cvec_cmat_AeqD:\n  assumes \"poincare_line_cvec_cmat z w = (A, B, C, D)\"\n  shows \"A = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = D", "using assms"], ["proof (prove)\nusing this:\n  poincare_line_cvec_cmat z w = (A, B, C, D)\n\ngoal (1 subgoal):\n 1. A = D", "by (cases z, cases w) (auto split: if_split_asm)"], ["", "lemma poincare_line_cvec_cmat_hermitean [simp]: \n  shows \"hermitean (poincare_line_cvec_cmat z w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitean (poincare_line_cvec_cmat z w)", "by (cases z, cases w) (auto split: if_split_asm simp del: mk_poincare_line_cmat_def)"], ["", "lemma poincare_line_cvec_cmat_nonzero [simp]:\n  assumes \"z \\<noteq> vec_zero\" \"w \\<noteq> vec_zero\"\n  shows  \"poincare_line_cvec_cmat z w \\<noteq> mat_zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat z w \\<noteq> mat_zero", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat z w \\<noteq> mat_zero", "obtain z1 z2 w1 w2 where *: \"z = (z1, z2)\" \"w = (w1, w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z1 z2 w1 w2.\n        \\<lbrakk>z = (z1, z2); w = (w1, w2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases z, cases w, auto)"], ["proof (state)\nthis:\n  z = (z1, z2)\n  w = (w1, w2)\n\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat z w \\<noteq> mat_zero", "let ?den = \"z1*cnj z2*cnj w1*w2 - w1*cnj w2*cnj z1*z2\""], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat z w \\<noteq> mat_zero", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat z w \\<noteq> mat_zero", "proof (cases \"?den \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq>\n    0 \\<Longrightarrow>\n    poincare_line_cvec_cmat z w \\<noteq> mat_zero\n 2. \\<not> z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq>\n           0 \\<Longrightarrow>\n    poincare_line_cvec_cmat z w \\<noteq> mat_zero", "case True"], ["proof (state)\nthis:\n  z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq>\n    0 \\<Longrightarrow>\n    poincare_line_cvec_cmat z w \\<noteq> mat_zero\n 2. \\<not> z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq>\n           0 \\<Longrightarrow>\n    poincare_line_cvec_cmat z w \\<noteq> mat_zero", "have \"is_real (\\<i> * ?den)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (\\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))", "using eq_cnj_iff_real[of \"\\<i> *?den\"]"], ["proof (prove)\nusing this:\n  (cnj (\\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)) =\n   \\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)) =\n  is_real (\\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))\n\ngoal (1 subgoal):\n 1. is_real (\\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  is_real (\\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))\n\ngoal (2 subgoals):\n 1. z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq>\n    0 \\<Longrightarrow>\n    poincare_line_cvec_cmat z w \\<noteq> mat_zero\n 2. \\<not> z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq>\n           0 \\<Longrightarrow>\n    poincare_line_cvec_cmat z w \\<noteq> mat_zero", "hence \"Re (\\<i> * ?den) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  is_real (\\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))\n\ngoal (1 subgoal):\n 1. Re (\\<i> *\n        (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)) \\<noteq>\n    0", "using \\<open>?den \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  is_real (\\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))\n  z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (\\<i> *\n        (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)) \\<noteq>\n    0", "by (metis complex_i_not_zero complex_surj mult_eq_0_iff zero_complex.code)"], ["proof (state)\nthis:\n  Re (\\<i> *\n      (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)) \\<noteq>\n  0\n\ngoal (2 subgoals):\n 1. z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq>\n    0 \\<Longrightarrow>\n    poincare_line_cvec_cmat z w \\<noteq> mat_zero\n 2. \\<not> z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq>\n           0 \\<Longrightarrow>\n    poincare_line_cvec_cmat z w \\<noteq> mat_zero", "thus ?thesis"], ["proof (prove)\nusing this:\n  Re (\\<i> *\n      (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat z w \\<noteq> mat_zero", "using * \\<open>?den \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  Re (\\<i> *\n      (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)) \\<noteq>\n  0\n  z = (z1, z2)\n  w = (w1, w2)\n  z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat z w \\<noteq> mat_zero", "by (simp del: mk_poincare_line_cmat_def mat_zero_def add: mk_poincare_line_cmat_zero_iff)"], ["proof (state)\nthis:\n  poincare_line_cvec_cmat z w \\<noteq> mat_zero\n\ngoal (1 subgoal):\n 1. \\<not> z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq>\n           0 \\<Longrightarrow>\n    poincare_line_cvec_cmat z w \\<noteq> mat_zero", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq>\n           0 \\<Longrightarrow>\n    poincare_line_cvec_cmat z w \\<noteq> mat_zero", "case False"], ["proof (state)\nthis:\n  \\<not> z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq>\n           0 \\<Longrightarrow>\n    poincare_line_cvec_cmat z w \\<noteq> mat_zero", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat z w \\<noteq> mat_zero", "using *"], ["proof (prove)\nusing this:\n  \\<not> z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq> 0\n  z = (z1, z2)\n  w = (w1, w2)\n\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat z w \\<noteq> mat_zero", "by (simp del: mk_poincare_line_cmat_def mat_zero_def add: mk_poincare_line_cmat_zero_iff)"], ["proof (state)\nthis:\n  poincare_line_cvec_cmat z w \\<noteq> mat_zero\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poincare_line_cvec_cmat z w \\<noteq> mat_zero\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition poincare_line_hcoords_clmat :: \"complex_homo_coords \\<Rightarrow> complex_homo_coords \\<Rightarrow> circline_mat\" is poincare_line_cvec_cmat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       \\<lbrakk>prod1 \\<noteq> vec_zero; prod2 \\<noteq> vec_zero\\<rbrakk>\n       \\<Longrightarrow> hermitean\n                          (poincare_line_cvec_cmat prod1 prod2) \\<and>\n                         poincare_line_cvec_cmat prod1 prod2 \\<noteq>\n                         mat_zero", "using poincare_line_cvec_cmat_hermitean poincare_line_cvec_cmat_nonzero"], ["proof (prove)\nusing this:\n  hermitean (poincare_line_cvec_cmat ?z ?w)\n  \\<lbrakk>?z \\<noteq> vec_zero; ?w \\<noteq> vec_zero\\<rbrakk>\n  \\<Longrightarrow> poincare_line_cvec_cmat ?z ?w \\<noteq> mat_zero\n\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       \\<lbrakk>prod1 \\<noteq> vec_zero; prod2 \\<noteq> vec_zero\\<rbrakk>\n       \\<Longrightarrow> hermitean\n                          (poincare_line_cvec_cmat prod1 prod2) \\<and>\n                         poincare_line_cvec_cmat prod1 prod2 \\<noteq>\n                         mat_zero", "by simp"], ["", "lift_definition poincare_line :: \"complex_homo \\<Rightarrow> complex_homo \\<Rightarrow> circline\" is poincare_line_hcoords_clmat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>complex_homo_coords1 complex_homo_coords2 complex_homo_coords3\n       complex_homo_coords4.\n       \\<lbrakk>complex_homo_coords1 \\<approx> complex_homo_coords2;\n        complex_homo_coords3 \\<approx> complex_homo_coords4\\<rbrakk>\n       \\<Longrightarrow> circline_eq_clmat\n                          (poincare_line_hcoords_clmat complex_homo_coords1\n                            complex_homo_coords3)\n                          (poincare_line_hcoords_clmat complex_homo_coords2\n                            complex_homo_coords4)", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>complex_homo_coords1 complex_homo_coords2 complex_homo_coords3\n       complex_homo_coords4.\n       \\<lbrakk>complex_homo_coords1 \\<noteq> vec_zero;\n        complex_homo_coords2 \\<noteq> vec_zero;\n        complex_homo_coords3 \\<noteq> vec_zero;\n        complex_homo_coords4 \\<noteq> vec_zero;\n        complex_homo_coords1 \\<approx>\\<^sub>v complex_homo_coords2;\n        complex_homo_coords3 \\<approx>\\<^sub>v complex_homo_coords4\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat complex_homo_coords1\n                            complex_homo_coords3)\n                          (poincare_line_cvec_cmat complex_homo_coords2\n                            complex_homo_coords4)", "fix za zb wa wb"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>complex_homo_coords1 complex_homo_coords2 complex_homo_coords3\n       complex_homo_coords4.\n       \\<lbrakk>complex_homo_coords1 \\<noteq> vec_zero;\n        complex_homo_coords2 \\<noteq> vec_zero;\n        complex_homo_coords3 \\<noteq> vec_zero;\n        complex_homo_coords4 \\<noteq> vec_zero;\n        complex_homo_coords1 \\<approx>\\<^sub>v complex_homo_coords2;\n        complex_homo_coords3 \\<approx>\\<^sub>v complex_homo_coords4\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat complex_homo_coords1\n                            complex_homo_coords3)\n                          (poincare_line_cvec_cmat complex_homo_coords2\n                            complex_homo_coords4)", "assume \"za \\<noteq> vec_zero\" \"zb \\<noteq> vec_zero\" \"wa \\<noteq> vec_zero\" \"wb \\<noteq> vec_zero\""], ["proof (state)\nthis:\n  za \\<noteq> vec_zero\n  zb \\<noteq> vec_zero\n  wa \\<noteq> vec_zero\n  wb \\<noteq> vec_zero\n\ngoal (1 subgoal):\n 1. \\<And>complex_homo_coords1 complex_homo_coords2 complex_homo_coords3\n       complex_homo_coords4.\n       \\<lbrakk>complex_homo_coords1 \\<noteq> vec_zero;\n        complex_homo_coords2 \\<noteq> vec_zero;\n        complex_homo_coords3 \\<noteq> vec_zero;\n        complex_homo_coords4 \\<noteq> vec_zero;\n        complex_homo_coords1 \\<approx>\\<^sub>v complex_homo_coords2;\n        complex_homo_coords3 \\<approx>\\<^sub>v complex_homo_coords4\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat complex_homo_coords1\n                            complex_homo_coords3)\n                          (poincare_line_cvec_cmat complex_homo_coords2\n                            complex_homo_coords4)", "assume \"za \\<approx>\\<^sub>v zb\" \"wa \\<approx>\\<^sub>v wb\""], ["proof (state)\nthis:\n  za \\<approx>\\<^sub>v zb\n  wa \\<approx>\\<^sub>v wb\n\ngoal (1 subgoal):\n 1. \\<And>complex_homo_coords1 complex_homo_coords2 complex_homo_coords3\n       complex_homo_coords4.\n       \\<lbrakk>complex_homo_coords1 \\<noteq> vec_zero;\n        complex_homo_coords2 \\<noteq> vec_zero;\n        complex_homo_coords3 \\<noteq> vec_zero;\n        complex_homo_coords4 \\<noteq> vec_zero;\n        complex_homo_coords1 \\<approx>\\<^sub>v complex_homo_coords2;\n        complex_homo_coords3 \\<approx>\\<^sub>v complex_homo_coords4\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat complex_homo_coords1\n                            complex_homo_coords3)\n                          (poincare_line_cvec_cmat complex_homo_coords2\n                            complex_homo_coords4)", "obtain za1 za2 zb1 zb2 wa1 wa2 wb1 wb2 where\n  *: \"(za1, za2) = za\" \"(zb1, zb2) = zb\"\n     \"(wa1, wa2) = wa\" \"(wb1, wb2) = wb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>za1 za2 zb1 zb2 wa1 wa2 wb1 wb2.\n        \\<lbrakk>(za1, za2) = za; (zb1, zb2) = zb; (wa1, wa2) = wa;\n         (wb1, wb2) = wb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases za, cases zb, cases wa, cases wb, auto)"], ["proof (state)\nthis:\n  (za1, za2) = za\n  (zb1, zb2) = zb\n  (wa1, wa2) = wa\n  (wb1, wb2) = wb\n\ngoal (1 subgoal):\n 1. \\<And>complex_homo_coords1 complex_homo_coords2 complex_homo_coords3\n       complex_homo_coords4.\n       \\<lbrakk>complex_homo_coords1 \\<noteq> vec_zero;\n        complex_homo_coords2 \\<noteq> vec_zero;\n        complex_homo_coords3 \\<noteq> vec_zero;\n        complex_homo_coords4 \\<noteq> vec_zero;\n        complex_homo_coords1 \\<approx>\\<^sub>v complex_homo_coords2;\n        complex_homo_coords3 \\<approx>\\<^sub>v complex_homo_coords4\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat complex_homo_coords1\n                            complex_homo_coords3)\n                          (poincare_line_cvec_cmat complex_homo_coords2\n                            complex_homo_coords4)", "obtain kz kw where\n    **: \"kz \\<noteq> 0\" \"kw \\<noteq> 0\" \"zb1 = kz * za1\" \"zb2 = kz * za2\" \"wb1 = kw * wa1\" \"wb2 = kw * wa2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>kz kw.\n        \\<lbrakk>kz \\<noteq> 0; kw \\<noteq> 0; zb1 = kz * za1;\n         zb2 = kz * za2; wb1 = kw * wa1; wb2 = kw * wa2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>za \\<approx>\\<^sub>v zb\\<close> \\<open>wa \\<approx>\\<^sub>v wb\\<close> *[symmetric]"], ["proof (prove)\nusing this:\n  za \\<approx>\\<^sub>v zb\n  wa \\<approx>\\<^sub>v wb\n  za = (za1, za2)\n  zb = (zb1, zb2)\n  wa = (wa1, wa2)\n  wb = (wb1, wb2)\n\ngoal (1 subgoal):\n 1. (\\<And>kz kw.\n        \\<lbrakk>kz \\<noteq> 0; kw \\<noteq> 0; zb1 = kz * za1;\n         zb2 = kz * za2; wb1 = kw * wa1; wb2 = kw * wa2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. \\<And>complex_homo_coords1 complex_homo_coords2 complex_homo_coords3\n       complex_homo_coords4.\n       \\<lbrakk>complex_homo_coords1 \\<noteq> vec_zero;\n        complex_homo_coords2 \\<noteq> vec_zero;\n        complex_homo_coords3 \\<noteq> vec_zero;\n        complex_homo_coords4 \\<noteq> vec_zero;\n        complex_homo_coords1 \\<approx>\\<^sub>v complex_homo_coords2;\n        complex_homo_coords3 \\<approx>\\<^sub>v complex_homo_coords4\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat complex_homo_coords1\n                            complex_homo_coords3)\n                          (poincare_line_cvec_cmat complex_homo_coords2\n                            complex_homo_coords4)", "let ?nom = \"\\<lambda> z1 z2 w1 w2. w1*cnj w2*(z1*cnj z1 + z2*cnj z2) - z1*cnj z2*(w1*cnj w1 + w2*cnj w2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>complex_homo_coords1 complex_homo_coords2 complex_homo_coords3\n       complex_homo_coords4.\n       \\<lbrakk>complex_homo_coords1 \\<noteq> vec_zero;\n        complex_homo_coords2 \\<noteq> vec_zero;\n        complex_homo_coords3 \\<noteq> vec_zero;\n        complex_homo_coords4 \\<noteq> vec_zero;\n        complex_homo_coords1 \\<approx>\\<^sub>v complex_homo_coords2;\n        complex_homo_coords3 \\<approx>\\<^sub>v complex_homo_coords4\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat complex_homo_coords1\n                            complex_homo_coords3)\n                          (poincare_line_cvec_cmat complex_homo_coords2\n                            complex_homo_coords4)", "let ?den = \"\\<lambda> z1 z2 w1 w2. z1*cnj z2*cnj w1*w2 - w1*cnj w2*cnj z1*z2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>complex_homo_coords1 complex_homo_coords2 complex_homo_coords3\n       complex_homo_coords4.\n       \\<lbrakk>complex_homo_coords1 \\<noteq> vec_zero;\n        complex_homo_coords2 \\<noteq> vec_zero;\n        complex_homo_coords3 \\<noteq> vec_zero;\n        complex_homo_coords4 \\<noteq> vec_zero;\n        complex_homo_coords1 \\<approx>\\<^sub>v complex_homo_coords2;\n        complex_homo_coords3 \\<approx>\\<^sub>v complex_homo_coords4\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat complex_homo_coords1\n                            complex_homo_coords3)\n                          (poincare_line_cvec_cmat complex_homo_coords2\n                            complex_homo_coords4)", "show \"circline_eq_cmat (poincare_line_cvec_cmat za wa)\n                         (poincare_line_cvec_cmat zb wb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat za wa)\n     (poincare_line_cvec_cmat zb wb)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat za wa)\n     (poincare_line_cvec_cmat zb wb)", "have \"\\<exists>k. k \\<noteq> 0 \\<and>\n            poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) = cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "proof (cases \"?den za1 za2 wa1 wa2 \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "case True"], ["proof (state)\nthis:\n  za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "hence \"?den zb1 zb2 wb1 wb2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2 \\<noteq> 0", "using **"], ["proof (prove)\nusing this:\n  za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq> 0\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2 \\<noteq> 0", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "let ?k = \"kz * cnj kz * kw * cnj kw\""], ["proof (state)\ngoal (2 subgoals):\n 1. za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "have \"?k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kz * cnj kz * kw * cnj kw \\<noteq> 0", "using **"], ["proof (prove)\nusing this:\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. kz * cnj kz * kw * cnj kw \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  kz * cnj kz * kw * cnj kw \\<noteq> 0\n\ngoal (2 subgoals):\n 1. za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "have \"is_real ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (kz * cnj kz * kw * cnj kw)", "using eq_cnj_iff_real[of ?k]"], ["proof (prove)\nusing this:\n  (cnj (kz * cnj kz * kw * cnj kw) = kz * cnj kz * kw * cnj kw) =\n  is_real (kz * cnj kz * kw * cnj kw)\n\ngoal (1 subgoal):\n 1. is_real (kz * cnj kz * kw * cnj kw)", "by auto"], ["proof (state)\nthis:\n  is_real (kz * cnj kz * kw * cnj kw)\n\ngoal (2 subgoals):\n 1. za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "have \"cor (Re ?k) = ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (Re (kz * cnj kz * kw * cnj kw)) = kz * cnj kz * kw * cnj kw", "using \\<open>is_real ?k\\<close>"], ["proof (prove)\nusing this:\n  is_real (kz * cnj kz * kw * cnj kw)\n\ngoal (1 subgoal):\n 1. cor (Re (kz * cnj kz * kw * cnj kw)) = kz * cnj kz * kw * cnj kw", "using complex_of_real_Re"], ["proof (prove)\nusing this:\n  is_real (kz * cnj kz * kw * cnj kw)\n  is_real ?k \\<Longrightarrow> cor (Re ?k) = ?k\n\ngoal (1 subgoal):\n 1. cor (Re (kz * cnj kz * kw * cnj kw)) = kz * cnj kz * kw * cnj kw", "by blast"], ["proof (state)\nthis:\n  cor (Re (kz * cnj kz * kw * cnj kw)) = kz * cnj kz * kw * cnj kw\n\ngoal (2 subgoals):\n 1. za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "have \"Re ?k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (kz * cnj kz * kw * cnj kw) \\<noteq> 0", "using \\<open>?k \\<noteq> 0\\<close> \\<open>cor (Re ?k) = ?k\\<close>"], ["proof (prove)\nusing this:\n  kz * cnj kz * kw * cnj kw \\<noteq> 0\n  cor (Re (kz * cnj kz * kw * cnj kw)) = kz * cnj kz * kw * cnj kw\n\ngoal (1 subgoal):\n 1. Re (kz * cnj kz * kw * cnj kw) \\<noteq> 0", "by (metis of_real_0)"], ["proof (state)\nthis:\n  Re (kz * cnj kz * kw * cnj kw) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "have arg1: \"Re (\\<i> * ?den zb1 zb2 wb1 wb2) = Re ?k * Re (\\<i> * ?den za1 za2 wa1 wa2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (\\<i> *\n        (zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2)) =\n    Re (kz * cnj kz * kw * cnj kw) *\n    Re (\\<i> *\n        (za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2))", "apply (subst **)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (\\<i> *\n        (kz * za1 * cnj (kz * za2) * cnj (kw * wa1) * (kw * wa2) -\n         kw * wa1 * cnj (kw * wa2) * cnj (kz * za1) * (kz * za2))) =\n    Re (kz * cnj kz * kw * cnj kw) *\n    Re (\\<i> *\n        (za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2))", "apply (subst Re_mult_real[symmetric, OF \\<open>is_real ?k\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (\\<i> *\n        (kz * za1 * cnj (kz * za2) * cnj (kw * wa1) * (kw * wa2) -\n         kw * wa1 * cnj (kw * wa2) * cnj (kz * za1) * (kz * za2))) =\n    Re (kz * cnj kz * kw * cnj kw *\n        (\\<i> *\n         (za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2)))", "apply (rule arg_cong[where f=Re])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> *\n    (kz * za1 * cnj (kz * za2) * cnj (kw * wa1) * (kw * wa2) -\n     kw * wa1 * cnj (kw * wa2) * cnj (kz * za1) * (kz * za2)) =\n    kz * cnj kz * kw * cnj kw *\n    (\\<i> * (za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2))", "apply (simp add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re (\\<i> *\n      (zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2)) =\n  Re (kz * cnj kz * kw * cnj kw) *\n  Re (\\<i> *\n      (za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2))\n\ngoal (2 subgoals):\n 1. za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "have arg2: \"\\<i> * ?nom zb1 zb2 wb1 wb2 = ?k * \\<i> * ?nom za1 za2 wa1 wa2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> *\n    (wb1 * cnj wb2 * (zb1 * cnj zb1 + zb2 * cnj zb2) -\n     zb1 * cnj zb2 * (wb1 * cnj wb1 + wb2 * cnj wb2)) =\n    kz * cnj kz * kw * cnj kw * \\<i> *\n    (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n     za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2))", "using **"], ["proof (prove)\nusing this:\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. \\<i> *\n    (wb1 * cnj wb2 * (zb1 * cnj zb1 + zb2 * cnj zb2) -\n     zb1 * cnj zb2 * (wb1 * cnj wb1 + wb2 * cnj wb2)) =\n    kz * cnj kz * kw * cnj kw * \\<i> *\n    (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n     za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  \\<i> *\n  (wb1 * cnj wb2 * (zb1 * cnj zb1 + zb2 * cnj zb2) -\n   zb1 * cnj zb2 * (wb1 * cnj wb1 + wb2 * cnj wb2)) =\n  kz * cnj kz * kw * cnj kw * \\<i> *\n  (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n   za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2))\n\ngoal (2 subgoals):\n 1. za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "have \"mk_poincare_line_cmat (Re (\\<i>*?den zb1 zb2 wb1 wb2)) (\\<i>*?nom zb1 zb2 wb1 wb2) =\n            cor (Re ?k) *\\<^sub>s\\<^sub>m mk_poincare_line_cmat (Re (\\<i>*?den za1 za2 wa1 wa2)) (\\<i>*?nom za1 za2 wa1 wa2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poincare_line_cmat\n     (Re (\\<i> *\n          (zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2)))\n     (\\<i> *\n      (wb1 * cnj wb2 * (zb1 * cnj zb1 + zb2 * cnj zb2) -\n       zb1 * cnj zb2 * (wb1 * cnj wb1 + wb2 * cnj wb2))) =\n    cor (Re (kz * cnj kz * kw * cnj kw)) *\\<^sub>s\\<^sub>m\n    mk_poincare_line_cmat\n     (Re (\\<i> *\n          (za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2)))\n     (\\<i> *\n      (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n       za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2)))", "using \\<open>cor (Re ?k) = ?k\\<close> \\<open>is_real ?k\\<close>"], ["proof (prove)\nusing this:\n  cor (Re (kz * cnj kz * kw * cnj kw)) = kz * cnj kz * kw * cnj kw\n  is_real (kz * cnj kz * kw * cnj kw)\n\ngoal (1 subgoal):\n 1. mk_poincare_line_cmat\n     (Re (\\<i> *\n          (zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2)))\n     (\\<i> *\n      (wb1 * cnj wb2 * (zb1 * cnj zb1 + zb2 * cnj zb2) -\n       zb1 * cnj zb2 * (wb1 * cnj wb1 + wb2 * cnj wb2))) =\n    cor (Re (kz * cnj kz * kw * cnj kw)) *\\<^sub>s\\<^sub>m\n    mk_poincare_line_cmat\n     (Re (\\<i> *\n          (za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2)))\n     (\\<i> *\n      (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n       za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2)))", "apply (subst mk_poincare_line_cmat_scale)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cor (Re (kz * cnj kz * kw * cnj kw)) =\n             kz * cnj kz * kw * cnj kw;\n     is_real (kz * cnj kz * kw * cnj kw)\\<rbrakk>\n    \\<Longrightarrow> mk_poincare_line_cmat\n                       (Re (\\<i> *\n                            (zb1 * cnj zb2 * cnj wb1 * wb2 -\n                             wb1 * cnj wb2 * cnj zb1 * zb2)))\n                       (\\<i> *\n                        (wb1 * cnj wb2 * (zb1 * cnj zb1 + zb2 * cnj zb2) -\n                         zb1 * cnj zb2 * (wb1 * cnj wb1 + wb2 * cnj wb2))) =\n                      mk_poincare_line_cmat\n                       (Re (kz * cnj kz * kw * cnj kw) *\n                        Re (\\<i> *\n                            (za1 * cnj za2 * cnj wa1 * wa2 -\n                             wa1 * cnj wa2 * cnj za1 * za2)))\n                       (cor (Re (kz * cnj kz * kw * cnj kw)) *\n                        (\\<i> *\n                         (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n                          za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2))))", "apply (subst arg1, subst arg2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cor (Re (kz * cnj kz * kw * cnj kw)) =\n             kz * cnj kz * kw * cnj kw;\n     is_real (kz * cnj kz * kw * cnj kw)\\<rbrakk>\n    \\<Longrightarrow> mk_poincare_line_cmat\n                       (Re (kz * cnj kz * kw * cnj kw) *\n                        Re (\\<i> *\n                            (za1 * cnj za2 * cnj wa1 * wa2 -\n                             wa1 * cnj wa2 * cnj za1 * za2)))\n                       (kz * cnj kz * kw * cnj kw * \\<i> *\n                        (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n                         za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2))) =\n                      mk_poincare_line_cmat\n                       (Re (kz * cnj kz * kw * cnj kw) *\n                        Re (\\<i> *\n                            (za1 * cnj za2 * cnj wa1 * wa2 -\n                             wa1 * cnj wa2 * cnj za1 * za2)))\n                       (cor (Re (kz * cnj kz * kw * cnj kw)) *\n                        (\\<i> *\n                         (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n                          za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2))))", "apply (subst \\<open>cor (Re ?k) = ?k\\<close>)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cor (Re (kz * cnj kz * kw * cnj kw)) =\n             kz * cnj kz * kw * cnj kw;\n     is_real (kz * cnj kz * kw * cnj kw)\\<rbrakk>\n    \\<Longrightarrow> mk_poincare_line_cmat\n                       (Re (kz * cnj kz * kw * cnj kw) *\n                        Re (\\<i> *\n                            (za1 * cnj za2 * cnj wa1 * wa2 -\n                             wa1 * cnj wa2 * cnj za1 * za2)))\n                       (kz * cnj kz * kw * cnj kw * \\<i> *\n                        (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n                         za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2))) =\n                      mk_poincare_line_cmat\n                       (Re (kz * cnj kz * kw * cnj kw) *\n                        Re (\\<i> *\n                            (za1 * cnj za2 * cnj wa1 * wa2 -\n                             wa1 * cnj wa2 * cnj za1 * za2)))\n                       (kz * cnj kz * kw * cnj kw *\n                        (\\<i> *\n                         (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n                          za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2))))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mk_poincare_line_cmat\n   (Re (\\<i> *\n        (zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2)))\n   (\\<i> *\n    (wb1 * cnj wb2 * (zb1 * cnj zb1 + zb2 * cnj zb2) -\n     zb1 * cnj zb2 * (wb1 * cnj wb1 + wb2 * cnj wb2))) =\n  cor (Re (kz * cnj kz * kw * cnj kw)) *\\<^sub>s\\<^sub>m\n  mk_poincare_line_cmat\n   (Re (\\<i> *\n        (za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2)))\n   (\\<i> *\n    (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n     za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2)))\n\ngoal (2 subgoals):\n 1. za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mk_poincare_line_cmat\n   (Re (\\<i> *\n        (zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2)))\n   (\\<i> *\n    (wb1 * cnj wb2 * (zb1 * cnj zb1 + zb2 * cnj zb2) -\n     zb1 * cnj zb2 * (wb1 * cnj wb1 + wb2 * cnj wb2))) =\n  cor (Re (kz * cnj kz * kw * cnj kw)) *\\<^sub>s\\<^sub>m\n  mk_poincare_line_cmat\n   (Re (\\<i> *\n        (za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2)))\n   (\\<i> *\n    (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n     za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2)))\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "using \\<open>?den za1 za2 wa1 wa2 \\<noteq> 0\\<close> \\<open>?den zb1 zb2 wb1 wb2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  mk_poincare_line_cmat\n   (Re (\\<i> *\n        (zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2)))\n   (\\<i> *\n    (wb1 * cnj wb2 * (zb1 * cnj zb1 + zb2 * cnj zb2) -\n     zb1 * cnj zb2 * (wb1 * cnj wb1 + wb2 * cnj wb2))) =\n  cor (Re (kz * cnj kz * kw * cnj kw)) *\\<^sub>s\\<^sub>m\n  mk_poincare_line_cmat\n   (Re (\\<i> *\n        (za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2)))\n   (\\<i> *\n    (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n     za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2)))\n  za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq> 0\n  zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "using \\<open>Re ?k \\<noteq> 0\\<close> \\<open>cor (Re ?k) = ?k\\<close>"], ["proof (prove)\nusing this:\n  mk_poincare_line_cmat\n   (Re (\\<i> *\n        (zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2)))\n   (\\<i> *\n    (wb1 * cnj wb2 * (zb1 * cnj zb1 + zb2 * cnj zb2) -\n     zb1 * cnj zb2 * (wb1 * cnj wb1 + wb2 * cnj wb2))) =\n  cor (Re (kz * cnj kz * kw * cnj kw)) *\\<^sub>s\\<^sub>m\n  mk_poincare_line_cmat\n   (Re (\\<i> *\n        (za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2)))\n   (\\<i> *\n    (wa1 * cnj wa2 * (za1 * cnj za1 + za2 * cnj za2) -\n     za1 * cnj za2 * (wa1 * cnj wa1 + wa2 * cnj wa2)))\n  za1 * cnj za2 * cnj wa1 * wa2 - wa1 * cnj wa2 * cnj za1 * za2 \\<noteq> 0\n  zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2 \\<noteq> 0\n  Re (kz * cnj kz * kw * cnj kw) \\<noteq> 0\n  cor (Re (kz * cnj kz * kw * cnj kw)) = kz * cnj kz * kw * cnj kw\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "by (rule_tac x=\"Re ?k\" in exI, simp)"], ["proof (state)\nthis:\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n     cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n\ngoal (1 subgoal):\n 1. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "case False"], ["proof (state)\nthis:\n  \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n         wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n         0\n\ngoal (1 subgoal):\n 1. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "hence \"?den zb1 zb2 wb1 wb2 = 0\""], ["proof (prove)\nusing this:\n  \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n         wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n         0\n\ngoal (1 subgoal):\n 1. zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2 = 0", "using **"], ["proof (prove)\nusing this:\n  \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n         wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n         0\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2 = 0", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2 = 0\n\ngoal (1 subgoal):\n 1. \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n           wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n           0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "proof (cases \"za1*cnj za2 \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "case True"], ["proof (state)\nthis:\n  za1 * cnj za2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "hence \"zb1*cnj zb2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  za1 * cnj za2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. zb1 * cnj zb2 \\<noteq> 0", "using **"], ["proof (prove)\nusing this:\n  za1 * cnj za2 \\<noteq> 0\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. zb1 * cnj zb2 \\<noteq> 0", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  zb1 * cnj zb2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "let ?k = \"kz * cnj kz\""], ["proof (state)\ngoal (2 subgoals):\n 1. za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "have \"?k \\<noteq> 0\" \"is_real ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kz * cnj kz \\<noteq> 0 &&& is_real (kz * cnj kz)", "using **"], ["proof (prove)\nusing this:\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. kz * cnj kz \\<noteq> 0 &&& is_real (kz * cnj kz)", "using eq_cnj_iff_real[of ?k]"], ["proof (prove)\nusing this:\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n  (cnj (kz * cnj kz) = kz * cnj kz) = is_real (kz * cnj kz)\n\ngoal (1 subgoal):\n 1. kz * cnj kz \\<noteq> 0 &&& is_real (kz * cnj kz)", "by auto"], ["proof (state)\nthis:\n  kz * cnj kz \\<noteq> 0\n  is_real (kz * cnj kz)\n\ngoal (2 subgoals):\n 1. za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  kz * cnj kz \\<noteq> 0\n  is_real (kz * cnj kz)\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "using \\<open>za1 * cnj za2 \\<noteq> 0\\<close> \\<open>zb1 * cnj zb2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  kz * cnj kz \\<noteq> 0\n  is_real (kz * cnj kz)\n  za1 * cnj za2 \\<noteq> 0\n  zb1 * cnj zb2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "using \\<open>\\<not> (?den za1 za2 wa1 wa2 \\<noteq> 0)\\<close> \\<open>?den zb1 zb2 wb1 wb2 = 0\\<close> **"], ["proof (prove)\nusing this:\n  kz * cnj kz \\<noteq> 0\n  is_real (kz * cnj kz)\n  za1 * cnj za2 \\<noteq> 0\n  zb1 * cnj zb2 \\<noteq> 0\n  \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n         wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n         0\n  zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2 = 0\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "by (rule_tac x=\"Re (kz * cnj kz)\" in exI, auto simp add: complex.expand)"], ["proof (state)\nthis:\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n     cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n\ngoal (1 subgoal):\n 1. \\<not> za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "case False"], ["proof (state)\nthis:\n  \\<not> za1 * cnj za2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "hence \"zb1 * cnj zb2 = 0\""], ["proof (prove)\nusing this:\n  \\<not> za1 * cnj za2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. zb1 * cnj zb2 = 0", "using **"], ["proof (prove)\nusing this:\n  \\<not> za1 * cnj za2 \\<noteq> 0\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. zb1 * cnj zb2 = 0", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  zb1 * cnj zb2 = 0\n\ngoal (1 subgoal):\n 1. \\<not> za1 * cnj za2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "proof (cases \"wa1 * cnj wa2 \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "case True"], ["proof (state)\nthis:\n  wa1 * cnj wa2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "hence \"wb1*cnj wb2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  wa1 * cnj wa2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. wb1 * cnj wb2 \\<noteq> 0", "using **"], ["proof (prove)\nusing this:\n  wa1 * cnj wa2 \\<noteq> 0\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. wb1 * cnj wb2 \\<noteq> 0", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  wb1 * cnj wb2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "let ?k = \"kw * cnj kw\""], ["proof (state)\ngoal (2 subgoals):\n 1. wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "have \"?k \\<noteq> 0\" \"is_real ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kw * cnj kw \\<noteq> 0 &&& is_real (kw * cnj kw)", "using **"], ["proof (prove)\nusing this:\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. kw * cnj kw \\<noteq> 0 &&& is_real (kw * cnj kw)", "using eq_cnj_iff_real[of ?k]"], ["proof (prove)\nusing this:\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n  (cnj (kw * cnj kw) = kw * cnj kw) = is_real (kw * cnj kw)\n\ngoal (1 subgoal):\n 1. kw * cnj kw \\<noteq> 0 &&& is_real (kw * cnj kw)", "by auto"], ["proof (state)\nthis:\n  kw * cnj kw \\<noteq> 0\n  is_real (kw * cnj kw)\n\ngoal (2 subgoals):\n 1. wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n 2. \\<not> wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  kw * cnj kw \\<noteq> 0\n  is_real (kw * cnj kw)\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "using \\<open>\\<not> (za1 * cnj za2 \\<noteq> 0)\\<close>"], ["proof (prove)\nusing this:\n  kw * cnj kw \\<noteq> 0\n  is_real (kw * cnj kw)\n  \\<not> za1 * cnj za2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "using \\<open>wa1 * cnj wa2 \\<noteq> 0\\<close> \\<open>wb1 * cnj wb2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  kw * cnj kw \\<noteq> 0\n  is_real (kw * cnj kw)\n  \\<not> za1 * cnj za2 \\<noteq> 0\n  wa1 * cnj wa2 \\<noteq> 0\n  wb1 * cnj wb2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "using \\<open>\\<not> (?den za1 za2 wa1 wa2 \\<noteq> 0)\\<close> \\<open>?den zb1 zb2 wb1 wb2 = 0\\<close> **"], ["proof (prove)\nusing this:\n  kw * cnj kw \\<noteq> 0\n  is_real (kw * cnj kw)\n  \\<not> za1 * cnj za2 \\<noteq> 0\n  wa1 * cnj wa2 \\<noteq> 0\n  wb1 * cnj wb2 \\<noteq> 0\n  \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n         wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n         0\n  zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2 = 0\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "by (rule_tac x=\"Re (kw * cnj kw)\" in exI) \n               (auto simp add: complex.expand)"], ["proof (state)\nthis:\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n     cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n\ngoal (1 subgoal):\n 1. \\<not> wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "case False"], ["proof (state)\nthis:\n  \\<not> wa1 * cnj wa2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "hence \"wb1 * cnj wb2 = 0\""], ["proof (prove)\nusing this:\n  \\<not> wa1 * cnj wa2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. wb1 * cnj wb2 = 0", "using **"], ["proof (prove)\nusing this:\n  \\<not> wa1 * cnj wa2 \\<noteq> 0\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. wb1 * cnj wb2 = 0", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  wb1 * cnj wb2 = 0\n\ngoal (1 subgoal):\n 1. \\<not> wa1 * cnj wa2 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  wb1 * cnj wb2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "using \\<open>\\<not> (za1 * cnj za2 \\<noteq> 0)\\<close> \\<open>zb1 * cnj zb2 = 0\\<close>"], ["proof (prove)\nusing this:\n  wb1 * cnj wb2 = 0\n  \\<not> za1 * cnj za2 \\<noteq> 0\n  zb1 * cnj zb2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "using \\<open>\\<not> (wa1 * cnj wa2 \\<noteq> 0)\\<close> \\<open>wb1 * cnj wb2 = 0\\<close>"], ["proof (prove)\nusing this:\n  wb1 * cnj wb2 = 0\n  \\<not> za1 * cnj za2 \\<noteq> 0\n  zb1 * cnj zb2 = 0\n  \\<not> wa1 * cnj wa2 \\<noteq> 0\n  wb1 * cnj wb2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "using \\<open>\\<not> (?den za1 za2 wa1 wa2 \\<noteq> 0)\\<close> \\<open>?den zb1 zb2 wb1 wb2 = 0\\<close> **"], ["proof (prove)\nusing this:\n  wb1 * cnj wb2 = 0\n  \\<not> za1 * cnj za2 \\<noteq> 0\n  zb1 * cnj zb2 = 0\n  \\<not> wa1 * cnj wa2 \\<noteq> 0\n  wb1 * cnj wb2 = 0\n  \\<not> za1 * cnj za2 * cnj wa1 * wa2 -\n         wa1 * cnj wa2 * cnj za1 * za2 \\<noteq>\n         0\n  zb1 * cnj zb2 * cnj wb1 * wb2 - wb1 * cnj wb2 * cnj zb1 * zb2 = 0\n  kz \\<noteq> 0\n  kw \\<noteq> 0\n  zb1 = kz * za1\n  zb2 = kz * za2\n  wb1 = kw * wa1\n  wb2 = kw * wa2\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> 0 \\<and>\n       poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n       cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)", "by simp"], ["proof (state)\nthis:\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n     cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n     cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n     cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n     cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat za wa)\n     (poincare_line_cvec_cmat zb wb)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n     cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat za wa)\n     (poincare_line_cvec_cmat zb wb)", "using *[symmetric]"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     k \\<noteq> 0 \\<and>\n     poincare_line_cvec_cmat (zb1, zb2) (wb1, wb2) =\n     cor k *\\<^sub>s\\<^sub>m poincare_line_cvec_cmat (za1, za2) (wa1, wa2)\n  za = (za1, za2)\n  zb = (zb1, zb2)\n  wa = (wa1, wa2)\n  wb = (wb1, wb2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat za wa)\n     (poincare_line_cvec_cmat zb wb)", "by simp"], ["proof (state)\nthis:\n  circline_eq_cmat (poincare_line_cvec_cmat za wa)\n   (poincare_line_cvec_cmat zb wb)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  circline_eq_cmat (poincare_line_cvec_cmat za wa)\n   (poincare_line_cvec_cmat zb wb)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Correctness of the construction\\<close>"], ["", "text\\<open>For finite points, our definition matches the classic algebraic definition for points in\n$\\mathbb{C}$ (given in ordinary, not homogenous coordinates).\\<close>"], ["", "lemma poincare_line_non_homogenous:\n  assumes \"u \\<noteq> \\<infinity>\\<^sub>h\" \"v \\<noteq> \\<infinity>\\<^sub>h\" \"u \\<noteq> v\" \"u \\<noteq> inversion v\"\n  shows \"let u' = to_complex u;  v' = to_complex v;\n             A = \\<i> * (u' * cnj v' - v' * cnj u');\n             B = \\<i> * (v' * ((cmod u')\\<^sup>2 + 1) - u' * ((cmod v')\\<^sup>2 + 1))\n          in poincare_line u v = mk_circline A B (cnj B) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let u' = to_complex u; v' = to_complex v;\n        A = \\<i> * (u' * cnj v' - v' * cnj u');\n        B = \\<i> *\n            (v' * cor ((cmod u')\\<^sup>2 + 1) -\n             u' * cor ((cmod v')\\<^sup>2 + 1))\n    in poincare_line u v = mk_circline A B (cnj B) A", "using assms"], ["proof (prove)\nusing this:\n  u \\<noteq> \\<infinity>\\<^sub>h\n  v \\<noteq> \\<infinity>\\<^sub>h\n  u \\<noteq> v\n  u \\<noteq> inversion v\n\ngoal (1 subgoal):\n 1. let u' = to_complex u; v' = to_complex v;\n        A = \\<i> * (u' * cnj v' - v' * cnj u');\n        B = \\<i> *\n            (v' * cor ((cmod u')\\<^sup>2 + 1) -\n             u' * cor ((cmod v')\\<^sup>2 + 1))\n    in poincare_line u v = mk_circline A B (cnj B) A", "unfolding unit_disc_def disc_def inversion_def"], ["proof (prove)\nusing this:\n  u \\<noteq> \\<infinity>\\<^sub>h\n  v \\<noteq> \\<infinity>\\<^sub>h\n  u \\<noteq> v\n  u \\<noteq> (conjugate \\<circ> reciprocal) v\n\ngoal (1 subgoal):\n 1. let u' = to_complex u; v' = to_complex v;\n        A = \\<i> * (u' * cnj v' - v' * cnj u');\n        B = \\<i> *\n            (v' * cor ((cmod u')\\<^sup>2 + 1) -\n             u' * cor ((cmod v')\\<^sup>2 + 1))\n    in poincare_line u v = mk_circline A B (cnj B) A", "apply (simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<noteq> \\<infinity>\\<^sub>h; v \\<noteq> \\<infinity>\\<^sub>h;\n     u \\<noteq> v; u \\<noteq> conjugate (reciprocal v)\\<rbrakk>\n    \\<Longrightarrow> poincare_line u v =\n                      mk_circline\n                       (\\<i> *\n                        (to_complex u * cnj (to_complex v) -\n                         to_complex v * cnj (to_complex u)))\n                       (\\<i> *\n                        (to_complex v *\n                         ((cor (cmod (to_complex u)))\\<^sup>2 + 1) -\n                         to_complex u *\n                         ((cor (cmod (to_complex v)))\\<^sup>2 + 1)))\n                       (- (\\<i> *\n                           (cnj (to_complex v) *\n                            ((cor (cmod (to_complex u)))\\<^sup>2 + 1) -\n                            cnj (to_complex u) *\n                            ((cor (cmod (to_complex v)))\\<^sup>2 + 1))))\n                       (\\<i> *\n                        (to_complex u * cnj (to_complex v) -\n                         to_complex v * cnj (to_complex u)))", "proof (transfer, transfer, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "fix u1 u2 v1 v2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "assume uv: \"(u1, u2) \\<noteq> vec_zero\" \"(v1, v2) \\<noteq> vec_zero\" \n             \"\\<not> (u1, u2) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v\" \"\\<not> (v1, v2) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v\"            \n             \"\\<not> (u1, u2) \\<approx>\\<^sub>v (v1, v2)\" \"\\<not> (u1, u2) \\<approx>\\<^sub>v conjugate_cvec (reciprocal_cvec (v1, v2))\""], ["proof (state)\nthis:\n  (u1, u2) \\<noteq> vec_zero\n  (v1, v2) \\<noteq> vec_zero\n  \\<not> (u1, u2) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v\n  \\<not> (v1, v2) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (v1, v2)\n  \\<not> (u1, u2) \\<approx>\\<^sub>v\n         conjugate_cvec (reciprocal_cvec (v1, v2))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "let ?u = \"to_complex_cvec (u1, u2)\" and ?v = \"to_complex_cvec (v1, v2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "let ?A = \"\\<i> * (?u * cnj ?v - ?v * cnj ?u)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "let ?B = \"\\<i> * (?v * ((cor (cmod ?u))\\<^sup>2 + 1) - ?u * ((cor (cmod ?v))\\<^sup>2 + 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "let ?C = \"- (\\<i> * (cnj ?v * ((cor (cmod ?u))\\<^sup>2 + 1) - cnj ?u * ((cor (cmod ?v))\\<^sup>2 + 1)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "let ?D = ?A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "let ?H = \"(?A, ?B, ?C, ?D)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "let ?den = \"u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "have \"u2 \\<noteq> 0\" \"v2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u2 \\<noteq> 0 &&& v2 \\<noteq> 0", "using uv"], ["proof (prove)\nusing this:\n  (u1, u2) \\<noteq> vec_zero\n  (v1, v2) \\<noteq> vec_zero\n  \\<not> (u1, u2) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v\n  \\<not> (v1, v2) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (v1, v2)\n  \\<not> (u1, u2) \\<approx>\\<^sub>v\n         conjugate_cvec (reciprocal_cvec (v1, v2))\n\ngoal (1 subgoal):\n 1. u2 \\<noteq> 0 &&& v2 \\<noteq> 0", "using inf_cvec_z2_zero_iff"], ["proof (prove)\nusing this:\n  (u1, u2) \\<noteq> vec_zero\n  (v1, v2) \\<noteq> vec_zero\n  \\<not> (u1, u2) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v\n  \\<not> (v1, v2) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (v1, v2)\n  \\<not> (u1, u2) \\<approx>\\<^sub>v\n         conjugate_cvec (reciprocal_cvec (v1, v2))\n  (?z1.0, ?z2.0) \\<noteq> vec_zero \\<Longrightarrow>\n  ((?z1.0, ?z2.0) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v) = (?z2.0 = 0)\n\ngoal (1 subgoal):\n 1. u2 \\<noteq> 0 &&& v2 \\<noteq> 0", "by blast+"], ["proof (state)\nthis:\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "have \"\\<not> (u1, u2) \\<approx>\\<^sub>v (cnj v2, cnj v1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (u1, u2) \\<approx>\\<^sub>v (cnj v2, cnj v1)", "using uv(6)"], ["proof (prove)\nusing this:\n  \\<not> (u1, u2) \\<approx>\\<^sub>v\n         conjugate_cvec (reciprocal_cvec (v1, v2))\n\ngoal (1 subgoal):\n 1. \\<not> (u1, u2) \\<approx>\\<^sub>v (cnj v2, cnj v1)", "by (simp add: vec_cnj_def)"], ["proof (state)\nthis:\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (cnj v2, cnj v1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "moreover"], ["proof (state)\nthis:\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (cnj v2, cnj v1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "have \"(cnj v2, cnj v1) \\<noteq> vec_zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnj v2, cnj v1) \\<noteq> vec_zero", "using uv(2)"], ["proof (prove)\nusing this:\n  (v1, v2) \\<noteq> vec_zero\n\ngoal (1 subgoal):\n 1. (cnj v2, cnj v1) \\<noteq> vec_zero", "by auto"], ["proof (state)\nthis:\n  (cnj v2, cnj v1) \\<noteq> vec_zero\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (cnj v2, cnj v1)\n  (cnj v2, cnj v1) \\<noteq> vec_zero", "have *: \"u1 * cnj v1 \\<noteq> u2 * cnj v2\" \"u1 * v2 \\<noteq> u2 * v1\""], ["proof (prove)\nusing this:\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (cnj v2, cnj v1)\n  (cnj v2, cnj v1) \\<noteq> vec_zero\n\ngoal (1 subgoal):\n 1. u1 * cnj v1 \\<noteq> u2 * cnj v2 &&& u1 * v2 \\<noteq> u2 * v1", "using uv(5) uv(1) uv(2) \\<open>u2 \\<noteq> 0\\<close> \\<open>v2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (cnj v2, cnj v1)\n  (cnj v2, cnj v1) \\<noteq> vec_zero\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (v1, v2)\n  (u1, u2) \\<noteq> vec_zero\n  (v1, v2) \\<noteq> vec_zero\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u1 * cnj v1 \\<noteq> u2 * cnj v2 &&& u1 * v2 \\<noteq> u2 * v1", "using complex_cvec_eq_mix"], ["proof (prove)\nusing this:\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (cnj v2, cnj v1)\n  (cnj v2, cnj v1) \\<noteq> vec_zero\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (v1, v2)\n  (u1, u2) \\<noteq> vec_zero\n  (v1, v2) \\<noteq> vec_zero\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  \\<lbrakk>(?z1.0, ?z2.0) \\<noteq> vec_zero;\n   (?w1.0, ?w2.0) \\<noteq> vec_zero\\<rbrakk>\n  \\<Longrightarrow> ((?z1.0, ?z2.0) \\<approx>\\<^sub>v (?w1.0, ?w2.0)) =\n                    (?z1.0 * ?w2.0 = ?z2.0 * ?w1.0)\n\ngoal (1 subgoal):\n 1. u1 * cnj v1 \\<noteq> u2 * cnj v2 &&& u1 * v2 \\<noteq> u2 * v1", "by blast+"], ["proof (state)\nthis:\n  u1 * cnj v1 \\<noteq> u2 * cnj v2\n  u1 * v2 \\<noteq> u2 * v1\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<noteq> vec_zero; (aa, ba) \\<noteq> vec_zero;\n        \\<not> (a, b) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (aa, ba) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v;\n        \\<not> (a, b) \\<approx>\\<^sub>v (aa, ba);\n        \\<not> (a, b) \\<approx>\\<^sub>v\n               conjugate_cvec (reciprocal_cvec (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> circline_eq_cmat\n                          (poincare_line_cvec_cmat (a, b) (aa, ba))\n                          (mk_circline_cmat\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b))))\n                            (\\<i> *\n                             (to_complex_cvec (aa, ba) *\n                              ((cor (cmod\n(to_complex_cvec (a, b))))\\<^sup>2 +\n                               1) -\n                              to_complex_cvec (a, b) *\n                              ((cor (cmod\n(to_complex_cvec (aa, ba))))\\<^sup>2 +\n                               1)))\n                            (- (\\<i> *\n                                (cnj (to_complex_cvec (aa, ba)) *\n                                 ((cor (cmod\n   (to_complex_cvec (a, b))))\\<^sup>2 +\n                                  1) -\n                                 cnj (to_complex_cvec (a, b)) *\n                                 ((cor (cmod\n   (to_complex_cvec (aa, ba))))\\<^sup>2 +\n                                  1))))\n                            (\\<i> *\n                             (to_complex_cvec (a, b) *\n                              cnj (to_complex_cvec (aa, ba)) -\n                              to_complex_cvec (aa, ba) *\n                              cnj (to_complex_cvec (a, b)))))", "show \"circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n                         (mk_circline_cmat ?A ?B ?C ?D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "proof (cases \"?den \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n    0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "case True"], ["proof (state)\nthis:\n  u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n    0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "let ?nom = \"v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) - u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)\""], ["proof (state)\ngoal (2 subgoals):\n 1. u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n    0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "let ?H' = \"mk_poincare_line_cmat (Re (\\<i> * ?den)) (\\<i> * ?nom)\""], ["proof (state)\ngoal (2 subgoals):\n 1. u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n    0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "have \"circline_eq_cmat ?H ?H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))", "let ?k = \"(u2 * cnj v2) * (v2 * cnj u2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))", "have \"is_real ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (u2 * cnj v2 * (v2 * cnj u2))", "using eq_cnj_iff_real"], ["proof (prove)\nusing this:\n  (cnj ?z = ?z) = is_real ?z\n\ngoal (1 subgoal):\n 1. is_real (u2 * cnj v2 * (v2 * cnj u2))", "by fastforce"], ["proof (state)\nthis:\n  is_real (u2 * cnj v2 * (v2 * cnj u2))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))", "hence \"cor (Re ?k) = ?k\""], ["proof (prove)\nusing this:\n  is_real (u2 * cnj v2 * (v2 * cnj u2))\n\ngoal (1 subgoal):\n 1. cor (Re (u2 * cnj v2 * (v2 * cnj u2))) = u2 * cnj v2 * (v2 * cnj u2)", "using complex_of_real_Re"], ["proof (prove)\nusing this:\n  is_real (u2 * cnj v2 * (v2 * cnj u2))\n  is_real ?k \\<Longrightarrow> cor (Re ?k) = ?k\n\ngoal (1 subgoal):\n 1. cor (Re (u2 * cnj v2 * (v2 * cnj u2))) = u2 * cnj v2 * (v2 * cnj u2)", "by blast"], ["proof (state)\nthis:\n  cor (Re (u2 * cnj v2 * (v2 * cnj u2))) = u2 * cnj v2 * (v2 * cnj u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))", "have \"Re (\\<i> * ?den) = Re ?k * ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n    cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n    cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "have \"?A = cnj ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))) =\n    cnj (\\<i> *\n         (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n          to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  \\<i> *\n  (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n   to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))) =\n  cnj (\\<i> *\n       (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n        to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n    cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "hence \"is_real ?A\""], ["proof (prove)\nusing this:\n  \\<i> *\n  (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n   to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))) =\n  cnj (\\<i> *\n       (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n        to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal (1 subgoal):\n 1. is_real\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "using eq_cnj_iff_real"], ["proof (prove)\nusing this:\n  \\<i> *\n  (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n   to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))) =\n  cnj (\\<i> *\n       (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n        to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n  (cnj ?z = ?z) = is_real ?z\n\ngoal (1 subgoal):\n 1. is_real\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "by fastforce"], ["proof (state)\nthis:\n  is_real\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n    cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "moreover"], ["proof (state)\nthis:\n  is_real\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n    cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "have \"\\<i> * ?den =  cnj (\\<i> * ?den)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2) =\n    cnj (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  \\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2) =\n  cnj (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n    cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "hence \"is_real (\\<i> * ?den)\""], ["proof (prove)\nusing this:\n  \\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2) =\n  cnj (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))\n\ngoal (1 subgoal):\n 1. is_real (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))", "using eq_cnj_iff_real"], ["proof (prove)\nusing this:\n  \\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2) =\n  cnj (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))\n  (cnj ?z = ?z) = is_real ?z\n\ngoal (1 subgoal):\n 1. is_real (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))", "by fastforce"], ["proof (state)\nthis:\n  is_real (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n    cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "hence \"cor (Re (\\<i> * ?den)) = \\<i> * ?den\""], ["proof (prove)\nusing this:\n  is_real (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n    \\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)", "using complex_of_real_Re"], ["proof (prove)\nusing this:\n  is_real (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))\n  is_real ?k \\<Longrightarrow> cor (Re ?k) = ?k\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n    \\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)", "by blast"], ["proof (state)\nthis:\n  cor (Re (\\<i> *\n           (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n  \\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n    cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "ultimately"], ["proof (chain)\npicking this:\n  is_real\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n  cor (Re (\\<i> *\n           (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n  \\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_real\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n  cor (Re (\\<i> *\n           (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n  \\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n    cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "using \\<open>cor (Re ?k) = ?k\\<close>"], ["proof (prove)\nusing this:\n  is_real\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n  cor (Re (\\<i> *\n           (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n  \\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)\n  cor (Re (u2 * cnj v2 * (v2 * cnj u2))) = u2 * cnj v2 * (v2 * cnj u2)\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n    cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cor (Re (\\<i> *\n           (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n  cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cor (Re (\\<i> *\n           (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n  cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))", "moreover"], ["proof (state)\nthis:\n  cor (Re (\\<i> *\n           (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n  cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))", "have \"\\<i> * ?nom = Re ?k  * ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> *\n    (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n     u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)) =\n    cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n    (\\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))", "using \\<open>cor (Re ?k) = ?k\\<close> \\<open>u2 \\<noteq>  0\\<close> \\<open>v2 \\<noteq> 0\\<close> complex_mult_cnj_cmod[symmetric]"], ["proof (prove)\nusing this:\n  cor (Re (u2 * cnj v2 * (v2 * cnj u2))) = u2 * cnj v2 * (v2 * cnj u2)\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  cor ((cmod ?z)\\<^sup>2) = ?z * cnj ?z\n\ngoal (1 subgoal):\n 1. \\<i> *\n    (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n     u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)) =\n    cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n    (\\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  \\<i> *\n  (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n   u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)) =\n  cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n  (\\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))", "moreover"], ["proof (state)\nthis:\n  \\<i> *\n  (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n   u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)) =\n  cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n  (\\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))", "have \"?k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u2 * cnj v2 * (v2 * cnj u2) \\<noteq> 0", "using \\<open>u2 \\<noteq> 0\\<close> \\<open>v2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u2 * cnj v2 * (v2 * cnj u2) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  u2 * cnj v2 * (v2 * cnj u2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))", "hence \"Re ?k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  u2 * cnj v2 * (v2 * cnj u2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (u2 * cnj v2 * (v2 * cnj u2)) \\<noteq> 0", "using \\<open>is_real ?k\\<close>"], ["proof (prove)\nusing this:\n  u2 * cnj v2 * (v2 * cnj u2) \\<noteq> 0\n  is_real (u2 * cnj v2 * (v2 * cnj u2))\n\ngoal (1 subgoal):\n 1. Re (u2 * cnj v2 * (v2 * cnj u2)) \\<noteq> 0", "by (metis \\<open>cor (Re ?k) = ?k\\<close> of_real_0)"], ["proof (state)\nthis:\n  Re (u2 * cnj v2 * (v2 * cnj u2)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))", "ultimately"], ["proof (chain)\npicking this:\n  cor (Re (\\<i> *\n           (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n  cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n  \\<i> *\n  (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n   u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)) =\n  cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n  (\\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n  Re (u2 * cnj v2 * (v2 * cnj u2)) \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  cor (Re (\\<i> *\n           (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2))) =\n  cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n  \\<i> *\n  (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n   u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)) =\n  cor (Re (u2 * cnj v2 * (v2 * cnj u2))) *\n  (\\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n  Re (u2 * cnj v2 * (v2 * cnj u2)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))", "by simp (rule_tac x=\"Re ?k\" in exI, simp add: mult.commute)"], ["proof (state)\nthis:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n    0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "moreover"], ["proof (state)\nthis:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n    0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "have \"poincare_line_cvec_cmat (u1, u2) (v1, v2) = ?H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n    mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))", "using \\<open>?den \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n    mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))", "unfolding poincare_line_cvec_cmat_def"], ["proof (prove)\nusing this:\n  u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (let (z1, z2) = (u1, u2); (w1, w2) = (v1, v2);\n         nom =\n           w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n           z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2);\n         den = z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2\n     in if den \\<noteq> 0\n        then mk_poincare_line_cmat (Re (\\<i> * den)) (\\<i> * nom)\n        else if z1 * cnj z2 \\<noteq> 0\n             then mk_poincare_line_cmat 0 (\\<i> * z1 * cnj z2)\n             else if w1 * cnj w2 \\<noteq> 0\n                  then mk_poincare_line_cmat 0 (\\<i> * w1 * cnj w2)\n                  else mk_poincare_line_cmat 0 \\<i>) =\n    mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat\n   (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n   (\\<i> *\n    (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n     u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n    0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "moreover"], ["proof (state)\nthis:\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat\n   (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n   (\\<i> *\n    (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n     u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n    0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "hence \"hermitean ?H' \\<and> ?H' \\<noteq> mat_zero\""], ["proof (prove)\nusing this:\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat\n   (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n   (\\<i> *\n    (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n     u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))\n\ngoal (1 subgoal):\n 1. hermitean\n     (mk_poincare_line_cmat\n       (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n       (\\<i> *\n        (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n         u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))) \\<and>\n    mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))) \\<noteq>\n    mat_zero", "by (metis mk_poincare_line_cmat_hermitean poincare_line_cvec_cmat_nonzero uv(1) uv(2))"], ["proof (state)\nthis:\n  hermitean\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))) \\<and>\n  mk_poincare_line_cmat\n   (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n   (\\<i> *\n    (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n     u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))) \\<noteq>\n  mat_zero\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n    0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "hence \"hermitean ?H \\<and> ?H \\<noteq> mat_zero\""], ["proof (prove)\nusing this:\n  hermitean\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))) \\<and>\n  mk_poincare_line_cmat\n   (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n   (\\<i> *\n    (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n     u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))) \\<noteq>\n  mat_zero\n\ngoal (1 subgoal):\n 1. hermitean\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n    mat_zero", "using \\<open>circline_eq_cmat ?H ?H'\\<close>"], ["proof (prove)\nusing this:\n  hermitean\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))) \\<and>\n  mk_poincare_line_cmat\n   (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n   (\\<i> *\n    (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n     u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))) \\<noteq>\n  mat_zero\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))\n\ngoal (1 subgoal):\n 1. hermitean\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n    mat_zero", "using circline_eq_cmat_hermitean_nonzero[of ?H' ?H] symp_circline_eq_cmat"], ["proof (prove)\nusing this:\n  hermitean\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))) \\<and>\n  mk_poincare_line_cmat\n   (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n   (\\<i> *\n    (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n     u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))) \\<noteq>\n  mat_zero\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))\n  \\<lbrakk>hermitean\n            (mk_poincare_line_cmat\n              (Re (\\<i> *\n                   (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n              (\\<i> *\n               (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n                u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))) \\<and>\n           mk_poincare_line_cmat\n            (Re (\\<i> *\n                 (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n            (\\<i> *\n             (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n              u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))) \\<noteq>\n           mat_zero;\n   circline_eq_cmat\n    (mk_poincare_line_cmat\n      (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n      (\\<i> *\n       (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n        u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\\<rbrakk>\n  \\<Longrightarrow> hermitean\n                     (\\<i> *\n                      (to_complex_cvec (u1, u2) *\n                       cnj (to_complex_cvec (v1, v2)) -\n                       to_complex_cvec (v1, v2) *\n                       cnj (to_complex_cvec (u1, u2))),\n                      \\<i> *\n                      (to_complex_cvec (v1, v2) *\n                       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                        1) -\n                       to_complex_cvec (u1, u2) *\n                       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                        1)),\n                      - (\\<i> *\n                         (cnj (to_complex_cvec (v1, v2)) *\n                          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                           1) -\n                          cnj (to_complex_cvec (u1, u2)) *\n                          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                           1))),\n                      \\<i> *\n                      (to_complex_cvec (u1, u2) *\n                       cnj (to_complex_cvec (v1, v2)) -\n                       to_complex_cvec (v1, v2) *\n                       cnj (to_complex_cvec (u1, u2)))) \\<and>\n                    (\\<i> *\n                     (to_complex_cvec (u1, u2) *\n                      cnj (to_complex_cvec (v1, v2)) -\n                      to_complex_cvec (v1, v2) *\n                      cnj (to_complex_cvec (u1, u2))),\n                     \\<i> *\n                     (to_complex_cvec (v1, v2) *\n                      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                       1) -\n                      to_complex_cvec (u1, u2) *\n                      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                       1)),\n                     - (\\<i> *\n                        (cnj (to_complex_cvec (v1, v2)) *\n                         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                          1) -\n                         cnj (to_complex_cvec (u1, u2)) *\n                         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                          1))),\n                     \\<i> *\n                     (to_complex_cvec (u1, u2) *\n                      cnj (to_complex_cvec (v1, v2)) -\n                      to_complex_cvec (v1, v2) *\n                      cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n                    mat_zero\n  symp circline_eq_cmat\n\ngoal (1 subgoal):\n 1. hermitean\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n    mat_zero", "unfolding symp_def"], ["proof (prove)\nusing this:\n  hermitean\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))) \\<and>\n  mk_poincare_line_cmat\n   (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n   (\\<i> *\n    (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n     u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))) \\<noteq>\n  mat_zero\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))\n  \\<lbrakk>hermitean\n            (mk_poincare_line_cmat\n              (Re (\\<i> *\n                   (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n              (\\<i> *\n               (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n                u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))) \\<and>\n           mk_poincare_line_cmat\n            (Re (\\<i> *\n                 (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n            (\\<i> *\n             (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n              u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))) \\<noteq>\n           mat_zero;\n   circline_eq_cmat\n    (mk_poincare_line_cmat\n      (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n      (\\<i> *\n       (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n        u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\\<rbrakk>\n  \\<Longrightarrow> hermitean\n                     (\\<i> *\n                      (to_complex_cvec (u1, u2) *\n                       cnj (to_complex_cvec (v1, v2)) -\n                       to_complex_cvec (v1, v2) *\n                       cnj (to_complex_cvec (u1, u2))),\n                      \\<i> *\n                      (to_complex_cvec (v1, v2) *\n                       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                        1) -\n                       to_complex_cvec (u1, u2) *\n                       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                        1)),\n                      - (\\<i> *\n                         (cnj (to_complex_cvec (v1, v2)) *\n                          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                           1) -\n                          cnj (to_complex_cvec (u1, u2)) *\n                          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                           1))),\n                      \\<i> *\n                      (to_complex_cvec (u1, u2) *\n                       cnj (to_complex_cvec (v1, v2)) -\n                       to_complex_cvec (v1, v2) *\n                       cnj (to_complex_cvec (u1, u2)))) \\<and>\n                    (\\<i> *\n                     (to_complex_cvec (u1, u2) *\n                      cnj (to_complex_cvec (v1, v2)) -\n                      to_complex_cvec (v1, v2) *\n                      cnj (to_complex_cvec (u1, u2))),\n                     \\<i> *\n                     (to_complex_cvec (v1, v2) *\n                      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                       1) -\n                      to_complex_cvec (u1, u2) *\n                      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                       1)),\n                     - (\\<i> *\n                        (cnj (to_complex_cvec (v1, v2)) *\n                         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                          1) -\n                         cnj (to_complex_cvec (u1, u2)) *\n                         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                          1))),\n                     \\<i> *\n                     (to_complex_cvec (u1, u2) *\n                      cnj (to_complex_cvec (v1, v2)) -\n                      to_complex_cvec (v1, v2) *\n                      cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n                    mat_zero\n  \\<forall>x y. circline_eq_cmat x y \\<longrightarrow> circline_eq_cmat y x\n\ngoal (1 subgoal):\n 1. hermitean\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n    mat_zero", "by metis"], ["proof (state)\nthis:\n  hermitean\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n  mat_zero\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n    0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "hence \"mk_circline_cmat ?A ?B ?C ?D = ?H\""], ["proof (prove)\nusing this:\n  hermitean\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n  mat_zero\n\ngoal (1 subgoal):\n 1. mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) =\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "by simp"], ["proof (state)\nthis:\n  mk_circline_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (\\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n   (- (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) =\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n    0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "ultimately"], ["proof (chain)\npicking this:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat\n   (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n   (\\<i> *\n    (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n     u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))\n  mk_circline_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (\\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n   (- (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) =\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "have \"circline_eq_cmat (mk_circline_cmat ?A ?B ?C ?D)\n                           (poincare_line_cvec_cmat (u1, u2) (v1, v2))\""], ["proof (prove)\nusing this:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat\n     (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n     (\\<i> *\n      (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n       u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2))))\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat\n   (Re (\\<i> * (u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2)))\n   (\\<i> *\n    (v1 * cnj v2 * (u1 * cnj u1 + u2 * cnj u2) -\n     u1 * cnj u2 * (v1 * cnj v1 + v2 * cnj v2)))\n  mk_circline_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (\\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n   (- (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) =\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n     (poincare_line_cvec_cmat (u1, u2) (v1, v2))", "by simp"], ["proof (state)\nthis:\n  circline_eq_cmat\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n   (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n    0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  circline_eq_cmat\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n   (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "using symp_circline_eq_cmat"], ["proof (prove)\nusing this:\n  circline_eq_cmat\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n   (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n  symp circline_eq_cmat\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "unfolding symp_def"], ["proof (prove)\nusing this:\n  circline_eq_cmat\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n   (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n  \\<forall>x y. circline_eq_cmat x y \\<longrightarrow> circline_eq_cmat y x\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "by blast"], ["proof (state)\nthis:\n  circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "case False"], ["proof (state)\nthis:\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "let ?d = \"v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 - u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "let ?cd = \"cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 - cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "have \"cnj ?d = ?cd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n         u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) =\n    cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n    cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  cnj (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) =\n  cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n  cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2\n\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "let ?d1 = \"(v1 / v2) * (cnj u1 / cnj u2) - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "let ?d2 = \"u1 / u2 - v1 / v2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "have **: \"?d = ?d1 * ?d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n    u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 =\n    (v1 / v2 * (cnj u1 / cnj u2) - 1) * (u1 / u2 - v1 / v2)", "using \\<open>\\<not> ?den \\<noteq> 0\\<close> \\<open>u2 \\<noteq> 0\\<close> \\<open>v2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n    u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 =\n    (v1 / v2 * (cnj u1 / cnj u2) - 1) * (u1 / u2 - v1 / v2)", "by(simp add: field_simps)"], ["proof (state)\nthis:\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 =\n  (v1 / v2 * (cnj u1 / cnj u2) - 1) * (u1 / u2 - v1 / v2)\n\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "hence \"?d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 =\n  (v1 / v2 * (cnj u1 / cnj u2) - 1) * (u1 / u2 - v1 / v2)\n\ngoal (1 subgoal):\n 1. v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n    u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n    0", "using \\<open>\\<not> ?den \\<noteq> 0\\<close> \\<open>u2 \\<noteq> 0\\<close> \\<open>v2 \\<noteq> 0\\<close> *"], ["proof (prove)\nusing this:\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 =\n  (v1 / v2 * (cnj u1 / cnj u2) - 1) * (u1 / u2 - v1 / v2)\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  u1 * cnj v1 \\<noteq> u2 * cnj v2\n  u1 * v2 \\<noteq> u2 * v1\n\ngoal (1 subgoal):\n 1. v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n    u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n    0", "by auto (simp add: field_simps)+"], ["proof (state)\nthis:\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "have \"is_real ?d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (v1 / v2 * (cnj u1 / cnj u2) - 1)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_real (v1 / v2 * (cnj u1 / cnj u2) - 1)", "have \"cnj ?d1 = ?d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (v1 / v2 * (cnj u1 / cnj u2) - 1) = v1 / v2 * (cnj u1 / cnj u2) - 1", "using \\<open>\\<not> ?den \\<noteq> 0\\<close> \\<open>u2 \\<noteq> 0\\<close> \\<open>v2 \\<noteq> 0\\<close> *"], ["proof (prove)\nusing this:\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  u1 * cnj v1 \\<noteq> u2 * cnj v2\n  u1 * v2 \\<noteq> u2 * v1\n\ngoal (1 subgoal):\n 1. cnj (v1 / v2 * (cnj u1 / cnj u2) - 1) = v1 / v2 * (cnj u1 / cnj u2) - 1", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cnj (v1 / v2 * (cnj u1 / cnj u2) - 1) = v1 / v2 * (cnj u1 / cnj u2) - 1\n\ngoal (1 subgoal):\n 1. is_real (v1 / v2 * (cnj u1 / cnj u2) - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cnj (v1 / v2 * (cnj u1 / cnj u2) - 1) = v1 / v2 * (cnj u1 / cnj u2) - 1\n\ngoal (1 subgoal):\n 1. is_real (v1 / v2 * (cnj u1 / cnj u2) - 1)", "using eq_cnj_iff_real"], ["proof (prove)\nusing this:\n  cnj (v1 / v2 * (cnj u1 / cnj u2) - 1) = v1 / v2 * (cnj u1 / cnj u2) - 1\n  (cnj ?z = ?z) = is_real ?z\n\ngoal (1 subgoal):\n 1. is_real (v1 / v2 * (cnj u1 / cnj u2) - 1)", "by blast"], ["proof (state)\nthis:\n  is_real (v1 / v2 * (cnj u1 / cnj u2) - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_real (v1 / v2 * (cnj u1 / cnj u2) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq>\n           0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "proof (cases \"u1 * cnj u2 \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "case True"], ["proof (state)\nthis:\n  u1 * cnj u2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "let ?nom = \"u1 * cnj u2\""], ["proof (state)\ngoal (2 subgoals):\n 1. u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "let ?H' = \"mk_poincare_line_cmat 0 (\\<i> * ?nom)\""], ["proof (state)\ngoal (2 subgoals):\n 1. u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "have \"circline_eq_cmat ?H ?H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "let ?k = \"(u1 * cnj u2) / ?d\""], ["proof (state)\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "have \"is_real ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real\n     (u1 * cnj u2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_real\n     (u1 * cnj u2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))", "have \"is_real ((u1 * cnj u2) / ?d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (u1 * cnj u2 / (u1 / u2 - v1 / v2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_real (u1 * cnj u2 / (u1 / u2 - v1 / v2))", "let ?rhs = \"(u2 * cnj u2) / (1 - (v1*u2)/(u1*v2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_real (u1 * cnj u2 / (u1 / u2 - v1 / v2))", "have 1: \"(u1 * cnj u2) / ?d2 = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u1 * cnj u2 / (u1 / u2 - v1 / v2) =\n    u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))", "using \\<open>\\<not> ?den \\<noteq> 0\\<close> \\<open>u2 \\<noteq> 0\\<close> \\<open>v2 \\<noteq> 0\\<close> * \\<open>u1 * cnj u2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  u1 * cnj v1 \\<noteq> u2 * cnj v2\n  u1 * v2 \\<noteq> u2 * v1\n  u1 * cnj u2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u1 * cnj u2 / (u1 / u2 - v1 / v2) =\n    u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  u1 * cnj u2 / (u1 / u2 - v1 / v2) =\n  u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))\n\ngoal (1 subgoal):\n 1. is_real (u1 * cnj u2 / (u1 / u2 - v1 / v2))", "moreover"], ["proof (state)\nthis:\n  u1 * cnj u2 / (u1 / u2 - v1 / v2) =\n  u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))\n\ngoal (1 subgoal):\n 1. is_real (u1 * cnj u2 / (u1 / u2 - v1 / v2))", "have \"cnj ?rhs = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))) =\n    u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cnj (u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))) =\n    u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))", "have \"cnj (1 - v1 * u2 / (u1 * v2)) = 1 - v1 * u2 / (u1 * v2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (1 - v1 * u2 / (u1 * v2)) = 1 - v1 * u2 / (u1 * v2)", "using \\<open>\\<not> ?den \\<noteq> 0\\<close> \\<open>u2 \\<noteq> 0\\<close> \\<open>v2 \\<noteq> 0\\<close> * \\<open>u1 * cnj u2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  u1 * cnj v1 \\<noteq> u2 * cnj v2\n  u1 * v2 \\<noteq> u2 * v1\n  u1 * cnj u2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cnj (1 - v1 * u2 / (u1 * v2)) = 1 - v1 * u2 / (u1 * v2)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cnj (1 - v1 * u2 / (u1 * v2)) = 1 - v1 * u2 / (u1 * v2)\n\ngoal (1 subgoal):\n 1. cnj (u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))) =\n    u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))", "moreover"], ["proof (state)\nthis:\n  cnj (1 - v1 * u2 / (u1 * v2)) = 1 - v1 * u2 / (u1 * v2)\n\ngoal (1 subgoal):\n 1. cnj (u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))) =\n    u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))", "have \"cnj (u2 * cnj u2) = u2 * cnj u2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (u2 * cnj u2) = u2 * cnj u2", "by simp"], ["proof (state)\nthis:\n  cnj (u2 * cnj u2) = u2 * cnj u2\n\ngoal (1 subgoal):\n 1. cnj (u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))) =\n    u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))", "ultimately"], ["proof (chain)\npicking this:\n  cnj (1 - v1 * u2 / (u1 * v2)) = 1 - v1 * u2 / (u1 * v2)\n  cnj (u2 * cnj u2) = u2 * cnj u2", "show ?thesis"], ["proof (prove)\nusing this:\n  cnj (1 - v1 * u2 / (u1 * v2)) = 1 - v1 * u2 / (u1 * v2)\n  cnj (u2 * cnj u2) = u2 * cnj u2\n\ngoal (1 subgoal):\n 1. cnj (u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))) =\n    u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))", "by simp"], ["proof (state)\nthis:\n  cnj (u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))) =\n  u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cnj (u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))) =\n  u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))\n\ngoal (1 subgoal):\n 1. is_real (u1 * cnj u2 / (u1 / u2 - v1 / v2))", "ultimately"], ["proof (chain)\npicking this:\n  u1 * cnj u2 / (u1 / u2 - v1 / v2) =\n  u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))\n  cnj (u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))) =\n  u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))", "show ?thesis"], ["proof (prove)\nusing this:\n  u1 * cnj u2 / (u1 / u2 - v1 / v2) =\n  u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))\n  cnj (u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))) =\n  u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))\n\ngoal (1 subgoal):\n 1. is_real (u1 * cnj u2 / (u1 / u2 - v1 / v2))", "using eq_cnj_iff_real"], ["proof (prove)\nusing this:\n  u1 * cnj u2 / (u1 / u2 - v1 / v2) =\n  u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))\n  cnj (u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))) =\n  u2 * cnj u2 / (1 - v1 * u2 / (u1 * v2))\n  (cnj ?z = ?z) = is_real ?z\n\ngoal (1 subgoal):\n 1. is_real (u1 * cnj u2 / (u1 / u2 - v1 / v2))", "by fastforce"], ["proof (state)\nthis:\n  is_real (u1 * cnj u2 / (u1 / u2 - v1 / v2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_real (u1 * cnj u2 / (u1 / u2 - v1 / v2))\n\ngoal (1 subgoal):\n 1. is_real\n     (u1 * cnj u2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_real (u1 * cnj u2 / (u1 / u2 - v1 / v2))\n\ngoal (1 subgoal):\n 1. is_real\n     (u1 * cnj u2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))", "using ** \\<open>is_real ?d1\\<close>"], ["proof (prove)\nusing this:\n  is_real (u1 * cnj u2 / (u1 / u2 - v1 / v2))\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 =\n  (v1 / v2 * (cnj u1 / cnj u2) - 1) * (u1 / u2 - v1 / v2)\n  is_real (v1 / v2 * (cnj u1 / cnj u2) - 1)\n\ngoal (1 subgoal):\n 1. is_real\n     (u1 * cnj u2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))", "by (metis complex_cnj_divide divide_divide_eq_left' eq_cnj_iff_real)"], ["proof (state)\nthis:\n  is_real\n   (u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_real\n   (u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "have \"?k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) \\<noteq>\n    0", "using \\<open>?d \\<noteq> 0\\<close> \\<open>u1 * cnj u2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n  u1 * cnj u2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) \\<noteq>\n    0", "by simp"], ["proof (state)\nthis:\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "have \"cnj ?k = ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (u1 * cnj u2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) =\n    u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)", "using \\<open>is_real ?k\\<close>"], ["proof (prove)\nusing this:\n  is_real\n   (u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n\ngoal (1 subgoal):\n 1. cnj (u1 * cnj u2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) =\n    u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)", "using eq_cnj_iff_real"], ["proof (prove)\nusing this:\n  is_real\n   (u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n  (cnj ?z = ?z) = is_real ?z\n\ngoal (1 subgoal):\n 1. cnj (u1 * cnj u2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) =\n    u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)", "by blast"], ["proof (state)\nthis:\n  cnj (u1 * cnj u2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "have \"Re ?k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (u1 * cnj u2 /\n        (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n         u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n    0", "using \\<open>?k \\<noteq> 0\\<close> \\<open>is_real ?k\\<close>"], ["proof (prove)\nusing this:\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) \\<noteq>\n  0\n  is_real\n   (u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n\ngoal (1 subgoal):\n 1. Re (u1 * cnj u2 /\n        (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n         u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n    0", "by (metis complex.expand zero_complex.simps(1) zero_complex.simps(2))"], ["proof (state)\nthis:\n  Re (u1 * cnj u2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "have \"u1 * cnj u2 = ?k * ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u1 * cnj u2 =\n    u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)", "using \\<open>?d \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. u1 * cnj u2 =\n    u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)", "by simp"], ["proof (state)\nthis:\n  u1 * cnj u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "moreover"], ["proof (state)\nthis:\n  u1 * cnj u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "hence \"cnj u1 * u2 = cnj ?k * cnj ?d\""], ["proof (prove)\nusing this:\n  u1 * cnj u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n\ngoal (1 subgoal):\n 1. cnj u1 * u2 =\n    cnj (u1 * cnj u2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) *\n    cnj (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n         u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)", "by (metis complex_cnj_cnj complex_cnj_mult)"], ["proof (state)\nthis:\n  cnj u1 * u2 =\n  cnj (u1 * cnj u2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) *\n  cnj (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "hence \"cnj u1 * u2 = ?k * ?cd\""], ["proof (prove)\nusing this:\n  cnj u1 * u2 =\n  cnj (u1 * cnj u2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) *\n  cnj (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n\ngoal (1 subgoal):\n 1. cnj u1 * u2 =\n    u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n    (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n     cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)", "using \\<open>cnj ?k = ?k\\<close> \\<open>cnj ?d = ?cd\\<close>"], ["proof (prove)\nusing this:\n  cnj u1 * u2 =\n  cnj (u1 * cnj u2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) *\n  cnj (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj (u1 * cnj u2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) =\n  cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n  cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2\n\ngoal (1 subgoal):\n 1. cnj u1 * u2 =\n    u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n    (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n     cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)", "by metis"], ["proof (state)\nthis:\n  cnj u1 * u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "ultimately"], ["proof (chain)\npicking this:\n  u1 * cnj u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj u1 * u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)", "show ?thesis"], ["proof (prove)\nusing this:\n  u1 * cnj u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj u1 * u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "using \\<open>~ ?den \\<noteq> 0\\<close> \\<open>u1 * cnj u2 \\<noteq> 0\\<close> \\<open>u2 \\<noteq> 0\\<close> \\<open>v2 \\<noteq> 0\\<close> \\<open>Re ?k \\<noteq> 0\\<close> \\<open>is_real ?k\\<close> \\<open>?d \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  u1 * cnj u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj u1 * u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u1 * cnj u2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  Re (u1 * cnj u2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n  0\n  is_real\n   (u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "using complex_mult_cnj_cmod[symmetric, of u1]"], ["proof (prove)\nusing this:\n  u1 * cnj u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj u1 * u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u1 * cnj u2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  Re (u1 * cnj u2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n  0\n  is_real\n   (u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n  cor ((cmod u1)\\<^sup>2) = u1 * cnj u1\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "using complex_mult_cnj_cmod[symmetric, of v1]"], ["proof (prove)\nusing this:\n  u1 * cnj u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj u1 * u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u1 * cnj u2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  Re (u1 * cnj u2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n  0\n  is_real\n   (u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n  cor ((cmod u1)\\<^sup>2) = u1 * cnj u1\n  cor ((cmod v1)\\<^sup>2) = v1 * cnj v1\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "using complex_mult_cnj_cmod[symmetric, of u2]"], ["proof (prove)\nusing this:\n  u1 * cnj u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj u1 * u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u1 * cnj u2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  Re (u1 * cnj u2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n  0\n  is_real\n   (u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n  cor ((cmod u1)\\<^sup>2) = u1 * cnj u1\n  cor ((cmod v1)\\<^sup>2) = v1 * cnj v1\n  cor ((cmod u2)\\<^sup>2) = u2 * cnj u2\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "using complex_mult_cnj_cmod[symmetric, of v2]"], ["proof (prove)\nusing this:\n  u1 * cnj u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj u1 * u2 =\n  u1 * cnj u2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u1 * cnj u2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  Re (u1 * cnj u2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n  0\n  is_real\n   (u1 * cnj u2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n  cor ((cmod u1)\\<^sup>2) = u1 * cnj u1\n  cor ((cmod v1)\\<^sup>2) = v1 * cnj v1\n  cor ((cmod u2)\\<^sup>2) = u2 * cnj u2\n  cor ((cmod v2)\\<^sup>2) = v2 * cnj v2\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))", "apply (auto simp add: power_divide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cnj u1 * u2 =\n             u1 * cnj u2 *\n             (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n              cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2) /\n             (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n              u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2);\n     u1 * cnj u2 * cnj v1 * v2 = v1 * cnj v2 * cnj u1 * u2; u1 \\<noteq> 0;\n     u2 \\<noteq> 0; v2 \\<noteq> 0;\n     Re (u1 * cnj u2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n     0;\n     is_real\n      (u1 * cnj u2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2));\n     v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 \\<noteq>\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2;\n     (cor (cmod u1))\\<^sup>2 = u1 * cnj u1;\n     (cor (cmod v1))\\<^sup>2 = v1 * cnj v1;\n     (cor (cmod u2))\\<^sup>2 = u2 * cnj u2;\n     (cor (cmod v2))\\<^sup>2 = v2 * cnj v2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         k \\<noteq> 0 \\<and>\n                         (k = 0 \\<or>\n                          u1 * cnj v1 / (u2 * cnj v2) =\n                          v1 * cnj u1 / (v2 * cnj u2)) \\<and>\n                         u1 * cnj u2 =\n                         cor k *\n                         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                          u2) \\<and>\n                         \\<i> *\n                         (u1 * cnj u2 *\n                          (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) /\n                           cnj v2 -\n                           cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                           cnj u2)) /\n                         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) =\n                         cor k *\n                         (\\<i> *\n                          (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) /\n                           cnj v2 -\n                           cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                           cnj u2)) \\<and>\n                         (k = 0 \\<or>\n                          u1 * cnj v1 / (u2 * cnj v2) =\n                          v1 * cnj u1 / (v2 * cnj u2))", "apply (rule_tac x=\"Re ?k\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cnj u1 * u2 =\n             u1 * cnj u2 *\n             (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n              cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2) /\n             (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n              u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2);\n     u1 * cnj u2 * cnj v1 * v2 = v1 * cnj v2 * cnj u1 * u2; u1 \\<noteq> 0;\n     u2 \\<noteq> 0; v2 \\<noteq> 0;\n     Re (u1 * cnj u2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n     0;\n     is_real\n      (u1 * cnj u2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2));\n     v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 \\<noteq>\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2;\n     (cor (cmod u1))\\<^sup>2 = u1 * cnj u1;\n     (cor (cmod v1))\\<^sup>2 = v1 * cnj v1;\n     (cor (cmod u2))\\<^sup>2 = u2 * cnj u2;\n     (cor (cmod v2))\\<^sup>2 = v2 * cnj v2\\<rbrakk>\n    \\<Longrightarrow> Re (u1 * cnj u2 /\n                          (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                           u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                           u2)) \\<noteq>\n                      0 \\<and>\n                      (is_imag\n                        (u1 * cnj u2 /\n                         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                          u2)) \\<or>\n                       u1 * cnj v1 / (u2 * cnj v2) =\n                       v1 * cnj u1 / (v2 * cnj u2)) \\<and>\n                      u1 * cnj u2 =\n                      cor (Re (u1 * cnj u2 /\n                               (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) /\n                                v2 -\n                                u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                                u2))) *\n                      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) \\<and>\n                      \\<i> *\n                      (u1 * cnj u2 *\n                       (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) /\n                        cnj v2 -\n                        cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                        cnj u2)) /\n                      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) =\n                      cor (Re (u1 * cnj u2 /\n                               (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) /\n                                v2 -\n                                u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                                u2))) *\n                      (\\<i> *\n                       (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) /\n                        cnj v2 -\n                        cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                        cnj u2)) \\<and>\n                      (is_imag\n                        (u1 * cnj u2 /\n                         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                          u2)) \\<or>\n                       u1 * cnj v1 / (u2 * cnj v2) =\n                       v1 * cnj u1 / (v2 * cnj u2))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cnj u1 * u2 =\n             u1 * cnj u2 *\n             (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n              cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2) /\n             (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n              u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2);\n     u1 * cnj u2 * cnj v1 * v2 = v1 * cnj v2 * cnj u1 * u2; u1 \\<noteq> 0;\n     u2 \\<noteq> 0; v2 \\<noteq> 0;\n     Re (u1 * cnj u2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n     0;\n     is_real\n      (u1 * cnj u2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2));\n     v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 \\<noteq>\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2;\n     (cor (cmod u1))\\<^sup>2 = u1 * cnj u1;\n     (cor (cmod v1))\\<^sup>2 = v1 * cnj v1;\n     (cor (cmod u2))\\<^sup>2 = u2 * cnj u2;\n     (cor (cmod v2))\\<^sup>2 = v2 * cnj v2\\<rbrakk>\n    \\<Longrightarrow> u1 * cnj v1 / (u2 * cnj v2) =\n                      v1 * cnj u1 / (v2 * cnj u2)", "apply (simp add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "moreover"], ["proof (state)\nthis:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "have \"poincare_line_cvec_cmat (u1, u2) (v1, v2) = ?H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n    mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))", "using \\<open>\\<not> ?den \\<noteq> 0\\<close> \\<open>u1 * cnj u2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u1 * cnj u2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n    mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))", "unfolding poincare_line_cvec_cmat_def"], ["proof (prove)\nusing this:\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u1 * cnj u2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (let (z1, z2) = (u1, u2); (w1, w2) = (v1, v2);\n         nom =\n           w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n           z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2);\n         den = z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2\n     in if den \\<noteq> 0\n        then mk_poincare_line_cmat (Re (\\<i> * den)) (\\<i> * nom)\n        else if z1 * cnj z2 \\<noteq> 0\n             then mk_poincare_line_cmat 0 (\\<i> * z1 * cnj z2)\n             else if w1 * cnj w2 \\<noteq> 0\n                  then mk_poincare_line_cmat 0 (\\<i> * w1 * cnj w2)\n                  else mk_poincare_line_cmat 0 \\<i>) =\n    mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "moreover"], ["proof (state)\nthis:\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "hence \"hermitean ?H' \\<and> ?H' \\<noteq> mat_zero\""], ["proof (prove)\nusing this:\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))\n\ngoal (1 subgoal):\n 1. hermitean (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))) \\<and>\n    mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)) \\<noteq> mat_zero", "by (metis mk_poincare_line_cmat_hermitean poincare_line_cvec_cmat_nonzero uv(1) uv(2))"], ["proof (state)\nthis:\n  hermitean (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))) \\<and>\n  mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)) \\<noteq> mat_zero\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "hence \"hermitean ?H \\<and> ?H \\<noteq> mat_zero\""], ["proof (prove)\nusing this:\n  hermitean (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))) \\<and>\n  mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)) \\<noteq> mat_zero\n\ngoal (1 subgoal):\n 1. hermitean\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n    mat_zero", "using \\<open>circline_eq_cmat ?H ?H'\\<close>"], ["proof (prove)\nusing this:\n  hermitean (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))) \\<and>\n  mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)) \\<noteq> mat_zero\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))\n\ngoal (1 subgoal):\n 1. hermitean\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n    mat_zero", "using circline_eq_cmat_hermitean_nonzero[of ?H' ?H] symp_circline_eq_cmat"], ["proof (prove)\nusing this:\n  hermitean (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))) \\<and>\n  mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)) \\<noteq> mat_zero\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))\n  \\<lbrakk>hermitean (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))) \\<and>\n           mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)) \\<noteq> mat_zero;\n   circline_eq_cmat (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\\<rbrakk>\n  \\<Longrightarrow> hermitean\n                     (\\<i> *\n                      (to_complex_cvec (u1, u2) *\n                       cnj (to_complex_cvec (v1, v2)) -\n                       to_complex_cvec (v1, v2) *\n                       cnj (to_complex_cvec (u1, u2))),\n                      \\<i> *\n                      (to_complex_cvec (v1, v2) *\n                       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                        1) -\n                       to_complex_cvec (u1, u2) *\n                       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                        1)),\n                      - (\\<i> *\n                         (cnj (to_complex_cvec (v1, v2)) *\n                          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                           1) -\n                          cnj (to_complex_cvec (u1, u2)) *\n                          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                           1))),\n                      \\<i> *\n                      (to_complex_cvec (u1, u2) *\n                       cnj (to_complex_cvec (v1, v2)) -\n                       to_complex_cvec (v1, v2) *\n                       cnj (to_complex_cvec (u1, u2)))) \\<and>\n                    (\\<i> *\n                     (to_complex_cvec (u1, u2) *\n                      cnj (to_complex_cvec (v1, v2)) -\n                      to_complex_cvec (v1, v2) *\n                      cnj (to_complex_cvec (u1, u2))),\n                     \\<i> *\n                     (to_complex_cvec (v1, v2) *\n                      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                       1) -\n                      to_complex_cvec (u1, u2) *\n                      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                       1)),\n                     - (\\<i> *\n                        (cnj (to_complex_cvec (v1, v2)) *\n                         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                          1) -\n                         cnj (to_complex_cvec (u1, u2)) *\n                         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                          1))),\n                     \\<i> *\n                     (to_complex_cvec (u1, u2) *\n                      cnj (to_complex_cvec (v1, v2)) -\n                      to_complex_cvec (v1, v2) *\n                      cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n                    mat_zero\n  symp circline_eq_cmat\n\ngoal (1 subgoal):\n 1. hermitean\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n    mat_zero", "unfolding symp_def"], ["proof (prove)\nusing this:\n  hermitean (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))) \\<and>\n  mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)) \\<noteq> mat_zero\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))\n  \\<lbrakk>hermitean (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))) \\<and>\n           mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)) \\<noteq> mat_zero;\n   circline_eq_cmat (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\\<rbrakk>\n  \\<Longrightarrow> hermitean\n                     (\\<i> *\n                      (to_complex_cvec (u1, u2) *\n                       cnj (to_complex_cvec (v1, v2)) -\n                       to_complex_cvec (v1, v2) *\n                       cnj (to_complex_cvec (u1, u2))),\n                      \\<i> *\n                      (to_complex_cvec (v1, v2) *\n                       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                        1) -\n                       to_complex_cvec (u1, u2) *\n                       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                        1)),\n                      - (\\<i> *\n                         (cnj (to_complex_cvec (v1, v2)) *\n                          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                           1) -\n                          cnj (to_complex_cvec (u1, u2)) *\n                          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                           1))),\n                      \\<i> *\n                      (to_complex_cvec (u1, u2) *\n                       cnj (to_complex_cvec (v1, v2)) -\n                       to_complex_cvec (v1, v2) *\n                       cnj (to_complex_cvec (u1, u2)))) \\<and>\n                    (\\<i> *\n                     (to_complex_cvec (u1, u2) *\n                      cnj (to_complex_cvec (v1, v2)) -\n                      to_complex_cvec (v1, v2) *\n                      cnj (to_complex_cvec (u1, u2))),\n                     \\<i> *\n                     (to_complex_cvec (v1, v2) *\n                      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                       1) -\n                      to_complex_cvec (u1, u2) *\n                      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                       1)),\n                     - (\\<i> *\n                        (cnj (to_complex_cvec (v1, v2)) *\n                         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                          1) -\n                         cnj (to_complex_cvec (u1, u2)) *\n                         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                          1))),\n                     \\<i> *\n                     (to_complex_cvec (u1, u2) *\n                      cnj (to_complex_cvec (v1, v2)) -\n                      to_complex_cvec (v1, v2) *\n                      cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n                    mat_zero\n  \\<forall>x y. circline_eq_cmat x y \\<longrightarrow> circline_eq_cmat y x\n\ngoal (1 subgoal):\n 1. hermitean\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n    mat_zero", "by metis"], ["proof (state)\nthis:\n  hermitean\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n  mat_zero\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "hence \"mk_circline_cmat ?A ?B ?C ?D = ?H\""], ["proof (prove)\nusing this:\n  hermitean\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n  mat_zero\n\ngoal (1 subgoal):\n 1. mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) =\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "by simp"], ["proof (state)\nthis:\n  mk_circline_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (\\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n   (- (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) =\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "ultimately"], ["proof (chain)\npicking this:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))\n  mk_circline_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (\\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n   (- (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) =\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "have \"circline_eq_cmat (mk_circline_cmat ?A ?B ?C ?D)\n                             (poincare_line_cvec_cmat (u1, u2) (v1, v2))\""], ["proof (prove)\nusing this:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2)))\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat 0 (\\<i> * (u1 * cnj u2))\n  mk_circline_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (\\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n   (- (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) =\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n     (poincare_line_cvec_cmat (u1, u2) (v1, v2))", "by simp"], ["proof (state)\nthis:\n  circline_eq_cmat\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n   (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n\ngoal (2 subgoals):\n 1. u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  circline_eq_cmat\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n   (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "using symp_circline_eq_cmat"], ["proof (prove)\nusing this:\n  circline_eq_cmat\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n   (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n  symp circline_eq_cmat\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "unfolding symp_def"], ["proof (prove)\nusing this:\n  circline_eq_cmat\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n   (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n  \\<forall>x y. circline_eq_cmat x y \\<longrightarrow> circline_eq_cmat y x\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "by blast"], ["proof (state)\nthis:\n  circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "case  False"], ["proof (state)\nthis:\n  \\<not> u1 * cnj u2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> u1 * cnj u2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "proof (cases \"v1 * cnj v2 \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "case True"], ["proof (state)\nthis:\n  v1 * cnj v2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "let ?nom = \"v1 * cnj v2\""], ["proof (state)\ngoal (2 subgoals):\n 1. v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "let ?H' = \"mk_poincare_line_cmat 0 (\\<i> * ?nom)\""], ["proof (state)\ngoal (2 subgoals):\n 1. v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "have \"circline_eq_cmat ?H ?H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "let ?k = \"(v1 * cnj v2) / ?d\""], ["proof (state)\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "have \"is_real ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real\n     (v1 * cnj v2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_real\n     (v1 * cnj v2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))", "have \"is_real ((v1 * cnj v2) / ?d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (v1 * cnj v2 / (u1 / u2 - v1 / v2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_real (v1 * cnj v2 / (u1 / u2 - v1 / v2))", "let ?rhs = \"(v2 * cnj v2) / ((u1*v2)/(u2*v1) - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_real (v1 * cnj v2 / (u1 / u2 - v1 / v2))", "have 1: \"(v1 * cnj v2) / ?d2 = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 * cnj v2 / (u1 / u2 - v1 / v2) =\n    v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)", "using \\<open>\\<not> ?den \\<noteq> 0\\<close> \\<open>u2 \\<noteq> 0\\<close> \\<open>v2 \\<noteq> 0\\<close> * \\<open>v1 * cnj v2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  u1 * cnj v1 \\<noteq> u2 * cnj v2\n  u1 * v2 \\<noteq> u2 * v1\n  v1 * cnj v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v1 * cnj v2 / (u1 / u2 - v1 / v2) =\n    v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  v1 * cnj v2 / (u1 / u2 - v1 / v2) =\n  v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)\n\ngoal (1 subgoal):\n 1. is_real (v1 * cnj v2 / (u1 / u2 - v1 / v2))", "moreover"], ["proof (state)\nthis:\n  v1 * cnj v2 / (u1 / u2 - v1 / v2) =\n  v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)\n\ngoal (1 subgoal):\n 1. is_real (v1 * cnj v2 / (u1 / u2 - v1 / v2))", "have \"cnj ?rhs = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)) =\n    v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cnj (v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)) =\n    v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)", "have \"cnj (u1 * v2 / (u2 * v1) - 1) = u1 * v2 / (u2 * v1) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (u1 * v2 / (u2 * v1) - 1) = u1 * v2 / (u2 * v1) - 1", "using \\<open>\\<not> ?den \\<noteq> 0\\<close> \\<open>u2 \\<noteq> 0\\<close> \\<open>v2 \\<noteq> 0\\<close> * \\<open>v1 * cnj v2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  u1 * cnj v1 \\<noteq> u2 * cnj v2\n  u1 * v2 \\<noteq> u2 * v1\n  v1 * cnj v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cnj (u1 * v2 / (u2 * v1) - 1) = u1 * v2 / (u2 * v1) - 1", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cnj (u1 * v2 / (u2 * v1) - 1) = u1 * v2 / (u2 * v1) - 1\n\ngoal (1 subgoal):\n 1. cnj (v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)) =\n    v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)", "moreover"], ["proof (state)\nthis:\n  cnj (u1 * v2 / (u2 * v1) - 1) = u1 * v2 / (u2 * v1) - 1\n\ngoal (1 subgoal):\n 1. cnj (v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)) =\n    v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)", "have \"cnj (v2 * cnj v2) = v2 * cnj v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (v2 * cnj v2) = v2 * cnj v2", "by simp"], ["proof (state)\nthis:\n  cnj (v2 * cnj v2) = v2 * cnj v2\n\ngoal (1 subgoal):\n 1. cnj (v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)) =\n    v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)", "ultimately"], ["proof (chain)\npicking this:\n  cnj (u1 * v2 / (u2 * v1) - 1) = u1 * v2 / (u2 * v1) - 1\n  cnj (v2 * cnj v2) = v2 * cnj v2", "show ?thesis"], ["proof (prove)\nusing this:\n  cnj (u1 * v2 / (u2 * v1) - 1) = u1 * v2 / (u2 * v1) - 1\n  cnj (v2 * cnj v2) = v2 * cnj v2\n\ngoal (1 subgoal):\n 1. cnj (v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)) =\n    v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)", "by simp"], ["proof (state)\nthis:\n  cnj (v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)) =\n  v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cnj (v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)) =\n  v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)\n\ngoal (1 subgoal):\n 1. is_real (v1 * cnj v2 / (u1 / u2 - v1 / v2))", "ultimately"], ["proof (chain)\npicking this:\n  v1 * cnj v2 / (u1 / u2 - v1 / v2) =\n  v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)\n  cnj (v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)) =\n  v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  v1 * cnj v2 / (u1 / u2 - v1 / v2) =\n  v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)\n  cnj (v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)) =\n  v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)\n\ngoal (1 subgoal):\n 1. is_real (v1 * cnj v2 / (u1 / u2 - v1 / v2))", "using eq_cnj_iff_real"], ["proof (prove)\nusing this:\n  v1 * cnj v2 / (u1 / u2 - v1 / v2) =\n  v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)\n  cnj (v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)) =\n  v2 * cnj v2 / (u1 * v2 / (u2 * v1) - 1)\n  (cnj ?z = ?z) = is_real ?z\n\ngoal (1 subgoal):\n 1. is_real (v1 * cnj v2 / (u1 / u2 - v1 / v2))", "by fastforce"], ["proof (state)\nthis:\n  is_real (v1 * cnj v2 / (u1 / u2 - v1 / v2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_real (v1 * cnj v2 / (u1 / u2 - v1 / v2))\n\ngoal (1 subgoal):\n 1. is_real\n     (v1 * cnj v2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_real (v1 * cnj v2 / (u1 / u2 - v1 / v2))\n\ngoal (1 subgoal):\n 1. is_real\n     (v1 * cnj v2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))", "using ** \\<open>is_real ?d1\\<close>"], ["proof (prove)\nusing this:\n  is_real (v1 * cnj v2 / (u1 / u2 - v1 / v2))\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 =\n  (v1 / v2 * (cnj u1 / cnj u2) - 1) * (u1 / u2 - v1 / v2)\n  is_real (v1 / v2 * (cnj u1 / cnj u2) - 1)\n\ngoal (1 subgoal):\n 1. is_real\n     (v1 * cnj v2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))", "by (metis complex_cnj_divide divide_divide_eq_left' eq_cnj_iff_real)"], ["proof (state)\nthis:\n  is_real\n   (v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_real\n   (v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "have \"?k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) \\<noteq>\n    0", "using \\<open>?d \\<noteq> 0\\<close> \\<open>v1 * cnj v2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n  v1 * cnj v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) \\<noteq>\n    0", "by simp"], ["proof (state)\nthis:\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "have \"cnj ?k = ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (v1 * cnj v2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) =\n    v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)", "using \\<open>is_real ?k\\<close>"], ["proof (prove)\nusing this:\n  is_real\n   (v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n\ngoal (1 subgoal):\n 1. cnj (v1 * cnj v2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) =\n    v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)", "using eq_cnj_iff_real"], ["proof (prove)\nusing this:\n  is_real\n   (v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n  (cnj ?z = ?z) = is_real ?z\n\ngoal (1 subgoal):\n 1. cnj (v1 * cnj v2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) =\n    v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)", "by blast"], ["proof (state)\nthis:\n  cnj (v1 * cnj v2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "have \"Re ?k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (v1 * cnj v2 /\n        (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n         u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n    0", "using \\<open>?k \\<noteq> 0\\<close> \\<open>is_real ?k\\<close>"], ["proof (prove)\nusing this:\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) \\<noteq>\n  0\n  is_real\n   (v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n\ngoal (1 subgoal):\n 1. Re (v1 * cnj v2 /\n        (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n         u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n    0", "by (metis complex.expand zero_complex.simps(1) zero_complex.simps(2))"], ["proof (state)\nthis:\n  Re (v1 * cnj v2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "have \"v1 * cnj v2 = ?k * ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 * cnj v2 =\n    v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)", "using \\<open>?d \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. v1 * cnj v2 =\n    v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)", "by simp"], ["proof (state)\nthis:\n  v1 * cnj v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "moreover"], ["proof (state)\nthis:\n  v1 * cnj v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "hence \"cnj v1 * v2 = cnj ?k * cnj ?d\""], ["proof (prove)\nusing this:\n  v1 * cnj v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n\ngoal (1 subgoal):\n 1. cnj v1 * v2 =\n    cnj (v1 * cnj v2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) *\n    cnj (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n         u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)", "by (metis complex_cnj_cnj complex_cnj_mult)"], ["proof (state)\nthis:\n  cnj v1 * v2 =\n  cnj (v1 * cnj v2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) *\n  cnj (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "hence \"cnj v1 * v2 = ?k * ?cd\""], ["proof (prove)\nusing this:\n  cnj v1 * v2 =\n  cnj (v1 * cnj v2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) *\n  cnj (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n\ngoal (1 subgoal):\n 1. cnj v1 * v2 =\n    v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n    (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n     cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)", "using \\<open>cnj ?k = ?k\\<close> \\<open>cnj ?d = ?cd\\<close>"], ["proof (prove)\nusing this:\n  cnj v1 * v2 =\n  cnj (v1 * cnj v2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) *\n  cnj (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj (v1 * cnj v2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) =\n  cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n  cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2\n\ngoal (1 subgoal):\n 1. cnj v1 * v2 =\n    v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n    (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n     cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)", "by metis"], ["proof (state)\nthis:\n  cnj v1 * v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "ultimately"], ["proof (chain)\npicking this:\n  v1 * cnj v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj v1 * v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)", "show ?thesis"], ["proof (prove)\nusing this:\n  v1 * cnj v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj v1 * v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "using \\<open>~ ?den \\<noteq> 0\\<close> \\<open>v1 * cnj v2 \\<noteq> 0\\<close> \\<open>u2 \\<noteq> 0\\<close> \\<open>v2 \\<noteq> 0\\<close> \\<open>Re ?k \\<noteq> 0\\<close> \\<open>is_real ?k\\<close> \\<open>?d \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  v1 * cnj v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj v1 * v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  v1 * cnj v2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  Re (v1 * cnj v2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n  0\n  is_real\n   (v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "using complex_mult_cnj_cmod[symmetric, of u1]"], ["proof (prove)\nusing this:\n  v1 * cnj v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj v1 * v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  v1 * cnj v2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  Re (v1 * cnj v2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n  0\n  is_real\n   (v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n  cor ((cmod u1)\\<^sup>2) = u1 * cnj u1\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "using complex_mult_cnj_cmod[symmetric, of v1]"], ["proof (prove)\nusing this:\n  v1 * cnj v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj v1 * v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  v1 * cnj v2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  Re (v1 * cnj v2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n  0\n  is_real\n   (v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n  cor ((cmod u1)\\<^sup>2) = u1 * cnj u1\n  cor ((cmod v1)\\<^sup>2) = v1 * cnj v1\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "using complex_mult_cnj_cmod[symmetric, of u2]"], ["proof (prove)\nusing this:\n  v1 * cnj v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj v1 * v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  v1 * cnj v2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  Re (v1 * cnj v2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n  0\n  is_real\n   (v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n  cor ((cmod u1)\\<^sup>2) = u1 * cnj u1\n  cor ((cmod v1)\\<^sup>2) = v1 * cnj v1\n  cor ((cmod u2)\\<^sup>2) = u2 * cnj u2\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "using complex_mult_cnj_cmod[symmetric, of v2]"], ["proof (prove)\nusing this:\n  v1 * cnj v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)\n  cnj v1 * v2 =\n  v1 * cnj v2 /\n  (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n   u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) *\n  (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n   cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2)\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  v1 * cnj v2 \\<noteq> 0\n  u2 \\<noteq> 0\n  v2 \\<noteq> 0\n  Re (v1 * cnj v2 /\n      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n  0\n  is_real\n   (v1 * cnj v2 /\n    (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2))\n  v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n  u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2 \\<noteq>\n  0\n  cor ((cmod u1)\\<^sup>2) = u1 * cnj u1\n  cor ((cmod v1)\\<^sup>2) = v1 * cnj v1\n  cor ((cmod u2)\\<^sup>2) = u2 * cnj u2\n  cor ((cmod v2)\\<^sup>2) = v2 * cnj v2\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))", "apply (auto simp add: power_divide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cnj v1 * v2 =\n             v1 * cnj v2 *\n             (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n              cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2) /\n             (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n              u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2);\n     u1 * cnj u2 * cnj v1 * v2 = v1 * cnj v2 * cnj u1 * u2; v1 \\<noteq> 0;\n     u2 \\<noteq> 0; v2 \\<noteq> 0;\n     Re (v1 * cnj v2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n     0;\n     is_real\n      (v1 * cnj v2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2));\n     v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 \\<noteq>\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2;\n     (cor (cmod u1))\\<^sup>2 = u1 * cnj u1;\n     (cor (cmod v1))\\<^sup>2 = v1 * cnj v1;\n     (cor (cmod u2))\\<^sup>2 = u2 * cnj u2;\n     (cor (cmod v2))\\<^sup>2 = v2 * cnj v2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         k \\<noteq> 0 \\<and>\n                         (k = 0 \\<or>\n                          u1 * cnj v1 / (u2 * cnj v2) =\n                          v1 * cnj u1 / (v2 * cnj u2)) \\<and>\n                         v1 * cnj v2 =\n                         cor k *\n                         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                          u2) \\<and>\n                         \\<i> *\n                         (v1 * cnj v2 *\n                          (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) /\n                           cnj v2 -\n                           cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                           cnj u2)) /\n                         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) =\n                         cor k *\n                         (\\<i> *\n                          (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) /\n                           cnj v2 -\n                           cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                           cnj u2)) \\<and>\n                         (k = 0 \\<or>\n                          u1 * cnj v1 / (u2 * cnj v2) =\n                          v1 * cnj u1 / (v2 * cnj u2))", "apply (rule_tac x=\"Re ?k\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cnj v1 * v2 =\n             v1 * cnj v2 *\n             (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n              cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2) /\n             (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n              u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2);\n     u1 * cnj u2 * cnj v1 * v2 = v1 * cnj v2 * cnj u1 * u2; v1 \\<noteq> 0;\n     u2 \\<noteq> 0; v2 \\<noteq> 0;\n     Re (v1 * cnj v2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n     0;\n     is_real\n      (v1 * cnj v2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2));\n     v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 \\<noteq>\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2;\n     (cor (cmod u1))\\<^sup>2 = u1 * cnj u1;\n     (cor (cmod v1))\\<^sup>2 = v1 * cnj v1;\n     (cor (cmod u2))\\<^sup>2 = u2 * cnj u2;\n     (cor (cmod v2))\\<^sup>2 = v2 * cnj v2\\<rbrakk>\n    \\<Longrightarrow> Re (v1 * cnj v2 /\n                          (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                           u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                           u2)) \\<noteq>\n                      0 \\<and>\n                      (is_imag\n                        (v1 * cnj v2 /\n                         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                          u2)) \\<or>\n                       u1 * cnj v1 / (u2 * cnj v2) =\n                       v1 * cnj u1 / (v2 * cnj u2)) \\<and>\n                      v1 * cnj v2 =\n                      cor (Re (v1 * cnj v2 /\n                               (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) /\n                                v2 -\n                                u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                                u2))) *\n                      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) \\<and>\n                      \\<i> *\n                      (v1 * cnj v2 *\n                       (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) /\n                        cnj v2 -\n                        cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                        cnj u2)) /\n                      (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                       u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2) =\n                      cor (Re (v1 * cnj v2 /\n                               (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) /\n                                v2 -\n                                u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                                u2))) *\n                      (\\<i> *\n                       (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) /\n                        cnj v2 -\n                        cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                        cnj u2)) \\<and>\n                      (is_imag\n                        (v1 * cnj v2 /\n                         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n                          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) /\n                          u2)) \\<or>\n                       u1 * cnj v1 / (u2 * cnj v2) =\n                       v1 * cnj u1 / (v2 * cnj u2))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cnj v1 * v2 =\n             v1 * cnj v2 *\n             (cnj v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / cnj v2 -\n              cnj u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / cnj u2) /\n             (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n              u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2);\n     u1 * cnj u2 * cnj v1 * v2 = v1 * cnj v2 * cnj u1 * u2; v1 \\<noteq> 0;\n     u2 \\<noteq> 0; v2 \\<noteq> 0;\n     Re (v1 * cnj v2 /\n         (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n          u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2)) \\<noteq>\n     0;\n     is_real\n      (v1 * cnj v2 /\n       (v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 -\n        u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2));\n     v1 * (u1 * cnj u1 / (u2 * cnj u2) + 1) / v2 \\<noteq>\n     u1 * (v1 * cnj v1 / (v2 * cnj v2) + 1) / u2;\n     (cor (cmod u1))\\<^sup>2 = u1 * cnj u1;\n     (cor (cmod v1))\\<^sup>2 = v1 * cnj v1;\n     (cor (cmod u2))\\<^sup>2 = u2 * cnj u2;\n     (cor (cmod v2))\\<^sup>2 = v2 * cnj v2\\<rbrakk>\n    \\<Longrightarrow> u1 * cnj v1 / (u2 * cnj v2) =\n                      v1 * cnj u1 / (v2 * cnj u2)", "apply (simp add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))\n\ngoal (2 subgoals):\n 1. v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "moreover"], ["proof (state)\nthis:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))\n\ngoal (2 subgoals):\n 1. v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "have \"poincare_line_cvec_cmat (u1, u2) (v1, v2) = ?H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n    mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))", "using \\<open>\\<not> ?den \\<noteq> 0\\<close> \\<open>\\<not> u1 * cnj u2 \\<noteq> 0\\<close> \\<open>v1 * cnj v2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  \\<not> u1 * cnj u2 \\<noteq> 0\n  v1 * cnj v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n    mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))", "unfolding poincare_line_cvec_cmat_def"], ["proof (prove)\nusing this:\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  \\<not> u1 * cnj u2 \\<noteq> 0\n  v1 * cnj v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (let (z1, z2) = (u1, u2); (w1, w2) = (v1, v2);\n         nom =\n           w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n           z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2);\n         den = z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2\n     in if den \\<noteq> 0\n        then mk_poincare_line_cmat (Re (\\<i> * den)) (\\<i> * nom)\n        else if z1 * cnj z2 \\<noteq> 0\n             then mk_poincare_line_cmat 0 (\\<i> * z1 * cnj z2)\n             else if w1 * cnj w2 \\<noteq> 0\n                  then mk_poincare_line_cmat 0 (\\<i> * w1 * cnj w2)\n                  else mk_poincare_line_cmat 0 \\<i>) =\n    mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))\n\ngoal (2 subgoals):\n 1. v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "moreover"], ["proof (state)\nthis:\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))\n\ngoal (2 subgoals):\n 1. v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "hence \"hermitean ?H' \\<and> ?H' \\<noteq> mat_zero\""], ["proof (prove)\nusing this:\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))\n\ngoal (1 subgoal):\n 1. hermitean (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))) \\<and>\n    mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)) \\<noteq> mat_zero", "by (metis mk_poincare_line_cmat_hermitean poincare_line_cvec_cmat_nonzero uv(1) uv(2))"], ["proof (state)\nthis:\n  hermitean (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))) \\<and>\n  mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)) \\<noteq> mat_zero\n\ngoal (2 subgoals):\n 1. v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "hence \"hermitean ?H \\<and> ?H \\<noteq> mat_zero\""], ["proof (prove)\nusing this:\n  hermitean (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))) \\<and>\n  mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)) \\<noteq> mat_zero\n\ngoal (1 subgoal):\n 1. hermitean\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n    mat_zero", "using \\<open>circline_eq_cmat ?H ?H'\\<close>"], ["proof (prove)\nusing this:\n  hermitean (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))) \\<and>\n  mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)) \\<noteq> mat_zero\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))\n\ngoal (1 subgoal):\n 1. hermitean\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n    mat_zero", "using circline_eq_cmat_hermitean_nonzero[of ?H' ?H] symp_circline_eq_cmat"], ["proof (prove)\nusing this:\n  hermitean (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))) \\<and>\n  mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)) \\<noteq> mat_zero\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))\n  \\<lbrakk>hermitean (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))) \\<and>\n           mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)) \\<noteq> mat_zero;\n   circline_eq_cmat (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\\<rbrakk>\n  \\<Longrightarrow> hermitean\n                     (\\<i> *\n                      (to_complex_cvec (u1, u2) *\n                       cnj (to_complex_cvec (v1, v2)) -\n                       to_complex_cvec (v1, v2) *\n                       cnj (to_complex_cvec (u1, u2))),\n                      \\<i> *\n                      (to_complex_cvec (v1, v2) *\n                       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                        1) -\n                       to_complex_cvec (u1, u2) *\n                       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                        1)),\n                      - (\\<i> *\n                         (cnj (to_complex_cvec (v1, v2)) *\n                          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                           1) -\n                          cnj (to_complex_cvec (u1, u2)) *\n                          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                           1))),\n                      \\<i> *\n                      (to_complex_cvec (u1, u2) *\n                       cnj (to_complex_cvec (v1, v2)) -\n                       to_complex_cvec (v1, v2) *\n                       cnj (to_complex_cvec (u1, u2)))) \\<and>\n                    (\\<i> *\n                     (to_complex_cvec (u1, u2) *\n                      cnj (to_complex_cvec (v1, v2)) -\n                      to_complex_cvec (v1, v2) *\n                      cnj (to_complex_cvec (u1, u2))),\n                     \\<i> *\n                     (to_complex_cvec (v1, v2) *\n                      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                       1) -\n                      to_complex_cvec (u1, u2) *\n                      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                       1)),\n                     - (\\<i> *\n                        (cnj (to_complex_cvec (v1, v2)) *\n                         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                          1) -\n                         cnj (to_complex_cvec (u1, u2)) *\n                         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                          1))),\n                     \\<i> *\n                     (to_complex_cvec (u1, u2) *\n                      cnj (to_complex_cvec (v1, v2)) -\n                      to_complex_cvec (v1, v2) *\n                      cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n                    mat_zero\n  symp circline_eq_cmat\n\ngoal (1 subgoal):\n 1. hermitean\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n    mat_zero", "unfolding symp_def"], ["proof (prove)\nusing this:\n  hermitean (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))) \\<and>\n  mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)) \\<noteq> mat_zero\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))\n  \\<lbrakk>hermitean (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))) \\<and>\n           mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)) \\<noteq> mat_zero;\n   circline_eq_cmat (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\\<rbrakk>\n  \\<Longrightarrow> hermitean\n                     (\\<i> *\n                      (to_complex_cvec (u1, u2) *\n                       cnj (to_complex_cvec (v1, v2)) -\n                       to_complex_cvec (v1, v2) *\n                       cnj (to_complex_cvec (u1, u2))),\n                      \\<i> *\n                      (to_complex_cvec (v1, v2) *\n                       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                        1) -\n                       to_complex_cvec (u1, u2) *\n                       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                        1)),\n                      - (\\<i> *\n                         (cnj (to_complex_cvec (v1, v2)) *\n                          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                           1) -\n                          cnj (to_complex_cvec (u1, u2)) *\n                          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                           1))),\n                      \\<i> *\n                      (to_complex_cvec (u1, u2) *\n                       cnj (to_complex_cvec (v1, v2)) -\n                       to_complex_cvec (v1, v2) *\n                       cnj (to_complex_cvec (u1, u2)))) \\<and>\n                    (\\<i> *\n                     (to_complex_cvec (u1, u2) *\n                      cnj (to_complex_cvec (v1, v2)) -\n                      to_complex_cvec (v1, v2) *\n                      cnj (to_complex_cvec (u1, u2))),\n                     \\<i> *\n                     (to_complex_cvec (v1, v2) *\n                      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                       1) -\n                      to_complex_cvec (u1, u2) *\n                      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                       1)),\n                     - (\\<i> *\n                        (cnj (to_complex_cvec (v1, v2)) *\n                         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 +\n                          1) -\n                         cnj (to_complex_cvec (u1, u2)) *\n                         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 +\n                          1))),\n                     \\<i> *\n                     (to_complex_cvec (u1, u2) *\n                      cnj (to_complex_cvec (v1, v2)) -\n                      to_complex_cvec (v1, v2) *\n                      cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n                    mat_zero\n  \\<forall>x y. circline_eq_cmat x y \\<longrightarrow> circline_eq_cmat y x\n\ngoal (1 subgoal):\n 1. hermitean\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n      \\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n      - (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n      \\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n    mat_zero", "by metis"], ["proof (state)\nthis:\n  hermitean\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n  mat_zero\n\ngoal (2 subgoals):\n 1. v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "hence \"mk_circline_cmat ?A ?B ?C ?D = ?H\""], ["proof (prove)\nusing this:\n  hermitean\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<and>\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) \\<noteq>\n  mat_zero\n\ngoal (1 subgoal):\n 1. mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) =\n    (\\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n     \\<i> *\n     (to_complex_cvec (v1, v2) *\n      ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n      to_complex_cvec (u1, u2) *\n      ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n     - (\\<i> *\n        (cnj (to_complex_cvec (v1, v2)) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         cnj (to_complex_cvec (u1, u2)) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n     \\<i> *\n     (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n      to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "by simp"], ["proof (state)\nthis:\n  mk_circline_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (\\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n   (- (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) =\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal (2 subgoals):\n 1. v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "ultimately"], ["proof (chain)\npicking this:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))\n  mk_circline_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (\\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n   (- (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) =\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))", "have \"circline_eq_cmat (mk_circline_cmat ?A ?B ?C ?D)\n                               (poincare_line_cvec_cmat (u1, u2) (v1, v2))\""], ["proof (prove)\nusing this:\n  circline_eq_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n    \\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n    - (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n    \\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2)))\n  poincare_line_cvec_cmat (u1, u2) (v1, v2) =\n  mk_poincare_line_cmat 0 (\\<i> * (v1 * cnj v2))\n  mk_circline_cmat\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n   (\\<i> *\n    (to_complex_cvec (v1, v2) *\n     ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n     to_complex_cvec (u1, u2) *\n     ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n   (- (\\<i> *\n       (cnj (to_complex_cvec (v1, v2)) *\n        ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n        cnj (to_complex_cvec (u1, u2)) *\n        ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n   (\\<i> *\n    (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n     to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))) =\n  (\\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))),\n   \\<i> *\n   (to_complex_cvec (v1, v2) *\n    ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n    to_complex_cvec (u1, u2) *\n    ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)),\n   - (\\<i> *\n      (cnj (to_complex_cvec (v1, v2)) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       cnj (to_complex_cvec (u1, u2)) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))),\n   \\<i> *\n   (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n    to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n     (poincare_line_cvec_cmat (u1, u2) (v1, v2))", "by simp"], ["proof (state)\nthis:\n  circline_eq_cmat\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n   (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n\ngoal (2 subgoals):\n 1. v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n 2. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  circline_eq_cmat\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n   (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "using symp_circline_eq_cmat"], ["proof (prove)\nusing this:\n  circline_eq_cmat\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n   (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n  symp circline_eq_cmat\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "unfolding symp_def"], ["proof (prove)\nusing this:\n  circline_eq_cmat\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n   (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n  \\<forall>x y. circline_eq_cmat x y \\<longrightarrow> circline_eq_cmat y x\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "by blast"], ["proof (state)\nthis:\n  circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n\ngoal (1 subgoal):\n 1. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "case False"], ["proof (state)\nthis:\n  \\<not> v1 * cnj v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "hence False"], ["proof (prove)\nusing this:\n  \\<not> v1 * cnj v2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> ?den \\<noteq> 0\\<close> \\<open>\\<not> u1 * cnj u2 \\<noteq> 0\\<close> uv"], ["proof (prove)\nusing this:\n  \\<not> v1 * cnj v2 \\<noteq> 0\n  \\<not> u1 * cnj u2 * cnj v1 * v2 - v1 * cnj v2 * cnj u1 * u2 \\<noteq> 0\n  \\<not> u1 * cnj u2 \\<noteq> 0\n  (u1, u2) \\<noteq> vec_zero\n  (v1, v2) \\<noteq> vec_zero\n  \\<not> (u1, u2) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v\n  \\<not> (v1, v2) \\<approx>\\<^sub>v \\<infinity>\\<^sub>v\n  \\<not> (u1, u2) \\<approx>\\<^sub>v (v1, v2)\n  \\<not> (u1, u2) \\<approx>\\<^sub>v\n         conjugate_cvec (reciprocal_cvec (v1, v2))\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>u2 \\<noteq> 0\\<close> \\<open>v2 \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> v1 * cnj v2 \\<noteq> 0 \\<Longrightarrow>\n    circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n     (mk_circline_cmat\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n       (\\<i> *\n        (to_complex_cvec (v1, v2) *\n         ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n         to_complex_cvec (u1, u2) *\n         ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n       (- (\\<i> *\n           (cnj (to_complex_cvec (v1, v2)) *\n            ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n            cnj (to_complex_cvec (u1, u2)) *\n            ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n       (\\<i> *\n        (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n         to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))", "by simp"], ["proof (state)\nthis:\n  circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  circline_eq_cmat (poincare_line_cvec_cmat (u1, u2) (v1, v2))\n   (mk_circline_cmat\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2))))\n     (\\<i> *\n      (to_complex_cvec (v1, v2) *\n       ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n       to_complex_cvec (u1, u2) *\n       ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1)))\n     (- (\\<i> *\n         (cnj (to_complex_cvec (v1, v2)) *\n          ((cor (cmod (to_complex_cvec (u1, u2))))\\<^sup>2 + 1) -\n          cnj (to_complex_cvec (u1, u2)) *\n          ((cor (cmod (to_complex_cvec (v1, v2))))\\<^sup>2 + 1))))\n     (\\<i> *\n      (to_complex_cvec (u1, u2) * cnj (to_complex_cvec (v1, v2)) -\n       to_complex_cvec (v1, v2) * cnj (to_complex_cvec (u1, u2)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Our construction (in homogenous coordinates) always yields an h-line that contain two starting\npoints (this also holds for all degenerate cases except when points are the same).\\<close>"], ["", "lemma poincare_line [simp]:\n  assumes \"z \\<noteq> w\"\n  shows \"on_circline (poincare_line z w) z\"\n        \"on_circline (poincare_line z w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. on_circline (poincare_line z w) z &&& on_circline (poincare_line z w) w", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. on_circline (poincare_line z w) z\n 2. on_circline (poincare_line z w) w", "have \"on_circline (poincare_line z w) z \\<and> on_circline (poincare_line z w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. on_circline (poincare_line z w) z \\<and>\n    on_circline (poincare_line z w) w", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> w\n\ngoal (1 subgoal):\n 1. on_circline (poincare_line z w) z \\<and>\n    on_circline (poincare_line z w) w", "proof (transfer, transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z w za wa.\n       \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero;\n        \\<not> z \\<approx>\\<^sub>v w; \\<not> za \\<approx> wa\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec (poincare_line_cvec_cmat z w)\n                          z \\<and>\n                         on_circline_cmat_cvec (poincare_line_cvec_cmat z w)\n                          w", "fix z w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z w za wa.\n       \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero;\n        \\<not> z \\<approx>\\<^sub>v w; \\<not> za \\<approx> wa\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec (poincare_line_cvec_cmat z w)\n                          z \\<and>\n                         on_circline_cmat_cvec (poincare_line_cvec_cmat z w)\n                          w", "assume vz: \"z \\<noteq> vec_zero\" \"w \\<noteq> vec_zero\""], ["proof (state)\nthis:\n  z \\<noteq> vec_zero\n  w \\<noteq> vec_zero\n\ngoal (1 subgoal):\n 1. \\<And>z w za wa.\n       \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero;\n        \\<not> z \\<approx>\\<^sub>v w; \\<not> za \\<approx> wa\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec (poincare_line_cvec_cmat z w)\n                          z \\<and>\n                         on_circline_cmat_cvec (poincare_line_cvec_cmat z w)\n                          w", "obtain z1 z2 w1 w2 where\n    zw: \"(z1, z2) = z\" \"(w1, w2) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z1 z2 w1 w2.\n        \\<lbrakk>(z1, z2) = z; (w1, w2) = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases z, cases w, auto)"], ["proof (state)\nthis:\n  (z1, z2) = z\n  (w1, w2) = w\n\ngoal (1 subgoal):\n 1. \\<And>z w za wa.\n       \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero;\n        \\<not> z \\<approx>\\<^sub>v w; \\<not> za \\<approx> wa\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec (poincare_line_cvec_cmat z w)\n                          z \\<and>\n                         on_circline_cmat_cvec (poincare_line_cvec_cmat z w)\n                          w", "let ?den = \"z1*cnj z2*cnj w1*w2 - w1*cnj w2*cnj z1*z2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z w za wa.\n       \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero;\n        \\<not> z \\<approx>\\<^sub>v w; \\<not> za \\<approx> wa\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec (poincare_line_cvec_cmat z w)\n                          z \\<and>\n                         on_circline_cmat_cvec (poincare_line_cvec_cmat z w)\n                          w", "have *: \"cor (Re (\\<i> * ?den)) = \\<i> * ?den\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))) =\n    \\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))) =\n    \\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)", "have \"cnj ?den = -?den\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2) =\n    - (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)", "by auto"], ["proof (state)\nthis:\n  cnj (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2) =\n  - (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))) =\n    \\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)", "hence \"is_imag ?den\""], ["proof (prove)\nusing this:\n  cnj (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2) =\n  - (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)\n\ngoal (1 subgoal):\n 1. is_imag (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)", "using eq_minus_cnj_iff_imag[of ?den]"], ["proof (prove)\nusing this:\n  cnj (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2) =\n  - (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)\n  (cnj (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2) =\n   - (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)) =\n  is_imag (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)\n\ngoal (1 subgoal):\n 1. is_imag (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)", "by simp"], ["proof (state)\nthis:\n  is_imag (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))) =\n    \\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_imag (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))) =\n    \\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)", "using complex_of_real_Re[of \"\\<i> * ?den\"]"], ["proof (prove)\nusing this:\n  is_imag (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)\n  is_real\n   (\\<i> *\n    (z1 * cnj z2 * cnj w1 * w2 -\n     w1 * cnj w2 * cnj z1 * z2)) \\<Longrightarrow>\n  cor (Re (\\<i> *\n           (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))) =\n  \\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)\n\ngoal (1 subgoal):\n 1. cor (Re (\\<i> *\n             (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))) =\n    \\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)", "by simp"], ["proof (state)\nthis:\n  cor (Re (\\<i> *\n           (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))) =\n  \\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cor (Re (\\<i> *\n           (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))) =\n  \\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2)\n\ngoal (1 subgoal):\n 1. \\<And>z w za wa.\n       \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero;\n        \\<not> z \\<approx>\\<^sub>v w; \\<not> za \\<approx> wa\\<rbrakk>\n       \\<Longrightarrow> on_circline_cmat_cvec (poincare_line_cvec_cmat z w)\n                          z \\<and>\n                         on_circline_cmat_cvec (poincare_line_cvec_cmat z w)\n                          w", "show \"on_circline_cmat_cvec (poincare_line_cvec_cmat z w) z \\<and>\n          on_circline_cmat_cvec (poincare_line_cvec_cmat z w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. on_circline_cmat_cvec (poincare_line_cvec_cmat z w) z \\<and>\n    on_circline_cmat_cvec (poincare_line_cvec_cmat z w) w", "unfolding poincare_line_cvec_cmat_def mk_poincare_line_cmat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. on_circline_cmat_cvec\n     (let (z1, z2) = z; (w1, w2) = w;\n          nom =\n            w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n            z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2);\n          den = z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2\n      in if den \\<noteq> 0\n         then (cor (Re (\\<i> * den)), \\<i> * nom, cnj (\\<i> * nom),\n               cor (Re (\\<i> * den)))\n         else if z1 * cnj z2 \\<noteq> 0\n              then (cor 0, \\<i> * z1 * cnj z2, cnj (\\<i> * z1 * cnj z2),\n                    cor 0)\n              else if w1 * cnj w2 \\<noteq> 0\n                   then (cor 0, \\<i> * w1 * cnj w2,\n                         cnj (\\<i> * w1 * cnj w2), cor 0)\n                   else (cor 0, \\<i>, cnj \\<i>, cor 0))\n     z \\<and>\n    on_circline_cmat_cvec\n     (let (z1, z2) = z; (w1, w2) = w;\n          nom =\n            w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n            z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2);\n          den = z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2\n      in if den \\<noteq> 0\n         then (cor (Re (\\<i> * den)), \\<i> * nom, cnj (\\<i> * nom),\n               cor (Re (\\<i> * den)))\n         else if z1 * cnj z2 \\<noteq> 0\n              then (cor 0, \\<i> * z1 * cnj z2, cnj (\\<i> * z1 * cnj z2),\n                    cor 0)\n              else if w1 * cnj w2 \\<noteq> 0\n                   then (cor 0, \\<i> * w1 * cnj w2,\n                         cnj (\\<i> * w1 * cnj w2), cor 0)\n                   else (cor 0, \\<i>, cnj \\<i>, cor 0))\n     w", "apply (subst zw[symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. on_circline_cmat_cvec\n     (let (z1, z2) = (z1, z2); (w1, w2) = (w1, w2);\n          nom =\n            w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n            z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2);\n          den = z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2\n      in if den \\<noteq> 0\n         then (cor (Re (\\<i> * den)), \\<i> * nom, cnj (\\<i> * nom),\n               cor (Re (\\<i> * den)))\n         else if z1 * cnj z2 \\<noteq> 0\n              then (cor 0, \\<i> * z1 * cnj z2, cnj (\\<i> * z1 * cnj z2),\n                    cor 0)\n              else if w1 * cnj w2 \\<noteq> 0\n                   then (cor 0, \\<i> * w1 * cnj w2,\n                         cnj (\\<i> * w1 * cnj w2), cor 0)\n                   else (cor 0, \\<i>, cnj \\<i>, cor 0))\n     (z1, z2) \\<and>\n    on_circline_cmat_cvec\n     (let (z1, z2) = (z1, z2); (w1, w2) = (w1, w2);\n          nom =\n            w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n            z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2);\n          den = z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2\n      in if den \\<noteq> 0\n         then (cor (Re (\\<i> * den)), \\<i> * nom, cnj (\\<i> * nom),\n               cor (Re (\\<i> * den)))\n         else if z1 * cnj z2 \\<noteq> 0\n              then (cor 0, \\<i> * z1 * cnj z2, cnj (\\<i> * z1 * cnj z2),\n                    cor 0)\n              else if w1 * cnj w2 \\<noteq> 0\n                   then (cor 0, \\<i> * w1 * cnj w2,\n                         cnj (\\<i> * w1 * cnj w2), cor 0)\n                   else (cor 0, \\<i>, cnj \\<i>, cor 0))\n     (w1, w2)", "unfolding Let_def prod.case"], ["proof (prove)\ngoal (1 subgoal):\n 1. on_circline_cmat_cvec\n     (if z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq> 0\n      then (cor (Re (\\<i> *\n                     (z1 * cnj z2 * cnj w1 * w2 -\n                      w1 * cnj w2 * cnj z1 * z2))),\n            \\<i> *\n            (w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n             z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2)),\n            cnj (\\<i> *\n                 (w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n                  z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2))),\n            cor (Re (\\<i> *\n                     (z1 * cnj z2 * cnj w1 * w2 -\n                      w1 * cnj w2 * cnj z1 * z2))))\n      else if z1 * cnj z2 \\<noteq> 0\n           then (cor 0, \\<i> * z1 * cnj z2, cnj (\\<i> * z1 * cnj z2), cor 0)\n           else if w1 * cnj w2 \\<noteq> 0\n                then (cor 0, \\<i> * w1 * cnj w2, cnj (\\<i> * w1 * cnj w2),\n                      cor 0)\n                else (cor 0, \\<i>, cnj \\<i>, cor 0))\n     (z1, z2) \\<and>\n    on_circline_cmat_cvec\n     (if z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq> 0\n      then (cor (Re (\\<i> *\n                     (z1 * cnj z2 * cnj w1 * w2 -\n                      w1 * cnj w2 * cnj z1 * z2))),\n            \\<i> *\n            (w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n             z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2)),\n            cnj (\\<i> *\n                 (w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n                  z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2))),\n            cor (Re (\\<i> *\n                     (z1 * cnj z2 * cnj w1 * w2 -\n                      w1 * cnj w2 * cnj z1 * z2))))\n      else if z1 * cnj z2 \\<noteq> 0\n           then (cor 0, \\<i> * z1 * cnj z2, cnj (\\<i> * z1 * cnj z2), cor 0)\n           else if w1 * cnj w2 \\<noteq> 0\n                then (cor 0, \\<i> * w1 * cnj w2, cnj (\\<i> * w1 * cnj w2),\n                      cor 0)\n                else (cor 0, \\<i>, cnj \\<i>, cor 0))\n     (w1, w2)", "apply (subst *)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. on_circline_cmat_cvec\n     (if z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq> 0\n      then (\\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2),\n            \\<i> *\n            (w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n             z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2)),\n            cnj (\\<i> *\n                 (w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n                  z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2))),\n            \\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))\n      else if z1 * cnj z2 \\<noteq> 0\n           then (cor 0, \\<i> * z1 * cnj z2, cnj (\\<i> * z1 * cnj z2), cor 0)\n           else if w1 * cnj w2 \\<noteq> 0\n                then (cor 0, \\<i> * w1 * cnj w2, cnj (\\<i> * w1 * cnj w2),\n                      cor 0)\n                else (cor 0, \\<i>, cnj \\<i>, cor 0))\n     (z1, z2) \\<and>\n    on_circline_cmat_cvec\n     (if z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2 \\<noteq> 0\n      then (\\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2),\n            \\<i> *\n            (w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n             z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2)),\n            cnj (\\<i> *\n                 (w1 * cnj w2 * (z1 * cnj z1 + z2 * cnj z2) -\n                  z1 * cnj z2 * (w1 * cnj w1 + w2 * cnj w2))),\n            \\<i> * (z1 * cnj z2 * cnj w1 * w2 - w1 * cnj w2 * cnj z1 * z2))\n      else if z1 * cnj z2 \\<noteq> 0\n           then (cor 0, \\<i> * z1 * cnj z2, cnj (\\<i> * z1 * cnj z2), cor 0)\n           else if w1 * cnj w2 \\<noteq> 0\n                then (cor 0, \\<i> * w1 * cnj w2, cnj (\\<i> * w1 * cnj w2),\n                      cor 0)\n                else (cor 0, \\<i>, cnj \\<i>, cor 0))\n     (w1, w2)", "by (auto simp add: vec_cnj_def field_simps)"], ["proof (state)\nthis:\n  on_circline_cmat_cvec (poincare_line_cvec_cmat z w) z \\<and>\n  on_circline_cmat_cvec (poincare_line_cvec_cmat z w) w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  on_circline (poincare_line z w) z \\<and> on_circline (poincare_line z w) w\n\ngoal (2 subgoals):\n 1. on_circline (poincare_line z w) z\n 2. on_circline (poincare_line z w) w", "thus \"on_circline (poincare_line z w) z\" \"on_circline (poincare_line z w) w\""], ["proof (prove)\nusing this:\n  on_circline (poincare_line z w) z \\<and> on_circline (poincare_line z w) w\n\ngoal (1 subgoal):\n 1. on_circline (poincare_line z w) z &&& on_circline (poincare_line z w) w", "by auto"], ["proof (state)\nthis:\n  on_circline (poincare_line z w) z\n  on_circline (poincare_line z w) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poincare_line_circline_set [simp]:\n  assumes \"z \\<noteq> w\"\n  shows \"z \\<in> circline_set (poincare_line z w)\"\n        \"w \\<in> circline_set (poincare_line z w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> circline_set (poincare_line z w) &&&\n    w \\<in> circline_set (poincare_line z w)", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> w\n\ngoal (1 subgoal):\n 1. z \\<in> circline_set (poincare_line z w) &&&\n    w \\<in> circline_set (poincare_line z w)", "by (auto simp add: circline_set_def)"], ["", "text\\<open>When the points are different, the constructed line matrix always has a negative determinant\\<close>"], ["", "lemma poincare_line_type:\n  assumes \"z \\<noteq> w\"\n  shows \"circline_type (poincare_line z w) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circline_type (poincare_line z w) = - 1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. circline_type (poincare_line z w) = - 1", "have \"\\<exists> a b. a \\<noteq> b \\<and> {a, b} \\<subseteq> circline_set (poincare_line z w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       {a, b} \\<subseteq> circline_set (poincare_line z w)", "using poincare_line[of z w] assms"], ["proof (prove)\nusing this:\n  z \\<noteq> w \\<Longrightarrow> on_circline (poincare_line z w) z\n  z \\<noteq> w \\<Longrightarrow> on_circline (poincare_line z w) w\n  z \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       {a, b} \\<subseteq> circline_set (poincare_line z w)", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  z \\<noteq> w \\<Longrightarrow> on_circline (poincare_line z w) z\n  z \\<noteq> w \\<Longrightarrow> on_circline (poincare_line z w) w\n  z \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> b \\<and>\n       {a, b} \\<subseteq> Collect (on_circline (poincare_line z w))", "by (rule_tac x=z in exI, rule_tac x=w in exI, simp)"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> b \\<and> {a, b} \\<subseteq> circline_set (poincare_line z w)\n\ngoal (1 subgoal):\n 1. circline_type (poincare_line z w) = - 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     a \\<noteq> b \\<and> {a, b} \\<subseteq> circline_set (poincare_line z w)\n\ngoal (1 subgoal):\n 1. circline_type (poincare_line z w) = - 1", "using circline_type[of \"poincare_line z w\"]"], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     a \\<noteq> b \\<and> {a, b} \\<subseteq> circline_set (poincare_line z w)\n  circline_type (poincare_line z w) = - 1 \\<or>\n  circline_type (poincare_line z w) = 0 \\<or>\n  circline_type (poincare_line z w) = 1\n\ngoal (1 subgoal):\n 1. circline_type (poincare_line z w) = - 1", "using circline_type_pos_card_eq0[of \"poincare_line z w\"]"], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     a \\<noteq> b \\<and> {a, b} \\<subseteq> circline_set (poincare_line z w)\n  circline_type (poincare_line z w) = - 1 \\<or>\n  circline_type (poincare_line z w) = 0 \\<or>\n  circline_type (poincare_line z w) = 1\n  0 < circline_type (poincare_line z w) \\<Longrightarrow>\n  circline_set (poincare_line z w) = {}\n\ngoal (1 subgoal):\n 1. circline_type (poincare_line z w) = - 1", "using circline_type_zero_card_eq1[of \"poincare_line z w\"]"], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     a \\<noteq> b \\<and> {a, b} \\<subseteq> circline_set (poincare_line z w)\n  circline_type (poincare_line z w) = - 1 \\<or>\n  circline_type (poincare_line z w) = 0 \\<or>\n  circline_type (poincare_line z w) = 1\n  0 < circline_type (poincare_line z w) \\<Longrightarrow>\n  circline_set (poincare_line z w) = {}\n  circline_type (poincare_line z w) = 0 \\<Longrightarrow>\n  \\<exists>za. circline_set (poincare_line z w) = {za}\n\ngoal (1 subgoal):\n 1. circline_type (poincare_line z w) = - 1", "by auto"], ["proof (state)\nthis:\n  circline_type (poincare_line z w) = - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The constructed line is an h-line in the Poincar\\'e model (in all cases when the two points are\ndifferent)\\<close>"], ["", "lemma is_poincare_line_poincare_line [simp]:\n  assumes \"z \\<noteq> w\"\n  shows \"is_poincare_line (poincare_line z w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line (poincare_line z w)", "using poincare_line_type[of z w, OF assms]"], ["proof (prove)\nusing this:\n  circline_type (poincare_line z w) = - 1\n\ngoal (1 subgoal):\n 1. is_poincare_line (poincare_line z w)", "proof (transfer, transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z w za wa.\n       \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero;\n        circline_type_cmat (poincare_line_cvec_cmat z w) = - 1;\n        circline_type_clmat (poincare_line_hcoords_clmat za wa) =\n        - 1\\<rbrakk>\n       \\<Longrightarrow> is_poincare_line_cmat (poincare_line_cvec_cmat z w)", "fix z w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z w za wa.\n       \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero;\n        circline_type_cmat (poincare_line_cvec_cmat z w) = - 1;\n        circline_type_clmat (poincare_line_hcoords_clmat za wa) =\n        - 1\\<rbrakk>\n       \\<Longrightarrow> is_poincare_line_cmat (poincare_line_cvec_cmat z w)", "assume vz: \"z \\<noteq> vec_zero\" \"w \\<noteq> vec_zero\""], ["proof (state)\nthis:\n  z \\<noteq> vec_zero\n  w \\<noteq> vec_zero\n\ngoal (1 subgoal):\n 1. \\<And>z w za wa.\n       \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero;\n        circline_type_cmat (poincare_line_cvec_cmat z w) = - 1;\n        circline_type_clmat (poincare_line_hcoords_clmat za wa) =\n        - 1\\<rbrakk>\n       \\<Longrightarrow> is_poincare_line_cmat (poincare_line_cvec_cmat z w)", "obtain A B C D where *: \"poincare_line_cvec_cmat z w = (A, B, C, D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A B C D.\n        poincare_line_cvec_cmat z w = (A, B, C, D) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"poincare_line_cvec_cmat z w\") auto"], ["proof (state)\nthis:\n  poincare_line_cvec_cmat z w = (A, B, C, D)\n\ngoal (1 subgoal):\n 1. \\<And>z w za wa.\n       \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero;\n        circline_type_cmat (poincare_line_cvec_cmat z w) = - 1;\n        circline_type_clmat (poincare_line_hcoords_clmat za wa) =\n        - 1\\<rbrakk>\n       \\<Longrightarrow> is_poincare_line_cmat (poincare_line_cvec_cmat z w)", "assume \"circline_type_cmat (poincare_line_cvec_cmat z w) = - 1\""], ["proof (state)\nthis:\n  circline_type_cmat (poincare_line_cvec_cmat z w) = - 1\n\ngoal (1 subgoal):\n 1. \\<And>z w za wa.\n       \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero;\n        circline_type_cmat (poincare_line_cvec_cmat z w) = - 1;\n        circline_type_clmat (poincare_line_hcoords_clmat za wa) =\n        - 1\\<rbrakk>\n       \\<Longrightarrow> is_poincare_line_cmat (poincare_line_cvec_cmat z w)", "thus \"is_poincare_line_cmat (poincare_line_cvec_cmat z w)\""], ["proof (prove)\nusing this:\n  circline_type_cmat (poincare_line_cvec_cmat z w) = - 1\n\ngoal (1 subgoal):\n 1. is_poincare_line_cmat (poincare_line_cvec_cmat z w)", "using vz *"], ["proof (prove)\nusing this:\n  circline_type_cmat (poincare_line_cvec_cmat z w) = - 1\n  z \\<noteq> vec_zero\n  w \\<noteq> vec_zero\n  poincare_line_cvec_cmat z w = (A, B, C, D)\n\ngoal (1 subgoal):\n 1. is_poincare_line_cmat (poincare_line_cvec_cmat z w)", "using poincare_line_cvec_cmat_hermitean[of z w]"], ["proof (prove)\nusing this:\n  circline_type_cmat (poincare_line_cvec_cmat z w) = - 1\n  z \\<noteq> vec_zero\n  w \\<noteq> vec_zero\n  poincare_line_cvec_cmat z w = (A, B, C, D)\n  hermitean (poincare_line_cvec_cmat z w)\n\ngoal (1 subgoal):\n 1. is_poincare_line_cmat (poincare_line_cvec_cmat z w)", "using poincare_line_cvec_cmat_nonzero[of z w]"], ["proof (prove)\nusing this:\n  circline_type_cmat (poincare_line_cvec_cmat z w) = - 1\n  z \\<noteq> vec_zero\n  w \\<noteq> vec_zero\n  poincare_line_cvec_cmat z w = (A, B, C, D)\n  hermitean (poincare_line_cvec_cmat z w)\n  \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero\\<rbrakk>\n  \\<Longrightarrow> poincare_line_cvec_cmat z w \\<noteq> mat_zero\n\ngoal (1 subgoal):\n 1. is_poincare_line_cmat (poincare_line_cvec_cmat z w)", "using poincare_line_cvec_cmat_AeqD[of z w A B C D]"], ["proof (prove)\nusing this:\n  circline_type_cmat (poincare_line_cvec_cmat z w) = - 1\n  z \\<noteq> vec_zero\n  w \\<noteq> vec_zero\n  poincare_line_cvec_cmat z w = (A, B, C, D)\n  hermitean (poincare_line_cvec_cmat z w)\n  \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero\\<rbrakk>\n  \\<Longrightarrow> poincare_line_cvec_cmat z w \\<noteq> mat_zero\n  poincare_line_cvec_cmat z w = (A, B, C, D) \\<Longrightarrow> A = D\n\ngoal (1 subgoal):\n 1. is_poincare_line_cmat (poincare_line_cvec_cmat z w)", "using hermitean_elems[of A B C D]"], ["proof (prove)\nusing this:\n  circline_type_cmat (poincare_line_cvec_cmat z w) = - 1\n  z \\<noteq> vec_zero\n  w \\<noteq> vec_zero\n  poincare_line_cvec_cmat z w = (A, B, C, D)\n  hermitean (poincare_line_cvec_cmat z w)\n  \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero\\<rbrakk>\n  \\<Longrightarrow> poincare_line_cvec_cmat z w \\<noteq> mat_zero\n  poincare_line_cvec_cmat z w = (A, B, C, D) \\<Longrightarrow> A = D\n  hermitean (A, B, C, D) \\<Longrightarrow> is_real A\n  hermitean (A, B, C, D) \\<Longrightarrow> is_real D\n  hermitean (A, B, C, D) \\<Longrightarrow> B = cnj C\n  hermitean (A, B, C, D) \\<Longrightarrow> cnj B = C\n\ngoal (1 subgoal):\n 1. is_poincare_line_cmat (poincare_line_cvec_cmat z w)", "using cmod_power2[of D] cmod_power2[of C]"], ["proof (prove)\nusing this:\n  circline_type_cmat (poincare_line_cvec_cmat z w) = - 1\n  z \\<noteq> vec_zero\n  w \\<noteq> vec_zero\n  poincare_line_cvec_cmat z w = (A, B, C, D)\n  hermitean (poincare_line_cvec_cmat z w)\n  \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero\\<rbrakk>\n  \\<Longrightarrow> poincare_line_cvec_cmat z w \\<noteq> mat_zero\n  poincare_line_cvec_cmat z w = (A, B, C, D) \\<Longrightarrow> A = D\n  hermitean (A, B, C, D) \\<Longrightarrow> is_real A\n  hermitean (A, B, C, D) \\<Longrightarrow> is_real D\n  hermitean (A, B, C, D) \\<Longrightarrow> B = cnj C\n  hermitean (A, B, C, D) \\<Longrightarrow> cnj B = C\n  (cmod D)\\<^sup>2 = (Re D)\\<^sup>2 + (Im D)\\<^sup>2\n  (cmod C)\\<^sup>2 = (Re C)\\<^sup>2 + (Im C)\\<^sup>2\n\ngoal (1 subgoal):\n 1. is_poincare_line_cmat (poincare_line_cvec_cmat z w)", "unfolding is_poincare_line_cmat_def"], ["proof (prove)\nusing this:\n  circline_type_cmat (poincare_line_cvec_cmat z w) = - 1\n  z \\<noteq> vec_zero\n  w \\<noteq> vec_zero\n  poincare_line_cvec_cmat z w = (A, B, C, D)\n  hermitean (poincare_line_cvec_cmat z w)\n  \\<lbrakk>z \\<noteq> vec_zero; w \\<noteq> vec_zero\\<rbrakk>\n  \\<Longrightarrow> poincare_line_cvec_cmat z w \\<noteq> mat_zero\n  poincare_line_cvec_cmat z w = (A, B, C, D) \\<Longrightarrow> A = D\n  hermitean (A, B, C, D) \\<Longrightarrow> is_real A\n  hermitean (A, B, C, D) \\<Longrightarrow> is_real D\n  hermitean (A, B, C, D) \\<Longrightarrow> B = cnj C\n  hermitean (A, B, C, D) \\<Longrightarrow> cnj B = C\n  (cmod D)\\<^sup>2 = (Re D)\\<^sup>2 + (Im D)\\<^sup>2\n  (cmod C)\\<^sup>2 = (Re C)\\<^sup>2 + (Im C)\\<^sup>2\n\ngoal (1 subgoal):\n 1. let (A, B, C, D) = poincare_line_cvec_cmat z w\n    in hermitean (A, B, C, D) \\<and>\n       A = D \\<and> (cmod A)\\<^sup>2 < (cmod B)\\<^sup>2", "by (simp del: poincare_line_cvec_cmat_def add: sgn_1_neg power2_eq_square)"], ["proof (state)\nthis:\n  is_poincare_line_cmat (poincare_line_cvec_cmat z w)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>When the points are different, the constructed h-line between two points also contains their inverses\\<close>"], ["", "lemma poincare_line_inversion:\n  assumes \"z \\<noteq> w\"\n  shows \"on_circline (poincare_line z w) (inversion z)\"\n        \"on_circline (poincare_line z w) (inversion w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. on_circline (poincare_line z w) (inversion z) &&&\n    on_circline (poincare_line z w) (inversion w)", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> w\n\ngoal (1 subgoal):\n 1. on_circline (poincare_line z w) (inversion z) &&&\n    on_circline (poincare_line z w) (inversion w)", "using is_poincare_line_poincare_line[OF \\<open>z \\<noteq> w\\<close>]"], ["proof (prove)\nusing this:\n  z \\<noteq> w\n  is_poincare_line (poincare_line z w)\n\ngoal (1 subgoal):\n 1. on_circline (poincare_line z w) (inversion z) &&&\n    on_circline (poincare_line z w) (inversion w)", "using is_poincare_line_inverse_point"], ["proof (prove)\nusing this:\n  z \\<noteq> w\n  is_poincare_line (poincare_line z w)\n  \\<lbrakk>is_poincare_line ?H; ?u \\<in> circline_set ?H\\<rbrakk>\n  \\<Longrightarrow> inversion ?u \\<in> circline_set ?H\n\ngoal (1 subgoal):\n 1. on_circline (poincare_line z w) (inversion z) &&&\n    on_circline (poincare_line z w) (inversion w)", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  z \\<noteq> w\n  is_poincare_line (poincare_line z w)\n  \\<lbrakk>is_poincare_line ?H; ?u \\<in> Collect (on_circline ?H)\\<rbrakk>\n  \\<Longrightarrow> inversion ?u \\<in> Collect (on_circline ?H)\n\ngoal (1 subgoal):\n 1. on_circline (poincare_line z w) (inversion z) &&&\n    on_circline (poincare_line z w) (inversion w)", "by auto"], ["", "text \\<open>When the points are different, the onstructed h-line between two points contains the inverse of its every point\\<close>"], ["", "lemma poincare_line_inversion_full:\n  assumes \"u \\<noteq> v\"\n  assumes \"on_circline (poincare_line u v) x\"\n  shows \"on_circline (poincare_line u v) (inversion x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. on_circline (poincare_line u v) (inversion x)", "using is_poincare_line_inverse_point[of \"poincare_line u v\" x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_poincare_line (poincare_line u v);\n   x \\<in> circline_set (poincare_line u v)\\<rbrakk>\n  \\<Longrightarrow> inversion x \\<in> circline_set (poincare_line u v)\n\ngoal (1 subgoal):\n 1. on_circline (poincare_line u v) (inversion x)", "using is_poincare_line_poincare_line[OF \\<open>u \\<noteq> v\\<close>] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_poincare_line (poincare_line u v);\n   x \\<in> circline_set (poincare_line u v)\\<rbrakk>\n  \\<Longrightarrow> inversion x \\<in> circline_set (poincare_line u v)\n  is_poincare_line (poincare_line u v)\n  u \\<noteq> v\n  on_circline (poincare_line u v) x\n\ngoal (1 subgoal):\n 1. on_circline (poincare_line u v) (inversion x)", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_poincare_line (poincare_line u v);\n   x \\<in> Collect (on_circline (poincare_line u v))\\<rbrakk>\n  \\<Longrightarrow> inversion x\n                    \\<in> Collect (on_circline (poincare_line u v))\n  is_poincare_line (poincare_line u v)\n  u \\<noteq> v\n  on_circline (poincare_line u v) x\n\ngoal (1 subgoal):\n 1. on_circline (poincare_line u v) (inversion x)", "by simp"], ["", "subsubsection \\<open>Existence of h-lines\\<close>"], ["", "text\\<open>There is an h-line trough every point in the Poincar\\'e model\\<close>"], ["", "lemma ex_poincare_line_one_point:\n  shows \"\\<exists> l. is_poincare_line l \\<and> z \\<in> circline_set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. is_poincare_line l \\<and> z \\<in> circline_set l", "proof (cases \"z = 0\\<^sub>h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = 0\\<^sub>h \\<Longrightarrow>\n    \\<exists>l. is_poincare_line l \\<and> z \\<in> circline_set l\n 2. z \\<noteq> 0\\<^sub>h \\<Longrightarrow>\n    \\<exists>l. is_poincare_line l \\<and> z \\<in> circline_set l", "case True"], ["proof (state)\nthis:\n  z = 0\\<^sub>h\n\ngoal (2 subgoals):\n 1. z = 0\\<^sub>h \\<Longrightarrow>\n    \\<exists>l. is_poincare_line l \\<and> z \\<in> circline_set l\n 2. z \\<noteq> 0\\<^sub>h \\<Longrightarrow>\n    \\<exists>l. is_poincare_line l \\<and> z \\<in> circline_set l", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<exists>l. is_poincare_line l \\<and> z \\<in> circline_set l", "by (rule_tac x=\"x_axis\" in exI) simp"], ["proof (state)\nthis:\n  \\<exists>l. is_poincare_line l \\<and> z \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0\\<^sub>h \\<Longrightarrow>\n    \\<exists>l. is_poincare_line l \\<and> z \\<in> circline_set l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<noteq> 0\\<^sub>h \\<Longrightarrow>\n    \\<exists>l. is_poincare_line l \\<and> z \\<in> circline_set l", "case False"], ["proof (state)\nthis:\n  z \\<noteq> 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0\\<^sub>h \\<Longrightarrow>\n    \\<exists>l. is_poincare_line l \\<and> z \\<in> circline_set l", "thus ?thesis"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<exists>l. is_poincare_line l \\<and> z \\<in> circline_set l", "by (rule_tac x=\"poincare_line 0\\<^sub>h z\" in exI) auto"], ["proof (state)\nthis:\n  \\<exists>l. is_poincare_line l \\<and> z \\<in> circline_set l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poincare_collinear_singleton [simp]:\n  assumes \"u \\<in> unit_disc\"\n  shows \"poincare_collinear {u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_collinear {u}", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_collinear {u}", "using ex_poincare_line_one_point[of u]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  \\<exists>l. is_poincare_line l \\<and> u \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. poincare_collinear {u}", "by (auto simp add: poincare_collinear_def)"], ["", "text\\<open>There is an h-line trough every two points in the Poincar\\'e model\\<close>"], ["", "lemma ex_poincare_line_two_points:\n  assumes \"z \\<noteq> w\"\n  shows \"\\<exists> l. is_poincare_line l \\<and> z \\<in> circline_set l \\<and> w \\<in> circline_set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       is_poincare_line l \\<and>\n       z \\<in> circline_set l \\<and> w \\<in> circline_set l", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       is_poincare_line l \\<and>\n       z \\<in> circline_set l \\<and> w \\<in> circline_set l", "by (rule_tac x=\"poincare_line z w\" in exI, simp)"], ["", "lemma poincare_collinear_doubleton [simp]:\n  assumes \"u \\<in> unit_disc\" \"v \\<in> unit_disc\"\n  shows \"poincare_collinear {u, v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_collinear {u, v}", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_collinear {u, v}", "using ex_poincare_line_one_point[of u]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  \\<exists>l. is_poincare_line l \\<and> u \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. poincare_collinear {u, v}", "using ex_poincare_line_two_points[of u v]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  \\<exists>l. is_poincare_line l \\<and> u \\<in> circline_set l\n  u \\<noteq> v \\<Longrightarrow>\n  \\<exists>l.\n     is_poincare_line l \\<and>\n     u \\<in> circline_set l \\<and> v \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. poincare_collinear {u, v}", "by (cases \"u = v\") (simp_all add: poincare_collinear_def)"], ["", "subsubsection \\<open>Uniqueness of h-lines\\<close>"], ["", "text \\<open>The only h-line between two points is the one obtained by the line-construction.\\<close>"], ["", "text \\<open>First we show this only for two different points inside the disc.\\<close>"], ["", "lemma unique_poincare_line:\n  assumes in_disc: \"u \\<noteq> v\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\"\n  assumes on_l: \"u \\<in> circline_set l\" \"v \\<in> circline_set l\" \"is_poincare_line l\"\n  shows \"l = poincare_line u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = poincare_line u v", "using assms"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<in> circline_set l\n  v \\<in> circline_set l\n  is_poincare_line l\n\ngoal (1 subgoal):\n 1. l = poincare_line u v", "using unique_is_poincare_line[of u v l \"poincare_line u v\"]"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<in> circline_set l\n  v \\<in> circline_set l\n  is_poincare_line l\n  \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc; u \\<noteq> v;\n   is_poincare_line l; is_poincare_line (poincare_line u v);\n   {u, v}\n   \\<subseteq> circline_set l \\<inter>\n               circline_set (poincare_line u v)\\<rbrakk>\n  \\<Longrightarrow> l = poincare_line u v\n\ngoal (1 subgoal):\n 1. l = poincare_line u v", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<in> Collect (on_circline l)\n  v \\<in> Collect (on_circline l)\n  is_poincare_line l\n  \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc; u \\<noteq> v;\n   is_poincare_line l; is_poincare_line (poincare_line u v);\n   {u, v}\n   \\<subseteq> Collect (on_circline l) \\<inter>\n               Collect (on_circline (poincare_line u v))\\<rbrakk>\n  \\<Longrightarrow> l = poincare_line u v\n\ngoal (1 subgoal):\n 1. l = poincare_line u v", "by auto"], ["", "text\\<open>The assumption that the points are inside the disc can be relaxed.\\<close>"], ["", "lemma unique_poincare_line_general:\n  assumes in_disc: \"u \\<noteq> v\" \"u \\<noteq> inversion v\"\n  assumes on_l: \"u \\<in> circline_set l\" \"v \\<in> circline_set l\" \"is_poincare_line l\"\n  shows \"l = poincare_line u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = poincare_line u v", "using assms"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<noteq> inversion v\n  u \\<in> circline_set l\n  v \\<in> circline_set l\n  is_poincare_line l\n\ngoal (1 subgoal):\n 1. l = poincare_line u v", "using unique_is_poincare_line_general[of u v l \"poincare_line u v\"]"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<noteq> inversion v\n  u \\<in> circline_set l\n  v \\<in> circline_set l\n  is_poincare_line l\n  \\<lbrakk>u \\<noteq> v; u \\<noteq> inversion v; is_poincare_line l;\n   is_poincare_line (poincare_line u v);\n   {u, v}\n   \\<subseteq> circline_set l \\<inter>\n               circline_set (poincare_line u v)\\<rbrakk>\n  \\<Longrightarrow> l = poincare_line u v\n\ngoal (1 subgoal):\n 1. l = poincare_line u v", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<noteq> inversion v\n  u \\<in> Collect (on_circline l)\n  v \\<in> Collect (on_circline l)\n  is_poincare_line l\n  \\<lbrakk>u \\<noteq> v; u \\<noteq> inversion v; is_poincare_line l;\n   is_poincare_line (poincare_line u v);\n   {u, v}\n   \\<subseteq> Collect (on_circline l) \\<inter>\n               Collect (on_circline (poincare_line u v))\\<rbrakk>\n  \\<Longrightarrow> l = poincare_line u v\n\ngoal (1 subgoal):\n 1. l = poincare_line u v", "by auto"], ["", "text\\<open>The explicit line construction enables us to prove that there exists a unique h-line through any\ngiven two h-points (uniqueness part was already shown earlier).\\<close>"], ["", "text \\<open>First we show this only for two different points inside the disc.\\<close>"], ["", "lemma ex1_poincare_line:\n  assumes \"u \\<noteq> v\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\"\n  shows \"\\<exists>! l. is_poincare_line l \\<and> u \\<in> circline_set l \\<and> v \\<in> circline_set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and> v \\<in> circline_set l", "proof (rule ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_poincare_line ?a \\<and>\n    u \\<in> circline_set ?a \\<and> v \\<in> circline_set ?a\n 2. \\<And>l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and>\n       v \\<in> circline_set l \\<Longrightarrow>\n       l = ?a", "let ?l = \"poincare_line u v\""], ["proof (state)\ngoal (2 subgoals):\n 1. is_poincare_line ?a \\<and>\n    u \\<in> circline_set ?a \\<and> v \\<in> circline_set ?a\n 2. \\<And>l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and>\n       v \\<in> circline_set l \\<Longrightarrow>\n       l = ?a", "show \"is_poincare_line ?l \\<and> u \\<in> circline_set ?l \\<and> v \\<in> circline_set ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line (poincare_line u v) \\<and>\n    u \\<in> circline_set (poincare_line u v) \\<and>\n    v \\<in> circline_set (poincare_line u v)", "using assms"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. is_poincare_line (poincare_line u v) \\<and>\n    u \\<in> circline_set (poincare_line u v) \\<and>\n    v \\<in> circline_set (poincare_line u v)", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. is_poincare_line (poincare_line u v) \\<and>\n    u \\<in> Collect (on_circline (poincare_line u v)) \\<and>\n    v \\<in> Collect (on_circline (poincare_line u v))", "by auto"], ["proof (state)\nthis:\n  is_poincare_line (poincare_line u v) \\<and>\n  u \\<in> circline_set (poincare_line u v) \\<and>\n  v \\<in> circline_set (poincare_line u v)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and>\n       v \\<in> circline_set l \\<Longrightarrow>\n       l = poincare_line u v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and>\n       v \\<in> circline_set l \\<Longrightarrow>\n       l = poincare_line u v", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and>\n       v \\<in> circline_set l \\<Longrightarrow>\n       l = poincare_line u v", "assume \"is_poincare_line l \\<and> u \\<in> circline_set l \\<and> v \\<in> circline_set l\""], ["proof (state)\nthis:\n  is_poincare_line l \\<and>\n  u \\<in> circline_set l \\<and> v \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and>\n       v \\<in> circline_set l \\<Longrightarrow>\n       l = poincare_line u v", "thus \"l = poincare_line u v\""], ["proof (prove)\nusing this:\n  is_poincare_line l \\<and>\n  u \\<in> circline_set l \\<and> v \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. l = poincare_line u v", "using unique_poincare_line assms"], ["proof (prove)\nusing this:\n  is_poincare_line l \\<and>\n  u \\<in> circline_set l \\<and> v \\<in> circline_set l\n  \\<lbrakk>?u \\<noteq> ?v; ?u \\<in> unit_disc; ?v \\<in> unit_disc;\n   ?u \\<in> circline_set ?l; ?v \\<in> circline_set ?l;\n   is_poincare_line ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = poincare_line ?u ?v\n  u \\<noteq> v\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. l = poincare_line u v", "by auto"], ["proof (state)\nthis:\n  l = poincare_line u v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The assumption that the points are in the disc can be relaxed.\\<close>"], ["", "lemma ex1_poincare_line_general:\n  assumes \"u \\<noteq> v\" \"u \\<noteq> inversion v\"\n  shows \"\\<exists>! l. is_poincare_line l \\<and> u \\<in> circline_set l \\<and> v \\<in> circline_set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and> v \\<in> circline_set l", "proof (rule ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_poincare_line ?a \\<and>\n    u \\<in> circline_set ?a \\<and> v \\<in> circline_set ?a\n 2. \\<And>l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and>\n       v \\<in> circline_set l \\<Longrightarrow>\n       l = ?a", "let ?l = \"poincare_line u v\""], ["proof (state)\ngoal (2 subgoals):\n 1. is_poincare_line ?a \\<and>\n    u \\<in> circline_set ?a \\<and> v \\<in> circline_set ?a\n 2. \\<And>l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and>\n       v \\<in> circline_set l \\<Longrightarrow>\n       l = ?a", "show \"is_poincare_line ?l \\<and> u \\<in> circline_set ?l \\<and> v \\<in> circline_set ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line (poincare_line u v) \\<and>\n    u \\<in> circline_set (poincare_line u v) \\<and>\n    v \\<in> circline_set (poincare_line u v)", "using assms"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<noteq> inversion v\n\ngoal (1 subgoal):\n 1. is_poincare_line (poincare_line u v) \\<and>\n    u \\<in> circline_set (poincare_line u v) \\<and>\n    v \\<in> circline_set (poincare_line u v)", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<noteq> inversion v\n\ngoal (1 subgoal):\n 1. is_poincare_line (poincare_line u v) \\<and>\n    u \\<in> Collect (on_circline (poincare_line u v)) \\<and>\n    v \\<in> Collect (on_circline (poincare_line u v))", "by auto"], ["proof (state)\nthis:\n  is_poincare_line (poincare_line u v) \\<and>\n  u \\<in> circline_set (poincare_line u v) \\<and>\n  v \\<in> circline_set (poincare_line u v)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and>\n       v \\<in> circline_set l \\<Longrightarrow>\n       l = poincare_line u v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and>\n       v \\<in> circline_set l \\<Longrightarrow>\n       l = poincare_line u v", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and>\n       v \\<in> circline_set l \\<Longrightarrow>\n       l = poincare_line u v", "assume \"is_poincare_line l \\<and> u \\<in> circline_set l \\<and> v \\<in> circline_set l\""], ["proof (state)\nthis:\n  is_poincare_line l \\<and>\n  u \\<in> circline_set l \\<and> v \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       is_poincare_line l \\<and>\n       u \\<in> circline_set l \\<and>\n       v \\<in> circline_set l \\<Longrightarrow>\n       l = poincare_line u v", "thus \"l = poincare_line u v\""], ["proof (prove)\nusing this:\n  is_poincare_line l \\<and>\n  u \\<in> circline_set l \\<and> v \\<in> circline_set l\n\ngoal (1 subgoal):\n 1. l = poincare_line u v", "using unique_poincare_line_general assms"], ["proof (prove)\nusing this:\n  is_poincare_line l \\<and>\n  u \\<in> circline_set l \\<and> v \\<in> circline_set l\n  \\<lbrakk>?u \\<noteq> ?v; ?u \\<noteq> inversion ?v;\n   ?u \\<in> circline_set ?l; ?v \\<in> circline_set ?l;\n   is_poincare_line ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = poincare_line ?u ?v\n  u \\<noteq> v\n  u \\<noteq> inversion v\n\ngoal (1 subgoal):\n 1. l = poincare_line u v", "by auto"], ["proof (state)\nthis:\n  l = poincare_line u v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Some consequences of line uniqueness\\<close>"], ["", "text\\<open>H-line $uv$ is the same as the h-line $vu$.\\<close>"], ["", "lemma poincare_line_sym:\n  assumes \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\"\n  shows \"poincare_line u v = poincare_line v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line u v = poincare_line v u", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. poincare_line u v = poincare_line v u", "using unique_poincare_line[of u v \"poincare_line v u\"]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n  \\<lbrakk>u \\<noteq> v; u \\<in> unit_disc; v \\<in> unit_disc;\n   u \\<in> circline_set (poincare_line v u);\n   v \\<in> circline_set (poincare_line v u);\n   is_poincare_line (poincare_line v u)\\<rbrakk>\n  \\<Longrightarrow> poincare_line v u = poincare_line u v\n\ngoal (1 subgoal):\n 1. poincare_line u v = poincare_line v u", "by simp"], ["", "lemma poincare_line_sym_general:\n  assumes \"u \\<noteq> v\" \"u \\<noteq> inversion v\"\n  shows \"poincare_line u v = poincare_line v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line u v = poincare_line v u", "using assms"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<noteq> inversion v\n\ngoal (1 subgoal):\n 1. poincare_line u v = poincare_line v u", "using unique_poincare_line_general[of u v \"poincare_line v u\"]"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<noteq> inversion v\n  \\<lbrakk>u \\<noteq> v; u \\<noteq> inversion v;\n   u \\<in> circline_set (poincare_line v u);\n   v \\<in> circline_set (poincare_line v u);\n   is_poincare_line (poincare_line v u)\\<rbrakk>\n  \\<Longrightarrow> poincare_line v u = poincare_line u v\n\ngoal (1 subgoal):\n 1. poincare_line u v = poincare_line v u", "by simp"], ["", "text\\<open>Each h-line is the h-line constructed out of its two arbitrary different points.\\<close>"], ["", "lemma ex_poincare_line_points:\n  assumes \"is_poincare_line H\"\n  shows \"\\<exists> u v. u \\<in> unit_disc \\<and> v \\<in> unit_disc \\<and> u \\<noteq> v \\<and> H = poincare_line u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and> u \\<noteq> v \\<and> H = poincare_line u v", "using assms"], ["proof (prove)\nusing this:\n  is_poincare_line H\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and> u \\<noteq> v \\<and> H = poincare_line u v", "using ex_is_poincare_line_points"], ["proof (prove)\nusing this:\n  is_poincare_line H\n  is_poincare_line ?H \\<Longrightarrow>\n  \\<exists>u v.\n     u \\<in> unit_disc \\<and>\n     v \\<in> unit_disc \\<and>\n     u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set ?H\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and> u \\<noteq> v \\<and> H = poincare_line u v", "using unique_poincare_line[where l=H]"], ["proof (prove)\nusing this:\n  is_poincare_line H\n  is_poincare_line ?H \\<Longrightarrow>\n  \\<exists>u v.\n     u \\<in> unit_disc \\<and>\n     v \\<in> unit_disc \\<and>\n     u \\<noteq> v \\<and> {u, v} \\<subseteq> circline_set ?H\n  \\<lbrakk>?u \\<noteq> ?v; ?u \\<in> unit_disc; ?v \\<in> unit_disc;\n   ?u \\<in> circline_set H; ?v \\<in> circline_set H;\n   is_poincare_line H\\<rbrakk>\n  \\<Longrightarrow> H = poincare_line ?u ?v\n\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       u \\<in> unit_disc \\<and>\n       v \\<in> unit_disc \\<and> u \\<noteq> v \\<and> H = poincare_line u v", "by fastforce"], ["", "text\\<open>If an h-line contains two different points on x-axis/y-axis then it is the x-axis/y-axis.\\<close>"], ["", "lemma poincare_line_0_real_is_x_axis:\n  assumes \"x \\<in> circline_set x_axis\" \"x \\<noteq> 0\\<^sub>h\" \"x \\<noteq> \\<infinity>\\<^sub>h\"\n  shows \"poincare_line 0\\<^sub>h x = x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line 0\\<^sub>h x = x_axis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> circline_set x_axis\n  x \\<noteq> 0\\<^sub>h\n  x \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. poincare_line 0\\<^sub>h x = x_axis", "using is_poincare_line_0_real_is_x_axis[of \"poincare_line 0\\<^sub>h x\" x]"], ["proof (prove)\nusing this:\n  x \\<in> circline_set x_axis\n  x \\<noteq> 0\\<^sub>h\n  x \\<noteq> \\<infinity>\\<^sub>h\n  \\<lbrakk>is_poincare_line (poincare_line 0\\<^sub>h x);\n   0\\<^sub>h \\<in> circline_set (poincare_line 0\\<^sub>h x);\n   x \\<in> circline_set (poincare_line 0\\<^sub>h x) \\<inter>\n           circline_set x_axis;\n   x \\<noteq> 0\\<^sub>h; x \\<noteq> \\<infinity>\\<^sub>h\\<rbrakk>\n  \\<Longrightarrow> poincare_line 0\\<^sub>h x = x_axis\n\ngoal (1 subgoal):\n 1. poincare_line 0\\<^sub>h x = x_axis", "by auto"], ["", "lemma poincare_line_0_imag_is_y_axis:\n  assumes \"y \\<in> circline_set y_axis\" \"y \\<noteq> 0\\<^sub>h\" \"y \\<noteq> \\<infinity>\\<^sub>h\"\n  shows \"poincare_line 0\\<^sub>h y = y_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line 0\\<^sub>h y = y_axis", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> circline_set y_axis\n  y \\<noteq> 0\\<^sub>h\n  y \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. poincare_line 0\\<^sub>h y = y_axis", "using is_poincare_line_0_imag_is_y_axis[of \"poincare_line 0\\<^sub>h y\" y]"], ["proof (prove)\nusing this:\n  y \\<in> circline_set y_axis\n  y \\<noteq> 0\\<^sub>h\n  y \\<noteq> \\<infinity>\\<^sub>h\n  \\<lbrakk>is_poincare_line (poincare_line 0\\<^sub>h y);\n   0\\<^sub>h \\<in> circline_set (poincare_line 0\\<^sub>h y);\n   y \\<in> circline_set (poincare_line 0\\<^sub>h y) \\<inter>\n           circline_set y_axis;\n   y \\<noteq> 0\\<^sub>h; y \\<noteq> \\<infinity>\\<^sub>h\\<rbrakk>\n  \\<Longrightarrow> poincare_line 0\\<^sub>h y = y_axis\n\ngoal (1 subgoal):\n 1. poincare_line 0\\<^sub>h y = y_axis", "by auto"], ["", "lemma poincare_line_x_axis:\n  assumes \"x \\<in> unit_disc\" \"y \\<in> unit_disc\" \"x \\<in> circline_set x_axis\" \"y \\<in> circline_set x_axis\" \"x \\<noteq> y\"\n  shows \"poincare_line x y = x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line x y = x_axis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> unit_disc\n  y \\<in> unit_disc\n  x \\<in> circline_set x_axis\n  y \\<in> circline_set x_axis\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. poincare_line x y = x_axis", "using unique_poincare_line"], ["proof (prove)\nusing this:\n  x \\<in> unit_disc\n  y \\<in> unit_disc\n  x \\<in> circline_set x_axis\n  y \\<in> circline_set x_axis\n  x \\<noteq> y\n  \\<lbrakk>?u \\<noteq> ?v; ?u \\<in> unit_disc; ?v \\<in> unit_disc;\n   ?u \\<in> circline_set ?l; ?v \\<in> circline_set ?l;\n   is_poincare_line ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = poincare_line ?u ?v\n\ngoal (1 subgoal):\n 1. poincare_line x y = x_axis", "by auto"], ["", "lemma poincare_line_minus_one_one [simp]: \n  shows \"poincare_line (of_complex (-1)) (of_complex 1) = x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line (of_complex (- 1)) (of_complex 1) = x_axis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_line (of_complex (- 1)) (of_complex 1) = x_axis", "have \"0\\<^sub>h \\<in> circline_set (poincare_line (of_complex (-1)) (of_complex 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>h\n    \\<in> circline_set (poincare_line (of_complex (- 1)) (of_complex 1))", "unfolding circline_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>h\n    \\<in> Collect\n           (on_circline (poincare_line (of_complex (- 1)) (of_complex 1)))", "by simp (transfer, transfer,  simp add: vec_cnj_def)"], ["proof (state)\nthis:\n  0\\<^sub>h\n  \\<in> circline_set (poincare_line (of_complex (- 1)) (of_complex 1))\n\ngoal (1 subgoal):\n 1. poincare_line (of_complex (- 1)) (of_complex 1) = x_axis", "hence \"poincare_line 0\\<^sub>h (of_complex 1) = poincare_line (of_complex (-1)) (of_complex 1)\""], ["proof (prove)\nusing this:\n  0\\<^sub>h\n  \\<in> circline_set (poincare_line (of_complex (- 1)) (of_complex 1))\n\ngoal (1 subgoal):\n 1. poincare_line 0\\<^sub>h (of_complex 1) =\n    poincare_line (of_complex (- 1)) (of_complex 1)", "by (metis is_poincare_line_poincare_line is_poincare_line_trough_zero_trough_infty not_zero_on_unit_circle of_complex_inj of_complex_one one_neq_neg_one one_on_unit_circle poincare_line_0_real_is_x_axis poincare_line_circline_set(2) reciprocal_involution reciprocal_one reciprocal_zero unique_circline_01inf')"], ["proof (state)\nthis:\n  poincare_line 0\\<^sub>h (of_complex 1) =\n  poincare_line (of_complex (- 1)) (of_complex 1)\n\ngoal (1 subgoal):\n 1. poincare_line (of_complex (- 1)) (of_complex 1) = x_axis", "thus ?thesis"], ["proof (prove)\nusing this:\n  poincare_line 0\\<^sub>h (of_complex 1) =\n  poincare_line (of_complex (- 1)) (of_complex 1)\n\ngoal (1 subgoal):\n 1. poincare_line (of_complex (- 1)) (of_complex 1) = x_axis", "using poincare_line_0_real_is_x_axis[of \"of_complex 1\"]"], ["proof (prove)\nusing this:\n  poincare_line 0\\<^sub>h (of_complex 1) =\n  poincare_line (of_complex (- 1)) (of_complex 1)\n  \\<lbrakk>of_complex 1 \\<in> circline_set x_axis;\n   of_complex 1 \\<noteq> 0\\<^sub>h;\n   of_complex 1 \\<noteq> \\<infinity>\\<^sub>h\\<rbrakk>\n  \\<Longrightarrow> poincare_line 0\\<^sub>h (of_complex 1) = x_axis\n\ngoal (1 subgoal):\n 1. poincare_line (of_complex (- 1)) (of_complex 1) = x_axis", "by auto"], ["proof (state)\nthis:\n  poincare_line (of_complex (- 1)) (of_complex 1) = x_axis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Transformations of constructed lines\\<close>"], ["", "text\\<open>Unit dics preserving M?bius transformations preserve the h-line construction\\<close>"], ["", "lemma unit_disc_fix_preserve_poincare_line [simp]:\n  assumes \"unit_disc_fix M\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\"\n  shows \"poincare_line (moebius_pt M u) (moebius_pt M v) = moebius_circline M (poincare_line u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line (moebius_pt M u) (moebius_pt M v) =\n    moebius_circline M (poincare_line u v)", "proof (rule unique_poincare_line[symmetric])"], ["proof (state)\ngoal (6 subgoals):\n 1. moebius_pt M u \\<noteq> moebius_pt M v\n 2. moebius_pt M u \\<in> unit_disc\n 3. moebius_pt M v \\<in> unit_disc\n 4. moebius_pt M u\n    \\<in> circline_set (moebius_circline M (poincare_line u v))\n 5. moebius_pt M v\n    \\<in> circline_set (moebius_circline M (poincare_line u v))\n 6. is_poincare_line (moebius_circline M (poincare_line u v))", "show \"moebius_pt M u \\<noteq> moebius_pt M v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt M u \\<noteq> moebius_pt M v", "using \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. moebius_pt M u \\<noteq> moebius_pt M v", "by auto"], ["proof (state)\nthis:\n  moebius_pt M u \\<noteq> moebius_pt M v\n\ngoal (5 subgoals):\n 1. moebius_pt M u \\<in> unit_disc\n 2. moebius_pt M v \\<in> unit_disc\n 3. moebius_pt M u\n    \\<in> circline_set (moebius_circline M (poincare_line u v))\n 4. moebius_pt M v\n    \\<in> circline_set (moebius_circline M (poincare_line u v))\n 5. is_poincare_line (moebius_circline M (poincare_line u v))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. moebius_pt M u \\<in> unit_disc\n 2. moebius_pt M v \\<in> unit_disc\n 3. moebius_pt M u\n    \\<in> circline_set (moebius_circline M (poincare_line u v))\n 4. moebius_pt M v\n    \\<in> circline_set (moebius_circline M (poincare_line u v))\n 5. is_poincare_line (moebius_circline M (poincare_line u v))", "show \"moebius_pt M u \\<in> circline_set (moebius_circline M (poincare_line u v))\"\n       \"moebius_pt M v \\<in> circline_set (moebius_circline M (poincare_line u v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt M u\n    \\<in> circline_set (moebius_circline M (poincare_line u v)) &&&\n    moebius_pt M v\n    \\<in> circline_set (moebius_circline M (poincare_line u v))", "unfolding circline_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt M u\n    \\<in> Collect (on_circline (moebius_circline M (poincare_line u v))) &&&\n    moebius_pt M v\n    \\<in> Collect (on_circline (moebius_circline M (poincare_line u v)))", "using moebius_circline[of M \"poincare_line u v\"] \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  {z. on_circline (moebius_circline M (poincare_line u v)) z} =\n  moebius_pt M ` {z. on_circline (poincare_line u v) z}\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. moebius_pt M u\n    \\<in> Collect (on_circline (moebius_circline M (poincare_line u v))) &&&\n    moebius_pt M v\n    \\<in> Collect (on_circline (moebius_circline M (poincare_line u v)))", "by auto"], ["proof (state)\nthis:\n  moebius_pt M u \\<in> circline_set (moebius_circline M (poincare_line u v))\n  moebius_pt M v \\<in> circline_set (moebius_circline M (poincare_line u v))\n\ngoal (3 subgoals):\n 1. moebius_pt M u \\<in> unit_disc\n 2. moebius_pt M v \\<in> unit_disc\n 3. is_poincare_line (moebius_circline M (poincare_line u v))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. moebius_pt M u \\<in> unit_disc\n 2. moebius_pt M v \\<in> unit_disc\n 3. is_poincare_line (moebius_circline M (poincare_line u v))", "from assms(1)"], ["proof (chain)\npicking this:\n  unit_disc_fix M", "have \"unit_circle_fix M\""], ["proof (prove)\nusing this:\n  unit_disc_fix M\n\ngoal (1 subgoal):\n 1. unit_circle_fix M", "by simp"], ["proof (state)\nthis:\n  unit_circle_fix M\n\ngoal (3 subgoals):\n 1. moebius_pt M u \\<in> unit_disc\n 2. moebius_pt M v \\<in> unit_disc\n 3. is_poincare_line (moebius_circline M (poincare_line u v))", "thus \"is_poincare_line (moebius_circline M (poincare_line u v))\""], ["proof (prove)\nusing this:\n  unit_circle_fix M\n\ngoal (1 subgoal):\n 1. is_poincare_line (moebius_circline M (poincare_line u v))", "using unit_circle_fix_preserve_is_poincare_line assms"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  \\<lbrakk>unit_circle_fix ?M; is_poincare_line ?H\\<rbrakk>\n  \\<Longrightarrow> is_poincare_line (moebius_circline ?M ?H)\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. is_poincare_line (moebius_circline M (poincare_line u v))", "by auto"], ["proof (state)\nthis:\n  is_poincare_line (moebius_circline M (poincare_line u v))\n\ngoal (2 subgoals):\n 1. moebius_pt M u \\<in> unit_disc\n 2. moebius_pt M v \\<in> unit_disc", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. moebius_pt M u \\<in> unit_disc\n 2. moebius_pt M v \\<in> unit_disc", "show \"moebius_pt M u \\<in> unit_disc\" \"moebius_pt M v \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt M u \\<in> unit_disc &&& moebius_pt M v \\<in> unit_disc", "using assms(2-3) unit_disc_fix_iff[OF assms(1)]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  moebius_pt M ` unit_disc = unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt M u \\<in> unit_disc &&& moebius_pt M v \\<in> unit_disc", "by auto"], ["proof (state)\nthis:\n  moebius_pt M u \\<in> unit_disc\n  moebius_pt M v \\<in> unit_disc\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Conjugate preserve the h-line construction\\<close>"], ["", "lemma conjugate_preserve_poincare_line [simp]:\n  assumes \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\"\n  shows \"poincare_line (conjugate u) (conjugate v) = conjugate_circline (poincare_line u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line (conjugate u) (conjugate v) =\n    conjugate_circline (poincare_line u v)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_line (conjugate u) (conjugate v) =\n    conjugate_circline (poincare_line u v)", "have \"conjugate u \\<noteq> conjugate v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate u \\<noteq> conjugate v", "using \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. conjugate u \\<noteq> conjugate v", "by (auto simp add: conjugate_inj)"], ["proof (state)\nthis:\n  conjugate u \\<noteq> conjugate v\n\ngoal (1 subgoal):\n 1. poincare_line (conjugate u) (conjugate v) =\n    conjugate_circline (poincare_line u v)", "moreover"], ["proof (state)\nthis:\n  conjugate u \\<noteq> conjugate v\n\ngoal (1 subgoal):\n 1. poincare_line (conjugate u) (conjugate v) =\n    conjugate_circline (poincare_line u v)", "have \"conjugate u \\<in> unit_disc\" \"conjugate v \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate u \\<in> unit_disc &&& conjugate v \\<in> unit_disc", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. conjugate u \\<in> unit_disc &&& conjugate v \\<in> unit_disc", "by auto"], ["proof (state)\nthis:\n  conjugate u \\<in> unit_disc\n  conjugate v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_line (conjugate u) (conjugate v) =\n    conjugate_circline (poincare_line u v)", "moreover"], ["proof (state)\nthis:\n  conjugate u \\<in> unit_disc\n  conjugate v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_line (conjugate u) (conjugate v) =\n    conjugate_circline (poincare_line u v)", "have \"conjugate u \\<in> circline_set (conjugate_circline (poincare_line u v))\"\n       \"conjugate v \\<in> circline_set (conjugate_circline (poincare_line u v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate u\n    \\<in> circline_set (conjugate_circline (poincare_line u v)) &&&\n    conjugate v \\<in> circline_set (conjugate_circline (poincare_line u v))", "using \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. conjugate u\n    \\<in> circline_set (conjugate_circline (poincare_line u v)) &&&\n    conjugate v \\<in> circline_set (conjugate_circline (poincare_line u v))", "by simp_all"], ["proof (state)\nthis:\n  conjugate u \\<in> circline_set (conjugate_circline (poincare_line u v))\n  conjugate v \\<in> circline_set (conjugate_circline (poincare_line u v))\n\ngoal (1 subgoal):\n 1. poincare_line (conjugate u) (conjugate v) =\n    conjugate_circline (poincare_line u v)", "moreover"], ["proof (state)\nthis:\n  conjugate u \\<in> circline_set (conjugate_circline (poincare_line u v))\n  conjugate v \\<in> circline_set (conjugate_circline (poincare_line u v))\n\ngoal (1 subgoal):\n 1. poincare_line (conjugate u) (conjugate v) =\n    conjugate_circline (poincare_line u v)", "have \"is_poincare_line (conjugate_circline (poincare_line u v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line (conjugate_circline (poincare_line u v))", "using is_poincare_line_poincare_line[OF \\<open>u \\<noteq> v\\<close>]"], ["proof (prove)\nusing this:\n  is_poincare_line (poincare_line u v)\n\ngoal (1 subgoal):\n 1. is_poincare_line (conjugate_circline (poincare_line u v))", "by simp"], ["proof (state)\nthis:\n  is_poincare_line (conjugate_circline (poincare_line u v))\n\ngoal (1 subgoal):\n 1. poincare_line (conjugate u) (conjugate v) =\n    conjugate_circline (poincare_line u v)", "ultimately"], ["proof (chain)\npicking this:\n  conjugate u \\<noteq> conjugate v\n  conjugate u \\<in> unit_disc\n  conjugate v \\<in> unit_disc\n  conjugate u \\<in> circline_set (conjugate_circline (poincare_line u v))\n  conjugate v \\<in> circline_set (conjugate_circline (poincare_line u v))\n  is_poincare_line (conjugate_circline (poincare_line u v))", "show ?thesis"], ["proof (prove)\nusing this:\n  conjugate u \\<noteq> conjugate v\n  conjugate u \\<in> unit_disc\n  conjugate v \\<in> unit_disc\n  conjugate u \\<in> circline_set (conjugate_circline (poincare_line u v))\n  conjugate v \\<in> circline_set (conjugate_circline (poincare_line u v))\n  is_poincare_line (conjugate_circline (poincare_line u v))\n\ngoal (1 subgoal):\n 1. poincare_line (conjugate u) (conjugate v) =\n    conjugate_circline (poincare_line u v)", "using unique_poincare_line[of \"conjugate u\" \"conjugate v\" \"conjugate_circline (poincare_line u v)\"]"], ["proof (prove)\nusing this:\n  conjugate u \\<noteq> conjugate v\n  conjugate u \\<in> unit_disc\n  conjugate v \\<in> unit_disc\n  conjugate u \\<in> circline_set (conjugate_circline (poincare_line u v))\n  conjugate v \\<in> circline_set (conjugate_circline (poincare_line u v))\n  is_poincare_line (conjugate_circline (poincare_line u v))\n  \\<lbrakk>conjugate u \\<noteq> conjugate v; conjugate u \\<in> unit_disc;\n   conjugate v \\<in> unit_disc;\n   conjugate u \\<in> circline_set (conjugate_circline (poincare_line u v));\n   conjugate v \\<in> circline_set (conjugate_circline (poincare_line u v));\n   is_poincare_line (conjugate_circline (poincare_line u v))\\<rbrakk>\n  \\<Longrightarrow> conjugate_circline (poincare_line u v) =\n                    poincare_line (conjugate u) (conjugate v)\n\ngoal (1 subgoal):\n 1. poincare_line (conjugate u) (conjugate v) =\n    conjugate_circline (poincare_line u v)", "by simp"], ["proof (state)\nthis:\n  poincare_line (conjugate u) (conjugate v) =\n  conjugate_circline (poincare_line u v)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Collinear points and h-lines\\<close>"], ["", "lemma poincare_collinear3_poincare_line_general:\n  assumes \"poincare_collinear {a, a1, a2}\" \"a1 \\<noteq> a2\" \"a1 \\<noteq> inversion a2\"\n  shows \"a \\<in> circline_set (poincare_line a1 a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> circline_set (poincare_line a1 a2)", "using assms"], ["proof (prove)\nusing this:\n  poincare_collinear {a, a1, a2}\n  a1 \\<noteq> a2\n  a1 \\<noteq> inversion a2\n\ngoal (1 subgoal):\n 1. a \\<in> circline_set (poincare_line a1 a2)", "using poincare_collinear_def unique_poincare_line_general"], ["proof (prove)\nusing this:\n  poincare_collinear {a, a1, a2}\n  a1 \\<noteq> a2\n  a1 \\<noteq> inversion a2\n  poincare_collinear ?S =\n  (\\<exists>p. is_poincare_line p \\<and> ?S \\<subseteq> circline_set p)\n  \\<lbrakk>?u \\<noteq> ?v; ?u \\<noteq> inversion ?v;\n   ?u \\<in> circline_set ?l; ?v \\<in> circline_set ?l;\n   is_poincare_line ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = poincare_line ?u ?v\n\ngoal (1 subgoal):\n 1. a \\<in> circline_set (poincare_line a1 a2)", "by auto"], ["", "lemma poincare_line_poincare_collinear3_general:\n  assumes \"a \\<in> circline_set (poincare_line a1 a2)\" \"a1 \\<noteq> a2\"\n  shows \"poincare_collinear {a, a1, a2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_collinear {a, a1, a2}", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> circline_set (poincare_line a1 a2)\n  a1 \\<noteq> a2\n\ngoal (1 subgoal):\n 1. poincare_collinear {a, a1, a2}", "unfolding poincare_collinear_def"], ["proof (prove)\nusing this:\n  a \\<in> circline_set (poincare_line a1 a2)\n  a1 \\<noteq> a2\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       is_poincare_line p \\<and> {a, a1, a2} \\<subseteq> circline_set p", "by (rule_tac x=\"poincare_line a1 a2\" in exI, simp)"], ["", "lemma poincare_collinear3_poincare_lines_equal_general:\n  assumes \"poincare_collinear {a, a1, a2}\" \"a \\<noteq> a1\" \"a \\<noteq> a2\" \"a \\<noteq> inversion a1\" \"a \\<noteq> inversion a2\"\n  shows \"poincare_line a a1 = poincare_line a a2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line a a1 = poincare_line a a2", "using assms"], ["proof (prove)\nusing this:\n  poincare_collinear {a, a1, a2}\n  a \\<noteq> a1\n  a \\<noteq> a2\n  a \\<noteq> inversion a1\n  a \\<noteq> inversion a2\n\ngoal (1 subgoal):\n 1. poincare_line a a1 = poincare_line a a2", "using unique_poincare_line_general[of a a2 \"poincare_line a a1\"]"], ["proof (prove)\nusing this:\n  poincare_collinear {a, a1, a2}\n  a \\<noteq> a1\n  a \\<noteq> a2\n  a \\<noteq> inversion a1\n  a \\<noteq> inversion a2\n  \\<lbrakk>a \\<noteq> a2; a \\<noteq> inversion a2;\n   a \\<in> circline_set (poincare_line a a1);\n   a2 \\<in> circline_set (poincare_line a a1);\n   is_poincare_line (poincare_line a a1)\\<rbrakk>\n  \\<Longrightarrow> poincare_line a a1 = poincare_line a a2\n\ngoal (1 subgoal):\n 1. poincare_line a a1 = poincare_line a a2", "by (simp add: insert_commute poincare_collinear3_poincare_line_general)"], ["", "subsubsection \\<open>Points collinear with @{term \"0\\<^sub>h\"}\\<close>"], ["", "lemma poincare_collinear_zero_iff:\n  assumes \"of_complex y' \\<in> unit_disc\" and \"of_complex z' \\<in> unit_disc\" and\n          \"y' \\<noteq> z'\" and \"y' \\<noteq> 0\" and \"z' \\<noteq> 0\"\n  shows \"poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'} \\<longleftrightarrow>\n         y'*cnj z' = cnj y'*z'\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'} =\n    (y' * cnj z' = cnj y' * z')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'} =\n    (y' * cnj z' = cnj y' * z')", "have \"of_complex y' \\<noteq> of_complex z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex y' \\<noteq> of_complex z'", "using assms"], ["proof (prove)\nusing this:\n  of_complex y' \\<in> unit_disc\n  of_complex z' \\<in> unit_disc\n  y' \\<noteq> z'\n  y' \\<noteq> 0\n  z' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_complex y' \\<noteq> of_complex z'", "using of_complex_inj"], ["proof (prove)\nusing this:\n  of_complex y' \\<in> unit_disc\n  of_complex z' \\<in> unit_disc\n  y' \\<noteq> z'\n  y' \\<noteq> 0\n  z' \\<noteq> 0\n  of_complex ?x = of_complex ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. of_complex y' \\<noteq> of_complex z'", "by blast"], ["proof (state)\nthis:\n  of_complex y' \\<noteq> of_complex z'\n\ngoal (1 subgoal):\n 1. poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'} =\n    (y' * cnj z' = cnj y' * z')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'} =\n    (y' * cnj z' = cnj y' * z')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. poincare_collinear\n     {0\\<^sub>h, of_complex y', of_complex z'} \\<Longrightarrow>\n    y' * cnj z' = cnj y' * z'\n 2. y' * cnj z' = cnj y' * z' \\<Longrightarrow>\n    poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}", "assume ?lhs"], ["proof (state)\nthis:\n  poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}\n\ngoal (2 subgoals):\n 1. poincare_collinear\n     {0\\<^sub>h, of_complex y', of_complex z'} \\<Longrightarrow>\n    y' * cnj z' = cnj y' * z'\n 2. y' * cnj z' = cnj y' * z' \\<Longrightarrow>\n    poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}", "hence \"0\\<^sub>h \\<in> circline_set (poincare_line (of_complex y') (of_complex z'))\""], ["proof (prove)\nusing this:\n  poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}\n\ngoal (1 subgoal):\n 1. 0\\<^sub>h\n    \\<in> circline_set (poincare_line (of_complex y') (of_complex z'))", "using unique_poincare_line[of \"of_complex y'\" \"of_complex z'\"]"], ["proof (prove)\nusing this:\n  poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}\n  \\<lbrakk>of_complex y' \\<noteq> of_complex z';\n   of_complex y' \\<in> unit_disc; of_complex z' \\<in> unit_disc;\n   of_complex y' \\<in> circline_set ?l; of_complex z' \\<in> circline_set ?l;\n   is_poincare_line ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = poincare_line (of_complex y') (of_complex z')\n\ngoal (1 subgoal):\n 1. 0\\<^sub>h\n    \\<in> circline_set (poincare_line (of_complex y') (of_complex z'))", "using assms \\<open>of_complex y' \\<noteq> of_complex z'\\<close>"], ["proof (prove)\nusing this:\n  poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}\n  \\<lbrakk>of_complex y' \\<noteq> of_complex z';\n   of_complex y' \\<in> unit_disc; of_complex z' \\<in> unit_disc;\n   of_complex y' \\<in> circline_set ?l; of_complex z' \\<in> circline_set ?l;\n   is_poincare_line ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = poincare_line (of_complex y') (of_complex z')\n  of_complex y' \\<in> unit_disc\n  of_complex z' \\<in> unit_disc\n  y' \\<noteq> z'\n  y' \\<noteq> 0\n  z' \\<noteq> 0\n  of_complex y' \\<noteq> of_complex z'\n\ngoal (1 subgoal):\n 1. 0\\<^sub>h\n    \\<in> circline_set (poincare_line (of_complex y') (of_complex z'))", "unfolding poincare_collinear_def"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     is_poincare_line p \\<and>\n     {0\\<^sub>h, of_complex y', of_complex z'} \\<subseteq> circline_set p\n  \\<lbrakk>of_complex y' \\<noteq> of_complex z';\n   of_complex y' \\<in> unit_disc; of_complex z' \\<in> unit_disc;\n   of_complex y' \\<in> circline_set ?l; of_complex z' \\<in> circline_set ?l;\n   is_poincare_line ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = poincare_line (of_complex y') (of_complex z')\n  of_complex y' \\<in> unit_disc\n  of_complex z' \\<in> unit_disc\n  y' \\<noteq> z'\n  y' \\<noteq> 0\n  z' \\<noteq> 0\n  of_complex y' \\<noteq> of_complex z'\n\ngoal (1 subgoal):\n 1. 0\\<^sub>h\n    \\<in> circline_set (poincare_line (of_complex y') (of_complex z'))", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>h\n  \\<in> circline_set (poincare_line (of_complex y') (of_complex z'))\n\ngoal (2 subgoals):\n 1. poincare_collinear\n     {0\\<^sub>h, of_complex y', of_complex z'} \\<Longrightarrow>\n    y' * cnj z' = cnj y' * z'\n 2. y' * cnj z' = cnj y' * z' \\<Longrightarrow>\n    poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}", "moreover"], ["proof (state)\nthis:\n  0\\<^sub>h\n  \\<in> circline_set (poincare_line (of_complex y') (of_complex z'))\n\ngoal (2 subgoals):\n 1. poincare_collinear\n     {0\\<^sub>h, of_complex y', of_complex z'} \\<Longrightarrow>\n    y' * cnj z' = cnj y' * z'\n 2. y' * cnj z' = cnj y' * z' \\<Longrightarrow>\n    poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}", "let ?mix = \"y' * cnj z' - cnj y' * z'\""], ["proof (state)\ngoal (2 subgoals):\n 1. poincare_collinear\n     {0\\<^sub>h, of_complex y', of_complex z'} \\<Longrightarrow>\n    y' * cnj z' = cnj y' * z'\n 2. y' * cnj z' = cnj y' * z' \\<Longrightarrow>\n    poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}", "have \"is_real (\\<i> * ?mix)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (\\<i> * (y' * cnj z' - cnj y' * z'))", "using eq_cnj_iff_real[of ?mix]"], ["proof (prove)\nusing this:\n  (cnj (y' * cnj z' - cnj y' * z') = y' * cnj z' - cnj y' * z') =\n  is_real (y' * cnj z' - cnj y' * z')\n\ngoal (1 subgoal):\n 1. is_real (\\<i> * (y' * cnj z' - cnj y' * z'))", "by auto"], ["proof (state)\nthis:\n  is_real (\\<i> * (y' * cnj z' - cnj y' * z'))\n\ngoal (2 subgoals):\n 1. poincare_collinear\n     {0\\<^sub>h, of_complex y', of_complex z'} \\<Longrightarrow>\n    y' * cnj z' = cnj y' * z'\n 2. y' * cnj z' = cnj y' * z' \\<Longrightarrow>\n    poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}", "hence \"y' * cnj z' = cnj y' * z' \\<longleftrightarrow> Re (\\<i> * ?mix) = 0\""], ["proof (prove)\nusing this:\n  is_real (\\<i> * (y' * cnj z' - cnj y' * z'))\n\ngoal (1 subgoal):\n 1. (y' * cnj z' = cnj y' * z') =\n    is_imag (\\<i> * (y' * cnj z' - cnj y' * z'))", "using complex.expand[of \"\\<i> * ?mix\" 0]"], ["proof (prove)\nusing this:\n  is_real (\\<i> * (y' * cnj z' - cnj y' * z'))\n  Re (\\<i> * (y' * cnj z' - cnj y' * z')) = Re 0 \\<and>\n  Im (\\<i> * (y' * cnj z' - cnj y' * z')) = Im 0 \\<Longrightarrow>\n  \\<i> * (y' * cnj z' - cnj y' * z') = 0\n\ngoal (1 subgoal):\n 1. (y' * cnj z' = cnj y' * z') =\n    is_imag (\\<i> * (y' * cnj z' - cnj y' * z'))", "by (metis complex_i_not_zero eq_iff_diff_eq_0 mult_eq_0_iff zero_complex.simps(1) zero_complex.simps(2))"], ["proof (state)\nthis:\n  (y' * cnj z' = cnj y' * z') = is_imag (\\<i> * (y' * cnj z' - cnj y' * z'))\n\ngoal (2 subgoals):\n 1. poincare_collinear\n     {0\\<^sub>h, of_complex y', of_complex z'} \\<Longrightarrow>\n    y' * cnj z' = cnj y' * z'\n 2. y' * cnj z' = cnj y' * z' \\<Longrightarrow>\n    poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}", "ultimately"], ["proof (chain)\npicking this:\n  0\\<^sub>h\n  \\<in> circline_set (poincare_line (of_complex y') (of_complex z'))\n  (y' * cnj z' = cnj y' * z') = is_imag (\\<i> * (y' * cnj z' - cnj y' * z'))", "show ?rhs"], ["proof (prove)\nusing this:\n  0\\<^sub>h\n  \\<in> circline_set (poincare_line (of_complex y') (of_complex z'))\n  (y' * cnj z' = cnj y' * z') = is_imag (\\<i> * (y' * cnj z' - cnj y' * z'))\n\ngoal (1 subgoal):\n 1. y' * cnj z' = cnj y' * z'", "using \\<open>y' \\<noteq> z'\\<close> \\<open>y' \\<noteq> 0\\<close> \\<open>z' \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  0\\<^sub>h\n  \\<in> circline_set (poincare_line (of_complex y') (of_complex z'))\n  (y' * cnj z' = cnj y' * z') = is_imag (\\<i> * (y' * cnj z' - cnj y' * z'))\n  y' \\<noteq> z'\n  y' \\<noteq> 0\n  z' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y' * cnj z' = cnj y' * z'", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  0\\<^sub>h\n  \\<in> Collect\n         (on_circline (poincare_line (of_complex y') (of_complex z')))\n  (y' * cnj z' = cnj y' * z') = is_imag (\\<i> * (y' * cnj z' - cnj y' * z'))\n  y' \\<noteq> z'\n  y' \\<noteq> 0\n  z' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y' * cnj z' = cnj y' * z'", "by simp (transfer, transfer, auto simp add: vec_cnj_def split: if_split_asm, metis Re_complex_of_real Re_mult_real Im_complex_of_real)"], ["proof (state)\nthis:\n  y' * cnj z' = cnj y' * z'\n\ngoal (1 subgoal):\n 1. y' * cnj z' = cnj y' * z' \\<Longrightarrow>\n    poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y' * cnj z' = cnj y' * z' \\<Longrightarrow>\n    poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}", "assume ?rhs"], ["proof (state)\nthis:\n  y' * cnj z' = cnj y' * z'\n\ngoal (1 subgoal):\n 1. y' * cnj z' = cnj y' * z' \\<Longrightarrow>\n    poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}", "thus ?lhs"], ["proof (prove)\nusing this:\n  y' * cnj z' = cnj y' * z'\n\ngoal (1 subgoal):\n 1. poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}", "using assms \\<open>of_complex y' \\<noteq> of_complex z'\\<close>"], ["proof (prove)\nusing this:\n  y' * cnj z' = cnj y' * z'\n  of_complex y' \\<in> unit_disc\n  of_complex z' \\<in> unit_disc\n  y' \\<noteq> z'\n  y' \\<noteq> 0\n  z' \\<noteq> 0\n  of_complex y' \\<noteq> of_complex z'\n\ngoal (1 subgoal):\n 1. poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}", "unfolding poincare_collinear_def"], ["proof (prove)\nusing this:\n  y' * cnj z' = cnj y' * z'\n  of_complex y' \\<in> unit_disc\n  of_complex z' \\<in> unit_disc\n  y' \\<noteq> z'\n  y' \\<noteq> 0\n  z' \\<noteq> 0\n  of_complex y' \\<noteq> of_complex z'\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       is_poincare_line p \\<and>\n       {0\\<^sub>h, of_complex y', of_complex z'} \\<subseteq> circline_set p", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  y' * cnj z' = cnj y' * z'\n  of_complex y' \\<in> unit_disc\n  of_complex z' \\<in> unit_disc\n  y' \\<noteq> z'\n  y' \\<noteq> 0\n  z' \\<noteq> 0\n  of_complex y' \\<noteq> of_complex z'\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       is_poincare_line p \\<and>\n       {0\\<^sub>h, of_complex y', of_complex z'}\n       \\<subseteq> Collect (on_circline p)", "apply (rule_tac x=\"poincare_line (of_complex y') (of_complex z')\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y' * cnj z' = cnj y' * z'; of_complex y' \\<in> unit_disc;\n     of_complex z' \\<in> unit_disc; y' \\<noteq> z'; y' \\<noteq> 0;\n     z' \\<noteq> 0; of_complex y' \\<noteq> of_complex z'\\<rbrakk>\n    \\<Longrightarrow> is_poincare_line\n                       (poincare_line (of_complex y')\n                         (of_complex z')) \\<and>\n                      {0\\<^sub>h, of_complex y', of_complex z'}\n                      \\<subseteq> Collect\n                                   (on_circline\n                                     (poincare_line (of_complex y')\n (of_complex z')))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y' * cnj z' = cnj y' * z'; cmod y' < 1; cmod z' < 1;\n     y' \\<noteq> z'; y' \\<noteq> 0; z' \\<noteq> 0;\n     of_complex y' \\<noteq> of_complex z'\\<rbrakk>\n    \\<Longrightarrow> on_circline\n                       (poincare_line (of_complex y') (of_complex z'))\n                       0\\<^sub>h", "apply (transfer, transfer, simp add: vec_cnj_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poincare_collinear {0\\<^sub>h, of_complex y', of_complex z'} =\n  (y' * cnj z' = cnj y' * z')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poincare_collinear_zero_polar_form:\n  assumes \"poincare_collinear {0\\<^sub>h, of_complex x, of_complex y}\" and\n          \"x \\<noteq> 0\" and \"y \\<noteq> 0\" and \"of_complex x \\<in> unit_disc\" and \"of_complex y \\<in> unit_disc\"\n  shows \"\\<exists> \\<phi> rx ry. x = cor rx * cis \\<phi> \\<and> y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "from \\<open>x \\<noteq> 0\\<close> \\<open>y \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> 0\n  y \\<noteq> 0", "obtain \\<phi> \\<phi>' rx ry where\n    polar: \"x = cor rx * cis \\<phi>\" \"y = cor ry * cis \\<phi>'\" and  \"\\<phi> = arg x\" \"\\<phi>' = arg y\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>rx \\<phi> ry \\<phi>'.\n        \\<lbrakk>x = cor rx * cis \\<phi>; y = cor ry * cis \\<phi>';\n         \\<phi> = arg x; \\<phi>' = arg y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis cmod_cis)"], ["proof (state)\nthis:\n  x = cor rx * cis \\<phi>\n  y = cor ry * cis \\<phi>'\n  \\<phi> = arg x\n  \\<phi>' = arg y\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "hence \"rx \\<noteq> 0\" \"ry \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x = cor rx * cis \\<phi>\n  y = cor ry * cis \\<phi>'\n  \\<phi> = arg x\n  \\<phi>' = arg y\n\ngoal (1 subgoal):\n 1. rx \\<noteq> 0 &&& ry \\<noteq> 0", "using \\<open>x \\<noteq> 0\\<close> \\<open>y \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  x = cor rx * cis \\<phi>\n  y = cor ry * cis \\<phi>'\n  \\<phi> = arg x\n  \\<phi>' = arg y\n  x \\<noteq> 0\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rx \\<noteq> 0 &&& ry \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  rx \\<noteq> 0\n  ry \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "have \"of_complex y \\<in> circline_set (poincare_line 0\\<^sub>h (of_complex x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex y \\<in> circline_set (poincare_line 0\\<^sub>h (of_complex x))", "using assms"], ["proof (prove)\nusing this:\n  poincare_collinear {0\\<^sub>h, of_complex x, of_complex y}\n  x \\<noteq> 0\n  y \\<noteq> 0\n  of_complex x \\<in> unit_disc\n  of_complex y \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. of_complex y \\<in> circline_set (poincare_line 0\\<^sub>h (of_complex x))", "using unique_poincare_line[of \"0\\<^sub>h\" \"of_complex x\"]"], ["proof (prove)\nusing this:\n  poincare_collinear {0\\<^sub>h, of_complex x, of_complex y}\n  x \\<noteq> 0\n  y \\<noteq> 0\n  of_complex x \\<in> unit_disc\n  of_complex y \\<in> unit_disc\n  \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; 0\\<^sub>h \\<in> unit_disc;\n   of_complex x \\<in> unit_disc; 0\\<^sub>h \\<in> circline_set ?l;\n   of_complex x \\<in> circline_set ?l; is_poincare_line ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = poincare_line 0\\<^sub>h (of_complex x)\n\ngoal (1 subgoal):\n 1. of_complex y \\<in> circline_set (poincare_line 0\\<^sub>h (of_complex x))", "unfolding poincare_collinear_def"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     is_poincare_line p \\<and>\n     {0\\<^sub>h, of_complex x, of_complex y} \\<subseteq> circline_set p\n  x \\<noteq> 0\n  y \\<noteq> 0\n  of_complex x \\<in> unit_disc\n  of_complex y \\<in> unit_disc\n  \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; 0\\<^sub>h \\<in> unit_disc;\n   of_complex x \\<in> unit_disc; 0\\<^sub>h \\<in> circline_set ?l;\n   of_complex x \\<in> circline_set ?l; is_poincare_line ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = poincare_line 0\\<^sub>h (of_complex x)\n\ngoal (1 subgoal):\n 1. of_complex y \\<in> circline_set (poincare_line 0\\<^sub>h (of_complex x))", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     is_poincare_line p \\<and>\n     {0\\<^sub>h, of_complex x, of_complex y}\n     \\<subseteq> Collect (on_circline p)\n  x \\<noteq> 0\n  y \\<noteq> 0\n  of_complex x \\<in> unit_disc\n  of_complex y \\<in> unit_disc\n  \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; 0\\<^sub>h \\<in> unit_disc;\n   of_complex x \\<in> unit_disc; 0\\<^sub>h \\<in> Collect (on_circline ?l);\n   of_complex x \\<in> Collect (on_circline ?l); is_poincare_line ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = poincare_line 0\\<^sub>h (of_complex x)\n\ngoal (1 subgoal):\n 1. of_complex y\n    \\<in> Collect (on_circline (poincare_line 0\\<^sub>h (of_complex x)))", "using of_complex_zero_iff"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     is_poincare_line p \\<and>\n     {0\\<^sub>h, of_complex x, of_complex y}\n     \\<subseteq> Collect (on_circline p)\n  x \\<noteq> 0\n  y \\<noteq> 0\n  of_complex x \\<in> unit_disc\n  of_complex y \\<in> unit_disc\n  \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; 0\\<^sub>h \\<in> unit_disc;\n   of_complex x \\<in> unit_disc; 0\\<^sub>h \\<in> Collect (on_circline ?l);\n   of_complex x \\<in> Collect (on_circline ?l); is_poincare_line ?l\\<rbrakk>\n  \\<Longrightarrow> ?l = poincare_line 0\\<^sub>h (of_complex x)\n  (of_complex ?x = 0\\<^sub>h) = (?x = 0)\n\ngoal (1 subgoal):\n 1. of_complex y\n    \\<in> Collect (on_circline (poincare_line 0\\<^sub>h (of_complex x)))", "by fastforce"], ["proof (state)\nthis:\n  of_complex y \\<in> circline_set (poincare_line 0\\<^sub>h (of_complex x))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "hence \"cnj x * y = x * cnj y\""], ["proof (prove)\nusing this:\n  of_complex y \\<in> circline_set (poincare_line 0\\<^sub>h (of_complex x))\n\ngoal (1 subgoal):\n 1. cnj x * y = x * cnj y", "using \\<open>x \\<noteq> 0\\<close> \\<open>y \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  of_complex y \\<in> circline_set (poincare_line 0\\<^sub>h (of_complex x))\n  x \\<noteq> 0\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cnj x * y = x * cnj y", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  of_complex y\n  \\<in> Collect (on_circline (poincare_line 0\\<^sub>h (of_complex x)))\n  x \\<noteq> 0\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cnj x * y = x * cnj y", "by simp (transfer, transfer, simp add: vec_cnj_def field_simps)"], ["proof (state)\nthis:\n  cnj x * y = x * cnj y\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "hence \"cis(\\<phi>' - \\<phi>) = cis(\\<phi> - \\<phi>')\""], ["proof (prove)\nusing this:\n  cnj x * y = x * cnj y\n\ngoal (1 subgoal):\n 1. cis (\\<phi>' - \\<phi>) = cis (\\<phi> - \\<phi>')", "using polar \\<open>rx \\<noteq> 0\\<close> \\<open>ry \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  cnj x * y = x * cnj y\n  x = cor rx * cis \\<phi>\n  y = cor ry * cis \\<phi>'\n  rx \\<noteq> 0\n  ry \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cis (\\<phi>' - \\<phi>) = cis (\\<phi> - \\<phi>')", "by (simp add: cis_mult)"], ["proof (state)\nthis:\n  cis (\\<phi>' - \\<phi>) = cis (\\<phi> - \\<phi>')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "hence \"sin (\\<phi>' - \\<phi>) = 0\""], ["proof (prove)\nusing this:\n  cis (\\<phi>' - \\<phi>) = cis (\\<phi> - \\<phi>')\n\ngoal (1 subgoal):\n 1. sin (\\<phi>' - \\<phi>) = 0", "using cis_diff_cis_opposite[of \"\\<phi>' - \\<phi>\"]"], ["proof (prove)\nusing this:\n  cis (\\<phi>' - \\<phi>) = cis (\\<phi> - \\<phi>')\n  cis (\\<phi>' - \\<phi>) - cis (- (\\<phi>' - \\<phi>)) =\n  2 * \\<i> * cor (sin (\\<phi>' - \\<phi>))\n\ngoal (1 subgoal):\n 1. sin (\\<phi>' - \\<phi>) = 0", "by simp"], ["proof (state)\nthis:\n  sin (\\<phi>' - \\<phi>) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  sin (\\<phi>' - \\<phi>) = 0", "obtain k :: int where \"\\<phi>' - \\<phi> = k * pi\""], ["proof (prove)\nusing this:\n  sin (\\<phi>' - \\<phi>) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<phi>' - \\<phi> = real_of_int k * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using sin_zero_iff_int2[of \"\\<phi>' - \\<phi>\"]"], ["proof (prove)\nusing this:\n  sin (\\<phi>' - \\<phi>) = 0\n  (sin (\\<phi>' - \\<phi>) = 0) =\n  (\\<exists>i. \\<phi>' - \\<phi> = real_of_int i * pi)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<phi>' - \\<phi> = real_of_int k * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<phi>' - \\<phi> = real_of_int k * pi\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "hence *: \"\\<phi>' = \\<phi> + k * pi\""], ["proof (prove)\nusing this:\n  \\<phi>' - \\<phi> = real_of_int k * pi\n\ngoal (1 subgoal):\n 1. \\<phi>' = \\<phi> + real_of_int k * pi", "by simp"], ["proof (state)\nthis:\n  \\<phi>' = \\<phi> + real_of_int k * pi\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "proof (cases \"even k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. even k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0\n 2. odd k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "case True"], ["proof (state)\nthis:\n  even k\n\ngoal (2 subgoals):\n 1. even k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0\n 2. odd k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  even k", "obtain k' where \"k = 2*k'\""], ["proof (prove)\nusing this:\n  even k\n\ngoal (1 subgoal):\n 1. (\\<And>k'. k = 2 * k' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using evenE"], ["proof (prove)\nusing this:\n  even k\n  \\<lbrakk>even ?a;\n   \\<And>b. ?a = (2::?'a) * b \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>k'. k = 2 * k' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  k = 2 * k'\n\ngoal (2 subgoals):\n 1. even k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0\n 2. odd k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "hence \"cis \\<phi> = cis \\<phi>'\""], ["proof (prove)\nusing this:\n  k = 2 * k'\n\ngoal (1 subgoal):\n 1. cis \\<phi> = cis \\<phi>'", "using * cos_periodic_int sin_periodic_int"], ["proof (prove)\nusing this:\n  k = 2 * k'\n  \\<phi>' = \\<phi> + real_of_int k * pi\n  cos (?x + real_of_int ?i * (2 * pi)) = cos ?x\n  sin (?x + real_of_int ?i * (2 * pi)) = sin ?x\n\ngoal (1 subgoal):\n 1. cis \\<phi> = cis \\<phi>'", "by (simp add: cis.ctr field_simps)"], ["proof (state)\nthis:\n  cis \\<phi> = cis \\<phi>'\n\ngoal (2 subgoals):\n 1. even k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0\n 2. odd k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  cis \\<phi> = cis \\<phi>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "using polar \\<open>rx \\<noteq> 0\\<close> \\<open>ry \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  cis \\<phi> = cis \\<phi>'\n  x = cor rx * cis \\<phi>\n  y = cor ry * cis \\<phi>'\n  rx \\<noteq> 0\n  ry \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "by (rule_tac x=\\<phi> in exI, rule_tac x=rx in exI, rule_tac x=ry in exI) simp"], ["proof (state)\nthis:\n  \\<exists>\\<phi> rx ry.\n     x = cor rx * cis \\<phi> \\<and>\n     y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0\n\ngoal (1 subgoal):\n 1. odd k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. odd k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "case False"], ["proof (state)\nthis:\n  odd k\n\ngoal (1 subgoal):\n 1. odd k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  odd k", "obtain k' where \"k = 2*k' + 1\""], ["proof (prove)\nusing this:\n  odd k\n\ngoal (1 subgoal):\n 1. (\\<And>k'. k = 2 * k' + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using oddE"], ["proof (prove)\nusing this:\n  odd k\n  \\<lbrakk>odd ?a;\n   \\<And>b. ?a = (2::?'a) * b + (1::?'a) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>k'. k = 2 * k' + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k = 2 * k' + 1\n\ngoal (1 subgoal):\n 1. odd k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "hence \"cis \\<phi> = - cis \\<phi>'\""], ["proof (prove)\nusing this:\n  k = 2 * k' + 1\n\ngoal (1 subgoal):\n 1. cis \\<phi> = - cis \\<phi>'", "using * cos_periodic_int sin_periodic_int"], ["proof (prove)\nusing this:\n  k = 2 * k' + 1\n  \\<phi>' = \\<phi> + real_of_int k * pi\n  cos (?x + real_of_int ?i * (2 * pi)) = cos ?x\n  sin (?x + real_of_int ?i * (2 * pi)) = sin ?x\n\ngoal (1 subgoal):\n 1. cis \\<phi> = - cis \\<phi>'", "by (simp add: cis.ctr complex_minus field_simps)"], ["proof (state)\nthis:\n  cis \\<phi> = - cis \\<phi>'\n\ngoal (1 subgoal):\n 1. odd k \\<Longrightarrow>\n    \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  cis \\<phi> = - cis \\<phi>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "using polar \\<open>rx \\<noteq> 0\\<close> \\<open>ry \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  cis \\<phi> = - cis \\<phi>'\n  x = cor rx * cis \\<phi>\n  y = cor ry * cis \\<phi>'\n  rx \\<noteq> 0\n  ry \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi> rx ry.\n       x = cor rx * cis \\<phi> \\<and>\n       y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0", "by (rule_tac x=\\<phi> in exI, rule_tac x=rx in exI, rule_tac x=\"-ry\" in exI) simp"], ["proof (state)\nthis:\n  \\<exists>\\<phi> rx ry.\n     x = cor rx * cis \\<phi> \\<and>\n     y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<phi> rx ry.\n     x = cor rx * cis \\<phi> \\<and>\n     y = cor ry * cis \\<phi> \\<and> rx \\<noteq> 0 \\<and> ry \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}