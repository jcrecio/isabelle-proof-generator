{"file_name": "/home/qj213/afp-2021-10-22/thys/Poincare_Disc/Poincare.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Poincare_Disc", "problem_names": ["lemma p_on_line:\n  assumes \"z \\<noteq> w\"\n  shows \"p_incident (p_line z w) z\"\n        \"p_incident (p_line z w) w\"", "lemma\n  assumes \"u \\<noteq> v\"\n  shows \"\\<exists>! l. {u, v} \\<subseteq> p_points l\"", "lemma\n  assumes \"p_zero \\<in> p_points l\" \"u \\<in> p_points l\" \"u \\<noteq> p_zero\" \"u \\<in> p_points p_x_axis\"\n  shows \"l = p_x_axis\"", "lemma p_collinear_p_isometry_pt [simp]: \n  shows \"p_collinear (p_isometry_pt M ` A) \\<longleftrightarrow> p_collinear A\"", "lemma\n  assumes \"p_dist u v = p_dist u' v'\"\n  assumes \"p_dist v w = p_dist v' w'\"\n  assumes \"p_dist u w = p_dist u' w'\"\n  shows \"\\<exists> f. p_isometry_pt f u = u' \\<and> p_isometry_pt f v = v' \\<and> p_isometry_pt f w = w'\""], "translations": [["", "lemma p_on_line:\n  assumes \"z \\<noteq> w\"\n  shows \"p_incident (p_line z w) z\"\n        \"p_incident (p_line z w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_incident (p_line z w) z &&& p_incident (p_line z w) w", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> w\n\ngoal (1 subgoal):\n 1. p_incident (p_line z w) z &&& p_incident (p_line z w) w", "by (transfer, simp)+"], ["", "text \\<open>There is a unique h-line passing trough the two different given h-points\\<close>"], ["", "lemma\n  assumes \"u \\<noteq> v\"\n  shows \"\\<exists>! l. {u, v} \\<subseteq> p_points l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!l. {u, v} \\<subseteq> p_points l", "using assms"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<exists>!l. {u, v} \\<subseteq> p_points l", "apply (rule_tac a=\"p_line u v\" in ex1I, auto simp add: p_points_def p_on_line)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>u \\<noteq> v; p_incident x u; p_incident x v\\<rbrakk>\n       \\<Longrightarrow> x = p_line u v", "apply (transfer, simp add: unique_poincare_line)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The unique h-line trough zero and a non-zero h-point on the x-axis is the x-axis\\<close>"], ["", "lemma\n  assumes \"p_zero \\<in> p_points l\" \"u \\<in> p_points l\" \"u \\<noteq> p_zero\" \"u \\<in> p_points p_x_axis\"\n  shows \"l = p_x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = p_x_axis", "using assms"], ["proof (prove)\nusing this:\n  p_zero \\<in> p_points l\n  u \\<in> p_points l\n  u \\<noteq> p_zero\n  u \\<in> p_points p_x_axis\n\ngoal (1 subgoal):\n 1. l = p_x_axis", "unfolding p_points_def"], ["proof (prove)\nusing this:\n  p_zero \\<in> Collect (p_incident l)\n  u \\<in> Collect (p_incident l)\n  u \\<noteq> p_zero\n  u \\<in> Collect (p_incident p_x_axis)\n\ngoal (1 subgoal):\n 1. l = p_x_axis", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p_incident l p_zero; p_incident l u; u \\<noteq> p_zero;\n     p_incident p_x_axis u\\<rbrakk>\n    \\<Longrightarrow> l = p_x_axis", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l u.\n       \\<lbrakk>is_poincare_line l; on_circline l 0\\<^sub>h;\n        u \\<in> unit_disc; on_circline l u; u \\<noteq> 0\\<^sub>h;\n        on_circline x_axis u\\<rbrakk>\n       \\<Longrightarrow> l = x_axis", "using is_poincare_line_0_real_is_x_axis inf_notin_unit_disc"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_poincare_line ?l; 0\\<^sub>h \\<in> circline_set ?l;\n   ?x \\<in> circline_set ?l \\<inter> circline_set x_axis;\n   ?x \\<noteq> 0\\<^sub>h; ?x \\<noteq> \\<infinity>\\<^sub>h\\<rbrakk>\n  \\<Longrightarrow> ?l = x_axis\n  \\<infinity>\\<^sub>h \\<notin> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>l u.\n       \\<lbrakk>is_poincare_line l; on_circline l 0\\<^sub>h;\n        u \\<in> unit_disc; on_circline l u; u \\<noteq> 0\\<^sub>h;\n        on_circline x_axis u\\<rbrakk>\n       \\<Longrightarrow> l = x_axis", "unfolding circline_set_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_poincare_line ?l; 0\\<^sub>h \\<in> Collect (on_circline ?l);\n   ?x \\<in> Collect (on_circline ?l) \\<inter> Collect (on_circline x_axis);\n   ?x \\<noteq> 0\\<^sub>h; ?x \\<noteq> \\<infinity>\\<^sub>h\\<rbrakk>\n  \\<Longrightarrow> ?l = x_axis\n  \\<infinity>\\<^sub>h \\<notin> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>l u.\n       \\<lbrakk>is_poincare_line l; on_circline l 0\\<^sub>h;\n        u \\<in> unit_disc; on_circline l u; u \\<noteq> 0\\<^sub>h;\n        on_circline x_axis u\\<rbrakk>\n       \\<Longrightarrow> l = x_axis", "by blast"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsection \\<open>H-collinearity\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "lift_definition p_collinear :: \"p_point set \\<Rightarrow> bool\" is poincare_collinear"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsection \\<open>H-isometries\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "text \\<open>H-isometries are functions that map the unit disc onto itself\\<close>"], ["", "typedef p_isometry = \"{f. unit_disc_fix_f f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. unit_disc_fix_f f}", "by (rule_tac x=\"id\" in exI, simp add: unit_disc_fix_f_def, rule_tac x=\"id_moebius\" in exI, simp)"], ["", "setup_lifting type_definition_p_isometry"], ["", "text \\<open>Action of an h-isometry on an h-point\\<close>"], ["", "lift_definition p_isometry_pt :: \"p_isometry \\<Rightarrow> p_point \\<Rightarrow> p_point\" is \"\\<lambda> f p. f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun complex_homo.\n       \\<lbrakk>unit_disc_fix_f fun; complex_homo \\<in> unit_disc\\<rbrakk>\n       \\<Longrightarrow> fun complex_homo \\<in> unit_disc", "using unit_disc_fix_f_unit_disc"], ["proof (prove)\nusing this:\n  unit_disc_fix_f ?M \\<Longrightarrow> ?M ` unit_disc = unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>fun complex_homo.\n       \\<lbrakk>unit_disc_fix_f fun; complex_homo \\<in> unit_disc\\<rbrakk>\n       \\<Longrightarrow> fun complex_homo \\<in> unit_disc", "by auto"], ["", "text \\<open>Action of an h-isometry on an h-line\\<close>"], ["", "lift_definition p_isometry_line :: \"p_isometry \\<Rightarrow> p_line \\<Rightarrow> p_line\" is \"\\<lambda> f l. unit_disc_fix_f_circline f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun circline.\n       \\<lbrakk>unit_disc_fix_f fun; is_poincare_line circline\\<rbrakk>\n       \\<Longrightarrow> is_poincare_line\n                          (unit_disc_fix_f_circline fun circline)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun circline.\n       \\<lbrakk>unit_disc_fix_f fun; is_poincare_line circline\\<rbrakk>\n       \\<Longrightarrow> is_poincare_line\n                          (unit_disc_fix_f_circline fun circline)", "fix f H"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun circline.\n       \\<lbrakk>unit_disc_fix_f fun; is_poincare_line circline\\<rbrakk>\n       \\<Longrightarrow> is_poincare_line\n                          (unit_disc_fix_f_circline fun circline)", "assume \"unit_disc_fix_f f\" \"is_poincare_line H\""], ["proof (state)\nthis:\n  unit_disc_fix_f f\n  is_poincare_line H\n\ngoal (1 subgoal):\n 1. \\<And>fun circline.\n       \\<lbrakk>unit_disc_fix_f fun; is_poincare_line circline\\<rbrakk>\n       \\<Longrightarrow> is_poincare_line\n                          (unit_disc_fix_f_circline fun circline)", "then"], ["proof (chain)\npicking this:\n  unit_disc_fix_f f\n  is_poincare_line H", "obtain M where \"unit_disc_fix M\" and *: \"f = moebius_pt M \\<or> f = moebius_pt M \\<circ> conjugate\""], ["proof (prove)\nusing this:\n  unit_disc_fix_f f\n  is_poincare_line H\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>unit_disc_fix M;\n         f = moebius_pt M \\<or> f = moebius_pt M \\<circ> conjugate\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding unit_disc_fix_f_def"], ["proof (prove)\nusing this:\n  \\<exists>M.\n     unit_disc_fix M \\<and>\n     (f = moebius_pt M \\<or> f = moebius_pt M \\<circ> conjugate)\n  is_poincare_line H\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>unit_disc_fix M;\n         f = moebius_pt M \\<or> f = moebius_pt M \\<circ> conjugate\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unit_disc_fix M\n  f = moebius_pt M \\<or> f = moebius_pt M \\<circ> conjugate\n\ngoal (1 subgoal):\n 1. \\<And>fun circline.\n       \\<lbrakk>unit_disc_fix_f fun; is_poincare_line circline\\<rbrakk>\n       \\<Longrightarrow> is_poincare_line\n                          (unit_disc_fix_f_circline fun circline)", "show \"is_poincare_line (unit_disc_fix_f_circline f H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_poincare_line (unit_disc_fix_f_circline f H)", "using *"], ["proof (prove)\nusing this:\n  f = moebius_pt M \\<or> f = moebius_pt M \\<circ> conjugate\n\ngoal (1 subgoal):\n 1. is_poincare_line (unit_disc_fix_f_circline f H)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. f = moebius_pt M \\<Longrightarrow>\n    is_poincare_line (unit_disc_fix_f_circline f H)\n 2. f = moebius_pt M \\<circ> conjugate \\<Longrightarrow>\n    is_poincare_line (unit_disc_fix_f_circline f H)", "assume \"f = moebius_pt M\""], ["proof (state)\nthis:\n  f = moebius_pt M\n\ngoal (2 subgoals):\n 1. f = moebius_pt M \\<Longrightarrow>\n    is_poincare_line (unit_disc_fix_f_circline f H)\n 2. f = moebius_pt M \\<circ> conjugate \\<Longrightarrow>\n    is_poincare_line (unit_disc_fix_f_circline f H)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = moebius_pt M\n\ngoal (1 subgoal):\n 1. is_poincare_line (unit_disc_fix_f_circline f H)", "using \\<open>unit_disc_fix M\\<close> \\<open>is_poincare_line H\\<close>"], ["proof (prove)\nusing this:\n  f = moebius_pt M\n  unit_disc_fix M\n  is_poincare_line H\n\ngoal (1 subgoal):\n 1. is_poincare_line (unit_disc_fix_f_circline f H)", "using unit_disc_fix_f_circline_direct[of M f H]"], ["proof (prove)\nusing this:\n  f = moebius_pt M\n  unit_disc_fix M\n  is_poincare_line H\n  \\<lbrakk>unit_disc_fix M; f = moebius_pt M\\<rbrakk>\n  \\<Longrightarrow> unit_disc_fix_f_circline f H = moebius_circline M H\n\ngoal (1 subgoal):\n 1. is_poincare_line (unit_disc_fix_f_circline f H)", "by auto"], ["proof (state)\nthis:\n  is_poincare_line (unit_disc_fix_f_circline f H)\n\ngoal (1 subgoal):\n 1. f = moebius_pt M \\<circ> conjugate \\<Longrightarrow>\n    is_poincare_line (unit_disc_fix_f_circline f H)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f = moebius_pt M \\<circ> conjugate \\<Longrightarrow>\n    is_poincare_line (unit_disc_fix_f_circline f H)", "assume \"f = moebius_pt M \\<circ> conjugate\""], ["proof (state)\nthis:\n  f = moebius_pt M \\<circ> conjugate\n\ngoal (1 subgoal):\n 1. f = moebius_pt M \\<circ> conjugate \\<Longrightarrow>\n    is_poincare_line (unit_disc_fix_f_circline f H)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = moebius_pt M \\<circ> conjugate\n\ngoal (1 subgoal):\n 1. is_poincare_line (unit_disc_fix_f_circline f H)", "using \\<open>unit_disc_fix M\\<close> \\<open>is_poincare_line H\\<close>"], ["proof (prove)\nusing this:\n  f = moebius_pt M \\<circ> conjugate\n  unit_disc_fix M\n  is_poincare_line H\n\ngoal (1 subgoal):\n 1. is_poincare_line (unit_disc_fix_f_circline f H)", "using unit_disc_fix_f_circline_indirect[of M f H]"], ["proof (prove)\nusing this:\n  f = moebius_pt M \\<circ> conjugate\n  unit_disc_fix M\n  is_poincare_line H\n  \\<lbrakk>unit_disc_fix M; f = moebius_pt M \\<circ> conjugate\\<rbrakk>\n  \\<Longrightarrow> unit_disc_fix_f_circline f H =\n                    (moebius_circline M \\<circ> conjugate_circline) H\n\ngoal (1 subgoal):\n 1. is_poincare_line (unit_disc_fix_f_circline f H)", "by auto"], ["proof (state)\nthis:\n  is_poincare_line (unit_disc_fix_f_circline f H)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_poincare_line (unit_disc_fix_f_circline f H)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>An example lemma about h-isometries.\\<close>"], ["", "text \\<open>H-isometries preserve h-collinearity\\<close>"], ["", "lemma p_collinear_p_isometry_pt [simp]: \n  shows \"p_collinear (p_isometry_pt M ` A) \\<longleftrightarrow> p_collinear A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_collinear (p_isometry_pt M ` A) = p_collinear A", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. p_collinear (p_isometry_pt M ` A) = p_collinear A", "have *: \"\\<forall> M A.  ((\\<lambda>x. moebius_pt M (conjugate x)) ` A = moebius_pt M ` (conjugate ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>M A.\n       (\\<lambda>x. moebius_pt M (conjugate x)) ` A =\n       moebius_pt M ` conjugate ` A", "by auto"], ["proof (state)\nthis:\n  \\<forall>M A.\n     (\\<lambda>x. moebius_pt M (conjugate x)) ` A =\n     moebius_pt M ` conjugate ` A\n\ngoal (1 subgoal):\n 1. p_collinear (p_isometry_pt M ` A) = p_collinear A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p_collinear (p_isometry_pt M ` A) = p_collinear A", "by transfer (auto simp add: unit_disc_fix_f_def *)"], ["proof (state)\nthis:\n  p_collinear (p_isometry_pt M ` A) = p_collinear A\n\ngoal:\nNo subgoals!", "qed"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsection \\<open>H-distance and h-congruence\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "lift_definition p_dist :: \"p_point \\<Rightarrow> p_point \\<Rightarrow> real\" is poincare_distance"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition p_congruent :: \"p_point \\<Rightarrow> p_point \\<Rightarrow> p_point \\<Rightarrow> p_point \\<Rightarrow> bool\" where\n  [simp]: \"p_congruent u v u' v' \\<longleftrightarrow> p_dist u v = p_dist u' v'\""], ["", "lemma\n  assumes \"p_dist u v = p_dist u' v'\"\n  assumes \"p_dist v w = p_dist v' w'\"\n  assumes \"p_dist u w = p_dist u' w'\"\n  shows \"\\<exists> f. p_isometry_pt f u = u' \\<and> p_isometry_pt f v = v' \\<and> p_isometry_pt f w = w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       p_isometry_pt f u = u' \\<and>\n       p_isometry_pt f v = v' \\<and> p_isometry_pt f w = w'", "using assms"], ["proof (prove)\nusing this:\n  p_dist u v = p_dist u' v'\n  p_dist v w = p_dist v' w'\n  p_dist u w = p_dist u' w'\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       p_isometry_pt f u = u' \\<and>\n       p_isometry_pt f v = v' \\<and> p_isometry_pt f w = w'", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v u' v' w w'.\n       \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc; u' \\<in> unit_disc;\n        v' \\<in> unit_disc; poincare_distance u v = poincare_distance u' v';\n        w \\<in> unit_disc; w' \\<in> unit_disc;\n        poincare_distance v w = poincare_distance v' w';\n        poincare_distance u w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>Collect unit_disc_fix_f.\n                            f u = u' \\<and> f v = v' \\<and> f w = w'", "using unit_disc_fix_f_congruent_triangles"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> unit_disc; ?v \\<in> unit_disc; ?w \\<in> unit_disc;\n   ?u' \\<in> unit_disc; ?v' \\<in> unit_disc; ?w' \\<in> unit_disc;\n   poincare_distance ?u ?v = poincare_distance ?u' ?v';\n   poincare_distance ?v ?w = poincare_distance ?v' ?w';\n   poincare_distance ?u ?w = poincare_distance ?u' ?w'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M.\n                       unit_disc_fix_f M \\<and>\n                       M ?u = ?u' \\<and> M ?v = ?v' \\<and> M ?w = ?w'\n\ngoal (1 subgoal):\n 1. \\<And>u v u' v' w w'.\n       \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc; u' \\<in> unit_disc;\n        v' \\<in> unit_disc; poincare_distance u v = poincare_distance u' v';\n        w \\<in> unit_disc; w' \\<in> unit_disc;\n        poincare_distance v w = poincare_distance v' w';\n        poincare_distance u w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>Collect unit_disc_fix_f.\n                            f u = u' \\<and> f v = v' \\<and> f w = w'", "by auto"], ["", "text\\<open>We prove that unit disc equipped with Poincar\\'e distance is a metric space, i.e. an\ninstantiation of @{term metric_space} locale.\\<close>"], ["", "instantiation p_point :: metric_space\nbegin"], ["", "definition \"dist_p_point = p_dist\""], ["", "definition \"(uniformity_p_point :: (p_point \\<times> p_point) filter) = (INF e\\<in>{0<..}. principal {(x, y). dist_class.dist x y < e})\""], ["", "definition \"open_p_point (U :: p_point set) = (\\<forall> x \\<in> U. eventually (\\<lambda>(x', y). x' = x \\<longrightarrow> y \\<in> U) uniformity)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(p_point, metric_space_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y. (dist x y = 0) = (x = y)\n 4. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "fix x y :: p_point"], ["proof (state)\ngoal (4 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y. (dist x y = 0) = (x = y)\n 4. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "show \"(dist_class.dist x y = 0) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist x y = 0) = (x = y)", "unfolding dist_p_point_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p_dist x y = 0) = (x = y)", "by (transfer, simp add: poincare_distance_eq_0_iff)"], ["proof (state)\nthis:\n  (dist x y = 0) = (x = y)\n\ngoal (3 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "fix x y z :: p_point"], ["proof (state)\ngoal (3 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "show \"dist_class.dist x y \\<le> dist_class.dist x z + dist_class.dist y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y \\<le> dist x z + dist y z", "unfolding dist_p_point_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p_dist x y \\<le> p_dist x z + p_dist y z", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<in> unit_disc; y \\<in> unit_disc;\n        z \\<in> unit_disc\\<rbrakk>\n       \\<Longrightarrow> poincare_distance x y\n                         \\<le> poincare_distance x z + poincare_distance y z", "using poincare_distance_triangle_inequality poincare_distance_sym"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> unit_disc; ?v \\<in> unit_disc;\n   ?w \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance ?u ?w\n                    \\<le> poincare_distance ?u ?v + poincare_distance ?v ?w\n  \\<lbrakk>?u \\<in> unit_disc; ?v \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance ?u ?v = poincare_distance ?v ?u\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<in> unit_disc; y \\<in> unit_disc;\n        z \\<in> unit_disc\\<rbrakk>\n       \\<Longrightarrow> poincare_distance x y\n                         \\<le> poincare_distance x z + poincare_distance y z", "by metis"], ["proof (state)\nthis:\n  dist x y \\<le> dist x z + dist y z\n\ngoal (2 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)", "qed (simp_all add: open_p_point_def uniformity_p_point_def)"], ["", "end"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsection \\<open>H-betweennes\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "lift_definition p_between :: \"p_point \\<Rightarrow> p_point \\<Rightarrow> p_point \\<Rightarrow> bool\" is poincare_between"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}