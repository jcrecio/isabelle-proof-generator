{"file_name": "/home/qj213/afp-2021-10-22/thys/Poincare_Disc/Poincare_Circles.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Poincare_Disc", "problem_names": ["lemma poincare_circle_in_disc:\n  assumes \"r > 0\" and \"z \\<in> unit_disc\" and \"(ze, re) = poincare_circle_euclidean z r\"\n  shows \"cmod ze < 1\" \"re > 0\" \"\\<forall> x \\<in> circle ze re. cmod x < 1\"", "lemma poincare_circle_is_euclidean_circle:\n  assumes \"z \\<in> unit_disc\" and \"r > 0\"\n  shows  \"let (Ze, Re) = poincare_circle_euclidean z r\n           in of_complex ` (circle Ze Re) = poincare_circle z r\"", "lemma intersect_poincare_circles_x_axis:\n  assumes z: \"is_real z1\" and \"is_real z2\" and \"r1 > 0\" and \"r2 > 0\" and\n             \"-1 < Re z1\" and \"Re z1 < 1\" and \"-1 < Re z2\" and \"Re z2 < 1\" and\n             \"z1 \\<noteq> z2\"\n  assumes x1: \"x1 \\<in> poincare_circle (of_complex z1) r1 \\<inter> poincare_circle (of_complex z2) r2\" and\n          x2: \"x2 \\<in> poincare_circle (of_complex z1) r1 \\<inter> poincare_circle (of_complex z2) r2\" and\n              \"x1 \\<noteq> x2\"\n  shows \"x1 = conjugate x2\"", "lemma intersect_poincare_circles_conjugate_centers:\n  assumes in_disc: \"z1 \\<in> unit_disc\" \"z2 \\<in> unit_disc\" and \n          \"z1 \\<noteq> z2\" and \"z1 = conjugate z2\" and \"r > 0\" and\n          u: \"u \\<in> poincare_circle z1 r \\<inter> poincare_circle z2 r\"\n  shows \"is_real (to_complex u)\"", "lemma unit_disc_fix_f_congruent_triangles:\n  assumes\n    in_disc: \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"w \\<in> unit_disc\" and\n    in_disc': \"u' \\<in> unit_disc\" \"v' \\<in> unit_disc\" \"w' \\<in> unit_disc\" and \n    d: \"poincare_distance u v = poincare_distance u' v'\"\n       \"poincare_distance v w = poincare_distance v' w'\"\n       \"poincare_distance u w = poincare_distance u' w'\"\n  shows\n    \"\\<exists> M. unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'\""], "translations": [["", "lemma poincare_circle_in_disc:\n  assumes \"r > 0\" and \"z \\<in> unit_disc\" and \"(ze, re) = poincare_circle_euclidean z r\"\n  shows \"cmod ze < 1\" \"re > 0\" \"\\<forall> x \\<in> circle ze re. cmod x < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod ze < 1 &&& 0 < re &&& \\<forall>x\\<in>circle ze re. cmod x < 1", "proof-"], ["proof (state)\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "let ?R = \"(cosh r - 1) / 2\""], ["proof (state)\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "let ?z' = \"to_complex z\""], ["proof (state)\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "let ?cz = \"1 - (cmod ?z')\\<^sup>2\""], ["proof (state)\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "let ?k = \"?cz * ?R + 1\""], ["proof (state)\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "let ?ze = \"?z' / ?k\""], ["proof (state)\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "let ?re = \"?cz * sqrt(?R * (?R + 1)) / ?k\""], ["proof (state)\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "from \\<open>z \\<in> unit_disc\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> unit_disc", "obtain z' where z': \"z = of_complex z'\""], ["proof (prove)\nusing this:\n  z \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. (\\<And>z'. z = of_complex z' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inf_or_of_complex[of z]"], ["proof (prove)\nusing this:\n  z \\<in> unit_disc\n  z = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. z = of_complex x)\n\ngoal (1 subgoal):\n 1. (\\<And>z'. z = of_complex z' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z = of_complex z'\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "hence \"z' = ?z'\""], ["proof (prove)\nusing this:\n  z = of_complex z'\n\ngoal (1 subgoal):\n 1. z' = to_complex z", "by simp"], ["proof (state)\nthis:\n  z' = to_complex z\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "obtain cz where cz: \"cz = (1 - (cmod z')\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cz.\n        cz = 1 - (cmod z')\\<^sup>2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cz = 1 - (cmod z')\\<^sup>2\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "have \"cz > 0\" \"cz \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < cz &&& cz \\<le> 1", "using \\<open>z \\<in> unit_disc\\<close> z' cz"], ["proof (prove)\nusing this:\n  z \\<in> unit_disc\n  z = of_complex z'\n  cz = 1 - (cmod z')\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 < cz &&& cz \\<le> 1", "using unit_disc_cmod_square_lt_1"], ["proof (prove)\nusing this:\n  z \\<in> unit_disc\n  z = of_complex z'\n  cz = 1 - (cmod z')\\<^sup>2\n  ?z \\<in> unit_disc \\<Longrightarrow> (cmod (to_complex ?z))\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. 0 < cz &&& cz \\<le> 1", "by fastforce+"], ["proof (state)\nthis:\n  0 < cz\n  cz \\<le> 1\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "obtain R where R: \"R = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        R = (cosh r - 1) / 2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  R = (cosh r - 1) / 2\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "have \"R > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < R", "using cosh_gt_1[of r] \\<open>r > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < r \\<Longrightarrow> 1 < cosh r\n  0 < r\n\ngoal (1 subgoal):\n 1. 0 < R", "by (subst R) simp"], ["proof (state)\nthis:\n  0 < R\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "obtain k where k: \"k = cz * R + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. k = cz * R + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k = cz * R + 1\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "have \"k > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < k", "using k \\<open>R > 0\\<close> \\<open>cz > 0\\<close>"], ["proof (prove)\nusing this:\n  k = cz * R + 1\n  0 < R\n  0 < cz\n\ngoal (1 subgoal):\n 1. 1 < k", "by simp"], ["proof (state)\nthis:\n  1 < k\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "hence \"cmod k = k\""], ["proof (prove)\nusing this:\n  1 < k\n\ngoal (1 subgoal):\n 1. cmod (cor k) = k", "by simp"], ["proof (state)\nthis:\n  cmod (cor k) = k\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "let ?RR = \"cz * sqrt(R * (R + 1)) / k\""], ["proof (state)\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "have \"cmod z' + cz * sqrt(R * (R + 1)) < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "have \"((R+1)-R)\\<^sup>2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (R + 1 - R)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  0 < (R + 1 - R)\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "hence \"(R+1)\\<^sup>2 - 2*R*(R+1) + R\\<^sup>2 > 0\""], ["proof (prove)\nusing this:\n  0 < (R + 1 - R)\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 < (R + 1)\\<^sup>2 - 2 * R * (R + 1) + R\\<^sup>2", "unfolding power2_diff"], ["proof (prove)\nusing this:\n  0 < (R + 1)\\<^sup>2 + R\\<^sup>2 - 2 * (R + 1) * R\n\ngoal (1 subgoal):\n 1. 0 < (R + 1)\\<^sup>2 - 2 * R * (R + 1) + R\\<^sup>2", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  0 < (R + 1)\\<^sup>2 - 2 * R * (R + 1) + R\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "hence \"(R+1)\\<^sup>2 + 2*R*(R+1) + R\\<^sup>2 - 4*R*(R+1) > 0\""], ["proof (prove)\nusing this:\n  0 < (R + 1)\\<^sup>2 - 2 * R * (R + 1) + R\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 < (R + 1)\\<^sup>2 + 2 * R * (R + 1) + R\\<^sup>2 - 4 * R * (R + 1)", "by simp"], ["proof (state)\nthis:\n  0 < (R + 1)\\<^sup>2 + 2 * R * (R + 1) + R\\<^sup>2 - 4 * R * (R + 1)\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "hence \"(2*R+1)\\<^sup>2 / 4 > R*(R+1)\""], ["proof (prove)\nusing this:\n  0 < (R + 1)\\<^sup>2 + 2 * R * (R + 1) + R\\<^sup>2 - 4 * R * (R + 1)\n\ngoal (1 subgoal):\n 1. R * (R + 1) < (2 * R + 1)\\<^sup>2 / 4", "using power2_sum[of \"R+1\" R]"], ["proof (prove)\nusing this:\n  0 < (R + 1)\\<^sup>2 + 2 * R * (R + 1) + R\\<^sup>2 - 4 * R * (R + 1)\n  (R + 1 + R)\\<^sup>2 = (R + 1)\\<^sup>2 + R\\<^sup>2 + 2 * (R + 1) * R\n\ngoal (1 subgoal):\n 1. R * (R + 1) < (2 * R + 1)\\<^sup>2 / 4", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  R * (R + 1) < (2 * R + 1)\\<^sup>2 / 4\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "hence \"sqrt(R*(R+1)) < (2*R+1) / 2\""], ["proof (prove)\nusing this:\n  R * (R + 1) < (2 * R + 1)\\<^sup>2 / 4\n\ngoal (1 subgoal):\n 1. sqrt (R * (R + 1)) < (2 * R + 1) / 2", "using \\<open>R > 0\\<close>"], ["proof (prove)\nusing this:\n  R * (R + 1) < (2 * R + 1)\\<^sup>2 / 4\n  0 < R\n\ngoal (1 subgoal):\n 1. sqrt (R * (R + 1)) < (2 * R + 1) / 2", "by (smt arith_geo_mean_sqrt power_divide real_sqrt_four real_sqrt_pow2 zero_le_mult_iff)"], ["proof (state)\nthis:\n  sqrt (R * (R + 1)) < (2 * R + 1) / 2\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "hence \"sqrt(R*(R+1)) - R < 1/2\""], ["proof (prove)\nusing this:\n  sqrt (R * (R + 1)) < (2 * R + 1) / 2\n\ngoal (1 subgoal):\n 1. sqrt (R * (R + 1)) - R < 1 / 2", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  sqrt (R * (R + 1)) - R < 1 / 2\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "hence \"(1 + (cmod z')) * (sqrt(R*(R+1)) - R) < (1 + (cmod z')) *  (1 / 2)\""], ["proof (prove)\nusing this:\n  sqrt (R * (R + 1)) - R < 1 / 2\n\ngoal (1 subgoal):\n 1. (1 + cmod z') * (sqrt (R * (R + 1)) - R) < (1 + cmod z') * (1 / 2)", "by (subst mult_strict_left_mono, simp, smt norm_not_less_zero, simp)"], ["proof (state)\nthis:\n  (1 + cmod z') * (sqrt (R * (R + 1)) - R) < (1 + cmod z') * (1 / 2)\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "also"], ["proof (state)\nthis:\n  (1 + cmod z') * (sqrt (R * (R + 1)) - R) < (1 + cmod z') * (1 / 2)\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "have \"... < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + cmod z') * (1 / 2) < 1", "using \\<open>z \\<in> unit_disc\\<close> z'"], ["proof (prove)\nusing this:\n  z \\<in> unit_disc\n  z = of_complex z'\n\ngoal (1 subgoal):\n 1. (1 + cmod z') * (1 / 2) < 1", "by auto"], ["proof (state)\nthis:\n  (1 + cmod z') * (1 / 2) < 1\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "finally"], ["proof (chain)\npicking this:\n  (1 + cmod z') * (sqrt (R * (R + 1)) - R) < 1", "have \"(1 - cmod z') * ((1 + cmod z') * (sqrt(R*(R+1)) - R)) < (1 - cmod z') * 1\""], ["proof (prove)\nusing this:\n  (1 + cmod z') * (sqrt (R * (R + 1)) - R) < 1\n\ngoal (1 subgoal):\n 1. (1 - cmod z') * ((1 + cmod z') * (sqrt (R * (R + 1)) - R))\n    < (1 - cmod z') * 1", "using \\<open>z \\<in> unit_disc\\<close> z'"], ["proof (prove)\nusing this:\n  (1 + cmod z') * (sqrt (R * (R + 1)) - R) < 1\n  z \\<in> unit_disc\n  z = of_complex z'\n\ngoal (1 subgoal):\n 1. (1 - cmod z') * ((1 + cmod z') * (sqrt (R * (R + 1)) - R))\n    < (1 - cmod z') * 1", "by (subst mult_strict_left_mono, simp_all)"], ["proof (state)\nthis:\n  (1 - cmod z') * ((1 + cmod z') * (sqrt (R * (R + 1)) - R))\n  < (1 - cmod z') * 1\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "hence \"cz * (sqrt (R*(R+1)) - R) < 1 - cmod z'\""], ["proof (prove)\nusing this:\n  (1 - cmod z') * ((1 + cmod z') * (sqrt (R * (R + 1)) - R))\n  < (1 - cmod z') * 1\n\ngoal (1 subgoal):\n 1. cz * (sqrt (R * (R + 1)) - R) < 1 - cmod z'", "using square_diff_square_factored[of 1 \"cmod z'\"]"], ["proof (prove)\nusing this:\n  (1 - cmod z') * ((1 + cmod z') * (sqrt (R * (R + 1)) - R))\n  < (1 - cmod z') * 1\n  1 * 1 - cmod z' * cmod z' = (1 + cmod z') * (1 - cmod z')\n\ngoal (1 subgoal):\n 1. cz * (sqrt (R * (R + 1)) - R) < 1 - cmod z'", "by (subst cz, subst (asm) mult.assoc[symmetric], simp add: power2_eq_square field_simps)"], ["proof (state)\nthis:\n  cz * (sqrt (R * (R + 1)) - R) < 1 - cmod z'\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "hence \"cmod z' + cz * sqrt(R*(R+1)) < 1 + R * cz\""], ["proof (prove)\nusing this:\n  cz * (sqrt (R * (R + 1)) - R) < 1 - cmod z'\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < 1 + R * cz", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cmod z' + cz * sqrt (R * (R + 1)) < 1 + R * cz\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "thus ?thesis"], ["proof (prove)\nusing this:\n  cmod z' + cz * sqrt (R * (R + 1)) < 1 + R * cz\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "using k"], ["proof (prove)\nusing this:\n  cmod z' + cz * sqrt (R * (R + 1)) < 1 + R * cz\n  k = cz * R + 1\n\ngoal (1 subgoal):\n 1. cmod z' + cz * sqrt (R * (R + 1)) < k", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cmod z' + cz * sqrt (R * (R + 1)) < k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cmod z' + cz * sqrt (R * (R + 1)) < k\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "hence \"cmod z' / k + cz * sqrt(R * (R + 1)) / k < 1\""], ["proof (prove)\nusing this:\n  cmod z' + cz * sqrt (R * (R + 1)) < k\n\ngoal (1 subgoal):\n 1. cmod z' / k + cz * sqrt (R * (R + 1)) / k < 1", "using \\<open>k > 1\\<close>"], ["proof (prove)\nusing this:\n  cmod z' + cz * sqrt (R * (R + 1)) < k\n  1 < k\n\ngoal (1 subgoal):\n 1. cmod z' / k + cz * sqrt (R * (R + 1)) / k < 1", "unfolding add_divide_distrib[symmetric]"], ["proof (prove)\nusing this:\n  cmod z' + cz * sqrt (R * (R + 1)) < k\n  1 < k\n\ngoal (1 subgoal):\n 1. (cmod z' + cz * sqrt (R * (R + 1))) / k < 1", "by simp"], ["proof (state)\nthis:\n  cmod z' / k + cz * sqrt (R * (R + 1)) / k < 1\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "hence \"cmod (z' / k) + cz * sqrt(R * (R + 1)) / k < 1\""], ["proof (prove)\nusing this:\n  cmod z' / k + cz * sqrt (R * (R + 1)) / k < 1\n\ngoal (1 subgoal):\n 1. cmod (z' / cor k) + cz * sqrt (R * (R + 1)) / k < 1", "using \\<open>k > 1\\<close>"], ["proof (prove)\nusing this:\n  cmod z' / k + cz * sqrt (R * (R + 1)) / k < 1\n  1 < k\n\ngoal (1 subgoal):\n 1. cmod (z' / cor k) + cz * sqrt (R * (R + 1)) / k < 1", "by simp"], ["proof (state)\nthis:\n  cmod (z' / cor k) + cz * sqrt (R * (R + 1)) / k < 1\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "hence \"cmod ?ze + ?re < 1\""], ["proof (prove)\nusing this:\n  cmod (z' / cor k) + cz * sqrt (R * (R + 1)) / k < 1\n\ngoal (1 subgoal):\n 1. cmod\n     (to_complex z /\n      cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)) +\n    (1 - (cmod (to_complex z))\\<^sup>2) *\n    sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n    ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n    < 1", "using k cz \\<open>R = ?R\\<close> z'"], ["proof (prove)\nusing this:\n  cmod (z' / cor k) + cz * sqrt (R * (R + 1)) / k < 1\n  k = cz * R + 1\n  cz = 1 - (cmod z')\\<^sup>2\n  R = (cosh r - 1) / 2\n  z = of_complex z'\n\ngoal (1 subgoal):\n 1. cmod\n     (to_complex z /\n      cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)) +\n    (1 - (cmod (to_complex z))\\<^sup>2) *\n    sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n    ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n    < 1", "by simp"], ["proof (state)\nthis:\n  cmod\n   (to_complex z /\n    cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)) +\n  (1 - (cmod (to_complex z))\\<^sup>2) *\n  sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n  ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  < 1\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "moreover"], ["proof (state)\nthis:\n  cmod\n   (to_complex z /\n    cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)) +\n  (1 - (cmod (to_complex z))\\<^sup>2) *\n  sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n  ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  < 1\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "have \"cz * sqrt(R * (R + 1)) / k > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < cz * sqrt (R * (R + 1)) / k", "using \\<open>cz > 0\\<close> \\<open>R > 0\\<close> \\<open>k > 1\\<close>"], ["proof (prove)\nusing this:\n  0 < cz\n  0 < R\n  1 < k\n\ngoal (1 subgoal):\n 1. 0 < cz * sqrt (R * (R + 1)) / k", "by auto"], ["proof (state)\nthis:\n  0 < cz * sqrt (R * (R + 1)) / k\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "hence \"?re > 0\""], ["proof (prove)\nusing this:\n  0 < cz * sqrt (R * (R + 1)) / k\n\ngoal (1 subgoal):\n 1. 0 < (1 - (cmod (to_complex z))\\<^sup>2) *\n        sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n        ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)", "using k cz \\<open>R = ?R\\<close> z'"], ["proof (prove)\nusing this:\n  0 < cz * sqrt (R * (R + 1)) / k\n  k = cz * R + 1\n  cz = 1 - (cmod z')\\<^sup>2\n  R = (cosh r - 1) / 2\n  z = of_complex z'\n\ngoal (1 subgoal):\n 1. 0 < (1 - (cmod (to_complex z))\\<^sup>2) *\n        sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n        ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)", "by simp"], ["proof (state)\nthis:\n  0 < (1 - (cmod (to_complex z))\\<^sup>2) *\n      sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n      ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "moreover"], ["proof (state)\nthis:\n  0 < (1 - (cmod (to_complex z))\\<^sup>2) *\n      sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n      ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "have \"cmod ?ze < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (to_complex z /\n      cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1))\n    < 1", "using \\<open>cmod ?ze + ?re < 1\\<close> \\<open>?re > 0\\<close>"], ["proof (prove)\nusing this:\n  cmod\n   (to_complex z /\n    cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)) +\n  (1 - (cmod (to_complex z))\\<^sup>2) *\n  sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n  ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  < 1\n  0 < (1 - (cmod (to_complex z))\\<^sup>2) *\n      sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n      ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n\ngoal (1 subgoal):\n 1. cmod\n     (to_complex z /\n      cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1))\n    < 1", "by simp"], ["proof (state)\nthis:\n  cmod\n   (to_complex z /\n    cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1))\n  < 1\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "moreover"], ["proof (state)\nthis:\n  cmod\n   (to_complex z /\n    cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1))\n  < 1\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "have \"ze = ?ze\" \"re = ?re\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ze =\n    to_complex z /\n    cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1) &&&\n    re =\n    (1 - (cmod (to_complex z))\\<^sup>2) *\n    sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n    ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)", "using \\<open>(ze, re) = poincare_circle_euclidean z r\\<close>"], ["proof (prove)\nusing this:\n  (ze, re) = poincare_circle_euclidean z r\n\ngoal (1 subgoal):\n 1. ze =\n    to_complex z /\n    cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1) &&&\n    re =\n    (1 - (cmod (to_complex z))\\<^sup>2) *\n    sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n    ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)", "unfolding poincare_circle_euclidean_def Let_def"], ["proof (prove)\nusing this:\n  (ze, re) =\n  (to_complex z /\n   cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1),\n   (1 - (cmod (to_complex z))\\<^sup>2) *\n   sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n   ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1))\n\ngoal (1 subgoal):\n 1. ze =\n    to_complex z /\n    cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1) &&&\n    re =\n    (1 - (cmod (to_complex z))\\<^sup>2) *\n    sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n    ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)", "by simp_all"], ["proof (state)\nthis:\n  ze =\n  to_complex z /\n  cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  re =\n  (1 - (cmod (to_complex z))\\<^sup>2) *\n  sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n  ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "moreover"], ["proof (state)\nthis:\n  ze =\n  to_complex z /\n  cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  re =\n  (1 - (cmod (to_complex z))\\<^sup>2) *\n  sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n  ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "have \"\\<forall> x \\<in> circle ze re. cmod x \\<le> cmod ze + re\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>circle ze re. cmod x \\<le> cmod ze + re", "using norm_triangle_ineq2[of _ ze]"], ["proof (prove)\nusing this:\n  cmod ?a - cmod ze \\<le> cmod (?a - ze)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>circle ze re. cmod x \\<le> cmod ze + re", "unfolding circle_def"], ["proof (prove)\nusing this:\n  cmod ?a - cmod ze \\<le> cmod (?a - ze)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{z. cmod (z - ze) = re}. cmod x \\<le> cmod ze + re", "by (smt mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>circle ze re. cmod x \\<le> cmod ze + re\n\ngoal (3 subgoals):\n 1. cmod ze < 1\n 2. 0 < re\n 3. \\<forall>x\\<in>circle ze re. cmod x < 1", "ultimately"], ["proof (chain)\npicking this:\n  cmod\n   (to_complex z /\n    cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)) +\n  (1 - (cmod (to_complex z))\\<^sup>2) *\n  sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n  ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  < 1\n  0 < (1 - (cmod (to_complex z))\\<^sup>2) *\n      sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n      ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  cmod\n   (to_complex z /\n    cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1))\n  < 1\n  ze =\n  to_complex z /\n  cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  re =\n  (1 - (cmod (to_complex z))\\<^sup>2) *\n  sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n  ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  \\<forall>x\\<in>circle ze re. cmod x \\<le> cmod ze + re", "show \"cmod ze < 1\" \"re > 0\" \"\\<forall> x \\<in> circle ze re. cmod x < 1\""], ["proof (prove)\nusing this:\n  cmod\n   (to_complex z /\n    cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)) +\n  (1 - (cmod (to_complex z))\\<^sup>2) *\n  sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n  ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  < 1\n  0 < (1 - (cmod (to_complex z))\\<^sup>2) *\n      sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n      ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  cmod\n   (to_complex z /\n    cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1))\n  < 1\n  ze =\n  to_complex z /\n  cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  re =\n  (1 - (cmod (to_complex z))\\<^sup>2) *\n  sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n  ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) + 1)\n  \\<forall>x\\<in>circle ze re. cmod x \\<le> cmod ze + re\n\ngoal (1 subgoal):\n 1. cmod ze < 1 &&& 0 < re &&& \\<forall>x\\<in>circle ze re. cmod x < 1", "by auto"], ["proof (state)\nthis:\n  cmod ze < 1\n  0 < re\n  \\<forall>x\\<in>circle ze re. cmod x < 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The connection between the points on the h-circle and its corresponding Euclidean circle.\\<close>"], ["", "lemma poincare_circle_is_euclidean_circle:\n  assumes \"z \\<in> unit_disc\" and \"r > 0\"\n  shows  \"let (Ze, Re) = poincare_circle_euclidean z r\n           in of_complex ` (circle Ze Re) = poincare_circle z r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "let ?z = \"to_complex z\""], ["proof (state)\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "from assms"], ["proof (chain)\npicking this:\n  z \\<in> unit_disc\n  0 < r", "obtain z' where z': \"z = of_complex z'\" \"cmod z' < 1\""], ["proof (prove)\nusing this:\n  z \\<in> unit_disc\n  0 < r\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>z = of_complex z'; cmod z' < 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inf_or_of_complex[of z]"], ["proof (prove)\nusing this:\n  z \\<in> unit_disc\n  0 < r\n  z = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. z = of_complex x)\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>z = of_complex z'; cmod z' < 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z = of_complex z'\n  cmod z' < 1\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have *: \"\\<And> x. cmod x < 1 \\<Longrightarrow> 1 - (cmod x)\\<^sup>2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. cmod x < 1 \\<Longrightarrow> 0 < 1 - (cmod x)\\<^sup>2", "by (metis less_iff_diff_less_0 minus_diff_eq mult.left_neutral neg_less_0_iff_less norm_mult_less norm_power power2_eq_square)"], ["proof (state)\nthis:\n  cmod ?x < 1 \\<Longrightarrow> 0 < 1 - (cmod ?x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "let ?R = \"(cosh r - 1) / 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "obtain R where R: \"R = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        R = (cosh r - 1) / 2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  R = (cosh r - 1) / 2\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "let ?cx = \"1 - (cmod x)\\<^sup>2\" and ?cz = \"1 - (cmod z')\\<^sup>2\"  and ?czx = \"(cmod (z' - x))\\<^sup>2\""], ["proof (state)\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "let ?k = \"1 + R * ?cz\""], ["proof (state)\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "obtain k where k: \"k = ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k = 1 + R * (1 - (cmod z')\\<^sup>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k = 1 + R * (1 - (cmod z')\\<^sup>2)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"R > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < R", "using R cosh_gt_1[OF \\<open>r > 0\\<close>]"], ["proof (prove)\nusing this:\n  R = (cosh r - 1) / 2\n  1 < cosh r\n\ngoal (1 subgoal):\n 1. 0 < R", "by simp"], ["proof (state)\nthis:\n  0 < R\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "hence \"k > 1\""], ["proof (prove)\nusing this:\n  0 < R\n\ngoal (1 subgoal):\n 1. 1 < k", "using assms z' k *[of z']"], ["proof (prove)\nusing this:\n  0 < R\n  z \\<in> unit_disc\n  0 < r\n  z = of_complex z'\n  cmod z' < 1\n  k = 1 + R * (1 - (cmod z')\\<^sup>2)\n  cmod z' < 1 \\<Longrightarrow> 0 < 1 - (cmod z')\\<^sup>2\n\ngoal (1 subgoal):\n 1. 1 < k", "by auto"], ["proof (state)\nthis:\n  1 < k\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "hence **: \"cor k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  1 < k\n\ngoal (1 subgoal):\n 1. cor k \\<noteq> 0", "by (smt of_real_eq_0_iff)"], ["proof (state)\nthis:\n  cor k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"of_complex x \\<in> poincare_circle z r \\<longleftrightarrow> cmod x < 1 \\<and> poincare_distance z (of_complex x) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_complex x \\<in> poincare_circle z r) =\n    (cmod x < 1 \\<and> poincare_distance z (of_complex x) = r)", "unfolding poincare_circle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_complex x \\<in> {z' \\<in> unit_disc. poincare_distance z z' = r}) =\n    (cmod x < 1 \\<and> poincare_distance z (of_complex x) = r)", "by auto"], ["proof (state)\nthis:\n  (of_complex x \\<in> poincare_circle z r) =\n  (cmod x < 1 \\<and> poincare_distance z (of_complex x) = r)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (of_complex x \\<in> poincare_circle z r) =\n  (cmod x < 1 \\<and> poincare_distance z (of_complex x) = r)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> poincare_distance_formula' ?z x = cosh r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and> poincare_distance z (of_complex x) = r) =\n    (cmod x < 1 \\<and> poincare_distance_formula' (to_complex z) x = cosh r)", "using poincare_distance_formula[of z \"of_complex x\"] cosh_dist[of z \"of_complex x\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>z \\<in> unit_disc; of_complex x \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance z (of_complex x) =\n                    poincare_distance_formula (to_complex z)\n                     (to_complex (of_complex x))\n  \\<lbrakk>z \\<in> unit_disc; of_complex x \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> cosh_dist z (of_complex x) =\n                    poincare_distance_formula' (to_complex z)\n                     (to_complex (of_complex x))\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and> poincare_distance z (of_complex x) = r) =\n    (cmod x < 1 \\<and> poincare_distance_formula' (to_complex z) x = cosh r)", "unfolding poincare_distance_formula_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>z \\<in> unit_disc; of_complex x \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance z (of_complex x) =\n                    arcosh\n                     (poincare_distance_formula' (to_complex z)\n                       (to_complex (of_complex x)))\n  \\<lbrakk>z \\<in> unit_disc; of_complex x \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> cosh_dist z (of_complex x) =\n                    poincare_distance_formula' (to_complex z)\n                     (to_complex (of_complex x))\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and> poincare_distance z (of_complex x) = r) =\n    (cmod x < 1 \\<and> poincare_distance_formula' (to_complex z) x = cosh r)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>z \\<in> unit_disc; of_complex x \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance z (of_complex x) =\n                    arcosh\n                     (poincare_distance_formula' (to_complex z)\n                       (to_complex (of_complex x)))\n  \\<lbrakk>z \\<in> unit_disc; of_complex x \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> cosh_dist z (of_complex x) =\n                    poincare_distance_formula' (to_complex z)\n                     (to_complex (of_complex x))\n  z \\<in> unit_disc\n  0 < r\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and> poincare_distance z (of_complex x) = r) =\n    (cmod x < 1 \\<and> poincare_distance_formula' (to_complex z) x = cosh r)", "using arcosh_cosh_real"], ["proof (prove)\nusing this:\n  \\<lbrakk>z \\<in> unit_disc; of_complex x \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance z (of_complex x) =\n                    arcosh\n                     (poincare_distance_formula' (to_complex z)\n                       (to_complex (of_complex x)))\n  \\<lbrakk>z \\<in> unit_disc; of_complex x \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> cosh_dist z (of_complex x) =\n                    poincare_distance_formula' (to_complex z)\n                     (to_complex (of_complex x))\n  z \\<in> unit_disc\n  0 < r\n  0 \\<le> ?x \\<Longrightarrow> arcosh (cosh ?x) = ?x\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and> poincare_distance z (of_complex x) = r) =\n    (cmod x < 1 \\<and> poincare_distance_formula' (to_complex z) x = cosh r)", "by auto"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and> poincare_distance z (of_complex x) = r) =\n  (cmod x < 1 \\<and> poincare_distance_formula' (to_complex z) x = cosh r)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and> poincare_distance z (of_complex x) = r) =\n  (cmod x < 1 \\<and> poincare_distance_formula' (to_complex z) x = cosh r)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> ?czx / (?cz * ?cx) = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     poincare_distance_formula' (to_complex z) x = cosh r) =\n    (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 /\n     ((1 - (cmod z')\\<^sup>2) * (1 - (cmod x)\\<^sup>2)) =\n     (cosh r - 1) / 2)", "using z'"], ["proof (prove)\nusing this:\n  z = of_complex z'\n  cmod z' < 1\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     poincare_distance_formula' (to_complex z) x = cosh r) =\n    (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 /\n     ((1 - (cmod z')\\<^sup>2) * (1 - (cmod x)\\<^sup>2)) =\n     (cosh r - 1) / 2)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and> poincare_distance_formula' (to_complex z) x = cosh r) =\n  (cmod x < 1 \\<and>\n   (cmod (z' - x))\\<^sup>2 /\n   ((1 - (cmod z')\\<^sup>2) * (1 - (cmod x)\\<^sup>2)) =\n   (cosh r - 1) / 2)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and> poincare_distance_formula' (to_complex z) x = cosh r) =\n  (cmod x < 1 \\<and>\n   (cmod (z' - x))\\<^sup>2 /\n   ((1 - (cmod z')\\<^sup>2) * (1 - (cmod x)\\<^sup>2)) =\n   (cosh r - 1) / 2)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> ?czx = ?R * ?cx * ?cz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 /\n     ((1 - (cmod z')\\<^sup>2) * (1 - (cmod x)\\<^sup>2)) =\n     (cosh r - 1) / 2) =\n    (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 =\n     (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2))", "using assms z' *[of z'] *[of x]"], ["proof (prove)\nusing this:\n  z \\<in> unit_disc\n  0 < r\n  z = of_complex z'\n  cmod z' < 1\n  cmod z' < 1 \\<Longrightarrow> 0 < 1 - (cmod z')\\<^sup>2\n  cmod x < 1 \\<Longrightarrow> 0 < 1 - (cmod x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 /\n     ((1 - (cmod z')\\<^sup>2) * (1 - (cmod x)\\<^sup>2)) =\n     (cosh r - 1) / 2) =\n    (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 =\n     (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2))", "using nonzero_divide_eq_eq[of \"(1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)\" \"(cmod (z' - x))\\<^sup>2\" ?R]"], ["proof (prove)\nusing this:\n  z \\<in> unit_disc\n  0 < r\n  z = of_complex z'\n  cmod z' < 1\n  cmod z' < 1 \\<Longrightarrow> 0 < 1 - (cmod z')\\<^sup>2\n  cmod x < 1 \\<Longrightarrow> 0 < 1 - (cmod x)\\<^sup>2\n  (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2) \\<noteq>\n  0 \\<Longrightarrow>\n  ((cmod (z' - x))\\<^sup>2 /\n   ((1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)) =\n   (cosh r - 1) / 2) =\n  ((cmod (z' - x))\\<^sup>2 =\n   (cosh r - 1) / 2 * ((1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 /\n     ((1 - (cmod z')\\<^sup>2) * (1 - (cmod x)\\<^sup>2)) =\n     (cosh r - 1) / 2) =\n    (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 =\n     (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2))", "by (auto, simp add: field_simps)"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cmod (z' - x))\\<^sup>2 /\n   ((1 - (cmod z')\\<^sup>2) * (1 - (cmod x)\\<^sup>2)) =\n   (cosh r - 1) / 2) =\n  (cmod x < 1 \\<and>\n   (cmod (z' - x))\\<^sup>2 =\n   (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2))\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cmod (z' - x))\\<^sup>2 /\n   ((1 - (cmod z')\\<^sup>2) * (1 - (cmod x)\\<^sup>2)) =\n   (cosh r - 1) / 2) =\n  (cmod x < 1 \\<and>\n   (cmod (z' - x))\\<^sup>2 =\n   (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2))\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> (z' - x) * (cnj z' - cnj x) = R * ?cz * (1 - x * cnj x)\" (is \"_ \\<longleftrightarrow> _ \\<and> ?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 =\n     (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)) =\n    (cmod x < 1 \\<and>\n     (z' - x) * (cnj z' - cnj x) =\n     cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 =\n     (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)) =\n    (cmod x < 1 \\<and>\n     (z' - x) * (cnj z' - cnj x) =\n     cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x))", "let ?l = \"(z' - x) * (cnj z' - cnj x)\" and ?r = \"R * (1 - Re (z' * cnj z')) * (1 - x * cnj x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 =\n     (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)) =\n    (cmod x < 1 \\<and>\n     (z' - x) * (cnj z' - cnj x) =\n     cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x))", "have \"is_real ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real ((z' - x) * (cnj z' - cnj x))", "using eq_cnj_iff_real[of \"?l\"]"], ["proof (prove)\nusing this:\n  (cnj ((z' - x) * (cnj z' - cnj x)) = (z' - x) * (cnj z' - cnj x)) =\n  is_real ((z' - x) * (cnj z' - cnj x))\n\ngoal (1 subgoal):\n 1. is_real ((z' - x) * (cnj z' - cnj x))", "by simp"], ["proof (state)\nthis:\n  is_real ((z' - x) * (cnj z' - cnj x))\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 =\n     (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)) =\n    (cmod x < 1 \\<and>\n     (z' - x) * (cnj z' - cnj x) =\n     cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x))", "moreover"], ["proof (state)\nthis:\n  is_real ((z' - x) * (cnj z' - cnj x))\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 =\n     (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)) =\n    (cmod x < 1 \\<and>\n     (z' - x) * (cnj z' - cnj x) =\n     cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x))", "have \"is_real ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (cor (R * (1 - Re (z' * cnj z'))) * (1 - x * cnj x))", "using eq_cnj_iff_real[of \"1 - x * cnj x\"]"], ["proof (prove)\nusing this:\n  (cnj (1 - x * cnj x) = 1 - x * cnj x) = is_real (1 - x * cnj x)\n\ngoal (1 subgoal):\n 1. is_real (cor (R * (1 - Re (z' * cnj z'))) * (1 - x * cnj x))", "using Im_complex_of_real[of \"R * (1 - Re (z' * cnj z'))\"]"], ["proof (prove)\nusing this:\n  (cnj (1 - x * cnj x) = 1 - x * cnj x) = is_real (1 - x * cnj x)\n  is_real (cor (R * (1 - Re (z' * cnj z'))))\n\ngoal (1 subgoal):\n 1. is_real (cor (R * (1 - Re (z' * cnj z'))) * (1 - x * cnj x))", "by simp"], ["proof (state)\nthis:\n  is_real (cor (R * (1 - Re (z' * cnj z'))) * (1 - x * cnj x))\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 =\n     (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)) =\n    (cmod x < 1 \\<and>\n     (z' - x) * (cnj z' - cnj x) =\n     cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x))", "ultimately"], ["proof (chain)\npicking this:\n  is_real ((z' - x) * (cnj z' - cnj x))\n  is_real (cor (R * (1 - Re (z' * cnj z'))) * (1 - x * cnj x))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_real ((z' - x) * (cnj z' - cnj x))\n  is_real (cor (R * (1 - Re (z' * cnj z'))) * (1 - x * cnj x))\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (z' - x))\\<^sup>2 =\n     (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)) =\n    (cmod x < 1 \\<and>\n     (z' - x) * (cnj z' - cnj x) =\n     cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x))", "apply (subst R[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_real ((z' - x) * (cnj z' - cnj x));\n     is_real (cor (R * (1 - Re (z' * cnj z'))) * (1 - x * cnj x))\\<rbrakk>\n    \\<Longrightarrow> (cmod x < 1 \\<and>\n                       (cmod (z' - x))\\<^sup>2 =\n                       R * (1 - (cmod x)\\<^sup>2) *\n                       (1 - (cmod z')\\<^sup>2)) =\n                      (cmod x < 1 \\<and>\n                       (z' - x) * (cnj z' - cnj x) =\n                       cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x))", "apply (subst cmod_square)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_real ((z' - x) * (cnj z' - cnj x));\n     is_real (cor (R * (1 - Re (z' * cnj z'))) * (1 - x * cnj x))\\<rbrakk>\n    \\<Longrightarrow> (cmod x < 1 \\<and>\n                       Re ((z' - x) * cnj (z' - x)) =\n                       R * (1 - Re (x * cnj x)) * (1 - Re (z' * cnj z'))) =\n                      (cmod x < 1 \\<and>\n                       (z' - x) * (cnj z' - cnj x) =\n                       cor (R * (1 - Re (z' * cnj z'))) * (1 - x * cnj x))", "apply (subst complex_eq_if_Re_eq, simp_all add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cmod (z' - x))\\<^sup>2 =\n   (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)) =\n  (cmod x < 1 \\<and>\n   (z' - x) * (cnj z' - cnj x) =\n   cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cmod (z' - x))\\<^sup>2 =\n   (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)) =\n  (cmod x < 1 \\<and>\n   (z' - x) * (cnj z' - cnj x) =\n   cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x))\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cmod (z' - x))\\<^sup>2 =\n   (cosh r - 1) / 2 * (1 - (cmod x)\\<^sup>2) * (1 - (cmod z')\\<^sup>2)) =\n  (cmod x < 1 \\<and>\n   (z' - x) * (cnj z' - cnj x) =\n   cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x))\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> z' * cnj z' - x * cnj z' - cnj x * z' + x * cnj x = R * ?cz - R * ?cz * x * cnj x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (z' - x) * (cnj z' - cnj x) =\n     cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x)) =\n    (cmod x < 1 \\<and>\n     z' * cnj z' - x * cnj z' - cnj x * z' + x * cnj x =\n     cor (R * (1 - (cmod z')\\<^sup>2)) -\n     cor (R * (1 - (cmod z')\\<^sup>2)) * x * cnj x)", "unfolding right_diff_distrib left_diff_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     z' * cnj z' - x * cnj z' - (z' * cnj x - x * cnj x) =\n     cor (R * 1 - R * (cmod z')\\<^sup>2) * 1 -\n     cor (R * 1 - R * (cmod z')\\<^sup>2) * (x * cnj x)) =\n    (cmod x < 1 \\<and>\n     z' * cnj z' - x * cnj z' - cnj x * z' + x * cnj x =\n     cor (R * 1 - R * (cmod z')\\<^sup>2) -\n     cor (R * 1 - R * (cmod z')\\<^sup>2) * x * cnj x)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (z' - x) * (cnj z' - cnj x) =\n   cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x)) =\n  (cmod x < 1 \\<and>\n   z' * cnj z' - x * cnj z' - cnj x * z' + x * cnj x =\n   cor (R * (1 - (cmod z')\\<^sup>2)) -\n   cor (R * (1 - (cmod z')\\<^sup>2)) * x * cnj x)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (z' - x) * (cnj z' - cnj x) =\n   cor (R * (1 - (cmod z')\\<^sup>2)) * (1 - x * cnj x)) =\n  (cmod x < 1 \\<and>\n   z' * cnj z' - x * cnj z' - cnj x * z' + x * cnj x =\n   cor (R * (1 - (cmod z')\\<^sup>2)) -\n   cor (R * (1 - (cmod z')\\<^sup>2)) * x * cnj x)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> k * (x * cnj x) - x * cnj z' - cnj x * z' + z' * cnj z' = R * ?cz\" (is \"_ \\<longleftrightarrow> _ \\<and> ?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     z' * cnj z' - x * cnj z' - cnj x * z' + x * cnj x =\n     cor (R * (1 - (cmod z')\\<^sup>2)) -\n     cor (R * (1 - (cmod z')\\<^sup>2)) * x * cnj x) =\n    (cmod x < 1 \\<and>\n     cor k * (x * cnj x) - x * cnj z' - cnj x * z' + z' * cnj z' =\n     cor (R * (1 - (cmod z')\\<^sup>2)))", "by (subst k) (auto simp add: field_simps)"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   z' * cnj z' - x * cnj z' - cnj x * z' + x * cnj x =\n   cor (R * (1 - (cmod z')\\<^sup>2)) -\n   cor (R * (1 - (cmod z')\\<^sup>2)) * x * cnj x) =\n  (cmod x < 1 \\<and>\n   cor k * (x * cnj x) - x * cnj z' - cnj x * z' + z' * cnj z' =\n   cor (R * (1 - (cmod z')\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   z' * cnj z' - x * cnj z' - cnj x * z' + x * cnj x =\n   cor (R * (1 - (cmod z')\\<^sup>2)) -\n   cor (R * (1 - (cmod z')\\<^sup>2)) * x * cnj x) =\n  (cmod x < 1 \\<and>\n   cor k * (x * cnj x) - x * cnj z' - cnj x * z' + z' * cnj z' =\n   cor (R * (1 - (cmod z')\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> (k * x * cnj x - x * cnj z' - cnj x * z' + z' * cnj z') / k = (R * ?cz) / k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     cor k * (x * cnj x) - x * cnj z' - cnj x * z' + z' * cnj z' =\n     cor (R * (1 - (cmod z')\\<^sup>2))) =\n    (cmod x < 1 \\<and>\n     (cor k * x * cnj x - x * cnj z' - cnj x * z' + z' * cnj z') / cor k =\n     cor (R * (1 - (cmod z')\\<^sup>2) / k))", "using **"], ["proof (prove)\nusing this:\n  cor k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     cor k * (x * cnj x) - x * cnj z' - cnj x * z' + z' * cnj z' =\n     cor (R * (1 - (cmod z')\\<^sup>2))) =\n    (cmod x < 1 \\<and>\n     (cor k * x * cnj x - x * cnj z' - cnj x * z' + z' * cnj z') / cor k =\n     cor (R * (1 - (cmod z')\\<^sup>2) / k))", "by (auto simp add: Groups.mult_ac(1))"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   cor k * (x * cnj x) - x * cnj z' - cnj x * z' + z' * cnj z' =\n   cor (R * (1 - (cmod z')\\<^sup>2))) =\n  (cmod x < 1 \\<and>\n   (cor k * x * cnj x - x * cnj z' - cnj x * z' + z' * cnj z') / cor k =\n   cor (R * (1 - (cmod z')\\<^sup>2) / k))\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   cor k * (x * cnj x) - x * cnj z' - cnj x * z' + z' * cnj z' =\n   cor (R * (1 - (cmod z')\\<^sup>2))) =\n  (cmod x < 1 \\<and>\n   (cor k * x * cnj x - x * cnj z' - cnj x * z' + z' * cnj z') / cor k =\n   cor (R * (1 - (cmod z')\\<^sup>2) / k))\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> x * cnj x - x * cnj z' / k - cnj x * z' / k + z' * cnj z' / k = (R * ?cz) / k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cor k * x * cnj x - x * cnj z' - cnj x * z' + z' * cnj z') / cor k =\n     cor (R * (1 - (cmod z')\\<^sup>2) / k)) =\n    (cmod x < 1 \\<and>\n     x * cnj x - x * cnj z' / cor k - cnj x * z' / cor k +\n     z' * cnj z' / cor k =\n     cor (R * (1 - (cmod z')\\<^sup>2) / k))", "using **"], ["proof (prove)\nusing this:\n  cor k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cor k * x * cnj x - x * cnj z' - cnj x * z' + z' * cnj z') / cor k =\n     cor (R * (1 - (cmod z')\\<^sup>2) / k)) =\n    (cmod x < 1 \\<and>\n     x * cnj x - x * cnj z' / cor k - cnj x * z' / cor k +\n     z' * cnj z' / cor k =\n     cor (R * (1 - (cmod z')\\<^sup>2) / k))", "unfolding add_divide_distrib diff_divide_distrib"], ["proof (prove)\nusing this:\n  cor k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     cor k * x * cnj x / cor k - x * cnj z' / cor k - cnj x * z' / cor k +\n     z' * cnj z' / cor k =\n     cor (R * (1 - (cmod z')\\<^sup>2) / k)) =\n    (cmod x < 1 \\<and>\n     x * cnj x - x * cnj z' / cor k - cnj x * z' / cor k +\n     z' * cnj z' / cor k =\n     cor (R * (1 - (cmod z')\\<^sup>2) / k))", "by auto"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cor k * x * cnj x - x * cnj z' - cnj x * z' + z' * cnj z') / cor k =\n   cor (R * (1 - (cmod z')\\<^sup>2) / k)) =\n  (cmod x < 1 \\<and>\n   x * cnj x - x * cnj z' / cor k - cnj x * z' / cor k +\n   z' * cnj z' / cor k =\n   cor (R * (1 - (cmod z')\\<^sup>2) / k))\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cor k * x * cnj x - x * cnj z' - cnj x * z' + z' * cnj z') / cor k =\n   cor (R * (1 - (cmod z')\\<^sup>2) / k)) =\n  (cmod x < 1 \\<and>\n   x * cnj x - x * cnj z' / cor k - cnj x * z' / cor k +\n   z' * cnj z' / cor k =\n   cor (R * (1 - (cmod z')\\<^sup>2) / k))\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> (x - z'/k) * cnj(x - z'/k) = (R * ?cz) / k + (z' / k) * cnj(z' / k) - z' * cnj z' / k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     x * cnj x - x * cnj z' / cor k - cnj x * z' / cor k +\n     z' * cnj z' / cor k =\n     cor (R * (1 - (cmod z')\\<^sup>2) / k)) =\n    (cmod x < 1 \\<and>\n     (x - z' / cor k) * cnj (x - z' / cor k) =\n     cor (R * (1 - (cmod z')\\<^sup>2) / k) + z' / cor k * cnj (z' / cor k) -\n     z' * cnj z' / cor k)", "by (auto simp add: field_simps diff_divide_distrib)"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   x * cnj x - x * cnj z' / cor k - cnj x * z' / cor k +\n   z' * cnj z' / cor k =\n   cor (R * (1 - (cmod z')\\<^sup>2) / k)) =\n  (cmod x < 1 \\<and>\n   (x - z' / cor k) * cnj (x - z' / cor k) =\n   cor (R * (1 - (cmod z')\\<^sup>2) / k) + z' / cor k * cnj (z' / cor k) -\n   z' * cnj z' / cor k)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   x * cnj x - x * cnj z' / cor k - cnj x * z' / cor k +\n   z' * cnj z' / cor k =\n   cor (R * (1 - (cmod z')\\<^sup>2) / k)) =\n  (cmod x < 1 \\<and>\n   (x - z' / cor k) * cnj (x - z' / cor k) =\n   cor (R * (1 - (cmod z')\\<^sup>2) / k) + z' / cor k * cnj (z' / cor k) -\n   z' * cnj z' / cor k)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> (cmod (x - z'/k))\\<^sup>2 = (R * ?cz) / k + (cmod z')\\<^sup>2 / k\\<^sup>2 - (cmod z')\\<^sup>2 / k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (x - z' / cor k) * cnj (x - z' / cor k) =\n     cor (R * (1 - (cmod z')\\<^sup>2) / k) + z' / cor k * cnj (z' / cor k) -\n     z' * cnj z' / cor k) =\n    (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     R * (1 - (cmod z')\\<^sup>2) / k + (cmod z')\\<^sup>2 / k\\<^sup>2 -\n     (cmod z')\\<^sup>2 / k)", "apply (subst complex_mult_cnj_cmod)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     cor ((cmod (x - z' / cor k))\\<^sup>2) =\n     cor (R * (1 - (cmod z')\\<^sup>2) / k) +\n     cor ((cmod (z' / cor k))\\<^sup>2) -\n     cor ((cmod z')\\<^sup>2) / cor k) =\n    (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     R * (1 - (cmod z')\\<^sup>2) / k + (cmod z')\\<^sup>2 / k\\<^sup>2 -\n     (cmod z')\\<^sup>2 / k)", "apply (subst complex_eq_if_Re_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_real (cor ((cmod (x - z' / cor k))\\<^sup>2))\n 2. is_real\n     (cor (R * (1 - (cmod z')\\<^sup>2) / k) +\n      cor ((cmod (z' / cor k))\\<^sup>2) -\n      cor ((cmod z')\\<^sup>2) / cor k)\n 3. (cmod x < 1 \\<and>\n     Re (cor ((cmod (x - z' / cor k))\\<^sup>2)) =\n     Re (cor (R * (1 - (cmod z')\\<^sup>2) / k) +\n         cor ((cmod (z' / cor k))\\<^sup>2) -\n         cor ((cmod z')\\<^sup>2) / cor k)) =\n    (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     R * (1 - (cmod z')\\<^sup>2) / k + (cmod z')\\<^sup>2 / k\\<^sup>2 -\n     (cmod z')\\<^sup>2 / k)", "apply (simp_all add: power_divide)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (x - z' / cor k) * cnj (x - z' / cor k) =\n   cor (R * (1 - (cmod z')\\<^sup>2) / k) + z' / cor k * cnj (z' / cor k) -\n   z' * cnj z' / cor k) =\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   R * (1 - (cmod z')\\<^sup>2) / k + (cmod z')\\<^sup>2 / k\\<^sup>2 -\n   (cmod z')\\<^sup>2 / k)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (x - z' / cor k) * cnj (x - z' / cor k) =\n   cor (R * (1 - (cmod z')\\<^sup>2) / k) + z' / cor k * cnj (z' / cor k) -\n   z' * cnj z' / cor k) =\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   R * (1 - (cmod z')\\<^sup>2) / k + (cmod z')\\<^sup>2 / k\\<^sup>2 -\n   (cmod z')\\<^sup>2 / k)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> (cmod (x - z'/k))\\<^sup>2 = (R * ?cz * k + (cmod z')\\<^sup>2 - (cmod z')\\<^sup>2 * k) / k\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     R * (1 - (cmod z')\\<^sup>2) / k + (cmod z')\\<^sup>2 / k\\<^sup>2 -\n     (cmod z')\\<^sup>2 / k) =\n    (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n      (cmod z')\\<^sup>2 * k) /\n     k\\<^sup>2)", "using **"], ["proof (prove)\nusing this:\n  cor k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     R * (1 - (cmod z')\\<^sup>2) / k + (cmod z')\\<^sup>2 / k\\<^sup>2 -\n     (cmod z')\\<^sup>2 / k) =\n    (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n      (cmod z')\\<^sup>2 * k) /\n     k\\<^sup>2)", "unfolding add_divide_distrib diff_divide_distrib"], ["proof (prove)\nusing this:\n  cor k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     R * (1 - (cmod z')\\<^sup>2) / k + (cmod z')\\<^sup>2 / k\\<^sup>2 -\n     (cmod z')\\<^sup>2 / k) =\n    (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     R * (1 - (cmod z')\\<^sup>2) * k / k\\<^sup>2 +\n     (cmod z')\\<^sup>2 / k\\<^sup>2 -\n     (cmod z')\\<^sup>2 * k / k\\<^sup>2)", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   R * (1 - (cmod z')\\<^sup>2) / k + (cmod z')\\<^sup>2 / k\\<^sup>2 -\n   (cmod z')\\<^sup>2 / k) =\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   (R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n    (cmod z')\\<^sup>2 * k) /\n   k\\<^sup>2)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   R * (1 - (cmod z')\\<^sup>2) / k + (cmod z')\\<^sup>2 / k\\<^sup>2 -\n   (cmod z')\\<^sup>2 / k) =\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   (R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n    (cmod z')\\<^sup>2 * k) /\n   k\\<^sup>2)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> (cmod (x - z'/k))\\<^sup>2 = ?cz\\<^sup>2 * R * (R + 1) / k\\<^sup>2\" (is \"_ \\<longleftrightarrow> _ \\<and> ?a\\<^sup>2 = ?b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n      (cmod z')\\<^sup>2 * k) /\n     k\\<^sup>2) =\n    (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) / k\\<^sup>2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n      (cmod z')\\<^sup>2 * k) /\n     k\\<^sup>2) =\n    (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) / k\\<^sup>2)", "have *: \"R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 - (cmod z')\\<^sup>2 * k = (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n    (cmod z')\\<^sup>2 * k =\n    (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1)", "by (subst k)+ (simp add: field_simps power2_diff)"], ["proof (state)\nthis:\n  R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n  (cmod z')\\<^sup>2 * k =\n  (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1)\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n      (cmod z')\\<^sup>2 * k) /\n     k\\<^sup>2) =\n    (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) / k\\<^sup>2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n  (cmod z')\\<^sup>2 * k =\n  (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1)\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n      (cmod z')\\<^sup>2 * k) /\n     k\\<^sup>2) =\n    (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) / k\\<^sup>2)", "by (subst *, simp)"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   (R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n    (cmod z')\\<^sup>2 * k) /\n   k\\<^sup>2) =\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) / k\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   (R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n    (cmod z')\\<^sup>2 * k) /\n   k\\<^sup>2) =\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) / k\\<^sup>2)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "also"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   (R * (1 - (cmod z')\\<^sup>2) * k + (cmod z')\\<^sup>2 -\n    (cmod z')\\<^sup>2 * k) /\n   k\\<^sup>2) =\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) / k\\<^sup>2)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "have \"... \\<longleftrightarrow> cmod x < 1 \\<and> cmod (x - z'/k) = ?cz * sqrt (R * (R + 1)) / k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) / k\\<^sup>2) =\n    (cmod x < 1 \\<and>\n     cmod (x - z' / cor k) =\n     (1 - (cmod z')\\<^sup>2) * sqrt (R * (R + 1)) / k)", "using \\<open>R > 0\\<close> *[of z'] ** \\<open>k > 1\\<close> \\<open>z \\<in> unit_disc\\<close> z'"], ["proof (prove)\nusing this:\n  0 < R\n  cmod z' < 1 \\<Longrightarrow> 0 < 1 - (cmod z')\\<^sup>2\n  cor k \\<noteq> 0\n  1 < k\n  z \\<in> unit_disc\n  z = of_complex z'\n  cmod z' < 1\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) / k\\<^sup>2) =\n    (cmod x < 1 \\<and>\n     cmod (x - z' / cor k) =\n     (1 - (cmod z')\\<^sup>2) * sqrt (R * (R + 1)) / k)", "using real_sqrt_unique[of ?a ?b, symmetric]"], ["proof (prove)\nusing this:\n  0 < R\n  cmod z' < 1 \\<Longrightarrow> 0 < 1 - (cmod z')\\<^sup>2\n  cor k \\<noteq> 0\n  1 < k\n  z \\<in> unit_disc\n  z = of_complex z'\n  cmod z' < 1\n  \\<lbrakk>(cmod (x - z' / cor k))\\<^sup>2 =\n           (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) / k\\<^sup>2;\n   0 \\<le> cmod (x - z' / cor k)\\<rbrakk>\n  \\<Longrightarrow> cmod (x - z' / cor k) =\n                    sqrt\n                     ((1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) /\n                      k\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (cmod x < 1 \\<and>\n     (cmod (x - z' / cor k))\\<^sup>2 =\n     (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) / k\\<^sup>2) =\n    (cmod x < 1 \\<and>\n     cmod (x - z' / cor k) =\n     (1 - (cmod z')\\<^sup>2) * sqrt (R * (R + 1)) / k)", "by (auto simp add: real_sqrt_divide real_sqrt_mult power_divide power_mult_distrib)"], ["proof (state)\nthis:\n  (cmod x < 1 \\<and>\n   (cmod (x - z' / cor k))\\<^sup>2 =\n   (1 - (cmod z')\\<^sup>2)\\<^sup>2 * R * (R + 1) / k\\<^sup>2) =\n  (cmod x < 1 \\<and>\n   cmod (x - z' / cor k) = (1 - (cmod z')\\<^sup>2) * sqrt (R * (R + 1)) / k)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "finally"], ["proof (chain)\npicking this:\n  (of_complex x \\<in> poincare_circle z r) =\n  (cmod x < 1 \\<and>\n   cmod (x - z' / cor k) = (1 - (cmod z')\\<^sup>2) * sqrt (R * (R + 1)) / k)", "have \"of_complex x \\<in> poincare_circle z r \\<longleftrightarrow> cmod x < 1 \\<and> x \\<in> circle (z'/k) (?cz * sqrt(R * (R+1)) / k)\""], ["proof (prove)\nusing this:\n  (of_complex x \\<in> poincare_circle z r) =\n  (cmod x < 1 \\<and>\n   cmod (x - z' / cor k) = (1 - (cmod z')\\<^sup>2) * sqrt (R * (R + 1)) / k)\n\ngoal (1 subgoal):\n 1. (of_complex x \\<in> poincare_circle z r) =\n    (cmod x < 1 \\<and>\n     x \\<in> circle (z' / cor k)\n              ((1 - (cmod z')\\<^sup>2) * sqrt (R * (R + 1)) / k))", "unfolding circle_def z' k R"], ["proof (prove)\nusing this:\n  (of_complex x \\<in> poincare_circle (of_complex z') r) =\n  (cmod x < 1 \\<and>\n   cmod (x - z' / cor (1 + (cosh r - 1) / 2 * (1 - (cmod z')\\<^sup>2))) =\n   (1 - (cmod z')\\<^sup>2) *\n   sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n   (1 + (cosh r - 1) / 2 * (1 - (cmod z')\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. (of_complex x \\<in> poincare_circle (of_complex z') r) =\n    (cmod x < 1 \\<and>\n     x \\<in> {z. cmod\n                  (z -\n                   z' /\n                   cor (1 + (cosh r - 1) / 2 * (1 - (cmod z')\\<^sup>2))) =\n                 (1 - (cmod z')\\<^sup>2) *\n                 sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n                 (1 + (cosh r - 1) / 2 * (1 - (cmod z')\\<^sup>2))})", "by simp"], ["proof (state)\nthis:\n  (of_complex x \\<in> poincare_circle z r) =\n  (cmod x < 1 \\<and>\n   x \\<in> circle (z' / cor k)\n            ((1 - (cmod z')\\<^sup>2) * sqrt (R * (R + 1)) / k))\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "hence \"of_complex x \\<in> poincare_circle z r \\<longleftrightarrow> (let (Ze, Re) = poincare_circle_euclidean z r in cmod x < 1 \\<and> x \\<in> circle Ze Re)\""], ["proof (prove)\nusing this:\n  (of_complex x \\<in> poincare_circle z r) =\n  (cmod x < 1 \\<and>\n   x \\<in> circle (z' / cor k)\n            ((1 - (cmod z')\\<^sup>2) * sqrt (R * (R + 1)) / k))\n\ngoal (1 subgoal):\n 1. (of_complex x \\<in> poincare_circle z r) =\n    (let (Ze, Re) = poincare_circle_euclidean z r\n     in cmod x < 1 \\<and> x \\<in> circle Ze Re)", "unfolding poincare_circle_euclidean_def Let_def circle_def"], ["proof (prove)\nusing this:\n  (of_complex x \\<in> poincare_circle z r) =\n  (cmod x < 1 \\<and>\n   x \\<in> {z. cmod (z - z' / cor k) =\n               (1 - (cmod z')\\<^sup>2) * sqrt (R * (R + 1)) / k})\n\ngoal (1 subgoal):\n 1. (of_complex x \\<in> poincare_circle z r) =\n    (case (to_complex z /\n           cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) +\n                1),\n           (1 - (cmod (to_complex z))\\<^sup>2) *\n           sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n           ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) +\n            1)) of\n     (Ze, Re) \\<Rightarrow>\n       cmod x < 1 \\<and> x \\<in> {z. cmod (z - Ze) = Re})", "using z' R k"], ["proof (prove)\nusing this:\n  (of_complex x \\<in> poincare_circle z r) =\n  (cmod x < 1 \\<and>\n   x \\<in> {z. cmod (z - z' / cor k) =\n               (1 - (cmod z')\\<^sup>2) * sqrt (R * (R + 1)) / k})\n  z = of_complex z'\n  cmod z' < 1\n  R = (cosh r - 1) / 2\n  k = 1 + R * (1 - (cmod z')\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (of_complex x \\<in> poincare_circle z r) =\n    (case (to_complex z /\n           cor ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) +\n                1),\n           (1 - (cmod (to_complex z))\\<^sup>2) *\n           sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n           ((1 - (cmod (to_complex z))\\<^sup>2) * ((cosh r - 1) / 2) +\n            1)) of\n     (Ze, Re) \\<Rightarrow>\n       cmod x < 1 \\<and> x \\<in> {z. cmod (z - Ze) = Re})", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (of_complex x \\<in> poincare_circle z r) =\n  (let (Ze, Re) = poincare_circle_euclidean z r\n   in cmod x < 1 \\<and> x \\<in> circle Ze Re)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "hence \"of_complex x \\<in> poincare_circle z r \\<longleftrightarrow> (let (Ze, Re) = poincare_circle_euclidean z r in x \\<in> circle Ze Re)\""], ["proof (prove)\nusing this:\n  (of_complex x \\<in> poincare_circle z r) =\n  (let (Ze, Re) = poincare_circle_euclidean z r\n   in cmod x < 1 \\<and> x \\<in> circle Ze Re)\n\ngoal (1 subgoal):\n 1. (of_complex x \\<in> poincare_circle z r) =\n    (let (Ze, Re) = poincare_circle_euclidean z r in x \\<in> circle Ze Re)", "using poincare_circle_in_disc[OF \\<open>r > 0\\<close> \\<open>z \\<in> unit_disc\\<close>]"], ["proof (prove)\nusing this:\n  (of_complex x \\<in> poincare_circle z r) =\n  (let (Ze, Re) = poincare_circle_euclidean z r\n   in cmod x < 1 \\<and> x \\<in> circle Ze Re)\n  (?ze, ?re) = poincare_circle_euclidean z r \\<Longrightarrow> cmod ?ze < 1\n  (?ze, ?re) = poincare_circle_euclidean z r \\<Longrightarrow> 0 < ?re\n  (?ze, ?re) = poincare_circle_euclidean z r \\<Longrightarrow>\n  \\<forall>x\\<in>circle ?ze ?re. cmod x < 1\n\ngoal (1 subgoal):\n 1. (of_complex x \\<in> poincare_circle z r) =\n    (let (Ze, Re) = poincare_circle_euclidean z r in x \\<in> circle Ze Re)", "by auto"], ["proof (state)\nthis:\n  (of_complex x \\<in> poincare_circle z r) =\n  (let (Ze, Re) = poincare_circle_euclidean z r in x \\<in> circle Ze Re)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "}"], ["proof (state)\nthis:\n  (of_complex ?x2 \\<in> poincare_circle z r) =\n  (let (Ze, Re) = poincare_circle_euclidean z r in ?x2 \\<in> circle Ze Re)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "note * = this"], ["proof (state)\nthis:\n  (of_complex ?x2 \\<in> poincare_circle z r) =\n  (let (Ze, Re) = poincare_circle_euclidean z r in ?x2 \\<in> circle Ze Re)\n\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. let (Ze, Re) = poincare_circle_euclidean z r\n    in of_complex ` circle Ze Re = poincare_circle z r", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case poincare_circle_euclidean z r of\n    (Ze, Re) \\<Rightarrow> of_complex ` circle Ze Re = poincare_circle z r", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ze Re x xa.\n       \\<lbrakk>poincare_circle_euclidean z r = (Ze, Re);\n        xa \\<in> circle Ze Re\\<rbrakk>\n       \\<Longrightarrow> of_complex xa \\<in> poincare_circle z r\n 2. \\<And>Ze Re x.\n       \\<lbrakk>poincare_circle_euclidean z r = (Ze, Re);\n        x \\<in> poincare_circle z r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> of_complex ` circle Ze Re", "fix Ze Re x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ze Re x xa.\n       \\<lbrakk>poincare_circle_euclidean z r = (Ze, Re);\n        xa \\<in> circle Ze Re\\<rbrakk>\n       \\<Longrightarrow> of_complex xa \\<in> poincare_circle z r\n 2. \\<And>Ze Re x.\n       \\<lbrakk>poincare_circle_euclidean z r = (Ze, Re);\n        x \\<in> poincare_circle z r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> of_complex ` circle Ze Re", "assume \"poincare_circle_euclidean z r = (Ze, Re)\" \"x \\<in> circle Ze Re\""], ["proof (state)\nthis:\n  poincare_circle_euclidean z r = (Ze, Re)\n  x \\<in> circle Ze Re\n\ngoal (2 subgoals):\n 1. \\<And>Ze Re x xa.\n       \\<lbrakk>poincare_circle_euclidean z r = (Ze, Re);\n        xa \\<in> circle Ze Re\\<rbrakk>\n       \\<Longrightarrow> of_complex xa \\<in> poincare_circle z r\n 2. \\<And>Ze Re x.\n       \\<lbrakk>poincare_circle_euclidean z r = (Ze, Re);\n        x \\<in> poincare_circle z r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> of_complex ` circle Ze Re", "thus \"of_complex x \\<in> poincare_circle z r\""], ["proof (prove)\nusing this:\n  poincare_circle_euclidean z r = (Ze, Re)\n  x \\<in> circle Ze Re\n\ngoal (1 subgoal):\n 1. of_complex x \\<in> poincare_circle z r", "using *[of x]"], ["proof (prove)\nusing this:\n  poincare_circle_euclidean z r = (Ze, Re)\n  x \\<in> circle Ze Re\n  (of_complex x \\<in> poincare_circle z r) =\n  (let (Ze, Re) = poincare_circle_euclidean z r in x \\<in> circle Ze Re)\n\ngoal (1 subgoal):\n 1. of_complex x \\<in> poincare_circle z r", "by simp"], ["proof (state)\nthis:\n  of_complex x \\<in> poincare_circle z r\n\ngoal (1 subgoal):\n 1. \\<And>Ze Re x.\n       \\<lbrakk>poincare_circle_euclidean z r = (Ze, Re);\n        x \\<in> poincare_circle z r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> of_complex ` circle Ze Re", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ze Re x.\n       \\<lbrakk>poincare_circle_euclidean z r = (Ze, Re);\n        x \\<in> poincare_circle z r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> of_complex ` circle Ze Re", "fix Ze Re x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ze Re x.\n       \\<lbrakk>poincare_circle_euclidean z r = (Ze, Re);\n        x \\<in> poincare_circle z r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> of_complex ` circle Ze Re", "assume **: \"poincare_circle_euclidean z r = (Ze, Re)\" \"x \\<in> poincare_circle z r\""], ["proof (state)\nthis:\n  poincare_circle_euclidean z r = (Ze, Re)\n  x \\<in> poincare_circle z r\n\ngoal (1 subgoal):\n 1. \\<And>Ze Re x.\n       \\<lbrakk>poincare_circle_euclidean z r = (Ze, Re);\n        x \\<in> poincare_circle z r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> of_complex ` circle Ze Re", "then"], ["proof (chain)\npicking this:\n  poincare_circle_euclidean z r = (Ze, Re)\n  x \\<in> poincare_circle z r", "obtain x' where x': \"x = of_complex x'\""], ["proof (prove)\nusing this:\n  poincare_circle_euclidean z r = (Ze, Re)\n  x \\<in> poincare_circle z r\n\ngoal (1 subgoal):\n 1. (\\<And>x'. x = of_complex x' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding poincare_circle_def"], ["proof (prove)\nusing this:\n  poincare_circle_euclidean z r = (Ze, Re)\n  x \\<in> {z' \\<in> unit_disc. poincare_distance z z' = r}\n\ngoal (1 subgoal):\n 1. (\\<And>x'. x = of_complex x' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inf_or_of_complex[of x]"], ["proof (prove)\nusing this:\n  poincare_circle_euclidean z r = (Ze, Re)\n  x \\<in> {z' \\<in> unit_disc. poincare_distance z z' = r}\n  x = \\<infinity>\\<^sub>h \\<or> (\\<exists>xa. x = of_complex xa)\n\ngoal (1 subgoal):\n 1. (\\<And>x'. x = of_complex x' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = of_complex x'\n\ngoal (1 subgoal):\n 1. \\<And>Ze Re x.\n       \\<lbrakk>poincare_circle_euclidean z r = (Ze, Re);\n        x \\<in> poincare_circle z r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> of_complex ` circle Ze Re", "hence \"x' \\<in> circle Ze Re\""], ["proof (prove)\nusing this:\n  x = of_complex x'\n\ngoal (1 subgoal):\n 1. x' \\<in> circle Ze Re", "using *[of x'] **"], ["proof (prove)\nusing this:\n  x = of_complex x'\n  (of_complex x' \\<in> poincare_circle z r) =\n  (let (Ze, Re) = poincare_circle_euclidean z r in x' \\<in> circle Ze Re)\n  poincare_circle_euclidean z r = (Ze, Re)\n  x \\<in> poincare_circle z r\n\ngoal (1 subgoal):\n 1. x' \\<in> circle Ze Re", "by simp"], ["proof (state)\nthis:\n  x' \\<in> circle Ze Re\n\ngoal (1 subgoal):\n 1. \\<And>Ze Re x.\n       \\<lbrakk>poincare_circle_euclidean z r = (Ze, Re);\n        x \\<in> poincare_circle z r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> of_complex ` circle Ze Re", "thus \"x \\<in> of_complex ` circle Ze Re\""], ["proof (prove)\nusing this:\n  x' \\<in> circle Ze Re\n\ngoal (1 subgoal):\n 1. x \\<in> of_complex ` circle Ze Re", "using x'"], ["proof (prove)\nusing this:\n  x' \\<in> circle Ze Re\n  x = of_complex x'\n\ngoal (1 subgoal):\n 1. x \\<in> of_complex ` circle Ze Re", "by auto"], ["proof (state)\nthis:\n  x \\<in> of_complex ` circle Ze Re\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  let (Ze, Re) = poincare_circle_euclidean z r\n  in of_complex ` circle Ze Re = poincare_circle z r\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Intersection of circles in special positions\\<close>"], ["", "text \\<open>Two h-circles centered at the x-axis intersect at mutually conjugate points\\<close>"], ["", "lemma intersect_poincare_circles_x_axis:\n  assumes z: \"is_real z1\" and \"is_real z2\" and \"r1 > 0\" and \"r2 > 0\" and\n             \"-1 < Re z1\" and \"Re z1 < 1\" and \"-1 < Re z2\" and \"Re z2 < 1\" and\n             \"z1 \\<noteq> z2\"\n  assumes x1: \"x1 \\<in> poincare_circle (of_complex z1) r1 \\<inter> poincare_circle (of_complex z2) r2\" and\n          x2: \"x2 \\<in> poincare_circle (of_complex z1) r1 \\<inter> poincare_circle (of_complex z2) r2\" and\n              \"x1 \\<noteq> x2\"\n  shows \"x1 = conjugate x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "have in_disc: \"of_complex z1 \\<in> unit_disc\" \"of_complex z2 \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex z1 \\<in> unit_disc &&& of_complex z2 \\<in> unit_disc", "using assms"], ["proof (prove)\nusing this:\n  is_real z1\n  is_real z2\n  0 < r1\n  0 < r2\n  - 1 < Re z1\n  Re z1 < 1\n  - 1 < Re z2\n  Re z2 < 1\n  z1 \\<noteq> z2\n  x1 \\<in> poincare_circle (of_complex z1) r1 \\<inter>\n           poincare_circle (of_complex z2) r2\n  x2 \\<in> poincare_circle (of_complex z1) r1 \\<inter>\n           poincare_circle (of_complex z2) r2\n  x1 \\<noteq> x2\n\ngoal (1 subgoal):\n 1. of_complex z1 \\<in> unit_disc &&& of_complex z2 \\<in> unit_disc", "by (auto simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  of_complex z1 \\<in> unit_disc\n  of_complex z2 \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "obtain x1' x2' where x': \"x1 = of_complex x1'\" \"x2 = of_complex x2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1' x2'.\n        \\<lbrakk>x1 = of_complex x1'; x2 = of_complex x2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using x1 x2"], ["proof (prove)\nusing this:\n  x1 \\<in> poincare_circle (of_complex z1) r1 \\<inter>\n           poincare_circle (of_complex z2) r2\n  x2 \\<in> poincare_circle (of_complex z1) r1 \\<inter>\n           poincare_circle (of_complex z2) r2\n\ngoal (1 subgoal):\n 1. (\\<And>x1' x2'.\n        \\<lbrakk>x1 = of_complex x1'; x2 = of_complex x2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inf_or_of_complex[of x1] inf_or_of_complex[of x2]"], ["proof (prove)\nusing this:\n  x1 \\<in> poincare_circle (of_complex z1) r1 \\<inter>\n           poincare_circle (of_complex z2) r2\n  x2 \\<in> poincare_circle (of_complex z1) r1 \\<inter>\n           poincare_circle (of_complex z2) r2\n  x1 = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. x1 = of_complex x)\n  x2 = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. x2 = of_complex x)\n\ngoal (1 subgoal):\n 1. (\\<And>x1' x2'.\n        \\<lbrakk>x1 = of_complex x1'; x2 = of_complex x2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding poincare_circle_def"], ["proof (prove)\nusing this:\n  x1 \\<in> {z' \\<in> unit_disc.\n            poincare_distance (of_complex z1) z' = r1} \\<inter>\n           {z' \\<in> unit_disc. poincare_distance (of_complex z2) z' = r2}\n  x2 \\<in> {z' \\<in> unit_disc.\n            poincare_distance (of_complex z1) z' = r1} \\<inter>\n           {z' \\<in> unit_disc. poincare_distance (of_complex z2) z' = r2}\n  x1 = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. x1 = of_complex x)\n  x2 = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. x2 = of_complex x)\n\ngoal (1 subgoal):\n 1. (\\<And>x1' x2'.\n        \\<lbrakk>x1 = of_complex x1'; x2 = of_complex x2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x1 = of_complex x1'\n  x2 = of_complex x2'\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "obtain Ze1 Re1 where 1: \"(Ze1, Re1) = poincare_circle_euclidean (of_complex z1) r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ze1 Re1.\n        (Ze1, Re1) =\n        poincare_circle_euclidean (of_complex z1) r1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis poincare_circle_euclidean_def)"], ["proof (state)\nthis:\n  (Ze1, Re1) = poincare_circle_euclidean (of_complex z1) r1\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "obtain Ze2 Re2 where 2: \"(Ze2, Re2) = poincare_circle_euclidean (of_complex z2) r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ze2 Re2.\n        (Ze2, Re2) =\n        poincare_circle_euclidean (of_complex z2) r2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis poincare_circle_euclidean_def)"], ["proof (state)\nthis:\n  (Ze2, Re2) = poincare_circle_euclidean (of_complex z2) r2\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "have circle: \"x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\"  \"x2' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2 &&&\n    x2' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2", "using poincare_circle_is_euclidean_circle[of \"of_complex z1\" r1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>of_complex z1 \\<in> unit_disc; 0 < r1\\<rbrakk>\n  \\<Longrightarrow> let (Ze, Re) =\n                          poincare_circle_euclidean (of_complex z1) r1\n                    in of_complex ` circle Ze Re =\n                       poincare_circle (of_complex z1) r1\n\ngoal (1 subgoal):\n 1. x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2 &&&\n    x2' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2", "using poincare_circle_is_euclidean_circle[of \"of_complex z2\" r2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>of_complex z1 \\<in> unit_disc; 0 < r1\\<rbrakk>\n  \\<Longrightarrow> let (Ze, Re) =\n                          poincare_circle_euclidean (of_complex z1) r1\n                    in of_complex ` circle Ze Re =\n                       poincare_circle (of_complex z1) r1\n  \\<lbrakk>of_complex z2 \\<in> unit_disc; 0 < r2\\<rbrakk>\n  \\<Longrightarrow> let (Ze, Re) =\n                          poincare_circle_euclidean (of_complex z2) r2\n                    in of_complex ` circle Ze Re =\n                       poincare_circle (of_complex z2) r2\n\ngoal (1 subgoal):\n 1. x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2 &&&\n    x2' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2", "using assms 1 2 \\<open>of_complex z1 \\<in> unit_disc\\<close> \\<open>of_complex z2 \\<in> unit_disc\\<close> x'"], ["proof (prove)\nusing this:\n  \\<lbrakk>of_complex z1 \\<in> unit_disc; 0 < r1\\<rbrakk>\n  \\<Longrightarrow> let (Ze, Re) =\n                          poincare_circle_euclidean (of_complex z1) r1\n                    in of_complex ` circle Ze Re =\n                       poincare_circle (of_complex z1) r1\n  \\<lbrakk>of_complex z2 \\<in> unit_disc; 0 < r2\\<rbrakk>\n  \\<Longrightarrow> let (Ze, Re) =\n                          poincare_circle_euclidean (of_complex z2) r2\n                    in of_complex ` circle Ze Re =\n                       poincare_circle (of_complex z2) r2\n  is_real z1\n  is_real z2\n  0 < r1\n  0 < r2\n  - 1 < Re z1\n  Re z1 < 1\n  - 1 < Re z2\n  Re z2 < 1\n  z1 \\<noteq> z2\n  x1 \\<in> poincare_circle (of_complex z1) r1 \\<inter>\n           poincare_circle (of_complex z2) r2\n  x2 \\<in> poincare_circle (of_complex z1) r1 \\<inter>\n           poincare_circle (of_complex z2) r2\n  x1 \\<noteq> x2\n  (Ze1, Re1) = poincare_circle_euclidean (of_complex z1) r1\n  (Ze2, Re2) = poincare_circle_euclidean (of_complex z2) r2\n  of_complex z1 \\<in> unit_disc\n  of_complex z2 \\<in> unit_disc\n  x1 = of_complex x1'\n  x2 = of_complex x2'\n\ngoal (1 subgoal):\n 1. x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2 &&&\n    x2' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2", "by auto (metis image_iff of_complex_inj)+"], ["proof (state)\nthis:\n  x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n  x2' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "have \"is_real Ze1\" \"is_real Ze2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real Ze1 &&& is_real Ze2", "using 1 2 \\<open>is_real z1\\<close> \\<open>is_real z2\\<close>"], ["proof (prove)\nusing this:\n  (Ze1, Re1) = poincare_circle_euclidean (of_complex z1) r1\n  (Ze2, Re2) = poincare_circle_euclidean (of_complex z2) r2\n  is_real z1\n  is_real z2\n\ngoal (1 subgoal):\n 1. is_real Ze1 &&& is_real Ze2", "by (simp_all add: poincare_circle_euclidean_def Let_def)"], ["proof (state)\nthis:\n  is_real Ze1\n  is_real Ze2\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "have \"Re1 > 0\" \"Re2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Re1 &&& 0 < Re2", "using 1 2 in_disc \\<open>r1 > 0\\<close> \\<open>r2 > 0\\<close>"], ["proof (prove)\nusing this:\n  (Ze1, Re1) = poincare_circle_euclidean (of_complex z1) r1\n  (Ze2, Re2) = poincare_circle_euclidean (of_complex z2) r2\n  of_complex z1 \\<in> unit_disc\n  of_complex z2 \\<in> unit_disc\n  0 < r1\n  0 < r2\n\ngoal (1 subgoal):\n 1. 0 < Re1 &&& 0 < Re2", "using poincare_circle_in_disc(2)[of r1 \"of_complex z1\" Ze1 Re1]"], ["proof (prove)\nusing this:\n  (Ze1, Re1) = poincare_circle_euclidean (of_complex z1) r1\n  (Ze2, Re2) = poincare_circle_euclidean (of_complex z2) r2\n  of_complex z1 \\<in> unit_disc\n  of_complex z2 \\<in> unit_disc\n  0 < r1\n  0 < r2\n  \\<lbrakk>0 < r1; of_complex z1 \\<in> unit_disc;\n   (Ze1, Re1) = poincare_circle_euclidean (of_complex z1) r1\\<rbrakk>\n  \\<Longrightarrow> 0 < Re1\n\ngoal (1 subgoal):\n 1. 0 < Re1 &&& 0 < Re2", "using poincare_circle_in_disc(2)[of r2 \"of_complex z2\" Ze2 Re2]"], ["proof (prove)\nusing this:\n  (Ze1, Re1) = poincare_circle_euclidean (of_complex z1) r1\n  (Ze2, Re2) = poincare_circle_euclidean (of_complex z2) r2\n  of_complex z1 \\<in> unit_disc\n  of_complex z2 \\<in> unit_disc\n  0 < r1\n  0 < r2\n  \\<lbrakk>0 < r1; of_complex z1 \\<in> unit_disc;\n   (Ze1, Re1) = poincare_circle_euclidean (of_complex z1) r1\\<rbrakk>\n  \\<Longrightarrow> 0 < Re1\n  \\<lbrakk>0 < r2; of_complex z2 \\<in> unit_disc;\n   (Ze2, Re2) = poincare_circle_euclidean (of_complex z2) r2\\<rbrakk>\n  \\<Longrightarrow> 0 < Re2\n\ngoal (1 subgoal):\n 1. 0 < Re1 &&& 0 < Re2", "by auto"], ["proof (state)\nthis:\n  0 < Re1\n  0 < Re2\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "have \"Ze1 \\<noteq> Ze2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ze1 \\<noteq> Ze2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Ze1 \\<noteq> Ze2 \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> Ze1 \\<noteq> Ze2\n\ngoal (1 subgoal):\n 1. \\<not> Ze1 \\<noteq> Ze2 \\<Longrightarrow> False", "hence eq: \"Ze1 = Ze2\" \"Re1 = Re2\""], ["proof (prove)\nusing this:\n  \\<not> Ze1 \\<noteq> Ze2\n\ngoal (1 subgoal):\n 1. Ze1 = Ze2 &&& Re1 = Re2", "using circle(1)"], ["proof (prove)\nusing this:\n  \\<not> Ze1 \\<noteq> Ze2\n  x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n\ngoal (1 subgoal):\n 1. Ze1 = Ze2 &&& Re1 = Re2", "unfolding circle_def"], ["proof (prove)\nusing this:\n  \\<not> Ze1 \\<noteq> Ze2\n  x1' \\<in> {z. cmod (z - Ze1) = Re1} \\<inter> {z. cmod (z - Ze2) = Re2}\n\ngoal (1 subgoal):\n 1. Ze1 = Ze2 &&& Re1 = Re2", "by auto"], ["proof (state)\nthis:\n  Ze1 = Ze2\n  Re1 = Re2\n\ngoal (1 subgoal):\n 1. \\<not> Ze1 \\<noteq> Ze2 \\<Longrightarrow> False", "let ?A = \"Ze1 - Re1\" and ?B = \"Ze1 + Re1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Ze1 \\<noteq> Ze2 \\<Longrightarrow> False", "have \"?A \\<in> circle Ze1 Re1\" \"?B \\<in> circle Ze1 Re1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ze1 - cor Re1 \\<in> circle Ze1 Re1 &&&\n    Ze1 + cor Re1 \\<in> circle Ze1 Re1", "using \\<open>Re1 > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < Re1\n\ngoal (1 subgoal):\n 1. Ze1 - cor Re1 \\<in> circle Ze1 Re1 &&&\n    Ze1 + cor Re1 \\<in> circle Ze1 Re1", "unfolding circle_def"], ["proof (prove)\nusing this:\n  0 < Re1\n\ngoal (1 subgoal):\n 1. Ze1 - cor Re1 \\<in> {z. cmod (z - Ze1) = Re1} &&&\n    Ze1 + cor Re1 \\<in> {z. cmod (z - Ze1) = Re1}", "by simp_all"], ["proof (state)\nthis:\n  Ze1 - cor Re1 \\<in> circle Ze1 Re1\n  Ze1 + cor Re1 \\<in> circle Ze1 Re1\n\ngoal (1 subgoal):\n 1. \\<not> Ze1 \\<noteq> Ze2 \\<Longrightarrow> False", "hence \"of_complex ?A \\<in> poincare_circle (of_complex z1) r1\" \"of_complex ?B \\<in> poincare_circle (of_complex z1) r1\"\n          \"of_complex ?A \\<in> poincare_circle (of_complex z2) r2\" \"of_complex ?B \\<in> poincare_circle (of_complex z2) r2\""], ["proof (prove)\nusing this:\n  Ze1 - cor Re1 \\<in> circle Ze1 Re1\n  Ze1 + cor Re1 \\<in> circle Ze1 Re1\n\ngoal (1 subgoal):\n 1. (of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z1) r1 &&&\n     of_complex (Ze1 + cor Re1)\n     \\<in> poincare_circle (of_complex z1) r1) &&&\n    of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z2) r2 &&&\n    of_complex (Ze1 + cor Re1) \\<in> poincare_circle (of_complex z2) r2", "using eq"], ["proof (prove)\nusing this:\n  Ze1 - cor Re1 \\<in> circle Ze1 Re1\n  Ze1 + cor Re1 \\<in> circle Ze1 Re1\n  Ze1 = Ze2\n  Re1 = Re2\n\ngoal (1 subgoal):\n 1. (of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z1) r1 &&&\n     of_complex (Ze1 + cor Re1)\n     \\<in> poincare_circle (of_complex z1) r1) &&&\n    of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z2) r2 &&&\n    of_complex (Ze1 + cor Re1) \\<in> poincare_circle (of_complex z2) r2", "using poincare_circle_is_euclidean_circle[OF \\<open>of_complex z1 \\<in> unit_disc\\<close> \\<open>r1 > 0\\<close>]"], ["proof (prove)\nusing this:\n  Ze1 - cor Re1 \\<in> circle Ze1 Re1\n  Ze1 + cor Re1 \\<in> circle Ze1 Re1\n  Ze1 = Ze2\n  Re1 = Re2\n  let (Ze, Re) = poincare_circle_euclidean (of_complex z1) r1\n  in of_complex ` circle Ze Re = poincare_circle (of_complex z1) r1\n\ngoal (1 subgoal):\n 1. (of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z1) r1 &&&\n     of_complex (Ze1 + cor Re1)\n     \\<in> poincare_circle (of_complex z1) r1) &&&\n    of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z2) r2 &&&\n    of_complex (Ze1 + cor Re1) \\<in> poincare_circle (of_complex z2) r2", "using poincare_circle_is_euclidean_circle[OF \\<open>of_complex z2 \\<in> unit_disc\\<close> \\<open>r2 > 0\\<close>]"], ["proof (prove)\nusing this:\n  Ze1 - cor Re1 \\<in> circle Ze1 Re1\n  Ze1 + cor Re1 \\<in> circle Ze1 Re1\n  Ze1 = Ze2\n  Re1 = Re2\n  let (Ze, Re) = poincare_circle_euclidean (of_complex z1) r1\n  in of_complex ` circle Ze Re = poincare_circle (of_complex z1) r1\n  let (Ze, Re) = poincare_circle_euclidean (of_complex z2) r2\n  in of_complex ` circle Ze Re = poincare_circle (of_complex z2) r2\n\ngoal (1 subgoal):\n 1. (of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z1) r1 &&&\n     of_complex (Ze1 + cor Re1)\n     \\<in> poincare_circle (of_complex z1) r1) &&&\n    of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z2) r2 &&&\n    of_complex (Ze1 + cor Re1) \\<in> poincare_circle (of_complex z2) r2", "using 1 2"], ["proof (prove)\nusing this:\n  Ze1 - cor Re1 \\<in> circle Ze1 Re1\n  Ze1 + cor Re1 \\<in> circle Ze1 Re1\n  Ze1 = Ze2\n  Re1 = Re2\n  let (Ze, Re) = poincare_circle_euclidean (of_complex z1) r1\n  in of_complex ` circle Ze Re = poincare_circle (of_complex z1) r1\n  let (Ze, Re) = poincare_circle_euclidean (of_complex z2) r2\n  in of_complex ` circle Ze Re = poincare_circle (of_complex z2) r2\n  (Ze1, Re1) = poincare_circle_euclidean (of_complex z1) r1\n  (Ze2, Re2) = poincare_circle_euclidean (of_complex z2) r2\n\ngoal (1 subgoal):\n 1. (of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z1) r1 &&&\n     of_complex (Ze1 + cor Re1)\n     \\<in> poincare_circle (of_complex z1) r1) &&&\n    of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z2) r2 &&&\n    of_complex (Ze1 + cor Re1) \\<in> poincare_circle (of_complex z2) r2", "by auto blast+"], ["proof (state)\nthis:\n  of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z1) r1\n  of_complex (Ze1 + cor Re1) \\<in> poincare_circle (of_complex z1) r1\n  of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z2) r2\n  of_complex (Ze1 + cor Re1) \\<in> poincare_circle (of_complex z2) r2\n\ngoal (1 subgoal):\n 1. \\<not> Ze1 \\<noteq> Ze2 \\<Longrightarrow> False", "hence \"poincare_distance (of_complex z1) (of_complex ?A) = poincare_distance (of_complex z1) (of_complex ?B)\"\n          \"poincare_distance (of_complex z2) (of_complex ?A) = poincare_distance (of_complex z2) (of_complex ?B)\"\n          \"-1 < Re (Ze1 - Re1)\" \"Re (Ze1 - Re1) < 1\" \"-1 < Re (Ze1 + Re1)\" \"Re (Ze1 + Re1) < 1\""], ["proof (prove)\nusing this:\n  of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z1) r1\n  of_complex (Ze1 + cor Re1) \\<in> poincare_circle (of_complex z1) r1\n  of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z2) r2\n  of_complex (Ze1 + cor Re1) \\<in> poincare_circle (of_complex z2) r2\n\ngoal (1 subgoal):\n 1. (poincare_distance (of_complex z1) (of_complex (Ze1 - cor Re1)) =\n     poincare_distance (of_complex z1) (of_complex (Ze1 + cor Re1)) &&&\n     poincare_distance (of_complex z2) (of_complex (Ze1 - cor Re1)) =\n     poincare_distance (of_complex z2) (of_complex (Ze1 + cor Re1)) &&&\n     - 1 < Re (Ze1 - cor Re1)) &&&\n    Re (Ze1 - cor Re1) < 1 &&&\n    - 1 < Re (Ze1 + cor Re1) &&& Re (Ze1 + cor Re1) < 1", "using \\<open>is_real Ze1\\<close> \\<open>is_real Ze2\\<close>"], ["proof (prove)\nusing this:\n  of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z1) r1\n  of_complex (Ze1 + cor Re1) \\<in> poincare_circle (of_complex z1) r1\n  of_complex (Ze1 - cor Re1) \\<in> poincare_circle (of_complex z2) r2\n  of_complex (Ze1 + cor Re1) \\<in> poincare_circle (of_complex z2) r2\n  is_real Ze1\n  is_real Ze2\n\ngoal (1 subgoal):\n 1. (poincare_distance (of_complex z1) (of_complex (Ze1 - cor Re1)) =\n     poincare_distance (of_complex z1) (of_complex (Ze1 + cor Re1)) &&&\n     poincare_distance (of_complex z2) (of_complex (Ze1 - cor Re1)) =\n     poincare_distance (of_complex z2) (of_complex (Ze1 + cor Re1)) &&&\n     - 1 < Re (Ze1 - cor Re1)) &&&\n    Re (Ze1 - cor Re1) < 1 &&&\n    - 1 < Re (Ze1 + cor Re1) &&& Re (Ze1 + cor Re1) < 1", "unfolding poincare_circle_def"], ["proof (prove)\nusing this:\n  of_complex (Ze1 - cor Re1)\n  \\<in> {z' \\<in> unit_disc. poincare_distance (of_complex z1) z' = r1}\n  of_complex (Ze1 + cor Re1)\n  \\<in> {z' \\<in> unit_disc. poincare_distance (of_complex z1) z' = r1}\n  of_complex (Ze1 - cor Re1)\n  \\<in> {z' \\<in> unit_disc. poincare_distance (of_complex z2) z' = r2}\n  of_complex (Ze1 + cor Re1)\n  \\<in> {z' \\<in> unit_disc. poincare_distance (of_complex z2) z' = r2}\n  is_real Ze1\n  is_real Ze2\n\ngoal (1 subgoal):\n 1. (poincare_distance (of_complex z1) (of_complex (Ze1 - cor Re1)) =\n     poincare_distance (of_complex z1) (of_complex (Ze1 + cor Re1)) &&&\n     poincare_distance (of_complex z2) (of_complex (Ze1 - cor Re1)) =\n     poincare_distance (of_complex z2) (of_complex (Ze1 + cor Re1)) &&&\n     - 1 < Re (Ze1 - cor Re1)) &&&\n    Re (Ze1 - cor Re1) < 1 &&&\n    - 1 < Re (Ze1 + cor Re1) &&& Re (Ze1 + cor Re1) < 1", "by (auto simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  poincare_distance (of_complex z1) (of_complex (Ze1 - cor Re1)) =\n  poincare_distance (of_complex z1) (of_complex (Ze1 + cor Re1))\n  poincare_distance (of_complex z2) (of_complex (Ze1 - cor Re1)) =\n  poincare_distance (of_complex z2) (of_complex (Ze1 + cor Re1))\n  - 1 < Re (Ze1 - cor Re1)\n  Re (Ze1 - cor Re1) < 1\n  - 1 < Re (Ze1 + cor Re1)\n  Re (Ze1 + cor Re1) < 1\n\ngoal (1 subgoal):\n 1. \\<not> Ze1 \\<noteq> Ze2 \\<Longrightarrow> False", "hence \"z1 = z2\""], ["proof (prove)\nusing this:\n  poincare_distance (of_complex z1) (of_complex (Ze1 - cor Re1)) =\n  poincare_distance (of_complex z1) (of_complex (Ze1 + cor Re1))\n  poincare_distance (of_complex z2) (of_complex (Ze1 - cor Re1)) =\n  poincare_distance (of_complex z2) (of_complex (Ze1 + cor Re1))\n  - 1 < Re (Ze1 - cor Re1)\n  Re (Ze1 - cor Re1) < 1\n  - 1 < Re (Ze1 + cor Re1)\n  Re (Ze1 + cor Re1) < 1\n\ngoal (1 subgoal):\n 1. z1 = z2", "using unique_midpoint_x_axis[of \"Ze1 - Re1\" \"Ze1 + Re1\"]"], ["proof (prove)\nusing this:\n  poincare_distance (of_complex z1) (of_complex (Ze1 - cor Re1)) =\n  poincare_distance (of_complex z1) (of_complex (Ze1 + cor Re1))\n  poincare_distance (of_complex z2) (of_complex (Ze1 - cor Re1)) =\n  poincare_distance (of_complex z2) (of_complex (Ze1 + cor Re1))\n  - 1 < Re (Ze1 - cor Re1)\n  Re (Ze1 - cor Re1) < 1\n  - 1 < Re (Ze1 + cor Re1)\n  Re (Ze1 + cor Re1) < 1\n  \\<lbrakk>is_real (Ze1 - cor Re1); - 1 < Re (Ze1 - cor Re1);\n   Re (Ze1 - cor Re1) < 1; is_real (Ze1 + cor Re1);\n   - 1 < Re (Ze1 + cor Re1); Re (Ze1 + cor Re1) < 1;\n   Ze1 - cor Re1 \\<noteq> Ze1 + cor Re1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!z.\n                       - 1 < Re z \\<and>\n                       Re z < 1 \\<and>\n                       is_real z \\<and>\n                       poincare_distance (of_complex z)\n                        (of_complex (Ze1 - cor Re1)) =\n                       poincare_distance (of_complex z)\n                        (of_complex (Ze1 + cor Re1))\n\ngoal (1 subgoal):\n 1. z1 = z2", "using \\<open>is_real Ze1\\<close> \\<open>is_real z1\\<close> \\<open>is_real z2\\<close> \\<open>Re1 > 0\\<close> \\<open>-1 < Re z1\\<close> \\<open>Re z1 < 1\\<close> \\<open>-1 < Re z2\\<close> \\<open>Re z2 < 1\\<close>"], ["proof (prove)\nusing this:\n  poincare_distance (of_complex z1) (of_complex (Ze1 - cor Re1)) =\n  poincare_distance (of_complex z1) (of_complex (Ze1 + cor Re1))\n  poincare_distance (of_complex z2) (of_complex (Ze1 - cor Re1)) =\n  poincare_distance (of_complex z2) (of_complex (Ze1 + cor Re1))\n  - 1 < Re (Ze1 - cor Re1)\n  Re (Ze1 - cor Re1) < 1\n  - 1 < Re (Ze1 + cor Re1)\n  Re (Ze1 + cor Re1) < 1\n  \\<lbrakk>is_real (Ze1 - cor Re1); - 1 < Re (Ze1 - cor Re1);\n   Re (Ze1 - cor Re1) < 1; is_real (Ze1 + cor Re1);\n   - 1 < Re (Ze1 + cor Re1); Re (Ze1 + cor Re1) < 1;\n   Ze1 - cor Re1 \\<noteq> Ze1 + cor Re1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!z.\n                       - 1 < Re z \\<and>\n                       Re z < 1 \\<and>\n                       is_real z \\<and>\n                       poincare_distance (of_complex z)\n                        (of_complex (Ze1 - cor Re1)) =\n                       poincare_distance (of_complex z)\n                        (of_complex (Ze1 + cor Re1))\n  is_real Ze1\n  is_real z1\n  is_real z2\n  0 < Re1\n  - 1 < Re z1\n  Re z1 < 1\n  - 1 < Re z2\n  Re z2 < 1\n\ngoal (1 subgoal):\n 1. z1 = z2", "by auto"], ["proof (state)\nthis:\n  z1 = z2\n\ngoal (1 subgoal):\n 1. \\<not> Ze1 \\<noteq> Ze2 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  z1 = z2\n\ngoal (1 subgoal):\n 1. False", "using \\<open>z1 \\<noteq> z2\\<close>"], ["proof (prove)\nusing this:\n  z1 = z2\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ze1 \\<noteq> Ze2\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "hence *: \"(Re x1')\\<^sup>2 + (Im x1')\\<^sup>2 - 2 * Re x1' * Ze1 + Ze1 * Ze1 - cor (Re1 * Re1) = 0\"\n           \"(Re x1')\\<^sup>2 + (Im x1')\\<^sup>2 - 2 * Re x1' * Ze2 + Ze2 * Ze2 - cor (Re2 * Re2) = 0\"\n           \"(Re x2')\\<^sup>2 + (Im x2')\\<^sup>2 - 2 * Re x2' * Ze1 + Ze1 * Ze1 - cor (Re1 * Re1) = 0\"\n           \"(Re x2')\\<^sup>2 + (Im x2')\\<^sup>2 - 2 * Re x2' * Ze2 + Ze2 * Ze2 - cor (Re2 * Re2) = 0\""], ["proof (prove)\nusing this:\n  Ze1 \\<noteq> Ze2\n\ngoal (1 subgoal):\n 1. (cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze1 +\n     Ze1 * Ze1 -\n     cor (Re1 * Re1) =\n     0 &&&\n     cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze2 +\n     Ze2 * Ze2 -\n     cor (Re2 * Re2) =\n     0) &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze1 +\n    Ze1 * Ze1 -\n    cor (Re1 * Re1) =\n    0 &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze2 +\n    Ze2 * Ze2 -\n    cor (Re2 * Re2) =\n    0", "using circle_equation[of Re1 Ze1] circle_equation[of Re2 Ze2] circle"], ["proof (prove)\nusing this:\n  Ze1 \\<noteq> Ze2\n  0 \\<le> Re1 \\<Longrightarrow>\n  circle Ze1 Re1 =\n  {z. z * cnj z - z * cnj Ze1 - cnj z * Ze1 + Ze1 * cnj Ze1 -\n      cor (Re1 * Re1) =\n      0}\n  0 \\<le> Re2 \\<Longrightarrow>\n  circle Ze2 Re2 =\n  {z. z * cnj z - z * cnj Ze2 - cnj z * Ze2 + Ze2 * cnj Ze2 -\n      cor (Re2 * Re2) =\n      0}\n  x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n  x2' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n\ngoal (1 subgoal):\n 1. (cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze1 +\n     Ze1 * Ze1 -\n     cor (Re1 * Re1) =\n     0 &&&\n     cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze2 +\n     Ze2 * Ze2 -\n     cor (Re2 * Re2) =\n     0) &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze1 +\n    Ze1 * Ze1 -\n    cor (Re1 * Re1) =\n    0 &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze2 +\n    Ze2 * Ze2 -\n    cor (Re2 * Re2) =\n    0", "using eq_cnj_iff_real[of Ze1] \\<open>is_real Ze1\\<close> \\<open>Re1 > 0\\<close>"], ["proof (prove)\nusing this:\n  Ze1 \\<noteq> Ze2\n  0 \\<le> Re1 \\<Longrightarrow>\n  circle Ze1 Re1 =\n  {z. z * cnj z - z * cnj Ze1 - cnj z * Ze1 + Ze1 * cnj Ze1 -\n      cor (Re1 * Re1) =\n      0}\n  0 \\<le> Re2 \\<Longrightarrow>\n  circle Ze2 Re2 =\n  {z. z * cnj z - z * cnj Ze2 - cnj z * Ze2 + Ze2 * cnj Ze2 -\n      cor (Re2 * Re2) =\n      0}\n  x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n  x2' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n  (cnj Ze1 = Ze1) = is_real Ze1\n  is_real Ze1\n  0 < Re1\n\ngoal (1 subgoal):\n 1. (cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze1 +\n     Ze1 * Ze1 -\n     cor (Re1 * Re1) =\n     0 &&&\n     cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze2 +\n     Ze2 * Ze2 -\n     cor (Re2 * Re2) =\n     0) &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze1 +\n    Ze1 * Ze1 -\n    cor (Re1 * Re1) =\n    0 &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze2 +\n    Ze2 * Ze2 -\n    cor (Re2 * Re2) =\n    0", "using eq_cnj_iff_real[of Ze2] \\<open>is_real Ze2\\<close> \\<open>Re2 > 0\\<close>"], ["proof (prove)\nusing this:\n  Ze1 \\<noteq> Ze2\n  0 \\<le> Re1 \\<Longrightarrow>\n  circle Ze1 Re1 =\n  {z. z * cnj z - z * cnj Ze1 - cnj z * Ze1 + Ze1 * cnj Ze1 -\n      cor (Re1 * Re1) =\n      0}\n  0 \\<le> Re2 \\<Longrightarrow>\n  circle Ze2 Re2 =\n  {z. z * cnj z - z * cnj Ze2 - cnj z * Ze2 + Ze2 * cnj Ze2 -\n      cor (Re2 * Re2) =\n      0}\n  x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n  x2' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n  (cnj Ze1 = Ze1) = is_real Ze1\n  is_real Ze1\n  0 < Re1\n  (cnj Ze2 = Ze2) = is_real Ze2\n  is_real Ze2\n  0 < Re2\n\ngoal (1 subgoal):\n 1. (cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze1 +\n     Ze1 * Ze1 -\n     cor (Re1 * Re1) =\n     0 &&&\n     cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze2 +\n     Ze2 * Ze2 -\n     cor (Re2 * Re2) =\n     0) &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze1 +\n    Ze1 * Ze1 -\n    cor (Re1 * Re1) =\n    0 &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze2 +\n    Ze2 * Ze2 -\n    cor (Re2 * Re2) =\n    0", "using complex_add_cnj[of x1']  complex_add_cnj[of x2']"], ["proof (prove)\nusing this:\n  Ze1 \\<noteq> Ze2\n  0 \\<le> Re1 \\<Longrightarrow>\n  circle Ze1 Re1 =\n  {z. z * cnj z - z * cnj Ze1 - cnj z * Ze1 + Ze1 * cnj Ze1 -\n      cor (Re1 * Re1) =\n      0}\n  0 \\<le> Re2 \\<Longrightarrow>\n  circle Ze2 Re2 =\n  {z. z * cnj z - z * cnj Ze2 - cnj z * Ze2 + Ze2 * cnj Ze2 -\n      cor (Re2 * Re2) =\n      0}\n  x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n  x2' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n  (cnj Ze1 = Ze1) = is_real Ze1\n  is_real Ze1\n  0 < Re1\n  (cnj Ze2 = Ze2) = is_real Ze2\n  is_real Ze2\n  0 < Re2\n  x1' + cnj x1' = cor (2 * Re x1')\n  x2' + cnj x2' = cor (2 * Re x2')\n\ngoal (1 subgoal):\n 1. (cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze1 +\n     Ze1 * Ze1 -\n     cor (Re1 * Re1) =\n     0 &&&\n     cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze2 +\n     Ze2 * Ze2 -\n     cor (Re2 * Re2) =\n     0) &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze1 +\n    Ze1 * Ze1 -\n    cor (Re1 * Re1) =\n    0 &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze2 +\n    Ze2 * Ze2 -\n    cor (Re2 * Re2) =\n    0", "using distrib_left[of Ze1 x1' \"cnj x1'\"] distrib_left[of Ze2 x1' \"cnj x1'\"]"], ["proof (prove)\nusing this:\n  Ze1 \\<noteq> Ze2\n  0 \\<le> Re1 \\<Longrightarrow>\n  circle Ze1 Re1 =\n  {z. z * cnj z - z * cnj Ze1 - cnj z * Ze1 + Ze1 * cnj Ze1 -\n      cor (Re1 * Re1) =\n      0}\n  0 \\<le> Re2 \\<Longrightarrow>\n  circle Ze2 Re2 =\n  {z. z * cnj z - z * cnj Ze2 - cnj z * Ze2 + Ze2 * cnj Ze2 -\n      cor (Re2 * Re2) =\n      0}\n  x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n  x2' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n  (cnj Ze1 = Ze1) = is_real Ze1\n  is_real Ze1\n  0 < Re1\n  (cnj Ze2 = Ze2) = is_real Ze2\n  is_real Ze2\n  0 < Re2\n  x1' + cnj x1' = cor (2 * Re x1')\n  x2' + cnj x2' = cor (2 * Re x2')\n  Ze1 * (x1' + cnj x1') = Ze1 * x1' + Ze1 * cnj x1'\n  Ze2 * (x1' + cnj x1') = Ze2 * x1' + Ze2 * cnj x1'\n\ngoal (1 subgoal):\n 1. (cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze1 +\n     Ze1 * Ze1 -\n     cor (Re1 * Re1) =\n     0 &&&\n     cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze2 +\n     Ze2 * Ze2 -\n     cor (Re2 * Re2) =\n     0) &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze1 +\n    Ze1 * Ze1 -\n    cor (Re1 * Re1) =\n    0 &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze2 +\n    Ze2 * Ze2 -\n    cor (Re2 * Re2) =\n    0", "using distrib_left[of Ze1 x2' \"cnj x2'\"] distrib_left[of Ze2 x2' \"cnj x2'\"]"], ["proof (prove)\nusing this:\n  Ze1 \\<noteq> Ze2\n  0 \\<le> Re1 \\<Longrightarrow>\n  circle Ze1 Re1 =\n  {z. z * cnj z - z * cnj Ze1 - cnj z * Ze1 + Ze1 * cnj Ze1 -\n      cor (Re1 * Re1) =\n      0}\n  0 \\<le> Re2 \\<Longrightarrow>\n  circle Ze2 Re2 =\n  {z. z * cnj z - z * cnj Ze2 - cnj z * Ze2 + Ze2 * cnj Ze2 -\n      cor (Re2 * Re2) =\n      0}\n  x1' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n  x2' \\<in> circle Ze1 Re1 \\<inter> circle Ze2 Re2\n  (cnj Ze1 = Ze1) = is_real Ze1\n  is_real Ze1\n  0 < Re1\n  (cnj Ze2 = Ze2) = is_real Ze2\n  is_real Ze2\n  0 < Re2\n  x1' + cnj x1' = cor (2 * Re x1')\n  x2' + cnj x2' = cor (2 * Re x2')\n  Ze1 * (x1' + cnj x1') = Ze1 * x1' + Ze1 * cnj x1'\n  Ze2 * (x1' + cnj x1') = Ze2 * x1' + Ze2 * cnj x1'\n  Ze1 * (x2' + cnj x2') = Ze1 * x2' + Ze1 * cnj x2'\n  Ze2 * (x2' + cnj x2') = Ze2 * x2' + Ze2 * cnj x2'\n\ngoal (1 subgoal):\n 1. (cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze1 +\n     Ze1 * Ze1 -\n     cor (Re1 * Re1) =\n     0 &&&\n     cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze2 +\n     Ze2 * Ze2 -\n     cor (Re2 * Re2) =\n     0) &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze1 +\n    Ze1 * Ze1 -\n    cor (Re1 * Re1) =\n    0 &&&\n    cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze2 +\n    Ze2 * Ze2 -\n    cor (Re2 * Re2) =\n    0", "by (auto simp add: complex_mult_cnj power2_eq_square field_simps)"], ["proof (state)\nthis:\n  cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze1 +\n  Ze1 * Ze1 -\n  cor (Re1 * Re1) =\n  0\n  cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze2 +\n  Ze2 * Ze2 -\n  cor (Re2 * Re2) =\n  0\n  cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze1 +\n  Ze1 * Ze1 -\n  cor (Re1 * Re1) =\n  0\n  cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze2 +\n  Ze2 * Ze2 -\n  cor (Re2 * Re2) =\n  0\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "hence \"- 2 * Re x1' * Ze1 + Ze1 * Ze1 - cor (Re1 * Re1) = - 2 * Re x1' * Ze2 + Ze2 * Ze2 - cor (Re2 * Re2)\"\n        \"- 2 * Re x2' * Ze1 + Ze1 * Ze1 - cor (Re1 * Re1) = - 2 * Re x2' * Ze2 + Ze2 * Ze2 - cor (Re2 * Re2)\""], ["proof (prove)\nusing this:\n  cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze1 +\n  Ze1 * Ze1 -\n  cor (Re1 * Re1) =\n  0\n  cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze2 +\n  Ze2 * Ze2 -\n  cor (Re2 * Re2) =\n  0\n  cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze1 +\n  Ze1 * Ze1 -\n  cor (Re1 * Re1) =\n  0\n  cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze2 +\n  Ze2 * Ze2 -\n  cor (Re2 * Re2) =\n  0\n\ngoal (1 subgoal):\n 1. cor (- 2 * Re x1') * Ze1 + Ze1 * Ze1 - cor (Re1 * Re1) =\n    cor (- 2 * Re x1') * Ze2 + Ze2 * Ze2 - cor (Re2 * Re2) &&&\n    cor (- 2 * Re x2') * Ze1 + Ze1 * Ze1 - cor (Re1 * Re1) =\n    cor (- 2 * Re x2') * Ze2 + Ze2 * Ze2 - cor (Re2 * Re2)", "by (smt add_diff_cancel_right' add_diff_eq eq_iff_diff_eq_0 minus_diff_eq mult_minus_left of_real_minus)+"], ["proof (state)\nthis:\n  cor (- 2 * Re x1') * Ze1 + Ze1 * Ze1 - cor (Re1 * Re1) =\n  cor (- 2 * Re x1') * Ze2 + Ze2 * Ze2 - cor (Re2 * Re2)\n  cor (- 2 * Re x2') * Ze1 + Ze1 * Ze1 - cor (Re1 * Re1) =\n  cor (- 2 * Re x2') * Ze2 + Ze2 * Ze2 - cor (Re2 * Re2)\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "hence \"2 * Re x1' * (Ze2 - Ze1) =  (Ze2 * Ze2 - cor (Re2 * Re2)) - (Ze1 * Ze1 - cor (Re1 * Re1))\"\n        \"2 * Re x2' * (Ze2 - Ze1) =  (Ze2 * Ze2 - cor (Re2 * Re2)) - (Ze1 * Ze1 - cor (Re1 * Re1))\""], ["proof (prove)\nusing this:\n  cor (- 2 * Re x1') * Ze1 + Ze1 * Ze1 - cor (Re1 * Re1) =\n  cor (- 2 * Re x1') * Ze2 + Ze2 * Ze2 - cor (Re2 * Re2)\n  cor (- 2 * Re x2') * Ze1 + Ze1 * Ze1 - cor (Re1 * Re1) =\n  cor (- 2 * Re x2') * Ze2 + Ze2 * Ze2 - cor (Re2 * Re2)\n\ngoal (1 subgoal):\n 1. cor (2 * Re x1') * (Ze2 - Ze1) =\n    Ze2 * Ze2 - cor (Re2 * Re2) - (Ze1 * Ze1 - cor (Re1 * Re1)) &&&\n    cor (2 * Re x2') * (Ze2 - Ze1) =\n    Ze2 * Ze2 - cor (Re2 * Re2) - (Ze1 * Ze1 - cor (Re1 * Re1))", "by simp_all (simp add: field_simps)+"], ["proof (state)\nthis:\n  cor (2 * Re x1') * (Ze2 - Ze1) =\n  Ze2 * Ze2 - cor (Re2 * Re2) - (Ze1 * Ze1 - cor (Re1 * Re1))\n  cor (2 * Re x2') * (Ze2 - Ze1) =\n  Ze2 * Ze2 - cor (Re2 * Re2) - (Ze1 * Ze1 - cor (Re1 * Re1))\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "hence \"2 * Re x1' * (Ze2 - Ze1) = 2 * Re x2' * (Ze2 - Ze1)\""], ["proof (prove)\nusing this:\n  cor (2 * Re x1') * (Ze2 - Ze1) =\n  Ze2 * Ze2 - cor (Re2 * Re2) - (Ze1 * Ze1 - cor (Re1 * Re1))\n  cor (2 * Re x2') * (Ze2 - Ze1) =\n  Ze2 * Ze2 - cor (Re2 * Re2) - (Ze1 * Ze1 - cor (Re1 * Re1))\n\ngoal (1 subgoal):\n 1. cor (2 * Re x1') * (Ze2 - Ze1) = cor (2 * Re x2') * (Ze2 - Ze1)", "by simp"], ["proof (state)\nthis:\n  cor (2 * Re x1') * (Ze2 - Ze1) = cor (2 * Re x2') * (Ze2 - Ze1)\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "hence \"Re x1' = Re x2'\""], ["proof (prove)\nusing this:\n  cor (2 * Re x1') * (Ze2 - Ze1) = cor (2 * Re x2') * (Ze2 - Ze1)\n\ngoal (1 subgoal):\n 1. Re x1' = Re x2'", "using \\<open>Ze1 \\<noteq> Ze2\\<close>"], ["proof (prove)\nusing this:\n  cor (2 * Re x1') * (Ze2 - Ze1) = cor (2 * Re x2') * (Ze2 - Ze1)\n  Ze1 \\<noteq> Ze2\n\ngoal (1 subgoal):\n 1. Re x1' = Re x2'", "by simp"], ["proof (state)\nthis:\n  Re x1' = Re x2'\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "moreover"], ["proof (state)\nthis:\n  Re x1' = Re x2'\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "hence \"(Im x1')\\<^sup>2 = (Im x2')\\<^sup>2\""], ["proof (prove)\nusing this:\n  Re x1' = Re x2'\n\ngoal (1 subgoal):\n 1. (Im x1')\\<^sup>2 = (Im x2')\\<^sup>2", "using *(1) *(3)"], ["proof (prove)\nusing this:\n  Re x1' = Re x2'\n  cor ((Re x1')\\<^sup>2 + (Im x1')\\<^sup>2) - cor (2 * Re x1') * Ze1 +\n  Ze1 * Ze1 -\n  cor (Re1 * Re1) =\n  0\n  cor ((Re x2')\\<^sup>2 + (Im x2')\\<^sup>2) - cor (2 * Re x2') * Ze1 +\n  Ze1 * Ze1 -\n  cor (Re1 * Re1) =\n  0\n\ngoal (1 subgoal):\n 1. (Im x1')\\<^sup>2 = (Im x2')\\<^sup>2", "by (simp add: \\<open>is_real Ze1\\<close> complex_eq_if_Re_eq)"], ["proof (state)\nthis:\n  (Im x1')\\<^sup>2 = (Im x2')\\<^sup>2\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "hence \"Im x1' = Im x2' \\<or> Im x1' = -Im x2'\""], ["proof (prove)\nusing this:\n  (Im x1')\\<^sup>2 = (Im x2')\\<^sup>2\n\ngoal (1 subgoal):\n 1. Im x1' = Im x2' \\<or> Im x1' = - Im x2'", "using power2_eq_iff"], ["proof (prove)\nusing this:\n  (Im x1')\\<^sup>2 = (Im x2')\\<^sup>2\n  (?x\\<^sup>2 = ?y\\<^sup>2) = (?x = ?y \\<or> ?x = - ?y)\n\ngoal (1 subgoal):\n 1. Im x1' = Im x2' \\<or> Im x1' = - Im x2'", "by blast"], ["proof (state)\nthis:\n  Im x1' = Im x2' \\<or> Im x1' = - Im x2'\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "ultimately"], ["proof (chain)\npicking this:\n  Re x1' = Re x2'\n  Im x1' = Im x2' \\<or> Im x1' = - Im x2'", "show ?thesis"], ["proof (prove)\nusing this:\n  Re x1' = Re x2'\n  Im x1' = Im x2' \\<or> Im x1' = - Im x2'\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "using x' \\<open>x1 \\<noteq> x2\\<close>"], ["proof (prove)\nusing this:\n  Re x1' = Re x2'\n  Im x1' = Im x2' \\<or> Im x1' = - Im x2'\n  x1 = of_complex x1'\n  x2 = of_complex x2'\n  x1 \\<noteq> x2\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "using complex.expand"], ["proof (prove)\nusing this:\n  Re x1' = Re x2'\n  Im x1' = Im x2' \\<or> Im x1' = - Im x2'\n  x1 = of_complex x1'\n  x2 = of_complex x2'\n  x1 \\<noteq> x2\n  Re ?complex = Re ?complex' \\<and>\n  Im ?complex = Im ?complex' \\<Longrightarrow>\n  ?complex = ?complex'\n\ngoal (1 subgoal):\n 1. x1 = conjugate x2", "by (metis cnj.code complex_surj conjugate_of_complex)"], ["proof (state)\nthis:\n  x1 = conjugate x2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Two h-circles of the same radius centered at mutually conjugate points intersect at the x-axis\\<close>"], ["", "lemma intersect_poincare_circles_conjugate_centers:\n  assumes in_disc: \"z1 \\<in> unit_disc\" \"z2 \\<in> unit_disc\" and \n          \"z1 \\<noteq> z2\" and \"z1 = conjugate z2\" and \"r > 0\" and\n          u: \"u \\<in> poincare_circle z1 r \\<inter> poincare_circle z2 r\"\n  shows \"is_real (to_complex u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "obtain z1e r1e z2e r2e where\n   euclidean: \"(z1e, r1e) = poincare_circle_euclidean z1 r\"\n              \"(z2e, r2e) = poincare_circle_euclidean z2 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z1e r1e z2e r2e.\n        \\<lbrakk>(z1e, r1e) = poincare_circle_euclidean z1 r;\n         (z2e, r2e) = poincare_circle_euclidean z2 r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis poincare_circle_euclidean_def)"], ["proof (state)\nthis:\n  (z1e, r1e) = poincare_circle_euclidean z1 r\n  (z2e, r2e) = poincare_circle_euclidean z2 r\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "obtain z1' z2' where z': \"z1 = of_complex z1'\" \"z2 = of_complex z2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z1' z2'.\n        \\<lbrakk>z1 = of_complex z1'; z2 = of_complex z2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inf_or_of_complex[of z1] inf_or_of_complex[of z2] in_disc"], ["proof (prove)\nusing this:\n  z1 = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. z1 = of_complex x)\n  z2 = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. z2 = of_complex x)\n  z1 \\<in> unit_disc\n  z2 \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. (\\<And>z1' z2'.\n        \\<lbrakk>z1 = of_complex z1'; z2 = of_complex z2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z1 = of_complex z1'\n  z2 = of_complex z2'\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "obtain u' where u': \"u = of_complex u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u'. u = of_complex u' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using u inf_or_of_complex[of u]"], ["proof (prove)\nusing this:\n  u \\<in> poincare_circle z1 r \\<inter> poincare_circle z2 r\n  u = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. u = of_complex x)\n\ngoal (1 subgoal):\n 1. (\\<And>u'. u = of_complex u' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: poincare_circle_def)"], ["proof (state)\nthis:\n  u = of_complex u'\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "have \"z1' = cnj z2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z1' = cnj z2'", "using \\<open>z1 = conjugate z2\\<close> z'"], ["proof (prove)\nusing this:\n  z1 = conjugate z2\n  z1 = of_complex z1'\n  z2 = of_complex z2'\n\ngoal (1 subgoal):\n 1. z1' = cnj z2'", "by (auto simp add: of_complex_inj)"], ["proof (state)\nthis:\n  z1' = cnj z2'\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "moreover"], ["proof (state)\nthis:\n  z1' = cnj z2'\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "let ?cz = \"1 - (cmod z2')\\<^sup>2\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "let ?den = \"?cz * (cosh r - 1) / 2 + 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "have \"?cz > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 - (cmod z2')\\<^sup>2", "using in_disc z'"], ["proof (prove)\nusing this:\n  z1 \\<in> unit_disc\n  z2 \\<in> unit_disc\n  z1 = of_complex z1'\n  z2 = of_complex z2'\n\ngoal (1 subgoal):\n 1. 0 < 1 - (cmod z2')\\<^sup>2", "by (simp add: cmod_def)"], ["proof (state)\nthis:\n  0 < 1 - (cmod z2')\\<^sup>2\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "hence \"?den \\<ge> 1\""], ["proof (prove)\nusing this:\n  0 < 1 - (cmod z2')\\<^sup>2\n\ngoal (1 subgoal):\n 1. 1 \\<le> (1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1", "using cosh_gt_1[OF \\<open>r > 0\\<close>]"], ["proof (prove)\nusing this:\n  0 < 1 - (cmod z2')\\<^sup>2\n  1 < cosh r\n\ngoal (1 subgoal):\n 1. 1 \\<le> (1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1", "by auto"], ["proof (state)\nthis:\n  1 \\<le> (1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "hence \"?den \\<noteq> 0\""], ["proof (prove)\nusing this:\n  1 \\<le> (1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1\n\ngoal (1 subgoal):\n 1. (1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  (1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "hence \"cor ?den \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cor ((1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1) \\<noteq> 0", "using of_real_eq_0_iff"], ["proof (prove)\nusing this:\n  (1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1 \\<noteq> 0\n  (of_real ?x = (0::?'a)) = (?x = 0)\n\ngoal (1 subgoal):\n 1. cor ((1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1) \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  cor ((1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "ultimately"], ["proof (chain)\npicking this:\n  z1' = cnj z2'\n  cor ((1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1) \\<noteq> 0", "have \"r1e = r2e\" \"z1e = cnj z2e\" \"z1e \\<noteq> z2e\""], ["proof (prove)\nusing this:\n  z1' = cnj z2'\n  cor ((1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r1e = r2e &&& z1e = cnj z2e &&& z1e \\<noteq> z2e", "using z' euclidean \\<open>z1 \\<noteq> z2\\<close>"], ["proof (prove)\nusing this:\n  z1' = cnj z2'\n  cor ((1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1) \\<noteq> 0\n  z1 = of_complex z1'\n  z2 = of_complex z2'\n  (z1e, r1e) = poincare_circle_euclidean z1 r\n  (z2e, r2e) = poincare_circle_euclidean z2 r\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. r1e = r2e &&& z1e = cnj z2e &&& z1e \\<noteq> z2e", "unfolding poincare_circle_euclidean_def Let_def"], ["proof (prove)\nusing this:\n  z1' = cnj z2'\n  cor ((1 - (cmod z2')\\<^sup>2) * (cosh r - 1) / 2 + 1) \\<noteq> 0\n  z1 = of_complex z1'\n  z2 = of_complex z2'\n  (z1e, r1e) =\n  (to_complex z1 /\n   cor ((1 - (cmod (to_complex z1))\\<^sup>2) * ((cosh r - 1) / 2) + 1),\n   (1 - (cmod (to_complex z1))\\<^sup>2) *\n   sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n   ((1 - (cmod (to_complex z1))\\<^sup>2) * ((cosh r - 1) / 2) + 1))\n  (z2e, r2e) =\n  (to_complex z2 /\n   cor ((1 - (cmod (to_complex z2))\\<^sup>2) * ((cosh r - 1) / 2) + 1),\n   (1 - (cmod (to_complex z2))\\<^sup>2) *\n   sqrt ((cosh r - 1) / 2 * ((cosh r - 1) / 2 + 1)) /\n   ((1 - (cmod (to_complex z2))\\<^sup>2) * ((cosh r - 1) / 2) + 1))\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. r1e = r2e &&& z1e = cnj z2e &&& z1e \\<noteq> z2e", "by simp_all metis"], ["proof (state)\nthis:\n  r1e = r2e\n  z1e = cnj z2e\n  z1e \\<noteq> z2e\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "hence \"u' \\<in> circle (cnj z2e) r2e \\<inter> circle z2e r2e\" \"z2e \\<noteq> cnj z2e\""], ["proof (prove)\nusing this:\n  r1e = r2e\n  z1e = cnj z2e\n  z1e \\<noteq> z2e\n\ngoal (1 subgoal):\n 1. u' \\<in> circle (cnj z2e) r2e \\<inter> circle z2e r2e &&&\n    z2e \\<noteq> cnj z2e", "using euclidean u u'"], ["proof (prove)\nusing this:\n  r1e = r2e\n  z1e = cnj z2e\n  z1e \\<noteq> z2e\n  (z1e, r1e) = poincare_circle_euclidean z1 r\n  (z2e, r2e) = poincare_circle_euclidean z2 r\n  u \\<in> poincare_circle z1 r \\<inter> poincare_circle z2 r\n  u = of_complex u'\n\ngoal (1 subgoal):\n 1. u' \\<in> circle (cnj z2e) r2e \\<inter> circle z2e r2e &&&\n    z2e \\<noteq> cnj z2e", "using poincare_circle_is_euclidean_circle[of z1 r]"], ["proof (prove)\nusing this:\n  r1e = r2e\n  z1e = cnj z2e\n  z1e \\<noteq> z2e\n  (z1e, r1e) = poincare_circle_euclidean z1 r\n  (z2e, r2e) = poincare_circle_euclidean z2 r\n  u \\<in> poincare_circle z1 r \\<inter> poincare_circle z2 r\n  u = of_complex u'\n  \\<lbrakk>z1 \\<in> unit_disc; 0 < r\\<rbrakk>\n  \\<Longrightarrow> let (Ze, Re) = poincare_circle_euclidean z1 r\n                    in of_complex ` circle Ze Re = poincare_circle z1 r\n\ngoal (1 subgoal):\n 1. u' \\<in> circle (cnj z2e) r2e \\<inter> circle z2e r2e &&&\n    z2e \\<noteq> cnj z2e", "using poincare_circle_is_euclidean_circle[of z2 r]"], ["proof (prove)\nusing this:\n  r1e = r2e\n  z1e = cnj z2e\n  z1e \\<noteq> z2e\n  (z1e, r1e) = poincare_circle_euclidean z1 r\n  (z2e, r2e) = poincare_circle_euclidean z2 r\n  u \\<in> poincare_circle z1 r \\<inter> poincare_circle z2 r\n  u = of_complex u'\n  \\<lbrakk>z1 \\<in> unit_disc; 0 < r\\<rbrakk>\n  \\<Longrightarrow> let (Ze, Re) = poincare_circle_euclidean z1 r\n                    in of_complex ` circle Ze Re = poincare_circle z1 r\n  \\<lbrakk>z2 \\<in> unit_disc; 0 < r\\<rbrakk>\n  \\<Longrightarrow> let (Ze, Re) = poincare_circle_euclidean z2 r\n                    in of_complex ` circle Ze Re = poincare_circle z2 r\n\ngoal (1 subgoal):\n 1. u' \\<in> circle (cnj z2e) r2e \\<inter> circle z2e r2e &&&\n    z2e \\<noteq> cnj z2e", "using in_disc \\<open>r > 0\\<close>"], ["proof (prove)\nusing this:\n  r1e = r2e\n  z1e = cnj z2e\n  z1e \\<noteq> z2e\n  (z1e, r1e) = poincare_circle_euclidean z1 r\n  (z2e, r2e) = poincare_circle_euclidean z2 r\n  u \\<in> poincare_circle z1 r \\<inter> poincare_circle z2 r\n  u = of_complex u'\n  \\<lbrakk>z1 \\<in> unit_disc; 0 < r\\<rbrakk>\n  \\<Longrightarrow> let (Ze, Re) = poincare_circle_euclidean z1 r\n                    in of_complex ` circle Ze Re = poincare_circle z1 r\n  \\<lbrakk>z2 \\<in> unit_disc; 0 < r\\<rbrakk>\n  \\<Longrightarrow> let (Ze, Re) = poincare_circle_euclidean z2 r\n                    in of_complex ` circle Ze Re = poincare_circle z2 r\n  z1 \\<in> unit_disc\n  z2 \\<in> unit_disc\n  0 < r\n\ngoal (1 subgoal):\n 1. u' \\<in> circle (cnj z2e) r2e \\<inter> circle z2e r2e &&&\n    z2e \\<noteq> cnj z2e", "by auto (metis image_iff of_complex_inj)+"], ["proof (state)\nthis:\n  u' \\<in> circle (cnj z2e) r2e \\<inter> circle z2e r2e\n  z2e \\<noteq> cnj z2e\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "hence \"(cmod (u' - z2e))\\<^sup>2 = (cmod(u' - cnj z2e))\\<^sup>2\""], ["proof (prove)\nusing this:\n  u' \\<in> circle (cnj z2e) r2e \\<inter> circle z2e r2e\n  z2e \\<noteq> cnj z2e\n\ngoal (1 subgoal):\n 1. (cmod (u' - z2e))\\<^sup>2 = (cmod (u' - cnj z2e))\\<^sup>2", "by (simp add: circle_def)"], ["proof (state)\nthis:\n  (cmod (u' - z2e))\\<^sup>2 = (cmod (u' - cnj z2e))\\<^sup>2\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "hence \"(u' - z2e) * (cnj u' - cnj z2e) = (u' - cnj z2e) * (cnj u' - z2e)\""], ["proof (prove)\nusing this:\n  (cmod (u' - z2e))\\<^sup>2 = (cmod (u' - cnj z2e))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (u' - z2e) * (cnj u' - cnj z2e) = (u' - cnj z2e) * (cnj u' - z2e)", "by (metis complex_cnj_cnj complex_cnj_diff complex_norm_square)"], ["proof (state)\nthis:\n  (u' - z2e) * (cnj u' - cnj z2e) = (u' - cnj z2e) * (cnj u' - z2e)\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "hence \"(z2e - cnj z2e) * (u' - cnj u') = 0\""], ["proof (prove)\nusing this:\n  (u' - z2e) * (cnj u' - cnj z2e) = (u' - cnj z2e) * (cnj u' - z2e)\n\ngoal (1 subgoal):\n 1. (z2e - cnj z2e) * (u' - cnj u') = 0", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (z2e - cnj z2e) * (u' - cnj u') = 0\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (z2e - cnj z2e) * (u' - cnj u') = 0\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "using u' \\<open>z2e \\<noteq> cnj z2e\\<close> eq_cnj_iff_real[of u']"], ["proof (prove)\nusing this:\n  (z2e - cnj z2e) * (u' - cnj u') = 0\n  u = of_complex u'\n  z2e \\<noteq> cnj z2e\n  (cnj u' = u') = is_real u'\n\ngoal (1 subgoal):\n 1. is_real (to_complex u)", "by simp"], ["proof (state)\nthis:\n  is_real (to_complex u)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Congruent triangles\\<close>"], ["", "text\\<open>For every pair of triangles such that its three pairs of sides are pairwise equal there is an\nh-isometry (a unit disc preserving M?bius transform, eventually composed with a conjugation) that\nmaps one triangle onto the other.\\<close>"], ["", "lemma unit_disc_fix_f_congruent_triangles:\n  assumes\n    in_disc: \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"w \\<in> unit_disc\" and\n    in_disc': \"u' \\<in> unit_disc\" \"v' \\<in> unit_disc\" \"w' \\<in> unit_disc\" and \n    d: \"poincare_distance u v = poincare_distance u' v'\"\n       \"poincare_distance v w = poincare_distance v' w'\"\n       \"poincare_distance u w = poincare_distance u' w'\"\n  shows\n    \"\\<exists> M. unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "proof (cases \"u = v \\<or> u = w \\<or> v = w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u = v \\<or> u = w \\<or> v = w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'\n 2. \\<not> (u = v \\<or> u = w \\<or> v = w) \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "case True"], ["proof (state)\nthis:\n  u = v \\<or> u = w \\<or> v = w\n\ngoal (2 subgoals):\n 1. u = v \\<or> u = w \\<or> v = w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'\n 2. \\<not> (u = v \\<or> u = w \\<or> v = w) \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "thus ?thesis"], ["proof (prove)\nusing this:\n  u = v \\<or> u = w \\<or> v = w\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "using assms"], ["proof (prove)\nusing this:\n  u = v \\<or> u = w \\<or> v = w\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n  poincare_distance v w = poincare_distance v' w'\n  poincare_distance u w = poincare_distance u' w'\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "using poincare_distance_eq_0_iff[of u' v']"], ["proof (prove)\nusing this:\n  u = v \\<or> u = w \\<or> v = w\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n  poincare_distance v w = poincare_distance v' w'\n  poincare_distance u w = poincare_distance u' w'\n  \\<lbrakk>u' \\<in> unit_disc; v' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance u' v' = 0) = (u' = v')\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "using poincare_distance_eq_0_iff[of v' w']"], ["proof (prove)\nusing this:\n  u = v \\<or> u = w \\<or> v = w\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n  poincare_distance v w = poincare_distance v' w'\n  poincare_distance u w = poincare_distance u' w'\n  \\<lbrakk>u' \\<in> unit_disc; v' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance u' v' = 0) = (u' = v')\n  \\<lbrakk>v' \\<in> unit_disc; w' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance v' w' = 0) = (v' = w')\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "using poincare_distance_eq_0_iff[of u' w']"], ["proof (prove)\nusing this:\n  u = v \\<or> u = w \\<or> v = w\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n  poincare_distance v w = poincare_distance v' w'\n  poincare_distance u w = poincare_distance u' w'\n  \\<lbrakk>u' \\<in> unit_disc; v' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance u' v' = 0) = (u' = v')\n  \\<lbrakk>v' \\<in> unit_disc; w' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance v' w' = 0) = (v' = w')\n  \\<lbrakk>u' \\<in> unit_disc; w' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance u' w' = 0) = (u' = w')\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "using poincare_distance_eq_ex_moebius[of v w v' w']"], ["proof (prove)\nusing this:\n  u = v \\<or> u = w \\<or> v = w\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n  poincare_distance v w = poincare_distance v' w'\n  poincare_distance u w = poincare_distance u' w'\n  \\<lbrakk>u' \\<in> unit_disc; v' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance u' v' = 0) = (u' = v')\n  \\<lbrakk>v' \\<in> unit_disc; w' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance v' w' = 0) = (v' = w')\n  \\<lbrakk>u' \\<in> unit_disc; w' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance u' w' = 0) = (u' = w')\n  \\<lbrakk>v \\<in> unit_disc; w \\<in> unit_disc; v' \\<in> unit_disc;\n   w' \\<in> unit_disc;\n   poincare_distance v w = poincare_distance v' w'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M.\n                       unit_disc_fix M \\<and>\n                       moebius_pt M v = v' \\<and> moebius_pt M w = w'\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "using poincare_distance_eq_ex_moebius[of u w u' w']"], ["proof (prove)\nusing this:\n  u = v \\<or> u = w \\<or> v = w\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n  poincare_distance v w = poincare_distance v' w'\n  poincare_distance u w = poincare_distance u' w'\n  \\<lbrakk>u' \\<in> unit_disc; v' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance u' v' = 0) = (u' = v')\n  \\<lbrakk>v' \\<in> unit_disc; w' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance v' w' = 0) = (v' = w')\n  \\<lbrakk>u' \\<in> unit_disc; w' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance u' w' = 0) = (u' = w')\n  \\<lbrakk>v \\<in> unit_disc; w \\<in> unit_disc; v' \\<in> unit_disc;\n   w' \\<in> unit_disc;\n   poincare_distance v w = poincare_distance v' w'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M.\n                       unit_disc_fix M \\<and>\n                       moebius_pt M v = v' \\<and> moebius_pt M w = w'\n  \\<lbrakk>u \\<in> unit_disc; w \\<in> unit_disc; u' \\<in> unit_disc;\n   w' \\<in> unit_disc;\n   poincare_distance u w = poincare_distance u' w'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M.\n                       unit_disc_fix M \\<and>\n                       moebius_pt M u = u' \\<and> moebius_pt M w = w'\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "using poincare_distance_eq_ex_moebius[of u v u' v']"], ["proof (prove)\nusing this:\n  u = v \\<or> u = w \\<or> v = w\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n  poincare_distance v w = poincare_distance v' w'\n  poincare_distance u w = poincare_distance u' w'\n  \\<lbrakk>u' \\<in> unit_disc; v' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance u' v' = 0) = (u' = v')\n  \\<lbrakk>v' \\<in> unit_disc; w' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance v' w' = 0) = (v' = w')\n  \\<lbrakk>u' \\<in> unit_disc; w' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance u' w' = 0) = (u' = w')\n  \\<lbrakk>v \\<in> unit_disc; w \\<in> unit_disc; v' \\<in> unit_disc;\n   w' \\<in> unit_disc;\n   poincare_distance v w = poincare_distance v' w'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M.\n                       unit_disc_fix M \\<and>\n                       moebius_pt M v = v' \\<and> moebius_pt M w = w'\n  \\<lbrakk>u \\<in> unit_disc; w \\<in> unit_disc; u' \\<in> unit_disc;\n   w' \\<in> unit_disc;\n   poincare_distance u w = poincare_distance u' w'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M.\n                       unit_disc_fix M \\<and>\n                       moebius_pt M u = u' \\<and> moebius_pt M w = w'\n  \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc; u' \\<in> unit_disc;\n   v' \\<in> unit_disc;\n   poincare_distance u v = poincare_distance u' v'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M.\n                       unit_disc_fix M \\<and>\n                       moebius_pt M u = u' \\<and> moebius_pt M v = v'\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "by (metis unit_disc_fix_f_def)"], ["proof (state)\nthis:\n  \\<exists>M.\n     unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'\n\ngoal (1 subgoal):\n 1. \\<not> (u = v \\<or> u = w \\<or> v = w) \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (u = v \\<or> u = w \\<or> v = w) \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "case False"], ["proof (state)\nthis:\n  \\<not> (u = v \\<or> u = w \\<or> v = w)\n\ngoal (1 subgoal):\n 1. \\<not> (u = v \\<or> u = w \\<or> v = w) \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "have \"\\<forall> w u' v' w'. w \\<in> unit_disc \\<and> u' \\<in> unit_disc \\<and> v' \\<in> unit_disc \\<and> w' \\<in> unit_disc \\<and> w \\<noteq> u \\<and> w \\<noteq> v \\<and>\n    poincare_distance u v = poincare_distance u' v' \\<and>\n    poincare_distance v w = poincare_distance v' w' \\<and>\n    poincare_distance u w = poincare_distance u' w' \\<longrightarrow>\n    (\\<exists> M. unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w')\" (is \"?P u v\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w u' v' w'.\n       w \\<in> unit_disc \\<and>\n       u' \\<in> unit_disc \\<and>\n       v' \\<in> unit_disc \\<and>\n       w' \\<in> unit_disc \\<and>\n       w \\<noteq> u \\<and>\n       w \\<noteq> v \\<and>\n       poincare_distance u v = poincare_distance u' v' \\<and>\n       poincare_distance v w = poincare_distance v' w' \\<and>\n       poincare_distance u w = poincare_distance u' w' \\<longrightarrow>\n       (\\<exists>M.\n           unit_disc_fix_f M \\<and>\n           M u = u' \\<and> M v = v' \\<and> M w = w')", "proof (rule wlog_positive_x_axis[where P=\"?P\"])"], ["proof (state)\ngoal (5 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. u \\<noteq> v\n 4. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')\n 5. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> 0\\<^sub>h \\<and>\n                            w \\<noteq> of_complex x \\<and>\n                            poincare_distance 0\\<^sub>h (of_complex x) =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance (of_complex x) w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance 0\\<^sub>h w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M 0\\<^sub>h = u' \\<and>\n                                M (of_complex x) = v' \\<and> M w = w')", "show \"v \\<in> unit_disc\" \"u \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> unit_disc &&& u \\<in> unit_disc", "by fact+"], ["proof (state)\nthis:\n  v \\<in> unit_disc\n  u \\<in> unit_disc\n\ngoal (3 subgoals):\n 1. u \\<noteq> v\n 2. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')\n 3. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> 0\\<^sub>h \\<and>\n                            w \\<noteq> of_complex x \\<and>\n                            poincare_distance 0\\<^sub>h (of_complex x) =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance (of_complex x) w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance 0\\<^sub>h w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M 0\\<^sub>h = u' \\<and>\n                                M (of_complex x) = v' \\<and> M w = w')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. u \\<noteq> v\n 2. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')\n 3. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> 0\\<^sub>h \\<and>\n                            w \\<noteq> of_complex x \\<and>\n                            poincare_distance 0\\<^sub>h (of_complex x) =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance (of_complex x) w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance 0\\<^sub>h w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M 0\\<^sub>h = u' \\<and>\n                                M (of_complex x) = v' \\<and> M w = w')", "show \"u \\<noteq> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> v", "using False"], ["proof (prove)\nusing this:\n  \\<not> (u = v \\<or> u = w \\<or> v = w)\n\ngoal (1 subgoal):\n 1. u \\<noteq> v", "by simp"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> 0\\<^sub>h \\<and>\n                            w \\<noteq> of_complex x \\<and>\n                            poincare_distance 0\\<^sub>h (of_complex x) =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance (of_complex x) w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance 0\\<^sub>h w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M 0\\<^sub>h = u' \\<and>\n                                M (of_complex x) = v' \\<and> M w = w')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> 0\\<^sub>h \\<and>\n                            w \\<noteq> of_complex x \\<and>\n                            poincare_distance 0\\<^sub>h (of_complex x) =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance (of_complex x) w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance 0\\<^sub>h w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M 0\\<^sub>h = u' \\<and>\n                                M (of_complex x) = v' \\<and> M w = w')", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> 0\\<^sub>h \\<and>\n                            w \\<noteq> of_complex x \\<and>\n                            poincare_distance 0\\<^sub>h (of_complex x) =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance (of_complex x) w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance 0\\<^sub>h w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M 0\\<^sub>h = u' \\<and>\n                                M (of_complex x) = v' \\<and> M w = w')", "assume x: \"is_real x\" \"0 < Re x\" \"Re x < 1\""], ["proof (state)\nthis:\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> 0\\<^sub>h \\<and>\n                            w \\<noteq> of_complex x \\<and>\n                            poincare_distance 0\\<^sub>h (of_complex x) =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance (of_complex x) w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance 0\\<^sub>h w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M 0\\<^sub>h = u' \\<and>\n                                M (of_complex x) = v' \\<and> M w = w')", "hence \"of_complex x \\<noteq> 0\\<^sub>h\""], ["proof (prove)\nusing this:\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. of_complex x \\<noteq> 0\\<^sub>h", "using of_complex_zero_iff[of x]"], ["proof (prove)\nusing this:\n  is_real x\n  0 < Re x\n  Re x < 1\n  (of_complex x = 0\\<^sub>h) = (x = 0)\n\ngoal (1 subgoal):\n 1. of_complex x \\<noteq> 0\\<^sub>h", "by (auto simp add: complex.expand)"], ["proof (state)\nthis:\n  of_complex x \\<noteq> 0\\<^sub>h\n\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> 0\\<^sub>h \\<and>\n                            w \\<noteq> of_complex x \\<and>\n                            poincare_distance 0\\<^sub>h (of_complex x) =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance (of_complex x) w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance 0\\<^sub>h w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M 0\\<^sub>h = u' \\<and>\n                                M (of_complex x) = v' \\<and> M w = w')", "show \"?P 0\\<^sub>h (of_complex x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w u' v' w'.\n       w \\<in> unit_disc \\<and>\n       u' \\<in> unit_disc \\<and>\n       v' \\<in> unit_disc \\<and>\n       w' \\<in> unit_disc \\<and>\n       w \\<noteq> 0\\<^sub>h \\<and>\n       w \\<noteq> of_complex x \\<and>\n       poincare_distance 0\\<^sub>h (of_complex x) =\n       poincare_distance u' v' \\<and>\n       poincare_distance (of_complex x) w = poincare_distance v' w' \\<and>\n       poincare_distance 0\\<^sub>h w =\n       poincare_distance u' w' \\<longrightarrow>\n       (\\<exists>M.\n           unit_disc_fix_f M \\<and>\n           M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w')", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "fix w u' v' w'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "assume in_disc: \"w \\<in> unit_disc\" \"u' \\<in> unit_disc\" \"v' \\<in> unit_disc\" \"w' \\<in> unit_disc\""], ["proof (state)\nthis:\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "assume \"poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\""], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\n\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "then"], ["proof (chain)\npicking this:\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'", "obtain M' where M': \"unit_disc_fix M'\" \"moebius_pt M' u' = 0\\<^sub>h\" \"moebius_pt M' v' = (of_complex x)\""], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>unit_disc_fix M'; moebius_pt M' u' = 0\\<^sub>h;\n         moebius_pt M' v' = of_complex x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using poincare_distance_eq_ex_moebius[of u' v' \"0\\<^sub>h\" \"of_complex x\"] in_disc x"], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\n  \\<lbrakk>u' \\<in> unit_disc; v' \\<in> unit_disc;\n   0\\<^sub>h \\<in> unit_disc; of_complex x \\<in> unit_disc;\n   poincare_distance u' v' =\n   poincare_distance 0\\<^sub>h (of_complex x)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M.\n                       unit_disc_fix M \\<and>\n                       moebius_pt M u' = 0\\<^sub>h \\<and>\n                       moebius_pt M v' = of_complex x\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>unit_disc_fix M'; moebius_pt M' u' = 0\\<^sub>h;\n         moebius_pt M' v' = of_complex x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  unit_disc_fix M'\n  moebius_pt M' u' = 0\\<^sub>h\n  moebius_pt M' v' = of_complex x\n\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "let ?w = \"moebius_pt M' w'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "have \"?w \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt M' w' \\<in> unit_disc", "using \\<open>unit_disc_fix M'\\<close> \\<open>w' \\<in> unit_disc\\<close>"], ["proof (prove)\nusing this:\n  unit_disc_fix M'\n  w' \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt M' w' \\<in> unit_disc", "by simp"], ["proof (state)\nthis:\n  moebius_pt M' w' \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "assume \"w \\<noteq> 0\\<^sub>h\" \"w \\<noteq> of_complex x\""], ["proof (state)\nthis:\n  w \\<noteq> 0\\<^sub>h\n  w \\<noteq> of_complex x\n\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "hence dist_gt_0: \"poincare_distance 0\\<^sub>h w > 0\" \"poincare_distance (of_complex x) w > 0\""], ["proof (prove)\nusing this:\n  w \\<noteq> 0\\<^sub>h\n  w \\<noteq> of_complex x\n\ngoal (1 subgoal):\n 1. 0 < poincare_distance 0\\<^sub>h w &&&\n    0 < poincare_distance (of_complex x) w", "using poincare_distance_eq_0_iff[of \"0\\<^sub>h\" w] in_disc poincare_distance_ge0[of \"0\\<^sub>h\" w]"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\\<^sub>h\n  w \\<noteq> of_complex x\n  \\<lbrakk>0\\<^sub>h \\<in> unit_disc; w \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance 0\\<^sub>h w = 0) = (0\\<^sub>h = w)\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  \\<lbrakk>0\\<^sub>h \\<in> unit_disc; w \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> poincare_distance 0\\<^sub>h w\n\ngoal (1 subgoal):\n 1. 0 < poincare_distance 0\\<^sub>h w &&&\n    0 < poincare_distance (of_complex x) w", "using poincare_distance_eq_0_iff[of \"of_complex x\" w] in_disc poincare_distance_ge0[of \"of_complex x\" w]"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\\<^sub>h\n  w \\<noteq> of_complex x\n  \\<lbrakk>0\\<^sub>h \\<in> unit_disc; w \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance 0\\<^sub>h w = 0) = (0\\<^sub>h = w)\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  \\<lbrakk>0\\<^sub>h \\<in> unit_disc; w \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> poincare_distance 0\\<^sub>h w\n  \\<lbrakk>of_complex x \\<in> unit_disc; w \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance (of_complex x) w = 0) =\n                    (of_complex x = w)\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  \\<lbrakk>of_complex x \\<in> unit_disc; w \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> poincare_distance (of_complex x) w\n\ngoal (1 subgoal):\n 1. 0 < poincare_distance 0\\<^sub>h w &&&\n    0 < poincare_distance (of_complex x) w", "using x"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\\<^sub>h\n  w \\<noteq> of_complex x\n  \\<lbrakk>0\\<^sub>h \\<in> unit_disc; w \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance 0\\<^sub>h w = 0) = (0\\<^sub>h = w)\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  \\<lbrakk>0\\<^sub>h \\<in> unit_disc; w \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> poincare_distance 0\\<^sub>h w\n  \\<lbrakk>of_complex x \\<in> unit_disc; w \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance (of_complex x) w = 0) =\n                    (of_complex x = w)\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  \\<lbrakk>of_complex x \\<in> unit_disc; w \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> poincare_distance (of_complex x) w\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. 0 < poincare_distance 0\\<^sub>h w &&&\n    0 < poincare_distance (of_complex x) w", "by (simp_all add: cmod_eq_Re)"], ["proof (state)\nthis:\n  0 < poincare_distance 0\\<^sub>h w\n  0 < poincare_distance (of_complex x) w\n\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "assume \"poincare_distance (of_complex x) w = poincare_distance v' w'\"\n             \"poincare_distance 0\\<^sub>h w = poincare_distance u' w'\""], ["proof (state)\nthis:\n  poincare_distance (of_complex x) w = poincare_distance v' w'\n  poincare_distance 0\\<^sub>h w = poincare_distance u' w'\n\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "hence \"poincare_distance 0\\<^sub>h ?w = poincare_distance 0\\<^sub>h w\"\n            \"poincare_distance (of_complex x) ?w = poincare_distance (of_complex x) w\""], ["proof (prove)\nusing this:\n  poincare_distance (of_complex x) w = poincare_distance v' w'\n  poincare_distance 0\\<^sub>h w = poincare_distance u' w'\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (moebius_pt M' w') =\n    poincare_distance 0\\<^sub>h w &&&\n    poincare_distance (of_complex x) (moebius_pt M' w') =\n    poincare_distance (of_complex x) w", "using M'(1) M'(2)[symmetric] M'(3)[symmetric] in_disc"], ["proof (prove)\nusing this:\n  poincare_distance (of_complex x) w = poincare_distance v' w'\n  poincare_distance 0\\<^sub>h w = poincare_distance u' w'\n  unit_disc_fix M'\n  0\\<^sub>h = moebius_pt M' u'\n  of_complex x = moebius_pt M' v'\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (moebius_pt M' w') =\n    poincare_distance 0\\<^sub>h w &&&\n    poincare_distance (of_complex x) (moebius_pt M' w') =\n    poincare_distance (of_complex x) w", "using unit_disc_fix_preserve_poincare_distance[of M' u' w']"], ["proof (prove)\nusing this:\n  poincare_distance (of_complex x) w = poincare_distance v' w'\n  poincare_distance 0\\<^sub>h w = poincare_distance u' w'\n  unit_disc_fix M'\n  0\\<^sub>h = moebius_pt M' u'\n  of_complex x = moebius_pt M' v'\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  \\<lbrakk>unit_disc_fix M'; u' \\<in> unit_disc; w' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance (moebius_pt M' u')\n                     (moebius_pt M' w') =\n                    poincare_distance u' w'\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (moebius_pt M' w') =\n    poincare_distance 0\\<^sub>h w &&&\n    poincare_distance (of_complex x) (moebius_pt M' w') =\n    poincare_distance (of_complex x) w", "using unit_disc_fix_preserve_poincare_distance[of M' v' w']"], ["proof (prove)\nusing this:\n  poincare_distance (of_complex x) w = poincare_distance v' w'\n  poincare_distance 0\\<^sub>h w = poincare_distance u' w'\n  unit_disc_fix M'\n  0\\<^sub>h = moebius_pt M' u'\n  of_complex x = moebius_pt M' v'\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  \\<lbrakk>unit_disc_fix M'; u' \\<in> unit_disc; w' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance (moebius_pt M' u')\n                     (moebius_pt M' w') =\n                    poincare_distance u' w'\n  \\<lbrakk>unit_disc_fix M'; v' \\<in> unit_disc; w' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance (moebius_pt M' v')\n                     (moebius_pt M' w') =\n                    poincare_distance v' w'\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (moebius_pt M' w') =\n    poincare_distance 0\\<^sub>h w &&&\n    poincare_distance (of_complex x) (moebius_pt M' w') =\n    poincare_distance (of_complex x) w", "by simp_all"], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h (moebius_pt M' w') =\n  poincare_distance 0\\<^sub>h w\n  poincare_distance (of_complex x) (moebius_pt M' w') =\n  poincare_distance (of_complex x) w\n\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "hence \"?w \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter> poincare_circle (of_complex x) (poincare_distance (of_complex x) w)\"\n            \"w \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter> poincare_circle (of_complex x) (poincare_distance (of_complex x) w)\""], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (moebius_pt M' w') =\n  poincare_distance 0\\<^sub>h w\n  poincare_distance (of_complex x) (moebius_pt M' w') =\n  poincare_distance (of_complex x) w\n\ngoal (1 subgoal):\n 1. moebius_pt M' w'\n    \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter>\n          poincare_circle (of_complex x)\n           (poincare_distance (of_complex x) w) &&&\n    w \\<in> poincare_circle 0\\<^sub>h\n             (poincare_distance 0\\<^sub>h w) \\<inter>\n            poincare_circle (of_complex x)\n             (poincare_distance (of_complex x) w)", "using \\<open>?w \\<in> unit_disc\\<close> \\<open>w \\<in> unit_disc\\<close>"], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (moebius_pt M' w') =\n  poincare_distance 0\\<^sub>h w\n  poincare_distance (of_complex x) (moebius_pt M' w') =\n  poincare_distance (of_complex x) w\n  moebius_pt M' w' \\<in> unit_disc\n  w \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt M' w'\n    \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter>\n          poincare_circle (of_complex x)\n           (poincare_distance (of_complex x) w) &&&\n    w \\<in> poincare_circle 0\\<^sub>h\n             (poincare_distance 0\\<^sub>h w) \\<inter>\n            poincare_circle (of_complex x)\n             (poincare_distance (of_complex x) w)", "unfolding poincare_circle_def"], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (moebius_pt M' w') =\n  poincare_distance 0\\<^sub>h w\n  poincare_distance (of_complex x) (moebius_pt M' w') =\n  poincare_distance (of_complex x) w\n  moebius_pt M' w' \\<in> unit_disc\n  w \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt M' w'\n    \\<in> {z' \\<in> unit_disc.\n           poincare_distance 0\\<^sub>h z' =\n           poincare_distance 0\\<^sub>h w} \\<inter>\n          {z' \\<in> unit_disc.\n           poincare_distance (of_complex x) z' =\n           poincare_distance (of_complex x) w} &&&\n    w \\<in> {z' \\<in> unit_disc.\n             poincare_distance 0\\<^sub>h z' =\n             poincare_distance 0\\<^sub>h w} \\<inter>\n            {z' \\<in> unit_disc.\n             poincare_distance (of_complex x) z' =\n             poincare_distance (of_complex x) w}", "by simp_all"], ["proof (state)\nthis:\n  moebius_pt M' w'\n  \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter>\n        poincare_circle (of_complex x) (poincare_distance (of_complex x) w)\n  w \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter>\n          poincare_circle (of_complex x)\n           (poincare_distance (of_complex x) w)\n\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "hence \"?w = w \\<or> ?w = conjugate w\""], ["proof (prove)\nusing this:\n  moebius_pt M' w'\n  \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter>\n        poincare_circle (of_complex x) (poincare_distance (of_complex x) w)\n  w \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter>\n          poincare_circle (of_complex x)\n           (poincare_distance (of_complex x) w)\n\ngoal (1 subgoal):\n 1. moebius_pt M' w' = w \\<or> moebius_pt M' w' = conjugate w", "using intersect_poincare_circles_x_axis[of 0 x \"poincare_distance 0\\<^sub>h w\" \"poincare_distance (of_complex x) w\" ?w w] x"], ["proof (prove)\nusing this:\n  moebius_pt M' w'\n  \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter>\n        poincare_circle (of_complex x) (poincare_distance (of_complex x) w)\n  w \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter>\n          poincare_circle (of_complex x)\n           (poincare_distance (of_complex x) w)\n  \\<lbrakk>is_real 0; is_real x; 0 < poincare_distance 0\\<^sub>h w;\n   0 < poincare_distance (of_complex x) w; - 1 < Re 0; Re 0 < 1; - 1 < Re x;\n   Re x < 1; 0 \\<noteq> x;\n   moebius_pt M' w'\n   \\<in> poincare_circle (of_complex 0)\n          (poincare_distance 0\\<^sub>h w) \\<inter>\n         poincare_circle (of_complex x)\n          (poincare_distance (of_complex x) w);\n   w \\<in> poincare_circle (of_complex 0)\n            (poincare_distance 0\\<^sub>h w) \\<inter>\n           poincare_circle (of_complex x)\n            (poincare_distance (of_complex x) w);\n   moebius_pt M' w' \\<noteq> w\\<rbrakk>\n  \\<Longrightarrow> moebius_pt M' w' = conjugate w\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. moebius_pt M' w' = w \\<or> moebius_pt M' w' = conjugate w", "using \\<open>of_complex x \\<noteq> 0\\<^sub>h\\<close> dist_gt_0"], ["proof (prove)\nusing this:\n  moebius_pt M' w'\n  \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter>\n        poincare_circle (of_complex x) (poincare_distance (of_complex x) w)\n  w \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter>\n          poincare_circle (of_complex x)\n           (poincare_distance (of_complex x) w)\n  \\<lbrakk>is_real 0; is_real x; 0 < poincare_distance 0\\<^sub>h w;\n   0 < poincare_distance (of_complex x) w; - 1 < Re 0; Re 0 < 1; - 1 < Re x;\n   Re x < 1; 0 \\<noteq> x;\n   moebius_pt M' w'\n   \\<in> poincare_circle (of_complex 0)\n          (poincare_distance 0\\<^sub>h w) \\<inter>\n         poincare_circle (of_complex x)\n          (poincare_distance (of_complex x) w);\n   w \\<in> poincare_circle (of_complex 0)\n            (poincare_distance 0\\<^sub>h w) \\<inter>\n           poincare_circle (of_complex x)\n            (poincare_distance (of_complex x) w);\n   moebius_pt M' w' \\<noteq> w\\<rbrakk>\n  \\<Longrightarrow> moebius_pt M' w' = conjugate w\n  is_real x\n  0 < Re x\n  Re x < 1\n  of_complex x \\<noteq> 0\\<^sub>h\n  0 < poincare_distance 0\\<^sub>h w\n  0 < poincare_distance (of_complex x) w\n\ngoal (1 subgoal):\n 1. moebius_pt M' w' = w \\<or> moebius_pt M' w' = conjugate w", "using poincare_distance_eq_0_iff"], ["proof (prove)\nusing this:\n  moebius_pt M' w'\n  \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter>\n        poincare_circle (of_complex x) (poincare_distance (of_complex x) w)\n  w \\<in> poincare_circle 0\\<^sub>h (poincare_distance 0\\<^sub>h w) \\<inter>\n          poincare_circle (of_complex x)\n           (poincare_distance (of_complex x) w)\n  \\<lbrakk>is_real 0; is_real x; 0 < poincare_distance 0\\<^sub>h w;\n   0 < poincare_distance (of_complex x) w; - 1 < Re 0; Re 0 < 1; - 1 < Re x;\n   Re x < 1; 0 \\<noteq> x;\n   moebius_pt M' w'\n   \\<in> poincare_circle (of_complex 0)\n          (poincare_distance 0\\<^sub>h w) \\<inter>\n         poincare_circle (of_complex x)\n          (poincare_distance (of_complex x) w);\n   w \\<in> poincare_circle (of_complex 0)\n            (poincare_distance 0\\<^sub>h w) \\<inter>\n           poincare_circle (of_complex x)\n            (poincare_distance (of_complex x) w);\n   moebius_pt M' w' \\<noteq> w\\<rbrakk>\n  \\<Longrightarrow> moebius_pt M' w' = conjugate w\n  is_real x\n  0 < Re x\n  Re x < 1\n  of_complex x \\<noteq> 0\\<^sub>h\n  0 < poincare_distance 0\\<^sub>h w\n  0 < poincare_distance (of_complex x) w\n  \\<lbrakk>?u \\<in> unit_disc; ?v \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance ?u ?v = 0) = (?u = ?v)\n\ngoal (1 subgoal):\n 1. moebius_pt M' w' = w \\<or> moebius_pt M' w' = conjugate w", "by auto"], ["proof (state)\nthis:\n  moebius_pt M' w' = w \\<or> moebius_pt M' w' = conjugate w\n\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> 0\\<^sub>h; w \\<noteq> of_complex x;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v';\n        poincare_distance (of_complex x) w = poincare_distance v' w';\n        poincare_distance 0\\<^sub>h w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M 0\\<^sub>h = u' \\<and>\n                            M (of_complex x) = v' \\<and> M w = w'", "thus \"\\<exists>M. unit_disc_fix_f M \\<and> M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'\""], ["proof (prove)\nusing this:\n  moebius_pt M' w' = w \\<or> moebius_pt M' w' = conjugate w\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. moebius_pt M' w' = w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'\n 2. moebius_pt M' w' = conjugate w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "assume \"moebius_pt M' w' = w\""], ["proof (state)\nthis:\n  moebius_pt M' w' = w\n\ngoal (2 subgoals):\n 1. moebius_pt M' w' = w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'\n 2. moebius_pt M' w' = conjugate w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "thus ?thesis"], ["proof (prove)\nusing this:\n  moebius_pt M' w' = w\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "using M'"], ["proof (prove)\nusing this:\n  moebius_pt M' w' = w\n  unit_disc_fix M'\n  moebius_pt M' u' = 0\\<^sub>h\n  moebius_pt M' v' = of_complex x\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "using moebius_pt_invert[of M' u' \"0\\<^sub>h\"]"], ["proof (prove)\nusing this:\n  moebius_pt M' w' = w\n  unit_disc_fix M'\n  moebius_pt M' u' = 0\\<^sub>h\n  moebius_pt M' v' = of_complex x\n  moebius_pt M' u' = 0\\<^sub>h \\<Longrightarrow>\n  moebius_pt (moebius_inv M') 0\\<^sub>h = u'\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "using moebius_pt_invert[of M' v' \"of_complex x\"]"], ["proof (prove)\nusing this:\n  moebius_pt M' w' = w\n  unit_disc_fix M'\n  moebius_pt M' u' = 0\\<^sub>h\n  moebius_pt M' v' = of_complex x\n  moebius_pt M' u' = 0\\<^sub>h \\<Longrightarrow>\n  moebius_pt (moebius_inv M') 0\\<^sub>h = u'\n  moebius_pt M' v' = of_complex x \\<Longrightarrow>\n  moebius_pt (moebius_inv M') (of_complex x) = v'\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "using moebius_pt_invert[of M' w' \"w\"]"], ["proof (prove)\nusing this:\n  moebius_pt M' w' = w\n  unit_disc_fix M'\n  moebius_pt M' u' = 0\\<^sub>h\n  moebius_pt M' v' = of_complex x\n  moebius_pt M' u' = 0\\<^sub>h \\<Longrightarrow>\n  moebius_pt (moebius_inv M') 0\\<^sub>h = u'\n  moebius_pt M' v' = of_complex x \\<Longrightarrow>\n  moebius_pt (moebius_inv M') (of_complex x) = v'\n  moebius_pt M' w' = w \\<Longrightarrow> moebius_pt (moebius_inv M') w = w'\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "apply (rule_tac x=\"moebius_pt (-M')\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>moebius_pt M' w' = w; unit_disc_fix M';\n     moebius_pt M' u' = 0\\<^sub>h; moebius_pt M' v' = of_complex x;\n     moebius_pt M' u' = 0\\<^sub>h \\<Longrightarrow>\n     moebius_pt (moebius_inv M') 0\\<^sub>h = u';\n     moebius_pt M' v' = of_complex x \\<Longrightarrow>\n     moebius_pt (moebius_inv M') (of_complex x) = v';\n     moebius_pt M' w' = w \\<Longrightarrow>\n     moebius_pt (moebius_inv M') w = w'\\<rbrakk>\n    \\<Longrightarrow> unit_disc_fix_f (moebius_pt (- M')) \\<and>\n                      moebius_pt (- M') 0\\<^sub>h = u' \\<and>\n                      moebius_pt (- M') (of_complex x) = v' \\<and>\n                      moebius_pt (- M') w = w'", "apply (simp add: unit_disc_fix_f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>moebius_pt M' w' = w; unit_disc_fix M';\n     moebius_pt M' u' = 0\\<^sub>h; moebius_pt M' v' = of_complex x;\n     moebius_pt (moebius_inv M') 0\\<^sub>h = u';\n     moebius_pt (moebius_inv M') (of_complex x) = v';\n     moebius_pt (moebius_inv M') w = w'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M.\n                         unit_disc_fix M \\<and>\n                         (moebius_pt (moebius_inv M') = moebius_pt M \\<or>\n                          moebius_pt (moebius_inv M') =\n                          moebius_pt M \\<circ> conjugate)", "apply (rule_tac x=\"-M'\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>M.\n     unit_disc_fix_f M \\<and>\n     M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'\n\ngoal (1 subgoal):\n 1. moebius_pt M' w' = conjugate w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. moebius_pt M' w' = conjugate w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "let ?M = \"moebius_pt (-M') \\<circ> conjugate\""], ["proof (state)\ngoal (1 subgoal):\n 1. moebius_pt M' w' = conjugate w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "assume \"moebius_pt M' w' = conjugate w\""], ["proof (state)\nthis:\n  moebius_pt M' w' = conjugate w\n\ngoal (1 subgoal):\n 1. moebius_pt M' w' = conjugate w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "hence \"?M w = w'\""], ["proof (prove)\nusing this:\n  moebius_pt M' w' = conjugate w\n\ngoal (1 subgoal):\n 1. (moebius_pt (- M') \\<circ> conjugate) w = w'", "using moebius_pt_invert[of  M' w' \"conjugate w\"]"], ["proof (prove)\nusing this:\n  moebius_pt M' w' = conjugate w\n  moebius_pt M' w' = conjugate w \\<Longrightarrow>\n  moebius_pt (moebius_inv M') (conjugate w) = w'\n\ngoal (1 subgoal):\n 1. (moebius_pt (- M') \\<circ> conjugate) w = w'", "by simp"], ["proof (state)\nthis:\n  (moebius_pt (- M') \\<circ> conjugate) w = w'\n\ngoal (1 subgoal):\n 1. moebius_pt M' w' = conjugate w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "moreover"], ["proof (state)\nthis:\n  (moebius_pt (- M') \\<circ> conjugate) w = w'\n\ngoal (1 subgoal):\n 1. moebius_pt M' w' = conjugate w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "have \"?M 0\\<^sub>h = u'\" \"?M (of_complex x) = v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (moebius_pt (- M') \\<circ> conjugate) 0\\<^sub>h = u' &&&\n    (moebius_pt (- M') \\<circ> conjugate) (of_complex x) = v'", "using moebius_pt_invert[of M' u' \"0\\<^sub>h\"]"], ["proof (prove)\nusing this:\n  moebius_pt M' u' = 0\\<^sub>h \\<Longrightarrow>\n  moebius_pt (moebius_inv M') 0\\<^sub>h = u'\n\ngoal (1 subgoal):\n 1. (moebius_pt (- M') \\<circ> conjugate) 0\\<^sub>h = u' &&&\n    (moebius_pt (- M') \\<circ> conjugate) (of_complex x) = v'", "using moebius_pt_invert[of M' v' \"of_complex x\"]"], ["proof (prove)\nusing this:\n  moebius_pt M' u' = 0\\<^sub>h \\<Longrightarrow>\n  moebius_pt (moebius_inv M') 0\\<^sub>h = u'\n  moebius_pt M' v' = of_complex x \\<Longrightarrow>\n  moebius_pt (moebius_inv M') (of_complex x) = v'\n\ngoal (1 subgoal):\n 1. (moebius_pt (- M') \\<circ> conjugate) 0\\<^sub>h = u' &&&\n    (moebius_pt (- M') \\<circ> conjugate) (of_complex x) = v'", "using M' \\<open>is_real x\\<close> eq_cnj_iff_real[of x]"], ["proof (prove)\nusing this:\n  moebius_pt M' u' = 0\\<^sub>h \\<Longrightarrow>\n  moebius_pt (moebius_inv M') 0\\<^sub>h = u'\n  moebius_pt M' v' = of_complex x \\<Longrightarrow>\n  moebius_pt (moebius_inv M') (of_complex x) = v'\n  unit_disc_fix M'\n  moebius_pt M' u' = 0\\<^sub>h\n  moebius_pt M' v' = of_complex x\n  is_real x\n  (cnj x = x) = is_real x\n\ngoal (1 subgoal):\n 1. (moebius_pt (- M') \\<circ> conjugate) 0\\<^sub>h = u' &&&\n    (moebius_pt (- M') \\<circ> conjugate) (of_complex x) = v'", "by simp_all"], ["proof (state)\nthis:\n  (moebius_pt (- M') \\<circ> conjugate) 0\\<^sub>h = u'\n  (moebius_pt (- M') \\<circ> conjugate) (of_complex x) = v'\n\ngoal (1 subgoal):\n 1. moebius_pt M' w' = conjugate w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "moreover"], ["proof (state)\nthis:\n  (moebius_pt (- M') \\<circ> conjugate) 0\\<^sub>h = u'\n  (moebius_pt (- M') \\<circ> conjugate) (of_complex x) = v'\n\ngoal (1 subgoal):\n 1. moebius_pt M' w' = conjugate w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "have \"unit_disc_fix_f ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_disc_fix_f (moebius_pt (- M') \\<circ> conjugate)", "using \\<open>unit_disc_fix M'\\<close>"], ["proof (prove)\nusing this:\n  unit_disc_fix M'\n\ngoal (1 subgoal):\n 1. unit_disc_fix_f (moebius_pt (- M') \\<circ> conjugate)", "unfolding unit_disc_fix_f_def"], ["proof (prove)\nusing this:\n  unit_disc_fix M'\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix M \\<and>\n       (moebius_pt (- M') \\<circ> conjugate = moebius_pt M \\<or>\n        moebius_pt (- M') \\<circ> conjugate =\n        moebius_pt M \\<circ> conjugate)", "by (rule_tac x=\"-M'\" in exI, simp)"], ["proof (state)\nthis:\n  unit_disc_fix_f (moebius_pt (- M') \\<circ> conjugate)\n\ngoal (1 subgoal):\n 1. moebius_pt M' w' = conjugate w \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "ultimately"], ["proof (chain)\npicking this:\n  (moebius_pt (- M') \\<circ> conjugate) w = w'\n  (moebius_pt (- M') \\<circ> conjugate) 0\\<^sub>h = u'\n  (moebius_pt (- M') \\<circ> conjugate) (of_complex x) = v'\n  unit_disc_fix_f (moebius_pt (- M') \\<circ> conjugate)", "show ?thesis"], ["proof (prove)\nusing this:\n  (moebius_pt (- M') \\<circ> conjugate) w = w'\n  (moebius_pt (- M') \\<circ> conjugate) 0\\<^sub>h = u'\n  (moebius_pt (- M') \\<circ> conjugate) (of_complex x) = v'\n  unit_disc_fix_f (moebius_pt (- M') \\<circ> conjugate)\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and>\n       M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'", "by blast"], ["proof (state)\nthis:\n  \\<exists>M.\n     unit_disc_fix_f M \\<and>\n     M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>M.\n     unit_disc_fix_f M \\<and>\n     M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>w u' v' w'.\n     w \\<in> unit_disc \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     w' \\<in> unit_disc \\<and>\n     w \\<noteq> 0\\<^sub>h \\<and>\n     w \\<noteq> of_complex x \\<and>\n     poincare_distance 0\\<^sub>h (of_complex x) =\n     poincare_distance u' v' \\<and>\n     poincare_distance (of_complex x) w = poincare_distance v' w' \\<and>\n     poincare_distance 0\\<^sub>h w =\n     poincare_distance u' w' \\<longrightarrow>\n     (\\<exists>M.\n         unit_disc_fix_f M \\<and>\n         M 0\\<^sub>h = u' \\<and> M (of_complex x) = v' \\<and> M w = w')\n\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')", "fix M u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')", "assume 1: \"unit_disc_fix M\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\""], ["proof (state)\nthis:\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')", "let ?Mu = \"moebius_pt M u\" and ?Mv = \"moebius_pt M v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')", "assume 2: \"?P ?Mu ?Mv\""], ["proof (state)\nthis:\n  \\<forall>w u' v' w'.\n     w \\<in> unit_disc \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     w' \\<in> unit_disc \\<and>\n     w \\<noteq> moebius_pt M u \\<and>\n     w \\<noteq> moebius_pt M v \\<and>\n     poincare_distance (moebius_pt M u) (moebius_pt M v) =\n     poincare_distance u' v' \\<and>\n     poincare_distance (moebius_pt M v) w = poincare_distance v' w' \\<and>\n     poincare_distance (moebius_pt M u) w =\n     poincare_distance u' w' \\<longrightarrow>\n     (\\<exists>Ma.\n         unit_disc_fix_f Ma \\<and>\n         Ma (moebius_pt M u) = u' \\<and>\n         Ma (moebius_pt M v) = v' \\<and> Ma w = w')\n\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>w u' v' w'.\n           w \\<in> unit_disc \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           w' \\<in> unit_disc \\<and>\n           w \\<noteq> moebius_pt M u \\<and>\n           w \\<noteq> moebius_pt M v \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<and>\n           poincare_distance (moebius_pt M v) w =\n           poincare_distance v' w' \\<and>\n           poincare_distance (moebius_pt M u) w =\n           poincare_distance u' w' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix_f Ma \\<and>\n               Ma (moebius_pt M u) = u' \\<and>\n               Ma (moebius_pt M v) = v' \\<and> Ma w = w')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w u' v' w'.\n                            w \\<in> unit_disc \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            w' \\<in> unit_disc \\<and>\n                            w \\<noteq> u \\<and>\n                            w \\<noteq> v \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<and>\n                            poincare_distance v w =\n                            poincare_distance v' w' \\<and>\n                            poincare_distance u w =\n                            poincare_distance u' w' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix_f M \\<and>\n                                M u = u' \\<and> M v = v' \\<and> M w = w')", "show \"?P u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w u' v' w'.\n       w \\<in> unit_disc \\<and>\n       u' \\<in> unit_disc \\<and>\n       v' \\<in> unit_disc \\<and>\n       w' \\<in> unit_disc \\<and>\n       w \\<noteq> u \\<and>\n       w \\<noteq> v \\<and>\n       poincare_distance u v = poincare_distance u' v' \\<and>\n       poincare_distance v w = poincare_distance v' w' \\<and>\n       poincare_distance u w = poincare_distance u' w' \\<longrightarrow>\n       (\\<exists>M.\n           unit_disc_fix_f M \\<and>\n           M u = u' \\<and> M v = v' \\<and> M w = w')", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> u; w \\<noteq> v;\n        poincare_distance u v = poincare_distance u' v';\n        poincare_distance v w = poincare_distance v' w';\n        poincare_distance u w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M u = u' \\<and> M v = v' \\<and> M w = w'", "fix w u' v' w'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> u; w \\<noteq> v;\n        poincare_distance u v = poincare_distance u' v';\n        poincare_distance v w = poincare_distance v' w';\n        poincare_distance u w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M u = u' \\<and> M v = v' \\<and> M w = w'", "let ?Mw = \"moebius_pt M w\" and ?Mu' = \"moebius_pt M u'\" and ?Mv' = \"moebius_pt M v'\" and ?Mw' = \"moebius_pt M w'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> u; w \\<noteq> v;\n        poincare_distance u v = poincare_distance u' v';\n        poincare_distance v w = poincare_distance v' w';\n        poincare_distance u w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M u = u' \\<and> M v = v' \\<and> M w = w'", "assume \"w \\<in> unit_disc\" \"u' \\<in> unit_disc\" \"v' \\<in> unit_disc\" \"w' \\<in> unit_disc\" \"w \\<noteq> u\" \"w \\<noteq> v\"\n             \"poincare_distance u v = poincare_distance u' v'\"\n             \"poincare_distance v w = poincare_distance v' w'\"\n             \"poincare_distance u w = poincare_distance u' w'\""], ["proof (state)\nthis:\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  w \\<noteq> u\n  w \\<noteq> v\n  poincare_distance u v = poincare_distance u' v'\n  poincare_distance v w = poincare_distance v' w'\n  poincare_distance u w = poincare_distance u' w'\n\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> u; w \\<noteq> v;\n        poincare_distance u v = poincare_distance u' v';\n        poincare_distance v w = poincare_distance v' w';\n        poincare_distance u w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M u = u' \\<and> M v = v' \\<and> M w = w'", "then"], ["proof (chain)\npicking this:\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  w \\<noteq> u\n  w \\<noteq> v\n  poincare_distance u v = poincare_distance u' v'\n  poincare_distance v w = poincare_distance v' w'\n  poincare_distance u w = poincare_distance u' w'", "obtain M' where M': \"unit_disc_fix_f M'\" \"M' ?Mu = ?Mu'\" \"M' ?Mv = ?Mv'\" \"M' ?Mw = ?Mw'\""], ["proof (prove)\nusing this:\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  w \\<noteq> u\n  w \\<noteq> v\n  poincare_distance u v = poincare_distance u' v'\n  poincare_distance v w = poincare_distance v' w'\n  poincare_distance u w = poincare_distance u' w'\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>unit_disc_fix_f M'; M' (moebius_pt M u) = moebius_pt M u';\n         M' (moebius_pt M v) = moebius_pt M v';\n         M' (moebius_pt M w) = moebius_pt M w'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1 2[rule_format, of ?Mw ?Mu' ?Mv' ?Mw']"], ["proof (prove)\nusing this:\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  w \\<noteq> u\n  w \\<noteq> v\n  poincare_distance u v = poincare_distance u' v'\n  poincare_distance v w = poincare_distance v' w'\n  poincare_distance u w = poincare_distance u' w'\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  moebius_pt M w \\<in> unit_disc \\<and>\n  moebius_pt M u' \\<in> unit_disc \\<and>\n  moebius_pt M v' \\<in> unit_disc \\<and>\n  moebius_pt M w' \\<in> unit_disc \\<and>\n  moebius_pt M w \\<noteq> moebius_pt M u \\<and>\n  moebius_pt M w \\<noteq> moebius_pt M v \\<and>\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  poincare_distance (moebius_pt M u') (moebius_pt M v') \\<and>\n  poincare_distance (moebius_pt M v) (moebius_pt M w) =\n  poincare_distance (moebius_pt M v') (moebius_pt M w') \\<and>\n  poincare_distance (moebius_pt M u) (moebius_pt M w) =\n  poincare_distance (moebius_pt M u') (moebius_pt M w') \\<Longrightarrow>\n  \\<exists>Ma.\n     unit_disc_fix_f Ma \\<and>\n     Ma (moebius_pt M u) = moebius_pt M u' \\<and>\n     Ma (moebius_pt M v) = moebius_pt M v' \\<and>\n     Ma (moebius_pt M w) = moebius_pt M w'\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>unit_disc_fix_f M'; M' (moebius_pt M u) = moebius_pt M u';\n         M' (moebius_pt M v) = moebius_pt M v';\n         M' (moebius_pt M w) = moebius_pt M w'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unit_disc_fix_f M'\n  M' (moebius_pt M u) = moebius_pt M u'\n  M' (moebius_pt M v) = moebius_pt M v'\n  M' (moebius_pt M w) = moebius_pt M w'\n\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> u; w \\<noteq> v;\n        poincare_distance u v = poincare_distance u' v';\n        poincare_distance v w = poincare_distance v' w';\n        poincare_distance u w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M u = u' \\<and> M v = v' \\<and> M w = w'", "let ?M = \"moebius_pt (-M) \\<circ> M' \\<circ> moebius_pt M\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w u' v' w'.\n       \\<lbrakk>w \\<in> unit_disc; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        w' \\<in> unit_disc; w \\<noteq> u; w \\<noteq> v;\n        poincare_distance u v = poincare_distance u' v';\n        poincare_distance v w = poincare_distance v' w';\n        poincare_distance u w = poincare_distance u' w'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix_f M \\<and>\n                            M u = u' \\<and> M v = v' \\<and> M w = w'", "show \"\\<exists>M. unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "proof (rule_tac x=\"?M\" in exI, safe)"], ["proof (state)\ngoal (4 subgoals):\n 1. unit_disc_fix_f (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M)\n 2. (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) u = u'\n 3. (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) v = v'\n 4. (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) w = w'", "show \"unit_disc_fix_f ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_disc_fix_f (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M)", "using M'(1) \\<open>unit_disc_fix M\\<close>"], ["proof (prove)\nusing this:\n  unit_disc_fix_f M'\n  unit_disc_fix M\n\ngoal (1 subgoal):\n 1. unit_disc_fix_f (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M)", "by (subst unit_disc_fix_f_comp, subst unit_disc_fix_f_comp, simp_all)"], ["proof (state)\nthis:\n  unit_disc_fix_f (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M)\n\ngoal (3 subgoals):\n 1. (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) u = u'\n 2. (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) v = v'\n 3. (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) w = w'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) u = u'\n 2. (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) v = v'\n 3. (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) w = w'", "show \"?M u = u'\" \"?M v = v'\" \"?M w = w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) u = u' &&&\n    (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) v = v' &&&\n    (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) w = w'", "using M'"], ["proof (prove)\nusing this:\n  unit_disc_fix_f M'\n  M' (moebius_pt M u) = moebius_pt M u'\n  M' (moebius_pt M v) = moebius_pt M v'\n  M' (moebius_pt M w) = moebius_pt M w'\n\ngoal (1 subgoal):\n 1. (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) u = u' &&&\n    (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) v = v' &&&\n    (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) w = w'", "by auto"], ["proof (state)\nthis:\n  (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) u = u'\n  (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) v = v'\n  (moebius_pt (- M) \\<circ> M' \\<circ> moebius_pt M) w = w'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>M.\n     unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>w u' v' w'.\n     w \\<in> unit_disc \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     w' \\<in> unit_disc \\<and>\n     w \\<noteq> u \\<and>\n     w \\<noteq> v \\<and>\n     poincare_distance u v = poincare_distance u' v' \\<and>\n     poincare_distance v w = poincare_distance v' w' \\<and>\n     poincare_distance u w = poincare_distance u' w' \\<longrightarrow>\n     (\\<exists>M.\n         unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>w u' v' w'.\n     w \\<in> unit_disc \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     w' \\<in> unit_disc \\<and>\n     w \\<noteq> u \\<and>\n     w \\<noteq> v \\<and>\n     poincare_distance u v = poincare_distance u' v' \\<and>\n     poincare_distance v w = poincare_distance v' w' \\<and>\n     poincare_distance u w = poincare_distance u' w' \\<longrightarrow>\n     (\\<exists>M.\n         unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w')\n\ngoal (1 subgoal):\n 1. \\<not> (u = v \\<or> u = w \\<or> v = w) \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>w u' v' w'.\n     w \\<in> unit_disc \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     w' \\<in> unit_disc \\<and>\n     w \\<noteq> u \\<and>\n     w \\<noteq> v \\<and>\n     poincare_distance u v = poincare_distance u' v' \\<and>\n     poincare_distance v w = poincare_distance v' w' \\<and>\n     poincare_distance u w = poincare_distance u' w' \\<longrightarrow>\n     (\\<exists>M.\n         unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w')\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "using assms False"], ["proof (prove)\nusing this:\n  \\<forall>w u' v' w'.\n     w \\<in> unit_disc \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     w' \\<in> unit_disc \\<and>\n     w \\<noteq> u \\<and>\n     w \\<noteq> v \\<and>\n     poincare_distance u v = poincare_distance u' v' \\<and>\n     poincare_distance v w = poincare_distance v' w' \\<and>\n     poincare_distance u w = poincare_distance u' w' \\<longrightarrow>\n     (\\<exists>M.\n         unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w')\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  w \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  w' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n  poincare_distance v w = poincare_distance v' w'\n  poincare_distance u w = poincare_distance u' w'\n  \\<not> (u = v \\<or> u = w \\<or> v = w)\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'", "by auto"], ["proof (state)\nthis:\n  \\<exists>M.\n     unit_disc_fix_f M \\<and> M u = u' \\<and> M v = v' \\<and> M w = w'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}