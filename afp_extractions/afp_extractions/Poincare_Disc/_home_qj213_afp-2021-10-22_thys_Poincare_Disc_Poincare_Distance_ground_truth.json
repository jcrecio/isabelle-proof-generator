{"file_name": "/home/qj213/afp-2021-10-22/thys/Poincare_Disc/Poincare_Distance.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Poincare_Disc", "problem_names": ["lemma distance_cross_ratio_real_positive:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\" and \"u \\<noteq> v\"\n  shows \"\\<forall> i1 i2. ideal_points (poincare_line u v) = {i1, i2} \\<longrightarrow> \n                  cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h \\<and> is_real (to_complex (cross_ratio u i1 v i2)) \\<and> Re_cross_ratio u i1 v i2 > 0\" (is \"?P u v\")", "lemma distance_unique:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"\\<exists>! d. poincare_distance_pred u v d\"", "lemma poincare_distance_satisfies_pred [simp]:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance_pred u v (poincare_distance u v)\"", "lemma poincare_distance_I:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\" and \"u \\<noteq> v\" and \"ideal_points (poincare_line u v) = {i1, i2}\"\n  shows \"poincare_distance u v = calc_poincare_distance u i1 v i2\"", "lemma poincare_distance_refl [simp]:\n  assumes \"u \\<in> unit_disc\"\n  shows \"poincare_distance u u = 0\"", "lemma unit_disc_fix_preserve_poincare_distance [simp]:\n  assumes \"unit_disc_fix M\" and \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance (moebius_pt M u) (moebius_pt M v) = poincare_distance u v\"", "lemma poincare_distance_x_axis_x_axis:\n  assumes \"x \\<in> unit_disc\" and \"y \\<in> unit_disc\" and \"x \\<in> circline_set x_axis\" and \"y \\<in> circline_set x_axis\"\n  shows \"poincare_distance x y =\n            (let x' = to_complex x; y' = to_complex y\n              in abs (ln (Re (((1 + x') * (1 - y')) / ((1 - x') * (1 + y'))))))\"", "lemma poincare_distance_zero_x_axis:\n  assumes \"x \\<in> unit_disc\" and \"x \\<in> circline_set x_axis\"\n  shows \"poincare_distance 0\\<^sub>h x = (let x' = to_complex x in abs (ln (Re ((1 - x') / (1 + x')))))\"", "lemma poincare_distance_zero:\n  assumes \"x \\<in> unit_disc\"\n  shows \"poincare_distance 0\\<^sub>h x = (let x' = to_complex x in abs (ln (Re ((1 - cmod x') / (1 + cmod x')))))\" (is \"?P x\")", "lemma poincare_distance_zero_opposite [simp]:\n  assumes \"of_complex z \\<in> unit_disc\"\n  shows \"poincare_distance 0\\<^sub>h (of_complex (- z)) = poincare_distance 0\\<^sub>h (of_complex z)\"", "lemma cosh_poincare_distance_cross_ratio_average:\n  assumes \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\" \"ideal_points (poincare_line u v) = {i1, i2}\"\n  shows \"cosh_dist u v =\n           ((Re_cross_ratio u i1 v i2) + (Re_cross_ratio v i1 u i2)) / 2\"", "lemma blaschke_preserve_distance_formula [simp]:\n  assumes \"of_complex k \\<in> unit_disc\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\"\n  shows \"poincare_distance_formula (to_complex (moebius_pt (blaschke k) u)) (to_complex (moebius_pt (blaschke k) v)) =\n         poincare_distance_formula (to_complex u) (to_complex v)\"", "lemma rotation_preserve_distance_formula [simp]:\n  assumes \"u \\<in> unit_disc\" \"v \\<in> unit_disc\"\n  shows \"poincare_distance_formula (to_complex (moebius_pt (moebius_rotation \\<phi>) u)) (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n         poincare_distance_formula (to_complex u) (to_complex v)\"", "lemma unit_disc_fix_preserve_distance_formula [simp]:\n  assumes \"unit_disc_fix M\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\"\n  shows \"poincare_distance_formula (to_complex (moebius_pt M u)) (to_complex (moebius_pt M v)) =\n         poincare_distance_formula (to_complex u) (to_complex v)\" (is \"?P' u v M\")", "lemma poincare_distance_formula:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance u v = poincare_distance_formula (to_complex u) (to_complex v)\" (is \"?P u v\")", "lemma poincare_distance_sym:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance u v = poincare_distance v u\"", "lemma poincare_distance_formula'_ge_1:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"1 \\<le> poincare_distance_formula' (to_complex u) (to_complex v)\"", "lemma poincare_distance_ge0:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance u v \\<ge> 0\"", "lemma cosh_dist:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"cosh_dist u v = poincare_distance_formula' (to_complex u) (to_complex v)\"", "lemma poincare_distance_eq_0_iff:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance u v = 0 \\<longleftrightarrow> u = v\"", "lemma conjugate_preserve_poincare_distance [simp]:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance (conjugate u) (conjugate v) = poincare_distance u v\"", "lemma ex_x_axis_poincare_distance_negative':\n  fixes d :: real\n  assumes \"d \\<ge> 0\"\n  shows \"let z = (1 - exp d) / (1 + exp d)\n          in is_real z \\<and> Re z \\<le> 0 \\<and> Re z > -1 \\<and>\n              of_complex z \\<in> unit_disc \\<and> of_complex z \\<in> circline_set x_axis \\<and>\n              poincare_distance 0\\<^sub>h (of_complex z) = d\"", "lemma ex_x_axis_poincare_distance_negative:\n  assumes \"d \\<ge> 0\"\n  shows \"\\<exists> z. is_real z \\<and> Re z \\<le> 0 \\<and> Re z > -1 \\<and>\n              of_complex z \\<in> unit_disc \\<and> of_complex z \\<in> circline_set x_axis \\<and>\n              poincare_distance 0\\<^sub>h (of_complex z) = d\" (is \"\\<exists> z. ?P z\")", "lemma unique_x_axis_poincare_distance_negative:\n  assumes \"d \\<ge> 0\"\n  shows \"\\<exists>! z. is_real z \\<and> Re z \\<le> 0 \\<and> Re z > -1 \\<and>\n              poincare_distance 0\\<^sub>h (of_complex z) = d\" (is \"\\<exists>! z. ?P z\")", "lemma ex_x_axis_poincare_distance_positive:\n  assumes \"d \\<ge> 0\"\n  shows \"\\<exists> z. is_real z \\<and> Re z \\<ge> 0 \\<and> Re z < 1 \\<and>\n              of_complex z \\<in> unit_disc \\<and> of_complex z \\<in> circline_set x_axis \\<and>\n              poincare_distance 0\\<^sub>h (of_complex z) = d\" (is \"\\<exists> z. is_real z \\<and> Re z \\<ge> 0 \\<and> Re z < 1 \\<and> ?P z\")", "lemma unique_x_axis_poincare_distance_positive:\n  assumes \"d \\<ge> 0\"\n  shows \"\\<exists>! z. is_real z \\<and> Re z \\<ge> 0 \\<and> Re z < 1 \\<and>\n               poincare_distance 0\\<^sub>h (of_complex z) = d\" (is \"\\<exists>! z. is_real z \\<and> Re z \\<ge> 0 \\<and> Re z < 1 \\<and> ?P z\")", "lemma poincare_distance_eq_ex_moebius:\n  assumes in_disc: \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\" and \"u' \\<in> unit_disc\" and \"v' \\<in> unit_disc\"\n  assumes \"poincare_distance u v = poincare_distance u' v'\"\n  shows \"\\<exists> M. unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'\" (is \"?P' u v u' v'\")", "lemma unique_midpoint_x_axis:\n  assumes x: \"is_real x\" \"-1 < Re x\" \"Re x < 1\" and\n          y: \"is_real y\" \"-1 < Re y\" \"Re y < 1\" and\n          \"x \\<noteq> y\"\n  shows \"\\<exists>! z. -1 < Re z \\<and> Re z < 1 \\<and> is_real z \\<and> poincare_distance (of_complex z) (of_complex x) = poincare_distance (of_complex z) (of_complex y)\" (is \"\\<exists>! z. ?R z (of_complex x) (of_complex y)\")", "lemma poincare_distance_formula_zero_sum:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n         (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n           in arcosh (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') / ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))\"", "lemma poincare_distance_triangle_inequality:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\" and \"w \\<in> unit_disc\"\n  shows \"poincare_distance u v + poincare_distance v w \\<ge> poincare_distance u w\" (is \"?P' u v w\")"], "translations": [["", "lemma distance_cross_ratio_real_positive:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\" and \"u \\<noteq> v\"\n  shows \"\\<forall> i1 i2. ideal_points (poincare_line u v) = {i1, i2} \\<longrightarrow> \n                  cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h \\<and> is_real (to_complex (cross_ratio u i1 v i2)) \\<and> Re_cross_ratio u i1 v i2 > 0\" (is \"?P u v\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<longrightarrow>\n       cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h \\<and>\n       is_real (to_complex (cross_ratio u i1 v i2)) \\<and>\n       0 < Re_cross_ratio u i1 v i2", "proof (rule wlog_positive_x_axis[OF assms])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points\n                             (poincare_line 0\\<^sub>h (of_complex x)) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio 0\\<^sub>h i1 (of_complex x)\n                             i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex\n                               (cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2)) \\<and>\n                            0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points\n                             (poincare_line 0\\<^sub>h (of_complex x)) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio 0\\<^sub>h i1 (of_complex x)\n                             i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex\n                               (cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2)) \\<and>\n                            0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2", "assume *: \"is_real x\" \"0 < Re x\" \"Re x < 1\""], ["proof (state)\nthis:\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points\n                             (poincare_line 0\\<^sub>h (of_complex x)) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio 0\\<^sub>h i1 (of_complex x)\n                             i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex\n                               (cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2)) \\<and>\n                            0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2", "hence \"x \\<noteq> -1\" \"x \\<noteq> 1\""], ["proof (prove)\nusing this:\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> - 1 &&& x \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> - 1\n  x \\<noteq> 1\n\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points\n                             (poincare_line 0\\<^sub>h (of_complex x)) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio 0\\<^sub>h i1 (of_complex x)\n                             i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex\n                               (cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2)) \\<and>\n                            0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2", "hence **: \"of_complex x \\<noteq> \\<infinity>\\<^sub>h\" \"of_complex x \\<noteq> 0\\<^sub>h\" \"of_complex x \\<noteq> of_complex (-1)\" \"of_complex 1 \\<noteq> of_complex x\"\n        \"of_complex x \\<in> circline_set x_axis\""], ["proof (prove)\nusing this:\n  x \\<noteq> - 1\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (of_complex x \\<noteq> \\<infinity>\\<^sub>h &&&\n     of_complex x \\<noteq> 0\\<^sub>h) &&&\n    of_complex x \\<noteq> of_complex (- 1) &&&\n    of_complex 1 \\<noteq> of_complex x &&&\n    of_complex x \\<in> circline_set x_axis", "using *"], ["proof (prove)\nusing this:\n  x \\<noteq> - 1\n  x \\<noteq> 1\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. (of_complex x \\<noteq> \\<infinity>\\<^sub>h &&&\n     of_complex x \\<noteq> 0\\<^sub>h) &&&\n    of_complex x \\<noteq> of_complex (- 1) &&&\n    of_complex 1 \\<noteq> of_complex x &&&\n    of_complex x \\<in> circline_set x_axis", "unfolding circline_set_x_axis"], ["proof (prove)\nusing this:\n  x \\<noteq> - 1\n  x \\<noteq> 1\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. (of_complex x \\<noteq> \\<infinity>\\<^sub>h &&&\n     of_complex x \\<noteq> 0\\<^sub>h) &&&\n    of_complex x \\<noteq> of_complex (- 1) &&&\n    of_complex 1 \\<noteq> of_complex x &&&\n    of_complex x\n    \\<in> of_complex ` {x. is_real x} \\<union> {\\<infinity>\\<^sub>h}", "by (auto simp add: of_complex_inj)"], ["proof (state)\nthis:\n  of_complex x \\<noteq> \\<infinity>\\<^sub>h\n  of_complex x \\<noteq> 0\\<^sub>h\n  of_complex x \\<noteq> of_complex (- 1)\n  of_complex 1 \\<noteq> of_complex x\n  of_complex x \\<in> circline_set x_axis\n\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points\n                             (poincare_line 0\\<^sub>h (of_complex x)) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio 0\\<^sub>h i1 (of_complex x)\n                             i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex\n                               (cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2)) \\<and>\n                            0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2", "have ***:  \"0\\<^sub>h \\<noteq> of_complex (-1)\" \"0\\<^sub>h \\<noteq> of_complex 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>h \\<noteq> of_complex (- 1) &&& 0\\<^sub>h \\<noteq> of_complex 1", "by (metis of_complex_zero_iff zero_neq_neg_one, simp)"], ["proof (state)\nthis:\n  0\\<^sub>h \\<noteq> of_complex (- 1)\n  0\\<^sub>h \\<noteq> of_complex 1\n\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points\n                             (poincare_line 0\\<^sub>h (of_complex x)) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio 0\\<^sub>h i1 (of_complex x)\n                             i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex\n                               (cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2)) \\<and>\n                            0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2", "have ****: \"- x - 1 \\<noteq> 0\" \"x - 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x - 1 \\<noteq> 0 &&& x - 1 \\<noteq> 0", "using \\<open>x \\<noteq> -1\\<close> \\<open>x \\<noteq> 1\\<close>"], ["proof (prove)\nusing this:\n  x \\<noteq> - 1\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. - x - 1 \\<noteq> 0 &&& x - 1 \\<noteq> 0", "by (metis add.inverse_inverse eq_iff_diff_eq_0, simp)"], ["proof (state)\nthis:\n  - x - 1 \\<noteq> 0\n  x - 1 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points\n                             (poincare_line 0\\<^sub>h (of_complex x)) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio 0\\<^sub>h i1 (of_complex x)\n                             i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex\n                               (cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2)) \\<and>\n                            0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2", "have \"poincare_line 0\\<^sub>h (of_complex x) = x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_line 0\\<^sub>h (of_complex x) = x_axis", "using **"], ["proof (prove)\nusing this:\n  of_complex x \\<noteq> \\<infinity>\\<^sub>h\n  of_complex x \\<noteq> 0\\<^sub>h\n  of_complex x \\<noteq> of_complex (- 1)\n  of_complex 1 \\<noteq> of_complex x\n  of_complex x \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. poincare_line 0\\<^sub>h (of_complex x) = x_axis", "by (simp add: poincare_line_0_real_is_x_axis)"], ["proof (state)\nthis:\n  poincare_line 0\\<^sub>h (of_complex x) = x_axis\n\ngoal (2 subgoals):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points\n                             (poincare_line 0\\<^sub>h (of_complex x)) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio 0\\<^sub>h i1 (of_complex x)\n                             i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex\n                               (cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2)) \\<and>\n                            0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x)\n                                 i2", "thus \"?P 0\\<^sub>h (of_complex x)\""], ["proof (prove)\nusing this:\n  poincare_line 0\\<^sub>h (of_complex x) = x_axis\n\ngoal (1 subgoal):\n 1. \\<forall>i1 i2.\n       ideal_points (poincare_line 0\\<^sub>h (of_complex x)) =\n       {i1, i2} \\<longrightarrow>\n       cross_ratio 0\\<^sub>h i1 (of_complex x) i2 \\<noteq>\n       \\<infinity>\\<^sub>h \\<and>\n       is_real\n        (to_complex (cross_ratio 0\\<^sub>h i1 (of_complex x) i2)) \\<and>\n       0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x) i2", "using * ** *** ****"], ["proof (prove)\nusing this:\n  poincare_line 0\\<^sub>h (of_complex x) = x_axis\n  is_real x\n  0 < Re x\n  Re x < 1\n  of_complex x \\<noteq> \\<infinity>\\<^sub>h\n  of_complex x \\<noteq> 0\\<^sub>h\n  of_complex x \\<noteq> of_complex (- 1)\n  of_complex 1 \\<noteq> of_complex x\n  of_complex x \\<in> circline_set x_axis\n  0\\<^sub>h \\<noteq> of_complex (- 1)\n  0\\<^sub>h \\<noteq> of_complex 1\n  - x - 1 \\<noteq> 0\n  x - 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>i1 i2.\n       ideal_points (poincare_line 0\\<^sub>h (of_complex x)) =\n       {i1, i2} \\<longrightarrow>\n       cross_ratio 0\\<^sub>h i1 (of_complex x) i2 \\<noteq>\n       \\<infinity>\\<^sub>h \\<and>\n       is_real\n        (to_complex (cross_ratio 0\\<^sub>h i1 (of_complex x) i2)) \\<and>\n       0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x) i2", "using cross_ratio_not_inf[of \"0\\<^sub>h\" \"of_complex 1\" \"of_complex (-1)\" \"of_complex x\"]"], ["proof (prove)\nusing this:\n  poincare_line 0\\<^sub>h (of_complex x) = x_axis\n  is_real x\n  0 < Re x\n  Re x < 1\n  of_complex x \\<noteq> \\<infinity>\\<^sub>h\n  of_complex x \\<noteq> 0\\<^sub>h\n  of_complex x \\<noteq> of_complex (- 1)\n  of_complex 1 \\<noteq> of_complex x\n  of_complex x \\<in> circline_set x_axis\n  0\\<^sub>h \\<noteq> of_complex (- 1)\n  0\\<^sub>h \\<noteq> of_complex 1\n  - x - 1 \\<noteq> 0\n  x - 1 \\<noteq> 0\n  \\<lbrakk>0\\<^sub>h \\<noteq> of_complex 1;\n   of_complex (- 1) \\<noteq> of_complex x\\<rbrakk>\n  \\<Longrightarrow> cross_ratio 0\\<^sub>h (of_complex (- 1)) (of_complex x)\n                     (of_complex 1) \\<noteq>\n                    \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<forall>i1 i2.\n       ideal_points (poincare_line 0\\<^sub>h (of_complex x)) =\n       {i1, i2} \\<longrightarrow>\n       cross_ratio 0\\<^sub>h i1 (of_complex x) i2 \\<noteq>\n       \\<infinity>\\<^sub>h \\<and>\n       is_real\n        (to_complex (cross_ratio 0\\<^sub>h i1 (of_complex x) i2)) \\<and>\n       0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x) i2", "using cross_ratio_not_inf[of \"0\\<^sub>h\" \"of_complex (-1)\" \"of_complex 1\" \"of_complex x\"]"], ["proof (prove)\nusing this:\n  poincare_line 0\\<^sub>h (of_complex x) = x_axis\n  is_real x\n  0 < Re x\n  Re x < 1\n  of_complex x \\<noteq> \\<infinity>\\<^sub>h\n  of_complex x \\<noteq> 0\\<^sub>h\n  of_complex x \\<noteq> of_complex (- 1)\n  of_complex 1 \\<noteq> of_complex x\n  of_complex x \\<in> circline_set x_axis\n  0\\<^sub>h \\<noteq> of_complex (- 1)\n  0\\<^sub>h \\<noteq> of_complex 1\n  - x - 1 \\<noteq> 0\n  x - 1 \\<noteq> 0\n  \\<lbrakk>0\\<^sub>h \\<noteq> of_complex 1;\n   of_complex (- 1) \\<noteq> of_complex x\\<rbrakk>\n  \\<Longrightarrow> cross_ratio 0\\<^sub>h (of_complex (- 1)) (of_complex x)\n                     (of_complex 1) \\<noteq>\n                    \\<infinity>\\<^sub>h\n  \\<lbrakk>0\\<^sub>h \\<noteq> of_complex (- 1);\n   of_complex 1 \\<noteq> of_complex x\\<rbrakk>\n  \\<Longrightarrow> cross_ratio 0\\<^sub>h (of_complex 1) (of_complex x)\n                     (of_complex (- 1)) \\<noteq>\n                    \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<forall>i1 i2.\n       ideal_points (poincare_line 0\\<^sub>h (of_complex x)) =\n       {i1, i2} \\<longrightarrow>\n       cross_ratio 0\\<^sub>h i1 (of_complex x) i2 \\<noteq>\n       \\<infinity>\\<^sub>h \\<and>\n       is_real\n        (to_complex (cross_ratio 0\\<^sub>h i1 (of_complex x) i2)) \\<and>\n       0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x) i2", "using cross_ratio_real[of 0 \"-1\" x 1] cross_ratio_real[of 0 1 x \"-1\"]"], ["proof (prove)\nusing this:\n  poincare_line 0\\<^sub>h (of_complex x) = x_axis\n  is_real x\n  0 < Re x\n  Re x < 1\n  of_complex x \\<noteq> \\<infinity>\\<^sub>h\n  of_complex x \\<noteq> 0\\<^sub>h\n  of_complex x \\<noteq> of_complex (- 1)\n  of_complex 1 \\<noteq> of_complex x\n  of_complex x \\<in> circline_set x_axis\n  0\\<^sub>h \\<noteq> of_complex (- 1)\n  0\\<^sub>h \\<noteq> of_complex 1\n  - x - 1 \\<noteq> 0\n  x - 1 \\<noteq> 0\n  \\<lbrakk>0\\<^sub>h \\<noteq> of_complex 1;\n   of_complex (- 1) \\<noteq> of_complex x\\<rbrakk>\n  \\<Longrightarrow> cross_ratio 0\\<^sub>h (of_complex (- 1)) (of_complex x)\n                     (of_complex 1) \\<noteq>\n                    \\<infinity>\\<^sub>h\n  \\<lbrakk>0\\<^sub>h \\<noteq> of_complex (- 1);\n   of_complex 1 \\<noteq> of_complex x\\<rbrakk>\n  \\<Longrightarrow> cross_ratio 0\\<^sub>h (of_complex 1) (of_complex x)\n                     (of_complex (- 1)) \\<noteq>\n                    \\<infinity>\\<^sub>h\n  \\<lbrakk>is_real 0; is_real (- 1); is_real x; is_real 1;\n   0 \\<noteq> - 1 \\<and> x \\<noteq> 1 \\<or>\n   0 \\<noteq> 1 \\<and> - 1 \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> is_real\n                     (to_complex\n                       (cross_ratio (of_complex 0) (of_complex (- 1))\n                         (of_complex x) (of_complex 1)))\n  \\<lbrakk>is_real 0; is_real 1; is_real x; is_real (- 1);\n   0 \\<noteq> 1 \\<and> x \\<noteq> - 1 \\<or>\n   0 \\<noteq> - 1 \\<and> 1 \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> is_real\n                     (to_complex\n                       (cross_ratio (of_complex 0) (of_complex 1)\n                         (of_complex x) (of_complex (- 1))))\n\ngoal (1 subgoal):\n 1. \\<forall>i1 i2.\n       ideal_points (poincare_line 0\\<^sub>h (of_complex x)) =\n       {i1, i2} \\<longrightarrow>\n       cross_ratio 0\\<^sub>h i1 (of_complex x) i2 \\<noteq>\n       \\<infinity>\\<^sub>h \\<and>\n       is_real\n        (to_complex (cross_ratio 0\\<^sub>h i1 (of_complex x) i2)) \\<and>\n       0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x) i2", "apply (auto simp add: poincare_line_0_real_is_x_axis doubleton_eq_iff circline_set_x_axis)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_real x; 0 < Re x; Re x < 1; x \\<noteq> 0;\n     of_complex x \\<noteq> of_complex (- 1);\n     1\\<^sub>h \\<noteq> of_complex x; 0\\<^sub>h \\<noteq> of_complex (- 1);\n     - x \\<noteq> 1; x \\<noteq> 1;\n     cross_ratio 0\\<^sub>h (of_complex (- 1)) (of_complex x)\n      1\\<^sub>h \\<noteq>\n     \\<infinity>\\<^sub>h;\n     cross_ratio 0\\<^sub>h 1\\<^sub>h (of_complex x)\n      (of_complex (- 1)) \\<noteq>\n     \\<infinity>\\<^sub>h;\n     is_real\n      (to_complex\n        (cross_ratio 0\\<^sub>h (of_complex (- 1)) (of_complex x)\n          1\\<^sub>h));\n     is_real\n      (to_complex\n        (cross_ratio 0\\<^sub>h 1\\<^sub>h (of_complex x)\n          (of_complex (- 1))))\\<rbrakk>\n    \\<Longrightarrow> 0 < Re_cross_ratio 0\\<^sub>h (of_complex (- 1))\n                           (of_complex x) 1\\<^sub>h\n 2. \\<lbrakk>is_real x; 0 < Re x; Re x < 1; x \\<noteq> 0;\n     of_complex x \\<noteq> of_complex (- 1);\n     1\\<^sub>h \\<noteq> of_complex x; 0\\<^sub>h \\<noteq> of_complex (- 1);\n     - x \\<noteq> 1; x \\<noteq> 1;\n     cross_ratio 0\\<^sub>h (of_complex (- 1)) (of_complex x)\n      1\\<^sub>h \\<noteq>\n     \\<infinity>\\<^sub>h;\n     cross_ratio 0\\<^sub>h 1\\<^sub>h (of_complex x)\n      (of_complex (- 1)) \\<noteq>\n     \\<infinity>\\<^sub>h;\n     is_real\n      (to_complex\n        (cross_ratio 0\\<^sub>h (of_complex (- 1)) (of_complex x)\n          1\\<^sub>h));\n     is_real\n      (to_complex\n        (cross_ratio 0\\<^sub>h 1\\<^sub>h (of_complex x)\n          (of_complex (- 1))))\\<rbrakk>\n    \\<Longrightarrow> 0 < Re_cross_ratio 0\\<^sub>h 1\\<^sub>h (of_complex x)\n                           (of_complex (- 1))", "apply (subst cross_ratio, simp_all, subst Re_complex_div_gt_0, simp, subst mult_neg_neg, simp_all)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>i1 i2.\n     ideal_points (poincare_line 0\\<^sub>h (of_complex x)) =\n     {i1, i2} \\<longrightarrow>\n     cross_ratio 0\\<^sub>h i1 (of_complex x) i2 \\<noteq>\n     \\<infinity>\\<^sub>h \\<and>\n     is_real\n      (to_complex (cross_ratio 0\\<^sub>h i1 (of_complex x) i2)) \\<and>\n     0 < Re_cross_ratio 0\\<^sub>h i1 (of_complex x) i2\n\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2", "fix M u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2", "let ?Mu = \"moebius_pt M u\" and ?Mv = \"moebius_pt M v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2", "assume *: \"unit_disc_fix M\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\"\n            \"?P ?Mu ?Mv\""], ["proof (state)\nthis:\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n  \\<forall>i1 i2.\n     ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n     {i1, i2} \\<longrightarrow>\n     cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n     \\<infinity>\\<^sub>h \\<and>\n     is_real\n      (to_complex\n        (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n     0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2\n\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>i1 i2.\n           ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n           {i1, i2} \\<longrightarrow>\n           cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n           \\<infinity>\\<^sub>h \\<and>\n           is_real\n            (to_complex\n              (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n           0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v)\n                i2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i1 i2.\n                            ideal_points (poincare_line u v) =\n                            {i1, i2} \\<longrightarrow>\n                            cross_ratio u i1 v i2 \\<noteq>\n                            \\<infinity>\\<^sub>h \\<and>\n                            is_real\n                             (to_complex (cross_ratio u i1 v i2)) \\<and>\n                            0 < Re_cross_ratio u i1 v i2", "show \"?P u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<longrightarrow>\n       cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h \\<and>\n       is_real (to_complex (cross_ratio u i1 v i2)) \\<and>\n       0 < Re_cross_ratio u i1 v i2", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i1 i2.\n       \\<lbrakk>ideal_points (poincare_line u v) = {i1, i2};\n        cross_ratio u i1 v i2 = \\<infinity>\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n       is_real (to_complex (cross_ratio u i1 v i2))\n 3. \\<And>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n       0 < Re_cross_ratio u i1 v i2", "fix i1 i2"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i1 i2.\n       \\<lbrakk>ideal_points (poincare_line u v) = {i1, i2};\n        cross_ratio u i1 v i2 = \\<infinity>\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n       is_real (to_complex (cross_ratio u i1 v i2))\n 3. \\<And>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n       0 < Re_cross_ratio u i1 v i2", "let ?cr = \"cross_ratio u i1 v i2\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i1 i2.\n       \\<lbrakk>ideal_points (poincare_line u v) = {i1, i2};\n        cross_ratio u i1 v i2 = \\<infinity>\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n       is_real (to_complex (cross_ratio u i1 v i2))\n 3. \\<And>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n       0 < Re_cross_ratio u i1 v i2", "assume **: \"ideal_points (poincare_line u v) = {i1, i2}\""], ["proof (state)\nthis:\n  ideal_points (poincare_line u v) = {i1, i2}\n\ngoal (3 subgoals):\n 1. \\<And>i1 i2.\n       \\<lbrakk>ideal_points (poincare_line u v) = {i1, i2};\n        cross_ratio u i1 v i2 = \\<infinity>\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n       is_real (to_complex (cross_ratio u i1 v i2))\n 3. \\<And>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n       0 < Re_cross_ratio u i1 v i2", "have \"i1 \\<noteq> u\" \"i1 \\<noteq> v\" \"i2 \\<noteq> u\" \"i2 \\<noteq> v\" \"i1 \\<noteq> i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i1 \\<noteq> u &&& i1 \\<noteq> v) &&&\n    i2 \\<noteq> u &&& i2 \\<noteq> v &&& i1 \\<noteq> i2", "using ideal_points_different[OF *(2-3), of i1 i2] ** \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>u \\<noteq> v;\n   ideal_points (poincare_line u v) = {i1, i2}\\<rbrakk>\n  \\<Longrightarrow> i1 \\<noteq> i2\n  \\<lbrakk>u \\<noteq> v;\n   ideal_points (poincare_line u v) = {i1, i2}\\<rbrakk>\n  \\<Longrightarrow> u \\<noteq> i1\n  \\<lbrakk>u \\<noteq> v;\n   ideal_points (poincare_line u v) = {i1, i2}\\<rbrakk>\n  \\<Longrightarrow> u \\<noteq> i2\n  \\<lbrakk>u \\<noteq> v;\n   ideal_points (poincare_line u v) = {i1, i2}\\<rbrakk>\n  \\<Longrightarrow> v \\<noteq> i1\n  \\<lbrakk>u \\<noteq> v;\n   ideal_points (poincare_line u v) = {i1, i2}\\<rbrakk>\n  \\<Longrightarrow> v \\<noteq> i2\n  ideal_points (poincare_line u v) = {i1, i2}\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (i1 \\<noteq> u &&& i1 \\<noteq> v) &&&\n    i2 \\<noteq> u &&& i2 \\<noteq> v &&& i1 \\<noteq> i2", "by auto"], ["proof (state)\nthis:\n  i1 \\<noteq> u\n  i1 \\<noteq> v\n  i2 \\<noteq> u\n  i2 \\<noteq> v\n  i1 \\<noteq> i2\n\ngoal (3 subgoals):\n 1. \\<And>i1 i2.\n       \\<lbrakk>ideal_points (poincare_line u v) = {i1, i2};\n        cross_ratio u i1 v i2 = \\<infinity>\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n       is_real (to_complex (cross_ratio u i1 v i2))\n 3. \\<And>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n       0 < Re_cross_ratio u i1 v i2", "hence \"0 < Re (to_complex ?cr) \\<and> is_real (to_complex ?cr) \\<and> ?cr \\<noteq> \\<infinity>\\<^sub>h\""], ["proof (prove)\nusing this:\n  i1 \\<noteq> u\n  i1 \\<noteq> v\n  i2 \\<noteq> u\n  i2 \\<noteq> v\n  i1 \\<noteq> i2\n\ngoal (1 subgoal):\n 1. 0 < Re_cross_ratio u i1 v i2 \\<and>\n    is_real (to_complex (cross_ratio u i1 v i2)) \\<and>\n    cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h", "using * **"], ["proof (prove)\nusing this:\n  i1 \\<noteq> u\n  i1 \\<noteq> v\n  i2 \\<noteq> u\n  i2 \\<noteq> v\n  i1 \\<noteq> i2\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n  \\<forall>i1 i2.\n     ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n     {i1, i2} \\<longrightarrow>\n     cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2 \\<noteq>\n     \\<infinity>\\<^sub>h \\<and>\n     is_real\n      (to_complex\n        (cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2)) \\<and>\n     0 < Re_cross_ratio (moebius_pt M u) i1 (moebius_pt M v) i2\n  ideal_points (poincare_line u v) = {i1, i2}\n\ngoal (1 subgoal):\n 1. 0 < Re_cross_ratio u i1 v i2 \\<and>\n    is_real (to_complex (cross_ratio u i1 v i2)) \\<and>\n    cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h", "apply (erule_tac x=\"moebius_pt M i1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i1 \\<noteq> u; i1 \\<noteq> v; i2 \\<noteq> u; i2 \\<noteq> v;\n     i1 \\<noteq> i2; unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n     u \\<noteq> v; ideal_points (poincare_line u v) = {i1, i2};\n     \\<forall>i2.\n        ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n        {moebius_pt M i1, i2} \\<longrightarrow>\n        cross_ratio (moebius_pt M u) (moebius_pt M i1) (moebius_pt M v)\n         i2 \\<noteq>\n        \\<infinity>\\<^sub>h \\<and>\n        is_real\n         (to_complex\n           (cross_ratio (moebius_pt M u) (moebius_pt M i1) (moebius_pt M v)\n             i2)) \\<and>\n        0 < Re_cross_ratio (moebius_pt M u) (moebius_pt M i1)\n             (moebius_pt M v) i2\\<rbrakk>\n    \\<Longrightarrow> 0 < Re_cross_ratio u i1 v i2 \\<and>\n                      is_real (to_complex (cross_ratio u i1 v i2)) \\<and>\n                      cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h", "apply (erule_tac x=\"moebius_pt M i2\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i1 \\<noteq> u; i1 \\<noteq> v; i2 \\<noteq> u; i2 \\<noteq> v;\n     i1 \\<noteq> i2; unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n     u \\<noteq> v; ideal_points (poincare_line u v) = {i1, i2};\n     ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n     {moebius_pt M i1, moebius_pt M i2} \\<longrightarrow>\n     cross_ratio (moebius_pt M u) (moebius_pt M i1) (moebius_pt M v)\n      (moebius_pt M i2) \\<noteq>\n     \\<infinity>\\<^sub>h \\<and>\n     is_real\n      (to_complex\n        (cross_ratio (moebius_pt M u) (moebius_pt M i1) (moebius_pt M v)\n          (moebius_pt M i2))) \\<and>\n     0 < Re_cross_ratio (moebius_pt M u) (moebius_pt M i1) (moebius_pt M v)\n          (moebius_pt M i2)\\<rbrakk>\n    \\<Longrightarrow> 0 < Re_cross_ratio u i1 v i2 \\<and>\n                      is_real (to_complex (cross_ratio u i1 v i2)) \\<and>\n                      cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h", "apply (subst (asm) ideal_points_poincare_line_moebius[of M u v i1 i2], simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < Re_cross_ratio u i1 v i2 \\<and>\n  is_real (to_complex (cross_ratio u i1 v i2)) \\<and>\n  cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (3 subgoals):\n 1. \\<And>i1 i2.\n       \\<lbrakk>ideal_points (poincare_line u v) = {i1, i2};\n        cross_ratio u i1 v i2 = \\<infinity>\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n       is_real (to_complex (cross_ratio u i1 v i2))\n 3. \\<And>i1 i2.\n       ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n       0 < Re_cross_ratio u i1 v i2", "thus \"0 < Re (to_complex ?cr)\" \"is_real (to_complex ?cr)\" \"?cr = \\<infinity>\\<^sub>h \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  0 < Re_cross_ratio u i1 v i2 \\<and>\n  is_real (to_complex (cross_ratio u i1 v i2)) \\<and>\n  cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. 0 < Re_cross_ratio u i1 v i2 &&&\n    is_real (to_complex (cross_ratio u i1 v i2)) &&&\n    (cross_ratio u i1 v i2 = \\<infinity>\\<^sub>h \\<Longrightarrow> False)", "by simp_all"], ["proof (state)\nthis:\n  0 < Re_cross_ratio u i1 v i2\n  is_real (to_complex (cross_ratio u i1 v i2))\n  cross_ratio u i1 v i2 = \\<infinity>\\<^sub>h \\<Longrightarrow> False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i1 i2.\n     ideal_points (poincare_line u v) = {i1, i2} \\<longrightarrow>\n     cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h \\<and>\n     is_real (to_complex (cross_ratio u i1 v i2)) \\<and>\n     0 < Re_cross_ratio u i1 v i2\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Next we can show that for every different points from the unit disc there is exactly one number\nthat satisfies the h-distance predicate.\\<close>"], ["", "lemma distance_unique:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"\\<exists>! d. poincare_distance_pred u v d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!d. poincare_distance_pred u v d", "proof (cases \"u = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> \\<exists>!d. poincare_distance_pred u v d\n 2. u \\<noteq> v \\<Longrightarrow> \\<exists>!d. poincare_distance_pred u v d", "case True"], ["proof (state)\nthis:\n  u = v\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> \\<exists>!d. poincare_distance_pred u v d\n 2. u \\<noteq> v \\<Longrightarrow> \\<exists>!d. poincare_distance_pred u v d", "thus ?thesis"], ["proof (prove)\nusing this:\n  u = v\n\ngoal (1 subgoal):\n 1. \\<exists>!d. poincare_distance_pred u v d", "by auto"], ["proof (state)\nthis:\n  \\<exists>!d. poincare_distance_pred u v d\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> \\<exists>!d. poincare_distance_pred u v d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> \\<exists>!d. poincare_distance_pred u v d", "case False"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> \\<exists>!d. poincare_distance_pred u v d", "obtain i1 i2 where *: \"i1 \\<noteq> i2\" \"ideal_points (poincare_line u v) = {i1, i2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i1 i2.\n        \\<lbrakk>i1 \\<noteq> i2;\n         ideal_points (poincare_line u v) = {i1, i2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using obtain_ideal_points[OF is_poincare_line_poincare_line] \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?z1 \\<noteq> ?w1;\n   \\<And>i1 i2.\n      \\<lbrakk>i1 \\<noteq> i2;\n       ideal_points (poincare_line ?z1 ?w1) = {i1, i2}\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (\\<And>i1 i2.\n        \\<lbrakk>i1 \\<noteq> i2;\n         ideal_points (poincare_line u v) = {i1, i2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i1 \\<noteq> i2\n  ideal_points (poincare_line u v) = {i1, i2}\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> \\<exists>!d. poincare_distance_pred u v d", "let ?d = \"calc_poincare_distance u i1 v i2\""], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> \\<exists>!d. poincare_distance_pred u v d", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!d. poincare_distance_pred u v d", "proof (rule ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. poincare_distance_pred u v ?a\n 2. \\<And>d. poincare_distance_pred u v d \\<Longrightarrow> d = ?a", "show \"poincare_distance_pred u v ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance_pred u v (calc_poincare_distance u i1 v i2)", "using * \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  i1 \\<noteq> i2\n  ideal_points (poincare_line u v) = {i1, i2}\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. poincare_distance_pred u v (calc_poincare_distance u i1 v i2)", "proof (simp del: calc_poincare_distance_def, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i1a i2a.\n       \\<lbrakk>i1 \\<noteq> i2; ideal_points (poincare_line u v) = {i1, i2};\n        u \\<noteq> v; i1 \\<noteq> i2;\n        ideal_points (poincare_line u v) = {i1, i2}; u \\<noteq> v;\n        {i1, i2} = {i1a, i2a}\\<rbrakk>\n       \\<Longrightarrow> calc_poincare_distance u i1 v i2 =\n                         calc_poincare_distance u i1a v i2a", "fix i1' i2'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i1a i2a.\n       \\<lbrakk>i1 \\<noteq> i2; ideal_points (poincare_line u v) = {i1, i2};\n        u \\<noteq> v; i1 \\<noteq> i2;\n        ideal_points (poincare_line u v) = {i1, i2}; u \\<noteq> v;\n        {i1, i2} = {i1a, i2a}\\<rbrakk>\n       \\<Longrightarrow> calc_poincare_distance u i1 v i2 =\n                         calc_poincare_distance u i1a v i2a", "assume \"{i1, i2} = {i1', i2'}\""], ["proof (state)\nthis:\n  {i1, i2} = {i1', i2'}\n\ngoal (1 subgoal):\n 1. \\<And>i1a i2a.\n       \\<lbrakk>i1 \\<noteq> i2; ideal_points (poincare_line u v) = {i1, i2};\n        u \\<noteq> v; i1 \\<noteq> i2;\n        ideal_points (poincare_line u v) = {i1, i2}; u \\<noteq> v;\n        {i1, i2} = {i1a, i2a}\\<rbrakk>\n       \\<Longrightarrow> calc_poincare_distance u i1 v i2 =\n                         calc_poincare_distance u i1a v i2a", "hence **: \"(i1' = i1 \\<and> i2' = i2) \\<or> (i1' = i2 \\<and> i2' = i1)\""], ["proof (prove)\nusing this:\n  {i1, i2} = {i1', i2'}\n\ngoal (1 subgoal):\n 1. i1' = i1 \\<and> i2' = i2 \\<or> i1' = i2 \\<and> i2' = i1", "using doubleton_eq_iff[of i1 i2 i1' i2']"], ["proof (prove)\nusing this:\n  {i1, i2} = {i1', i2'}\n  ({i1, i2} = {i1', i2'}) =\n  (i1 = i1' \\<and> i2 = i2' \\<or> i1 = i2' \\<and> i2 = i1')\n\ngoal (1 subgoal):\n 1. i1' = i1 \\<and> i2' = i2 \\<or> i1' = i2 \\<and> i2' = i1", "by blast"], ["proof (state)\nthis:\n  i1' = i1 \\<and> i2' = i2 \\<or> i1' = i2 \\<and> i2' = i1\n\ngoal (1 subgoal):\n 1. \\<And>i1a i2a.\n       \\<lbrakk>i1 \\<noteq> i2; ideal_points (poincare_line u v) = {i1, i2};\n        u \\<noteq> v; i1 \\<noteq> i2;\n        ideal_points (poincare_line u v) = {i1, i2}; u \\<noteq> v;\n        {i1, i2} = {i1a, i2a}\\<rbrakk>\n       \\<Longrightarrow> calc_poincare_distance u i1 v i2 =\n                         calc_poincare_distance u i1a v i2a", "have all_different: \"u \\<noteq> i1\" \"u \\<noteq> i2\" \"v \\<noteq> i1\" \"v \\<noteq> i2\" \"u \\<noteq> i1'\" \"u \\<noteq> i2'\" \"v \\<noteq> i1'\" \"v \\<noteq> i2'\" \"i1 \\<noteq> i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((u \\<noteq> i1 &&& u \\<noteq> i2) &&&\n     v \\<noteq> i1 &&& v \\<noteq> i2) &&&\n    (u \\<noteq> i1' &&& u \\<noteq> i2') &&&\n    v \\<noteq> i1' &&& v \\<noteq> i2' &&& i1 \\<noteq> i2", "using ideal_points_different[OF assms, of i1 i2] * ** \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>u \\<noteq> v;\n   ideal_points (poincare_line u v) = {i1, i2}\\<rbrakk>\n  \\<Longrightarrow> i1 \\<noteq> i2\n  \\<lbrakk>u \\<noteq> v;\n   ideal_points (poincare_line u v) = {i1, i2}\\<rbrakk>\n  \\<Longrightarrow> u \\<noteq> i1\n  \\<lbrakk>u \\<noteq> v;\n   ideal_points (poincare_line u v) = {i1, i2}\\<rbrakk>\n  \\<Longrightarrow> u \\<noteq> i2\n  \\<lbrakk>u \\<noteq> v;\n   ideal_points (poincare_line u v) = {i1, i2}\\<rbrakk>\n  \\<Longrightarrow> v \\<noteq> i1\n  \\<lbrakk>u \\<noteq> v;\n   ideal_points (poincare_line u v) = {i1, i2}\\<rbrakk>\n  \\<Longrightarrow> v \\<noteq> i2\n  i1 \\<noteq> i2\n  ideal_points (poincare_line u v) = {i1, i2}\n  i1' = i1 \\<and> i2' = i2 \\<or> i1' = i2 \\<and> i2' = i1\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. ((u \\<noteq> i1 &&& u \\<noteq> i2) &&&\n     v \\<noteq> i1 &&& v \\<noteq> i2) &&&\n    (u \\<noteq> i1' &&& u \\<noteq> i2') &&&\n    v \\<noteq> i1' &&& v \\<noteq> i2' &&& i1 \\<noteq> i2", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> i1\n  u \\<noteq> i2\n  v \\<noteq> i1\n  v \\<noteq> i2\n  u \\<noteq> i1'\n  u \\<noteq> i2'\n  v \\<noteq> i1'\n  v \\<noteq> i2'\n  i1 \\<noteq> i2\n\ngoal (1 subgoal):\n 1. \\<And>i1a i2a.\n       \\<lbrakk>i1 \\<noteq> i2; ideal_points (poincare_line u v) = {i1, i2};\n        u \\<noteq> v; i1 \\<noteq> i2;\n        ideal_points (poincare_line u v) = {i1, i2}; u \\<noteq> v;\n        {i1, i2} = {i1a, i2a}\\<rbrakk>\n       \\<Longrightarrow> calc_poincare_distance u i1 v i2 =\n                         calc_poincare_distance u i1a v i2a", "show \"calc_poincare_distance u i1 v i2 = calc_poincare_distance u i1' v i2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. calc_poincare_distance u i1 v i2 = calc_poincare_distance u i1' v i2'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. calc_poincare_distance u i1 v i2 = calc_poincare_distance u i1' v i2'", "let ?cr = \"cross_ratio u i1 v i2\""], ["proof (state)\ngoal (1 subgoal):\n 1. calc_poincare_distance u i1 v i2 = calc_poincare_distance u i1' v i2'", "let ?cr' = \"cross_ratio u i1' v i2'\""], ["proof (state)\ngoal (1 subgoal):\n 1. calc_poincare_distance u i1 v i2 = calc_poincare_distance u i1' v i2'", "have \"Re (to_complex ?cr) > 0\" \"is_real (to_complex ?cr)\"\n             \"Re (to_complex ?cr') > 0\" \"is_real (to_complex ?cr')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < Re_cross_ratio u i1 v i2 &&&\n     is_real (to_complex (cross_ratio u i1 v i2))) &&&\n    0 < Re_cross_ratio u i1' v i2' &&&\n    is_real (to_complex (cross_ratio u i1' v i2'))", "using False distance_cross_ratio_real_positive[OF assms(1-2)] * **"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<noteq> v \\<Longrightarrow>\n  \\<forall>i1 i2.\n     ideal_points (poincare_line u v) = {i1, i2} \\<longrightarrow>\n     cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h \\<and>\n     is_real (to_complex (cross_ratio u i1 v i2)) \\<and>\n     0 < Re_cross_ratio u i1 v i2\n  i1 \\<noteq> i2\n  ideal_points (poincare_line u v) = {i1, i2}\n  i1' = i1 \\<and> i2' = i2 \\<or> i1' = i2 \\<and> i2' = i1\n\ngoal (1 subgoal):\n 1. (0 < Re_cross_ratio u i1 v i2 &&&\n     is_real (to_complex (cross_ratio u i1 v i2))) &&&\n    0 < Re_cross_ratio u i1' v i2' &&&\n    is_real (to_complex (cross_ratio u i1' v i2'))", "by auto"], ["proof (state)\nthis:\n  0 < Re_cross_ratio u i1 v i2\n  is_real (to_complex (cross_ratio u i1 v i2))\n  0 < Re_cross_ratio u i1' v i2'\n  is_real (to_complex (cross_ratio u i1' v i2'))\n\ngoal (1 subgoal):\n 1. calc_poincare_distance u i1 v i2 = calc_poincare_distance u i1' v i2'", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < Re_cross_ratio u i1 v i2\n  is_real (to_complex (cross_ratio u i1 v i2))\n  0 < Re_cross_ratio u i1' v i2'\n  is_real (to_complex (cross_ratio u i1' v i2'))\n\ngoal (1 subgoal):\n 1. calc_poincare_distance u i1 v i2 = calc_poincare_distance u i1' v i2'", "using **"], ["proof (prove)\nusing this:\n  0 < Re_cross_ratio u i1 v i2\n  is_real (to_complex (cross_ratio u i1 v i2))\n  0 < Re_cross_ratio u i1' v i2'\n  is_real (to_complex (cross_ratio u i1' v i2'))\n  i1' = i1 \\<and> i2' = i2 \\<or> i1' = i2 \\<and> i2' = i1\n\ngoal (1 subgoal):\n 1. calc_poincare_distance u i1 v i2 = calc_poincare_distance u i1' v i2'", "using cross_ratio_not_zero cross_ratio_not_inf all_different"], ["proof (prove)\nusing this:\n  0 < Re_cross_ratio u i1 v i2\n  is_real (to_complex (cross_ratio u i1 v i2))\n  0 < Re_cross_ratio u i1' v i2'\n  is_real (to_complex (cross_ratio u i1' v i2'))\n  i1' = i1 \\<and> i2' = i2 \\<or> i1' = i2 \\<and> i2' = i1\n  \\<lbrakk>?z \\<noteq> ?u; ?v \\<noteq> ?w\\<rbrakk>\n  \\<Longrightarrow> cross_ratio ?z ?u ?v ?w \\<noteq> 0\\<^sub>h\n  \\<lbrakk>?z \\<noteq> ?w; ?u \\<noteq> ?v\\<rbrakk>\n  \\<Longrightarrow> cross_ratio ?z ?u ?v ?w \\<noteq> \\<infinity>\\<^sub>h\n  u \\<noteq> i1\n  u \\<noteq> i2\n  v \\<noteq> i1\n  v \\<noteq> i2\n  u \\<noteq> i1'\n  u \\<noteq> i2'\n  v \\<noteq> i1'\n  v \\<noteq> i2'\n  i1 \\<noteq> i2\n\ngoal (1 subgoal):\n 1. calc_poincare_distance u i1 v i2 = calc_poincare_distance u i1' v i2'", "by auto (subst cross_ratio_commute_24, subst reciprocal_real, simp_all add: ln_div)"], ["proof (state)\nthis:\n  calc_poincare_distance u i1 v i2 = calc_poincare_distance u i1' v i2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  calc_poincare_distance u i1 v i2 = calc_poincare_distance u i1' v i2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poincare_distance_pred u v (calc_poincare_distance u i1 v i2)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       poincare_distance_pred u v d \\<Longrightarrow>\n       d = calc_poincare_distance u i1 v i2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       poincare_distance_pred u v d \\<Longrightarrow>\n       d = calc_poincare_distance u i1 v i2", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       poincare_distance_pred u v d \\<Longrightarrow>\n       d = calc_poincare_distance u i1 v i2", "assume \"poincare_distance_pred u v d\""], ["proof (state)\nthis:\n  poincare_distance_pred u v d\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       poincare_distance_pred u v d \\<Longrightarrow>\n       d = calc_poincare_distance u i1 v i2", "thus \"d = ?d\""], ["proof (prove)\nusing this:\n  poincare_distance_pred u v d\n\ngoal (1 subgoal):\n 1. d = calc_poincare_distance u i1 v i2", "using * \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  poincare_distance_pred u v d\n  i1 \\<noteq> i2\n  ideal_points (poincare_line u v) = {i1, i2}\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. d = calc_poincare_distance u i1 v i2", "by auto"], ["proof (state)\nthis:\n  d = calc_poincare_distance u i1 v i2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!d. poincare_distance_pred u v d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poincare_distance_satisfies_pred [simp]:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance_pred u v (poincare_distance u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance_pred u v (poincare_distance u v)", "using distance_unique[OF assms] theI'[of \"poincare_distance_pred u v\"]"], ["proof (prove)\nusing this:\n  \\<exists>!d. poincare_distance_pred u v d\n  \\<exists>!x. poincare_distance_pred u v x \\<Longrightarrow>\n  poincare_distance_pred u v (THE x. poincare_distance_pred u v x)\n\ngoal (1 subgoal):\n 1. poincare_distance_pred u v (poincare_distance u v)", "unfolding poincare_distance_def"], ["proof (prove)\nusing this:\n  \\<exists>!d. poincare_distance_pred u v d\n  \\<exists>!x. poincare_distance_pred u v x \\<Longrightarrow>\n  poincare_distance_pred u v (THE x. poincare_distance_pred u v x)\n\ngoal (1 subgoal):\n 1. poincare_distance_pred u v (The (poincare_distance_pred u v))", "by blast"], ["", "lemma poincare_distance_I:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\" and \"u \\<noteq> v\" and \"ideal_points (poincare_line u v) = {i1, i2}\"\n  shows \"poincare_distance u v = calc_poincare_distance u i1 v i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance u v = calc_poincare_distance u i1 v i2", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n  ideal_points (poincare_line u v) = {i1, i2}\n\ngoal (1 subgoal):\n 1. poincare_distance u v = calc_poincare_distance u i1 v i2", "using poincare_distance_satisfies_pred[OF assms(1-2)]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n  ideal_points (poincare_line u v) = {i1, i2}\n  poincare_distance_pred u v (poincare_distance u v)\n\ngoal (1 subgoal):\n 1. poincare_distance u v = calc_poincare_distance u i1 v i2", "by simp"], ["", "lemma poincare_distance_refl [simp]:\n  assumes \"u \\<in> unit_disc\"\n  shows \"poincare_distance u u = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance u u = 0", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance u u = 0", "using poincare_distance_satisfies_pred[OF assms assms]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  poincare_distance_pred u u (poincare_distance u u)\n\ngoal (1 subgoal):\n 1. poincare_distance u u = 0", "by simp"], ["", "text\\<open>Unit disc preserving M?bius transformations preserve h-distance. \\<close>"], ["", "lemma unit_disc_fix_preserve_poincare_distance [simp]:\n  assumes \"unit_disc_fix M\" and \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance (moebius_pt M u) (moebius_pt M v) = poincare_distance u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "proof (cases \"u = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v\n 2. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "case True"], ["proof (state)\nthis:\n  u = v\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v\n 2. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "have \"moebius_pt M u \\<in> unit_disc\" \"moebius_pt M v \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt M u \\<in> unit_disc &&& moebius_pt M v \\<in> unit_disc", "using unit_disc_fix_iff[OF assms(1), symmetric] assms"], ["proof (prove)\nusing this:\n  unit_disc = moebius_pt M ` unit_disc\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt M u \\<in> unit_disc &&& moebius_pt M v \\<in> unit_disc", "by blast+"], ["proof (state)\nthis:\n  moebius_pt M u \\<in> unit_disc\n  moebius_pt M v \\<in> unit_disc\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v\n 2. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "thus ?thesis"], ["proof (prove)\nusing this:\n  moebius_pt M u \\<in> unit_disc\n  moebius_pt M v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "using assms \\<open>u = v\\<close>"], ["proof (prove)\nusing this:\n  moebius_pt M u \\<in> unit_disc\n  moebius_pt M v \\<in> unit_disc\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u = v\n\ngoal (1 subgoal):\n 1. poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "by simp"], ["proof (state)\nthis:\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  poincare_distance u v\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "case False"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "obtain i1 i2 where *: \"ideal_points (poincare_line u v) = {i1, i2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i1 i2.\n        ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (\\<And>i1 i2.\n        ideal_points (poincare_line u v) = {i1, i2} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_ideal_points[OF is_poincare_line_poincare_line[of u v]])"], ["proof (state)\nthis:\n  ideal_points (poincare_line u v) = {i1, i2}\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "let ?Mu = \"moebius_pt M u\" and ?Mv = \"moebius_pt M v\" and ?Mi1 = \"moebius_pt M i1\" and ?Mi2 = \"moebius_pt M i2\""], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "have **: \"?Mu \\<in> unit_disc\" \"?Mv \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt M u \\<in> unit_disc &&& moebius_pt M v \\<in> unit_disc", "using assms"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt M u \\<in> unit_disc &&& moebius_pt M v \\<in> unit_disc", "using unit_disc_fix_iff"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  unit_disc_fix ?M \\<Longrightarrow> moebius_pt ?M ` unit_disc = unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt M u \\<in> unit_disc &&& moebius_pt M v \\<in> unit_disc", "by blast+"], ["proof (state)\nthis:\n  moebius_pt M u \\<in> unit_disc\n  moebius_pt M v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "have ***: \"?Mu \\<noteq> ?Mv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt M u \\<noteq> moebius_pt M v", "using \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. moebius_pt M u \\<noteq> moebius_pt M v", "by simp"], ["proof (state)\nthis:\n  moebius_pt M u \\<noteq> moebius_pt M v\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "have \"poincare_distance u v = calc_poincare_distance u i1 v i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance u v = calc_poincare_distance u i1 v i2", "using poincare_distance_I[OF assms(2-3) \\<open>u \\<noteq> v\\<close> *]"], ["proof (prove)\nusing this:\n  poincare_distance u v = calc_poincare_distance u i1 v i2\n\ngoal (1 subgoal):\n 1. poincare_distance u v = calc_poincare_distance u i1 v i2", "by auto"], ["proof (state)\nthis:\n  poincare_distance u v = calc_poincare_distance u i1 v i2\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "moreover"], ["proof (state)\nthis:\n  poincare_distance u v = calc_poincare_distance u i1 v i2\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "have \"unit_circle_fix M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_circle_fix M", "using assms"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. unit_circle_fix M", "by simp"], ["proof (state)\nthis:\n  unit_circle_fix M\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "hence ++: \"ideal_points (poincare_line ?Mu ?Mv) = {?Mi1, ?Mi2}\""], ["proof (prove)\nusing this:\n  unit_circle_fix M\n\ngoal (1 subgoal):\n 1. ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n    {moebius_pt M i1, moebius_pt M i2}", "using \\<open>u \\<noteq> v\\<close> assms *"], ["proof (prove)\nusing this:\n  unit_circle_fix M\n  u \\<noteq> v\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  ideal_points (poincare_line u v) = {i1, i2}\n\ngoal (1 subgoal):\n 1. ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n    {moebius_pt M i1, moebius_pt M i2}", "by simp"], ["proof (state)\nthis:\n  ideal_points (poincare_line (moebius_pt M u) (moebius_pt M v)) =\n  {moebius_pt M i1, moebius_pt M i2}\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "have \"poincare_distance ?Mu ?Mv = calc_poincare_distance ?Mu ?Mi1 ?Mv ?Mi2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    calc_poincare_distance (moebius_pt M u) (moebius_pt M i1)\n     (moebius_pt M v) (moebius_pt M i2)", "by (rule poincare_distance_I[OF ** *** ++])"], ["proof (state)\nthis:\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  calc_poincare_distance (moebius_pt M u) (moebius_pt M i1) (moebius_pt M v)\n   (moebius_pt M i2)\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "moreover"], ["proof (state)\nthis:\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  calc_poincare_distance (moebius_pt M u) (moebius_pt M i1) (moebius_pt M v)\n   (moebius_pt M i2)\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "have \"calc_poincare_distance ?Mu ?Mi1 ?Mv ?Mi2 = calc_poincare_distance u i1 v i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. calc_poincare_distance (moebius_pt M u) (moebius_pt M i1)\n     (moebius_pt M v) (moebius_pt M i2) =\n    calc_poincare_distance u i1 v i2", "using ideal_points_different[OF assms(2-3) \\<open>u \\<noteq> v\\<close> *]"], ["proof (prove)\nusing this:\n  i1 \\<noteq> i2\n  u \\<noteq> i1\n  u \\<noteq> i2\n  v \\<noteq> i1\n  v \\<noteq> i2\n\ngoal (1 subgoal):\n 1. calc_poincare_distance (moebius_pt M u) (moebius_pt M i1)\n     (moebius_pt M v) (moebius_pt M i2) =\n    calc_poincare_distance u i1 v i2", "unfolding calc_poincare_distance_def"], ["proof (prove)\nusing this:\n  i1 \\<noteq> i2\n  u \\<noteq> i1\n  u \\<noteq> i2\n  v \\<noteq> i1\n  v \\<noteq> i2\n\ngoal (1 subgoal):\n 1. \\<bar>ln (Re_cross_ratio (moebius_pt M u) (moebius_pt M i1)\n               (moebius_pt M v) (moebius_pt M i2))\\<bar> =\n    \\<bar>ln (Re_cross_ratio u i1 v i2)\\<bar>", "by (subst moebius_preserve_cross_ratio[symmetric], simp_all)"], ["proof (state)\nthis:\n  calc_poincare_distance (moebius_pt M u) (moebius_pt M i1) (moebius_pt M v)\n   (moebius_pt M i2) =\n  calc_poincare_distance u i1 v i2\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "ultimately"], ["proof (chain)\npicking this:\n  poincare_distance u v = calc_poincare_distance u i1 v i2\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  calc_poincare_distance (moebius_pt M u) (moebius_pt M i1) (moebius_pt M v)\n   (moebius_pt M i2)\n  calc_poincare_distance (moebius_pt M u) (moebius_pt M i1) (moebius_pt M v)\n   (moebius_pt M i2) =\n  calc_poincare_distance u i1 v i2", "show ?thesis"], ["proof (prove)\nusing this:\n  poincare_distance u v = calc_poincare_distance u i1 v i2\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  calc_poincare_distance (moebius_pt M u) (moebius_pt M i1) (moebius_pt M v)\n   (moebius_pt M i2)\n  calc_poincare_distance (moebius_pt M u) (moebius_pt M i1) (moebius_pt M v)\n   (moebius_pt M i2) =\n  calc_poincare_distance u i1 v i2\n\ngoal (1 subgoal):\n 1. poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "by simp"], ["proof (state)\nthis:\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  poincare_distance u v\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Knowing ideal points for x-axis, we can easily explicitly calculate distances.\\<close>"], ["", "lemma poincare_distance_x_axis_x_axis:\n  assumes \"x \\<in> unit_disc\" and \"y \\<in> unit_disc\" and \"x \\<in> circline_set x_axis\" and \"y \\<in> circline_set x_axis\"\n  shows \"poincare_distance x y =\n            (let x' = to_complex x; y' = to_complex y\n              in abs (ln (Re (((1 + x') * (1 - y')) / ((1 - x') * (1 + y'))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "obtain x' y' where *: \"x = of_complex x'\" \"y = of_complex y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x' y'.\n        \\<lbrakk>x = of_complex x'; y = of_complex y'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inf_or_of_complex[of x] inf_or_of_complex[of y] \\<open>x \\<in> unit_disc\\<close> \\<open>y \\<in> unit_disc\\<close>"], ["proof (prove)\nusing this:\n  x = \\<infinity>\\<^sub>h \\<or> (\\<exists>xa. x = of_complex xa)\n  y = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. y = of_complex x)\n  x \\<in> unit_disc\n  y \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. (\\<And>x' y'.\n        \\<lbrakk>x = of_complex x'; y = of_complex y'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = of_complex x'\n  y = of_complex y'\n\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "have \"cmod x' < 1\" \"cmod y' < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod x' < 1 &&& cmod y' < 1", "using \\<open>x \\<in> unit_disc\\<close> \\<open>y \\<in> unit_disc\\<close> *"], ["proof (prove)\nusing this:\n  x \\<in> unit_disc\n  y \\<in> unit_disc\n  x = of_complex x'\n  y = of_complex y'\n\ngoal (1 subgoal):\n 1. cmod x' < 1 &&& cmod y' < 1", "by (metis unit_disc_iff_cmod_lt_1)+"], ["proof (state)\nthis:\n  cmod x' < 1\n  cmod y' < 1\n\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "hence **: \"x' \\<noteq> 1\" \"x' \\<noteq> 1\" \"y' \\<noteq> -1\" \"y' \\<noteq> 1\""], ["proof (prove)\nusing this:\n  cmod x' < 1\n  cmod y' < 1\n\ngoal (1 subgoal):\n 1. (x' \\<noteq> 1 &&& x' \\<noteq> 1) &&& y' \\<noteq> - 1 &&& y' \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  x' \\<noteq> 1\n  x' \\<noteq> 1\n  y' \\<noteq> - 1\n  y' \\<noteq> 1\n\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "have \"1 + y' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + y' \\<noteq> 0", "using **"], ["proof (prove)\nusing this:\n  x' \\<noteq> 1\n  x' \\<noteq> 1\n  y' \\<noteq> - 1\n  y' \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 + y' \\<noteq> 0", "by (metis add.left_cancel add_neg_numeral_special(7))"], ["proof (state)\nthis:\n  1 + y' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)\n 2. x \\<noteq> y \\<Longrightarrow>\n    poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)\n 2. x \\<noteq> y \\<Longrightarrow>\n    poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "using assms(1-2)"], ["proof (prove)\nusing this:\n  x = y\n  x \\<in> unit_disc\n  y \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "using unit_disc_iff_cmod_lt_1[of \"to_complex x\"] * ** \\<open>1 + y' \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  x = y\n  x \\<in> unit_disc\n  y \\<in> unit_disc\n  (of_complex (to_complex x) \\<in> unit_disc) = (cmod (to_complex x) < 1)\n  x = of_complex x'\n  y = of_complex y'\n  x' \\<noteq> 1\n  x' \\<noteq> 1\n  y' \\<noteq> - 1\n  y' \\<noteq> 1\n  1 + y' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "by auto"], ["proof (state)\nthis:\n  poincare_distance x y =\n  (let x' = to_complex x; y' = to_complex y\n   in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "hence \"poincare_line x y = x_axis\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. poincare_line x y = x_axis", "using poincare_line_x_axis[OF assms]"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<noteq> y \\<Longrightarrow> poincare_line x y = x_axis\n\ngoal (1 subgoal):\n 1. poincare_line x y = x_axis", "by simp"], ["proof (state)\nthis:\n  poincare_line x y = x_axis\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "hence \"ideal_points (poincare_line x y) = {of_complex (-1), of_complex 1}\""], ["proof (prove)\nusing this:\n  poincare_line x y = x_axis\n\ngoal (1 subgoal):\n 1. ideal_points (poincare_line x y) = {of_complex (- 1), of_complex 1}", "by simp"], ["proof (state)\nthis:\n  ideal_points (poincare_line x y) = {of_complex (- 1), of_complex 1}\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "hence \"poincare_distance x y = calc_poincare_distance x (of_complex (-1)) y (of_complex 1)\""], ["proof (prove)\nusing this:\n  ideal_points (poincare_line x y) = {of_complex (- 1), of_complex 1}\n\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    calc_poincare_distance x (of_complex (- 1)) y (of_complex 1)", "using poincare_distance_I assms \\<open>x \\<noteq> y\\<close>"], ["proof (prove)\nusing this:\n  ideal_points (poincare_line x y) = {of_complex (- 1), of_complex 1}\n  \\<lbrakk>?u \\<in> unit_disc; ?v \\<in> unit_disc; ?u \\<noteq> ?v;\n   ideal_points (poincare_line ?u ?v) = {?i1.0, ?i2.0}\\<rbrakk>\n  \\<Longrightarrow> poincare_distance ?u ?v =\n                    calc_poincare_distance ?u ?i1.0 ?v ?i2.0\n  x \\<in> unit_disc\n  y \\<in> unit_disc\n  x \\<in> circline_set x_axis\n  y \\<in> circline_set x_axis\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    calc_poincare_distance x (of_complex (- 1)) y (of_complex 1)", "by auto"], ["proof (state)\nthis:\n  poincare_distance x y =\n  calc_poincare_distance x (of_complex (- 1)) y (of_complex 1)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "also"], ["proof (state)\nthis:\n  poincare_distance x y =\n  calc_poincare_distance x (of_complex (- 1)) y (of_complex 1)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "have \"... = abs (ln (Re (((x' + 1) * (y' - 1)) / ((x' - 1) * (y' + 1)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. calc_poincare_distance x (of_complex (- 1)) y (of_complex 1) =\n    \\<bar>ln (Re ((x' + 1) * (y' - 1) / ((x' - 1) * (y' + 1))))\\<bar>", "using * \\<open>cmod x' < 1\\<close> \\<open>cmod y' < 1\\<close>"], ["proof (prove)\nusing this:\n  x = of_complex x'\n  y = of_complex y'\n  cmod x' < 1\n  cmod y' < 1\n\ngoal (1 subgoal):\n 1. calc_poincare_distance x (of_complex (- 1)) y (of_complex 1) =\n    \\<bar>ln (Re ((x' + 1) * (y' - 1) / ((x' - 1) * (y' + 1))))\\<bar>", "by (simp, transfer, transfer, auto)"], ["proof (state)\nthis:\n  calc_poincare_distance x (of_complex (- 1)) y (of_complex 1) =\n  \\<bar>ln (Re ((x' + 1) * (y' - 1) / ((x' - 1) * (y' + 1))))\\<bar>\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "finally"], ["proof (chain)\npicking this:\n  poincare_distance x y =\n  \\<bar>ln (Re ((x' + 1) * (y' - 1) / ((x' - 1) * (y' + 1))))\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  poincare_distance x y =\n  \\<bar>ln (Re ((x' + 1) * (y' - 1) / ((x' - 1) * (y' + 1))))\\<bar>\n\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "using *"], ["proof (prove)\nusing this:\n  poincare_distance x y =\n  \\<bar>ln (Re ((x' + 1) * (y' - 1) / ((x' - 1) * (y' + 1))))\\<bar>\n  x = of_complex x'\n  y = of_complex y'\n\ngoal (1 subgoal):\n 1. poincare_distance x y =\n    (let x' = to_complex x; y' = to_complex y\n     in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)", "by (metis (no_types, lifting) add.commute minus_diff_eq minus_divide_divide mult_minus_left mult_minus_right to_complex_of_complex)"], ["proof (state)\nthis:\n  poincare_distance x y =\n  (let x' = to_complex x; y' = to_complex y\n   in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poincare_distance x y =\n  (let x' = to_complex x; y' = to_complex y\n   in \\<bar>ln (Re ((1 + x') * (1 - y') / ((1 - x') * (1 + y'))))\\<bar>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poincare_distance_zero_x_axis:\n  assumes \"x \\<in> unit_disc\" and \"x \\<in> circline_set x_axis\"\n  shows \"poincare_distance 0\\<^sub>h x = (let x' = to_complex x in abs (ln (Re ((1 - x') / (1 + x')))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x in \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> unit_disc\n  x \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x in \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)", "using poincare_distance_x_axis_x_axis[of \"0\\<^sub>h\" x]"], ["proof (prove)\nusing this:\n  x \\<in> unit_disc\n  x \\<in> circline_set x_axis\n  \\<lbrakk>0\\<^sub>h \\<in> unit_disc; x \\<in> unit_disc;\n   0\\<^sub>h \\<in> circline_set x_axis; x \\<in> circline_set x_axis\\<rbrakk>\n  \\<Longrightarrow> poincare_distance 0\\<^sub>h x =\n                    (let x' = to_complex 0\\<^sub>h; y' = to_complex x\n                     in \\<bar>ln (Re ((1 + x') * (1 - y') /\n((1 - x') * (1 + y'))))\\<bar>)\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x in \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)", "by (simp add: Let_def)"], ["", "lemma poincare_distance_zero:\n  assumes \"x \\<in> unit_disc\"\n  shows \"poincare_distance 0\\<^sub>h x = (let x' = to_complex x in abs (ln (Re ((1 - cmod x') / (1 + cmod x')))))\" (is \"?P x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "proof (cases \"x = 0\\<^sub>h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0\\<^sub>h \\<Longrightarrow>\n    poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n 2. x \\<noteq> 0\\<^sub>h \\<Longrightarrow>\n    poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "case True"], ["proof (state)\nthis:\n  x = 0\\<^sub>h\n\ngoal (2 subgoals):\n 1. x = 0\\<^sub>h \\<Longrightarrow>\n    poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n 2. x \\<noteq> 0\\<^sub>h \\<Longrightarrow>\n    poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "by auto"], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h x =\n  (let x' = to_complex x\n   in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0\\<^sub>h \\<Longrightarrow>\n    poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0\\<^sub>h \\<Longrightarrow>\n    poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0\\<^sub>h \\<Longrightarrow>\n    poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h x =\n    (let x' = to_complex x\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "proof (rule wlog_rotation_to_positive_x_axis)"], ["proof (state)\ngoal (4 subgoals):\n 1. x \\<in> unit_disc\n 2. x \\<noteq> 0\\<^sub>h\n 3. \\<And>\\<phi> u.\n       \\<lbrakk>u \\<in> unit_disc; u \\<noteq> 0\\<^sub>h;\n        poincare_distance 0\\<^sub>h\n         (moebius_pt (moebius_rotation \\<phi>) u) =\n        (let x' = to_complex (moebius_pt (moebius_rotation \\<phi>) u)\n         in \\<bar>ln (Re (cor ((1 - cmod x') /\n                               (1 + cmod x'))))\\<bar>)\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h u =\n                         (let x' = to_complex u\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n 4. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                         (let x' = to_complex (of_complex x)\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "show \"x \\<in> unit_disc\" \"x \\<noteq> 0\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> unit_disc &&& x \\<noteq> 0\\<^sub>h", "by fact+"], ["proof (state)\nthis:\n  x \\<in> unit_disc\n  x \\<noteq> 0\\<^sub>h\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi> u.\n       \\<lbrakk>u \\<in> unit_disc; u \\<noteq> 0\\<^sub>h;\n        poincare_distance 0\\<^sub>h\n         (moebius_pt (moebius_rotation \\<phi>) u) =\n        (let x' = to_complex (moebius_pt (moebius_rotation \\<phi>) u)\n         in \\<bar>ln (Re (cor ((1 - cmod x') /\n                               (1 + cmod x'))))\\<bar>)\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h u =\n                         (let x' = to_complex u\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                         (let x' = to_complex (of_complex x)\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi> u.\n       \\<lbrakk>u \\<in> unit_disc; u \\<noteq> 0\\<^sub>h;\n        poincare_distance 0\\<^sub>h\n         (moebius_pt (moebius_rotation \\<phi>) u) =\n        (let x' = to_complex (moebius_pt (moebius_rotation \\<phi>) u)\n         in \\<bar>ln (Re (cor ((1 - cmod x') /\n                               (1 + cmod x'))))\\<bar>)\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h u =\n                         (let x' = to_complex u\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                         (let x' = to_complex (of_complex x)\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "fix \\<phi> u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi> u.\n       \\<lbrakk>u \\<in> unit_disc; u \\<noteq> 0\\<^sub>h;\n        poincare_distance 0\\<^sub>h\n         (moebius_pt (moebius_rotation \\<phi>) u) =\n        (let x' = to_complex (moebius_pt (moebius_rotation \\<phi>) u)\n         in \\<bar>ln (Re (cor ((1 - cmod x') /\n                               (1 + cmod x'))))\\<bar>)\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h u =\n                         (let x' = to_complex u\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                         (let x' = to_complex (of_complex x)\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "assume \"u \\<in> unit_disc\" \"u \\<noteq> 0\\<^sub>h\" \"?P (moebius_pt (moebius_rotation \\<phi>) u)\""], ["proof (state)\nthis:\n  u \\<in> unit_disc\n  u \\<noteq> 0\\<^sub>h\n  poincare_distance 0\\<^sub>h (moebius_pt (moebius_rotation \\<phi>) u) =\n  (let x' = to_complex (moebius_pt (moebius_rotation \\<phi>) u)\n   in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi> u.\n       \\<lbrakk>u \\<in> unit_disc; u \\<noteq> 0\\<^sub>h;\n        poincare_distance 0\\<^sub>h\n         (moebius_pt (moebius_rotation \\<phi>) u) =\n        (let x' = to_complex (moebius_pt (moebius_rotation \\<phi>) u)\n         in \\<bar>ln (Re (cor ((1 - cmod x') /\n                               (1 + cmod x'))))\\<bar>)\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h u =\n                         (let x' = to_complex u\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n 2. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                         (let x' = to_complex (of_complex x)\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "thus \"?P u\""], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  u \\<noteq> 0\\<^sub>h\n  poincare_distance 0\\<^sub>h (moebius_pt (moebius_rotation \\<phi>) u) =\n  (let x' = to_complex (moebius_pt (moebius_rotation \\<phi>) u)\n   in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h u =\n    (let x' = to_complex u\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "using unit_disc_fix_preserve_poincare_distance[of \"moebius_rotation \\<phi>\" \"0\\<^sub>h\" u]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  u \\<noteq> 0\\<^sub>h\n  poincare_distance 0\\<^sub>h (moebius_pt (moebius_rotation \\<phi>) u) =\n  (let x' = to_complex (moebius_pt (moebius_rotation \\<phi>) u)\n   in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n  \\<lbrakk>unit_disc_fix (moebius_rotation \\<phi>);\n   0\\<^sub>h \\<in> unit_disc; u \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance\n                     (moebius_pt (moebius_rotation \\<phi>) 0\\<^sub>h)\n                     (moebius_pt (moebius_rotation \\<phi>) u) =\n                    poincare_distance 0\\<^sub>h u\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h u =\n    (let x' = to_complex u\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "by (cases \"u = \\<infinity>\\<^sub>h\") (simp_all add: Let_def)"], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h u =\n  (let x' = to_complex u\n   in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                         (let x' = to_complex (of_complex x)\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                         (let x' = to_complex (of_complex x)\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                         (let x' = to_complex (of_complex x)\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "assume \"is_real x\" \"0 < Re x\" \"Re x < 1\""], ["proof (state)\nthis:\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                         (let x' = to_complex (of_complex x)\n                          in \\<bar>ln (Re\n  (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "thus \"?P (of_complex x)\""], ["proof (prove)\nusing this:\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex x) =\n    (let x' = to_complex (of_complex x)\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "using poincare_distance_zero_x_axis[of \"of_complex x\"]"], ["proof (prove)\nusing this:\n  is_real x\n  0 < Re x\n  Re x < 1\n  \\<lbrakk>of_complex x \\<in> unit_disc;\n   of_complex x \\<in> circline_set x_axis\\<rbrakk>\n  \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                    (let x' = to_complex (of_complex x)\n                     in \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex x) =\n    (let x' = to_complex (of_complex x)\n     in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)", "by simp (auto simp add: circline_set_x_axis cmod_eq_Re complex_is_Real_iff)"], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h (of_complex x) =\n  (let x' = to_complex (of_complex x)\n   in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h x =\n  (let x' = to_complex x\n   in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poincare_distance_zero_opposite [simp]:\n  assumes \"of_complex z \\<in> unit_disc\"\n  shows \"poincare_distance 0\\<^sub>h (of_complex (- z)) = poincare_distance 0\\<^sub>h (of_complex z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex (- z)) =\n    poincare_distance 0\\<^sub>h (of_complex z)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex (- z)) =\n    poincare_distance 0\\<^sub>h (of_complex z)", "have *: \"of_complex (-z) \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (- z) \\<in> unit_disc", "using assms"], ["proof (prove)\nusing this:\n  of_complex z \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. of_complex (- z) \\<in> unit_disc", "by auto"], ["proof (state)\nthis:\n  of_complex (- z) \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex (- z)) =\n    poincare_distance 0\\<^sub>h (of_complex z)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex (- z)) =\n    poincare_distance 0\\<^sub>h (of_complex z)", "using poincare_distance_zero[OF assms]"], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (of_complex z) =\n  (let x' = to_complex (of_complex z)\n   in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex (- z)) =\n    poincare_distance 0\\<^sub>h (of_complex z)", "using poincare_distance_zero[OF *]"], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (of_complex z) =\n  (let x' = to_complex (of_complex z)\n   in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n  poincare_distance 0\\<^sub>h (of_complex (- z)) =\n  (let x' = to_complex (of_complex (- z))\n   in \\<bar>ln (Re (cor ((1 - cmod x') / (1 + cmod x'))))\\<bar>)\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex (- z)) =\n    poincare_distance 0\\<^sub>h (of_complex z)", "by simp"], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h (of_complex (- z)) =\n  poincare_distance 0\\<^sub>h (of_complex z)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsection\\<open>Distance explicit formula\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "text\\<open>Instead of the h-distance itself, very frequently its hyperbolic cosine is analyzed.\\<close>"], ["", "abbreviation \"cosh_dist u v \\<equiv> cosh (poincare_distance u v)\""], ["", "lemma cosh_poincare_distance_cross_ratio_average:\n  assumes \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\" \"ideal_points (poincare_line u v) = {i1, i2}\"\n  shows \"cosh_dist u v =\n           ((Re_cross_ratio u i1 v i2) + (Re_cross_ratio v i1 u i2)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cosh_dist u v =\n    (Re_cross_ratio u i1 v i2 + Re_cross_ratio v i1 u i2) / 2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cosh_dist u v =\n    (Re_cross_ratio u i1 v i2 + Re_cross_ratio v i1 u i2) / 2", "let ?cr = \"cross_ratio u i1 v i2\""], ["proof (state)\ngoal (1 subgoal):\n 1. cosh_dist u v =\n    (Re_cross_ratio u i1 v i2 + Re_cross_ratio v i1 u i2) / 2", "let ?crRe = \"Re (to_complex ?cr)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cosh_dist u v =\n    (Re_cross_ratio u i1 v i2 + Re_cross_ratio v i1 u i2) / 2", "have \"?cr \\<noteq> \\<infinity>\\<^sub>h\" \"is_real (to_complex ?cr)\" \"?crRe > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h &&&\n    is_real (to_complex (cross_ratio u i1 v i2)) &&&\n    0 < Re_cross_ratio u i1 v i2", "using distance_cross_ratio_real_positive[OF assms(1-3)] assms(4)"], ["proof (prove)\nusing this:\n  \\<forall>i1 i2.\n     ideal_points (poincare_line u v) = {i1, i2} \\<longrightarrow>\n     cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h \\<and>\n     is_real (to_complex (cross_ratio u i1 v i2)) \\<and>\n     0 < Re_cross_ratio u i1 v i2\n  ideal_points (poincare_line u v) = {i1, i2}\n\ngoal (1 subgoal):\n 1. cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h &&&\n    is_real (to_complex (cross_ratio u i1 v i2)) &&&\n    0 < Re_cross_ratio u i1 v i2", "by simp_all"], ["proof (state)\nthis:\n  cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h\n  is_real (to_complex (cross_ratio u i1 v i2))\n  0 < Re_cross_ratio u i1 v i2\n\ngoal (1 subgoal):\n 1. cosh_dist u v =\n    (Re_cross_ratio u i1 v i2 + Re_cross_ratio v i1 u i2) / 2", "then"], ["proof (chain)\npicking this:\n  cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h\n  is_real (to_complex (cross_ratio u i1 v i2))\n  0 < Re_cross_ratio u i1 v i2", "obtain cr where *: \"cross_ratio u i1 v i2 = of_complex cr\" \"cr \\<noteq> 0\" \"is_real cr\" \"Re cr > 0\""], ["proof (prove)\nusing this:\n  cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h\n  is_real (to_complex (cross_ratio u i1 v i2))\n  0 < Re_cross_ratio u i1 v i2\n\ngoal (1 subgoal):\n 1. (\\<And>cr.\n        \\<lbrakk>cross_ratio u i1 v i2 = of_complex cr; cr \\<noteq> 0;\n         is_real cr; 0 < Re cr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inf_or_of_complex[of \"cross_ratio u i1 v i2\"]"], ["proof (prove)\nusing this:\n  cross_ratio u i1 v i2 \\<noteq> \\<infinity>\\<^sub>h\n  is_real (to_complex (cross_ratio u i1 v i2))\n  0 < Re_cross_ratio u i1 v i2\n  cross_ratio u i1 v i2 = \\<infinity>\\<^sub>h \\<or>\n  (\\<exists>x. cross_ratio u i1 v i2 = of_complex x)\n\ngoal (1 subgoal):\n 1. (\\<And>cr.\n        \\<lbrakk>cross_ratio u i1 v i2 = of_complex cr; cr \\<noteq> 0;\n         is_real cr; 0 < Re cr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (smt to_complex_of_complex zero_complex.simps(1))"], ["proof (state)\nthis:\n  cross_ratio u i1 v i2 = of_complex cr\n  cr \\<noteq> 0\n  is_real cr\n  0 < Re cr\n\ngoal (1 subgoal):\n 1. cosh_dist u v =\n    (Re_cross_ratio u i1 v i2 + Re_cross_ratio v i1 u i2) / 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  cross_ratio u i1 v i2 = of_complex cr\n  cr \\<noteq> 0\n  is_real cr\n  0 < Re cr\n\ngoal (1 subgoal):\n 1. cosh_dist u v =\n    (Re_cross_ratio u i1 v i2 + Re_cross_ratio v i1 u i2) / 2", "using *"], ["proof (prove)\nusing this:\n  cross_ratio u i1 v i2 = of_complex cr\n  cr \\<noteq> 0\n  is_real cr\n  0 < Re cr\n  cross_ratio u i1 v i2 = of_complex cr\n  cr \\<noteq> 0\n  is_real cr\n  0 < Re cr\n\ngoal (1 subgoal):\n 1. cosh_dist u v =\n    (Re_cross_ratio u i1 v i2 + Re_cross_ratio v i1 u i2) / 2", "using assms cross_ratio_commute_13[of v i1 u i2]"], ["proof (prove)\nusing this:\n  cross_ratio u i1 v i2 = of_complex cr\n  cr \\<noteq> 0\n  is_real cr\n  0 < Re cr\n  cross_ratio u i1 v i2 = of_complex cr\n  cr \\<noteq> 0\n  is_real cr\n  0 < Re cr\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n  ideal_points (poincare_line u v) = {i1, i2}\n  cross_ratio v i1 u i2 = reciprocal (cross_ratio u i1 v i2)\n\ngoal (1 subgoal):\n 1. cosh_dist u v =\n    (Re_cross_ratio u i1 v i2 + Re_cross_ratio v i1 u i2) / 2", "unfolding poincare_distance_I[OF assms] calc_poincare_distance_def cosh_def"], ["proof (prove)\nusing this:\n  cross_ratio u i1 v i2 = of_complex cr\n  cr \\<noteq> 0\n  is_real cr\n  0 < Re cr\n  cross_ratio u i1 v i2 = of_complex cr\n  cr \\<noteq> 0\n  is_real cr\n  0 < Re cr\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n  ideal_points (poincare_line u v) = {i1, i2}\n  cross_ratio v i1 u i2 = reciprocal (cross_ratio u i1 v i2)\n\ngoal (1 subgoal):\n 1. (exp \\<bar>ln (Re_cross_ratio u i1 v i2)\\<bar> +\n     exp (- \\<bar>ln (Re_cross_ratio u i1 v i2)\\<bar>)) /\\<^sub>R\n    2 =\n    (Re_cross_ratio u i1 v i2 + Re_cross_ratio v i1 u i2) / 2", "by (cases \"Re cr \\<ge> 1\")\n       (auto simp add: ln_div[of 0] exp_minus field_simps Re_divide power2_eq_square complex.expand)"], ["proof (state)\nthis:\n  cosh_dist u v = (Re_cross_ratio u i1 v i2 + Re_cross_ratio v i1 u i2) / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "definition poincare_distance_formula' :: \"complex \\<Rightarrow> complex \\<Rightarrow> real\" where\n[simp]: \"poincare_distance_formula' u v = 1 + 2 * ((cmod (u - v))\\<^sup>2 / ((1 - (cmod u)\\<^sup>2) * (1 - (cmod v)\\<^sup>2)))\""], ["", "text\\<open>Next we show that the following formula expresses h-distance between any two h-points (note\nthat the ideal points do not figure anymore).\\<close>"], ["", "definition poincare_distance_formula :: \"complex \\<Rightarrow> complex \\<Rightarrow> real\" where\n  [simp]: \"poincare_distance_formula u v = arcosh (poincare_distance_formula' u v)\""], ["", "lemma blaschke_preserve_distance_formula [simp]:\n  assumes \"of_complex k \\<in> unit_disc\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\"\n  shows \"poincare_distance_formula (to_complex (moebius_pt (blaschke k) u)) (to_complex (moebius_pt (blaschke k) v)) =\n         poincare_distance_formula (to_complex u) (to_complex v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "by simp"], ["proof (state)\nthis:\n  poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n   (to_complex (moebius_pt (blaschke k) v)) =\n  poincare_distance_formula (to_complex u) (to_complex v)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "obtain u' v' where *: \"u' = to_complex u\" \"v' = to_complex v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        \\<lbrakk>u' = to_complex u; v' = to_complex v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u' = to_complex u\n  v' = to_complex v\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"cmod u' < 1\" \"cmod v' < 1\" \"cmod k < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod u' < 1 &&& cmod v' < 1 &&& cmod k < 1", "using assms *"], ["proof (prove)\nusing this:\n  of_complex k \\<in> unit_disc\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u' = to_complex u\n  v' = to_complex v\n\ngoal (1 subgoal):\n 1. cmod u' < 1 &&& cmod v' < 1 &&& cmod k < 1", "using inf_or_of_complex[of u] inf_or_of_complex[of v]"], ["proof (prove)\nusing this:\n  of_complex k \\<in> unit_disc\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u' = to_complex u\n  v' = to_complex v\n  u = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. u = of_complex x)\n  v = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. v = of_complex x)\n\ngoal (1 subgoal):\n 1. cmod u' < 1 &&& cmod v' < 1 &&& cmod k < 1", "by auto"], ["proof (state)\nthis:\n  cmod u' < 1\n  cmod v' < 1\n  cmod k < 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "obtain nu du nv dv d kk ddu ddv where\n    **: \"nu = u' - k\" \"du = 1 - cnj k *u'\" \"nv = v' - k\" \"dv = 1 - cnj k * v'\"\n        \"d = u' - v'\" \"ddu = 1 - u'*cnj u'\" \"ddv = 1 - v'*cnj v'\" \"kk = 1 - k*cnj k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nu du nv dv d ddu ddv kk.\n        \\<lbrakk>nu = u' - k; du = 1 - cnj k * u'; nv = v' - k;\n         dv = 1 - cnj k * v'; d = u' - v'; ddu = 1 - u' * cnj u';\n         ddv = 1 - v' * cnj v'; kk = 1 - k * cnj k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  nu = u' - k\n  du = 1 - cnj k * u'\n  nv = v' - k\n  dv = 1 - cnj k * v'\n  d = u' - v'\n  ddu = 1 - u' * cnj u'\n  ddv = 1 - v' * cnj v'\n  kk = 1 - k * cnj k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have d: \"nu*dv - nv*du = d*kk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nu * dv - nv * du = d * kk", "by (subst **)+ (simp add: field_simps)"], ["proof (state)\nthis:\n  nu * dv - nv * du = d * kk\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have ddu: \"du*cnj du - nu*cnj nu = ddu*kk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. du * cnj du - nu * cnj nu = ddu * kk", "by (subst **)+ (simp add: field_simps)"], ["proof (state)\nthis:\n  du * cnj du - nu * cnj nu = ddu * kk\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have ddv: \"dv*cnj dv - nv*cnj nv = ddv*kk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dv * cnj dv - nv * cnj nv = ddv * kk", "by (subst **)+ (simp add: field_simps)"], ["proof (state)\nthis:\n  dv * cnj dv - nv * cnj nv = ddv * kk\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"du \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. du \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> du \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> du \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> du \\<noteq> 0 \\<Longrightarrow> False", "hence \"cmod (1 - cnj k * u') = 0\""], ["proof (prove)\nusing this:\n  \\<not> du \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod (1 - cnj k * u') = 0", "using \\<open>du = 1 - cnj k * u'\\<close>"], ["proof (prove)\nusing this:\n  \\<not> du \\<noteq> 0\n  du = 1 - cnj k * u'\n\ngoal (1 subgoal):\n 1. cmod (1 - cnj k * u') = 0", "by auto"], ["proof (state)\nthis:\n  cmod (1 - cnj k * u') = 0\n\ngoal (1 subgoal):\n 1. \\<not> du \\<noteq> 0 \\<Longrightarrow> False", "hence \"cmod (cnj k * u') = 1\""], ["proof (prove)\nusing this:\n  cmod (1 - cnj k * u') = 0\n\ngoal (1 subgoal):\n 1. cmod (cnj k * u') = 1", "by auto"], ["proof (state)\nthis:\n  cmod (cnj k * u') = 1\n\ngoal (1 subgoal):\n 1. \\<not> du \\<noteq> 0 \\<Longrightarrow> False", "hence \"cmod k * cmod u' = 1\""], ["proof (prove)\nusing this:\n  cmod (cnj k * u') = 1\n\ngoal (1 subgoal):\n 1. cmod k * cmod u' = 1", "by auto"], ["proof (state)\nthis:\n  cmod k * cmod u' = 1\n\ngoal (1 subgoal):\n 1. \\<not> du \\<noteq> 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  cmod k * cmod u' = 1\n\ngoal (1 subgoal):\n 1. False", "using \\<open>cmod k < 1\\<close> \\<open>cmod u' < 1\\<close>"], ["proof (prove)\nusing this:\n  cmod k * cmod u' = 1\n  cmod k < 1\n  cmod u' < 1\n\ngoal (1 subgoal):\n 1. False", "using mult_strict_mono[of \"cmod k\" 1 \"cmod u'\" 1]"], ["proof (prove)\nusing this:\n  cmod k * cmod u' = 1\n  cmod k < 1\n  cmod u' < 1\n  \\<lbrakk>cmod k < 1; cmod u' < 1; 0 < 1; 0 \\<le> cmod u'\\<rbrakk>\n  \\<Longrightarrow> cmod k * cmod u' < 1 * 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  du \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"dv \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dv \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dv \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> dv \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> dv \\<noteq> 0 \\<Longrightarrow> False", "hence \"cmod (1 - cnj k * v') = 0\""], ["proof (prove)\nusing this:\n  \\<not> dv \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod (1 - cnj k * v') = 0", "using \\<open>dv = 1 - cnj k * v'\\<close>"], ["proof (prove)\nusing this:\n  \\<not> dv \\<noteq> 0\n  dv = 1 - cnj k * v'\n\ngoal (1 subgoal):\n 1. cmod (1 - cnj k * v') = 0", "by auto"], ["proof (state)\nthis:\n  cmod (1 - cnj k * v') = 0\n\ngoal (1 subgoal):\n 1. \\<not> dv \\<noteq> 0 \\<Longrightarrow> False", "hence \"cmod (cnj k * v') = 1\""], ["proof (prove)\nusing this:\n  cmod (1 - cnj k * v') = 0\n\ngoal (1 subgoal):\n 1. cmod (cnj k * v') = 1", "by auto"], ["proof (state)\nthis:\n  cmod (cnj k * v') = 1\n\ngoal (1 subgoal):\n 1. \\<not> dv \\<noteq> 0 \\<Longrightarrow> False", "hence \"cmod k * cmod v' = 1\""], ["proof (prove)\nusing this:\n  cmod (cnj k * v') = 1\n\ngoal (1 subgoal):\n 1. cmod k * cmod v' = 1", "by auto"], ["proof (state)\nthis:\n  cmod k * cmod v' = 1\n\ngoal (1 subgoal):\n 1. \\<not> dv \\<noteq> 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  cmod k * cmod v' = 1\n\ngoal (1 subgoal):\n 1. False", "using \\<open>cmod k < 1\\<close> \\<open>cmod v' < 1\\<close>"], ["proof (prove)\nusing this:\n  cmod k * cmod v' = 1\n  cmod k < 1\n  cmod v' < 1\n\ngoal (1 subgoal):\n 1. False", "using mult_strict_mono[of \"cmod k\" 1 \"cmod v'\" 1]"], ["proof (prove)\nusing this:\n  cmod k * cmod v' = 1\n  cmod k < 1\n  cmod v' < 1\n  \\<lbrakk>cmod k < 1; cmod v' < 1; 0 < 1; 0 \\<le> cmod v'\\<rbrakk>\n  \\<Longrightarrow> cmod k * cmod v' < 1 * 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dv \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"kk \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kk \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> kk \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> kk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> kk \\<noteq> 0 \\<Longrightarrow> False", "hence \"cmod (1 - k * cnj k) = 0\""], ["proof (prove)\nusing this:\n  \\<not> kk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod (1 - k * cnj k) = 0", "using \\<open>kk = 1 - k * cnj k\\<close>"], ["proof (prove)\nusing this:\n  \\<not> kk \\<noteq> 0\n  kk = 1 - k * cnj k\n\ngoal (1 subgoal):\n 1. cmod (1 - k * cnj k) = 0", "by auto"], ["proof (state)\nthis:\n  cmod (1 - k * cnj k) = 0\n\ngoal (1 subgoal):\n 1. \\<not> kk \\<noteq> 0 \\<Longrightarrow> False", "hence \"cmod (k * cnj k) = 1\""], ["proof (prove)\nusing this:\n  cmod (1 - k * cnj k) = 0\n\ngoal (1 subgoal):\n 1. cmod (k * cnj k) = 1", "by auto"], ["proof (state)\nthis:\n  cmod (k * cnj k) = 1\n\ngoal (1 subgoal):\n 1. \\<not> kk \\<noteq> 0 \\<Longrightarrow> False", "hence \"cmod k * cmod k = 1\""], ["proof (prove)\nusing this:\n  cmod (k * cnj k) = 1\n\ngoal (1 subgoal):\n 1. cmod k * cmod k = 1", "by auto"], ["proof (state)\nthis:\n  cmod k * cmod k = 1\n\ngoal (1 subgoal):\n 1. \\<not> kk \\<noteq> 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  cmod k * cmod k = 1\n\ngoal (1 subgoal):\n 1. False", "using \\<open>cmod k < 1\\<close>"], ["proof (prove)\nusing this:\n  cmod k * cmod k = 1\n  cmod k < 1\n\ngoal (1 subgoal):\n 1. False", "using mult_strict_mono[of \"cmod k\" 1 \"cmod k\" 1]"], ["proof (prove)\nusing this:\n  cmod k * cmod k = 1\n  cmod k < 1\n  \\<lbrakk>cmod k < 1; cmod k < 1; 0 < 1; 0 \\<le> cmod k\\<rbrakk>\n  \\<Longrightarrow> cmod k * cmod k < 1 * 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  kk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "note nz = \\<open>du \\<noteq> 0\\<close> \\<open>dv \\<noteq> 0\\<close> \\<open>kk \\<noteq> 0\\<close>"], ["proof (state)\nthis:\n  du \\<noteq> 0\n  dv \\<noteq> 0\n  kk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"nu / du - nv / dv = (nu*dv - nv*du) / (du * dv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nu / du - nv / dv = (nu * dv - nv * du) / (du * dv)", "using nz"], ["proof (prove)\nusing this:\n  du \\<noteq> 0\n  dv \\<noteq> 0\n  kk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. nu / du - nv / dv = (nu * dv - nv * du) / (du * dv)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  nu / du - nv / dv = (nu * dv - nv * du) / (du * dv)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "hence \"(cmod (nu/du - nv/dv))\\<^sup>2 = cmod ((d*kk) / (du*dv) * (cnj ((d*kk) / (du*dv))))\" (is \"?lhs = _\")"], ["proof (prove)\nusing this:\n  nu / du - nv / dv = (nu * dv - nv * du) / (du * dv)\n\ngoal (1 subgoal):\n 1. (cmod (nu / du - nv / dv))\\<^sup>2 =\n    cmod (d * kk / (du * dv) * cnj (d * kk / (du * dv)))", "unfolding complex_mod_mult_cnj[symmetric]"], ["proof (prove)\nusing this:\n  nu / du - nv / dv = (nu * dv - nv * du) / (du * dv)\n\ngoal (1 subgoal):\n 1. cmod ((nu / du - nv / dv) * cnj (nu / du - nv / dv)) =\n    cmod (d * kk / (du * dv) * cnj (d * kk / (du * dv)))", "by (subst (asm) d) simp"], ["proof (state)\nthis:\n  (cmod (nu / du - nv / dv))\\<^sup>2 =\n  cmod (d * kk / (du * dv) * cnj (d * kk / (du * dv)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "also"], ["proof (state)\nthis:\n  (cmod (nu / du - nv / dv))\\<^sup>2 =\n  cmod (d * kk / (du * dv) * cnj (d * kk / (du * dv)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"... = cmod ((d*cnj d*kk*kk) / (du*cnj du*dv*cnj dv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (d * kk / (du * dv) * cnj (d * kk / (du * dv))) =\n    cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cmod (d * kk / (du * dv) * cnj (d * kk / (du * dv))) =\n  cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "finally"], ["proof (chain)\npicking this:\n  (cmod (nu / du - nv / dv))\\<^sup>2 =\n  cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv))", "have 1: \"?lhs = cmod ((d*cnj d*kk*kk) / (du*cnj du*dv*cnj dv))\""], ["proof (prove)\nusing this:\n  (cmod (nu / du - nv / dv))\\<^sup>2 =\n  cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv))\n\ngoal (1 subgoal):\n 1. (cmod (nu / du - nv / dv))\\<^sup>2 =\n    cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv))", "."], ["proof (state)\nthis:\n  (cmod (nu / du - nv / dv))\\<^sup>2 =\n  cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"(1 - ((cmod nu) / (cmod du))\\<^sup>2)*(1 - ((cmod nv) / (cmod dv))\\<^sup>2) =\n        (1 - cmod((nu * cnj nu) / (du * cnj du)))*(1 - cmod((nv * cnj nv) / (dv * cnj dv)))\" (is \"?rhs = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2) =\n    (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv)))", "by (metis cmod_divide complex_mod_mult_cnj power_divide)"], ["proof (state)\nthis:\n  (1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2) =\n  (1 - cmod (nu * cnj nu / (du * cnj du))) *\n  (1 - cmod (nv * cnj nv / (dv * cnj dv)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "also"], ["proof (state)\nthis:\n  (1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2) =\n  (1 - cmod (nu * cnj nu / (du * cnj du))) *\n  (1 - cmod (nv * cnj nv / (dv * cnj dv)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"... = cmod(((du*cnj du - nu*cnj nu) / (du * cnj du)) * ((dv*cnj dv - nv*cnj nv) / (dv * cnj dv)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "have \"u' \\<noteq> 1 / cnj k\" \"v' \\<noteq> 1 / cnj k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u' \\<noteq> 1 / cnj k &&& v' \\<noteq> 1 / cnj k", "using \\<open>cmod u' < 1\\<close> \\<open>cmod v' < 1\\<close> \\<open>cmod k < 1\\<close>"], ["proof (prove)\nusing this:\n  cmod u' < 1\n  cmod v' < 1\n  cmod k < 1\n\ngoal (1 subgoal):\n 1. u' \\<noteq> 1 / cnj k &&& v' \\<noteq> 1 / cnj k", "by (auto simp add: False)"], ["proof (state)\nthis:\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "moreover"], ["proof (state)\nthis:\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "have \"cmod k \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod k \\<noteq> 1", "using \\<open>cmod k < 1\\<close>"], ["proof (prove)\nusing this:\n  cmod k < 1\n\ngoal (1 subgoal):\n 1. cmod k \\<noteq> 1", "by linarith"], ["proof (state)\nthis:\n  cmod k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "ultimately"], ["proof (chain)\npicking this:\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  cmod k \\<noteq> 1", "have \"cmod (nu/du) < 1\" \"cmod (nv/dv) < 1\""], ["proof (prove)\nusing this:\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  cmod k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. cmod (nu / du) < 1 &&& cmod (nv / dv) < 1", "using **(1-4)"], ["proof (prove)\nusing this:\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  cmod k \\<noteq> 1\n  nu = u' - k\n  du = 1 - cnj k * u'\n  nv = v' - k\n  dv = 1 - cnj k * v'\n\ngoal (1 subgoal):\n 1. cmod (nu / du) < 1 &&& cmod (nv / dv) < 1", "using unit_disc_fix_discI[OF blaschke_unit_disc_fix[OF \\<open>cmod k < 1\\<close>] \\<open>u \\<in> unit_disc\\<close>] \\<open>u' = to_complex u\\<close>"], ["proof (prove)\nusing this:\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  cmod k \\<noteq> 1\n  nu = u' - k\n  du = 1 - cnj k * u'\n  nv = v' - k\n  dv = 1 - cnj k * v'\n  moebius_pt (blaschke k) u \\<in> unit_disc\n  u' = to_complex u\n\ngoal (1 subgoal):\n 1. cmod (nu / du) < 1 &&& cmod (nv / dv) < 1", "using unit_disc_fix_discI[OF blaschke_unit_disc_fix[OF \\<open>cmod k < 1\\<close>] \\<open>v \\<in> unit_disc\\<close>] \\<open>v' = to_complex v\\<close>"], ["proof (prove)\nusing this:\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  cmod k \\<noteq> 1\n  nu = u' - k\n  du = 1 - cnj k * u'\n  nv = v' - k\n  dv = 1 - cnj k * v'\n  moebius_pt (blaschke k) u \\<in> unit_disc\n  u' = to_complex u\n  moebius_pt (blaschke k) v \\<in> unit_disc\n  v' = to_complex v\n\ngoal (1 subgoal):\n 1. cmod (nu / du) < 1 &&& cmod (nv / dv) < 1", "using inf_or_of_complex[of u] \\<open>u \\<in> unit_disc\\<close> inf_or_of_complex[of v] \\<open>v \\<in> unit_disc\\<close>"], ["proof (prove)\nusing this:\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  cmod k \\<noteq> 1\n  nu = u' - k\n  du = 1 - cnj k * u'\n  nv = v' - k\n  dv = 1 - cnj k * v'\n  moebius_pt (blaschke k) u \\<in> unit_disc\n  u' = to_complex u\n  moebius_pt (blaschke k) v \\<in> unit_disc\n  v' = to_complex v\n  u = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. u = of_complex x)\n  u \\<in> unit_disc\n  v = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. v = of_complex x)\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. cmod (nu / du) < 1 &&& cmod (nv / dv) < 1", "using moebius_pt_blaschke[of k u']"], ["proof (prove)\nusing this:\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  cmod k \\<noteq> 1\n  nu = u' - k\n  du = 1 - cnj k * u'\n  nv = v' - k\n  dv = 1 - cnj k * v'\n  moebius_pt (blaschke k) u \\<in> unit_disc\n  u' = to_complex u\n  moebius_pt (blaschke k) v \\<in> unit_disc\n  v' = to_complex v\n  u = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. u = of_complex x)\n  u \\<in> unit_disc\n  v = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. v = of_complex x)\n  v \\<in> unit_disc\n  \\<lbrakk>cmod k \\<noteq> 1; u' \\<noteq> 1 / cnj k\\<rbrakk>\n  \\<Longrightarrow> moebius_pt (blaschke k) (of_complex u') =\n                    of_complex ((u' - k) / (1 - cnj k * u'))\n\ngoal (1 subgoal):\n 1. cmod (nu / du) < 1 &&& cmod (nv / dv) < 1", "using moebius_pt_blaschke[of k v']"], ["proof (prove)\nusing this:\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  cmod k \\<noteq> 1\n  nu = u' - k\n  du = 1 - cnj k * u'\n  nv = v' - k\n  dv = 1 - cnj k * v'\n  moebius_pt (blaschke k) u \\<in> unit_disc\n  u' = to_complex u\n  moebius_pt (blaschke k) v \\<in> unit_disc\n  v' = to_complex v\n  u = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. u = of_complex x)\n  u \\<in> unit_disc\n  v = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. v = of_complex x)\n  v \\<in> unit_disc\n  \\<lbrakk>cmod k \\<noteq> 1; u' \\<noteq> 1 / cnj k\\<rbrakk>\n  \\<Longrightarrow> moebius_pt (blaschke k) (of_complex u') =\n                    of_complex ((u' - k) / (1 - cnj k * u'))\n  \\<lbrakk>cmod k \\<noteq> 1; v' \\<noteq> 1 / cnj k\\<rbrakk>\n  \\<Longrightarrow> moebius_pt (blaschke k) (of_complex v') =\n                    of_complex ((v' - k) / (1 - cnj k * v'))\n\ngoal (1 subgoal):\n 1. cmod (nu / du) < 1 &&& cmod (nv / dv) < 1", "by auto"], ["proof (state)\nthis:\n  cmod (nu / du) < 1\n  cmod (nv / dv) < 1\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "hence \"(cmod (nu/du))\\<^sup>2 < 1\" \"(cmod (nv/dv))\\<^sup>2 < 1\""], ["proof (prove)\nusing this:\n  cmod (nu / du) < 1\n  cmod (nv / dv) < 1\n\ngoal (1 subgoal):\n 1. (cmod (nu / du))\\<^sup>2 < 1 &&& (cmod (nv / dv))\\<^sup>2 < 1", "by (simp_all add: cmod_def)"], ["proof (state)\nthis:\n  (cmod (nu / du))\\<^sup>2 < 1\n  (cmod (nv / dv))\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "hence \"cmod (nu * cnj nu / (du * cnj du)) < 1\"  \"cmod (nv * cnj nv / (dv * cnj dv)) < 1\""], ["proof (prove)\nusing this:\n  (cmod (nu / du))\\<^sup>2 < 1\n  (cmod (nv / dv))\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. cmod (nu * cnj nu / (du * cnj du)) < 1 &&&\n    cmod (nv * cnj nv / (dv * cnj dv)) < 1", "by (metis complex_mod_mult_cnj norm_divide power_divide)+"], ["proof (state)\nthis:\n  cmod (nu * cnj nu / (du * cnj du)) < 1\n  cmod (nv * cnj nv / (dv * cnj dv)) < 1\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "moreover"], ["proof (state)\nthis:\n  cmod (nu * cnj nu / (du * cnj du)) < 1\n  cmod (nv * cnj nv / (dv * cnj dv)) < 1\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "have \"is_real (nu * cnj nu / (du * cnj du))\" \"is_real (nv * cnj nv / (dv * cnj dv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (nu * cnj nu / (du * cnj du)) &&&\n    is_real (nv * cnj nv / (dv * cnj dv))", "using eq_cnj_iff_real[of \"nu * cnj nu / (du * cnj du)\"]"], ["proof (prove)\nusing this:\n  (cnj (nu * cnj nu / (du * cnj du)) = nu * cnj nu / (du * cnj du)) =\n  is_real (nu * cnj nu / (du * cnj du))\n\ngoal (1 subgoal):\n 1. is_real (nu * cnj nu / (du * cnj du)) &&&\n    is_real (nv * cnj nv / (dv * cnj dv))", "using eq_cnj_iff_real[of \"nv * cnj nv / (dv * cnj dv)\"]"], ["proof (prove)\nusing this:\n  (cnj (nu * cnj nu / (du * cnj du)) = nu * cnj nu / (du * cnj du)) =\n  is_real (nu * cnj nu / (du * cnj du))\n  (cnj (nv * cnj nv / (dv * cnj dv)) = nv * cnj nv / (dv * cnj dv)) =\n  is_real (nv * cnj nv / (dv * cnj dv))\n\ngoal (1 subgoal):\n 1. is_real (nu * cnj nu / (du * cnj du)) &&&\n    is_real (nv * cnj nv / (dv * cnj dv))", "by (auto simp add: mult.commute)"], ["proof (state)\nthis:\n  is_real (nu * cnj nu / (du * cnj du))\n  is_real (nv * cnj nv / (dv * cnj dv))\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "moreover"], ["proof (state)\nthis:\n  is_real (nu * cnj nu / (du * cnj du))\n  is_real (nv * cnj nv / (dv * cnj dv))\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "have \"Re (nu * cnj nu / (du * cnj du)) \\<ge> 0\"  \"Re (nv * cnj nv / (dv * cnj dv)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Re (nu * cnj nu / (du * cnj du)) &&&\n    0 \\<le> Re (nv * cnj nv / (dv * cnj dv))", "using \\<open>du \\<noteq> 0\\<close> \\<open>dv \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  du \\<noteq> 0\n  dv \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re (nu * cnj nu / (du * cnj du)) &&&\n    0 \\<le> Re (nv * cnj nv / (dv * cnj dv))", "unfolding complex_mult_cnj_cmod"], ["proof (prove)\nusing this:\n  du \\<noteq> 0\n  dv \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re (cor ((cmod nu)\\<^sup>2) / cor ((cmod du)\\<^sup>2)) &&&\n    0 \\<le> Re (cor ((cmod nv)\\<^sup>2) / cor ((cmod dv)\\<^sup>2))", "by simp_all"], ["proof (state)\nthis:\n  0 \\<le> Re (nu * cnj nu / (du * cnj du))\n  0 \\<le> Re (nv * cnj nv / (dv * cnj dv))\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "ultimately"], ["proof (chain)\npicking this:\n  cmod (nu * cnj nu / (du * cnj du)) < 1\n  cmod (nv * cnj nv / (dv * cnj dv)) < 1\n  is_real (nu * cnj nu / (du * cnj du))\n  is_real (nv * cnj nv / (dv * cnj dv))\n  0 \\<le> Re (nu * cnj nu / (du * cnj du))\n  0 \\<le> Re (nv * cnj nv / (dv * cnj dv))", "have \"1 - cmod (nu * cnj nu / (du * cnj du)) = cmod (1 - nu * cnj nu / (du * cnj du))\"\n         \"1 - cmod (nv * cnj nv / (dv * cnj dv)) = cmod (1 - nv * cnj nv / (dv * cnj dv))\""], ["proof (prove)\nusing this:\n  cmod (nu * cnj nu / (du * cnj du)) < 1\n  cmod (nv * cnj nv / (dv * cnj dv)) < 1\n  is_real (nu * cnj nu / (du * cnj du))\n  is_real (nv * cnj nv / (dv * cnj dv))\n  0 \\<le> Re (nu * cnj nu / (du * cnj du))\n  0 \\<le> Re (nv * cnj nv / (dv * cnj dv))\n\ngoal (1 subgoal):\n 1. 1 - cmod (nu * cnj nu / (du * cnj du)) =\n    cmod (1 - nu * cnj nu / (du * cnj du)) &&&\n    1 - cmod (nv * cnj nv / (dv * cnj dv)) =\n    cmod (1 - nv * cnj nv / (dv * cnj dv))", "by (simp_all add: cmod_def)"], ["proof (state)\nthis:\n  1 - cmod (nu * cnj nu / (du * cnj du)) =\n  cmod (1 - nu * cnj nu / (du * cnj du))\n  1 - cmod (nv * cnj nv / (dv * cnj dv)) =\n  cmod (1 - nv * cnj nv / (dv * cnj dv))\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 - cmod (nu * cnj nu / (du * cnj du)) =\n  cmod (1 - nu * cnj nu / (du * cnj du))\n  1 - cmod (nv * cnj nv / (dv * cnj dv)) =\n  cmod (1 - nv * cnj nv / (dv * cnj dv))\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "using nz"], ["proof (prove)\nusing this:\n  1 - cmod (nu * cnj nu / (du * cnj du)) =\n  cmod (1 - nu * cnj nu / (du * cnj du))\n  1 - cmod (nv * cnj nv / (dv * cnj dv)) =\n  cmod (1 - nv * cnj nv / (dv * cnj dv))\n  du \\<noteq> 0\n  dv \\<noteq> 0\n  kk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (1 - cmod (nu * cnj nu / (du * cnj du))) *\n    (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n    cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 - cmod nu * cmod nu / (cmod du * cmod du) =\n             cmod (1 - nu * cnj nu / (du * cnj du));\n     1 - cmod nv * cmod nv / (cmod dv * cmod dv) =\n     cmod (1 - nv * cnj nv / (dv * cnj dv));\n     du \\<noteq> 0; dv \\<noteq> 0; kk \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod (1 - nu * cnj nu / (du * cnj du)) *\n                      cmod (1 - nv * cnj nv / (dv * cnj dv)) =\n                      cmod (du * cnj du - nu * cnj nu) *\n                      cmod (dv * cnj dv - nv * cnj nv) /\n                      (cmod du * cmod du * (cmod dv * cmod dv))", "apply (subst diff_divide_eq_iff, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 - cmod nu * cmod nu / (cmod du * cmod du) =\n             cmod (1 - nu * cnj nu / (du * cnj du));\n     1 - cmod nv * cmod nv / (cmod dv * cmod dv) =\n     cmod (1 - nv * cnj nv / (dv * cnj dv));\n     du \\<noteq> 0; dv \\<noteq> 0; kk \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod (du * cnj du - nu * cnj nu) *\n                      cmod (1 - nv * cnj nv / (dv * cnj dv)) /\n                      (cmod du * cmod du) =\n                      cmod (du * cnj du - nu * cnj nu) *\n                      cmod (dv * cnj dv - nv * cnj nv) /\n                      (cmod du * cmod du * (cmod dv * cmod dv))", "apply (subst diff_divide_eq_iff, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (1 - cmod (nu * cnj nu / (du * cnj du))) *\n  (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n  cmod\n   ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n    ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (1 - cmod (nu * cnj nu / (du * cnj du))) *\n  (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n  cmod\n   ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n    ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "also"], ["proof (state)\nthis:\n  (1 - cmod (nu * cnj nu / (du * cnj du))) *\n  (1 - cmod (nv * cnj nv / (dv * cnj dv))) =\n  cmod\n   ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n    ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"... = cmod(((ddu * kk) / (du * cnj du)) * ((ddv * kk) / (dv * cnj dv)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n      ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv))) =\n    cmod (ddu * kk / (du * cnj du) * (ddv * kk / (dv * cnj dv)))", "by (subst ddu, subst ddv, simp)"], ["proof (state)\nthis:\n  cmod\n   ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n    ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv))) =\n  cmod (ddu * kk / (du * cnj du) * (ddv * kk / (dv * cnj dv)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "also"], ["proof (state)\nthis:\n  cmod\n   ((du * cnj du - nu * cnj nu) / (du * cnj du) *\n    ((dv * cnj dv - nv * cnj nv) / (dv * cnj dv))) =\n  cmod (ddu * kk / (du * cnj du) * (ddv * kk / (dv * cnj dv)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"... = cmod((ddu*ddv*kk*kk) / (du*cnj du*dv*cnj dv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (ddu * kk / (du * cnj du) * (ddv * kk / (dv * cnj dv))) =\n    cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cmod (ddu * kk / (du * cnj du) * (ddv * kk / (dv * cnj dv))) =\n  cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "finally"], ["proof (chain)\npicking this:\n  (1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2) =\n  cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv))", "have 2: \"?rhs = cmod((ddu*ddv*kk*kk) / (du*cnj du*dv*cnj dv))\""], ["proof (prove)\nusing this:\n  (1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2) =\n  cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv))\n\ngoal (1 subgoal):\n 1. (1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2) =\n    cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv))", "."], ["proof (state)\nthis:\n  (1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2) =\n  cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"?lhs / ?rhs =\n       cmod ((d*cnj d*kk*kk) / (du*cnj du*dv*cnj dv)) / cmod((ddu*ddv*kk*kk) / (du*cnj du*dv*cnj dv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (nu / du - nv / dv))\\<^sup>2 /\n    ((1 - (cmod nu / cmod du)\\<^sup>2) *\n     (1 - (cmod nv / cmod dv)\\<^sup>2)) =\n    cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv)) /\n    cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv))", "by (subst 1, subst 2, simp)"], ["proof (state)\nthis:\n  (cmod (nu / du - nv / dv))\\<^sup>2 /\n  ((1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2)) =\n  cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv)) /\n  cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "also"], ["proof (state)\nthis:\n  (cmod (nu / du - nv / dv))\\<^sup>2 /\n  ((1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2)) =\n  cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv)) /\n  cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"... = cmod ((d*cnj d)/(ddu*ddv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv)) /\n    cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv)) =\n    cmod (d * cnj d / (ddu * ddv))", "using nz"], ["proof (prove)\nusing this:\n  du \\<noteq> 0\n  dv \\<noteq> 0\n  kk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv)) /\n    cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv)) =\n    cmod (d * cnj d / (ddu * ddv))", "by simp"], ["proof (state)\nthis:\n  cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv)) /\n  cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv)) =\n  cmod (d * cnj d / (ddu * ddv))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "also"], ["proof (state)\nthis:\n  cmod (d * cnj d * kk * kk / (du * cnj du * dv * cnj dv)) /\n  cmod (ddu * ddv * kk * kk / (du * cnj du * dv * cnj dv)) =\n  cmod (d * cnj d / (ddu * ddv))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"... = (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2)*(1 - (cmod v')\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (d * cnj d / (ddu * ddv)) =\n    (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (d * cnj d / (ddu * ddv)) =\n    (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "have \"(cmod u')\\<^sup>2 < 1\" \"(cmod v')\\<^sup>2 < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod u')\\<^sup>2 < 1 &&& (cmod v')\\<^sup>2 < 1", "using \\<open>cmod u' < 1\\<close> \\<open>cmod v' < 1\\<close>"], ["proof (prove)\nusing this:\n  cmod u' < 1\n  cmod v' < 1\n\ngoal (1 subgoal):\n 1. (cmod u')\\<^sup>2 < 1 &&& (cmod v')\\<^sup>2 < 1", "by (simp_all add: cmod_def)"], ["proof (state)\nthis:\n  (cmod u')\\<^sup>2 < 1\n  (cmod v')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. cmod (d * cnj d / (ddu * ddv)) =\n    (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "hence \"cmod (1 - u' * cnj u') = 1 - (cmod u')\\<^sup>2\" \"cmod (1 - v' * cnj v') = 1 - (cmod v')\\<^sup>2\""], ["proof (prove)\nusing this:\n  (cmod u')\\<^sup>2 < 1\n  (cmod v')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. cmod (1 - u' * cnj u') = 1 - (cmod u')\\<^sup>2 &&&\n    cmod (1 - v' * cnj v') = 1 - (cmod v')\\<^sup>2", "by (auto simp add: cmod_eq_Re cmod_power2 power2_eq_square[symmetric])"], ["proof (state)\nthis:\n  cmod (1 - u' * cnj u') = 1 - (cmod u')\\<^sup>2\n  cmod (1 - v' * cnj v') = 1 - (cmod v')\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (d * cnj d / (ddu * ddv)) =\n    (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  cmod (1 - u' * cnj u') = 1 - (cmod u')\\<^sup>2\n  cmod (1 - v' * cnj v') = 1 - (cmod v')\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (d * cnj d / (ddu * ddv)) =\n    (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "using nz"], ["proof (prove)\nusing this:\n  cmod (1 - u' * cnj u') = 1 - (cmod u')\\<^sup>2\n  cmod (1 - v' * cnj v') = 1 - (cmod v')\\<^sup>2\n  du \\<noteq> 0\n  dv \\<noteq> 0\n  kk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod (d * cnj d / (ddu * ddv)) =\n    (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "apply (subst **)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod (1 - u' * cnj u') = 1 - (cmod u')\\<^sup>2;\n     cmod (1 - v' * cnj v') = 1 - (cmod v')\\<^sup>2; du \\<noteq> 0;\n     dv \\<noteq> 0; kk \\<noteq> 0;\n     cmod (1 - u' * cnj u') = 1 - (cmod u')\\<^sup>2;\n     cmod (1 - v' * cnj v') = 1 - (cmod v')\\<^sup>2; du \\<noteq> 0;\n     dv \\<noteq> 0; kk \\<noteq> 0;\n     cmod (1 - u' * cnj u') = 1 - (cmod u')\\<^sup>2;\n     cmod (1 - v' * cnj v') = 1 - (cmod v')\\<^sup>2; du \\<noteq> 0;\n     dv \\<noteq> 0; kk \\<noteq> 0;\n     cmod (1 - u' * cnj u') = 1 - (cmod u')\\<^sup>2;\n     cmod (1 - v' * cnj v') = 1 - (cmod v')\\<^sup>2; du \\<noteq> 0;\n     dv \\<noteq> 0; kk \\<noteq> 0;\n     cmod (1 - u' * cnj u') = 1 - (cmod u')\\<^sup>2;\n     cmod (1 - v' * cnj v') = 1 - (cmod v')\\<^sup>2; du \\<noteq> 0;\n     dv \\<noteq> 0; kk \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod\n                       ((u' - v') * cnj (u' - v') /\n                        ((1 - u' * cnj u') * (1 - v' * cnj v'))) =\n                      (cmod (u' - v'))\\<^sup>2 /\n                      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "unfolding complex_mod_mult_cnj[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cmod (1 - u' * cnj u') = 1 - cmod (u' * cnj u');\n     cmod (1 - v' * cnj v') = 1 - cmod (v' * cnj v'); du \\<noteq> 0;\n     dv \\<noteq> 0; kk \\<noteq> 0;\n     cmod (1 - u' * cnj u') = 1 - cmod (u' * cnj u');\n     cmod (1 - v' * cnj v') = 1 - cmod (v' * cnj v'); du \\<noteq> 0;\n     dv \\<noteq> 0; kk \\<noteq> 0;\n     cmod (1 - u' * cnj u') = 1 - cmod (u' * cnj u');\n     cmod (1 - v' * cnj v') = 1 - cmod (v' * cnj v'); du \\<noteq> 0;\n     dv \\<noteq> 0; kk \\<noteq> 0;\n     cmod (1 - u' * cnj u') = 1 - cmod (u' * cnj u');\n     cmod (1 - v' * cnj v') = 1 - cmod (v' * cnj v'); du \\<noteq> 0;\n     dv \\<noteq> 0; kk \\<noteq> 0;\n     cmod (1 - u' * cnj u') = 1 - cmod (u' * cnj u');\n     cmod (1 - v' * cnj v') = 1 - cmod (v' * cnj v'); du \\<noteq> 0;\n     dv \\<noteq> 0; kk \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod\n                       ((u' - v') * cnj (u' - v') /\n                        ((1 - u' * cnj u') * (1 - v' * cnj v'))) =\n                      cmod ((u' - v') * cnj (u' - v')) /\n                      ((1 - cmod (u' * cnj u')) * (1 - cmod (v' * cnj v')))", "by simp"], ["proof (state)\nthis:\n  cmod (d * cnj d / (ddu * ddv)) =\n  (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cmod (d * cnj d / (ddu * ddv)) =\n  (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "finally"], ["proof (chain)\npicking this:\n  (cmod (nu / du - nv / dv))\\<^sup>2 /\n  ((1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2)) =\n  (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "have 3: \"?lhs / ?rhs = (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2)*(1 - (cmod v')\\<^sup>2))\""], ["proof (prove)\nusing this:\n  (cmod (nu / du - nv / dv))\\<^sup>2 /\n  ((1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2)) =\n  (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n\ngoal (1 subgoal):\n 1. (cmod (nu / du - nv / dv))\\<^sup>2 /\n    ((1 - (cmod nu / cmod du)\\<^sup>2) *\n     (1 - (cmod nv / cmod dv)\\<^sup>2)) =\n    (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "."], ["proof (state)\nthis:\n  (cmod (nu / du - nv / dv))\\<^sup>2 /\n  ((1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2)) =\n  (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"cmod k \\<noteq> 1\" \"u' \\<noteq> 1 / cnj k\" \"v' \\<noteq> 1 / cnj k\" \"u \\<noteq> \\<infinity>\\<^sub>h\" \"v \\<noteq> \\<infinity>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod k \\<noteq> 1 &&& u' \\<noteq> 1 / cnj k) &&&\n    v' \\<noteq> 1 / cnj k &&&\n    u \\<noteq> \\<infinity>\\<^sub>h &&& v \\<noteq> \\<infinity>\\<^sub>h", "using \\<open>cmod k < 1\\<close> \\<open>u \\<in> unit_disc\\<close> \\<open>v \\<in> unit_disc\\<close> * \\<open>k \\<noteq> 0\\<close> ** \\<open>kk \\<noteq> 0\\<close> nz"], ["proof (prove)\nusing this:\n  cmod k < 1\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u' = to_complex u\n  v' = to_complex v\n  k \\<noteq> 0\n  nu = u' - k\n  du = 1 - cnj k * u'\n  nv = v' - k\n  dv = 1 - cnj k * v'\n  d = u' - v'\n  ddu = 1 - u' * cnj u'\n  ddv = 1 - v' * cnj v'\n  kk = 1 - k * cnj k\n  kk \\<noteq> 0\n  du \\<noteq> 0\n  dv \\<noteq> 0\n  kk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (cmod k \\<noteq> 1 &&& u' \\<noteq> 1 / cnj k) &&&\n    v' \\<noteq> 1 / cnj k &&&\n    u \\<noteq> \\<infinity>\\<^sub>h &&& v \\<noteq> \\<infinity>\\<^sub>h", "by auto"], ["proof (state)\nthis:\n  cmod k \\<noteq> 1\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  u \\<noteq> \\<infinity>\\<^sub>h\n  v \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cmod k \\<noteq> 1\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  u \\<noteq> \\<infinity>\\<^sub>h\n  v \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "using assms"], ["proof (prove)\nusing this:\n  cmod k \\<noteq> 1\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  u \\<noteq> \\<infinity>\\<^sub>h\n  v \\<noteq> \\<infinity>\\<^sub>h\n  of_complex k \\<in> unit_disc\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "using * ** 3"], ["proof (prove)\nusing this:\n  cmod k \\<noteq> 1\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  u \\<noteq> \\<infinity>\\<^sub>h\n  v \\<noteq> \\<infinity>\\<^sub>h\n  of_complex k \\<in> unit_disc\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u' = to_complex u\n  v' = to_complex v\n  nu = u' - k\n  du = 1 - cnj k * u'\n  nv = v' - k\n  dv = 1 - cnj k * v'\n  d = u' - v'\n  ddu = 1 - u' * cnj u'\n  ddv = 1 - v' * cnj v'\n  kk = 1 - k * cnj k\n  (cmod (nu / du - nv / dv))\\<^sup>2 /\n  ((1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2)) =\n  (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "using moebius_pt_blaschke[of k u']"], ["proof (prove)\nusing this:\n  cmod k \\<noteq> 1\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  u \\<noteq> \\<infinity>\\<^sub>h\n  v \\<noteq> \\<infinity>\\<^sub>h\n  of_complex k \\<in> unit_disc\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u' = to_complex u\n  v' = to_complex v\n  nu = u' - k\n  du = 1 - cnj k * u'\n  nv = v' - k\n  dv = 1 - cnj k * v'\n  d = u' - v'\n  ddu = 1 - u' * cnj u'\n  ddv = 1 - v' * cnj v'\n  kk = 1 - k * cnj k\n  (cmod (nu / du - nv / dv))\\<^sup>2 /\n  ((1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2)) =\n  (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n  \\<lbrakk>cmod k \\<noteq> 1; u' \\<noteq> 1 / cnj k\\<rbrakk>\n  \\<Longrightarrow> moebius_pt (blaschke k) (of_complex u') =\n                    of_complex ((u' - k) / (1 - cnj k * u'))\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "using moebius_pt_blaschke[of k v']"], ["proof (prove)\nusing this:\n  cmod k \\<noteq> 1\n  u' \\<noteq> 1 / cnj k\n  v' \\<noteq> 1 / cnj k\n  u \\<noteq> \\<infinity>\\<^sub>h\n  v \\<noteq> \\<infinity>\\<^sub>h\n  of_complex k \\<in> unit_disc\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u' = to_complex u\n  v' = to_complex v\n  nu = u' - k\n  du = 1 - cnj k * u'\n  nv = v' - k\n  dv = 1 - cnj k * v'\n  d = u' - v'\n  ddu = 1 - u' * cnj u'\n  ddv = 1 - v' * cnj v'\n  kk = 1 - k * cnj k\n  (cmod (nu / du - nv / dv))\\<^sup>2 /\n  ((1 - (cmod nu / cmod du)\\<^sup>2) * (1 - (cmod nv / cmod dv)\\<^sup>2)) =\n  (cmod d)\\<^sup>2 / ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n  \\<lbrakk>cmod k \\<noteq> 1; u' \\<noteq> 1 / cnj k\\<rbrakk>\n  \\<Longrightarrow> moebius_pt (blaschke k) (of_complex u') =\n                    of_complex ((u' - k) / (1 - cnj k * u'))\n  \\<lbrakk>cmod k \\<noteq> 1; v' \\<noteq> 1 / cnj k\\<rbrakk>\n  \\<Longrightarrow> moebius_pt (blaschke k) (of_complex v') =\n                    of_complex ((v' - k) / (1 - cnj k * v'))\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n     (to_complex (moebius_pt (blaschke k) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "by simp"], ["proof (state)\nthis:\n  poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n   (to_complex (moebius_pt (blaschke k) v)) =\n  poincare_distance_formula (to_complex u) (to_complex v)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>To prove the equivalence between the h-distance definition and the distance formula, we shall\nemploy the without loss of generality principle. Therefore, we must show that the distance formula\nis preserved by h-isometries.\\<close>"], ["", "text\\<open>Rotation preserve @{term poincare_distance_formula}.\\<close>"], ["", "lemma rotation_preserve_distance_formula [simp]:\n  assumes \"u \\<in> unit_disc\" \"v \\<in> unit_disc\"\n  shows \"poincare_distance_formula (to_complex (moebius_pt (moebius_rotation \\<phi>) u)) (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n         poincare_distance_formula (to_complex u) (to_complex v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance_formula\n     (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n     (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance_formula\n     (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n     (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "using inf_or_of_complex[of u] inf_or_of_complex[of v]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. u = of_complex x)\n  v = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. v = of_complex x)\n\ngoal (1 subgoal):\n 1. poincare_distance_formula\n     (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n     (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "by auto"], ["", "text\\<open>Unit disc fixing M?bius preserve @{term poincare_distance_formula}.\\<close>"], ["", "lemma unit_disc_fix_preserve_distance_formula [simp]:\n  assumes \"unit_disc_fix M\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\"\n  shows \"poincare_distance_formula (to_complex (moebius_pt M u)) (to_complex (moebius_pt M v)) =\n         poincare_distance_formula (to_complex u) (to_complex v)\" (is \"?P' u v M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex (moebius_pt M u))\n     (to_complex (moebius_pt M v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex (moebius_pt M u))\n     (to_complex (moebius_pt M v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "have \"\\<forall> u \\<in> unit_disc. \\<forall> v \\<in> unit_disc. ?P' u v M\" (is \"?P M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>unit_disc.\n       \\<forall>v\\<in>unit_disc.\n          poincare_distance_formula (to_complex (moebius_pt M u))\n           (to_complex (moebius_pt M v)) =\n          poincare_distance_formula (to_complex u) (to_complex v)", "proof (rule wlog_unit_disc_fix[OF assms(1)])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       cmod k < 1 \\<Longrightarrow>\n       \\<forall>u\\<in>unit_disc.\n          \\<forall>v\\<in>unit_disc.\n             poincare_distance_formula\n              (to_complex (moebius_pt (blaschke k) u))\n              (to_complex (moebius_pt (blaschke k) v)) =\n             poincare_distance_formula (to_complex u) (to_complex v)\n 2. \\<And>\\<phi>.\n       \\<forall>u\\<in>unit_disc.\n          \\<forall>v\\<in>unit_disc.\n             poincare_distance_formula\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n             poincare_distance_formula (to_complex u) (to_complex v)\n 3. \\<And>M1 M2.\n       \\<lbrakk>unit_disc_fix M1;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M1 u))\n               (to_complex (moebius_pt M1 v)) =\n              poincare_distance_formula (to_complex u) (to_complex v);\n        unit_disc_fix M2;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M2 u))\n               (to_complex (moebius_pt M2 v)) =\n              poincare_distance_formula (to_complex u)\n               (to_complex v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u\\<in>unit_disc.\n                            \\<forall>v\\<in>unit_disc.\n                               poincare_distance_formula\n                                (to_complex (moebius_pt (M1 + M2) u))\n                                (to_complex (moebius_pt (M1 + M2) v)) =\n                               poincare_distance_formula (to_complex u)\n                                (to_complex v)", "fix k"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       cmod k < 1 \\<Longrightarrow>\n       \\<forall>u\\<in>unit_disc.\n          \\<forall>v\\<in>unit_disc.\n             poincare_distance_formula\n              (to_complex (moebius_pt (blaschke k) u))\n              (to_complex (moebius_pt (blaschke k) v)) =\n             poincare_distance_formula (to_complex u) (to_complex v)\n 2. \\<And>\\<phi>.\n       \\<forall>u\\<in>unit_disc.\n          \\<forall>v\\<in>unit_disc.\n             poincare_distance_formula\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n             poincare_distance_formula (to_complex u) (to_complex v)\n 3. \\<And>M1 M2.\n       \\<lbrakk>unit_disc_fix M1;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M1 u))\n               (to_complex (moebius_pt M1 v)) =\n              poincare_distance_formula (to_complex u) (to_complex v);\n        unit_disc_fix M2;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M2 u))\n               (to_complex (moebius_pt M2 v)) =\n              poincare_distance_formula (to_complex u)\n               (to_complex v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u\\<in>unit_disc.\n                            \\<forall>v\\<in>unit_disc.\n                               poincare_distance_formula\n                                (to_complex (moebius_pt (M1 + M2) u))\n                                (to_complex (moebius_pt (M1 + M2) v)) =\n                               poincare_distance_formula (to_complex u)\n                                (to_complex v)", "assume \"cmod k < 1\""], ["proof (state)\nthis:\n  cmod k < 1\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       cmod k < 1 \\<Longrightarrow>\n       \\<forall>u\\<in>unit_disc.\n          \\<forall>v\\<in>unit_disc.\n             poincare_distance_formula\n              (to_complex (moebius_pt (blaschke k) u))\n              (to_complex (moebius_pt (blaschke k) v)) =\n             poincare_distance_formula (to_complex u) (to_complex v)\n 2. \\<And>\\<phi>.\n       \\<forall>u\\<in>unit_disc.\n          \\<forall>v\\<in>unit_disc.\n             poincare_distance_formula\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n             poincare_distance_formula (to_complex u) (to_complex v)\n 3. \\<And>M1 M2.\n       \\<lbrakk>unit_disc_fix M1;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M1 u))\n               (to_complex (moebius_pt M1 v)) =\n              poincare_distance_formula (to_complex u) (to_complex v);\n        unit_disc_fix M2;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M2 u))\n               (to_complex (moebius_pt M2 v)) =\n              poincare_distance_formula (to_complex u)\n               (to_complex v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u\\<in>unit_disc.\n                            \\<forall>v\\<in>unit_disc.\n                               poincare_distance_formula\n                                (to_complex (moebius_pt (M1 + M2) u))\n                                (to_complex (moebius_pt (M1 + M2) v)) =\n                               poincare_distance_formula (to_complex u)\n                                (to_complex v)", "hence \"of_complex k \\<in> unit_disc\""], ["proof (prove)\nusing this:\n  cmod k < 1\n\ngoal (1 subgoal):\n 1. of_complex k \\<in> unit_disc", "by simp"], ["proof (state)\nthis:\n  of_complex k \\<in> unit_disc\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       cmod k < 1 \\<Longrightarrow>\n       \\<forall>u\\<in>unit_disc.\n          \\<forall>v\\<in>unit_disc.\n             poincare_distance_formula\n              (to_complex (moebius_pt (blaschke k) u))\n              (to_complex (moebius_pt (blaschke k) v)) =\n             poincare_distance_formula (to_complex u) (to_complex v)\n 2. \\<And>\\<phi>.\n       \\<forall>u\\<in>unit_disc.\n          \\<forall>v\\<in>unit_disc.\n             poincare_distance_formula\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n             poincare_distance_formula (to_complex u) (to_complex v)\n 3. \\<And>M1 M2.\n       \\<lbrakk>unit_disc_fix M1;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M1 u))\n               (to_complex (moebius_pt M1 v)) =\n              poincare_distance_formula (to_complex u) (to_complex v);\n        unit_disc_fix M2;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M2 u))\n               (to_complex (moebius_pt M2 v)) =\n              poincare_distance_formula (to_complex u)\n               (to_complex v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u\\<in>unit_disc.\n                            \\<forall>v\\<in>unit_disc.\n                               poincare_distance_formula\n                                (to_complex (moebius_pt (M1 + M2) u))\n                                (to_complex (moebius_pt (M1 + M2) v)) =\n                               poincare_distance_formula (to_complex u)\n                                (to_complex v)", "thus  \"?P (blaschke k)\""], ["proof (prove)\nusing this:\n  of_complex k \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>unit_disc.\n       \\<forall>v\\<in>unit_disc.\n          poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n           (to_complex (moebius_pt (blaschke k) v)) =\n          poincare_distance_formula (to_complex u) (to_complex v)", "using blaschke_preserve_distance_formula"], ["proof (prove)\nusing this:\n  of_complex k \\<in> unit_disc\n  \\<lbrakk>of_complex ?k \\<in> unit_disc; ?u \\<in> unit_disc;\n   ?v \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance_formula\n                     (to_complex (moebius_pt (blaschke ?k) ?u))\n                     (to_complex (moebius_pt (blaschke ?k) ?v)) =\n                    poincare_distance_formula (to_complex ?u)\n                     (to_complex ?v)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>unit_disc.\n       \\<forall>v\\<in>unit_disc.\n          poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n           (to_complex (moebius_pt (blaschke k) v)) =\n          poincare_distance_formula (to_complex u) (to_complex v)", "by simp"], ["proof (state)\nthis:\n  \\<forall>u\\<in>unit_disc.\n     \\<forall>v\\<in>unit_disc.\n        poincare_distance_formula (to_complex (moebius_pt (blaschke k) u))\n         (to_complex (moebius_pt (blaschke k) v)) =\n        poincare_distance_formula (to_complex u) (to_complex v)\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>u\\<in>unit_disc.\n          \\<forall>v\\<in>unit_disc.\n             poincare_distance_formula\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n             poincare_distance_formula (to_complex u) (to_complex v)\n 2. \\<And>M1 M2.\n       \\<lbrakk>unit_disc_fix M1;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M1 u))\n               (to_complex (moebius_pt M1 v)) =\n              poincare_distance_formula (to_complex u) (to_complex v);\n        unit_disc_fix M2;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M2 u))\n               (to_complex (moebius_pt M2 v)) =\n              poincare_distance_formula (to_complex u)\n               (to_complex v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u\\<in>unit_disc.\n                            \\<forall>v\\<in>unit_disc.\n                               poincare_distance_formula\n                                (to_complex (moebius_pt (M1 + M2) u))\n                                (to_complex (moebius_pt (M1 + M2) v)) =\n                               poincare_distance_formula (to_complex u)\n                                (to_complex v)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>u\\<in>unit_disc.\n          \\<forall>v\\<in>unit_disc.\n             poincare_distance_formula\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n             poincare_distance_formula (to_complex u) (to_complex v)\n 2. \\<And>M1 M2.\n       \\<lbrakk>unit_disc_fix M1;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M1 u))\n               (to_complex (moebius_pt M1 v)) =\n              poincare_distance_formula (to_complex u) (to_complex v);\n        unit_disc_fix M2;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M2 u))\n               (to_complex (moebius_pt M2 v)) =\n              poincare_distance_formula (to_complex u)\n               (to_complex v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u\\<in>unit_disc.\n                            \\<forall>v\\<in>unit_disc.\n                               poincare_distance_formula\n                                (to_complex (moebius_pt (M1 + M2) u))\n                                (to_complex (moebius_pt (M1 + M2) v)) =\n                               poincare_distance_formula (to_complex u)\n                                (to_complex v)", "fix \\<phi>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>u\\<in>unit_disc.\n          \\<forall>v\\<in>unit_disc.\n             poincare_distance_formula\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n              (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n             poincare_distance_formula (to_complex u) (to_complex v)\n 2. \\<And>M1 M2.\n       \\<lbrakk>unit_disc_fix M1;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M1 u))\n               (to_complex (moebius_pt M1 v)) =\n              poincare_distance_formula (to_complex u) (to_complex v);\n        unit_disc_fix M2;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M2 u))\n               (to_complex (moebius_pt M2 v)) =\n              poincare_distance_formula (to_complex u)\n               (to_complex v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u\\<in>unit_disc.\n                            \\<forall>v\\<in>unit_disc.\n                               poincare_distance_formula\n                                (to_complex (moebius_pt (M1 + M2) u))\n                                (to_complex (moebius_pt (M1 + M2) v)) =\n                               poincare_distance_formula (to_complex u)\n                                (to_complex v)", "show \"?P (moebius_rotation \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>unit_disc.\n       \\<forall>v\\<in>unit_disc.\n          poincare_distance_formula\n           (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n           (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n          poincare_distance_formula (to_complex u) (to_complex v)", "using rotation_preserve_distance_formula"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> unit_disc; ?v \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance_formula\n                     (to_complex (moebius_pt (moebius_rotation ?\\<phi>) ?u))\n                     (to_complex\n                       (moebius_pt (moebius_rotation ?\\<phi>) ?v)) =\n                    poincare_distance_formula (to_complex ?u)\n                     (to_complex ?v)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>unit_disc.\n       \\<forall>v\\<in>unit_disc.\n          poincare_distance_formula\n           (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n           (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n          poincare_distance_formula (to_complex u) (to_complex v)", "by simp"], ["proof (state)\nthis:\n  \\<forall>u\\<in>unit_disc.\n     \\<forall>v\\<in>unit_disc.\n        poincare_distance_formula\n         (to_complex (moebius_pt (moebius_rotation \\<phi>) u))\n         (to_complex (moebius_pt (moebius_rotation \\<phi>) v)) =\n        poincare_distance_formula (to_complex u) (to_complex v)\n\ngoal (1 subgoal):\n 1. \\<And>M1 M2.\n       \\<lbrakk>unit_disc_fix M1;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M1 u))\n               (to_complex (moebius_pt M1 v)) =\n              poincare_distance_formula (to_complex u) (to_complex v);\n        unit_disc_fix M2;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M2 u))\n               (to_complex (moebius_pt M2 v)) =\n              poincare_distance_formula (to_complex u)\n               (to_complex v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u\\<in>unit_disc.\n                            \\<forall>v\\<in>unit_disc.\n                               poincare_distance_formula\n                                (to_complex (moebius_pt (M1 + M2) u))\n                                (to_complex (moebius_pt (M1 + M2) v)) =\n                               poincare_distance_formula (to_complex u)\n                                (to_complex v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M1 M2.\n       \\<lbrakk>unit_disc_fix M1;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M1 u))\n               (to_complex (moebius_pt M1 v)) =\n              poincare_distance_formula (to_complex u) (to_complex v);\n        unit_disc_fix M2;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M2 u))\n               (to_complex (moebius_pt M2 v)) =\n              poincare_distance_formula (to_complex u)\n               (to_complex v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u\\<in>unit_disc.\n                            \\<forall>v\\<in>unit_disc.\n                               poincare_distance_formula\n                                (to_complex (moebius_pt (M1 + M2) u))\n                                (to_complex (moebius_pt (M1 + M2) v)) =\n                               poincare_distance_formula (to_complex u)\n                                (to_complex v)", "fix M1 M2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M1 M2.\n       \\<lbrakk>unit_disc_fix M1;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M1 u))\n               (to_complex (moebius_pt M1 v)) =\n              poincare_distance_formula (to_complex u) (to_complex v);\n        unit_disc_fix M2;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M2 u))\n               (to_complex (moebius_pt M2 v)) =\n              poincare_distance_formula (to_complex u)\n               (to_complex v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u\\<in>unit_disc.\n                            \\<forall>v\\<in>unit_disc.\n                               poincare_distance_formula\n                                (to_complex (moebius_pt (M1 + M2) u))\n                                (to_complex (moebius_pt (M1 + M2) v)) =\n                               poincare_distance_formula (to_complex u)\n                                (to_complex v)", "assume *: \"?P M1\" and **: \"?P M2\"  and u11: \"unit_disc_fix M1\" \"unit_disc_fix M2\""], ["proof (state)\nthis:\n  \\<forall>u\\<in>unit_disc.\n     \\<forall>v\\<in>unit_disc.\n        poincare_distance_formula (to_complex (moebius_pt M1 u))\n         (to_complex (moebius_pt M1 v)) =\n        poincare_distance_formula (to_complex u) (to_complex v)\n  \\<forall>u\\<in>unit_disc.\n     \\<forall>v\\<in>unit_disc.\n        poincare_distance_formula (to_complex (moebius_pt M2 u))\n         (to_complex (moebius_pt M2 v)) =\n        poincare_distance_formula (to_complex u) (to_complex v)\n  unit_disc_fix M1\n  unit_disc_fix M2\n\ngoal (1 subgoal):\n 1. \\<And>M1 M2.\n       \\<lbrakk>unit_disc_fix M1;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M1 u))\n               (to_complex (moebius_pt M1 v)) =\n              poincare_distance_formula (to_complex u) (to_complex v);\n        unit_disc_fix M2;\n        \\<forall>u\\<in>unit_disc.\n           \\<forall>v\\<in>unit_disc.\n              poincare_distance_formula (to_complex (moebius_pt M2 u))\n               (to_complex (moebius_pt M2 v)) =\n              poincare_distance_formula (to_complex u)\n               (to_complex v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u\\<in>unit_disc.\n                            \\<forall>v\\<in>unit_disc.\n                               poincare_distance_formula\n                                (to_complex (moebius_pt (M1 + M2) u))\n                                (to_complex (moebius_pt (M1 + M2) v)) =\n                               poincare_distance_formula (to_complex u)\n                                (to_complex v)", "thus \"?P (M1 + M2)\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>unit_disc.\n     \\<forall>v\\<in>unit_disc.\n        poincare_distance_formula (to_complex (moebius_pt M1 u))\n         (to_complex (moebius_pt M1 v)) =\n        poincare_distance_formula (to_complex u) (to_complex v)\n  \\<forall>u\\<in>unit_disc.\n     \\<forall>v\\<in>unit_disc.\n        poincare_distance_formula (to_complex (moebius_pt M2 u))\n         (to_complex (moebius_pt M2 v)) =\n        poincare_distance_formula (to_complex u) (to_complex v)\n  unit_disc_fix M1\n  unit_disc_fix M2\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>unit_disc.\n       \\<forall>v\\<in>unit_disc.\n          poincare_distance_formula (to_complex (moebius_pt (M1 + M2) u))\n           (to_complex (moebius_pt (M1 + M2) v)) =\n          poincare_distance_formula (to_complex u) (to_complex v)", "by (auto simp del: poincare_distance_formula_def)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>unit_disc.\n     \\<forall>v\\<in>unit_disc.\n        poincare_distance_formula (to_complex (moebius_pt (M1 + M2) u))\n         (to_complex (moebius_pt (M1 + M2) v)) =\n        poincare_distance_formula (to_complex u) (to_complex v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>u\\<in>unit_disc.\n     \\<forall>v\\<in>unit_disc.\n        poincare_distance_formula (to_complex (moebius_pt M u))\n         (to_complex (moebius_pt M v)) =\n        poincare_distance_formula (to_complex u) (to_complex v)\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex (moebius_pt M u))\n     (to_complex (moebius_pt M v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>unit_disc.\n     \\<forall>v\\<in>unit_disc.\n        poincare_distance_formula (to_complex (moebius_pt M u))\n         (to_complex (moebius_pt M v)) =\n        poincare_distance_formula (to_complex u) (to_complex v)\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex (moebius_pt M u))\n     (to_complex (moebius_pt M v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>unit_disc.\n     \\<forall>v\\<in>unit_disc.\n        poincare_distance_formula (to_complex (moebius_pt M u))\n         (to_complex (moebius_pt M v)) =\n        poincare_distance_formula (to_complex u) (to_complex v)\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex (moebius_pt M u))\n     (to_complex (moebius_pt M v)) =\n    poincare_distance_formula (to_complex u) (to_complex v)", "by simp"], ["proof (state)\nthis:\n  poincare_distance_formula (to_complex (moebius_pt M u))\n   (to_complex (moebius_pt M v)) =\n  poincare_distance_formula (to_complex u) (to_complex v)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The equivalence between the two h-distance representations.\\<close>"], ["", "lemma poincare_distance_formula:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance u v = poincare_distance_formula (to_complex u) (to_complex v)\" (is \"?P u v\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance u v =\n    poincare_distance_formula (to_complex u) (to_complex v)", "proof (rule wlog_x_axis)"], ["proof (state)\ngoal (4 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        poincare_distance (moebius_pt M u) (moebius_pt M v) =\n        poincare_distance_formula (to_complex (moebius_pt M u))\n         (to_complex (moebius_pt M v))\\<rbrakk>\n       \\<Longrightarrow> poincare_distance u v =\n                         poincare_distance_formula (to_complex u)\n                          (to_complex v)\n 4. \\<And>x.\n       \\<lbrakk>is_real x; 0 \\<le> Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                         poincare_distance_formula (to_complex 0\\<^sub>h)\n                          (to_complex (of_complex x))", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        poincare_distance (moebius_pt M u) (moebius_pt M v) =\n        poincare_distance_formula (to_complex (moebius_pt M u))\n         (to_complex (moebius_pt M v))\\<rbrakk>\n       \\<Longrightarrow> poincare_distance u v =\n                         poincare_distance_formula (to_complex u)\n                          (to_complex v)\n 4. \\<And>x.\n       \\<lbrakk>is_real x; 0 \\<le> Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                         poincare_distance_formula (to_complex 0\\<^sub>h)\n                          (to_complex (of_complex x))", "assume *: \"is_real x\" \"0 \\<le> Re x\" \"Re x < 1\""], ["proof (state)\nthis:\n  is_real x\n  0 \\<le> Re x\n  Re x < 1\n\ngoal (4 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        poincare_distance (moebius_pt M u) (moebius_pt M v) =\n        poincare_distance_formula (to_complex (moebius_pt M u))\n         (to_complex (moebius_pt M v))\\<rbrakk>\n       \\<Longrightarrow> poincare_distance u v =\n                         poincare_distance_formula (to_complex u)\n                          (to_complex v)\n 4. \\<And>x.\n       \\<lbrakk>is_real x; 0 \\<le> Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                         poincare_distance_formula (to_complex 0\\<^sub>h)\n                          (to_complex (of_complex x))", "show \"?P  0\\<^sub>h (of_complex x)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex x) =\n    poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex x) =\n    poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x))", "have \"of_complex x \\<in> unit_disc\" \"of_complex x \\<in> circline_set x_axis\" \"cmod x < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex x \\<in> unit_disc &&&\n    of_complex x \\<in> circline_set x_axis &&& cmod x < 1", "using * cmod_eq_Re"], ["proof (prove)\nusing this:\n  is_real x\n  0 \\<le> Re x\n  Re x < 1\n  is_real ?z \\<Longrightarrow> cmod ?z = \\<bar>Re ?z\\<bar>\n\ngoal (1 subgoal):\n 1. of_complex x \\<in> unit_disc &&&\n    of_complex x \\<in> circline_set x_axis &&& cmod x < 1", "by (auto simp add: circline_set_x_axis)"], ["proof (state)\nthis:\n  of_complex x \\<in> unit_disc\n  of_complex x \\<in> circline_set x_axis\n  cmod x < 1\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex x) =\n    poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x))", "hence \"?lhs = \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\""], ["proof (prove)\nusing this:\n  of_complex x \\<in> unit_disc\n  of_complex x \\<in> circline_set x_axis\n  cmod x < 1\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex x) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "using poincare_distance_zero_x_axis[of \"of_complex x\"]"], ["proof (prove)\nusing this:\n  of_complex x \\<in> unit_disc\n  of_complex x \\<in> circline_set x_axis\n  cmod x < 1\n  \\<lbrakk>of_complex x \\<in> unit_disc;\n   of_complex x \\<in> circline_set x_axis\\<rbrakk>\n  \\<Longrightarrow> poincare_distance 0\\<^sub>h (of_complex x) =\n                    (let x' = to_complex (of_complex x)\n                     in \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex x) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "by simp"], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h (of_complex x) =\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex x) =\n    poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x))", "moreover"], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h (of_complex x) =\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex x) =\n    poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x))", "have \"?rhs = \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "let ?x = \"1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "have \"0 \\<le> 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)", "by (smt \\<open>cmod x < 1\\<close> divide_nonneg_nonneg norm_ge_zero power_le_one zero_le_power2)"], ["proof (state)\nthis:\n  0 \\<le> 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "hence arcosh_real_gt: \"1 \\<le> ?x\""], ["proof (prove)\nusing this:\n  0 \\<le> 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 1 \\<le> 1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  1 \\<le> 1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "have \"?rhs = arcosh ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2))", "by simp"], ["proof (state)\nthis:\n  poincare_distance_formula (to_complex 0\\<^sub>h)\n   (to_complex (of_complex x)) =\n  arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "also"], ["proof (state)\nthis:\n  poincare_distance_formula (to_complex 0\\<^sub>h)\n   (to_complex (of_complex x)) =\n  arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "have \"... = ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) + 2 * (cmod x) / (1 - (cmod x)\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2))", "have \"1 - (cmod x)\\<^sup>2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 - (cmod x)\\<^sup>2", "using \\<open>cmod x < 1\\<close>"], ["proof (prove)\nusing this:\n  cmod x < 1\n\ngoal (1 subgoal):\n 1. 0 < 1 - (cmod x)\\<^sup>2", "by (smt norm_not_less_zero one_power2 power2_eq_imp_eq power_mono)"], ["proof (state)\nthis:\n  0 < 1 - (cmod x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2))", "hence 1: \"?x = (1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2)\""], ["proof (prove)\nusing this:\n  0 < 1 - (cmod x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. 1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2) =\n    (1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2) =\n  (1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2))", "have 2: \"?x\\<^sup>2 - 1 = (4 * (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2))\\<^sup>2 - 1 =\n    4 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\\<^sup>2", "using \\<open>1 - (cmod x)\\<^sup>2 > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < 1 - (cmod x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2))\\<^sup>2 - 1 =\n    4 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\\<^sup>2", "apply (subst 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 - (cmod x)\\<^sup>2 \\<Longrightarrow>\n    ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2))\\<^sup>2 - 1 =\n    4 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\\<^sup>2", "unfolding power_divide"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 - (cmod x)\\<^sup>2 \\<Longrightarrow>\n    (1 + (cmod x)\\<^sup>2)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\\<^sup>2 - 1 =\n    4 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\\<^sup>2", "by (subst divide_diff_eq_iff, simp, simp add: power2_eq_square field_simps)"], ["proof (state)\nthis:\n  (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2))\\<^sup>2 - 1 =\n  4 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2))", "using \\<open>1 - (cmod x)\\<^sup>2 > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < 1 - (cmod x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2))", "apply (subst arcosh_real_def[OF arcosh_real_gt])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 - (cmod x)\\<^sup>2 \\<Longrightarrow>\n    ln (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2) +\n        sqrt\n         ((1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2))\\<^sup>2 -\n          1)) =\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2))", "apply (subst 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 - (cmod x)\\<^sup>2 \\<Longrightarrow>\n    ln (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2) +\n        sqrt (4 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\\<^sup>2)) =\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2))", "apply (subst 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 - (cmod x)\\<^sup>2 \\<Longrightarrow>\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        sqrt (4 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)\\<^sup>2)) =\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2))", "apply (subst real_sqrt_divide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 - (cmod x)\\<^sup>2 \\<Longrightarrow>\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        sqrt (4 * (cmod x)\\<^sup>2) /\n        sqrt ((1 - (cmod x)\\<^sup>2)\\<^sup>2)) =\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2))", "apply (subst real_sqrt_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 - (cmod x)\\<^sup>2 \\<Longrightarrow>\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        sqrt 4 * sqrt ((cmod x)\\<^sup>2) /\n        sqrt ((1 - (cmod x)\\<^sup>2)\\<^sup>2)) =\n    ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n  ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n      2 * cmod x / (1 - (cmod x)\\<^sup>2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n  ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n      2 * cmod x / (1 - (cmod x)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "also"], ["proof (state)\nthis:\n  arcosh (1 + 2 * (cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n  ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n      2 * cmod x / (1 - (cmod x)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "have \"... = ln (((1 + (cmod x))\\<^sup>2) / (1 - (cmod x)\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n        2 * cmod x / (1 - (cmod x)\\<^sup>2)) =\n    ln ((1 + cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2))", "apply (subst add_divide_distrib[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ln ((1 + (cmod x)\\<^sup>2 + 2 * cmod x) / (1 - (cmod x)\\<^sup>2)) =\n    ln ((1 + cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2))", "apply (simp add: field_simps power2_eq_square)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n      2 * cmod x / (1 - (cmod x)\\<^sup>2)) =\n  ln ((1 + cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "also"], ["proof (state)\nthis:\n  ln ((1 + (cmod x)\\<^sup>2) / (1 - (cmod x)\\<^sup>2) +\n      2 * cmod x / (1 - (cmod x)\\<^sup>2)) =\n  ln ((1 + cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "have \"... = ln ((1 + cmod x) / (1 - (cmod x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln ((1 + cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n    ln ((1 + cmod x) / (1 - cmod x))", "using \\<open>cmod x < 1\\<close>"], ["proof (prove)\nusing this:\n  cmod x < 1\n\ngoal (1 subgoal):\n 1. ln ((1 + cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n    ln ((1 + cmod x) / (1 - cmod x))", "using square_diff_square_factored[of 1 \"cmod x\"]"], ["proof (prove)\nusing this:\n  cmod x < 1\n  1 * 1 - cmod x * cmod x = (1 + cmod x) * (1 - cmod x)\n\ngoal (1 subgoal):\n 1. ln ((1 + cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n    ln ((1 + cmod x) / (1 - cmod x))", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  ln ((1 + cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n  ln ((1 + cmod x) / (1 - cmod x))\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "also"], ["proof (state)\nthis:\n  ln ((1 + cmod x)\\<^sup>2 / (1 - (cmod x)\\<^sup>2)) =\n  ln ((1 + cmod x) / (1 - cmod x))\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "have \"... = \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "have *: \"Re ((1 - x) / (1 + x)) \\<le> 1\" \"Re ((1 - x) / (1 + x)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((1 - x) / (1 + x)) \\<le> 1 &&& 0 < Re ((1 - x) / (1 + x))", "using \\<open>is_real x\\<close> \\<open>Re x \\<ge> 0\\<close> \\<open>Re x < 1\\<close>"], ["proof (prove)\nusing this:\n  is_real x\n  0 \\<le> Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. Re ((1 - x) / (1 + x)) \\<le> 1 &&& 0 < Re ((1 - x) / (1 + x))", "using complex_is_Real_iff"], ["proof (prove)\nusing this:\n  is_real x\n  0 \\<le> Re x\n  Re x < 1\n  (?z \\<in> \\<real>) = is_real ?z\n\ngoal (1 subgoal):\n 1. Re ((1 - x) / (1 + x)) \\<le> 1 &&& 0 < Re ((1 - x) / (1 + x))", "by auto"], ["proof (state)\nthis:\n  Re ((1 - x) / (1 + x)) \\<le> 1\n  0 < Re ((1 - x) / (1 + x))\n\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "hence \"\\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = - ln (Re ((1 - x) / (1 + x)))\""], ["proof (prove)\nusing this:\n  Re ((1 - x) / (1 + x)) \\<le> 1\n  0 < Re ((1 - x) / (1 + x))\n\ngoal (1 subgoal):\n 1. \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = - ln (Re ((1 - x) / (1 + x)))", "by auto"], ["proof (state)\nthis:\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = - ln (Re ((1 - x) / (1 + x)))\n\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "hence \"\\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = ln (Re ((1 + x) / (1 - x)))\""], ["proof (prove)\nusing this:\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = - ln (Re ((1 - x) / (1 + x)))\n\ngoal (1 subgoal):\n 1. \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = ln (Re ((1 + x) / (1 - x)))", "using ln_div[of 1 \"Re ((1 - x)/(1 + x))\"] * \\<open>is_real x\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = - ln (Re ((1 - x) / (1 + x)))\n  \\<lbrakk>0 < 1; 0 < Re ((1 - x) / (1 + x))\\<rbrakk>\n  \\<Longrightarrow> ln (1 / Re ((1 - x) / (1 + x))) =\n                    ln 1 - ln (Re ((1 - x) / (1 + x)))\n  Re ((1 - x) / (1 + x)) \\<le> 1\n  0 < Re ((1 - x) / (1 + x))\n  is_real x\n\ngoal (1 subgoal):\n 1. \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = ln (Re ((1 + x) / (1 - x)))", "by (simp add: complex_is_Real_iff)"], ["proof (state)\nthis:\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = ln (Re ((1 + x) / (1 - x)))\n\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "moreover"], ["proof (state)\nthis:\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = ln (Re ((1 + x) / (1 - x)))\n\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "have \"ln ((1 + cmod x) / (1 - cmod x)) = ln ((1 + Re x) / (1 - Re x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) = ln ((1 + Re x) / (1 - Re x))", "using \\<open>Re x \\<ge> 0\\<close> \\<open>is_real x\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> Re x\n  is_real x\n\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) = ln ((1 + Re x) / (1 - Re x))", "using cmod_eq_Re"], ["proof (prove)\nusing this:\n  0 \\<le> Re x\n  is_real x\n  is_real ?z \\<Longrightarrow> cmod ?z = \\<bar>Re ?z\\<bar>\n\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) = ln ((1 + Re x) / (1 - Re x))", "by auto"], ["proof (state)\nthis:\n  ln ((1 + cmod x) / (1 - cmod x)) = ln ((1 + Re x) / (1 - Re x))\n\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "moreover"], ["proof (state)\nthis:\n  ln ((1 + cmod x) / (1 - cmod x)) = ln ((1 + Re x) / (1 - Re x))\n\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "have \"(1 + Re x) / (1 - Re x) = Re ((1 + x) / (1 - x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + Re x) / (1 - Re x) = Re ((1 + x) / (1 - x))", "using \\<open>is_real x\\<close> \\<open>Re x < 1\\<close>"], ["proof (prove)\nusing this:\n  is_real x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. (1 + Re x) / (1 - Re x) = Re ((1 + x) / (1 - x))", "by (smt Re_divide_real eq_iff_diff_eq_0 minus_complex.simps one_complex.simps plus_complex.simps)"], ["proof (state)\nthis:\n  (1 + Re x) / (1 - Re x) = Re ((1 + x) / (1 - x))\n\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = ln (Re ((1 + x) / (1 - x)))\n  ln ((1 + cmod x) / (1 - cmod x)) = ln ((1 + Re x) / (1 - Re x))\n  (1 + Re x) / (1 - Re x) = Re ((1 + x) / (1 - x))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = ln (Re ((1 + x) / (1 - x)))\n  ln ((1 + cmod x) / (1 - cmod x)) = ln ((1 + Re x) / (1 - Re x))\n  (1 + Re x) / (1 - Re x) = Re ((1 + x) / (1 - x))\n\ngoal (1 subgoal):\n 1. ln ((1 + cmod x) / (1 - cmod x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "by simp"], ["proof (state)\nthis:\n  ln ((1 + cmod x) / (1 - cmod x)) = \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ln ((1 + cmod x) / (1 - cmod x)) = \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "finally"], ["proof (chain)\npicking this:\n  poincare_distance_formula (to_complex 0\\<^sub>h)\n   (to_complex (of_complex x)) =\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  poincare_distance_formula (to_complex 0\\<^sub>h)\n   (to_complex (of_complex x)) =\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\n\ngoal (1 subgoal):\n 1. poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x)) =\n    \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "."], ["proof (state)\nthis:\n  poincare_distance_formula (to_complex 0\\<^sub>h)\n   (to_complex (of_complex x)) =\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poincare_distance_formula (to_complex 0\\<^sub>h)\n   (to_complex (of_complex x)) =\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex x) =\n    poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x))", "ultimately"], ["proof (chain)\npicking this:\n  poincare_distance 0\\<^sub>h (of_complex x) =\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\n  poincare_distance_formula (to_complex 0\\<^sub>h)\n   (to_complex (of_complex x)) =\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (of_complex x) =\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\n  poincare_distance_formula (to_complex 0\\<^sub>h)\n   (to_complex (of_complex x)) =\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar>\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (of_complex x) =\n    poincare_distance_formula (to_complex 0\\<^sub>h)\n     (to_complex (of_complex x))", "by simp"], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h (of_complex x) =\n  poincare_distance_formula (to_complex 0\\<^sub>h)\n   (to_complex (of_complex x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h (of_complex x) =\n  poincare_distance_formula (to_complex 0\\<^sub>h)\n   (to_complex (of_complex x))\n\ngoal (3 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        poincare_distance (moebius_pt M u) (moebius_pt M v) =\n        poincare_distance_formula (to_complex (moebius_pt M u))\n         (to_complex (moebius_pt M v))\\<rbrakk>\n       \\<Longrightarrow> poincare_distance u v =\n                         poincare_distance_formula (to_complex u)\n                          (to_complex v)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        poincare_distance (moebius_pt M u) (moebius_pt M v) =\n        poincare_distance_formula (to_complex (moebius_pt M u))\n         (to_complex (moebius_pt M v))\\<rbrakk>\n       \\<Longrightarrow> poincare_distance u v =\n                         poincare_distance_formula (to_complex u)\n                          (to_complex v)", "fix M u v"], ["proof (state)\ngoal (3 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        poincare_distance (moebius_pt M u) (moebius_pt M v) =\n        poincare_distance_formula (to_complex (moebius_pt M u))\n         (to_complex (moebius_pt M v))\\<rbrakk>\n       \\<Longrightarrow> poincare_distance u v =\n                         poincare_distance_formula (to_complex u)\n                          (to_complex v)", "assume *: \"unit_disc_fix M\"  \"u \\<in> unit_disc\" \"v \\<in> unit_disc\""], ["proof (state)\nthis:\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (3 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        poincare_distance (moebius_pt M u) (moebius_pt M v) =\n        poincare_distance_formula (to_complex (moebius_pt M u))\n         (to_complex (moebius_pt M v))\\<rbrakk>\n       \\<Longrightarrow> poincare_distance u v =\n                         poincare_distance_formula (to_complex u)\n                          (to_complex v)", "assume \"?P (moebius_pt M u) (moebius_pt M v)\""], ["proof (state)\nthis:\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  poincare_distance_formula (to_complex (moebius_pt M u))\n   (to_complex (moebius_pt M v))\n\ngoal (3 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        poincare_distance (moebius_pt M u) (moebius_pt M v) =\n        poincare_distance_formula (to_complex (moebius_pt M u))\n         (to_complex (moebius_pt M v))\\<rbrakk>\n       \\<Longrightarrow> poincare_distance u v =\n                         poincare_distance_formula (to_complex u)\n                          (to_complex v)", "thus \"?P u v\""], ["proof (prove)\nusing this:\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  poincare_distance_formula (to_complex (moebius_pt M u))\n   (to_complex (moebius_pt M v))\n\ngoal (1 subgoal):\n 1. poincare_distance u v =\n    poincare_distance_formula (to_complex u) (to_complex v)", "using *(1-3)"], ["proof (prove)\nusing this:\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  poincare_distance_formula (to_complex (moebius_pt M u))\n   (to_complex (moebius_pt M v))\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance u v =\n    poincare_distance_formula (to_complex u) (to_complex v)", "by (simp del: poincare_distance_formula_def)"], ["proof (state)\nthis:\n  poincare_distance u v =\n  poincare_distance_formula (to_complex u) (to_complex v)\n\ngoal (2 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc", "show \"u \\<in> unit_disc\" \"v \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> unit_disc &&& v \\<in> unit_disc", "by fact+"], ["proof (state)\nthis:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Some additional properties proved easily using the distance formula.\\<close>"], ["", "text \\<open>@{term poincare_distance} is symmetric.\\<close>"], ["", "lemma poincare_distance_sym:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance u v = poincare_distance v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance u v = poincare_distance v u", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance u v = poincare_distance v u", "using poincare_distance_formula[OF assms(1) assms(2)]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  poincare_distance u v =\n  poincare_distance_formula (to_complex u) (to_complex v)\n\ngoal (1 subgoal):\n 1. poincare_distance u v = poincare_distance v u", "using poincare_distance_formula[OF assms(2) assms(1)]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  poincare_distance u v =\n  poincare_distance_formula (to_complex u) (to_complex v)\n  poincare_distance v u =\n  poincare_distance_formula (to_complex v) (to_complex u)\n\ngoal (1 subgoal):\n 1. poincare_distance u v = poincare_distance v u", "by (simp add: mult.commute norm_minus_commute)"], ["", "lemma poincare_distance_formula'_ge_1:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"1 \\<le> poincare_distance_formula' (to_complex u) (to_complex v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> poincare_distance_formula' (to_complex u) (to_complex v)", "using unit_disc_cmod_square_lt_1[OF assms(1)] unit_disc_cmod_square_lt_1[OF assms(2)]"], ["proof (prove)\nusing this:\n  (cmod (to_complex u))\\<^sup>2 < 1\n  (cmod (to_complex v))\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> poincare_distance_formula' (to_complex u) (to_complex v)", "by auto"], ["", "text\\<open>@{term poincare_distance} is non-negative.\\<close>"], ["", "lemma poincare_distance_ge0:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance u v \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> poincare_distance u v", "using poincare_distance_formula'_ge_1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> unit_disc; ?v \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> poincare_distance_formula' (to_complex ?u)\n                             (to_complex ?v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> poincare_distance u v", "unfolding poincare_distance_formula[OF assms(1) assms(2)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> unit_disc; ?v \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> poincare_distance_formula' (to_complex ?u)\n                             (to_complex ?v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> poincare_distance_formula (to_complex u) (to_complex v)", "unfolding poincare_distance_formula_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> unit_disc; ?v \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> poincare_distance_formula' (to_complex ?u)\n                             (to_complex ?v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> arcosh\n             (poincare_distance_formula' (to_complex u) (to_complex v))", "unfolding poincare_distance_formula'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> unit_disc; ?v \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> 1 +\n                            2 *\n                            ((cmod\n                               (to_complex ?u - to_complex ?v))\\<^sup>2 /\n                             ((1 - (cmod (to_complex ?u))\\<^sup>2) *\n                              (1 - (cmod (to_complex ?v))\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. 0 \\<le> arcosh\n             (1 +\n              2 *\n              ((cmod (to_complex u - to_complex v))\\<^sup>2 /\n               ((1 - (cmod (to_complex u))\\<^sup>2) *\n                (1 - (cmod (to_complex v))\\<^sup>2))))", "by (rule arcosh_ge_0, simp_all add: assms)"], ["", "lemma cosh_dist:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"cosh_dist u v = poincare_distance_formula' (to_complex u) (to_complex v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cosh_dist u v = poincare_distance_formula' (to_complex u) (to_complex v)", "using poincare_distance_formula[OF assms] poincare_distance_formula'_ge_1[OF assms]"], ["proof (prove)\nusing this:\n  poincare_distance u v =\n  poincare_distance_formula (to_complex u) (to_complex v)\n  1 \\<le> poincare_distance_formula' (to_complex u) (to_complex v)\n\ngoal (1 subgoal):\n 1. cosh_dist u v = poincare_distance_formula' (to_complex u) (to_complex v)", "by simp"], ["", "text\\<open>@{term poincare_distance}  is zero only if the two points are equal.\\<close>"], ["", "lemma poincare_distance_eq_0_iff:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance u v = 0 \\<longleftrightarrow> u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poincare_distance u v = 0) = (u = v)", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. (poincare_distance u v = 0) = (u = v)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc;\n     poincare_distance u v = 0\\<rbrakk>\n    \\<Longrightarrow> u = v", "using poincare_distance_formula'_ge_1[OF assms]"], ["proof (prove)\nusing this:\n  1 \\<le> poincare_distance_formula' (to_complex u) (to_complex v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc;\n     poincare_distance u v = 0\\<rbrakk>\n    \\<Longrightarrow> u = v", "using unit_disc_cmod_square_lt_1[OF assms(1)] unit_disc_cmod_square_lt_1[OF assms(2)]"], ["proof (prove)\nusing this:\n  1 \\<le> poincare_distance_formula' (to_complex u) (to_complex v)\n  (cmod (to_complex u))\\<^sup>2 < 1\n  (cmod (to_complex v))\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc;\n     poincare_distance u v = 0\\<rbrakk>\n    \\<Longrightarrow> u = v", "unfolding poincare_distance_formula[OF assms(1) assms(2)]"], ["proof (prove)\nusing this:\n  1 \\<le> poincare_distance_formula' (to_complex u) (to_complex v)\n  (cmod (to_complex u))\\<^sup>2 < 1\n  (cmod (to_complex v))\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc;\n     poincare_distance_formula (to_complex u) (to_complex v) = 0\\<rbrakk>\n    \\<Longrightarrow> u = v", "unfolding poincare_distance_formula_def"], ["proof (prove)\nusing this:\n  1 \\<le> poincare_distance_formula' (to_complex u) (to_complex v)\n  (cmod (to_complex u))\\<^sup>2 < 1\n  (cmod (to_complex v))\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc;\n     arcosh (poincare_distance_formula' (to_complex u) (to_complex v)) =\n     0\\<rbrakk>\n    \\<Longrightarrow> u = v", "unfolding poincare_distance_formula'_def"], ["proof (prove)\nusing this:\n  1 \\<le> 1 +\n          2 *\n          ((cmod (to_complex u - to_complex v))\\<^sup>2 /\n           ((1 - (cmod (to_complex u))\\<^sup>2) *\n            (1 - (cmod (to_complex v))\\<^sup>2)))\n  (cmod (to_complex u))\\<^sup>2 < 1\n  (cmod (to_complex v))\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc;\n     arcosh\n      (1 +\n       2 *\n       ((cmod (to_complex u - to_complex v))\\<^sup>2 /\n        ((1 - (cmod (to_complex u))\\<^sup>2) *\n         (1 - (cmod (to_complex v))\\<^sup>2)))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> u = v", "apply (subst (asm) arcosh_eq_0_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> 1 +\n                     2 *\n                     ((cmod (to_complex u - to_complex v))\\<^sup>2 /\n                      ((1 - (cmod (to_complex u))\\<^sup>2) *\n                       (1 - (cmod (to_complex v))\\<^sup>2)));\n     (cmod (to_complex u))\\<^sup>2 < 1; (cmod (to_complex v))\\<^sup>2 < 1;\n     u \\<in> unit_disc; v \\<in> unit_disc\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> 1 +\n                              2 *\n                              ((cmod\n                                 (to_complex u - to_complex v))\\<^sup>2 /\n                               ((1 - (cmod (to_complex u))\\<^sup>2) *\n                                (1 - (cmod (to_complex v))\\<^sup>2)))\n 2. \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc;\n     1 +\n     2 *\n     ((cmod (to_complex u - to_complex v))\\<^sup>2 /\n      ((1 - (cmod (to_complex u))\\<^sup>2) *\n       (1 - (cmod (to_complex v))\\<^sup>2))) =\n     1;\n     1 \\<le> 1 +\n             2 *\n             ((cmod (to_complex u - to_complex v))\\<^sup>2 /\n              ((1 - (cmod (to_complex u))\\<^sup>2) *\n               (1 - (cmod (to_complex v))\\<^sup>2)));\n     (cmod (to_complex u))\\<^sup>2 < 1;\n     (cmod (to_complex v))\\<^sup>2 < 1\\<rbrakk>\n    \\<Longrightarrow> u = v", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> unit_disc; v \\<in> unit_disc;\n     1 +\n     2 *\n     ((cmod (to_complex u - to_complex v))\\<^sup>2 /\n      ((1 - (cmod (to_complex u))\\<^sup>2) *\n       (1 - (cmod (to_complex v))\\<^sup>2))) =\n     1;\n     1 \\<le> 1 +\n             2 *\n             ((cmod (to_complex u - to_complex v))\\<^sup>2 /\n              ((1 - (cmod (to_complex u))\\<^sup>2) *\n               (1 - (cmod (to_complex v))\\<^sup>2)));\n     (cmod (to_complex u))\\<^sup>2 < 1;\n     (cmod (to_complex v))\\<^sup>2 < 1\\<rbrakk>\n    \\<Longrightarrow> u = v", "apply (simp add: unit_disc_to_complex_inj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Conjugate preserve @{term poincare_distance_formula}.\\<close>"], ["", "lemma conjugate_preserve_poincare_distance [simp]:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance (conjugate u) (conjugate v) = poincare_distance u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance (conjugate u) (conjugate v) = poincare_distance u v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_distance (conjugate u) (conjugate v) = poincare_distance u v", "obtain u' v' where *: \"u = of_complex u'\" \"v = of_complex v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        \\<lbrakk>u = of_complex u'; v = of_complex v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms inf_or_of_complex[of u] inf_or_of_complex[of v]"], ["proof (prove)\nusing this:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. u = of_complex x)\n  v = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. v = of_complex x)\n\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        \\<lbrakk>u = of_complex u'; v = of_complex v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u = of_complex u'\n  v = of_complex v'\n\ngoal (1 subgoal):\n 1. poincare_distance (conjugate u) (conjugate v) = poincare_distance u v", "have **: \"conjugate u \\<in> unit_disc\" \"conjugate v \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate u \\<in> unit_disc &&& conjugate v \\<in> unit_disc", "using * assms"], ["proof (prove)\nusing this:\n  u = of_complex u'\n  v = of_complex v'\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. conjugate u \\<in> unit_disc &&& conjugate v \\<in> unit_disc", "by auto"], ["proof (state)\nthis:\n  conjugate u \\<in> unit_disc\n  conjugate v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance (conjugate u) (conjugate v) = poincare_distance u v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance (conjugate u) (conjugate v) = poincare_distance u v", "using *"], ["proof (prove)\nusing this:\n  u = of_complex u'\n  v = of_complex v'\n\ngoal (1 subgoal):\n 1. poincare_distance (conjugate u) (conjugate v) = poincare_distance u v", "using poincare_distance_formula[OF assms]"], ["proof (prove)\nusing this:\n  u = of_complex u'\n  v = of_complex v'\n  poincare_distance u v =\n  poincare_distance_formula (to_complex u) (to_complex v)\n\ngoal (1 subgoal):\n 1. poincare_distance (conjugate u) (conjugate v) = poincare_distance u v", "using poincare_distance_formula[OF **]"], ["proof (prove)\nusing this:\n  u = of_complex u'\n  v = of_complex v'\n  poincare_distance u v =\n  poincare_distance_formula (to_complex u) (to_complex v)\n  poincare_distance (conjugate u) (conjugate v) =\n  poincare_distance_formula (to_complex (conjugate u))\n   (to_complex (conjugate v))\n\ngoal (1 subgoal):\n 1. poincare_distance (conjugate u) (conjugate v) = poincare_distance u v", "by (metis complex_cnj_diff complex_mod_cnj conjugate_of_complex poincare_distance_def poincare_distance_formula'_def poincare_distance_formula_def to_complex_of_complex)"], ["proof (state)\nthis:\n  poincare_distance (conjugate u) (conjugate v) = poincare_distance u v\n\ngoal:\nNo subgoals!", "qed"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsection\\<open>Existence and uniqueness of points with a given distance\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "lemma ex_x_axis_poincare_distance_negative':\n  fixes d :: real\n  assumes \"d \\<ge> 0\"\n  shows \"let z = (1 - exp d) / (1 + exp d)\n          in is_real z \\<and> Re z \\<le> 0 \\<and> Re z > -1 \\<and>\n              of_complex z \\<in> unit_disc \\<and> of_complex z \\<in> circline_set x_axis \\<and>\n              poincare_distance 0\\<^sub>h (of_complex z) = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "have \"exp d \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> exp d", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> d\n\ngoal (1 subgoal):\n 1. 1 \\<le> exp d", "using one_le_exp_iff[of d, symmetric]"], ["proof (prove)\nusing this:\n  0 \\<le> d\n  (0 \\<le> d) = (1 \\<le> exp d)\n\ngoal (1 subgoal):\n 1. 1 \\<le> exp d", "by blast"], ["proof (state)\nthis:\n  1 \\<le> exp d\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "hence \"1 + exp d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  1 \\<le> exp d\n\ngoal (1 subgoal):\n 1. 1 + exp d \\<noteq> 0", "by linarith"], ["proof (state)\nthis:\n  1 + exp d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "let ?z = \"(1 - exp d) / (1 + exp d)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "have \"?z \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - exp d) / (1 + exp d) \\<le> 0", "using \\<open>exp d \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> exp d\n\ngoal (1 subgoal):\n 1. (1 - exp d) / (1 + exp d) \\<le> 0", "by (simp add: divide_nonpos_nonneg)"], ["proof (state)\nthis:\n  (1 - exp d) / (1 + exp d) \\<le> 0\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "moreover"], ["proof (state)\nthis:\n  (1 - exp d) / (1 + exp d) \\<le> 0\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "have \"?z > -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 < (1 - exp d) / (1 + exp d)", "using exp_gt_zero[of d]"], ["proof (prove)\nusing this:\n  0 < exp d\n\ngoal (1 subgoal):\n 1. - 1 < (1 - exp d) / (1 + exp d)", "by (smt divide_less_eq_1_neg nonzero_minus_divide_right)"], ["proof (state)\nthis:\n  - 1 < (1 - exp d) / (1 + exp d)\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "moreover"], ["proof (state)\nthis:\n  - 1 < (1 - exp d) / (1 + exp d)\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "hence \"abs ?z < 1\""], ["proof (prove)\nusing this:\n  - 1 < (1 - exp d) / (1 + exp d)\n\ngoal (1 subgoal):\n 1. \\<bar>(1 - exp d) / (1 + exp d)\\<bar> < 1", "using \\<open>?z \\<le> 0\\<close>"], ["proof (prove)\nusing this:\n  - 1 < (1 - exp d) / (1 + exp d)\n  (1 - exp d) / (1 + exp d) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<bar>(1 - exp d) / (1 + exp d)\\<bar> < 1", "by simp"], ["proof (state)\nthis:\n  \\<bar>(1 - exp d) / (1 + exp d)\\<bar> < 1\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "hence \"cmod ?z < 1\""], ["proof (prove)\nusing this:\n  \\<bar>(1 - exp d) / (1 + exp d)\\<bar> < 1\n\ngoal (1 subgoal):\n 1. cmod (cor ((1 - exp d) / (1 + exp d))) < 1", "by (metis norm_of_real)"], ["proof (state)\nthis:\n  cmod (cor ((1 - exp d) / (1 + exp d))) < 1\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "hence \"of_complex ?z \\<in> unit_disc\""], ["proof (prove)\nusing this:\n  cmod (cor ((1 - exp d) / (1 + exp d))) < 1\n\ngoal (1 subgoal):\n 1. of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> unit_disc", "by simp"], ["proof (state)\nthis:\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "moreover"], ["proof (state)\nthis:\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "have \"of_complex ?z \\<in> circline_set x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> circline_set x_axis", "unfolding circline_set_x_axis"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (cor ((1 - exp d) / (1 + exp d)))\n    \\<in> of_complex ` {x. is_real x} \\<union> {\\<infinity>\\<^sub>h}", "by simp"], ["proof (state)\nthis:\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "moreover"], ["proof (state)\nthis:\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "have \"(1 - ?z) / (1 + ?z) = exp d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) =\n    exp d", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) =\n    exp d", "have \"1 + ?z = 2 / (1 + exp d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + (1 - exp d) / (1 + exp d) = 2 / (1 + exp d)", "using \\<open>1 + exp d \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  1 + exp d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 + (1 - exp d) / (1 + exp d) = 2 / (1 + exp d)", "by (subst add_divide_eq_iff, auto)"], ["proof (state)\nthis:\n  1 + (1 - exp d) / (1 + exp d) = 2 / (1 + exp d)\n\ngoal (1 subgoal):\n 1. (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) =\n    exp d", "moreover"], ["proof (state)\nthis:\n  1 + (1 - exp d) / (1 + exp d) = 2 / (1 + exp d)\n\ngoal (1 subgoal):\n 1. (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) =\n    exp d", "have \"1 - ?z = 2 * exp d / (1 + exp d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - (1 - exp d) / (1 + exp d) = 2 * exp d / (1 + exp d)", "using \\<open>1 + exp d \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  1 + exp d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 - (1 - exp d) / (1 + exp d) = 2 * exp d / (1 + exp d)", "by (subst diff_divide_eq_iff, auto)"], ["proof (state)\nthis:\n  1 - (1 - exp d) / (1 + exp d) = 2 * exp d / (1 + exp d)\n\ngoal (1 subgoal):\n 1. (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) =\n    exp d", "ultimately"], ["proof (chain)\npicking this:\n  1 + (1 - exp d) / (1 + exp d) = 2 / (1 + exp d)\n  1 - (1 - exp d) / (1 + exp d) = 2 * exp d / (1 + exp d)", "show ?thesis"], ["proof (prove)\nusing this:\n  1 + (1 - exp d) / (1 + exp d) = 2 / (1 + exp d)\n  1 - (1 - exp d) / (1 + exp d) = 2 * exp d / (1 + exp d)\n\ngoal (1 subgoal):\n 1. (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) =\n    exp d", "using \\<open>1 + exp d \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  1 + (1 - exp d) / (1 + exp d) = 2 / (1 + exp d)\n  1 - (1 - exp d) / (1 + exp d) = 2 * exp d / (1 + exp d)\n  1 + exp d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) =\n    exp d", "by simp"], ["proof (state)\nthis:\n  (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) = exp d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) = exp d\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "ultimately"], ["proof (chain)\npicking this:\n  (1 - exp d) / (1 + exp d) \\<le> 0\n  - 1 < (1 - exp d) / (1 + exp d)\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> unit_disc\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> circline_set x_axis\n  (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) = exp d", "show ?thesis"], ["proof (prove)\nusing this:\n  (1 - exp d) / (1 + exp d) \\<le> 0\n  - 1 < (1 - exp d) / (1 + exp d)\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> unit_disc\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> circline_set x_axis\n  (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) = exp d\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "using poincare_distance_zero_x_axis[of \"of_complex ?z\"]"], ["proof (prove)\nusing this:\n  (1 - exp d) / (1 + exp d) \\<le> 0\n  - 1 < (1 - exp d) / (1 + exp d)\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> unit_disc\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> circline_set x_axis\n  (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) = exp d\n  \\<lbrakk>of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> unit_disc;\n   of_complex (cor ((1 - exp d) / (1 + exp d)))\n   \\<in> circline_set x_axis\\<rbrakk>\n  \\<Longrightarrow> poincare_distance 0\\<^sub>h\n                     (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n                    (let x' = to_complex\n                               (of_complex\n                                 (cor ((1 - exp d) / (1 + exp d))))\n                     in \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "using \\<open>d \\<ge> 0\\<close> \\<open>exp d \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  (1 - exp d) / (1 + exp d) \\<le> 0\n  - 1 < (1 - exp d) / (1 + exp d)\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> unit_disc\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> circline_set x_axis\n  (1 - (1 - exp d) / (1 + exp d)) / (1 + (1 - exp d) / (1 + exp d)) = exp d\n  \\<lbrakk>of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> unit_disc;\n   of_complex (cor ((1 - exp d) / (1 + exp d)))\n   \\<in> circline_set x_axis\\<rbrakk>\n  \\<Longrightarrow> poincare_distance 0\\<^sub>h\n                     (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n                    (let x' = to_complex\n                               (of_complex\n                                 (cor ((1 - exp d) / (1 + exp d))))\n                     in \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n  0 \\<le> d\n  1 \\<le> exp d\n\ngoal (1 subgoal):\n 1. let x = (1 - exp d) / (1 + exp d)\n    in is_real (cor x) \\<and>\n       Re (cor x) \\<le> 0 \\<and>\n       - 1 < Re (cor x) \\<and>\n       of_complex (cor x) \\<in> unit_disc \\<and>\n       of_complex (cor x) \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex (cor x)) = d", "by simp (simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  let x = (1 - exp d) / (1 + exp d)\n  in is_real (cor x) \\<and>\n     Re (cor x) \\<le> 0 \\<and>\n     - 1 < Re (cor x) \\<and>\n     of_complex (cor x) \\<in> unit_disc \\<and>\n     of_complex (cor x) \\<in> circline_set x_axis \\<and>\n     poincare_distance 0\\<^sub>h (of_complex (cor x)) = d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_x_axis_poincare_distance_negative:\n  assumes \"d \\<ge> 0\"\n  shows \"\\<exists> z. is_real z \\<and> Re z \\<le> 0 \\<and> Re z > -1 \\<and>\n              of_complex z \\<in> unit_disc \\<and> of_complex z \\<in> circline_set x_axis \\<and>\n              poincare_distance 0\\<^sub>h (of_complex z) = d\" (is \"\\<exists> z. ?P z\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_real z \\<and>\n       Re z \\<le> 0 \\<and>\n       - 1 < Re z \\<and>\n       of_complex z \\<in> unit_disc \\<and>\n       of_complex z \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z) = d", "using ex_x_axis_poincare_distance_negative'[OF assms]"], ["proof (prove)\nusing this:\n  let x = (1 - exp d) / (1 + exp d)\n  in is_real (cor x) \\<and>\n     Re (cor x) \\<le> 0 \\<and>\n     - 1 < Re (cor x) \\<and>\n     of_complex (cor x) \\<in> unit_disc \\<and>\n     of_complex (cor x) \\<in> circline_set x_axis \\<and>\n     poincare_distance 0\\<^sub>h (of_complex (cor x)) = d\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_real z \\<and>\n       Re z \\<le> 0 \\<and>\n       - 1 < Re z \\<and>\n       of_complex z \\<in> unit_disc \\<and>\n       of_complex z \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z) = d", "unfolding Let_def"], ["proof (prove)\nusing this:\n  is_real (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  Re (cor ((1 - exp d) / (1 + exp d))) \\<le> 0 \\<and>\n  - 1 < Re (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> unit_disc \\<and>\n  of_complex (cor ((1 - exp d) / (1 + exp d)))\n  \\<in> circline_set x_axis \\<and>\n  poincare_distance 0\\<^sub>h\n   (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n  d\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_real z \\<and>\n       Re z \\<le> 0 \\<and>\n       - 1 < Re z \\<and>\n       of_complex z \\<in> unit_disc \\<and>\n       of_complex z \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z) = d", "by blast"], ["", "text\\<open>For each real number $d$ there is exactly one point on the positive x-axis such that h-distance\nbetween 0 and that point is $d$.\\<close>"], ["", "lemma unique_x_axis_poincare_distance_negative:\n  assumes \"d \\<ge> 0\"\n  shows \"\\<exists>! z. is_real z \\<and> Re z \\<le> 0 \\<and> Re z > -1 \\<and>\n              poincare_distance 0\\<^sub>h (of_complex z) = d\" (is \"\\<exists>! z. ?P z\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_real z \\<and>\n       Re z \\<le> 0 \\<and>\n       - 1 < Re z \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_real z \\<and>\n       Re z \\<le> 0 \\<and>\n       - 1 < Re z \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d", "let ?z = \"(1 - exp d) / (1 + exp d)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_real z \\<and>\n       Re z \\<le> 0 \\<and>\n       - 1 < Re z \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d", "have \"?P ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (cor ((1 - exp d) / (1 + exp d))) \\<and>\n    Re (cor ((1 - exp d) / (1 + exp d))) \\<le> 0 \\<and>\n    - 1 < Re (cor ((1 - exp d) / (1 + exp d))) \\<and>\n    poincare_distance 0\\<^sub>h\n     (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n    d", "using ex_x_axis_poincare_distance_negative'[OF assms]"], ["proof (prove)\nusing this:\n  let x = (1 - exp d) / (1 + exp d)\n  in is_real (cor x) \\<and>\n     Re (cor x) \\<le> 0 \\<and>\n     - 1 < Re (cor x) \\<and>\n     of_complex (cor x) \\<in> unit_disc \\<and>\n     of_complex (cor x) \\<in> circline_set x_axis \\<and>\n     poincare_distance 0\\<^sub>h (of_complex (cor x)) = d\n\ngoal (1 subgoal):\n 1. is_real (cor ((1 - exp d) / (1 + exp d))) \\<and>\n    Re (cor ((1 - exp d) / (1 + exp d))) \\<le> 0 \\<and>\n    - 1 < Re (cor ((1 - exp d) / (1 + exp d))) \\<and>\n    poincare_distance 0\\<^sub>h\n     (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n    d", "unfolding Let_def"], ["proof (prove)\nusing this:\n  is_real (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  Re (cor ((1 - exp d) / (1 + exp d))) \\<le> 0 \\<and>\n  - 1 < Re (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  of_complex (cor ((1 - exp d) / (1 + exp d))) \\<in> unit_disc \\<and>\n  of_complex (cor ((1 - exp d) / (1 + exp d)))\n  \\<in> circline_set x_axis \\<and>\n  poincare_distance 0\\<^sub>h\n   (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n  d\n\ngoal (1 subgoal):\n 1. is_real (cor ((1 - exp d) / (1 + exp d))) \\<and>\n    Re (cor ((1 - exp d) / (1 + exp d))) \\<le> 0 \\<and>\n    - 1 < Re (cor ((1 - exp d) / (1 + exp d))) \\<and>\n    poincare_distance 0\\<^sub>h\n     (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n    d", "by blast"], ["proof (state)\nthis:\n  is_real (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  Re (cor ((1 - exp d) / (1 + exp d))) \\<le> 0 \\<and>\n  - 1 < Re (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  poincare_distance 0\\<^sub>h\n   (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n  d\n\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_real z \\<and>\n       Re z \\<le> 0 \\<and>\n       - 1 < Re z \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d", "moreover"], ["proof (state)\nthis:\n  is_real (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  Re (cor ((1 - exp d) / (1 + exp d))) \\<le> 0 \\<and>\n  - 1 < Re (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  poincare_distance 0\\<^sub>h\n   (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n  d\n\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_real z \\<and>\n       Re z \\<le> 0 \\<and>\n       - 1 < Re z \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d", "have \"\\<forall> z'. ?P z' \\<longrightarrow> z' = ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z'.\n       is_real z' \\<and>\n       Re z' \\<le> 0 \\<and>\n       - 1 < Re z' \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z') = d \\<longrightarrow>\n       z' = cor ((1 - exp d) / (1 + exp d))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>z'.\n       is_real z' \\<and>\n       Re z' \\<le> 0 \\<and>\n       - 1 < Re z' \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z') = d \\<longrightarrow>\n       z' = cor ((1 - exp d) / (1 + exp d))", "let ?g = \"\\<lambda> x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>z'.\n       is_real z' \\<and>\n       Re z' \\<le> 0 \\<and>\n       - 1 < Re z' \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z') = d \\<longrightarrow>\n       z' = cor ((1 - exp d) / (1 + exp d))", "let ?A = \"{x. is_real x \\<and> Re x > -1 \\<and> Re x \\<le> 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>z'.\n       is_real z' \\<and>\n       Re z' \\<le> 0 \\<and>\n       - 1 < Re z' \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z') = d \\<longrightarrow>\n       z' = cor ((1 - exp d) / (1 + exp d))", "have \"inj_on (poincare_distance 0\\<^sub>h \\<circ> of_complex) ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (poincare_distance 0\\<^sub>h \\<circ> of_complex)\n     {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}", "proof (rule comp_inj_on)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on of_complex {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n 2. inj_on (poincare_distance 0\\<^sub>h)\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "show \"inj_on of_complex ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on of_complex {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}", "using of_complex_inj"], ["proof (prove)\nusing this:\n  of_complex ?x = of_complex ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. inj_on of_complex {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  of_complex ?x = of_complex ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}.\n       \\<forall>y\\<in>{x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}.\n          of_complex x = of_complex y \\<longrightarrow> x = y", "by blast"], ["proof (state)\nthis:\n  inj_on of_complex {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n\ngoal (1 subgoal):\n 1. inj_on (poincare_distance 0\\<^sub>h)\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (poincare_distance 0\\<^sub>h)\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "show \"inj_on (poincare_distance 0\\<^sub>h) (of_complex ` ?A)\" (is \"inj_on ?f (of_complex ` ?A)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (poincare_distance 0\\<^sub>h)\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "proof (subst inj_on_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> of_complex `\n               {x. is_real x \\<and>\n                   - 1 < Re x \\<and> Re x \\<le> 0} \\<Longrightarrow>\n       poincare_distance 0\\<^sub>h a = ?g a\n 2. inj_on ?g\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "have *: \"of_complex ` ?A =\n                 {z. z \\<in> unit_disc \\<and> z \\<in> circline_set x_axis \\<and> Re (to_complex z) \\<le> 0}\" (is \"_ = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0} =\n    {z \\<in> unit_disc.\n     z \\<in> circline_set x_axis \\<and> Re (to_complex z) \\<le> 0}", "by (auto simp add: cmod_eq_Re circline_set_x_axis)"], ["proof (state)\nthis:\n  of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0} =\n  {z \\<in> unit_disc.\n   z \\<in> circline_set x_axis \\<and> Re (to_complex z) \\<le> 0}\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> of_complex `\n               {x. is_real x \\<and>\n                   - 1 < Re x \\<and> Re x \\<le> 0} \\<Longrightarrow>\n       poincare_distance 0\\<^sub>h a = ?g a\n 2. inj_on ?g\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> of_complex `\n               {x. is_real x \\<and>\n                   - 1 < Re x \\<and> Re x \\<le> 0} \\<Longrightarrow>\n       poincare_distance 0\\<^sub>h a = ?g a\n 2. inj_on ?g\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "assume \"x \\<in> of_complex ` ?A\""], ["proof (state)\nthis:\n  x \\<in> of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> of_complex `\n               {x. is_real x \\<and>\n                   - 1 < Re x \\<and> Re x \\<le> 0} \\<Longrightarrow>\n       poincare_distance 0\\<^sub>h a = ?g a\n 2. inj_on ?g\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "hence \"x \\<in> ?B\""], ["proof (prove)\nusing this:\n  x \\<in> of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n\ngoal (1 subgoal):\n 1. x \\<in> {z \\<in> unit_disc.\n             z \\<in> circline_set x_axis \\<and> Re (to_complex z) \\<le> 0}", "using *"], ["proof (prove)\nusing this:\n  x \\<in> of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n  of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0} =\n  {z \\<in> unit_disc.\n   z \\<in> circline_set x_axis \\<and> Re (to_complex z) \\<le> 0}\n\ngoal (1 subgoal):\n 1. x \\<in> {z \\<in> unit_disc.\n             z \\<in> circline_set x_axis \\<and> Re (to_complex z) \\<le> 0}", "by simp"], ["proof (state)\nthis:\n  x \\<in> {z \\<in> unit_disc.\n           z \\<in> circline_set x_axis \\<and> Re (to_complex z) \\<le> 0}\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> of_complex `\n               {x. is_real x \\<and>\n                   - 1 < Re x \\<and> Re x \\<le> 0} \\<Longrightarrow>\n       poincare_distance 0\\<^sub>h a = ?g a\n 2. inj_on ?g\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "thus \"poincare_distance 0\\<^sub>h x = (?g \\<circ> to_complex) x\""], ["proof (prove)\nusing this:\n  x \\<in> {z \\<in> unit_disc.\n           z \\<in> circline_set x_axis \\<and> Re (to_complex z) \\<le> 0}\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h x =\n    ((\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>) \\<circ>\n     to_complex)\n     x", "using poincare_distance_zero_x_axis"], ["proof (prove)\nusing this:\n  x \\<in> {z \\<in> unit_disc.\n           z \\<in> circline_set x_axis \\<and> Re (to_complex z) \\<le> 0}\n  \\<lbrakk>?x \\<in> unit_disc; ?x \\<in> circline_set x_axis\\<rbrakk>\n  \\<Longrightarrow> poincare_distance 0\\<^sub>h ?x =\n                    (let x' = to_complex ?x\n                     in \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h x =\n    ((\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>) \\<circ>\n     to_complex)\n     x", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h x =\n  ((\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>) \\<circ>\n   to_complex)\n   x\n\ngoal (1 subgoal):\n 1. inj_on\n     ((\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>) \\<circ>\n      to_complex)\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on\n     ((\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>) \\<circ>\n      to_complex)\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "have *: \"to_complex ` of_complex ` ?A = ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_complex `\n    of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0} =\n    {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}", "by (auto simp add: image_iff)"], ["proof (state)\nthis:\n  to_complex `\n  of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0} =\n  {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n\ngoal (1 subgoal):\n 1. inj_on\n     ((\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>) \\<circ>\n      to_complex)\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "show \"inj_on (?g \\<circ> to_complex) (of_complex ` ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     ((\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>) \\<circ>\n      to_complex)\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "proof (rule comp_inj_on)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on to_complex\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})\n 2. inj_on (\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n     (to_complex `\n      of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "show \"inj_on to_complex (of_complex ` ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on to_complex\n     (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>of_complex `\n                   {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}.\n       \\<forall>y\\<in>of_complex `\n                      {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}.\n          to_complex x = to_complex y \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj_on to_complex\n   (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n     (to_complex `\n      of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n     (to_complex `\n      of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "have \"inj_on ?g ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n     {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}.\n       \\<forall>y\\<in>{x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}.\n          \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n          \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar> \\<longrightarrow>\n          x = y", "proof(safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume hh: \"is_real x\" \"is_real y\" \"- 1 < Re x\" \"Re x \\<le> 0\"\n              \"- 1 < Re y\" \"Re y \\<le> 0\" \"\\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> = \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\""], ["proof (state)\nthis:\n  is_real x\n  is_real y\n  - 1 < Re x\n  Re x \\<le> 0\n  - 1 < Re y\n  Re y \\<le> 0\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n  \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"is_real ((1 - x)/(1 + x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real ((1 - x) / (1 + x))", "using \\<open>is_real x\\<close> div_reals[of \"1-x\" \"1+x\"]"], ["proof (prove)\nusing this:\n  is_real x\n  \\<lbrakk>is_real (1 - x); is_real (1 + x)\\<rbrakk>\n  \\<Longrightarrow> is_real ((1 - x) / (1 + x))\n\ngoal (1 subgoal):\n 1. is_real ((1 - x) / (1 + x))", "by auto"], ["proof (state)\nthis:\n  is_real ((1 - x) / (1 + x))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"is_real ((1 - y)/(1 + y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real ((1 - y) / (1 + y))", "using \\<open>is_real y\\<close> div_reals[of \"1-y\" \"1+y\"]"], ["proof (prove)\nusing this:\n  is_real y\n  \\<lbrakk>is_real (1 - y); is_real (1 + y)\\<rbrakk>\n  \\<Longrightarrow> is_real ((1 - y) / (1 + y))\n\ngoal (1 subgoal):\n 1. is_real ((1 - y) / (1 + y))", "by auto"], ["proof (state)\nthis:\n  is_real ((1 - y) / (1 + y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"Re (1 + x) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Re (1 + x)", "using \\<open>- 1 < Re x\\<close>"], ["proof (prove)\nusing this:\n  - 1 < Re x\n\ngoal (1 subgoal):\n 1. 0 < Re (1 + x)", "by auto"], ["proof (state)\nthis:\n  0 < Re (1 + x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"1 + x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < Re (1 + x)\n\ngoal (1 subgoal):\n 1. 1 + x \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  1 + x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"Re (1 - x) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Re (1 - x)", "using \\<open>Re x \\<le> 0\\<close>"], ["proof (prove)\nusing this:\n  Re x \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re (1 - x)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> Re (1 - x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"Re ((1 - x)/(1 + x)) > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> Re (1 - x)\n\ngoal (1 subgoal):\n 1. 0 < Re ((1 - x) / (1 + x))", "using Re_divide_real \\<open>0 < Re (1 + x)\\<close> complex_eq_if_Re_eq hh(1) hh(4)"], ["proof (prove)\nusing this:\n  0 \\<le> Re (1 - x)\n  \\<lbrakk>is_real ?b; ?b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> Re (?a / ?b) = Re ?a / Re ?b\n  0 < Re (1 + x)\n  \\<lbrakk>is_real ?z1.0; is_real ?z2.0\\<rbrakk>\n  \\<Longrightarrow> (?z1.0 = ?z2.0) = (Re ?z1.0 = Re ?z2.0)\n  is_real x\n  Re x \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 < Re ((1 - x) / (1 + x))", "by auto"], ["proof (state)\nthis:\n  0 < Re ((1 - x) / (1 + x))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"Re(1 - x) \\<ge> Re ( 1 + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (1 + x) \\<le> Re (1 - x)", "using hh"], ["proof (prove)\nusing this:\n  is_real x\n  is_real y\n  - 1 < Re x\n  Re x \\<le> 0\n  - 1 < Re y\n  Re y \\<le> 0\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n  \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\n\ngoal (1 subgoal):\n 1. Re (1 + x) \\<le> Re (1 - x)", "by auto"], ["proof (state)\nthis:\n  Re (1 + x) \\<le> Re (1 - x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"Re ((1 - x)/(1 + x)) \\<ge> 1\""], ["proof (prove)\nusing this:\n  Re (1 + x) \\<le> Re (1 - x)\n\ngoal (1 subgoal):\n 1. 1 \\<le> Re ((1 - x) / (1 + x))", "using \\<open>Re (1 + x) > 0\\<close> \\<open>is_real ((1 - x)/(1 + x))\\<close>"], ["proof (prove)\nusing this:\n  Re (1 + x) \\<le> Re (1 - x)\n  0 < Re (1 + x)\n  is_real ((1 - x) / (1 + x))\n\ngoal (1 subgoal):\n 1. 1 \\<le> Re ((1 - x) / (1 + x))", "by (smt Re_divide_real arg_0_iff hh(1) le_divide_eq_1_pos one_complex.simps(2) plus_complex.simps(2))"], ["proof (state)\nthis:\n  1 \\<le> Re ((1 - x) / (1 + x))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"Re (1 + y) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Re (1 + y)", "using \\<open>- 1 < Re y\\<close>"], ["proof (prove)\nusing this:\n  - 1 < Re y\n\ngoal (1 subgoal):\n 1. 0 < Re (1 + y)", "by auto"], ["proof (state)\nthis:\n  0 < Re (1 + y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"1 + y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < Re (1 + y)\n\ngoal (1 subgoal):\n 1. 1 + y \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  1 + y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"Re (1 - y) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Re (1 - y)", "using \\<open>Re y \\<le> 0\\<close>"], ["proof (prove)\nusing this:\n  Re y \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re (1 - y)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> Re (1 - y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"Re ((1 - y)/(1 + y)) > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> Re (1 - y)\n\ngoal (1 subgoal):\n 1. 0 < Re ((1 - y) / (1 + y))", "using Re_divide_real \\<open>0 < Re (1 + y)\\<close> complex_eq_if_Re_eq hh"], ["proof (prove)\nusing this:\n  0 \\<le> Re (1 - y)\n  \\<lbrakk>is_real ?b; ?b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> Re (?a / ?b) = Re ?a / Re ?b\n  0 < Re (1 + y)\n  \\<lbrakk>is_real ?z1.0; is_real ?z2.0\\<rbrakk>\n  \\<Longrightarrow> (?z1.0 = ?z2.0) = (Re ?z1.0 = Re ?z2.0)\n  is_real x\n  is_real y\n  - 1 < Re x\n  Re x \\<le> 0\n  - 1 < Re y\n  Re y \\<le> 0\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n  \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\n\ngoal (1 subgoal):\n 1. 0 < Re ((1 - y) / (1 + y))", "by auto"], ["proof (state)\nthis:\n  0 < Re ((1 - y) / (1 + y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"Re(1 - y) \\<ge> Re ( 1 + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (1 + y) \\<le> Re (1 - y)", "using hh"], ["proof (prove)\nusing this:\n  is_real x\n  is_real y\n  - 1 < Re x\n  Re x \\<le> 0\n  - 1 < Re y\n  Re y \\<le> 0\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n  \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\n\ngoal (1 subgoal):\n 1. Re (1 + y) \\<le> Re (1 - y)", "by auto"], ["proof (state)\nthis:\n  Re (1 + y) \\<le> Re (1 - y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"Re ((1 - y)/(1 + y)) \\<ge> 1\""], ["proof (prove)\nusing this:\n  Re (1 + y) \\<le> Re (1 - y)\n\ngoal (1 subgoal):\n 1. 1 \\<le> Re ((1 - y) / (1 + y))", "using \\<open>Re (1 + y) > 0\\<close> \\<open>is_real ((1 - y)/(1 + y))\\<close>"], ["proof (prove)\nusing this:\n  Re (1 + y) \\<le> Re (1 - y)\n  0 < Re (1 + y)\n  is_real ((1 - y) / (1 + y))\n\ngoal (1 subgoal):\n 1. 1 \\<le> Re ((1 - y) / (1 + y))", "by (smt Re_divide_real arg_0_iff hh le_divide_eq_1_pos one_complex.simps(2) plus_complex.simps(2))"], ["proof (state)\nthis:\n  1 \\<le> Re ((1 - y) / (1 + y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"ln (Re ((1 - x) / (1 + x))) = ln (Re ((1 - y) / (1 + y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (Re ((1 - x) / (1 + x))) = ln (Re ((1 - y) / (1 + y)))", "using \\<open>Re ((1 - y)/(1 + y)) \\<ge> 1\\<close> \\<open>Re ((1 - x)/(1 + x)) \\<ge> 1\\<close> hh"], ["proof (prove)\nusing this:\n  1 \\<le> Re ((1 - y) / (1 + y))\n  1 \\<le> Re ((1 - x) / (1 + x))\n  is_real x\n  is_real y\n  - 1 < Re x\n  Re x \\<le> 0\n  - 1 < Re y\n  Re y \\<le> 0\n  \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n  \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\n\ngoal (1 subgoal):\n 1. ln (Re ((1 - x) / (1 + x))) = ln (Re ((1 - y) / (1 + y)))", "by auto"], ["proof (state)\nthis:\n  ln (Re ((1 - x) / (1 + x))) = ln (Re ((1 - y) / (1 + y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"Re ((1 - x) / (1 + x)) = Re ((1 - y) / (1 + y))\""], ["proof (prove)\nusing this:\n  ln (Re ((1 - x) / (1 + x))) = ln (Re ((1 - y) / (1 + y)))\n\ngoal (1 subgoal):\n 1. Re ((1 - x) / (1 + x)) = Re ((1 - y) / (1 + y))", "using \\<open>Re ((1 - y)/(1 + y)) > 0\\<close> \\<open>Re ((1 - x)/(1 + x)) > 0\\<close>"], ["proof (prove)\nusing this:\n  ln (Re ((1 - x) / (1 + x))) = ln (Re ((1 - y) / (1 + y)))\n  0 < Re ((1 - y) / (1 + y))\n  0 < Re ((1 - x) / (1 + x))\n\ngoal (1 subgoal):\n 1. Re ((1 - x) / (1 + x)) = Re ((1 - y) / (1 + y))", "by auto"], ["proof (state)\nthis:\n  Re ((1 - x) / (1 + x)) = Re ((1 - y) / (1 + y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"(1 - x) / (1 + x) = (1 - y) / (1 + y)\""], ["proof (prove)\nusing this:\n  Re ((1 - x) / (1 + x)) = Re ((1 - y) / (1 + y))\n\ngoal (1 subgoal):\n 1. (1 - x) / (1 + x) = (1 - y) / (1 + y)", "using \\<open>is_real ((1 - y)/(1 + y))\\<close> \\<open>is_real ((1 - x)/(1 + x))\\<close>"], ["proof (prove)\nusing this:\n  Re ((1 - x) / (1 + x)) = Re ((1 - y) / (1 + y))\n  is_real ((1 - y) / (1 + y))\n  is_real ((1 - x) / (1 + x))\n\ngoal (1 subgoal):\n 1. (1 - x) / (1 + x) = (1 - y) / (1 + y)", "using complex_eq_if_Re_eq"], ["proof (prove)\nusing this:\n  Re ((1 - x) / (1 + x)) = Re ((1 - y) / (1 + y))\n  is_real ((1 - y) / (1 + y))\n  is_real ((1 - x) / (1 + x))\n  \\<lbrakk>is_real ?z1.0; is_real ?z2.0\\<rbrakk>\n  \\<Longrightarrow> (?z1.0 = ?z2.0) = (Re ?z1.0 = Re ?z2.0)\n\ngoal (1 subgoal):\n 1. (1 - x) / (1 + x) = (1 - y) / (1 + y)", "by blast"], ["proof (state)\nthis:\n  (1 - x) / (1 + x) = (1 - y) / (1 + y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"(1 - x) * (1 + y) = (1 - y) * (1 + x)\""], ["proof (prove)\nusing this:\n  (1 - x) / (1 + x) = (1 - y) / (1 + y)\n\ngoal (1 subgoal):\n 1. (1 - x) * (1 + y) = (1 - y) * (1 + x)", "using \\<open>1 + y \\<noteq> 0\\<close> \\<open>1 + x \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  (1 - x) / (1 + x) = (1 - y) / (1 + y)\n  1 + y \\<noteq> 0\n  1 + x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (1 - x) * (1 + y) = (1 - y) * (1 + x)", "by (simp add:field_simps)"], ["proof (state)\nthis:\n  (1 - x) * (1 + y) = (1 - y) * (1 + x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>is_real x; is_real y; - 1 < Re x; Re x \\<le> 0; - 1 < Re y;\n        Re y \\<le> 0;\n        \\<bar>ln (Re ((1 - x) / (1 + x)))\\<bar> =\n        \\<bar>ln (Re ((1 - y) / (1 + y)))\\<bar>\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  (1 - x) * (1 + y) = (1 - y) * (1 + x)\n\ngoal (1 subgoal):\n 1. x = y", "by (simp add:field_simps)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n   {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n     (to_complex `\n      of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "thus \"inj_on ?g (to_complex ` of_complex ` ?A)\""], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n   {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n     (to_complex `\n      of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "using *"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n   {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n  to_complex `\n  of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0} =\n  {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n     (to_complex `\n      of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})", "by simp"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>)\n   (to_complex `\n    of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on\n   ((\\<lambda>x'. \\<bar>ln (Re ((1 - x') / (1 + x')))\\<bar>) \\<circ>\n    to_complex)\n   (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (poincare_distance 0\\<^sub>h)\n   (of_complex ` {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (poincare_distance 0\\<^sub>h \\<circ> of_complex)\n   {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n\ngoal (1 subgoal):\n 1. \\<forall>z'.\n       is_real z' \\<and>\n       Re z' \\<le> 0 \\<and>\n       - 1 < Re z' \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z') = d \\<longrightarrow>\n       z' = cor ((1 - exp d) / (1 + exp d))", "thus ?thesis"], ["proof (prove)\nusing this:\n  inj_on (poincare_distance 0\\<^sub>h \\<circ> of_complex)\n   {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n\ngoal (1 subgoal):\n 1. \\<forall>z'.\n       is_real z' \\<and>\n       Re z' \\<le> 0 \\<and>\n       - 1 < Re z' \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z') = d \\<longrightarrow>\n       z' = cor ((1 - exp d) / (1 + exp d))", "using \\<open>?P ?z\\<close>"], ["proof (prove)\nusing this:\n  inj_on (poincare_distance 0\\<^sub>h \\<circ> of_complex)\n   {x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}\n  is_real (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  Re (cor ((1 - exp d) / (1 + exp d))) \\<le> 0 \\<and>\n  - 1 < Re (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  poincare_distance 0\\<^sub>h\n   (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n  d\n\ngoal (1 subgoal):\n 1. \\<forall>z'.\n       is_real z' \\<and>\n       Re z' \\<le> 0 \\<and>\n       - 1 < Re z' \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z') = d \\<longrightarrow>\n       z' = cor ((1 - exp d) / (1 + exp d))", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}.\n     \\<forall>y\\<in>{x. is_real x \\<and> - 1 < Re x \\<and> Re x \\<le> 0}.\n        (poincare_distance 0\\<^sub>h \\<circ> of_complex) x =\n        (poincare_distance 0\\<^sub>h \\<circ> of_complex) y \\<longrightarrow>\n        x = y\n  is_real (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  Re (cor ((1 - exp d) / (1 + exp d))) \\<le> 0 \\<and>\n  - 1 < Re (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  poincare_distance 0\\<^sub>h\n   (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n  d\n\ngoal (1 subgoal):\n 1. \\<forall>z'.\n       is_real z' \\<and>\n       Re z' \\<le> 0 \\<and>\n       - 1 < Re z' \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z') = d \\<longrightarrow>\n       z' = cor ((1 - exp d) / (1 + exp d))", "by auto"], ["proof (state)\nthis:\n  \\<forall>z'.\n     is_real z' \\<and>\n     Re z' \\<le> 0 \\<and>\n     - 1 < Re z' \\<and>\n     poincare_distance 0\\<^sub>h (of_complex z') = d \\<longrightarrow>\n     z' = cor ((1 - exp d) / (1 + exp d))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>z'.\n     is_real z' \\<and>\n     Re z' \\<le> 0 \\<and>\n     - 1 < Re z' \\<and>\n     poincare_distance 0\\<^sub>h (of_complex z') = d \\<longrightarrow>\n     z' = cor ((1 - exp d) / (1 + exp d))\n\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_real z \\<and>\n       Re z \\<le> 0 \\<and>\n       - 1 < Re z \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d", "ultimately"], ["proof (chain)\npicking this:\n  is_real (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  Re (cor ((1 - exp d) / (1 + exp d))) \\<le> 0 \\<and>\n  - 1 < Re (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  poincare_distance 0\\<^sub>h\n   (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n  d\n  \\<forall>z'.\n     is_real z' \\<and>\n     Re z' \\<le> 0 \\<and>\n     - 1 < Re z' \\<and>\n     poincare_distance 0\\<^sub>h (of_complex z') = d \\<longrightarrow>\n     z' = cor ((1 - exp d) / (1 + exp d))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_real (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  Re (cor ((1 - exp d) / (1 + exp d))) \\<le> 0 \\<and>\n  - 1 < Re (cor ((1 - exp d) / (1 + exp d))) \\<and>\n  poincare_distance 0\\<^sub>h\n   (of_complex (cor ((1 - exp d) / (1 + exp d)))) =\n  d\n  \\<forall>z'.\n     is_real z' \\<and>\n     Re z' \\<le> 0 \\<and>\n     - 1 < Re z' \\<and>\n     poincare_distance 0\\<^sub>h (of_complex z') = d \\<longrightarrow>\n     z' = cor ((1 - exp d) / (1 + exp d))\n\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_real z \\<and>\n       Re z \\<le> 0 \\<and>\n       - 1 < Re z \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d", "by blast"], ["proof (state)\nthis:\n  \\<exists>!z.\n     is_real z \\<and>\n     Re z \\<le> 0 \\<and>\n     - 1 < Re z \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_x_axis_poincare_distance_positive:\n  assumes \"d \\<ge> 0\"\n  shows \"\\<exists> z. is_real z \\<and> Re z \\<ge> 0 \\<and> Re z < 1 \\<and>\n              of_complex z \\<in> unit_disc \\<and> of_complex z \\<in> circline_set x_axis \\<and>\n              poincare_distance 0\\<^sub>h (of_complex z) = d\" (is \"\\<exists> z. is_real z \\<and> Re z \\<ge> 0 \\<and> Re z < 1 \\<and> ?P z\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_real z \\<and>\n       0 \\<le> Re z \\<and>\n       Re z < 1 \\<and>\n       of_complex z \\<in> unit_disc \\<and>\n       of_complex z \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z) = d", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_real z \\<and>\n       0 \\<le> Re z \\<and>\n       Re z < 1 \\<and>\n       of_complex z \\<in> unit_disc \\<and>\n       of_complex z \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z) = d", "obtain z where *: \"is_real z\" \"Re z \\<le> 0\" \"Re z > -1\" \"?P z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>is_real z; Re z \\<le> 0; - 1 < Re z;\n         of_complex z \\<in> unit_disc \\<and>\n         of_complex z \\<in> circline_set x_axis \\<and>\n         poincare_distance 0\\<^sub>h (of_complex z) = d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_x_axis_poincare_distance_negative[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     is_real z \\<and>\n     Re z \\<le> 0 \\<and>\n     - 1 < Re z \\<and>\n     of_complex z \\<in> unit_disc \\<and>\n     of_complex z \\<in> circline_set x_axis \\<and>\n     poincare_distance 0\\<^sub>h (of_complex z) = d\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>is_real z; Re z \\<le> 0; - 1 < Re z;\n         of_complex z \\<in> unit_disc \\<and>\n         of_complex z \\<in> circline_set x_axis \\<and>\n         poincare_distance 0\\<^sub>h (of_complex z) = d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_real z\n  Re z \\<le> 0\n  - 1 < Re z\n  of_complex z \\<in> unit_disc \\<and>\n  of_complex z \\<in> circline_set x_axis \\<and>\n  poincare_distance 0\\<^sub>h (of_complex z) = d\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_real z \\<and>\n       0 \\<le> Re z \\<and>\n       Re z < 1 \\<and>\n       of_complex z \\<in> unit_disc \\<and>\n       of_complex z \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z) = d", "hence **: \"of_complex z \\<in> unit_disc\" \"of_complex z \\<in> circline_set x_axis\""], ["proof (prove)\nusing this:\n  is_real z\n  Re z \\<le> 0\n  - 1 < Re z\n  of_complex z \\<in> unit_disc \\<and>\n  of_complex z \\<in> circline_set x_axis \\<and>\n  poincare_distance 0\\<^sub>h (of_complex z) = d\n\ngoal (1 subgoal):\n 1. of_complex z \\<in> unit_disc &&& of_complex z \\<in> circline_set x_axis", "by (auto simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  of_complex z \\<in> unit_disc\n  of_complex z \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_real z \\<and>\n       0 \\<le> Re z \\<and>\n       Re z < 1 \\<and>\n       of_complex z \\<in> unit_disc \\<and>\n       of_complex z \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z) = d", "have \"is_real (-z) \\<and> Re (-z) \\<ge> 0 \\<and> Re (-z) < 1 \\<and> ?P (-z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (- z) \\<and>\n    0 \\<le> Re (- z) \\<and>\n    Re (- z) < 1 \\<and>\n    of_complex (- z) \\<in> unit_disc \\<and>\n    of_complex (- z) \\<in> circline_set x_axis \\<and>\n    poincare_distance 0\\<^sub>h (of_complex (- z)) = d", "using * **"], ["proof (prove)\nusing this:\n  is_real z\n  Re z \\<le> 0\n  - 1 < Re z\n  of_complex z \\<in> unit_disc \\<and>\n  of_complex z \\<in> circline_set x_axis \\<and>\n  poincare_distance 0\\<^sub>h (of_complex z) = d\n  of_complex z \\<in> unit_disc\n  of_complex z \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. is_real (- z) \\<and>\n    0 \\<le> Re (- z) \\<and>\n    Re (- z) < 1 \\<and>\n    of_complex (- z) \\<in> unit_disc \\<and>\n    of_complex (- z) \\<in> circline_set x_axis \\<and>\n    poincare_distance 0\\<^sub>h (of_complex (- z)) = d", "by (simp add: circline_set_x_axis)"], ["proof (state)\nthis:\n  is_real (- z) \\<and>\n  0 \\<le> Re (- z) \\<and>\n  Re (- z) < 1 \\<and>\n  of_complex (- z) \\<in> unit_disc \\<and>\n  of_complex (- z) \\<in> circline_set x_axis \\<and>\n  poincare_distance 0\\<^sub>h (of_complex (- z)) = d\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_real z \\<and>\n       0 \\<le> Re z \\<and>\n       Re z < 1 \\<and>\n       of_complex z \\<in> unit_disc \\<and>\n       of_complex z \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z) = d", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_real (- z) \\<and>\n  0 \\<le> Re (- z) \\<and>\n  Re (- z) < 1 \\<and>\n  of_complex (- z) \\<in> unit_disc \\<and>\n  of_complex (- z) \\<in> circline_set x_axis \\<and>\n  poincare_distance 0\\<^sub>h (of_complex (- z)) = d\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_real z \\<and>\n       0 \\<le> Re z \\<and>\n       Re z < 1 \\<and>\n       of_complex z \\<in> unit_disc \\<and>\n       of_complex z \\<in> circline_set x_axis \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z) = d", "by blast"], ["proof (state)\nthis:\n  \\<exists>z.\n     is_real z \\<and>\n     0 \\<le> Re z \\<and>\n     Re z < 1 \\<and>\n     of_complex z \\<in> unit_disc \\<and>\n     of_complex z \\<in> circline_set x_axis \\<and>\n     poincare_distance 0\\<^sub>h (of_complex z) = d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_x_axis_poincare_distance_positive:\n  assumes \"d \\<ge> 0\"\n  shows \"\\<exists>! z. is_real z \\<and> Re z \\<ge> 0 \\<and> Re z < 1 \\<and>\n               poincare_distance 0\\<^sub>h (of_complex z) = d\" (is \"\\<exists>! z. is_real z \\<and> Re z \\<ge> 0 \\<and> Re z < 1 \\<and> ?P z\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_real z \\<and>\n       0 \\<le> Re z \\<and>\n       Re z < 1 \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_real z \\<and>\n       0 \\<le> Re z \\<and>\n       Re z < 1 \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d", "obtain z where *: \"is_real z\" \"Re z \\<le> 0\" \"Re z > -1\" \"?P z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>is_real z; Re z \\<le> 0; - 1 < Re z;\n         poincare_distance 0\\<^sub>h (of_complex z) = d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using unique_x_axis_poincare_distance_negative[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>!z.\n     is_real z \\<and>\n     Re z \\<le> 0 \\<and>\n     - 1 < Re z \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>is_real z; Re z \\<le> 0; - 1 < Re z;\n         poincare_distance 0\\<^sub>h (of_complex z) = d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_real z\n  Re z \\<le> 0\n  - 1 < Re z\n  poincare_distance 0\\<^sub>h (of_complex z) = d\n\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_real z \\<and>\n       0 \\<le> Re z \\<and>\n       Re z < 1 \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d", "hence **: \"of_complex z \\<in> unit_disc\" \"of_complex z \\<in> circline_set x_axis\""], ["proof (prove)\nusing this:\n  is_real z\n  Re z \\<le> 0\n  - 1 < Re z\n  poincare_distance 0\\<^sub>h (of_complex z) = d\n\ngoal (1 subgoal):\n 1. of_complex z \\<in> unit_disc &&& of_complex z \\<in> circline_set x_axis", "by (auto simp add: cmod_eq_Re circline_set_x_axis)"], ["proof (state)\nthis:\n  of_complex z \\<in> unit_disc\n  of_complex z \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_real z \\<and>\n       0 \\<le> Re z \\<and>\n       Re z < 1 \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_real z \\<and>\n       0 \\<le> Re z \\<and>\n       Re z < 1 \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_real ?a \\<and>\n    0 \\<le> Re ?a \\<and>\n    Re ?a < 1 \\<and> poincare_distance 0\\<^sub>h (of_complex ?a) = d\n 2. \\<And>z.\n       is_real z \\<and>\n       0 \\<le> Re z \\<and>\n       Re z < 1 \\<and>\n       poincare_distance 0\\<^sub>h (of_complex z) = d \\<Longrightarrow>\n       z = ?a", "show \"is_real (-z) \\<and> Re (-z) \\<ge> 0 \\<and> Re (-z) < 1 \\<and> ?P (-z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (- z) \\<and>\n    0 \\<le> Re (- z) \\<and>\n    Re (- z) < 1 \\<and> poincare_distance 0\\<^sub>h (of_complex (- z)) = d", "using * **"], ["proof (prove)\nusing this:\n  is_real z\n  Re z \\<le> 0\n  - 1 < Re z\n  poincare_distance 0\\<^sub>h (of_complex z) = d\n  of_complex z \\<in> unit_disc\n  of_complex z \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. is_real (- z) \\<and>\n    0 \\<le> Re (- z) \\<and>\n    Re (- z) < 1 \\<and> poincare_distance 0\\<^sub>h (of_complex (- z)) = d", "by simp"], ["proof (state)\nthis:\n  is_real (- z) \\<and>\n  0 \\<le> Re (- z) \\<and>\n  Re (- z) < 1 \\<and> poincare_distance 0\\<^sub>h (of_complex (- z)) = d\n\ngoal (1 subgoal):\n 1. \\<And>za.\n       is_real za \\<and>\n       0 \\<le> Re za \\<and>\n       Re za < 1 \\<and>\n       poincare_distance 0\\<^sub>h (of_complex za) = d \\<Longrightarrow>\n       za = - z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>za.\n       is_real za \\<and>\n       0 \\<le> Re za \\<and>\n       Re za < 1 \\<and>\n       poincare_distance 0\\<^sub>h (of_complex za) = d \\<Longrightarrow>\n       za = - z", "fix z'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>za.\n       is_real za \\<and>\n       0 \\<le> Re za \\<and>\n       Re za < 1 \\<and>\n       poincare_distance 0\\<^sub>h (of_complex za) = d \\<Longrightarrow>\n       za = - z", "assume \"is_real z' \\<and> Re z' \\<ge> 0 \\<and> Re z' < 1 \\<and> ?P z'\""], ["proof (state)\nthis:\n  is_real z' \\<and>\n  0 \\<le> Re z' \\<and>\n  Re z' < 1 \\<and> poincare_distance 0\\<^sub>h (of_complex z') = d\n\ngoal (1 subgoal):\n 1. \\<And>za.\n       is_real za \\<and>\n       0 \\<le> Re za \\<and>\n       Re za < 1 \\<and>\n       poincare_distance 0\\<^sub>h (of_complex za) = d \\<Longrightarrow>\n       za = - z", "hence \"is_real (-z') \\<and> Re (-z') \\<le> 0 \\<and> Re (-z') > -1 \\<and> ?P (-z')\""], ["proof (prove)\nusing this:\n  is_real z' \\<and>\n  0 \\<le> Re z' \\<and>\n  Re z' < 1 \\<and> poincare_distance 0\\<^sub>h (of_complex z') = d\n\ngoal (1 subgoal):\n 1. is_real (- z') \\<and>\n    Re (- z') \\<le> 0 \\<and>\n    - 1 < Re (- z') \\<and>\n    poincare_distance 0\\<^sub>h (of_complex (- z')) = d", "by (auto simp add: circline_set_x_axis cmod_eq_Re)"], ["proof (state)\nthis:\n  is_real (- z') \\<and>\n  Re (- z') \\<le> 0 \\<and>\n  - 1 < Re (- z') \\<and> poincare_distance 0\\<^sub>h (of_complex (- z')) = d\n\ngoal (1 subgoal):\n 1. \\<And>za.\n       is_real za \\<and>\n       0 \\<le> Re za \\<and>\n       Re za < 1 \\<and>\n       poincare_distance 0\\<^sub>h (of_complex za) = d \\<Longrightarrow>\n       za = - z", "hence \"-z' = z\""], ["proof (prove)\nusing this:\n  is_real (- z') \\<and>\n  Re (- z') \\<le> 0 \\<and>\n  - 1 < Re (- z') \\<and> poincare_distance 0\\<^sub>h (of_complex (- z')) = d\n\ngoal (1 subgoal):\n 1. - z' = z", "using unique_x_axis_poincare_distance_negative[OF assms] *"], ["proof (prove)\nusing this:\n  is_real (- z') \\<and>\n  Re (- z') \\<le> 0 \\<and>\n  - 1 < Re (- z') \\<and> poincare_distance 0\\<^sub>h (of_complex (- z')) = d\n  \\<exists>!z.\n     is_real z \\<and>\n     Re z \\<le> 0 \\<and>\n     - 1 < Re z \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d\n  is_real z\n  Re z \\<le> 0\n  - 1 < Re z\n  poincare_distance 0\\<^sub>h (of_complex z) = d\n\ngoal (1 subgoal):\n 1. - z' = z", "by blast"], ["proof (state)\nthis:\n  - z' = z\n\ngoal (1 subgoal):\n 1. \\<And>za.\n       is_real za \\<and>\n       0 \\<le> Re za \\<and>\n       Re za < 1 \\<and>\n       poincare_distance 0\\<^sub>h (of_complex za) = d \\<Longrightarrow>\n       za = - z", "thus \"z' = -z\""], ["proof (prove)\nusing this:\n  - z' = z\n\ngoal (1 subgoal):\n 1. z' = - z", "by auto"], ["proof (state)\nthis:\n  z' = - z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!z.\n     is_real z \\<and>\n     0 \\<le> Re z \\<and>\n     Re z < 1 \\<and> poincare_distance 0\\<^sub>h (of_complex z) = d\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Equal distance implies that segments are isometric - this means that congruence could be\ndefined either by two segments having the same distance or by requiring existence of an isometry\nthat maps one segment to the other.\\<close>"], ["", "lemma poincare_distance_eq_ex_moebius:\n  assumes in_disc: \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\" and \"u' \\<in> unit_disc\" and \"v' \\<in> unit_disc\"\n  assumes \"poincare_distance u v = poincare_distance u' v'\"\n  shows \"\\<exists> M. unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'\" (is \"?P' u v u' v'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'", "proof (cases \"u = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'\n 2. u \\<noteq> v \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'", "case True"], ["proof (state)\nthis:\n  u = v\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'\n 2. u \\<noteq> v \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'", "thus ?thesis"], ["proof (prove)\nusing this:\n  u = v\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'", "using assms poincare_distance_eq_0_iff[of u' v']"], ["proof (prove)\nusing this:\n  u = v\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n  \\<lbrakk>u' \\<in> unit_disc; v' \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance u' v' = 0) = (u' = v')\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'", "by (simp add: unit_disc_fix_transitive)"], ["proof (state)\nthis:\n  \\<exists>M.\n     unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'", "case False"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'", "have \"\\<forall> u' v'. u \\<noteq> v \\<and> u' \\<in> unit_disc \\<and> v' \\<in> unit_disc \\<and> poincare_distance u v = poincare_distance u' v' \\<longrightarrow>\n                 ?P' u' v' u v\" (is \"?P u v\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u' v'.\n       u \\<noteq> v \\<and>\n       u' \\<in> unit_disc \\<and>\n       v' \\<in> unit_disc \\<and>\n       poincare_distance u v = poincare_distance u' v' \\<longrightarrow>\n       (\\<exists>M.\n           unit_disc_fix M \\<and>\n           moebius_pt M u' = u \\<and> moebius_pt M v' = v)", "proof (rule wlog_positive_x_axis[where P=\"?P\"])"], ["proof (state)\ngoal (5 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. u \\<noteq> v\n 4. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)\n 5. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            0\\<^sub>h \\<noteq> of_complex x \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance 0\\<^sub>h (of_complex x) =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = 0\\<^sub>h \\<and>\n                                moebius_pt M v' = of_complex x)", "fix x"], ["proof (state)\ngoal (5 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. u \\<noteq> v\n 4. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)\n 5. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            0\\<^sub>h \\<noteq> of_complex x \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance 0\\<^sub>h (of_complex x) =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = 0\\<^sub>h \\<and>\n                                moebius_pt M v' = of_complex x)", "assume \"is_real x\" \"0 < Re x\" \"Re x < 1\""], ["proof (state)\nthis:\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (5 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. u \\<noteq> v\n 4. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)\n 5. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            0\\<^sub>h \\<noteq> of_complex x \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance 0\\<^sub>h (of_complex x) =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = 0\\<^sub>h \\<and>\n                                moebius_pt M v' = of_complex x)", "hence \"of_complex x \\<in> unit_disc\" \"of_complex x \\<in> circline_set x_axis\""], ["proof (prove)\nusing this:\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. of_complex x \\<in> unit_disc &&& of_complex x \\<in> circline_set x_axis", "unfolding circline_set_x_axis"], ["proof (prove)\nusing this:\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. of_complex x \\<in> unit_disc &&&\n    of_complex x\n    \\<in> of_complex ` {x. is_real x} \\<union> {\\<infinity>\\<^sub>h}", "by (auto simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  of_complex x \\<in> unit_disc\n  of_complex x \\<in> circline_set x_axis\n\ngoal (5 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. u \\<noteq> v\n 4. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)\n 5. \\<And>x.\n       \\<lbrakk>is_real x; 0 < Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            0\\<^sub>h \\<noteq> of_complex x \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance 0\\<^sub>h (of_complex x) =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = 0\\<^sub>h \\<and>\n                                moebius_pt M v' = of_complex x)", "show \"?P 0\\<^sub>h (of_complex x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u' v'.\n       0\\<^sub>h \\<noteq> of_complex x \\<and>\n       u' \\<in> unit_disc \\<and>\n       v' \\<in> unit_disc \\<and>\n       poincare_distance 0\\<^sub>h (of_complex x) =\n       poincare_distance u' v' \\<longrightarrow>\n       (\\<exists>M.\n           unit_disc_fix M \\<and>\n           moebius_pt M u' = 0\\<^sub>h \\<and>\n           moebius_pt M v' = of_complex x)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; u' \\<in> unit_disc;\n        v' \\<in> unit_disc;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = 0\\<^sub>h \\<and>\n                            moebius_pt M v' = of_complex x", "fix u' v'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; u' \\<in> unit_disc;\n        v' \\<in> unit_disc;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = 0\\<^sub>h \\<and>\n                            moebius_pt M v' = of_complex x", "assume \"0\\<^sub>h \\<noteq> of_complex x\" and in_disc: \"u' \\<in> unit_disc\" \"v' \\<in> unit_disc\" and\n             \"poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\""], ["proof (state)\nthis:\n  0\\<^sub>h \\<noteq> of_complex x\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\n\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; u' \\<in> unit_disc;\n        v' \\<in> unit_disc;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = 0\\<^sub>h \\<and>\n                            moebius_pt M v' = of_complex x", "hence \"u' \\<noteq> v'\" \"poincare_distance u' v' > 0\""], ["proof (prove)\nusing this:\n  0\\<^sub>h \\<noteq> of_complex x\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\n\ngoal (1 subgoal):\n 1. u' \\<noteq> v' &&& 0 < poincare_distance u' v'", "using poincare_distance_eq_0_iff[of \"0\\<^sub>h\" \"of_complex x\"] \\<open>of_complex x \\<in> unit_disc\\<close>"], ["proof (prove)\nusing this:\n  0\\<^sub>h \\<noteq> of_complex x\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\n  \\<lbrakk>0\\<^sub>h \\<in> unit_disc; of_complex x \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance 0\\<^sub>h (of_complex x) = 0) =\n                    (0\\<^sub>h = of_complex x)\n  of_complex x \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. u' \\<noteq> v' &&& 0 < poincare_distance u' v'", "using poincare_distance_ge0[of \"0\\<^sub>h\" \"of_complex x\"]"], ["proof (prove)\nusing this:\n  0\\<^sub>h \\<noteq> of_complex x\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\n  \\<lbrakk>0\\<^sub>h \\<in> unit_disc; of_complex x \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> (poincare_distance 0\\<^sub>h (of_complex x) = 0) =\n                    (0\\<^sub>h = of_complex x)\n  of_complex x \\<in> unit_disc\n  \\<lbrakk>0\\<^sub>h \\<in> unit_disc; of_complex x \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> poincare_distance 0\\<^sub>h (of_complex x)\n\ngoal (1 subgoal):\n 1. u' \\<noteq> v' &&& 0 < poincare_distance u' v'", "by auto"], ["proof (state)\nthis:\n  u' \\<noteq> v'\n  0 < poincare_distance u' v'\n\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; u' \\<in> unit_disc;\n        v' \\<in> unit_disc;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = 0\\<^sub>h \\<and>\n                            moebius_pt M v' = of_complex x", "then"], ["proof (chain)\npicking this:\n  u' \\<noteq> v'\n  0 < poincare_distance u' v'", "obtain M where M: \"unit_disc_fix M\" \"moebius_pt M u' = 0\\<^sub>h\" \"moebius_pt M v' \\<in> positive_x_axis\""], ["proof (prove)\nusing this:\n  u' \\<noteq> v'\n  0 < poincare_distance u' v'\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>unit_disc_fix M; moebius_pt M u' = 0\\<^sub>h;\n         moebius_pt M v' \\<in> positive_x_axis\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_unit_disc_fix_to_zero_positive_x_axis[of u' v'] in_disc"], ["proof (prove)\nusing this:\n  u' \\<noteq> v'\n  0 < poincare_distance u' v'\n  \\<lbrakk>u' \\<in> unit_disc; v' \\<in> unit_disc; u' \\<noteq> v'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M.\n                       unit_disc_fix M \\<and>\n                       moebius_pt M u' = 0\\<^sub>h \\<and>\n                       moebius_pt M v' \\<in> positive_x_axis\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>unit_disc_fix M; moebius_pt M u' = 0\\<^sub>h;\n         moebius_pt M v' \\<in> positive_x_axis\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unit_disc_fix M\n  moebius_pt M u' = 0\\<^sub>h\n  moebius_pt M v' \\<in> positive_x_axis\n\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; u' \\<in> unit_disc;\n        v' \\<in> unit_disc;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = 0\\<^sub>h \\<and>\n                            moebius_pt M v' = of_complex x", "then"], ["proof (chain)\npicking this:\n  unit_disc_fix M\n  moebius_pt M u' = 0\\<^sub>h\n  moebius_pt M v' \\<in> positive_x_axis", "obtain Mv' where Mv': \"moebius_pt M v' = of_complex Mv'\""], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  moebius_pt M u' = 0\\<^sub>h\n  moebius_pt M v' \\<in> positive_x_axis\n\ngoal (1 subgoal):\n 1. (\\<And>Mv'.\n        moebius_pt M v' = of_complex Mv' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inf_or_of_complex[of \"moebius_pt M v'\"] in_disc unit_disc_fix_iff[of M]"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  moebius_pt M u' = 0\\<^sub>h\n  moebius_pt M v' \\<in> positive_x_axis\n  moebius_pt M v' = \\<infinity>\\<^sub>h \\<or>\n  (\\<exists>x. moebius_pt M v' = of_complex x)\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  unit_disc_fix M \\<Longrightarrow> moebius_pt M ` unit_disc = unit_disc\n\ngoal (1 subgoal):\n 1. (\\<And>Mv'.\n        moebius_pt M v' = of_complex Mv' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis image_eqI inf_notin_unit_disc)"], ["proof (state)\nthis:\n  moebius_pt M v' = of_complex Mv'\n\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; u' \\<in> unit_disc;\n        v' \\<in> unit_disc;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = 0\\<^sub>h \\<and>\n                            moebius_pt M v' = of_complex x", "have \"moebius_pt M v' \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt M v' \\<in> unit_disc", "using M(1) \\<open>v' \\<in> unit_disc\\<close>"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  v' \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt M v' \\<in> unit_disc", "by auto"], ["proof (state)\nthis:\n  moebius_pt M v' \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; u' \\<in> unit_disc;\n        v' \\<in> unit_disc;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = 0\\<^sub>h \\<and>\n                            moebius_pt M v' = of_complex x", "have \"Re Mv' > 0\" \"is_real Mv'\" \"Re Mv' < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Re Mv' &&& is_real Mv' &&& Re Mv' < 1", "using M Mv' of_complex_inj \\<open>moebius_pt M v' \\<in> unit_disc\\<close>"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  moebius_pt M u' = 0\\<^sub>h\n  moebius_pt M v' \\<in> positive_x_axis\n  moebius_pt M v' = of_complex Mv'\n  of_complex ?x = of_complex ?y \\<Longrightarrow> ?x = ?y\n  moebius_pt M v' \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. 0 < Re Mv' &&& is_real Mv' &&& Re Mv' < 1", "unfolding positive_x_axis_def circline_set_x_axis"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  moebius_pt M u' = 0\\<^sub>h\n  moebius_pt M v'\n  \\<in> {z \\<in> of_complex ` {x. is_real x} \\<union> {\\<infinity>\\<^sub>h}.\n         z \\<noteq> \\<infinity>\\<^sub>h \\<and> 0 < Re (to_complex z)}\n  moebius_pt M v' = of_complex Mv'\n  of_complex ?x = of_complex ?y \\<Longrightarrow> ?x = ?y\n  moebius_pt M v' \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. 0 < Re Mv' &&& is_real Mv' &&& Re Mv' < 1", "using cmod_eq_Re"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  moebius_pt M u' = 0\\<^sub>h\n  moebius_pt M v'\n  \\<in> {z \\<in> of_complex ` {x. is_real x} \\<union> {\\<infinity>\\<^sub>h}.\n         z \\<noteq> \\<infinity>\\<^sub>h \\<and> 0 < Re (to_complex z)}\n  moebius_pt M v' = of_complex Mv'\n  of_complex ?x = of_complex ?y \\<Longrightarrow> ?x = ?y\n  moebius_pt M v' \\<in> unit_disc\n  is_real ?z \\<Longrightarrow> cmod ?z = \\<bar>Re ?z\\<bar>\n\ngoal (1 subgoal):\n 1. 0 < Re Mv' &&& is_real Mv' &&& Re Mv' < 1", "by auto fastforce"], ["proof (state)\nthis:\n  0 < Re Mv'\n  is_real Mv'\n  Re Mv' < 1\n\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; u' \\<in> unit_disc;\n        v' \\<in> unit_disc;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = 0\\<^sub>h \\<and>\n                            moebius_pt M v' = of_complex x", "have \"poincare_distance 0\\<^sub>h (moebius_pt M v') = poincare_distance u' v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (moebius_pt M v') = poincare_distance u' v'", "using M(1)"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (moebius_pt M v') = poincare_distance u' v'", "using in_disc"], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance 0\\<^sub>h (moebius_pt M v') = poincare_distance u' v'", "by (subst M(2)[symmetric], simp)"], ["proof (state)\nthis:\n  poincare_distance 0\\<^sub>h (moebius_pt M v') = poincare_distance u' v'\n\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; u' \\<in> unit_disc;\n        v' \\<in> unit_disc;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = 0\\<^sub>h \\<and>\n                            moebius_pt M v' = of_complex x", "have \"Mv' = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mv' = x", "using \\<open>poincare_distance 0\\<^sub>h (moebius_pt M v') = poincare_distance u' v'\\<close> Mv'"], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (moebius_pt M v') = poincare_distance u' v'\n  moebius_pt M v' = of_complex Mv'\n\ngoal (1 subgoal):\n 1. Mv' = x", "using \\<open>poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\\<close>"], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (moebius_pt M v') = poincare_distance u' v'\n  moebius_pt M v' = of_complex Mv'\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\n\ngoal (1 subgoal):\n 1. Mv' = x", "using unique_x_axis_poincare_distance_positive[of \"poincare_distance u' v'\"]\n          \\<open>poincare_distance u' v' > 0\\<close>"], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (moebius_pt M v') = poincare_distance u' v'\n  moebius_pt M v' = of_complex Mv'\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\n  0 \\<le> poincare_distance u' v' \\<Longrightarrow>\n  \\<exists>!z.\n     is_real z \\<and>\n     0 \\<le> Re z \\<and>\n     Re z < 1 \\<and>\n     poincare_distance 0\\<^sub>h (of_complex z) = poincare_distance u' v'\n  0 < poincare_distance u' v'\n\ngoal (1 subgoal):\n 1. Mv' = x", "using \\<open>Re Mv' > 0\\<close> \\<open>Re Mv' < 1\\<close> \\<open>is_real Mv'\\<close>"], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (moebius_pt M v') = poincare_distance u' v'\n  moebius_pt M v' = of_complex Mv'\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\n  0 \\<le> poincare_distance u' v' \\<Longrightarrow>\n  \\<exists>!z.\n     is_real z \\<and>\n     0 \\<le> Re z \\<and>\n     Re z < 1 \\<and>\n     poincare_distance 0\\<^sub>h (of_complex z) = poincare_distance u' v'\n  0 < poincare_distance u' v'\n  0 < Re Mv'\n  Re Mv' < 1\n  is_real Mv'\n\ngoal (1 subgoal):\n 1. Mv' = x", "using \\<open>is_real x\\<close> \\<open>Re x > 0\\<close> \\<open>Re x < 1\\<close>"], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (moebius_pt M v') = poincare_distance u' v'\n  moebius_pt M v' = of_complex Mv'\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\n  0 \\<le> poincare_distance u' v' \\<Longrightarrow>\n  \\<exists>!z.\n     is_real z \\<and>\n     0 \\<le> Re z \\<and>\n     Re z < 1 \\<and>\n     poincare_distance 0\\<^sub>h (of_complex z) = poincare_distance u' v'\n  0 < poincare_distance u' v'\n  0 < Re Mv'\n  Re Mv' < 1\n  is_real Mv'\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. Mv' = x", "unfolding positive_x_axis_def"], ["proof (prove)\nusing this:\n  poincare_distance 0\\<^sub>h (moebius_pt M v') = poincare_distance u' v'\n  moebius_pt M v' = of_complex Mv'\n  poincare_distance 0\\<^sub>h (of_complex x) = poincare_distance u' v'\n  0 \\<le> poincare_distance u' v' \\<Longrightarrow>\n  \\<exists>!z.\n     is_real z \\<and>\n     0 \\<le> Re z \\<and>\n     Re z < 1 \\<and>\n     poincare_distance 0\\<^sub>h (of_complex z) = poincare_distance u' v'\n  0 < poincare_distance u' v'\n  0 < Re Mv'\n  Re Mv' < 1\n  is_real Mv'\n  is_real x\n  0 < Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. Mv' = x", "by auto"], ["proof (state)\nthis:\n  Mv' = x\n\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>0\\<^sub>h \\<noteq> of_complex x; u' \\<in> unit_disc;\n        v' \\<in> unit_disc;\n        poincare_distance 0\\<^sub>h (of_complex x) =\n        poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = 0\\<^sub>h \\<and>\n                            moebius_pt M v' = of_complex x", "thus \"?P' u' v' 0\\<^sub>h (of_complex x)\""], ["proof (prove)\nusing this:\n  Mv' = x\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix M \\<and>\n       moebius_pt M u' = 0\\<^sub>h \\<and> moebius_pt M v' = of_complex x", "using M Mv'"], ["proof (prove)\nusing this:\n  Mv' = x\n  unit_disc_fix M\n  moebius_pt M u' = 0\\<^sub>h\n  moebius_pt M v' \\<in> positive_x_axis\n  moebius_pt M v' = of_complex Mv'\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix M \\<and>\n       moebius_pt M u' = 0\\<^sub>h \\<and> moebius_pt M v' = of_complex x", "by auto"], ["proof (state)\nthis:\n  \\<exists>M.\n     unit_disc_fix M \\<and>\n     moebius_pt M u' = 0\\<^sub>h \\<and> moebius_pt M v' = of_complex x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>u' v'.\n     0\\<^sub>h \\<noteq> of_complex x \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     poincare_distance 0\\<^sub>h (of_complex x) =\n     poincare_distance u' v' \\<longrightarrow>\n     (\\<exists>M.\n         unit_disc_fix M \\<and>\n         moebius_pt M u' = 0\\<^sub>h \\<and> moebius_pt M v' = of_complex x)\n\ngoal (4 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. u \\<noteq> v\n 4. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. u \\<in> unit_disc\n 2. v \\<in> unit_disc\n 3. u \\<noteq> v\n 4. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)", "show \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> unit_disc &&& v \\<in> unit_disc &&& u \\<noteq> v", "by fact+"], ["proof (state)\nthis:\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)", "fix M u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)", "let ?Mu = \"moebius_pt M u\" and ?Mv = \"moebius_pt M v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)", "assume 1: \"unit_disc_fix M\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\" \"u \\<noteq> v\""], ["proof (state)\nthis:\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)", "hence 2: \"?Mu \\<noteq> ?Mv\" \"?Mu \\<in> unit_disc\" \"?Mv \\<in> unit_disc\""], ["proof (prove)\nusing this:\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. moebius_pt M u \\<noteq> moebius_pt M v &&&\n    moebius_pt M u \\<in> unit_disc &&& moebius_pt M v \\<in> unit_disc", "by auto"], ["proof (state)\nthis:\n  moebius_pt M u \\<noteq> moebius_pt M v\n  moebius_pt M u \\<in> unit_disc\n  moebius_pt M v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)", "assume 3: \"?P (moebius_pt M u) (moebius_pt M v)\""], ["proof (state)\nthis:\n  \\<forall>u' v'.\n     moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     poincare_distance (moebius_pt M u) (moebius_pt M v) =\n     poincare_distance u' v' \\<longrightarrow>\n     (\\<exists>Ma.\n         unit_disc_fix Ma \\<and>\n         moebius_pt Ma u' = moebius_pt M u \\<and>\n         moebius_pt Ma v' = moebius_pt M v)\n\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        u \\<noteq> v;\n        \\<forall>u' v'.\n           moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n           u' \\<in> unit_disc \\<and>\n           v' \\<in> unit_disc \\<and>\n           poincare_distance (moebius_pt M u) (moebius_pt M v) =\n           poincare_distance u' v' \\<longrightarrow>\n           (\\<exists>Ma.\n               unit_disc_fix Ma \\<and>\n               moebius_pt Ma u' = moebius_pt M u \\<and>\n               moebius_pt Ma v' = moebius_pt M v)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u' v'.\n                            u \\<noteq> v \\<and>\n                            u' \\<in> unit_disc \\<and>\n                            v' \\<in> unit_disc \\<and>\n                            poincare_distance u v =\n                            poincare_distance u' v' \\<longrightarrow>\n                            (\\<exists>M.\n                                unit_disc_fix M \\<and>\n                                moebius_pt M u' = u \\<and>\n                                moebius_pt M v' = v)", "show \"?P u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u' v'.\n       u \\<noteq> v \\<and>\n       u' \\<in> unit_disc \\<and>\n       v' \\<in> unit_disc \\<and>\n       poincare_distance u v = poincare_distance u' v' \\<longrightarrow>\n       (\\<exists>M.\n           unit_disc_fix M \\<and>\n           moebius_pt M u' = u \\<and> moebius_pt M v' = v)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>u \\<noteq> v; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        poincare_distance u v = poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = u \\<and> moebius_pt M v' = v", "fix u' v'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>u \\<noteq> v; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        poincare_distance u v = poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = u \\<and> moebius_pt M v' = v", "assume 4: \"u' \\<in> unit_disc\" \"v' \\<in> unit_disc\" \"poincare_distance u v = poincare_distance u' v'\""], ["proof (state)\nthis:\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>u \\<noteq> v; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        poincare_distance u v = poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = u \\<and> moebius_pt M v' = v", "hence \"poincare_distance ?Mu ?Mv = poincare_distance u v\""], ["proof (prove)\nusing this:\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n\ngoal (1 subgoal):\n 1. poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "using 1"], ["proof (prove)\nusing this:\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. poincare_distance (moebius_pt M u) (moebius_pt M v) =\n    poincare_distance u v", "by simp"], ["proof (state)\nthis:\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  poincare_distance u v\n\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>u \\<noteq> v; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        poincare_distance u v = poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = u \\<and> moebius_pt M v' = v", "then"], ["proof (chain)\npicking this:\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  poincare_distance u v", "obtain M' where 5: \"unit_disc_fix M'\" \"moebius_pt M' u' = ?Mu\" \"moebius_pt M' v' = ?Mv\""], ["proof (prove)\nusing this:\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  poincare_distance u v\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>unit_disc_fix M'; moebius_pt M' u' = moebius_pt M u;\n         moebius_pt M' v' = moebius_pt M v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2 3 4"], ["proof (prove)\nusing this:\n  poincare_distance (moebius_pt M u) (moebius_pt M v) =\n  poincare_distance u v\n  moebius_pt M u \\<noteq> moebius_pt M v\n  moebius_pt M u \\<in> unit_disc\n  moebius_pt M v \\<in> unit_disc\n  \\<forall>u' v'.\n     moebius_pt M u \\<noteq> moebius_pt M v \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     poincare_distance (moebius_pt M u) (moebius_pt M v) =\n     poincare_distance u' v' \\<longrightarrow>\n     (\\<exists>Ma.\n         unit_disc_fix Ma \\<and>\n         moebius_pt Ma u' = moebius_pt M u \\<and>\n         moebius_pt Ma v' = moebius_pt M v)\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>unit_disc_fix M'; moebius_pt M' u' = moebius_pt M u;\n         moebius_pt M' v' = moebius_pt M v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unit_disc_fix M'\n  moebius_pt M' u' = moebius_pt M u\n  moebius_pt M' v' = moebius_pt M v\n\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>u \\<noteq> v; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        poincare_distance u v = poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = u \\<and> moebius_pt M v' = v", "let ?M = \"(-M) + M'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>u \\<noteq> v; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        poincare_distance u v = poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = u \\<and> moebius_pt M v' = v", "have \"unit_disc_fix ?M \\<and> moebius_pt ?M u' = u \\<and> moebius_pt ?M v' = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_disc_fix (- M + M') \\<and>\n    moebius_pt (- M + M') u' = u \\<and> moebius_pt (- M + M') v' = v", "using 5 \\<open>unit_disc_fix M\\<close>"], ["proof (prove)\nusing this:\n  unit_disc_fix M'\n  moebius_pt M' u' = moebius_pt M u\n  moebius_pt M' v' = moebius_pt M v\n  unit_disc_fix M\n\ngoal (1 subgoal):\n 1. unit_disc_fix (- M + M') \\<and>\n    moebius_pt (- M + M') u' = u \\<and> moebius_pt (- M + M') v' = v", "using unit_disc_fix_moebius_comp[of \"-M\" \"M'\"]"], ["proof (prove)\nusing this:\n  unit_disc_fix M'\n  moebius_pt M' u' = moebius_pt M u\n  moebius_pt M' v' = moebius_pt M v\n  unit_disc_fix M\n  \\<lbrakk>unit_disc_fix (- M); unit_disc_fix M'\\<rbrakk>\n  \\<Longrightarrow> unit_disc_fix (moebius_comp (- M) M')\n\ngoal (1 subgoal):\n 1. unit_disc_fix (- M + M') \\<and>\n    moebius_pt (- M + M') u' = u \\<and> moebius_pt (- M + M') v' = v", "using unit_disc_fix_moebius_inv[of M]"], ["proof (prove)\nusing this:\n  unit_disc_fix M'\n  moebius_pt M' u' = moebius_pt M u\n  moebius_pt M' v' = moebius_pt M v\n  unit_disc_fix M\n  \\<lbrakk>unit_disc_fix (- M); unit_disc_fix M'\\<rbrakk>\n  \\<Longrightarrow> unit_disc_fix (moebius_comp (- M) M')\n  unit_disc_fix M \\<Longrightarrow> unit_disc_fix (moebius_inv M)\n\ngoal (1 subgoal):\n 1. unit_disc_fix (- M + M') \\<and>\n    moebius_pt (- M + M') u' = u \\<and> moebius_pt (- M + M') v' = v", "by simp"], ["proof (state)\nthis:\n  unit_disc_fix (- M + M') \\<and>\n  moebius_pt (- M + M') u' = u \\<and> moebius_pt (- M + M') v' = v\n\ngoal (1 subgoal):\n 1. \\<And>u' v'.\n       \\<lbrakk>u \\<noteq> v; u' \\<in> unit_disc; v' \\<in> unit_disc;\n        poincare_distance u v = poincare_distance u' v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unit_disc_fix M \\<and>\n                            moebius_pt M u' = u \\<and> moebius_pt M v' = v", "thus \"\\<exists>M. unit_disc_fix M \\<and> moebius_pt M u' = u \\<and> moebius_pt M v' = v\""], ["proof (prove)\nusing this:\n  unit_disc_fix (- M + M') \\<and>\n  moebius_pt (- M + M') u' = u \\<and> moebius_pt (- M + M') v' = v\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u' = u \\<and> moebius_pt M v' = v", "by blast"], ["proof (state)\nthis:\n  \\<exists>M.\n     unit_disc_fix M \\<and> moebius_pt M u' = u \\<and> moebius_pt M v' = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>u' v'.\n     u \\<noteq> v \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     poincare_distance u v = poincare_distance u' v' \\<longrightarrow>\n     (\\<exists>M.\n         unit_disc_fix M \\<and>\n         moebius_pt M u' = u \\<and> moebius_pt M v' = v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>u' v'.\n     u \\<noteq> v \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     poincare_distance u v = poincare_distance u' v' \\<longrightarrow>\n     (\\<exists>M.\n         unit_disc_fix M \\<and>\n         moebius_pt M u' = u \\<and> moebius_pt M v' = v)\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'", "then"], ["proof (chain)\npicking this:\n  \\<forall>u' v'.\n     u \\<noteq> v \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     poincare_distance u v = poincare_distance u' v' \\<longrightarrow>\n     (\\<exists>M.\n         unit_disc_fix M \\<and>\n         moebius_pt M u' = u \\<and> moebius_pt M v' = v)", "obtain M where \"unit_disc_fix M \\<and> moebius_pt M u' = u \\<and> moebius_pt M v' = v\""], ["proof (prove)\nusing this:\n  \\<forall>u' v'.\n     u \\<noteq> v \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     poincare_distance u v = poincare_distance u' v' \\<longrightarrow>\n     (\\<exists>M.\n         unit_disc_fix M \\<and>\n         moebius_pt M u' = u \\<and> moebius_pt M v' = v)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        unit_disc_fix M \\<and>\n        moebius_pt M u' = u \\<and> moebius_pt M v' = v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>u' v'.\n     u \\<noteq> v \\<and>\n     u' \\<in> unit_disc \\<and>\n     v' \\<in> unit_disc \\<and>\n     poincare_distance u v = poincare_distance u' v' \\<longrightarrow>\n     (\\<exists>M.\n         unit_disc_fix M \\<and>\n         moebius_pt M u' = u \\<and> moebius_pt M v' = v)\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u' \\<in> unit_disc\n  v' \\<in> unit_disc\n  poincare_distance u v = poincare_distance u' v'\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        unit_disc_fix M \\<and>\n        moebius_pt M u' = u \\<and> moebius_pt M v' = v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  unit_disc_fix M \\<and> moebius_pt M u' = u \\<and> moebius_pt M v' = v\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'", "hence \"unit_disc_fix (-M) \\<and> moebius_pt (-M) u = u' \\<and> moebius_pt (-M) v = v'\""], ["proof (prove)\nusing this:\n  unit_disc_fix M \\<and> moebius_pt M u' = u \\<and> moebius_pt M v' = v\n\ngoal (1 subgoal):\n 1. unit_disc_fix (- M) \\<and>\n    moebius_pt (- M) u = u' \\<and> moebius_pt (- M) v = v'", "using unit_disc_fix_moebius_inv[of M]"], ["proof (prove)\nusing this:\n  unit_disc_fix M \\<and> moebius_pt M u' = u \\<and> moebius_pt M v' = v\n  unit_disc_fix M \\<Longrightarrow> unit_disc_fix (moebius_inv M)\n\ngoal (1 subgoal):\n 1. unit_disc_fix (- M) \\<and>\n    moebius_pt (- M) u = u' \\<and> moebius_pt (- M) v = v'", "by auto"], ["proof (state)\nthis:\n  unit_disc_fix (- M) \\<and>\n  moebius_pt (- M) u = u' \\<and> moebius_pt (- M) v = v'\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'", "thus ?thesis"], ["proof (prove)\nusing this:\n  unit_disc_fix (- M) \\<and>\n  moebius_pt (- M) u = u' \\<and> moebius_pt (- M) v = v'\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'", "by blast"], ["proof (state)\nthis:\n  \\<exists>M.\n     unit_disc_fix M \\<and> moebius_pt M u = u' \\<and> moebius_pt M v = v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_midpoint_x_axis:\n  assumes x: \"is_real x\" \"-1 < Re x\" \"Re x < 1\" and\n          y: \"is_real y\" \"-1 < Re y\" \"Re y < 1\" and\n          \"x \\<noteq> y\"\n  shows \"\\<exists>! z. -1 < Re z \\<and> Re z < 1 \\<and> is_real z \\<and> poincare_distance (of_complex z) (of_complex x) = poincare_distance (of_complex z) (of_complex y)\" (is \"\\<exists>! z. ?R z (of_complex x) (of_complex y)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) (of_complex y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) (of_complex y)", "let ?x = \"of_complex x\" and ?y = \"of_complex y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) (of_complex y)", "let ?P = \"\\<lambda> x y. \\<exists>! z. ?R z x y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) (of_complex y)", "have \"\\<forall> x. -1 < Re x \\<and> Re x < 1 \\<and> is_real x \\<and> of_complex x \\<noteq> ?y \\<longrightarrow> ?P (of_complex x) ?y\" (is \"?Q (of_complex y)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       - 1 < Re x \\<and>\n       Re x < 1 \\<and>\n       is_real x \\<and> of_complex x \\<noteq> of_complex y \\<longrightarrow>\n       (\\<exists>!z.\n           - 1 < Re z \\<and>\n           Re z < 1 \\<and>\n           is_real z \\<and>\n           poincare_distance (of_complex z) (of_complex x) =\n           poincare_distance (of_complex z) (of_complex y))", "proof (rule wlog_real_zero)"], ["proof (state)\ngoal (4 subgoals):\n 1. of_complex y \\<in> unit_disc\n 2. is_real (to_complex (of_complex y))\n 3. \\<And>a u.\n       \\<lbrakk>u \\<in> unit_disc; is_real a; cmod a < 1;\n        \\<forall>x.\n           - 1 < Re x \\<and>\n           Re x < 1 \\<and>\n           is_real x \\<and>\n           of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n           (\\<exists>!z.\n               - 1 < Re z \\<and>\n               Re z < 1 \\<and>\n               is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) =\n               poincare_distance (of_complex z)\n                (moebius_pt (blaschke a) u))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            - 1 < Re x \\<and>\n                            Re x < 1 \\<and>\n                            is_real x \\<and>\n                            of_complex x \\<noteq> u \\<longrightarrow>\n                            (\\<exists>!z.\n                                - 1 < Re z \\<and>\n                                Re z < 1 \\<and>\n                                is_real z \\<and>\n                                poincare_distance (of_complex z)\n                                 (of_complex x) =\n                                poincare_distance (of_complex z) u)\n 4. \\<forall>x.\n       - 1 < Re x \\<and>\n       Re x < 1 \\<and>\n       is_real x \\<and> of_complex x \\<noteq> 0\\<^sub>h \\<longrightarrow>\n       (\\<exists>!z.\n           - 1 < Re z \\<and>\n           Re z < 1 \\<and>\n           is_real z \\<and>\n           poincare_distance (of_complex z) (of_complex x) =\n           poincare_distance (of_complex z) 0\\<^sub>h)", "show \"?y \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex y \\<in> unit_disc", "using y"], ["proof (prove)\nusing this:\n  is_real y\n  - 1 < Re y\n  Re y < 1\n\ngoal (1 subgoal):\n 1. of_complex y \\<in> unit_disc", "by (simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  of_complex y \\<in> unit_disc\n\ngoal (3 subgoals):\n 1. is_real (to_complex (of_complex y))\n 2. \\<And>a u.\n       \\<lbrakk>u \\<in> unit_disc; is_real a; cmod a < 1;\n        \\<forall>x.\n           - 1 < Re x \\<and>\n           Re x < 1 \\<and>\n           is_real x \\<and>\n           of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n           (\\<exists>!z.\n               - 1 < Re z \\<and>\n               Re z < 1 \\<and>\n               is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) =\n               poincare_distance (of_complex z)\n                (moebius_pt (blaschke a) u))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            - 1 < Re x \\<and>\n                            Re x < 1 \\<and>\n                            is_real x \\<and>\n                            of_complex x \\<noteq> u \\<longrightarrow>\n                            (\\<exists>!z.\n                                - 1 < Re z \\<and>\n                                Re z < 1 \\<and>\n                                is_real z \\<and>\n                                poincare_distance (of_complex z)\n                                 (of_complex x) =\n                                poincare_distance (of_complex z) u)\n 3. \\<forall>x.\n       - 1 < Re x \\<and>\n       Re x < 1 \\<and>\n       is_real x \\<and> of_complex x \\<noteq> 0\\<^sub>h \\<longrightarrow>\n       (\\<exists>!z.\n           - 1 < Re z \\<and>\n           Re z < 1 \\<and>\n           is_real z \\<and>\n           poincare_distance (of_complex z) (of_complex x) =\n           poincare_distance (of_complex z) 0\\<^sub>h)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. is_real (to_complex (of_complex y))\n 2. \\<And>a u.\n       \\<lbrakk>u \\<in> unit_disc; is_real a; cmod a < 1;\n        \\<forall>x.\n           - 1 < Re x \\<and>\n           Re x < 1 \\<and>\n           is_real x \\<and>\n           of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n           (\\<exists>!z.\n               - 1 < Re z \\<and>\n               Re z < 1 \\<and>\n               is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) =\n               poincare_distance (of_complex z)\n                (moebius_pt (blaschke a) u))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            - 1 < Re x \\<and>\n                            Re x < 1 \\<and>\n                            is_real x \\<and>\n                            of_complex x \\<noteq> u \\<longrightarrow>\n                            (\\<exists>!z.\n                                - 1 < Re z \\<and>\n                                Re z < 1 \\<and>\n                                is_real z \\<and>\n                                poincare_distance (of_complex z)\n                                 (of_complex x) =\n                                poincare_distance (of_complex z) u)\n 3. \\<forall>x.\n       - 1 < Re x \\<and>\n       Re x < 1 \\<and>\n       is_real x \\<and> of_complex x \\<noteq> 0\\<^sub>h \\<longrightarrow>\n       (\\<exists>!z.\n           - 1 < Re z \\<and>\n           Re z < 1 \\<and>\n           is_real z \\<and>\n           poincare_distance (of_complex z) (of_complex x) =\n           poincare_distance (of_complex z) 0\\<^sub>h)", "show \"is_real (to_complex ?y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (to_complex (of_complex y))", "using y"], ["proof (prove)\nusing this:\n  is_real y\n  - 1 < Re y\n  Re y < 1\n\ngoal (1 subgoal):\n 1. is_real (to_complex (of_complex y))", "by simp"], ["proof (state)\nthis:\n  is_real (to_complex (of_complex y))\n\ngoal (2 subgoals):\n 1. \\<And>a u.\n       \\<lbrakk>u \\<in> unit_disc; is_real a; cmod a < 1;\n        \\<forall>x.\n           - 1 < Re x \\<and>\n           Re x < 1 \\<and>\n           is_real x \\<and>\n           of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n           (\\<exists>!z.\n               - 1 < Re z \\<and>\n               Re z < 1 \\<and>\n               is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) =\n               poincare_distance (of_complex z)\n                (moebius_pt (blaschke a) u))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            - 1 < Re x \\<and>\n                            Re x < 1 \\<and>\n                            is_real x \\<and>\n                            of_complex x \\<noteq> u \\<longrightarrow>\n                            (\\<exists>!z.\n                                - 1 < Re z \\<and>\n                                Re z < 1 \\<and>\n                                is_real z \\<and>\n                                poincare_distance (of_complex z)\n                                 (of_complex x) =\n                                poincare_distance (of_complex z) u)\n 2. \\<forall>x.\n       - 1 < Re x \\<and>\n       Re x < 1 \\<and>\n       is_real x \\<and> of_complex x \\<noteq> 0\\<^sub>h \\<longrightarrow>\n       (\\<exists>!z.\n           - 1 < Re z \\<and>\n           Re z < 1 \\<and>\n           is_real z \\<and>\n           poincare_distance (of_complex z) (of_complex x) =\n           poincare_distance (of_complex z) 0\\<^sub>h)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a u.\n       \\<lbrakk>u \\<in> unit_disc; is_real a; cmod a < 1;\n        \\<forall>x.\n           - 1 < Re x \\<and>\n           Re x < 1 \\<and>\n           is_real x \\<and>\n           of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n           (\\<exists>!z.\n               - 1 < Re z \\<and>\n               Re z < 1 \\<and>\n               is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) =\n               poincare_distance (of_complex z)\n                (moebius_pt (blaschke a) u))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            - 1 < Re x \\<and>\n                            Re x < 1 \\<and>\n                            is_real x \\<and>\n                            of_complex x \\<noteq> u \\<longrightarrow>\n                            (\\<exists>!z.\n                                - 1 < Re z \\<and>\n                                Re z < 1 \\<and>\n                                is_real z \\<and>\n                                poincare_distance (of_complex z)\n                                 (of_complex x) =\n                                poincare_distance (of_complex z) u)\n 2. \\<forall>x.\n       - 1 < Re x \\<and>\n       Re x < 1 \\<and>\n       is_real x \\<and> of_complex x \\<noteq> 0\\<^sub>h \\<longrightarrow>\n       (\\<exists>!z.\n           - 1 < Re z \\<and>\n           Re z < 1 \\<and>\n           is_real z \\<and>\n           poincare_distance (of_complex z) (of_complex x) =\n           poincare_distance (of_complex z) 0\\<^sub>h)", "show \"?Q 0\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       - 1 < Re x \\<and>\n       Re x < 1 \\<and>\n       is_real x \\<and> of_complex x \\<noteq> 0\\<^sub>h \\<longrightarrow>\n       (\\<exists>!z.\n           - 1 < Re z \\<and>\n           Re z < 1 \\<and>\n           is_real z \\<and>\n           poincare_distance (of_complex z) (of_complex x) =\n           poincare_distance (of_complex z) 0\\<^sub>h)", "proof (rule allI, rule impI, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> 0\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) 0\\<^sub>h", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> 0\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) 0\\<^sub>h", "assume x: \"-1 < Re x\" \"Re x < 1\" \"is_real x\""], ["proof (state)\nthis:\n  - 1 < Re x\n  Re x < 1\n  is_real x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> 0\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) 0\\<^sub>h", "let ?x = \"of_complex x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> 0\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) 0\\<^sub>h", "assume \"?x \\<noteq> 0\\<^sub>h\""], ["proof (state)\nthis:\n  of_complex x \\<noteq> 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> 0\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) 0\\<^sub>h", "hence \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  of_complex x \\<noteq> 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> 0\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) 0\\<^sub>h", "hence \"Re x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re x \\<noteq> 0", "using x"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  - 1 < Re x\n  Re x < 1\n  is_real x\n\ngoal (1 subgoal):\n 1. Re x \\<noteq> 0", "using complex_neq_0"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  - 1 < Re x\n  Re x < 1\n  is_real x\n  (?z \\<noteq> 0) = (0 < (Re ?z)\\<^sup>2 + (Im ?z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. Re x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Re x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> 0\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) 0\\<^sub>h", "have *: \"\\<forall> a. -1 < a \\<and> a < 1 \\<longrightarrow> \n                 (poincare_distance (of_complex (cor a)) ?x = poincare_distance (of_complex (cor a)) 0\\<^sub>h \\<longleftrightarrow>\n                 (Re x) * a * a - 2 * a + Re x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       - 1 < a \\<and> a < 1 \\<longrightarrow>\n       (poincare_distance (of_complex (cor a)) (of_complex x) =\n        poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n       (Re x * a * a - 2 * a + Re x = 0)", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       - 1 < a \\<and> a < 1 \\<Longrightarrow>\n       (poincare_distance (of_complex (cor a)) (of_complex x) =\n        poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n       (Re x * a * a - 2 * a + Re x = 0)", "fix a :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       - 1 < a \\<and> a < 1 \\<Longrightarrow>\n       (poincare_distance (of_complex (cor a)) (of_complex x) =\n        poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n       (Re x * a * a - 2 * a + Re x = 0)", "assume \"-1 < a \\<and> a < 1\""], ["proof (state)\nthis:\n  - 1 < a \\<and> a < 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       - 1 < a \\<and> a < 1 \\<Longrightarrow>\n       (poincare_distance (of_complex (cor a)) (of_complex x) =\n        poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n       (Re x * a * a - 2 * a + Re x = 0)", "hence \"of_complex (cor a) \\<in> unit_disc\""], ["proof (prove)\nusing this:\n  - 1 < a \\<and> a < 1\n\ngoal (1 subgoal):\n 1. of_complex (cor a) \\<in> unit_disc", "by auto"], ["proof (state)\nthis:\n  of_complex (cor a) \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       - 1 < a \\<and> a < 1 \\<Longrightarrow>\n       (poincare_distance (of_complex (cor a)) (of_complex x) =\n        poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n       (Re x * a * a - 2 * a + Re x = 0)", "moreover"], ["proof (state)\nthis:\n  of_complex (cor a) \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       - 1 < a \\<and> a < 1 \\<Longrightarrow>\n       (poincare_distance (of_complex (cor a)) (of_complex x) =\n        poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n       (Re x * a * a - 2 * a + Re x = 0)", "have \"(a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) = a\\<^sup>2 / (1 - a\\<^sup>2) \\<longleftrightarrow>\n              (Re x) * a * a - 2 * a + Re x = 0\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "have \"1 - a\\<^sup>2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - a\\<^sup>2 \\<noteq> 0", "using \\<open>-1 < a \\<and> a < 1\\<close>"], ["proof (prove)\nusing this:\n  - 1 < a \\<and> a < 1\n\ngoal (1 subgoal):\n 1. 1 - a\\<^sup>2 \\<noteq> 0", "by (metis cancel_comm_monoid_add_class.diff_cancel diff_eq_diff_less less_numeral_extra(4) power2_eq_1_iff right_minus_eq)"], ["proof (state)\nthis:\n  1 - a\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "hence \"?lhs \\<longleftrightarrow> (a - Re x)\\<^sup>2 / (1 - (Re x)\\<^sup>2) = a\\<^sup>2\""], ["proof (prove)\nusing this:\n  1 - a\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    ((a - Re x)\\<^sup>2 / (1 - (Re x)\\<^sup>2) = a\\<^sup>2)", "by (smt divide_cancel_right divide_divide_eq_left mult.commute)"], ["proof (state)\nthis:\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2)) =\n  ((a - Re x)\\<^sup>2 / (1 - (Re x)\\<^sup>2) = a\\<^sup>2)\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "also"], ["proof (state)\nthis:\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2)) =\n  ((a - Re x)\\<^sup>2 / (1 - (Re x)\\<^sup>2) = a\\<^sup>2)\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "have \"... \\<longleftrightarrow> (a - Re x)\\<^sup>2 = a\\<^sup>2 * (1 - (Re x)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / (1 - (Re x)\\<^sup>2) = a\\<^sup>2) =\n    ((a - Re x)\\<^sup>2 = a\\<^sup>2 * (1 - (Re x)\\<^sup>2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / (1 - (Re x)\\<^sup>2) = a\\<^sup>2) =\n    ((a - Re x)\\<^sup>2 = a\\<^sup>2 * (1 - (Re x)\\<^sup>2))", "have \"1 - (Re x)\\<^sup>2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - (Re x)\\<^sup>2 \\<noteq> 0", "using x"], ["proof (prove)\nusing this:\n  - 1 < Re x\n  Re x < 1\n  is_real x\n\ngoal (1 subgoal):\n 1. 1 - (Re x)\\<^sup>2 \\<noteq> 0", "by (smt power2_eq_1_iff)"], ["proof (state)\nthis:\n  1 - (Re x)\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / (1 - (Re x)\\<^sup>2) = a\\<^sup>2) =\n    ((a - Re x)\\<^sup>2 = a\\<^sup>2 * (1 - (Re x)\\<^sup>2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 - (Re x)\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / (1 - (Re x)\\<^sup>2) = a\\<^sup>2) =\n    ((a - Re x)\\<^sup>2 = a\\<^sup>2 * (1 - (Re x)\\<^sup>2))", "by (simp add: divide_eq_eq)"], ["proof (state)\nthis:\n  ((a - Re x)\\<^sup>2 / (1 - (Re x)\\<^sup>2) = a\\<^sup>2) =\n  ((a - Re x)\\<^sup>2 = a\\<^sup>2 * (1 - (Re x)\\<^sup>2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((a - Re x)\\<^sup>2 / (1 - (Re x)\\<^sup>2) = a\\<^sup>2) =\n  ((a - Re x)\\<^sup>2 = a\\<^sup>2 * (1 - (Re x)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "also"], ["proof (state)\nthis:\n  ((a - Re x)\\<^sup>2 / (1 - (Re x)\\<^sup>2) = a\\<^sup>2) =\n  ((a - Re x)\\<^sup>2 = a\\<^sup>2 * (1 - (Re x)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "have \"... \\<longleftrightarrow> a\\<^sup>2 * (Re x)\\<^sup>2 - 2*a*Re x + (Re x)\\<^sup>2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 = a\\<^sup>2 * (1 - (Re x)\\<^sup>2)) =\n    (a\\<^sup>2 * (Re x)\\<^sup>2 - 2 * a * Re x + (Re x)\\<^sup>2 = 0)", "by (simp add: power2_diff field_simps)"], ["proof (state)\nthis:\n  ((a - Re x)\\<^sup>2 = a\\<^sup>2 * (1 - (Re x)\\<^sup>2)) =\n  (a\\<^sup>2 * (Re x)\\<^sup>2 - 2 * a * Re x + (Re x)\\<^sup>2 = 0)\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "also"], ["proof (state)\nthis:\n  ((a - Re x)\\<^sup>2 = a\\<^sup>2 * (1 - (Re x)\\<^sup>2)) =\n  (a\\<^sup>2 * (Re x)\\<^sup>2 - 2 * a * Re x + (Re x)\\<^sup>2 = 0)\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "have \"... \\<longleftrightarrow> Re x * (a\\<^sup>2 * Re x - 2 * a + Re x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a\\<^sup>2 * (Re x)\\<^sup>2 - 2 * a * Re x + (Re x)\\<^sup>2 = 0) =\n    (Re x * (a\\<^sup>2 * Re x - 2 * a + Re x) = 0)", "by (simp add: power2_eq_square field_simps)"], ["proof (state)\nthis:\n  (a\\<^sup>2 * (Re x)\\<^sup>2 - 2 * a * Re x + (Re x)\\<^sup>2 = 0) =\n  (Re x * (a\\<^sup>2 * Re x - 2 * a + Re x) = 0)\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "also"], ["proof (state)\nthis:\n  (a\\<^sup>2 * (Re x)\\<^sup>2 - 2 * a * Re x + (Re x)\\<^sup>2 = 0) =\n  (Re x * (a\\<^sup>2 * Re x - 2 * a + Re x) = 0)\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "have \"... \\<longleftrightarrow> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re x * (a\\<^sup>2 * Re x - 2 * a + Re x) = 0) =\n    (Re x * a * a - 2 * a + Re x = 0)", "using \\<open>Re x \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  Re x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (Re x * (a\\<^sup>2 * Re x - 2 * a + Re x) = 0) =\n    (Re x * a * a - 2 * a + Re x = 0)", "by (simp add: mult.commute mult.left_commute power2_eq_square)"], ["proof (state)\nthis:\n  (Re x * (a\\<^sup>2 * Re x - 2 * a + Re x) = 0) =\n  (Re x * a * a - 2 * a + Re x = 0)\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "finally"], ["proof (chain)\npicking this:\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2)) =\n  (Re x * a * a - 2 * a + Re x = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2)) =\n  (Re x * a * a - 2 * a + Re x = 0)\n\ngoal (1 subgoal):\n 1. ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2)) =\n    (Re x * a * a - 2 * a + Re x = 0)", "."], ["proof (state)\nthis:\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2)) =\n  (Re x * a * a - 2 * a + Re x = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2)) =\n  (Re x * a * a - 2 * a + Re x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       - 1 < a \\<and> a < 1 \\<Longrightarrow>\n       (poincare_distance (of_complex (cor a)) (of_complex x) =\n        poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n       (Re x * a * a - 2 * a + Re x = 0)", "moreover"], ["proof (state)\nthis:\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2)) =\n  (Re x * a * a - 2 * a + Re x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       - 1 < a \\<and> a < 1 \\<Longrightarrow>\n       (poincare_distance (of_complex (cor a)) (of_complex x) =\n        poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n       (Re x * a * a - 2 * a + Re x = 0)", "have \"arcosh (1 + 2 * ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)))) = arcosh (1 + 2 * a\\<^sup>2 / (1 - a\\<^sup>2)) \\<longleftrightarrow> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arcosh\n      (1 +\n       2 *\n       ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)))) =\n     arcosh (1 + 2 * a\\<^sup>2 / (1 - a\\<^sup>2))) =\n    ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2))", "using \\<open>-1 < a \\<and> a < 1\\<close> x mult_left_cancel[of \"2::real\" \"(a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2))\" \"a\\<^sup>2 / (1 - a\\<^sup>2)\"]"], ["proof (prove)\nusing this:\n  - 1 < a \\<and> a < 1\n  - 1 < Re x\n  Re x < 1\n  is_real x\n  2 \\<noteq> 0 \\<Longrightarrow>\n  (2 * ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2))) =\n   2 * (a\\<^sup>2 / (1 - a\\<^sup>2))) =\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2))\n\ngoal (1 subgoal):\n 1. (arcosh\n      (1 +\n       2 *\n       ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)))) =\n     arcosh (1 + 2 * a\\<^sup>2 / (1 - a\\<^sup>2))) =\n    ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n     a\\<^sup>2 / (1 - a\\<^sup>2))", "by (subst arcosh_eq_iff, simp_all add: square_le_1)"], ["proof (state)\nthis:\n  (arcosh\n    (1 +\n     2 * ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)))) =\n   arcosh (1 + 2 * a\\<^sup>2 / (1 - a\\<^sup>2))) =\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       - 1 < a \\<and> a < 1 \\<Longrightarrow>\n       (poincare_distance (of_complex (cor a)) (of_complex x) =\n        poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n       (Re x * a * a - 2 * a + Re x = 0)", "ultimately"], ["proof (chain)\npicking this:\n  of_complex (cor a) \\<in> unit_disc\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2)) =\n  (Re x * a * a - 2 * a + Re x = 0)\n  (arcosh\n    (1 +\n     2 * ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)))) =\n   arcosh (1 + 2 * a\\<^sup>2 / (1 - a\\<^sup>2))) =\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2))", "show \"poincare_distance (of_complex (cor a)) (of_complex x) = poincare_distance (of_complex (cor a)) 0\\<^sub>h \\<longleftrightarrow>\n              (Re x) * a * a - 2 * a + Re x = 0\""], ["proof (prove)\nusing this:\n  of_complex (cor a) \\<in> unit_disc\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2)) =\n  (Re x * a * a - 2 * a + Re x = 0)\n  (arcosh\n    (1 +\n     2 * ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)))) =\n   arcosh (1 + 2 * a\\<^sup>2 / (1 - a\\<^sup>2))) =\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2))\n\ngoal (1 subgoal):\n 1. (poincare_distance (of_complex (cor a)) (of_complex x) =\n     poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n    (Re x * a * a - 2 * a + Re x = 0)", "using x"], ["proof (prove)\nusing this:\n  of_complex (cor a) \\<in> unit_disc\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2)) =\n  (Re x * a * a - 2 * a + Re x = 0)\n  (arcosh\n    (1 +\n     2 * ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)))) =\n   arcosh (1 + 2 * a\\<^sup>2 / (1 - a\\<^sup>2))) =\n  ((a - Re x)\\<^sup>2 / ((1 - a\\<^sup>2) * (1 - (Re x)\\<^sup>2)) =\n   a\\<^sup>2 / (1 - a\\<^sup>2))\n  - 1 < Re x\n  Re x < 1\n  is_real x\n\ngoal (1 subgoal):\n 1. (poincare_distance (of_complex (cor a)) (of_complex x) =\n     poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n    (Re x * a * a - 2 * a + Re x = 0)", "by (auto simp add: poincare_distance_formula cmod_eq_Re)"], ["proof (state)\nthis:\n  (poincare_distance (of_complex (cor a)) (of_complex x) =\n   poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n  (Re x * a * a - 2 * a + Re x = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a.\n     - 1 < a \\<and> a < 1 \\<longrightarrow>\n     (poincare_distance (of_complex (cor a)) (of_complex x) =\n      poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n     (Re x * a * a - 2 * a + Re x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> 0\\<^sub>h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) 0\\<^sub>h", "show \"?P ?x 0\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. - 1 < Re ?a \\<and>\n    Re ?a < 1 \\<and>\n    is_real ?a \\<and>\n    poincare_distance (of_complex ?a) (of_complex x) =\n    poincare_distance (of_complex ?a) 0\\<^sub>h\n 2. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = ?a", "let ?a = \"(1 - sqrt(1 - (Re x)\\<^sup>2)) / (Re x)\""], ["proof (state)\ngoal (2 subgoals):\n 1. - 1 < Re ?a \\<and>\n    Re ?a < 1 \\<and>\n    is_real ?a \\<and>\n    poincare_distance (of_complex ?a) (of_complex x) =\n    poincare_distance (of_complex ?a) 0\\<^sub>h\n 2. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = ?a", "let ?b = \"(1 + sqrt(1 - (Re x)\\<^sup>2)) / (Re x)\""], ["proof (state)\ngoal (2 subgoals):\n 1. - 1 < Re ?a \\<and>\n    Re ?a < 1 \\<and>\n    is_real ?a \\<and>\n    poincare_distance (of_complex ?a) (of_complex x) =\n    poincare_distance (of_complex ?a) 0\\<^sub>h\n 2. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = ?a", "have \"is_real ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x))", "by simp"], ["proof (state)\nthis:\n  is_real (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x))\n\ngoal (2 subgoals):\n 1. - 1 < Re ?a \\<and>\n    Re ?a < 1 \\<and>\n    is_real ?a \\<and>\n    poincare_distance (of_complex ?a) (of_complex x) =\n    poincare_distance (of_complex ?a) 0\\<^sub>h\n 2. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = ?a", "moreover"], ["proof (state)\nthis:\n  is_real (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x))\n\ngoal (2 subgoals):\n 1. - 1 < Re ?a \\<and>\n    Re ?a < 1 \\<and>\n    is_real ?a \\<and>\n    poincare_distance (of_complex ?a) (of_complex x) =\n    poincare_distance (of_complex ?a) 0\\<^sub>h\n 2. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = ?a", "have \"1 - (Re x)\\<^sup>2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 - (Re x)\\<^sup>2", "using x"], ["proof (prove)\nusing this:\n  - 1 < Re x\n  Re x < 1\n  is_real x\n\ngoal (1 subgoal):\n 1. 0 < 1 - (Re x)\\<^sup>2", "by (smt power2_eq_1_iff square_le_1)"], ["proof (state)\nthis:\n  0 < 1 - (Re x)\\<^sup>2\n\ngoal (2 subgoals):\n 1. - 1 < Re ?a \\<and>\n    Re ?a < 1 \\<and>\n    is_real ?a \\<and>\n    poincare_distance (of_complex ?a) (of_complex x) =\n    poincare_distance (of_complex ?a) 0\\<^sub>h\n 2. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = ?a", "have \"\\<bar>?a\\<bar> < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "proof (cases \"Re x > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1\n 2. \\<not> 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "case True"], ["proof (state)\nthis:\n  0 < Re x\n\ngoal (2 subgoals):\n 1. 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1\n 2. \\<not> 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "have \"(1 - Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2", "using \\<open>Re x > 0\\<close> x"], ["proof (prove)\nusing this:\n  0 < Re x\n  - 1 < Re x\n  Re x < 1\n  is_real x\n\ngoal (1 subgoal):\n 1. (1 - Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2", "by (simp add: power2_eq_square field_simps)"], ["proof (state)\nthis:\n  (1 - Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n\ngoal (2 subgoals):\n 1. 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1\n 2. \\<not> 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "hence \"1 - Re x < sqrt (1 - (Re x)\\<^sup>2)\""], ["proof (prove)\nusing this:\n  (1 - Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. 1 - Re x < sqrt (1 - (Re x)\\<^sup>2)", "using real_less_rsqrt"], ["proof (prove)\nusing this:\n  (1 - Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n  ?x\\<^sup>2 < ?y \\<Longrightarrow> ?x < sqrt ?y\n\ngoal (1 subgoal):\n 1. 1 - Re x < sqrt (1 - (Re x)\\<^sup>2)", "by fastforce"], ["proof (state)\nthis:\n  1 - Re x < sqrt (1 - (Re x)\\<^sup>2)\n\ngoal (2 subgoals):\n 1. 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1\n 2. \\<not> 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 - Re x < sqrt (1 - (Re x)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "using \\<open>1 - (Re x)\\<^sup>2 > 0\\<close> \\<open>Re x > 0\\<close>"], ["proof (prove)\nusing this:\n  1 - Re x < sqrt (1 - (Re x)\\<^sup>2)\n  0 < 1 - (Re x)\\<^sup>2\n  0 < Re x\n\ngoal (1 subgoal):\n 1. \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "by simp"], ["proof (state)\nthis:\n  \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < Re x\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "hence \"Re x < 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < Re x\n\ngoal (1 subgoal):\n 1. Re x < 0", "using \\<open>Re x \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> 0 < Re x\n  Re x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re x < 0", "by simp"], ["proof (state)\nthis:\n  Re x < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "have \"1 + Re x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 + Re x", "using \\<open>Re x > -1\\<close>"], ["proof (prove)\nusing this:\n  - 1 < Re x\n\ngoal (1 subgoal):\n 1. 0 < 1 + Re x", "by simp"], ["proof (state)\nthis:\n  0 < 1 + Re x\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "hence \"2*Re x + 2*Re x*Re x < 0\""], ["proof (prove)\nusing this:\n  0 < 1 + Re x\n\ngoal (1 subgoal):\n 1. 2 * Re x + 2 * Re x * Re x < 0", "using \\<open>Re x < 0\\<close>"], ["proof (prove)\nusing this:\n  0 < 1 + Re x\n  Re x < 0\n\ngoal (1 subgoal):\n 1. 2 * Re x + 2 * Re x * Re x < 0", "by (metis comm_semiring_class.distrib mult.commute mult_2_right mult_less_0_iff one_add_one zero_less_double_add_iff_zero_less_single_add)"], ["proof (state)\nthis:\n  2 * Re x + 2 * Re x * Re x < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "hence \"(1 + Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2\""], ["proof (prove)\nusing this:\n  2 * Re x + 2 * Re x * Re x < 0\n\ngoal (1 subgoal):\n 1. (1 + Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2", "by (simp add: power2_eq_square field_simps)"], ["proof (state)\nthis:\n  (1 + Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "hence \"1 + Re x < sqrt (1 - (Re x)\\<^sup>2)\""], ["proof (prove)\nusing this:\n  (1 + Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. 1 + Re x < sqrt (1 - (Re x)\\<^sup>2)", "using \\<open>1 - (Re x)\\<^sup>2 > 0\\<close>"], ["proof (prove)\nusing this:\n  (1 + Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n  0 < 1 - (Re x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. 1 + Re x < sqrt (1 - (Re x)\\<^sup>2)", "using real_less_rsqrt"], ["proof (prove)\nusing this:\n  (1 + Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n  0 < 1 - (Re x)\\<^sup>2\n  ?x\\<^sup>2 < ?y \\<Longrightarrow> ?x < sqrt ?y\n\ngoal (1 subgoal):\n 1. 1 + Re x < sqrt (1 - (Re x)\\<^sup>2)", "by blast"], ["proof (state)\nthis:\n  1 + Re x < sqrt (1 - (Re x)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 + Re x < sqrt (1 - (Re x)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "using \\<open>Re x < 0\\<close>"], ["proof (prove)\nusing this:\n  1 + Re x < sqrt (1 - (Re x)\\<^sup>2)\n  Re x < 0\n\ngoal (1 subgoal):\n 1. \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1\n\ngoal (2 subgoals):\n 1. - 1 < Re ?a \\<and>\n    Re ?a < 1 \\<and>\n    is_real ?a \\<and>\n    poincare_distance (of_complex ?a) (of_complex x) =\n    poincare_distance (of_complex ?a) 0\\<^sub>h\n 2. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = ?a", "hence \"-1 < ?a\" \"?a < 1\""], ["proof (prove)\nusing this:\n  \\<bar>(1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar> < 1\n\ngoal (1 subgoal):\n 1. - 1 < (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x &&&\n    (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x < 1", "by linarith+"], ["proof (state)\nthis:\n  - 1 < (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x < 1\n\ngoal (2 subgoals):\n 1. - 1 < Re ?a \\<and>\n    Re ?a < 1 \\<and>\n    is_real ?a \\<and>\n    poincare_distance (of_complex ?a) (of_complex x) =\n    poincare_distance (of_complex ?a) 0\\<^sub>h\n 2. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = ?a", "moreover"], ["proof (state)\nthis:\n  - 1 < (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x < 1\n\ngoal (2 subgoals):\n 1. - 1 < Re ?a \\<and>\n    Re ?a < 1 \\<and>\n    is_real ?a \\<and>\n    poincare_distance (of_complex ?a) (of_complex x) =\n    poincare_distance (of_complex ?a) 0\\<^sub>h\n 2. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = ?a", "have \"(Re x) * ?a * ?a - 2 * ?a + Re x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re x * ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) *\n    ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) -\n    2 * ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) +\n    Re x =\n    0", "using \\<open>Re x \\<noteq> 0\\<close> \\<open>1 - (Re x)\\<^sup>2 > 0\\<close>"], ["proof (prove)\nusing this:\n  Re x \\<noteq> 0\n  0 < 1 - (Re x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. Re x * ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) *\n    ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) -\n    2 * ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) +\n    Re x =\n    0", "by (simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  Re x * ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) *\n  ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) -\n  2 * ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) +\n  Re x =\n  0\n\ngoal (2 subgoals):\n 1. - 1 < Re ?a \\<and>\n    Re ?a < 1 \\<and>\n    is_real ?a \\<and>\n    poincare_distance (of_complex ?a) (of_complex x) =\n    poincare_distance (of_complex ?a) 0\\<^sub>h\n 2. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = ?a", "ultimately"], ["proof (chain)\npicking this:\n  is_real (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x))\n  - 1 < (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x < 1\n  Re x * ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) *\n  ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) -\n  2 * ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) +\n  Re x =\n  0", "show \"-1 < Re (cor ?a) \\<and> Re (cor ?a) < 1 \\<and> is_real ?a \\<and> poincare_distance (of_complex ?a) (of_complex x) = poincare_distance (of_complex ?a) 0\\<^sub>h\""], ["proof (prove)\nusing this:\n  is_real (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x))\n  - 1 < (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x < 1\n  Re x * ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) *\n  ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) -\n  2 * ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) +\n  Re x =\n  0\n\ngoal (1 subgoal):\n 1. - 1 < Re (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)) \\<and>\n    Re (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)) < 1 \\<and>\n    is_real (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)) \\<and>\n    poincare_distance\n     (of_complex (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)))\n     (of_complex x) =\n    poincare_distance\n     (of_complex (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x))) 0\\<^sub>h", "using *"], ["proof (prove)\nusing this:\n  is_real (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x))\n  - 1 < (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x < 1\n  Re x * ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) *\n  ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) -\n  2 * ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x) +\n  Re x =\n  0\n  \\<forall>a.\n     - 1 < a \\<and> a < 1 \\<longrightarrow>\n     (poincare_distance (of_complex (cor a)) (of_complex x) =\n      poincare_distance (of_complex (cor a)) 0\\<^sub>h) =\n     (Re x * a * a - 2 * a + Re x = 0)\n\ngoal (1 subgoal):\n 1. - 1 < Re (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)) \\<and>\n    Re (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)) < 1 \\<and>\n    is_real (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)) \\<and>\n    poincare_distance\n     (of_complex (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)))\n     (of_complex x) =\n    poincare_distance\n     (of_complex (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x))) 0\\<^sub>h", "by auto"], ["proof (state)\nthis:\n  - 1 < Re (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)) \\<and>\n  Re (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)) < 1 \\<and>\n  is_real (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)) \\<and>\n  poincare_distance\n   (of_complex (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)))\n   (of_complex x) =\n  poincare_distance\n   (of_complex (cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x))) 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "assume **: \"- 1 < Re z \\<and> Re z < 1 \\<and> is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) = poincare_distance (of_complex z) 0\\<^sub>h\""], ["proof (state)\nthis:\n  - 1 < Re z \\<and>\n  Re z < 1 \\<and>\n  is_real z \\<and>\n  poincare_distance (of_complex z) (of_complex x) =\n  poincare_distance (of_complex z) 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "hence \"Re x * Re z * Re z - 2 * Re z + Re x = 0\""], ["proof (prove)\nusing this:\n  - 1 < Re z \\<and>\n  Re z < 1 \\<and>\n  is_real z \\<and>\n  poincare_distance (of_complex z) (of_complex x) =\n  poincare_distance (of_complex z) 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. Re x * Re z * Re z - 2 * Re z + Re x = 0", "using *[rule_format, of \"Re z\"] x"], ["proof (prove)\nusing this:\n  - 1 < Re z \\<and>\n  Re z < 1 \\<and>\n  is_real z \\<and>\n  poincare_distance (of_complex z) (of_complex x) =\n  poincare_distance (of_complex z) 0\\<^sub>h\n  - 1 < Re z \\<and> Re z < 1 \\<Longrightarrow>\n  (poincare_distance (of_complex (cor (Re z))) (of_complex x) =\n   poincare_distance (of_complex (cor (Re z))) 0\\<^sub>h) =\n  (Re x * Re z * Re z - 2 * Re z + Re x = 0)\n  - 1 < Re x\n  Re x < 1\n  is_real x\n\ngoal (1 subgoal):\n 1. Re x * Re z * Re z - 2 * Re z + Re x = 0", "by auto"], ["proof (state)\nthis:\n  Re x * Re z * Re z - 2 * Re z + Re x = 0\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "moreover"], ["proof (state)\nthis:\n  Re x * Re z * Re z - 2 * Re z + Re x = 0\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "have \"sqrt (4 - 4 * Re x * Re x) = 2 * sqrt(1 - Re x * Re x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (4 - 4 * Re x * Re x) = 2 * sqrt (1 - Re x * Re x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sqrt (4 - 4 * Re x * Re x) = 2 * sqrt (1 - Re x * Re x)", "have \"sqrt (4 - 4 * Re x * Re x) = sqrt(4 * (1 - Re x * Re x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (4 - 4 * Re x * Re x) = sqrt (4 * (1 - Re x * Re x))", "by simp"], ["proof (state)\nthis:\n  sqrt (4 - 4 * Re x * Re x) = sqrt (4 * (1 - Re x * Re x))\n\ngoal (1 subgoal):\n 1. sqrt (4 - 4 * Re x * Re x) = 2 * sqrt (1 - Re x * Re x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sqrt (4 - 4 * Re x * Re x) = sqrt (4 * (1 - Re x * Re x))\n\ngoal (1 subgoal):\n 1. sqrt (4 - 4 * Re x * Re x) = 2 * sqrt (1 - Re x * Re x)", "by (simp only: real_sqrt_mult, simp)"], ["proof (state)\nthis:\n  sqrt (4 - 4 * Re x * Re x) = 2 * sqrt (1 - Re x * Re x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sqrt (4 - 4 * Re x * Re x) = 2 * sqrt (1 - Re x * Re x)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "moreover"], ["proof (state)\nthis:\n  sqrt (4 - 4 * Re x * Re x) = 2 * sqrt (1 - Re x * Re x)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "have \"(2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) = ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n    (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n    (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x", "have \"(2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) = \n               (2 * (1 - sqrt (1 - Re x * Re x))) / (2 * Re x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n    2 * (1 - sqrt (1 - Re x * Re x)) / (2 * Re x)", "by simp"], ["proof (state)\nthis:\n  (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  2 * (1 - sqrt (1 - Re x * Re x)) / (2 * Re x)\n\ngoal (1 subgoal):\n 1. (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n    (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x", "thus ?thesis"], ["proof (prove)\nusing this:\n  (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  2 * (1 - sqrt (1 - Re x * Re x)) / (2 * Re x)\n\ngoal (1 subgoal):\n 1. (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n    (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x", "by (subst (asm) mult_divide_mult_cancel_left) (auto simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "moreover"], ["proof (state)\nthis:\n  (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "have \"(2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) = ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n    (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n    (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x", "have \"(2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) = \n               (2 * (1 + sqrt (1 - Re x * Re x))) / (2 * Re x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n    2 * (1 + sqrt (1 - Re x * Re x)) / (2 * Re x)", "by simp"], ["proof (state)\nthis:\n  (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  2 * (1 + sqrt (1 - Re x * Re x)) / (2 * Re x)\n\ngoal (1 subgoal):\n 1. (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n    (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x", "thus ?thesis"], ["proof (prove)\nusing this:\n  (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  2 * (1 + sqrt (1 - Re x * Re x)) / (2 * Re x)\n\ngoal (1 subgoal):\n 1. (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n    (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x", "by (subst (asm) mult_divide_mult_cancel_left) (auto simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "ultimately"], ["proof (chain)\npicking this:\n  Re x * Re z * Re z - 2 * Re z + Re x = 0\n  sqrt (4 - 4 * Re x * Re x) = 2 * sqrt (1 - Re x * Re x)\n  (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x", "have \"Re z = ?a \\<or> Re z = ?b\""], ["proof (prove)\nusing this:\n  Re x * Re z * Re z - 2 * Re z + Re x = 0\n  sqrt (4 - 4 * Re x * Re x) = 2 * sqrt (1 - Re x * Re x)\n  (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\n\ngoal (1 subgoal):\n 1. Re z = (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x \\<or>\n    Re z = (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x", "using discriminant_nonneg[of \"Re x\" \"-2\" \"Re x\" \"Re z\"] discrim_def[of \"Re x\" \"-2\" \"Re x\"]"], ["proof (prove)\nusing this:\n  Re x * Re z * Re z - 2 * Re z + Re x = 0\n  sqrt (4 - 4 * Re x * Re x) = 2 * sqrt (1 - Re x * Re x)\n  (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  \\<lbrakk>Re x \\<noteq> 0; 0 \\<le> discrim (Re x) (- 2) (Re x)\\<rbrakk>\n  \\<Longrightarrow> (Re x * (Re z)\\<^sup>2 + - 2 * Re z + Re x = 0) =\n                    (Re z =\n                     (- (- 2) + sqrt (discrim (Re x) (- 2) (Re x))) /\n                     (2 * Re x) \\<or>\n                     Re z =\n                     (- (- 2) - sqrt (discrim (Re x) (- 2) (Re x))) /\n                     (2 * Re x))\n  discrim (Re x) (- 2) (Re x) \\<equiv> (- 2)\\<^sup>2 - 4 * Re x * Re x\n\ngoal (1 subgoal):\n 1. Re z = (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x \\<or>\n    Re z = (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x", "using \\<open>Re x \\<noteq> 0\\<close> \\<open>-1 < Re x\\<close> \\<open>Re x < 1\\<close> \\<open>1 - (Re x)\\<^sup>2 > 0\\<close>"], ["proof (prove)\nusing this:\n  Re x * Re z * Re z - 2 * Re z + Re x = 0\n  sqrt (4 - 4 * Re x * Re x) = 2 * sqrt (1 - Re x * Re x)\n  (2 - 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  (2 + 2 * sqrt (1 - Re x * Re x)) / (2 * Re x) =\n  (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  \\<lbrakk>Re x \\<noteq> 0; 0 \\<le> discrim (Re x) (- 2) (Re x)\\<rbrakk>\n  \\<Longrightarrow> (Re x * (Re z)\\<^sup>2 + - 2 * Re z + Re x = 0) =\n                    (Re z =\n                     (- (- 2) + sqrt (discrim (Re x) (- 2) (Re x))) /\n                     (2 * Re x) \\<or>\n                     Re z =\n                     (- (- 2) - sqrt (discrim (Re x) (- 2) (Re x))) /\n                     (2 * Re x))\n  discrim (Re x) (- 2) (Re x) \\<equiv> (- 2)\\<^sup>2 - 4 * Re x * Re x\n  Re x \\<noteq> 0\n  - 1 < Re x\n  Re x < 1\n  0 < 1 - (Re x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. Re z = (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x \\<or>\n    Re z = (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x", "by (auto simp add:power2_eq_square)"], ["proof (state)\nthis:\n  Re z = (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x \\<or>\n  Re z = (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "have \"\\<bar>?b\\<bar> > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "proof (cases \"Re x > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>\n 2. \\<not> 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "case True"], ["proof (state)\nthis:\n  0 < Re x\n\ngoal (2 subgoals):\n 1. 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>\n 2. \\<not> 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "have \"(Re x - 1)\\<^sup>2 < 1 - (Re x)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re x - 1)\\<^sup>2 < 1 - (Re x)\\<^sup>2", "using \\<open>Re x > 0\\<close> x"], ["proof (prove)\nusing this:\n  0 < Re x\n  - 1 < Re x\n  Re x < 1\n  is_real x\n\ngoal (1 subgoal):\n 1. (Re x - 1)\\<^sup>2 < 1 - (Re x)\\<^sup>2", "by (simp add: power2_eq_square field_simps)"], ["proof (state)\nthis:\n  (Re x - 1)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n\ngoal (2 subgoals):\n 1. 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>\n 2. \\<not> 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "hence \"Re x - 1 < sqrt (1 - (Re x)\\<^sup>2)\""], ["proof (prove)\nusing this:\n  (Re x - 1)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. Re x - 1 < sqrt (1 - (Re x)\\<^sup>2)", "using real_less_rsqrt"], ["proof (prove)\nusing this:\n  (Re x - 1)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n  ?x\\<^sup>2 < ?y \\<Longrightarrow> ?x < sqrt ?y\n\ngoal (1 subgoal):\n 1. Re x - 1 < sqrt (1 - (Re x)\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  Re x - 1 < sqrt (1 - (Re x)\\<^sup>2)\n\ngoal (2 subgoals):\n 1. 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>\n 2. \\<not> 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "thus ?thesis"], ["proof (prove)\nusing this:\n  Re x - 1 < sqrt (1 - (Re x)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "using \\<open>1 - (Re x)\\<^sup>2 > 0\\<close> \\<open>Re x > 0\\<close>"], ["proof (prove)\nusing this:\n  Re x - 1 < sqrt (1 - (Re x)\\<^sup>2)\n  0 < 1 - (Re x)\\<^sup>2\n  0 < Re x\n\ngoal (1 subgoal):\n 1. 1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "by simp"], ["proof (state)\nthis:\n  1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < Re x\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "hence \"Re x < 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < Re x\n\ngoal (1 subgoal):\n 1. Re x < 0", "using \\<open>Re x \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> 0 < Re x\n  Re x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re x < 0", "by simp"], ["proof (state)\nthis:\n  Re x < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "have \"1 + Re x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 + Re x", "using \\<open>Re x > -1\\<close>"], ["proof (prove)\nusing this:\n  - 1 < Re x\n\ngoal (1 subgoal):\n 1. 0 < 1 + Re x", "by simp"], ["proof (state)\nthis:\n  0 < 1 + Re x\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "hence \"2*Re x + 2*Re x*Re x < 0\""], ["proof (prove)\nusing this:\n  0 < 1 + Re x\n\ngoal (1 subgoal):\n 1. 2 * Re x + 2 * Re x * Re x < 0", "using \\<open>Re x < 0\\<close>"], ["proof (prove)\nusing this:\n  0 < 1 + Re x\n  Re x < 0\n\ngoal (1 subgoal):\n 1. 2 * Re x + 2 * Re x * Re x < 0", "by (metis comm_semiring_class.distrib mult.commute mult_2_right mult_less_0_iff one_add_one zero_less_double_add_iff_zero_less_single_add)"], ["proof (state)\nthis:\n  2 * Re x + 2 * Re x * Re x < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "hence \"1 - (Re x)\\<^sup>2 > (- 1 - (Re x))\\<^sup>2\""], ["proof (prove)\nusing this:\n  2 * Re x + 2 * Re x * Re x < 0\n\ngoal (1 subgoal):\n 1. (- 1 - Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2", "by (simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  (- 1 - Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "hence \"sqrt (1 - (Re x)\\<^sup>2) > -1 - Re x\""], ["proof (prove)\nusing this:\n  (- 1 - Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. - 1 - Re x < sqrt (1 - (Re x)\\<^sup>2)", "using real_less_rsqrt"], ["proof (prove)\nusing this:\n  (- 1 - Re x)\\<^sup>2 < 1 - (Re x)\\<^sup>2\n  ?x\\<^sup>2 < ?y \\<Longrightarrow> ?x < sqrt ?y\n\ngoal (1 subgoal):\n 1. - 1 - Re x < sqrt (1 - (Re x)\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  - 1 - Re x < sqrt (1 - (Re x)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "thus ?thesis"], ["proof (prove)\nusing this:\n  - 1 - Re x < sqrt (1 - (Re x)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "using \\<open>Re x < 0\\<close>"], ["proof (prove)\nusing this:\n  - 1 - Re x < sqrt (1 - (Re x)\\<^sup>2)\n  Re x < 0\n\ngoal (1 subgoal):\n 1. 1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "hence \"?b < -1 \\<or> ?b > 1\""], ["proof (prove)\nusing this:\n  1 < \\<bar>(1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\\<bar>\n\ngoal (1 subgoal):\n 1. (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x < - 1 \\<or>\n    1 < (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x", "by auto"], ["proof (state)\nthis:\n  (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x < - 1 \\<or>\n  1 < (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "hence \"Re z = ?a\""], ["proof (prove)\nusing this:\n  (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x < - 1 \\<or>\n  1 < (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\n\ngoal (1 subgoal):\n 1. Re z = (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x", "using \\<open>Re z = ?a \\<or> Re z = ?b\\<close> **"], ["proof (prove)\nusing this:\n  (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x < - 1 \\<or>\n  1 < (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  Re z = (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x \\<or>\n  Re z = (1 + sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  - 1 < Re z \\<and>\n  Re z < 1 \\<and>\n  is_real z \\<and>\n  poincare_distance (of_complex z) (of_complex x) =\n  poincare_distance (of_complex z) 0\\<^sub>h\n\ngoal (1 subgoal):\n 1. Re z = (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x", "by auto"], ["proof (state)\nthis:\n  Re z = (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) 0\\<^sub>h \\<Longrightarrow>\n       z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "thus \"z = ?a\""], ["proof (prove)\nusing this:\n  Re z = (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n\ngoal (1 subgoal):\n 1. z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "using ** complex_of_real_Re"], ["proof (prove)\nusing this:\n  Re z = (1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x\n  - 1 < Re z \\<and>\n  Re z < 1 \\<and>\n  is_real z \\<and>\n  poincare_distance (of_complex z) (of_complex x) =\n  poincare_distance (of_complex z) 0\\<^sub>h\n  is_real ?k \\<Longrightarrow> cor (Re ?k) = ?k\n\ngoal (1 subgoal):\n 1. z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)", "by fastforce"], ["proof (state)\nthis:\n  z = cor ((1 - sqrt (1 - (Re x)\\<^sup>2)) / Re x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!z.\n     - 1 < Re z \\<and>\n     Re z < 1 \\<and>\n     is_real z \\<and>\n     poincare_distance (of_complex z) (of_complex x) =\n     poincare_distance (of_complex z) 0\\<^sub>h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     - 1 < Re x \\<and>\n     Re x < 1 \\<and>\n     is_real x \\<and> of_complex x \\<noteq> 0\\<^sub>h \\<longrightarrow>\n     (\\<exists>!z.\n         - 1 < Re z \\<and>\n         Re z < 1 \\<and>\n         is_real z \\<and>\n         poincare_distance (of_complex z) (of_complex x) =\n         poincare_distance (of_complex z) 0\\<^sub>h)\n\ngoal (1 subgoal):\n 1. \\<And>a u.\n       \\<lbrakk>u \\<in> unit_disc; is_real a; cmod a < 1;\n        \\<forall>x.\n           - 1 < Re x \\<and>\n           Re x < 1 \\<and>\n           is_real x \\<and>\n           of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n           (\\<exists>!z.\n               - 1 < Re z \\<and>\n               Re z < 1 \\<and>\n               is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) =\n               poincare_distance (of_complex z)\n                (moebius_pt (blaschke a) u))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            - 1 < Re x \\<and>\n                            Re x < 1 \\<and>\n                            is_real x \\<and>\n                            of_complex x \\<noteq> u \\<longrightarrow>\n                            (\\<exists>!z.\n                                - 1 < Re z \\<and>\n                                Re z < 1 \\<and>\n                                is_real z \\<and>\n                                poincare_distance (of_complex z)\n                                 (of_complex x) =\n                                poincare_distance (of_complex z) u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a u.\n       \\<lbrakk>u \\<in> unit_disc; is_real a; cmod a < 1;\n        \\<forall>x.\n           - 1 < Re x \\<and>\n           Re x < 1 \\<and>\n           is_real x \\<and>\n           of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n           (\\<exists>!z.\n               - 1 < Re z \\<and>\n               Re z < 1 \\<and>\n               is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) =\n               poincare_distance (of_complex z)\n                (moebius_pt (blaschke a) u))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            - 1 < Re x \\<and>\n                            Re x < 1 \\<and>\n                            is_real x \\<and>\n                            of_complex x \\<noteq> u \\<longrightarrow>\n                            (\\<exists>!z.\n                                - 1 < Re z \\<and>\n                                Re z < 1 \\<and>\n                                is_real z \\<and>\n                                poincare_distance (of_complex z)\n                                 (of_complex x) =\n                                poincare_distance (of_complex z) u)", "fix a u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a u.\n       \\<lbrakk>u \\<in> unit_disc; is_real a; cmod a < 1;\n        \\<forall>x.\n           - 1 < Re x \\<and>\n           Re x < 1 \\<and>\n           is_real x \\<and>\n           of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n           (\\<exists>!z.\n               - 1 < Re z \\<and>\n               Re z < 1 \\<and>\n               is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) =\n               poincare_distance (of_complex z)\n                (moebius_pt (blaschke a) u))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            - 1 < Re x \\<and>\n                            Re x < 1 \\<and>\n                            is_real x \\<and>\n                            of_complex x \\<noteq> u \\<longrightarrow>\n                            (\\<exists>!z.\n                                - 1 < Re z \\<and>\n                                Re z < 1 \\<and>\n                                is_real z \\<and>\n                                poincare_distance (of_complex z)\n                                 (of_complex x) =\n                                poincare_distance (of_complex z) u)", "let ?M = \"moebius_pt (blaschke a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a u.\n       \\<lbrakk>u \\<in> unit_disc; is_real a; cmod a < 1;\n        \\<forall>x.\n           - 1 < Re x \\<and>\n           Re x < 1 \\<and>\n           is_real x \\<and>\n           of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n           (\\<exists>!z.\n               - 1 < Re z \\<and>\n               Re z < 1 \\<and>\n               is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) =\n               poincare_distance (of_complex z)\n                (moebius_pt (blaschke a) u))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            - 1 < Re x \\<and>\n                            Re x < 1 \\<and>\n                            is_real x \\<and>\n                            of_complex x \\<noteq> u \\<longrightarrow>\n                            (\\<exists>!z.\n                                - 1 < Re z \\<and>\n                                Re z < 1 \\<and>\n                                is_real z \\<and>\n                                poincare_distance (of_complex z)\n                                 (of_complex x) =\n                                poincare_distance (of_complex z) u)", "let ?Mu = \"?M u\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a u.\n       \\<lbrakk>u \\<in> unit_disc; is_real a; cmod a < 1;\n        \\<forall>x.\n           - 1 < Re x \\<and>\n           Re x < 1 \\<and>\n           is_real x \\<and>\n           of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n           (\\<exists>!z.\n               - 1 < Re z \\<and>\n               Re z < 1 \\<and>\n               is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) =\n               poincare_distance (of_complex z)\n                (moebius_pt (blaschke a) u))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            - 1 < Re x \\<and>\n                            Re x < 1 \\<and>\n                            is_real x \\<and>\n                            of_complex x \\<noteq> u \\<longrightarrow>\n                            (\\<exists>!z.\n                                - 1 < Re z \\<and>\n                                Re z < 1 \\<and>\n                                is_real z \\<and>\n                                poincare_distance (of_complex z)\n                                 (of_complex x) =\n                                poincare_distance (of_complex z) u)", "assume \"u \\<in> unit_disc\" \"is_real a\" \"cmod a < 1\""], ["proof (state)\nthis:\n  u \\<in> unit_disc\n  is_real a\n  cmod a < 1\n\ngoal (1 subgoal):\n 1. \\<And>a u.\n       \\<lbrakk>u \\<in> unit_disc; is_real a; cmod a < 1;\n        \\<forall>x.\n           - 1 < Re x \\<and>\n           Re x < 1 \\<and>\n           is_real x \\<and>\n           of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n           (\\<exists>!z.\n               - 1 < Re z \\<and>\n               Re z < 1 \\<and>\n               is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) =\n               poincare_distance (of_complex z)\n                (moebius_pt (blaschke a) u))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            - 1 < Re x \\<and>\n                            Re x < 1 \\<and>\n                            is_real x \\<and>\n                            of_complex x \\<noteq> u \\<longrightarrow>\n                            (\\<exists>!z.\n                                - 1 < Re z \\<and>\n                                Re z < 1 \\<and>\n                                is_real z \\<and>\n                                poincare_distance (of_complex z)\n                                 (of_complex x) =\n                                poincare_distance (of_complex z) u)", "assume *: \"?Q ?Mu\""], ["proof (state)\nthis:\n  \\<forall>x.\n     - 1 < Re x \\<and>\n     Re x < 1 \\<and>\n     is_real x \\<and>\n     of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n     (\\<exists>!z.\n         - 1 < Re z \\<and>\n         Re z < 1 \\<and>\n         is_real z \\<and>\n         poincare_distance (of_complex z) (of_complex x) =\n         poincare_distance (of_complex z) (moebius_pt (blaschke a) u))\n\ngoal (1 subgoal):\n 1. \\<And>a u.\n       \\<lbrakk>u \\<in> unit_disc; is_real a; cmod a < 1;\n        \\<forall>x.\n           - 1 < Re x \\<and>\n           Re x < 1 \\<and>\n           is_real x \\<and>\n           of_complex x \\<noteq> moebius_pt (blaschke a) u \\<longrightarrow>\n           (\\<exists>!z.\n               - 1 < Re z \\<and>\n               Re z < 1 \\<and>\n               is_real z \\<and>\n               poincare_distance (of_complex z) (of_complex x) =\n               poincare_distance (of_complex z)\n                (moebius_pt (blaschke a) u))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            - 1 < Re x \\<and>\n                            Re x < 1 \\<and>\n                            is_real x \\<and>\n                            of_complex x \\<noteq> u \\<longrightarrow>\n                            (\\<exists>!z.\n                                - 1 < Re z \\<and>\n                                Re z < 1 \\<and>\n                                is_real z \\<and>\n                                poincare_distance (of_complex z)\n                                 (of_complex x) =\n                                poincare_distance (of_complex z) u)", "show \"?Q u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       - 1 < Re x \\<and>\n       Re x < 1 \\<and>\n       is_real x \\<and> of_complex x \\<noteq> u \\<longrightarrow>\n       (\\<exists>!z.\n           - 1 < Re z \\<and>\n           Re z < 1 \\<and>\n           is_real z \\<and>\n           poincare_distance (of_complex z) (of_complex x) =\n           poincare_distance (of_complex z) u)", "proof (rule allI, rule impI, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "assume x: \"-1 < Re x\" \"Re x < 1\" \"is_real x\" \"of_complex x \\<noteq> u\""], ["proof (state)\nthis:\n  - 1 < Re x\n  Re x < 1\n  is_real x\n  of_complex x \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "let ?Mx = \"?M (of_complex x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "have \"of_complex x \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex x \\<in> unit_disc", "using x cmod_eq_Re"], ["proof (prove)\nusing this:\n  - 1 < Re x\n  Re x < 1\n  is_real x\n  of_complex x \\<noteq> u\n  is_real ?z \\<Longrightarrow> cmod ?z = \\<bar>Re ?z\\<bar>\n\ngoal (1 subgoal):\n 1. of_complex x \\<in> unit_disc", "by auto"], ["proof (state)\nthis:\n  of_complex x \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "hence \"?Mx \\<in> unit_disc\""], ["proof (prove)\nusing this:\n  of_complex x \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex x) \\<in> unit_disc", "using \\<open>is_real a\\<close> \\<open>cmod a < 1\\<close> blaschke_unit_disc_fix[of a]"], ["proof (prove)\nusing this:\n  of_complex x \\<in> unit_disc\n  is_real a\n  cmod a < 1\n  cmod a < 1 \\<Longrightarrow> unit_disc_fix (blaschke a)\n\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex x) \\<in> unit_disc", "using unit_disc_fix_discI"], ["proof (prove)\nusing this:\n  of_complex x \\<in> unit_disc\n  is_real a\n  cmod a < 1\n  cmod a < 1 \\<Longrightarrow> unit_disc_fix (blaschke a)\n  \\<lbrakk>unit_disc_fix ?M; ?u \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> moebius_pt ?M ?u \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex x) \\<in> unit_disc", "by blast"], ["proof (state)\nthis:\n  moebius_pt (blaschke a) (of_complex x) \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "hence \"?Mx \\<noteq> \\<infinity>\\<^sub>h\""], ["proof (prove)\nusing this:\n  moebius_pt (blaschke a) (of_complex x) \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex x) \\<noteq> \\<infinity>\\<^sub>h", "by auto"], ["proof (state)\nthis:\n  moebius_pt (blaschke a) (of_complex x) \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "moreover"], ["proof (state)\nthis:\n  moebius_pt (blaschke a) (of_complex x) \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "have \"of_complex x \\<in> circline_set x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex x \\<in> circline_set x_axis", "using x"], ["proof (prove)\nusing this:\n  - 1 < Re x\n  Re x < 1\n  is_real x\n  of_complex x \\<noteq> u\n\ngoal (1 subgoal):\n 1. of_complex x \\<in> circline_set x_axis", "by auto"], ["proof (state)\nthis:\n  of_complex x \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "hence \"?Mx \\<in> circline_set x_axis\""], ["proof (prove)\nusing this:\n  of_complex x \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex x) \\<in> circline_set x_axis", "using blaschke_real_preserve_x_axis[OF \\<open>is_real a\\<close> \\<open>cmod a < 1\\<close>, of \"of_complex x\"]"], ["proof (prove)\nusing this:\n  of_complex x \\<in> circline_set x_axis\n  (moebius_pt (blaschke a) (of_complex x) \\<in> circline_set x_axis) =\n  (of_complex x \\<in> circline_set x_axis)\n\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex x) \\<in> circline_set x_axis", "by auto"], ["proof (state)\nthis:\n  moebius_pt (blaschke a) (of_complex x) \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "hence \"-1 < Re (to_complex ?Mx) \\<and> Re (to_complex ?Mx) < 1 \\<and> is_real (to_complex ?Mx)\""], ["proof (prove)\nusing this:\n  moebius_pt (blaschke a) (of_complex x) \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex x))) \\<and>\n    Re (to_complex (moebius_pt (blaschke a) (of_complex x))) < 1 \\<and>\n    is_real (to_complex (moebius_pt (blaschke a) (of_complex x)))", "using \\<open>?Mx \\<noteq> \\<infinity>\\<^sub>h\\<close> \\<open>?Mx \\<in> unit_disc\\<close>"], ["proof (prove)\nusing this:\n  moebius_pt (blaschke a) (of_complex x) \\<in> circline_set x_axis\n  moebius_pt (blaschke a) (of_complex x) \\<noteq> \\<infinity>\\<^sub>h\n  moebius_pt (blaschke a) (of_complex x) \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex x))) \\<and>\n    Re (to_complex (moebius_pt (blaschke a) (of_complex x))) < 1 \\<and>\n    is_real (to_complex (moebius_pt (blaschke a) (of_complex x)))", "unfolding circline_set_x_axis"], ["proof (prove)\nusing this:\n  moebius_pt (blaschke a) (of_complex x)\n  \\<in> of_complex ` {x. is_real x} \\<union> {\\<infinity>\\<^sub>h}\n  moebius_pt (blaschke a) (of_complex x) \\<noteq> \\<infinity>\\<^sub>h\n  moebius_pt (blaschke a) (of_complex x) \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex x))) \\<and>\n    Re (to_complex (moebius_pt (blaschke a) (of_complex x))) < 1 \\<and>\n    is_real (to_complex (moebius_pt (blaschke a) (of_complex x)))", "by (auto simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex x))) \\<and>\n  Re (to_complex (moebius_pt (blaschke a) (of_complex x))) < 1 \\<and>\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex x)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "moreover"], ["proof (state)\nthis:\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex x))) \\<and>\n  Re (to_complex (moebius_pt (blaschke a) (of_complex x))) < 1 \\<and>\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex x)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "have \"?Mx \\<noteq> ?Mu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex x) \\<noteq>\n    moebius_pt (blaschke a) u", "using \\<open>of_complex x \\<noteq> u\\<close>"], ["proof (prove)\nusing this:\n  of_complex x \\<noteq> u\n\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex x) \\<noteq>\n    moebius_pt (blaschke a) u", "by simp"], ["proof (state)\nthis:\n  moebius_pt (blaschke a) (of_complex x) \\<noteq> moebius_pt (blaschke a) u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "ultimately"], ["proof (chain)\npicking this:\n  moebius_pt (blaschke a) (of_complex x) \\<noteq> \\<infinity>\\<^sub>h\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex x))) \\<and>\n  Re (to_complex (moebius_pt (blaschke a) (of_complex x))) < 1 \\<and>\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex x)))\n  moebius_pt (blaschke a) (of_complex x) \\<noteq> moebius_pt (blaschke a) u", "have \"?P ?Mx ?Mu\""], ["proof (prove)\nusing this:\n  moebius_pt (blaschke a) (of_complex x) \\<noteq> \\<infinity>\\<^sub>h\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex x))) \\<and>\n  Re (to_complex (moebius_pt (blaschke a) (of_complex x))) < 1 \\<and>\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex x)))\n  moebius_pt (blaschke a) (of_complex x) \\<noteq> moebius_pt (blaschke a) u\n\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z)\n        (moebius_pt (blaschke a) (of_complex x)) =\n       poincare_distance (of_complex z) (moebius_pt (blaschke a) u)", "using *[rule_format, of \"to_complex ?Mx\"] \\<open>?Mx \\<noteq> \\<infinity>\\<^sub>h\\<close>"], ["proof (prove)\nusing this:\n  moebius_pt (blaschke a) (of_complex x) \\<noteq> \\<infinity>\\<^sub>h\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex x))) \\<and>\n  Re (to_complex (moebius_pt (blaschke a) (of_complex x))) < 1 \\<and>\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex x)))\n  moebius_pt (blaschke a) (of_complex x) \\<noteq> moebius_pt (blaschke a) u\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex x))) \\<and>\n  Re (to_complex (moebius_pt (blaschke a) (of_complex x))) < 1 \\<and>\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex x))) \\<and>\n  of_complex (to_complex (moebius_pt (blaschke a) (of_complex x))) \\<noteq>\n  moebius_pt (blaschke a) u \\<Longrightarrow>\n  \\<exists>!z.\n     - 1 < Re z \\<and>\n     Re z < 1 \\<and>\n     is_real z \\<and>\n     poincare_distance (of_complex z)\n      (of_complex (to_complex (moebius_pt (blaschke a) (of_complex x)))) =\n     poincare_distance (of_complex z) (moebius_pt (blaschke a) u)\n  moebius_pt (blaschke a) (of_complex x) \\<noteq> \\<infinity>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z)\n        (moebius_pt (blaschke a) (of_complex x)) =\n       poincare_distance (of_complex z) (moebius_pt (blaschke a) u)", "by simp"], ["proof (state)\nthis:\n  \\<exists>!z.\n     - 1 < Re z \\<and>\n     Re z < 1 \\<and>\n     is_real z \\<and>\n     poincare_distance (of_complex z)\n      (moebius_pt (blaschke a) (of_complex x)) =\n     poincare_distance (of_complex z) (moebius_pt (blaschke a) u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "then"], ["proof (chain)\npicking this:\n  \\<exists>!z.\n     - 1 < Re z \\<and>\n     Re z < 1 \\<and>\n     is_real z \\<and>\n     poincare_distance (of_complex z)\n      (moebius_pt (blaschke a) (of_complex x)) =\n     poincare_distance (of_complex z) (moebius_pt (blaschke a) u)", "obtain Mz where\n        \"?R Mz ?Mx ?Mu\""], ["proof (prove)\nusing this:\n  \\<exists>!z.\n     - 1 < Re z \\<and>\n     Re z < 1 \\<and>\n     is_real z \\<and>\n     poincare_distance (of_complex z)\n      (moebius_pt (blaschke a) (of_complex x)) =\n     poincare_distance (of_complex z) (moebius_pt (blaschke a) u)\n\ngoal (1 subgoal):\n 1. (\\<And>Mz.\n        - 1 < Re Mz \\<and>\n        Re Mz < 1 \\<and>\n        is_real Mz \\<and>\n        poincare_distance (of_complex Mz)\n         (moebius_pt (blaschke a) (of_complex x)) =\n        poincare_distance (of_complex Mz)\n         (moebius_pt (blaschke a) u) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  - 1 < Re Mz \\<and>\n  Re Mz < 1 \\<and>\n  is_real Mz \\<and>\n  poincare_distance (of_complex Mz)\n   (moebius_pt (blaschke a) (of_complex x)) =\n  poincare_distance (of_complex Mz) (moebius_pt (blaschke a) u)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "have \"of_complex Mz \\<in> unit_disc\" \"of_complex Mz \\<in> circline_set x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex Mz \\<in> unit_disc &&&\n    of_complex Mz \\<in> circline_set x_axis", "using \\<open>?R Mz ?Mx ?Mu\\<close>"], ["proof (prove)\nusing this:\n  - 1 < Re Mz \\<and>\n  Re Mz < 1 \\<and>\n  is_real Mz \\<and>\n  poincare_distance (of_complex Mz)\n   (moebius_pt (blaschke a) (of_complex x)) =\n  poincare_distance (of_complex Mz) (moebius_pt (blaschke a) u)\n\ngoal (1 subgoal):\n 1. of_complex Mz \\<in> unit_disc &&&\n    of_complex Mz \\<in> circline_set x_axis", "using cmod_eq_Re"], ["proof (prove)\nusing this:\n  - 1 < Re Mz \\<and>\n  Re Mz < 1 \\<and>\n  is_real Mz \\<and>\n  poincare_distance (of_complex Mz)\n   (moebius_pt (blaschke a) (of_complex x)) =\n  poincare_distance (of_complex Mz) (moebius_pt (blaschke a) u)\n  is_real ?z \\<Longrightarrow> cmod ?z = \\<bar>Re ?z\\<bar>\n\ngoal (1 subgoal):\n 1. of_complex Mz \\<in> unit_disc &&&\n    of_complex Mz \\<in> circline_set x_axis", "by auto"], ["proof (state)\nthis:\n  of_complex Mz \\<in> unit_disc\n  of_complex Mz \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "let ?Minv = \"- (blaschke a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "let ?z = \"moebius_pt ?Minv (of_complex Mz)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "have \"?z \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt (- blaschke a) (of_complex Mz) \\<in> unit_disc", "using \\<open>of_complex Mz \\<in> unit_disc\\<close> \\<open>cmod a < 1\\<close>"], ["proof (prove)\nusing this:\n  of_complex Mz \\<in> unit_disc\n  cmod a < 1\n\ngoal (1 subgoal):\n 1. moebius_pt (- blaschke a) (of_complex Mz) \\<in> unit_disc", "by auto"], ["proof (state)\nthis:\n  moebius_pt (- blaschke a) (of_complex Mz) \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "moreover"], ["proof (state)\nthis:\n  moebius_pt (- blaschke a) (of_complex Mz) \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "have \"?z \\<in> circline_set x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt (- blaschke a) (of_complex Mz) \\<in> circline_set x_axis", "using \\<open>of_complex Mz \\<in> circline_set x_axis\\<close>"], ["proof (prove)\nusing this:\n  of_complex Mz \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. moebius_pt (- blaschke a) (of_complex Mz) \\<in> circline_set x_axis", "using blaschke_real_preserve_x_axis \\<open>is_real a\\<close> \\<open>cmod a < 1\\<close>"], ["proof (prove)\nusing this:\n  of_complex Mz \\<in> circline_set x_axis\n  \\<lbrakk>is_real ?a; cmod ?a < 1\\<rbrakk>\n  \\<Longrightarrow> (moebius_pt (blaschke ?a) ?z\n                     \\<in> circline_set x_axis) =\n                    (?z \\<in> circline_set x_axis)\n  is_real a\n  cmod a < 1\n\ngoal (1 subgoal):\n 1. moebius_pt (- blaschke a) (of_complex Mz) \\<in> circline_set x_axis", "by fastforce"], ["proof (state)\nthis:\n  moebius_pt (- blaschke a) (of_complex Mz) \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "ultimately"], ["proof (chain)\npicking this:\n  moebius_pt (- blaschke a) (of_complex Mz) \\<in> unit_disc\n  moebius_pt (- blaschke a) (of_complex Mz) \\<in> circline_set x_axis", "have z1: \"-1 < Re (to_complex ?z)\" \"Re (to_complex ?z) < 1\" \"is_real (to_complex ?z)\""], ["proof (prove)\nusing this:\n  moebius_pt (- blaschke a) (of_complex Mz) \\<in> unit_disc\n  moebius_pt (- blaschke a) (of_complex Mz) \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. - 1 < Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) &&&\n    Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) < 1 &&&\n    is_real (to_complex (moebius_pt (- blaschke a) (of_complex Mz)))", "using inf_or_of_complex[of \"?z\"]"], ["proof (prove)\nusing this:\n  moebius_pt (- blaschke a) (of_complex Mz) \\<in> unit_disc\n  moebius_pt (- blaschke a) (of_complex Mz) \\<in> circline_set x_axis\n  moebius_pt (- blaschke a) (of_complex Mz) = \\<infinity>\\<^sub>h \\<or>\n  (\\<exists>x. moebius_pt (- blaschke a) (of_complex Mz) = of_complex x)\n\ngoal (1 subgoal):\n 1. - 1 < Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) &&&\n    Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) < 1 &&&\n    is_real (to_complex (moebius_pt (- blaschke a) (of_complex Mz)))", "unfolding circline_set_x_axis"], ["proof (prove)\nusing this:\n  moebius_pt (- blaschke a) (of_complex Mz) \\<in> unit_disc\n  moebius_pt (- blaschke a) (of_complex Mz)\n  \\<in> of_complex ` {x. is_real x} \\<union> {\\<infinity>\\<^sub>h}\n  moebius_pt (- blaschke a) (of_complex Mz) = \\<infinity>\\<^sub>h \\<or>\n  (\\<exists>x. moebius_pt (- blaschke a) (of_complex Mz) = of_complex x)\n\ngoal (1 subgoal):\n 1. - 1 < Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) &&&\n    Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) < 1 &&&\n    is_real (to_complex (moebius_pt (- blaschke a) (of_complex Mz)))", "by (auto simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  - 1 < Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz)))\n  Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) < 1\n  is_real (to_complex (moebius_pt (- blaschke a) (of_complex Mz)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "have z2: \"poincare_distance ?z (of_complex x) = poincare_distance ?z u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance (moebius_pt (- blaschke a) (of_complex Mz))\n     (of_complex x) =\n    poincare_distance (moebius_pt (- blaschke a) (of_complex Mz)) u", "using \\<open>?R Mz ?Mx ?Mu\\<close> \\<open>cmod a < 1\\<close> \\<open>?z \\<in> unit_disc\\<close> \\<open>of_complex x \\<in> unit_disc\\<close> \\<open>u \\<in> unit_disc\\<close>"], ["proof (prove)\nusing this:\n  - 1 < Re Mz \\<and>\n  Re Mz < 1 \\<and>\n  is_real Mz \\<and>\n  poincare_distance (of_complex Mz)\n   (moebius_pt (blaschke a) (of_complex x)) =\n  poincare_distance (of_complex Mz) (moebius_pt (blaschke a) u)\n  cmod a < 1\n  moebius_pt (- blaschke a) (of_complex Mz) \\<in> unit_disc\n  of_complex x \\<in> unit_disc\n  u \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance (moebius_pt (- blaschke a) (of_complex Mz))\n     (of_complex x) =\n    poincare_distance (moebius_pt (- blaschke a) (of_complex Mz)) u", "by (metis blaschke_preserve_distance_formula blaschke_unit_disc_fix moebius_pt_comp_inv_right poincare_distance_formula uminus_moebius_def unit_disc_fix_discI unit_disc_iff_cmod_lt_1)"], ["proof (state)\nthis:\n  poincare_distance (moebius_pt (- blaschke a) (of_complex Mz))\n   (of_complex x) =\n  poincare_distance (moebius_pt (- blaschke a) (of_complex Mz)) u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>- 1 < Re x; Re x < 1; is_real x;\n        of_complex x \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!z.\n                            - 1 < Re z \\<and>\n                            Re z < 1 \\<and>\n                            is_real z \\<and>\n                            poincare_distance (of_complex z)\n                             (of_complex x) =\n                            poincare_distance (of_complex z) u", "show \"?P (of_complex x) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. - 1 < Re ?a \\<and>\n    Re ?a < 1 \\<and>\n    is_real ?a \\<and>\n    poincare_distance (of_complex ?a) (of_complex x) =\n    poincare_distance (of_complex ?a) u\n 2. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = ?a", "show \"?R (to_complex ?z) (of_complex x) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 < Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) \\<and>\n    Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) < 1 \\<and>\n    is_real (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) \\<and>\n    poincare_distance\n     (of_complex (to_complex (moebius_pt (- blaschke a) (of_complex Mz))))\n     (of_complex x) =\n    poincare_distance\n     (of_complex (to_complex (moebius_pt (- blaschke a) (of_complex Mz)))) u", "using z1 z2 \\<open>?z \\<in> unit_disc\\<close> inf_or_of_complex[of ?z]"], ["proof (prove)\nusing this:\n  - 1 < Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz)))\n  Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) < 1\n  is_real (to_complex (moebius_pt (- blaschke a) (of_complex Mz)))\n  poincare_distance (moebius_pt (- blaschke a) (of_complex Mz))\n   (of_complex x) =\n  poincare_distance (moebius_pt (- blaschke a) (of_complex Mz)) u\n  moebius_pt (- blaschke a) (of_complex Mz) \\<in> unit_disc\n  moebius_pt (- blaschke a) (of_complex Mz) = \\<infinity>\\<^sub>h \\<or>\n  (\\<exists>x. moebius_pt (- blaschke a) (of_complex Mz) = of_complex x)\n\ngoal (1 subgoal):\n 1. - 1 < Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) \\<and>\n    Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) < 1 \\<and>\n    is_real (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) \\<and>\n    poincare_distance\n     (of_complex (to_complex (moebius_pt (- blaschke a) (of_complex Mz))))\n     (of_complex x) =\n    poincare_distance\n     (of_complex (to_complex (moebius_pt (- blaschke a) (of_complex Mz)))) u", "by auto"], ["proof (state)\nthis:\n  - 1 < Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) \\<and>\n  Re (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) < 1 \\<and>\n  is_real (to_complex (moebius_pt (- blaschke a) (of_complex Mz))) \\<and>\n  poincare_distance\n   (of_complex (to_complex (moebius_pt (- blaschke a) (of_complex Mz))))\n   (of_complex x) =\n  poincare_distance\n   (of_complex (to_complex (moebius_pt (- blaschke a) (of_complex Mz)))) u\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "fix z'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "assume \"?R z' (of_complex x) u\""], ["proof (state)\nthis:\n  - 1 < Re z' \\<and>\n  Re z' < 1 \\<and>\n  is_real z' \\<and>\n  poincare_distance (of_complex z') (of_complex x) =\n  poincare_distance (of_complex z') u\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "hence \"of_complex z' \\<in> unit_disc\" \"of_complex z' \\<in> circline_set x_axis\""], ["proof (prove)\nusing this:\n  - 1 < Re z' \\<and>\n  Re z' < 1 \\<and>\n  is_real z' \\<and>\n  poincare_distance (of_complex z') (of_complex x) =\n  poincare_distance (of_complex z') u\n\ngoal (1 subgoal):\n 1. of_complex z' \\<in> unit_disc &&&\n    of_complex z' \\<in> circline_set x_axis", "by (auto simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  of_complex z' \\<in> unit_disc\n  of_complex z' \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "let ?Mz' = \"?M (of_complex z')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "have \"?Mz' \\<in> unit_disc\" \"?Mz' \\<in> circline_set x_axis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex z') \\<in> unit_disc &&&\n    moebius_pt (blaschke a) (of_complex z') \\<in> circline_set x_axis", "using \\<open>of_complex z' \\<in> unit_disc\\<close> \\<open>of_complex z' \\<in> circline_set x_axis\\<close> \\<open>cmod a < 1\\<close> \\<open>is_real a\\<close>"], ["proof (prove)\nusing this:\n  of_complex z' \\<in> unit_disc\n  of_complex z' \\<in> circline_set x_axis\n  cmod a < 1\n  is_real a\n\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex z') \\<in> unit_disc &&&\n    moebius_pt (blaschke a) (of_complex z') \\<in> circline_set x_axis", "using  blaschke_unit_disc_fix unit_disc_fix_discI"], ["proof (prove)\nusing this:\n  of_complex z' \\<in> unit_disc\n  of_complex z' \\<in> circline_set x_axis\n  cmod a < 1\n  is_real a\n  cmod ?a < 1 \\<Longrightarrow> unit_disc_fix (blaschke ?a)\n  \\<lbrakk>unit_disc_fix ?M; ?u \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> moebius_pt ?M ?u \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex z') \\<in> unit_disc &&&\n    moebius_pt (blaschke a) (of_complex z') \\<in> circline_set x_axis", "using blaschke_real_preserve_x_axis circline_set_x_axis"], ["proof (prove)\nusing this:\n  of_complex z' \\<in> unit_disc\n  of_complex z' \\<in> circline_set x_axis\n  cmod a < 1\n  is_real a\n  cmod ?a < 1 \\<Longrightarrow> unit_disc_fix (blaschke ?a)\n  \\<lbrakk>unit_disc_fix ?M; ?u \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> moebius_pt ?M ?u \\<in> unit_disc\n  \\<lbrakk>is_real ?a; cmod ?a < 1\\<rbrakk>\n  \\<Longrightarrow> (moebius_pt (blaschke ?a) ?z\n                     \\<in> circline_set x_axis) =\n                    (?z \\<in> circline_set x_axis)\n  circline_set x_axis =\n  of_complex ` {x. is_real x} \\<union> {\\<infinity>\\<^sub>h}\n\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex z') \\<in> unit_disc &&&\n    moebius_pt (blaschke a) (of_complex z') \\<in> circline_set x_axis", "by blast+"], ["proof (state)\nthis:\n  moebius_pt (blaschke a) (of_complex z') \\<in> unit_disc\n  moebius_pt (blaschke a) (of_complex z') \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "hence \"-1 < Re (to_complex ?Mz')\" \"Re (to_complex ?Mz') < 1\" \"is_real (to_complex ?Mz')\""], ["proof (prove)\nusing this:\n  moebius_pt (blaschke a) (of_complex z') \\<in> unit_disc\n  moebius_pt (blaschke a) (of_complex z') \\<in> circline_set x_axis\n\ngoal (1 subgoal):\n 1. - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) &&&\n    Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) < 1 &&&\n    is_real (to_complex (moebius_pt (blaschke a) (of_complex z')))", "unfolding circline_set_x_axis"], ["proof (prove)\nusing this:\n  moebius_pt (blaschke a) (of_complex z') \\<in> unit_disc\n  moebius_pt (blaschke a) (of_complex z')\n  \\<in> of_complex ` {x. is_real x} \\<union> {\\<infinity>\\<^sub>h}\n\ngoal (1 subgoal):\n 1. - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) &&&\n    Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) < 1 &&&\n    is_real (to_complex (moebius_pt (blaschke a) (of_complex z')))", "by (auto simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex z')))\n  Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) < 1\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex z')))\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "moreover"], ["proof (state)\nthis:\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex z')))\n  Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) < 1\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex z')))\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "have \"poincare_distance ?Mz' ?Mx = poincare_distance ?Mz' ?Mu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n     (moebius_pt (blaschke a) (of_complex x)) =\n    poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n     (moebius_pt (blaschke a) u)", "using \\<open>?R z' (of_complex x) u\\<close>"], ["proof (prove)\nusing this:\n  - 1 < Re z' \\<and>\n  Re z' < 1 \\<and>\n  is_real z' \\<and>\n  poincare_distance (of_complex z') (of_complex x) =\n  poincare_distance (of_complex z') u\n\ngoal (1 subgoal):\n 1. poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n     (moebius_pt (blaschke a) (of_complex x)) =\n    poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n     (moebius_pt (blaschke a) u)", "using \\<open>cmod a < 1\\<close> \\<open>of_complex x \\<in> unit_disc\\<close> \\<open>of_complex z' \\<in> unit_disc\\<close> \\<open>u \\<in> unit_disc\\<close>"], ["proof (prove)\nusing this:\n  - 1 < Re z' \\<and>\n  Re z' < 1 \\<and>\n  is_real z' \\<and>\n  poincare_distance (of_complex z') (of_complex x) =\n  poincare_distance (of_complex z') u\n  cmod a < 1\n  of_complex x \\<in> unit_disc\n  of_complex z' \\<in> unit_disc\n  u \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n     (moebius_pt (blaschke a) (of_complex x)) =\n    poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n     (moebius_pt (blaschke a) u)", "by auto"], ["proof (state)\nthis:\n  poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n   (moebius_pt (blaschke a) (of_complex x)) =\n  poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n   (moebius_pt (blaschke a) u)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "ultimately"], ["proof (chain)\npicking this:\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex z')))\n  Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) < 1\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex z')))\n  poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n   (moebius_pt (blaschke a) (of_complex x)) =\n  poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n   (moebius_pt (blaschke a) u)", "have \"?R (to_complex ?Mz') ?Mx ?Mu\""], ["proof (prove)\nusing this:\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex z')))\n  Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) < 1\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex z')))\n  poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n   (moebius_pt (blaschke a) (of_complex x)) =\n  poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n   (moebius_pt (blaschke a) u)\n\ngoal (1 subgoal):\n 1. - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) \\<and>\n    Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) < 1 \\<and>\n    is_real (to_complex (moebius_pt (blaschke a) (of_complex z'))) \\<and>\n    poincare_distance\n     (of_complex (to_complex (moebius_pt (blaschke a) (of_complex z'))))\n     (moebius_pt (blaschke a) (of_complex x)) =\n    poincare_distance\n     (of_complex (to_complex (moebius_pt (blaschke a) (of_complex z'))))\n     (moebius_pt (blaschke a) u)", "using \\<open>?Mz' \\<in> unit_disc\\<close> inf_or_of_complex[of ?Mz']"], ["proof (prove)\nusing this:\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex z')))\n  Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) < 1\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex z')))\n  poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n   (moebius_pt (blaschke a) (of_complex x)) =\n  poincare_distance (moebius_pt (blaschke a) (of_complex z'))\n   (moebius_pt (blaschke a) u)\n  moebius_pt (blaschke a) (of_complex z') \\<in> unit_disc\n  moebius_pt (blaschke a) (of_complex z') = \\<infinity>\\<^sub>h \\<or>\n  (\\<exists>x. moebius_pt (blaschke a) (of_complex z') = of_complex x)\n\ngoal (1 subgoal):\n 1. - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) \\<and>\n    Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) < 1 \\<and>\n    is_real (to_complex (moebius_pt (blaschke a) (of_complex z'))) \\<and>\n    poincare_distance\n     (of_complex (to_complex (moebius_pt (blaschke a) (of_complex z'))))\n     (moebius_pt (blaschke a) (of_complex x)) =\n    poincare_distance\n     (of_complex (to_complex (moebius_pt (blaschke a) (of_complex z'))))\n     (moebius_pt (blaschke a) u)", "by auto"], ["proof (state)\nthis:\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) \\<and>\n  Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) < 1 \\<and>\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex z'))) \\<and>\n  poincare_distance\n   (of_complex (to_complex (moebius_pt (blaschke a) (of_complex z'))))\n   (moebius_pt (blaschke a) (of_complex x)) =\n  poincare_distance\n   (of_complex (to_complex (moebius_pt (blaschke a) (of_complex z'))))\n   (moebius_pt (blaschke a) u)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "hence \"?Mz' = of_complex Mz\""], ["proof (prove)\nusing this:\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) \\<and>\n  Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) < 1 \\<and>\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex z'))) \\<and>\n  poincare_distance\n   (of_complex (to_complex (moebius_pt (blaschke a) (of_complex z'))))\n   (moebius_pt (blaschke a) (of_complex x)) =\n  poincare_distance\n   (of_complex (to_complex (moebius_pt (blaschke a) (of_complex z'))))\n   (moebius_pt (blaschke a) u)\n\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex z') = of_complex Mz", "using \\<open>?P ?Mx ?Mu\\<close> \\<open>?R Mz ?Mx ?Mu\\<close>"], ["proof (prove)\nusing this:\n  - 1 < Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) \\<and>\n  Re (to_complex (moebius_pt (blaschke a) (of_complex z'))) < 1 \\<and>\n  is_real (to_complex (moebius_pt (blaschke a) (of_complex z'))) \\<and>\n  poincare_distance\n   (of_complex (to_complex (moebius_pt (blaschke a) (of_complex z'))))\n   (moebius_pt (blaschke a) (of_complex x)) =\n  poincare_distance\n   (of_complex (to_complex (moebius_pt (blaschke a) (of_complex z'))))\n   (moebius_pt (blaschke a) u)\n  \\<exists>!z.\n     - 1 < Re z \\<and>\n     Re z < 1 \\<and>\n     is_real z \\<and>\n     poincare_distance (of_complex z)\n      (moebius_pt (blaschke a) (of_complex x)) =\n     poincare_distance (of_complex z) (moebius_pt (blaschke a) u)\n  - 1 < Re Mz \\<and>\n  Re Mz < 1 \\<and>\n  is_real Mz \\<and>\n  poincare_distance (of_complex Mz)\n   (moebius_pt (blaschke a) (of_complex x)) =\n  poincare_distance (of_complex Mz) (moebius_pt (blaschke a) u)\n\ngoal (1 subgoal):\n 1. moebius_pt (blaschke a) (of_complex z') = of_complex Mz", "by (metis \\<open>moebius_pt (blaschke a) (of_complex z') \\<in> unit_disc\\<close> \\<open>of_complex Mz \\<in> unit_disc\\<close> to_complex_of_complex unit_disc_to_complex_inj)"], ["proof (state)\nthis:\n  moebius_pt (blaschke a) (of_complex z') = of_complex Mz\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) u \\<Longrightarrow>\n       z = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "thus \"z' = to_complex ?z\""], ["proof (prove)\nusing this:\n  moebius_pt (blaschke a) (of_complex z') = of_complex Mz\n\ngoal (1 subgoal):\n 1. z' = to_complex (moebius_pt (- blaschke a) (of_complex Mz))", "by (simp add: moebius_pt_invert)"], ["proof (state)\nthis:\n  z' = to_complex (moebius_pt (- blaschke a) (of_complex Mz))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!z.\n     - 1 < Re z \\<and>\n     Re z < 1 \\<and>\n     is_real z \\<and>\n     poincare_distance (of_complex z) (of_complex x) =\n     poincare_distance (of_complex z) u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     - 1 < Re x \\<and>\n     Re x < 1 \\<and>\n     is_real x \\<and> of_complex x \\<noteq> u \\<longrightarrow>\n     (\\<exists>!z.\n         - 1 < Re z \\<and>\n         Re z < 1 \\<and>\n         is_real z \\<and>\n         poincare_distance (of_complex z) (of_complex x) =\n         poincare_distance (of_complex z) u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     - 1 < Re x \\<and>\n     Re x < 1 \\<and>\n     is_real x \\<and> of_complex x \\<noteq> of_complex y \\<longrightarrow>\n     (\\<exists>!z.\n         - 1 < Re z \\<and>\n         Re z < 1 \\<and>\n         is_real z \\<and>\n         poincare_distance (of_complex z) (of_complex x) =\n         poincare_distance (of_complex z) (of_complex y))\n\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) (of_complex y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     - 1 < Re x \\<and>\n     Re x < 1 \\<and>\n     is_real x \\<and> of_complex x \\<noteq> of_complex y \\<longrightarrow>\n     (\\<exists>!z.\n         - 1 < Re z \\<and>\n         Re z < 1 \\<and>\n         is_real z \\<and>\n         poincare_distance (of_complex z) (of_complex x) =\n         poincare_distance (of_complex z) (of_complex y))\n\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) (of_complex y)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     - 1 < Re x \\<and>\n     Re x < 1 \\<and>\n     is_real x \\<and> of_complex x \\<noteq> of_complex y \\<longrightarrow>\n     (\\<exists>!z.\n         - 1 < Re z \\<and>\n         Re z < 1 \\<and>\n         is_real z \\<and>\n         poincare_distance (of_complex z) (of_complex x) =\n         poincare_distance (of_complex z) (of_complex y))\n  is_real x\n  - 1 < Re x\n  Re x < 1\n  is_real y\n  - 1 < Re y\n  Re y < 1\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       - 1 < Re z \\<and>\n       Re z < 1 \\<and>\n       is_real z \\<and>\n       poincare_distance (of_complex z) (of_complex x) =\n       poincare_distance (of_complex z) (of_complex y)", "by (metis to_complex_of_complex)"], ["proof (state)\nthis:\n  \\<exists>!z.\n     - 1 < Re z \\<and>\n     Re z < 1 \\<and>\n     is_real z \\<and>\n     poincare_distance (of_complex z) (of_complex x) =\n     poincare_distance (of_complex z) (of_complex y)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* ------------------------------------------------------------------ *)"], ["", "subsection\\<open>Triangle inequality\\<close>"], ["", "(* ------------------------------------------------------------------ *)"], ["", "lemma poincare_distance_formula_zero_sum:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\"\n  shows \"poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n         (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n           in arcosh (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') / ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n    (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n     in arcosh\n         (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n          ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n    (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n     in arcosh\n         (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n          ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))", "obtain u' v' where uv: \"u' = to_complex u\" \"v' = to_complex v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        \\<lbrakk>u' = to_complex u; v' = to_complex v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u' = to_complex u\n  v' = to_complex v\n\ngoal (1 subgoal):\n 1. poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n    (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n     in arcosh\n         (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n          ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))", "have uv': \"u = of_complex u'\" \"v = of_complex v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = of_complex u' &&& v = of_complex v'", "using uv assms inf_or_of_complex[of u] inf_or_of_complex[of v]"], ["proof (prove)\nusing this:\n  u' = to_complex u\n  v' = to_complex v\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  u = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. u = of_complex x)\n  v = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. v = of_complex x)\n\ngoal (1 subgoal):\n 1. u = of_complex u' &&& v = of_complex v'", "by auto"], ["proof (state)\nthis:\n  u = of_complex u'\n  v = of_complex v'\n\ngoal (1 subgoal):\n 1. poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n    (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n     in arcosh\n         (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n          ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))", "let ?u' = \"cmod u'\" and ?v' = \"cmod v'\""], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n    (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n     in arcosh\n         (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n          ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))", "have disc: \"?u'\\<^sup>2 < 1\" \"?v'\\<^sup>2 < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod u')\\<^sup>2 < 1 &&& (cmod v')\\<^sup>2 < 1", "using unit_disc_cmod_square_lt_1[OF \\<open>u \\<in> unit_disc\\<close>]"], ["proof (prove)\nusing this:\n  (cmod (to_complex u))\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. (cmod u')\\<^sup>2 < 1 &&& (cmod v')\\<^sup>2 < 1", "using unit_disc_cmod_square_lt_1[OF \\<open>v \\<in> unit_disc\\<close>] uv"], ["proof (prove)\nusing this:\n  (cmod (to_complex u))\\<^sup>2 < 1\n  (cmod (to_complex v))\\<^sup>2 < 1\n  u' = to_complex u\n  v' = to_complex v\n\ngoal (1 subgoal):\n 1. (cmod u')\\<^sup>2 < 1 &&& (cmod v')\\<^sup>2 < 1", "by auto"], ["proof (state)\nthis:\n  (cmod u')\\<^sup>2 < 1\n  (cmod v')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n    (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n     in arcosh\n         (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n          ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))", "thm arcosh_add"], ["proof (state)\nthis:\n  (cmod u')\\<^sup>2 < 1\n  (cmod v')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n    (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n     in arcosh\n         (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n          ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))", "have \"arcosh (1 + 2 * ?u'\\<^sup>2 / (1 - ?u'\\<^sup>2)) + arcosh (1 + 2 * ?v'\\<^sup>2 / (1 - ?v'\\<^sup>2)) =\n        arcosh (((1 + ?u'\\<^sup>2) * (1 + ?v'\\<^sup>2) + 4 * ?u' * ?v') / ((1 - ?u'\\<^sup>2) * (1 - ?v'\\<^sup>2)))\" (is \"arcosh ?ll + arcosh ?rr = arcosh ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. arcosh (1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) +\n    arcosh (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "proof (subst arcosh_add)"], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<le> 1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)\n 2. 1 \\<le> 1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)\n 3. arcosh\n     ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n      (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n      sqrt\n       (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n         1) *\n        ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n         1))) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "show \"?ll \\<ge> 1\"  \"?rr \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> 1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2) &&&\n    1 \\<le> 1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)", "using disc"], ["proof (prove)\nusing this:\n  (cmod u')\\<^sup>2 < 1\n  (cmod v')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> 1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2) &&&\n    1 \\<le> 1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  1 \\<le> 1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)\n  1 \\<le> 1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)\n\ngoal (1 subgoal):\n 1. arcosh\n     ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n      (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n      sqrt\n       (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n         1) *\n        ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n         1))) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arcosh\n     ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n      (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n      sqrt\n       (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n         1) *\n        ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n         1))) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "show \"arcosh ((1 + 2 * ?u'\\<^sup>2 / (1 - ?u'\\<^sup>2)) * (1 + 2 * ?v'\\<^sup>2 / (1 - ?v'\\<^sup>2)) +\n                  sqrt (((1 + 2 * ?u'\\<^sup>2 / (1 - ?u'\\<^sup>2))\\<^sup>2 - 1) * ((1 + 2 * ?v'\\<^sup>2 / (1 - ?v'\\<^sup>2))\\<^sup>2 - 1))) =\n          arcosh ?r\" (is \"arcosh ?l = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. arcosh\n     ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n      (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n      sqrt\n       (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n         1) *\n        ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n         1))) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arcosh\n     ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n      (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n      sqrt\n       (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n         1) *\n        ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n         1))) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "have \"1 + 2 * ?u'\\<^sup>2 / (1 - ?u'\\<^sup>2) = (1 + ?u'\\<^sup>2) / (1 - ?u'\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2) =\n    (1 + (cmod u')\\<^sup>2) / (1 - (cmod u')\\<^sup>2)", "using disc"], ["proof (prove)\nusing this:\n  (cmod u')\\<^sup>2 < 1\n  (cmod v')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. 1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2) =\n    (1 + (cmod u')\\<^sup>2) / (1 - (cmod u')\\<^sup>2)", "by (subst add_divide_eq_iff, simp_all)"], ["proof (state)\nthis:\n  1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2) =\n  (1 + (cmod u')\\<^sup>2) / (1 - (cmod u')\\<^sup>2)\n\ngoal (1 subgoal):\n 1. arcosh\n     ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n      (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n      sqrt\n       (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n         1) *\n        ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n         1))) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "moreover"], ["proof (state)\nthis:\n  1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2) =\n  (1 + (cmod u')\\<^sup>2) / (1 - (cmod u')\\<^sup>2)\n\ngoal (1 subgoal):\n 1. arcosh\n     ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n      (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n      sqrt\n       (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n         1) *\n        ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n         1))) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "have \"1 + 2 * ?v'\\<^sup>2 / (1 - ?v'\\<^sup>2) = (1 + ?v'\\<^sup>2) / (1 - ?v'\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2) =\n    (1 + (cmod v')\\<^sup>2) / (1 - (cmod v')\\<^sup>2)", "using disc"], ["proof (prove)\nusing this:\n  (cmod u')\\<^sup>2 < 1\n  (cmod v')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. 1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2) =\n    (1 + (cmod v')\\<^sup>2) / (1 - (cmod v')\\<^sup>2)", "by (subst add_divide_eq_iff, simp_all)"], ["proof (state)\nthis:\n  1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2) =\n  (1 + (cmod v')\\<^sup>2) / (1 - (cmod v')\\<^sup>2)\n\ngoal (1 subgoal):\n 1. arcosh\n     ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n      (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n      sqrt\n       (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n         1) *\n        ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n         1))) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "moreover"], ["proof (state)\nthis:\n  1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2) =\n  (1 + (cmod v')\\<^sup>2) / (1 - (cmod v')\\<^sup>2)\n\ngoal (1 subgoal):\n 1. arcosh\n     ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n      (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n      sqrt\n       (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n         1) *\n        ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n         1))) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "have \"sqrt (((1 + 2 * ?u'\\<^sup>2 / (1 - ?u'\\<^sup>2))\\<^sup>2 - 1) * ((1 + 2 * ?v'\\<^sup>2 / (1 - ?v'\\<^sup>2))\\<^sup>2 - 1)) =\n               (4  * ?u' * ?v') / ((1 - ?u'\\<^sup>2) * (1 - ?v'\\<^sup>2))\" (is \"sqrt ?s = ?t\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n      ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n    4 * cmod u' * cmod v' /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sqrt\n     (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n      ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n    4 * cmod u' * cmod v' /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "have \"?s = ?t\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n    ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1) =\n    (4 * cmod u' * cmod v' /\n     ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))\\<^sup>2", "using disc"], ["proof (prove)\nusing this:\n  (cmod u')\\<^sup>2 < 1\n  (cmod v')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n    ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1) =\n    (4 * cmod u' * cmod v' /\n     ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))\\<^sup>2", "apply (subst add_divide_eq_iff, simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cmod u')\\<^sup>2 < 1; (cmod v')\\<^sup>2 < 1;\n     (cmod u')\\<^sup>2 < 1; (cmod v')\\<^sup>2 < 1\\<rbrakk>\n    \\<Longrightarrow> (((1 * (1 - (cmod u')\\<^sup>2) +\n                         2 * (cmod u')\\<^sup>2) /\n                        (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n                       1) *\n                      (((1 * (1 - (cmod v')\\<^sup>2) +\n                         2 * (cmod v')\\<^sup>2) /\n                        (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n                       1) =\n                      (4 * cmod u' * cmod v' /\n                       ((1 - (cmod u')\\<^sup>2) *\n                        (1 - (cmod v')\\<^sup>2)))\\<^sup>2", "apply (subst power_divide)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cmod u')\\<^sup>2 < 1; (cmod v')\\<^sup>2 < 1;\n     (cmod u')\\<^sup>2 < 1; (cmod v')\\<^sup>2 < 1\\<rbrakk>\n    \\<Longrightarrow> ((1 * (1 - (cmod u')\\<^sup>2) +\n                        2 * (cmod u')\\<^sup>2)\\<^sup>2 /\n                       (1 - (cmod u')\\<^sup>2)\\<^sup>2 -\n                       1) *\n                      ((1 * (1 - (cmod v')\\<^sup>2) +\n                        2 * (cmod v')\\<^sup>2)\\<^sup>2 /\n                       (1 - (cmod v')\\<^sup>2)\\<^sup>2 -\n                       1) =\n                      (4 * cmod u' * cmod v')\\<^sup>2 /\n                      ((1 - (cmod u')\\<^sup>2) *\n                       (1 - (cmod v')\\<^sup>2))\\<^sup>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cmod u')\\<^sup>2 < 1; (cmod v')\\<^sup>2 < 1\\<rbrakk>\n    \\<Longrightarrow> (((cmod u')\\<^sup>2 + 1)\\<^sup>2 /\n                       (1 - (cmod u')\\<^sup>2)\\<^sup>2 -\n                       1) *\n                      (((cmod v')\\<^sup>2 + 1)\\<^sup>2 /\n                       (1 - (cmod v')\\<^sup>2)\\<^sup>2 -\n                       1) =\n                      (4 * cmod u' * cmod v')\\<^sup>2 /\n                      ((1 - (cmod u')\\<^sup>2) *\n                       (1 - (cmod v')\\<^sup>2))\\<^sup>2", "apply (subst divide_diff_eq_iff, simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cmod u')\\<^sup>2 < 1; (cmod v')\\<^sup>2 < 1\\<rbrakk>\n    \\<Longrightarrow> (((cmod u')\\<^sup>2 + 1)\\<^sup>2 -\n                       1 * (1 - (cmod u')\\<^sup>2)\\<^sup>2) /\n                      (1 - (cmod u')\\<^sup>2)\\<^sup>2 *\n                      ((((cmod v')\\<^sup>2 + 1)\\<^sup>2 -\n                        1 * (1 - (cmod v')\\<^sup>2)\\<^sup>2) /\n                       (1 - (cmod v')\\<^sup>2)\\<^sup>2) =\n                      (4 * cmod u' * cmod v')\\<^sup>2 /\n                      ((1 - (cmod u')\\<^sup>2) *\n                       (1 - (cmod v')\\<^sup>2))\\<^sup>2", "apply (simp add: power2_eq_square field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n  ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1) =\n  (4 * cmod u' * cmod v' /\n   ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt\n     (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n      ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n    4 * cmod u' * cmod v' /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n  ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1) =\n  (4 * cmod u' * cmod v' /\n   ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt\n     (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n      ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n    4 * cmod u' * cmod v' /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "using disc"], ["proof (prove)\nusing this:\n  ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n  ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1) =\n  (4 * cmod u' * cmod v' /\n   ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))\\<^sup>2\n  (cmod u')\\<^sup>2 < 1\n  (cmod v')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. sqrt\n     (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n      ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n    4 * cmod u' * cmod v' /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "by simp"], ["proof (state)\nthis:\n  sqrt\n   (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n    ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n  4 * cmod u' * cmod v' /\n  ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sqrt\n   (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n    ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n  4 * cmod u' * cmod v' /\n  ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n\ngoal (1 subgoal):\n 1. arcosh\n     ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n      (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n      sqrt\n       (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n         1) *\n        ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n         1))) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "ultimately"], ["proof (chain)\npicking this:\n  1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2) =\n  (1 + (cmod u')\\<^sup>2) / (1 - (cmod u')\\<^sup>2)\n  1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2) =\n  (1 + (cmod v')\\<^sup>2) / (1 - (cmod v')\\<^sup>2)\n  sqrt\n   (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n    ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n  4 * cmod u' * cmod v' /\n  ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "have \"?l = ?r\""], ["proof (prove)\nusing this:\n  1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2) =\n  (1 + (cmod u')\\<^sup>2) / (1 - (cmod u')\\<^sup>2)\n  1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2) =\n  (1 + (cmod v')\\<^sup>2) / (1 - (cmod v')\\<^sup>2)\n  sqrt\n   (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n    ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n  4 * cmod u' * cmod v' /\n  ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n\ngoal (1 subgoal):\n 1. (1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n    (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n    sqrt\n     (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n      ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n    ((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n     4 * cmod u' * cmod v') /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "using disc"], ["proof (prove)\nusing this:\n  1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2) =\n  (1 + (cmod u')\\<^sup>2) / (1 - (cmod u')\\<^sup>2)\n  1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2) =\n  (1 + (cmod v')\\<^sup>2) / (1 - (cmod v')\\<^sup>2)\n  sqrt\n   (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n    ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n  4 * cmod u' * cmod v' /\n  ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n  (cmod u')\\<^sup>2 < 1\n  (cmod v')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. (1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n    (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n    sqrt\n     (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n      ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n    ((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n     4 * cmod u' * cmod v') /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))", "by simp (subst add_divide_distrib, simp)"], ["proof (state)\nthis:\n  (1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n  (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n  sqrt\n   (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n    ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n  ((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n   4 * cmod u' * cmod v') /\n  ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n\ngoal (1 subgoal):\n 1. arcosh\n     ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n      (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n      sqrt\n       (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n         1) *\n        ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n         1))) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n  (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n  sqrt\n   (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n    ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 - 1)) =\n  ((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n   4 * cmod u' * cmod v') /\n  ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2))\n\ngoal (1 subgoal):\n 1. arcosh\n     ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n      (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n      sqrt\n       (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 -\n         1) *\n        ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n         1))) =\n    arcosh\n     (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n       4 * cmod u' * cmod v') /\n      ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))", "by simp"], ["proof (state)\nthis:\n  arcosh\n   ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n    (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n    sqrt\n     (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n      ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n       1))) =\n  arcosh\n   (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n     4 * cmod u' * cmod v') /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arcosh\n   ((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) *\n    (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) +\n    sqrt\n     (((1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2))\\<^sup>2 - 1) *\n      ((1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2))\\<^sup>2 -\n       1))) =\n  arcosh\n   (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n     4 * cmod u' * cmod v') /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arcosh (1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) +\n  arcosh (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) =\n  arcosh\n   (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n     4 * cmod u' * cmod v') /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n    (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n     in arcosh\n         (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n          ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  arcosh (1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) +\n  arcosh (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) =\n  arcosh\n   (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n     4 * cmod u' * cmod v') /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n    (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n     in arcosh\n         (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n          ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))", "using uv' assms"], ["proof (prove)\nusing this:\n  arcosh (1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) +\n  arcosh (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) =\n  arcosh\n   (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n     4 * cmod u' * cmod v') /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))\n  u = of_complex u'\n  v = of_complex v'\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n    (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n     in arcosh\n         (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n          ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))", "using poincare_distance_formula"], ["proof (prove)\nusing this:\n  arcosh (1 + 2 * (cmod u')\\<^sup>2 / (1 - (cmod u')\\<^sup>2)) +\n  arcosh (1 + 2 * (cmod v')\\<^sup>2 / (1 - (cmod v')\\<^sup>2)) =\n  arcosh\n   (((1 + (cmod u')\\<^sup>2) * (1 + (cmod v')\\<^sup>2) +\n     4 * cmod u' * cmod v') /\n    ((1 - (cmod u')\\<^sup>2) * (1 - (cmod v')\\<^sup>2)))\n  u = of_complex u'\n  v = of_complex v'\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  \\<lbrakk>?u \\<in> unit_disc; ?v \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance ?u ?v =\n                    poincare_distance_formula (to_complex ?u)\n                     (to_complex ?v)\n\ngoal (1 subgoal):\n 1. poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n    (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n     in arcosh\n         (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n          ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  poincare_distance u 0\\<^sub>h + poincare_distance 0\\<^sub>h v =\n  (let u' = cmod (to_complex u); v' = cmod (to_complex v)\n   in arcosh\n       (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n        ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poincare_distance_triangle_inequality:\n  assumes \"u \\<in> unit_disc\" and \"v \\<in> unit_disc\" and \"w \\<in> unit_disc\"\n  shows \"poincare_distance u v + poincare_distance v w \\<ge> poincare_distance u w\" (is \"?P' u v w\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance u w\n    \\<le> poincare_distance u v + poincare_distance v w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poincare_distance u w\n    \\<le> poincare_distance u v + poincare_distance v w", "have \"\\<forall> w. w \\<in> unit_disc \\<longrightarrow> ?P' u v w\"  (is \"?P v u\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w.\n       w \\<in> unit_disc \\<longrightarrow>\n       poincare_distance u w\n       \\<le> poincare_distance u v + poincare_distance v w", "proof (rule wlog_x_axis[where P=\"?P\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. v \\<in> unit_disc\n 2. u \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        \\<forall>w.\n           w \\<in> unit_disc \\<longrightarrow>\n           poincare_distance (moebius_pt M v) w\n           \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n                 poincare_distance (moebius_pt M u) w\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance v w\n                            \\<le> poincare_distance v u +\n                                  poincare_distance u w\n 4. \\<And>x.\n       \\<lbrakk>is_real x; 0 \\<le> Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance (of_complex x) w\n                            \\<le> poincare_distance (of_complex x)\n                                   0\\<^sub>h +\n                                  poincare_distance 0\\<^sub>h w", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. v \\<in> unit_disc\n 2. u \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        \\<forall>w.\n           w \\<in> unit_disc \\<longrightarrow>\n           poincare_distance (moebius_pt M v) w\n           \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n                 poincare_distance (moebius_pt M u) w\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance v w\n                            \\<le> poincare_distance v u +\n                                  poincare_distance u w\n 4. \\<And>x.\n       \\<lbrakk>is_real x; 0 \\<le> Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance (of_complex x) w\n                            \\<le> poincare_distance (of_complex x)\n                                   0\\<^sub>h +\n                                  poincare_distance 0\\<^sub>h w", "assume \"is_real x\" \"0 \\<le> Re x\" \"Re x < 1\""], ["proof (state)\nthis:\n  is_real x\n  0 \\<le> Re x\n  Re x < 1\n\ngoal (4 subgoals):\n 1. v \\<in> unit_disc\n 2. u \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        \\<forall>w.\n           w \\<in> unit_disc \\<longrightarrow>\n           poincare_distance (moebius_pt M v) w\n           \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n                 poincare_distance (moebius_pt M u) w\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance v w\n                            \\<le> poincare_distance v u +\n                                  poincare_distance u w\n 4. \\<And>x.\n       \\<lbrakk>is_real x; 0 \\<le> Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance (of_complex x) w\n                            \\<le> poincare_distance (of_complex x)\n                                   0\\<^sub>h +\n                                  poincare_distance 0\\<^sub>h w", "hence \"of_complex x \\<in> unit_disc\""], ["proof (prove)\nusing this:\n  is_real x\n  0 \\<le> Re x\n  Re x < 1\n\ngoal (1 subgoal):\n 1. of_complex x \\<in> unit_disc", "by (simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  of_complex x \\<in> unit_disc\n\ngoal (4 subgoals):\n 1. v \\<in> unit_disc\n 2. u \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        \\<forall>w.\n           w \\<in> unit_disc \\<longrightarrow>\n           poincare_distance (moebius_pt M v) w\n           \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n                 poincare_distance (moebius_pt M u) w\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance v w\n                            \\<le> poincare_distance v u +\n                                  poincare_distance u w\n 4. \\<And>x.\n       \\<lbrakk>is_real x; 0 \\<le> Re x; Re x < 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance (of_complex x) w\n                            \\<le> poincare_distance (of_complex x)\n                                   0\\<^sub>h +\n                                  poincare_distance 0\\<^sub>h w", "show \"?P 0\\<^sub>h (of_complex x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w.\n       w \\<in> unit_disc \\<longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "assume \"w \\<in> unit_disc\""], ["proof (state)\nthis:\n  w \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "then"], ["proof (chain)\npicking this:\n  w \\<in> unit_disc", "obtain w' where w: \"w = of_complex w'\""], ["proof (prove)\nusing this:\n  w \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. (\\<And>w'. w = of_complex w' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inf_or_of_complex[of w]"], ["proof (prove)\nusing this:\n  w \\<in> unit_disc\n  w = \\<infinity>\\<^sub>h \\<or> (\\<exists>x. w = of_complex x)\n\ngoal (1 subgoal):\n 1. (\\<And>w'. w = of_complex w' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w = of_complex w'\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "let ?x = \"cmod x\" and ?w = \"cmod w'\" and ?xw = \"cmod (x - w')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "have disc: \"?x\\<^sup>2 < 1\" \"?w\\<^sup>2 < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod x)\\<^sup>2 < 1 &&& (cmod w')\\<^sup>2 < 1", "using unit_disc_cmod_square_lt_1[OF \\<open>of_complex x \\<in> unit_disc\\<close>]"], ["proof (prove)\nusing this:\n  (cmod (to_complex (of_complex x)))\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. (cmod x)\\<^sup>2 < 1 &&& (cmod w')\\<^sup>2 < 1", "using unit_disc_cmod_square_lt_1[OF \\<open>w \\<in> unit_disc\\<close>] w"], ["proof (prove)\nusing this:\n  (cmod (to_complex (of_complex x)))\\<^sup>2 < 1\n  (cmod (to_complex w))\\<^sup>2 < 1\n  w = of_complex w'\n\ngoal (1 subgoal):\n 1. (cmod x)\\<^sup>2 < 1 &&& (cmod w')\\<^sup>2 < 1", "by auto"], ["proof (state)\nthis:\n  (cmod x)\\<^sup>2 < 1\n  (cmod w')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "have \"poincare_distance (of_complex x) 0\\<^sub>h + poincare_distance 0\\<^sub>h w =\n           arcosh (((1 + ?x\\<^sup>2) * (1 + ?w\\<^sup>2) + 4 * ?x * ?w) / ((1 - ?x\\<^sup>2) * (1 - ?w\\<^sup>2)))\" (is \"_ = arcosh ?r1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance (of_complex x) 0\\<^sub>h +\n    poincare_distance 0\\<^sub>h w =\n    arcosh\n     (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n       4 * cmod x * cmod w') /\n      ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))", "using poincare_distance_formula_zero_sum[OF \\<open>of_complex x \\<in> unit_disc\\<close> \\<open>w \\<in> unit_disc\\<close>] w"], ["proof (prove)\nusing this:\n  poincare_distance (of_complex x) 0\\<^sub>h +\n  poincare_distance 0\\<^sub>h w =\n  (let u' = cmod (to_complex (of_complex x)); v' = cmod (to_complex w)\n   in arcosh\n       (((1 + u'\\<^sup>2) * (1 + v'\\<^sup>2) + 4 * u' * v') /\n        ((1 - u'\\<^sup>2) * (1 - v'\\<^sup>2))))\n  w = of_complex w'\n\ngoal (1 subgoal):\n 1. poincare_distance (of_complex x) 0\\<^sub>h +\n    poincare_distance 0\\<^sub>h w =\n    arcosh\n     (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n       4 * cmod x * cmod w') /\n      ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  poincare_distance (of_complex x) 0\\<^sub>h +\n  poincare_distance 0\\<^sub>h w =\n  arcosh\n   (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n     4 * cmod x * cmod w') /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "moreover"], ["proof (state)\nthis:\n  poincare_distance (of_complex x) 0\\<^sub>h +\n  poincare_distance 0\\<^sub>h w =\n  arcosh\n   (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n     4 * cmod x * cmod w') /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "have \"poincare_distance (of_complex x) (of_complex w') =\n            arcosh (((1 - ?x\\<^sup>2) * (1 - ?w\\<^sup>2) + 2 * ?xw\\<^sup>2) / ((1 - ?x\\<^sup>2) * (1 - ?w\\<^sup>2)))\" (is \"_ = arcosh ?r2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poincare_distance (of_complex x) (of_complex w') =\n    arcosh\n     (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n       2 * (cmod (x - w'))\\<^sup>2) /\n      ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))", "using disc"], ["proof (prove)\nusing this:\n  (cmod x)\\<^sup>2 < 1\n  (cmod w')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. poincare_distance (of_complex x) (of_complex w') =\n    arcosh\n     (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n       2 * (cmod (x - w'))\\<^sup>2) /\n      ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))", "using poincare_distance_formula[OF \\<open>of_complex x \\<in> unit_disc\\<close> \\<open>w \\<in> unit_disc\\<close>] w"], ["proof (prove)\nusing this:\n  (cmod x)\\<^sup>2 < 1\n  (cmod w')\\<^sup>2 < 1\n  poincare_distance (of_complex x) w =\n  poincare_distance_formula (to_complex (of_complex x)) (to_complex w)\n  w = of_complex w'\n\ngoal (1 subgoal):\n 1. poincare_distance (of_complex x) (of_complex w') =\n    arcosh\n     (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n       2 * (cmod (x - w'))\\<^sup>2) /\n      ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))", "by (subst add_divide_distrib) simp"], ["proof (state)\nthis:\n  poincare_distance (of_complex x) (of_complex w') =\n  arcosh\n   (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "moreover"], ["proof (state)\nthis:\n  poincare_distance (of_complex x) (of_complex w') =\n  arcosh\n   (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "have *: \"(1 - ?x\\<^sup>2) * (1 - ?w\\<^sup>2) + 2 * ?xw\\<^sup>2 \\<le> (1 + ?x\\<^sup>2) * (1 + ?w\\<^sup>2) + 4 * ?x * ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n    2 * (cmod (x - w'))\\<^sup>2\n    \\<le> (1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n          4 * cmod x * cmod w'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n    2 * (cmod (x - w'))\\<^sup>2\n    \\<le> (1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n          4 * cmod x * cmod w'", "have \"(cmod (x - w'))\\<^sup>2 \\<le> (cmod x + cmod w')\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (x - w'))\\<^sup>2 \\<le> (cmod x + cmod w')\\<^sup>2", "using norm_triangle_ineq4[of x w']"], ["proof (prove)\nusing this:\n  cmod (x - w') \\<le> cmod x + cmod w'\n\ngoal (1 subgoal):\n 1. (cmod (x - w'))\\<^sup>2 \\<le> (cmod x + cmod w')\\<^sup>2", "by (simp add: power_mono)"], ["proof (state)\nthis:\n  (cmod (x - w'))\\<^sup>2 \\<le> (cmod x + cmod w')\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n    2 * (cmod (x - w'))\\<^sup>2\n    \\<le> (1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n          4 * cmod x * cmod w'", "thus ?thesis"], ["proof (prove)\nusing this:\n  (cmod (x - w'))\\<^sup>2 \\<le> (cmod x + cmod w')\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n    2 * (cmod (x - w'))\\<^sup>2\n    \\<le> (1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n          4 * cmod x * cmod w'", "by (simp add: field_simps power2_sum)"], ["proof (state)\nthis:\n  (1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n  2 * (cmod (x - w'))\\<^sup>2\n  \\<le> (1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n        4 * cmod x * cmod w'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n  2 * (cmod (x - w'))\\<^sup>2\n  \\<le> (1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n        4 * cmod x * cmod w'\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "have \"arcosh ?r1 \\<ge> arcosh ?r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arcosh\n     (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n       2 * (cmod (x - w'))\\<^sup>2) /\n      ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n    \\<le> arcosh\n           (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n             4 * cmod x * cmod w') /\n            ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))", "proof (subst arcosh_mono)"], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n             4 * cmod x * cmod w') /\n            ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n 2. 1 \\<le> ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n             2 * (cmod (x - w'))\\<^sup>2) /\n            ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n 3. ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n    \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))", "show \"?r1 \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n             4 * cmod x * cmod w') /\n            ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))", "using disc"], ["proof (prove)\nusing this:\n  (cmod x)\\<^sup>2 < 1\n  (cmod w')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n             4 * cmod x * cmod w') /\n            ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))", "by (smt \"*\" le_divide_eq_1_pos mult_pos_pos zero_le_power2)"], ["proof (state)\nthis:\n  1 \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n\ngoal (2 subgoals):\n 1. 1 \\<le> ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n             2 * (cmod (x - w'))\\<^sup>2) /\n            ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n 2. ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n    \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 \\<le> ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n             2 * (cmod (x - w'))\\<^sup>2) /\n            ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n 2. ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n    \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))", "show \"?r2 \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n             2 * (cmod (x - w'))\\<^sup>2) /\n            ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))", "using disc"], ["proof (prove)\nusing this:\n  (cmod x)\\<^sup>2 < 1\n  (cmod w')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n             2 * (cmod (x - w'))\\<^sup>2) /\n            ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))", "by simp"], ["proof (state)\nthis:\n  1 \\<le> ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n           2 * (cmod (x - w'))\\<^sup>2) /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n\ngoal (1 subgoal):\n 1. ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n    \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n    \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))", "show \"?r1 \\<ge> ?r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n    \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))", "using disc"], ["proof (prove)\nusing this:\n  (cmod x)\\<^sup>2 < 1\n  (cmod w')\\<^sup>2 < 1\n\ngoal (1 subgoal):\n 1. ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n    \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))", "using *"], ["proof (prove)\nusing this:\n  (cmod x)\\<^sup>2 < 1\n  (cmod w')\\<^sup>2 < 1\n  (1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n  2 * (cmod (x - w'))\\<^sup>2\n  \\<le> (1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n        4 * cmod x * cmod w'\n\ngoal (1 subgoal):\n 1. ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n    \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))", "by (subst divide_right_mono, simp_all)"], ["proof (state)\nthis:\n  ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n   2 * (cmod (x - w'))\\<^sup>2) /\n  ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n  \\<le> ((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n         4 * cmod x * cmod w') /\n        ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arcosh\n   (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  \\<le> arcosh\n         (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance (of_complex x) w\n       \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n             poincare_distance 0\\<^sub>h w", "ultimately"], ["proof (chain)\npicking this:\n  poincare_distance (of_complex x) 0\\<^sub>h +\n  poincare_distance 0\\<^sub>h w =\n  arcosh\n   (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n     4 * cmod x * cmod w') /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  poincare_distance (of_complex x) (of_complex w') =\n  arcosh\n   (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  arcosh\n   (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  \\<le> arcosh\n         (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))", "show \"poincare_distance (of_complex x) w \\<le> poincare_distance (of_complex x) 0\\<^sub>h + poincare_distance 0\\<^sub>h w\""], ["proof (prove)\nusing this:\n  poincare_distance (of_complex x) 0\\<^sub>h +\n  poincare_distance 0\\<^sub>h w =\n  arcosh\n   (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n     4 * cmod x * cmod w') /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  poincare_distance (of_complex x) (of_complex w') =\n  arcosh\n   (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  arcosh\n   (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  \\<le> arcosh\n         (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. poincare_distance (of_complex x) w\n    \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n          poincare_distance 0\\<^sub>h w", "using \\<open>of_complex x \\<in> unit_disc\\<close> \\<open>w \\<in> unit_disc\\<close> w"], ["proof (prove)\nusing this:\n  poincare_distance (of_complex x) 0\\<^sub>h +\n  poincare_distance 0\\<^sub>h w =\n  arcosh\n   (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n     4 * cmod x * cmod w') /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  poincare_distance (of_complex x) (of_complex w') =\n  arcosh\n   (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  arcosh\n   (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  \\<le> arcosh\n         (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  of_complex x \\<in> unit_disc\n  w \\<in> unit_disc\n  w = of_complex w'\n\ngoal (1 subgoal):\n 1. poincare_distance (of_complex x) w\n    \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n          poincare_distance 0\\<^sub>h w", "using poincare_distance_formula"], ["proof (prove)\nusing this:\n  poincare_distance (of_complex x) 0\\<^sub>h +\n  poincare_distance 0\\<^sub>h w =\n  arcosh\n   (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n     4 * cmod x * cmod w') /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  poincare_distance (of_complex x) (of_complex w') =\n  arcosh\n   (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  arcosh\n   (((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2) +\n     2 * (cmod (x - w'))\\<^sup>2) /\n    ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  \\<le> arcosh\n         (((1 + (cmod x)\\<^sup>2) * (1 + (cmod w')\\<^sup>2) +\n           4 * cmod x * cmod w') /\n          ((1 - (cmod x)\\<^sup>2) * (1 - (cmod w')\\<^sup>2)))\n  of_complex x \\<in> unit_disc\n  w \\<in> unit_disc\n  w = of_complex w'\n  \\<lbrakk>?u \\<in> unit_disc; ?v \\<in> unit_disc\\<rbrakk>\n  \\<Longrightarrow> poincare_distance ?u ?v =\n                    poincare_distance_formula (to_complex ?u)\n                     (to_complex ?v)\n\ngoal (1 subgoal):\n 1. poincare_distance (of_complex x) w\n    \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n          poincare_distance 0\\<^sub>h w", "by simp"], ["proof (state)\nthis:\n  poincare_distance (of_complex x) w\n  \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n        poincare_distance 0\\<^sub>h w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>w.\n     w \\<in> unit_disc \\<longrightarrow>\n     poincare_distance (of_complex x) w\n     \\<le> poincare_distance (of_complex x) 0\\<^sub>h +\n           poincare_distance 0\\<^sub>h w\n\ngoal (3 subgoals):\n 1. v \\<in> unit_disc\n 2. u \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        \\<forall>w.\n           w \\<in> unit_disc \\<longrightarrow>\n           poincare_distance (moebius_pt M v) w\n           \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n                 poincare_distance (moebius_pt M u) w\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance v w\n                            \\<le> poincare_distance v u +\n                                  poincare_distance u w", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. v \\<in> unit_disc\n 2. u \\<in> unit_disc\n 3. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        \\<forall>w.\n           w \\<in> unit_disc \\<longrightarrow>\n           poincare_distance (moebius_pt M v) w\n           \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n                 poincare_distance (moebius_pt M u) w\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance v w\n                            \\<le> poincare_distance v u +\n                                  poincare_distance u w", "show \"v \\<in> unit_disc\" \"u \\<in> unit_disc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> unit_disc &&& u \\<in> unit_disc", "by fact+"], ["proof (state)\nthis:\n  v \\<in> unit_disc\n  u \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        \\<forall>w.\n           w \\<in> unit_disc \\<longrightarrow>\n           poincare_distance (moebius_pt M v) w\n           \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n                 poincare_distance (moebius_pt M u) w\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance v w\n                            \\<le> poincare_distance v u +\n                                  poincare_distance u w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        \\<forall>w.\n           w \\<in> unit_disc \\<longrightarrow>\n           poincare_distance (moebius_pt M v) w\n           \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n                 poincare_distance (moebius_pt M u) w\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance v w\n                            \\<le> poincare_distance v u +\n                                  poincare_distance u w", "fix M u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        \\<forall>w.\n           w \\<in> unit_disc \\<longrightarrow>\n           poincare_distance (moebius_pt M v) w\n           \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n                 poincare_distance (moebius_pt M u) w\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance v w\n                            \\<le> poincare_distance v u +\n                                  poincare_distance u w", "assume *: \"unit_disc_fix M\" \"u \\<in> unit_disc\" \"v \\<in> unit_disc\""], ["proof (state)\nthis:\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        \\<forall>w.\n           w \\<in> unit_disc \\<longrightarrow>\n           poincare_distance (moebius_pt M v) w\n           \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n                 poincare_distance (moebius_pt M u) w\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance v w\n                            \\<le> poincare_distance v u +\n                                  poincare_distance u w", "assume **: \"?P (moebius_pt M u) (moebius_pt M v)\""], ["proof (state)\nthis:\n  \\<forall>w.\n     w \\<in> unit_disc \\<longrightarrow>\n     poincare_distance (moebius_pt M v) w\n     \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n           poincare_distance (moebius_pt M u) w\n\ngoal (1 subgoal):\n 1. \\<And>M u v.\n       \\<lbrakk>unit_disc_fix M; u \\<in> unit_disc; v \\<in> unit_disc;\n        \\<forall>w.\n           w \\<in> unit_disc \\<longrightarrow>\n           poincare_distance (moebius_pt M v) w\n           \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n                 poincare_distance (moebius_pt M u) w\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                            w \\<in> unit_disc \\<longrightarrow>\n                            poincare_distance v w\n                            \\<le> poincare_distance v u +\n                                  poincare_distance u w", "show \"?P u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w.\n       w \\<in> unit_disc \\<longrightarrow>\n       poincare_distance v w\n       \\<le> poincare_distance v u + poincare_distance u w", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance v w\n       \\<le> poincare_distance v u + poincare_distance u w", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance v w\n       \\<le> poincare_distance v u + poincare_distance u w", "assume \"w \\<in> unit_disc\""], ["proof (state)\nthis:\n  w \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> unit_disc \\<Longrightarrow>\n       poincare_distance v w\n       \\<le> poincare_distance v u + poincare_distance u w", "thus \"?P' v u w\""], ["proof (prove)\nusing this:\n  w \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance v w\n    \\<le> poincare_distance v u + poincare_distance u w", "using * **[rule_format, of \"moebius_pt M w\"]"], ["proof (prove)\nusing this:\n  w \\<in> unit_disc\n  unit_disc_fix M\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  moebius_pt M w \\<in> unit_disc \\<Longrightarrow>\n  poincare_distance (moebius_pt M v) (moebius_pt M w)\n  \\<le> poincare_distance (moebius_pt M v) (moebius_pt M u) +\n        poincare_distance (moebius_pt M u) (moebius_pt M w)\n\ngoal (1 subgoal):\n 1. poincare_distance v w\n    \\<le> poincare_distance v u + poincare_distance u w", "by simp"], ["proof (state)\nthis:\n  poincare_distance v w \\<le> poincare_distance v u + poincare_distance u w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>w.\n     w \\<in> unit_disc \\<longrightarrow>\n     poincare_distance v w\n     \\<le> poincare_distance v u + poincare_distance u w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>w.\n     w \\<in> unit_disc \\<longrightarrow>\n     poincare_distance u w\n     \\<le> poincare_distance u v + poincare_distance v w\n\ngoal (1 subgoal):\n 1. poincare_distance u w\n    \\<le> poincare_distance u v + poincare_distance v w", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>w.\n     w \\<in> unit_disc \\<longrightarrow>\n     poincare_distance u w\n     \\<le> poincare_distance u v + poincare_distance v w\n\ngoal (1 subgoal):\n 1. poincare_distance u w\n    \\<le> poincare_distance u v + poincare_distance v w", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>w.\n     w \\<in> unit_disc \\<longrightarrow>\n     poincare_distance u w\n     \\<le> poincare_distance u v + poincare_distance v w\n  u \\<in> unit_disc\n  v \\<in> unit_disc\n  w \\<in> unit_disc\n\ngoal (1 subgoal):\n 1. poincare_distance u w\n    \\<le> poincare_distance u v + poincare_distance v w", "by auto"], ["proof (state)\nthis:\n  poincare_distance u w \\<le> poincare_distance u v + poincare_distance v w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}