{"file_name": "/home/qj213/afp-2021-10-22/thys/Weighted_Path_Order/WPO.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Weighted_Path_Order", "problem_names": ["lemma wpo_s_imp_ns: \"s \\<succ> t \\<Longrightarrow> s \\<succeq> t\"", "lemma ss_NS_not_UNIV: \"ssimple \\<Longrightarrow> NS \\<noteq> UNIV\"", "lemmas \\<sigma> = status[of \\<sigma>\\<sigma>]", "lemma NS_arg: assumes i: \"i \\<in> set (\\<sigma> (f,length ts))\"\n  shows \"(Fun f ts, ts ! i) \\<in> NS\"", "lemma NS_subterm: assumes all: \"\\<And> f k. set (\\<sigma> (f,k)) = {0 ..< k}\"\n  shows \"s \\<unrhd> t \\<Longrightarrow> (s,t) \\<in> NS\"", "lemma \\<sigma>E: \"i \\<in> set (\\<sigma> (f, length ss)) \\<Longrightarrow> ss ! i \\<in> set ss\"", "lemma wpo_ns_refl: \n  shows \"s \\<succeq> s\"", "lemma wpo_ns_imp_NS: \"s \\<succeq> t \\<Longrightarrow> (s,t) \\<in> NS\"", "lemma wpo_s_imp_NS: \"s \\<succ> t \\<Longrightarrow> (s,t) \\<in> NS\"", "lemma S_imp_wpo_s: assumes st: \"(s,t) \\<in> S\"\n  shows \"s \\<succ> t\"", "lemma wpo_least_1: assumes \"prl (f,length ss)\" \n  and \"(t, Fun f ss) \\<in> NS\"\n  and \"\\<sigma> (f,length ss) = []\"\nshows \"t \\<succeq> Fun f ss\"", "lemma wpo_least_2: assumes \"prl (f,length ss)\" (is \"prl ?f\")\n  and \"(Fun f ss, t) \\<notin> S\"\n  and \"\\<sigma> (f,length ss) = []\"\nshows \"\\<not> Fun f ss \\<succ> t\"", "lemma wpo_least_3: assumes \"prl (f,length ss)\" (is \"prl ?f\") \n  and ns: \"Fun f ss \\<succeq> t\"\n  and NS: \"(u, Fun f ss) \\<in> NS\"\n  and ss: \"\\<sigma> (f,length ss) = []\"\n  and S: \"\\<And> x. (Fun f ss, x) \\<notin> S\"\n  and u: \"u = Var x\" \nshows \"u \\<succeq> t\"", "lemma wpo_compat: \"\n  (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\" (is \"?tran s t u\")", "lemma subterm_wpo_s_arg: assumes i: \"i \\<in> set (\\<sigma> (f,length ss))\"\n  shows \"Fun f ss \\<succ> ss ! i\"", "lemma subterm_wpo_ns_arg: assumes i: \"i \\<in> set (\\<sigma> (f,length ss))\"\n  shows \"Fun f ss \\<succeq> ss ! i\"", "lemma wpo_ns_pre_mono: fixes f and bef aft :: \"('f,'v)term list\"\n  defines \"\\<sigma>f \\<equiv> \\<sigma> (f, Suc (length bef + length aft))\"\n  assumes rel: \"(wpo_ns s t)\"\n  shows \"(\\<forall>j\\<in>set \\<sigma>f. Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j)\n    \\<and> (Fun f (bef @ s # aft), (Fun f (bef @ t # aft))) \\<in> NS\n    \\<and> (\\<forall> i < length \\<sigma>f. ((map ((!) (bef @ s # aft)) \\<sigma>f) ! i) \\<succeq> ((map ((!) (bef @ t # aft)) \\<sigma>f) ! i))\"\n    (is \"_ \\<and> _ \\<and> ?three\")", "lemma wpo_ns_mono:\n  assumes rel: \"s \\<succeq> t\"\n  shows \"Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)\"", "lemma wpo_stable: fixes \\<delta> :: \"('f,'v)subst\"\n  shows \"(s \\<succ> t \\<longrightarrow> s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and> (s \\<succeq> t \\<longrightarrow> s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\"\n    (is \"?p s t\")", "lemma WPO_S_SN: \"SN WPO_S\"", "theorem WPO_SN_order_pair: \"SN_order_pair WPO_S WPO_NS\"", "theorem WPO_S_subst: \"(s,t) \\<in> WPO_S \\<Longrightarrow> (s \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>) \\<in> WPO_S\" for \\<sigma>", "theorem WPO_NS_subst: \"(s,t) \\<in> WPO_NS \\<Longrightarrow> (s \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>) \\<in> WPO_NS\" for \\<sigma>", "theorem WPO_NS_ctxt: \"(s,t) \\<in> WPO_NS \\<Longrightarrow> (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> WPO_NS\"", "theorem WPO_S_subset_WPO_NS: \"WPO_S \\<subseteq> WPO_NS\"", "lemma subterm_wpo_s: \"s \\<rhd> t \\<Longrightarrow> s \\<succ> t\"", "lemma subterm_wpo_ns: assumes supteq: \"s \\<unrhd> t\" shows \"s \\<succeq> t\"", "lemma wpo_s_mono: assumes rels: \"s \\<succ> t\"\n  shows \"Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)\"", "theorem WPO_S_ctxt: \"(s,t) \\<in> WPO_S \\<Longrightarrow> (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> WPO_S\"", "theorem supt_subset_WPO_S: \"{\\<rhd>} \\<subseteq> WPO_S\"", "theorem supteq_subset_WPO_NS: \"{\\<unrhd>} \\<subseteq> WPO_NS\""], "translations": [["", "lemma wpo_s_imp_ns: \"s \\<succ> t \\<Longrightarrow> s \\<succeq> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> t \\<Longrightarrow> s \\<succeq> t", "using lex_ext_stri_imp_nstri"], ["proof (prove)\nusing this:\n  fst (lex_ext ?f ?m ?xs ?ys) \\<Longrightarrow> snd (lex_ext ?f ?m ?xs ?ys)\n\ngoal (1 subgoal):\n 1. s \\<succ> t \\<Longrightarrow> s \\<succeq> t", "unfolding wpo.simps[of s t]"], ["proof (prove)\nusing this:\n  fst (lex_ext ?f ?m ?xs ?ys) \\<Longrightarrow> snd (lex_ext ?f ?m ?xs ?ys)\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case t of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, t) \\<in> NS \\<and>\n                status \\<sigma>\\<sigma> (g, length ts) = [] \\<and>\n                prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, t) \\<in> S then (True, True)\n             else if (s, t) \\<in> NS\n                  then if \\<exists>i\\<in>set\n    (status \\<sigma>\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> t\n                       then (True, True)\n                       else case t of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (status \\<sigma>\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (status \\<sigma>\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (status \\<sigma>\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False)) \\<Longrightarrow>\n    snd (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case t of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, t) \\<in> NS \\<and>\n                status \\<sigma>\\<sigma> (g, length ts) = [] \\<and>\n                prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, t) \\<in> S then (True, True)\n             else if (s, t) \\<in> NS\n                  then if \\<exists>i\\<in>set\n    (status \\<sigma>\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> t\n                       then (True, True)\n                       else case t of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (status \\<sigma>\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (status \\<sigma>\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (status \\<sigma>\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by (auto simp: Let_def mul_ext_stri_imp_nstri split: term.splits if_splits prod.splits)"], ["", "end"], ["", "declare wpo.wpo.simps[code]"], ["", "definition strictly_simple_status :: \"'f status \\<Rightarrow> ('f,'v)term rel \\<Rightarrow> bool\" where\n  \"strictly_simple_status \\<sigma> rel = \n    (\\<forall> f ts i. i \\<in> set (status \\<sigma> (f,length ts)) \\<longrightarrow> (Fun f ts, ts ! i) \\<in> rel)\""], ["", "locale wpo_with_assms = wpo +\n  SN_order_pair + precedence +\n  constrains S :: \"('f, 'v) term rel\" and NS :: _\n    and prc :: \"'f \\<times> nat \\<Rightarrow> 'f \\<times> nat \\<Rightarrow> bool \\<times> bool\"\n    and prl :: \"'f \\<times> nat \\<Rightarrow> bool\"\n    and ssimple :: bool\n    and large :: \"'f \\<times> nat \\<Rightarrow> bool\" \n    and c :: \"'f \\<times> nat \\<Rightarrow> order_tag\" \n    and n :: nat\n    and \\<sigma>\\<sigma> :: \"'f status\"\n  assumes subst_S: \"(s,t) \\<in> S \\<Longrightarrow> (s \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>) \\<in> S\"\n    and subst_NS: \"(s,t) \\<in> NS \\<Longrightarrow> (s \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>) \\<in> NS\"\n    and ctxt_NS: \"(s,t) \\<in> NS \\<Longrightarrow> (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS\" \n    and S_imp_NS: \"S \\<subseteq> NS\"\n    and ws_status: \"i \\<in> set (status \\<sigma>\\<sigma> fn) \\<Longrightarrow> simple_arg_pos NS fn i\"\n    and large: \"ssimple \\<Longrightarrow> large fn \\<Longrightarrow> fst (prc fn gm) \\<or> snd (prc fn gm) \\<and> status \\<sigma>\\<sigma> gm = []\"  \n    and large_trans: \"ssimple \\<Longrightarrow> large fn \\<Longrightarrow> snd (prc gm fn) \\<Longrightarrow> large gm\"  \n    and ss_status: \"ssimple \\<Longrightarrow> i \\<in> set (status \\<sigma>\\<sigma> fn) \\<Longrightarrow> simple_arg_pos S fn i\"\n    and ss_S_non_empty: \"ssimple \\<Longrightarrow> S \\<noteq> {}\"\nbegin"], ["", "lemma ss_NS_not_UNIV: \"ssimple \\<Longrightarrow> NS \\<noteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ssimple \\<Longrightarrow> NS \\<noteq> UNIV", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ssimple; NS = UNIV\\<rbrakk> \\<Longrightarrow> False", "assume \"ssimple\" \"NS = UNIV\""], ["proof (state)\nthis:\n  ssimple\n  NS = UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ssimple; NS = UNIV\\<rbrakk> \\<Longrightarrow> False", "with ss_S_non_empty"], ["proof (chain)\npicking this:\n  ssimple \\<Longrightarrow> S \\<noteq> {}\n  ssimple\n  NS = UNIV", "obtain a b where \"(a,b) \\<in> S\" \"(b,a) \\<in> NS\""], ["proof (prove)\nusing this:\n  ssimple \\<Longrightarrow> S \\<noteq> {}\n  ssimple\n  NS = UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>(a, b) \\<in> S; (b, a) \\<in> NS\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (a, b) \\<in> S\n  (b, a) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ssimple; NS = UNIV\\<rbrakk> \\<Longrightarrow> False", "from compat_S_NS_point[OF this]"], ["proof (chain)\npicking this:\n  (a, a) \\<in> S", "have \"(a,a) \\<in> S\""], ["proof (prove)\nusing this:\n  (a, a) \\<in> S\n\ngoal (1 subgoal):\n 1. (a, a) \\<in> S", "."], ["proof (state)\nthis:\n  (a, a) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ssimple; NS = UNIV\\<rbrakk> \\<Longrightarrow> False", "with SN"], ["proof (chain)\npicking this:\n  SN S\n  (a, a) \\<in> S", "show False"], ["proof (prove)\nusing this:\n  SN S\n  (a, a) \\<in> S\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"\\<sigma> \\<equiv> status \\<sigma>\\<sigma>\""], ["", "lemmas \\<sigma> = status[of \\<sigma>\\<sigma>]"], ["", "lemma NS_arg: assumes i: \"i \\<in> set (\\<sigma> (f,length ts))\"\n  shows \"(Fun f ts, ts ! i) \\<in> NS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Fun f ts, ts ! i) \\<in> NS", "by (rule ws_status[OF i, unfolded simple_arg_pos_def fst_conv, rule_format],\n      insert \\<sigma>[of f \"length ts\"] i, auto)"], ["", "lemma NS_subterm: assumes all: \"\\<And> f k. set (\\<sigma> (f,k)) = {0 ..< k}\"\n  shows \"s \\<unrhd> t \\<Longrightarrow> (s,t) \\<in> NS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<unrhd> t \\<Longrightarrow> (s, t) \\<in> NS", "proof (induct s t rule: supteq.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t. (t, t) \\<in> NS\n 2. \\<And>u ss t f.\n       \\<lbrakk>u \\<in> set ss; u \\<unrhd> t; (u, t) \\<in> NS\\<rbrakk>\n       \\<Longrightarrow> (Fun f ss, t) \\<in> NS", "case (refl)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>t. (t, t) \\<in> NS\n 2. \\<And>u ss t f.\n       \\<lbrakk>u \\<in> set ss; u \\<unrhd> t; (u, t) \\<in> NS\\<rbrakk>\n       \\<Longrightarrow> (Fun f ss, t) \\<in> NS", "from refl_NS"], ["proof (chain)\npicking this:\n  refl NS", "show ?case"], ["proof (prove)\nusing this:\n  refl NS\n\ngoal (1 subgoal):\n 1. (t_, t_) \\<in> NS", "unfolding refl_on_def"], ["proof (prove)\nusing this:\n  NS \\<subseteq> UNIV \\<times> UNIV \\<and>\n  (\\<forall>x\\<in>UNIV. (x, x) \\<in> NS)\n\ngoal (1 subgoal):\n 1. (t_, t_) \\<in> NS", "by blast"], ["proof (state)\nthis:\n  (t_, t_) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>u ss t f.\n       \\<lbrakk>u \\<in> set ss; u \\<unrhd> t; (u, t) \\<in> NS\\<rbrakk>\n       \\<Longrightarrow> (Fun f ss, t) \\<in> NS", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u ss t f.\n       \\<lbrakk>u \\<in> set ss; u \\<unrhd> t; (u, t) \\<in> NS\\<rbrakk>\n       \\<Longrightarrow> (Fun f ss, t) \\<in> NS", "case (subt s ss t f)"], ["proof (state)\nthis:\n  s \\<in> set ss\n  s \\<unrhd> t\n  (s, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>u ss t f.\n       \\<lbrakk>u \\<in> set ss; u \\<unrhd> t; (u, t) \\<in> NS\\<rbrakk>\n       \\<Longrightarrow> (Fun f ss, t) \\<in> NS", "from subt(1)"], ["proof (chain)\npicking this:\n  s \\<in> set ss", "obtain i where i: \"i < length ss\" and s: \"s = ss ! i\""], ["proof (prove)\nusing this:\n  s \\<in> set ss\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length ss; s = ss ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  s \\<in> {ss ! i |i. i < length ss}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length ss; s = ss ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length ss\n  s = ss ! i\n\ngoal (1 subgoal):\n 1. \\<And>u ss t f.\n       \\<lbrakk>u \\<in> set ss; u \\<unrhd> t; (u, t) \\<in> NS\\<rbrakk>\n       \\<Longrightarrow> (Fun f ss, t) \\<in> NS", "from NS_arg[of i f ss, unfolded all] s i"], ["proof (chain)\npicking this:\n  i \\<in> {0..<length ss} \\<Longrightarrow> (Fun f ss, ss ! i) \\<in> NS\n  s = ss ! i\n  i < length ss", "have \"(Fun f ss, s) \\<in> NS\""], ["proof (prove)\nusing this:\n  i \\<in> {0..<length ss} \\<Longrightarrow> (Fun f ss, ss ! i) \\<in> NS\n  s = ss ! i\n  i < length ss\n\ngoal (1 subgoal):\n 1. (Fun f ss, s) \\<in> NS", "by auto"], ["proof (state)\nthis:\n  (Fun f ss, s) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>u ss t f.\n       \\<lbrakk>u \\<in> set ss; u \\<unrhd> t; (u, t) \\<in> NS\\<rbrakk>\n       \\<Longrightarrow> (Fun f ss, t) \\<in> NS", "from trans_NS_point[OF this subt(3)]"], ["proof (chain)\npicking this:\n  (Fun f ss, t) \\<in> NS", "show ?case"], ["proof (prove)\nusing this:\n  (Fun f ss, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. (Fun f ss, t) \\<in> NS", "."], ["proof (state)\nthis:\n  (Fun f ss, t) \\<in> NS\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<sigma>E: \"i \\<in> set (\\<sigma> (f, length ss)) \\<Longrightarrow> ss ! i \\<in> set ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> set (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    ss ! i \\<in> set ss", "by (rule status_aux)"], ["", "lemma wpo_ns_refl: \n  shows \"s \\<succeq> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> s", "proof (induct s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<succeq> Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<succeq> x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<succeq> Fun x1a x2", "case (Fun f ss)"], ["proof (state)\nthis:\n  ?x2a \\<in> set ss \\<Longrightarrow> ?x2a \\<succeq> ?x2a\n\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<succeq> Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<succeq> x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<succeq> Fun x1a x2", "{"], ["proof (state)\nthis:\n  ?x2a \\<in> set ss \\<Longrightarrow> ?x2a \\<succeq> ?x2a\n\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<succeq> Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<succeq> x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<succeq> Fun x1a x2", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<succeq> Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<succeq> x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<succeq> Fun x1a x2", "assume si: \"i \\<in> set (\\<sigma> (f,length ss))\""], ["proof (state)\nthis:\n  i \\<in> set (\\<sigma> (f, length ss))\n\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<succeq> Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<succeq> x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<succeq> Fun x1a x2", "from NS_arg[OF this]"], ["proof (chain)\npicking this:\n  (Fun f ss, ss ! i) \\<in> NS", "have \"(Fun f ss, ss ! i) \\<in> NS\""], ["proof (prove)\nusing this:\n  (Fun f ss, ss ! i) \\<in> NS\n\ngoal (1 subgoal):\n 1. (Fun f ss, ss ! i) \\<in> NS", "."], ["proof (state)\nthis:\n  (Fun f ss, ss ! i) \\<in> NS\n\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<succeq> Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<succeq> x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<succeq> Fun x1a x2", "with si Fun[OF \\<sigma>E[OF si]]"], ["proof (chain)\npicking this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<succeq> ss ! i\n  (Fun f ss, ss ! i) \\<in> NS", "have \"wpo_s (Fun f ss) (ss ! i)\""], ["proof (prove)\nusing this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<succeq> ss ! i\n  (Fun f ss, ss ! i) \\<in> NS\n\ngoal (1 subgoal):\n 1. Fun f ss \\<succ> ss ! i", "unfolding wpo.simps[of \"Fun f ss\" \"ss ! i\"]"], ["proof (prove)\nusing this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<succeq> ss ! i\n  (Fun f ss, ss ! i) \\<in> NS\n\ngoal (1 subgoal):\n 1. fst (case Fun f ss of\n         Var x \\<Rightarrow>\n           (False,\n            case ss ! i of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (Fun f ss, ss ! i) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun fa ssa \\<Rightarrow>\n             if (Fun f ss, ss ! i) \\<in> S then (True, True)\n             else if (Fun f ss, ss ! i) \\<in> NS\n                  then if \\<exists>ia\\<in>set (\\<sigma> (fa, length ssa)).\n                             ssa ! ia \\<succeq> ss ! i\n                       then (True, True)\n                       else case ss ! i of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (fa, length ssa))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (fa, length ssa) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   Fun f ss \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ssa) (\\<sigma> (fa, length ssa));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (fa, length ssa); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by auto"], ["proof (state)\nthis:\n  Fun f ss \\<succ> ss ! i\n\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<succeq> Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<succeq> x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<succeq> Fun x1a x2", "}"], ["proof (state)\nthis:\n  ?i2 \\<in> set (\\<sigma> (f, length ss)) \\<Longrightarrow>\n  Fun f ss \\<succ> ss ! ?i2\n\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<succeq> Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<succeq> x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<succeq> Fun x1a x2", "note wpo_s = this"], ["proof (state)\nthis:\n  ?i2 \\<in> set (\\<sigma> (f, length ss)) \\<Longrightarrow>\n  Fun f ss \\<succ> ss ! ?i2\n\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<succeq> Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<succeq> x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<succeq> Fun x1a x2", "let ?ss = \"map (\\<lambda> i. ss ! i) (\\<sigma> (f,length ss))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<succeq> Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<succeq> x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<succeq> Fun x1a x2", "have rec11: \"snd (lex_ext wpo n ?ss ?ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ss) (\\<sigma> (f, length ss))))", "by (rule all_nstri_imp_lex_nstri, insert \\<sigma>E[of _ f ss], auto simp: Fun)"], ["proof (state)\nthis:\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ss) (\\<sigma> (f, length ss))))\n\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<succeq> Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<succeq> x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<succeq> Fun x1a x2", "have rec12: \"snd (mul_ext wpo ?ss ?ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ss) (\\<sigma> (f, length ss))))", "unfolding mul_ext_def Let_def snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset (map ((!) ss) (\\<sigma> (f, length ss))),\n     mset (map ((!) ss) (\\<sigma> (f, length ss))))\n    \\<in> ns_mul_ext WPO_NS WPO_S", "by (intro ns_mul_ext_refl_local,\n        unfold locally_refl_def, auto simp: in_multiset_in_set[of ?ss] intro!: Fun status_aux)"], ["proof (state)\nthis:\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ss) (\\<sigma> (f, length ss))))\n\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<succeq> Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<succeq> x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<succeq> Fun x1a x2", "from rec11 rec12"], ["proof (chain)\npicking this:\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ss) (\\<sigma> (f, length ss))))\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ss) (\\<sigma> (f, length ss))))", "show ?case"], ["proof (prove)\nusing this:\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ss) (\\<sigma> (f, length ss))))\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ss) (\\<sigma> (f, length ss))))\n\ngoal (1 subgoal):\n 1. Fun f ss \\<succeq> Fun f ss", "using refl_NS_point prc_refl wpo_s"], ["proof (prove)\nusing this:\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ss) (\\<sigma> (f, length ss))))\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ss) (\\<sigma> (f, length ss))))\n  (?s, ?s) \\<in> NS\n  prc ?f ?f = (False, True)\n  ?i2 \\<in> set (\\<sigma> (f, length ss)) \\<Longrightarrow>\n  Fun f ss \\<succ> ss ! ?i2\n\ngoal (1 subgoal):\n 1. Fun f ss \\<succeq> Fun f ss", "by (cases \"c (f,length ss)\", auto simp: wpo.simps[of \"Fun f ss\" \"Fun f ss\"])"], ["proof (state)\nthis:\n  Fun f ss \\<succeq> Fun f ss\n\ngoal (1 subgoal):\n 1. \\<And>x. Var x \\<succeq> Var x", "qed (simp add: wpo.simps)"], ["", "lemma wpo_ns_imp_NS: \"s \\<succeq> t \\<Longrightarrow> (s,t) \\<in> NS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> t \\<Longrightarrow> (s, t) \\<in> NS", "using S_imp_NS"], ["proof (prove)\nusing this:\n  S \\<subseteq> NS\n\ngoal (1 subgoal):\n 1. s \\<succeq> t \\<Longrightarrow> (s, t) \\<in> NS", "by (cases s, auto simp: wpo.simps[of _ t], cases t, \n      auto simp: refl_NS_point split: if_splits)"], ["", "lemma wpo_s_imp_NS: \"s \\<succ> t \\<Longrightarrow> (s,t) \\<in> NS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> t \\<Longrightarrow> (s, t) \\<in> NS", "by (rule wpo_ns_imp_NS[OF wpo_s_imp_ns])"], ["", "lemma S_imp_wpo_s: assumes st: \"(s,t) \\<in> S\"\n  shows \"s \\<succ> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> t", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. s = Var x1 \\<Longrightarrow> s \\<succ> t\n 2. \\<And>x21 x22. s = Fun x21 x22 \\<Longrightarrow> s \\<succ> t", "case (Fun f ss)"], ["proof (state)\nthis:\n  s = Fun f ss\n\ngoal (2 subgoals):\n 1. \\<And>x1. s = Var x1 \\<Longrightarrow> s \\<succ> t\n 2. \\<And>x21 x22. s = Fun x21 x22 \\<Longrightarrow> s \\<succ> t", "then"], ["proof (chain)\npicking this:\n  s = Fun f ss", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. s \\<succ> t", "using st"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  (s, t) \\<in> S\n\ngoal (1 subgoal):\n 1. s \\<succ> t", "by (auto simp: wpo.simps)"], ["proof (state)\nthis:\n  s \\<succ> t\n\ngoal (1 subgoal):\n 1. \\<And>x1. s = Var x1 \\<Longrightarrow> s \\<succ> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1. s = Var x1 \\<Longrightarrow> s \\<succ> t", "case (Var x)"], ["proof (state)\nthis:\n  s = Var x\n\ngoal (1 subgoal):\n 1. \\<And>x1. s = Var x1 \\<Longrightarrow> s \\<succ> t", "from SN_imp_minimal[OF SN, rule_format, of undefined UNIV]"], ["proof (chain)\npicking this:\n  undefined \\<in> UNIV \\<Longrightarrow>\n  \\<exists>z\\<in>UNIV.\n     \\<forall>y. (z, y) \\<in> S \\<longrightarrow> y \\<notin> UNIV", "obtain s where \"\\<And> u. (s,u) \\<notin> S\""], ["proof (prove)\nusing this:\n  undefined \\<in> UNIV \\<Longrightarrow>\n  \\<exists>z\\<in>UNIV.\n     \\<forall>y. (z, y) \\<in> S \\<longrightarrow> y \\<notin> UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        (\\<And>u. (s, u) \\<notin> S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (s, ?u) \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<And>x1. s = Var x1 \\<Longrightarrow> s \\<succ> t", "with subst_S[OF st[unfolded Var], of \"\\<lambda> _. s\"]"], ["proof (chain)\npicking this:\n  (Var x \\<cdot> (\\<lambda>_. s), t \\<cdot> (\\<lambda>_. s)) \\<in> S\n  (s, ?u) \\<notin> S", "have False"], ["proof (prove)\nusing this:\n  (Var x \\<cdot> (\\<lambda>_. s), t \\<cdot> (\\<lambda>_. s)) \\<in> S\n  (s, ?u) \\<notin> S\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x1. s = Var x1 \\<Longrightarrow> s \\<succ> t", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. s \\<succ> t", "by auto"], ["proof (state)\nthis:\n  s \\<succ> t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wpo_least_1: assumes \"prl (f,length ss)\" \n  and \"(t, Fun f ss) \\<in> NS\"\n  and \"\\<sigma> (f,length ss) = []\"\nshows \"t \\<succeq> Fun f ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<succeq> Fun f ss", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. t = Var x1 \\<Longrightarrow> t \\<succeq> Fun f ss\n 2. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> t \\<succeq> Fun f ss", "case (Var x)"], ["proof (state)\nthis:\n  t = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x1. t = Var x1 \\<Longrightarrow> t \\<succeq> Fun f ss\n 2. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> t \\<succeq> Fun f ss", "with assms"], ["proof (chain)\npicking this:\n  prl (f, length ss)\n  (t, Fun f ss) \\<in> NS\n  \\<sigma> (f, length ss) = []\n  t = Var x", "show ?thesis"], ["proof (prove)\nusing this:\n  prl (f, length ss)\n  (t, Fun f ss) \\<in> NS\n  \\<sigma> (f, length ss) = []\n  t = Var x\n\ngoal (1 subgoal):\n 1. t \\<succeq> Fun f ss", "by (simp add: wpo.simps)"], ["proof (state)\nthis:\n  t \\<succeq> Fun f ss\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> t \\<succeq> Fun f ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> t \\<succeq> Fun f ss", "case (Fun g ts)"], ["proof (state)\nthis:\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> t \\<succeq> Fun f ss", "let ?f = \"(f,length ss)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> t \\<succeq> Fun f ss", "let ?g = \"(g,length ts)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> t \\<succeq> Fun f ss", "obtain s ns where \"prc ?g ?f = (s,ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s ns.\n        prc (g, length ts) (f, length ss) = (s, ns) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (g, length ts) (f, length ss) = (s, ns)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> t \\<succeq> Fun f ss", "with prl[OF assms(1), of ?g]"], ["proof (chain)\npicking this:\n  snd (prc (g, length ts) (f, length ss)) = True\n  prc (g, length ts) (f, length ss) = (s, ns)", "have prc: \"prc ?g ?f = (s,True)\""], ["proof (prove)\nusing this:\n  snd (prc (g, length ts) (f, length ss)) = True\n  prc (g, length ts) (f, length ss) = (s, ns)\n\ngoal (1 subgoal):\n 1. prc (g, length ts) (f, length ss) = (s, True)", "by auto"], ["proof (state)\nthis:\n  prc (g, length ts) (f, length ss) = (s, True)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> t \\<succeq> Fun f ss", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<succeq> Fun f ss", "using assms(2)"], ["proof (prove)\nusing this:\n  (t, Fun f ss) \\<in> NS\n\ngoal (1 subgoal):\n 1. t \\<succeq> Fun f ss", "unfolding Fun"], ["proof (prove)\nusing this:\n  (Fun g ts, Fun f ss) \\<in> NS\n\ngoal (1 subgoal):\n 1. Fun g ts \\<succeq> Fun f ss", "unfolding wpo.simps[of \"Fun g ts\" \"Fun f ss\"] term.simps assms(3)"], ["proof (prove)\nusing this:\n  (Fun g ts, Fun f ss) \\<in> NS\n\ngoal (1 subgoal):\n 1. snd (if (Fun g ts, Fun f ss) \\<in> S then (True, True)\n         else if (Fun g ts, Fun f ss) \\<in> NS\n              then if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n                         ts ! i \\<succeq> Fun f ss\n                   then (True, True)\n                   else case prc (g, length ts) (f, length ss) of\n                        (prs, prns) \\<Rightarrow>\n                          if prns \\<and>\n                             (\\<forall>j\\<in>set [].\n                                 Fun g ts \\<succ> ss ! j)\n                          then if prs then (True, True)\n                               else let ss' =\n    map ((!) ts) (\\<sigma> (g, length ts));\n  ts' = map ((!) ss) []; cf = c (g, length ts); cg = c (f, length ss)\n                                    in if cf = Lex \\<and> cg = Lex\n then lex_ext wpo n ss' ts'\n else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n      else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                          else (False, False)\n              else (False, False))", "by (auto simp: prc lex_ext_least_1 mul_ext_def ns_mul_ext_bottom Let_def)"], ["proof (state)\nthis:\n  t \\<succeq> Fun f ss\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wpo_least_2: assumes \"prl (f,length ss)\" (is \"prl ?f\")\n  and \"(Fun f ss, t) \\<notin> S\"\n  and \"\\<sigma> (f,length ss) = []\"\nshows \"\\<not> Fun f ss \\<succ> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Fun f ss \\<succ> t", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. t = Var x1 \\<Longrightarrow> \\<not> Fun f ss \\<succ> t\n 2. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow> \\<not> Fun f ss \\<succ> t", "case (Var x)"], ["proof (state)\nthis:\n  t = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x1. t = Var x1 \\<Longrightarrow> \\<not> Fun f ss \\<succ> t\n 2. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow> \\<not> Fun f ss \\<succ> t", "with Var"], ["proof (chain)\npicking this:\n  t = Var x\n  t = Var x", "show ?thesis"], ["proof (prove)\nusing this:\n  t = Var x\n  t = Var x\n\ngoal (1 subgoal):\n 1. \\<not> Fun f ss \\<succ> t", "using assms(2-3)"], ["proof (prove)\nusing this:\n  t = Var x\n  t = Var x\n  (Fun f ss, t) \\<notin> S\n  \\<sigma> (f, length ss) = []\n\ngoal (1 subgoal):\n 1. \\<not> Fun f ss \\<succ> t", "by (auto simp: wpo.simps split: if_splits)"], ["proof (state)\nthis:\n  \\<not> Fun f ss \\<succ> t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow> \\<not> Fun f ss \\<succ> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow> \\<not> Fun f ss \\<succ> t", "case (Fun g ts)"], ["proof (state)\nthis:\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow> \\<not> Fun f ss \\<succ> t", "let ?g = \"(g,length ts)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow> \\<not> Fun f ss \\<succ> t", "obtain s ns where \"prc ?f ?g = (s,ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s ns.\n        prc (f, length ss) (g, length ts) = (s, ns) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (f, length ss) (g, length ts) = (s, ns)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow> \\<not> Fun f ss \\<succ> t", "with prl2[OF assms(1), of ?g]"], ["proof (chain)\npicking this:\n  fst (prc (f, length ss) (g, length ts)) = False\n  prc (f, length ss) (g, length ts) = (s, ns)", "have prc: \"prc ?f ?g = (False,ns)\""], ["proof (prove)\nusing this:\n  fst (prc (f, length ss) (g, length ts)) = False\n  prc (f, length ss) (g, length ts) = (s, ns)\n\ngoal (1 subgoal):\n 1. prc (f, length ss) (g, length ts) = (False, ns)", "by auto"], ["proof (state)\nthis:\n  prc (f, length ss) (g, length ts) = (False, ns)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow> \\<not> Fun f ss \\<succ> t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Fun f ss \\<succ> t", "using assms(2) assms(3)"], ["proof (prove)\nusing this:\n  (Fun f ss, t) \\<notin> S\n  \\<sigma> (f, length ss) = []\n\ngoal (1 subgoal):\n 1. \\<not> Fun f ss \\<succ> t", "unfolding Fun"], ["proof (prove)\nusing this:\n  (Fun f ss, Fun g ts) \\<notin> S\n  \\<sigma> (f, length ss) = []\n\ngoal (1 subgoal):\n 1. \\<not> Fun f ss \\<succ> Fun g ts", "by (simp add: wpo.simps[of _ \"Fun g ts\"] lex_ext_least_2 prc\n        mul_ext_def s_mul_ext_bottom_strict Let_def)"], ["proof (state)\nthis:\n  \\<not> Fun f ss \\<succ> t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wpo_least_3: assumes \"prl (f,length ss)\" (is \"prl ?f\") \n  and ns: \"Fun f ss \\<succeq> t\"\n  and NS: \"(u, Fun f ss) \\<in> NS\"\n  and ss: \"\\<sigma> (f,length ss) = []\"\n  and S: \"\\<And> x. (Fun f ss, x) \\<notin> S\"\n  and u: \"u = Var x\" \nshows \"u \\<succeq> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<succeq> t", "proof (cases \"(Fun f ss, t) \\<in> S \\<or> (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (Fun f ss, t) \\<in> S \\<or>\n    (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S \\<Longrightarrow>\n    u \\<succeq> t\n 2. \\<not> ((Fun f ss, t) \\<in> S \\<or>\n            (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S) \\<Longrightarrow>\n    u \\<succeq> t", "case True"], ["proof (state)\nthis:\n  (Fun f ss, t) \\<in> S \\<or> (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S\n\ngoal (2 subgoals):\n 1. (Fun f ss, t) \\<in> S \\<or>\n    (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S \\<Longrightarrow>\n    u \\<succeq> t\n 2. \\<not> ((Fun f ss, t) \\<in> S \\<or>\n            (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S) \\<Longrightarrow>\n    u \\<succeq> t", "with wpo_ns_imp_NS[OF ns] NS compat_NS_S_point compat_S_NS_point"], ["proof (chain)\npicking this:\n  (Fun f ss, t) \\<in> NS\n  (u, Fun f ss) \\<in> NS\n  \\<lbrakk>(?x, ?y) \\<in> NS; (?y, ?z) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> S\n  \\<lbrakk>(?x, ?y) \\<in> S; (?y, ?z) \\<in> NS\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> S\n  (Fun f ss, t) \\<in> S \\<or> (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S", "have \"(u, t) \\<in> S\""], ["proof (prove)\nusing this:\n  (Fun f ss, t) \\<in> NS\n  (u, Fun f ss) \\<in> NS\n  \\<lbrakk>(?x, ?y) \\<in> NS; (?y, ?z) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> S\n  \\<lbrakk>(?x, ?y) \\<in> S; (?y, ?z) \\<in> NS\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> S\n  (Fun f ss, t) \\<in> S \\<or> (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S\n\ngoal (1 subgoal):\n 1. (u, t) \\<in> S", "by blast"], ["proof (state)\nthis:\n  (u, t) \\<in> S\n\ngoal (2 subgoals):\n 1. (Fun f ss, t) \\<in> S \\<or>\n    (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S \\<Longrightarrow>\n    u \\<succeq> t\n 2. \\<not> ((Fun f ss, t) \\<in> S \\<or>\n            (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S) \\<Longrightarrow>\n    u \\<succeq> t", "from wpo_s_imp_ns[OF S_imp_wpo_s[OF this]]"], ["proof (chain)\npicking this:\n  u \\<succeq> t", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<succeq> t\n\ngoal (1 subgoal):\n 1. u \\<succeq> t", "."], ["proof (state)\nthis:\n  u \\<succeq> t\n\ngoal (1 subgoal):\n 1. \\<not> ((Fun f ss, t) \\<in> S \\<or>\n            (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S) \\<Longrightarrow>\n    u \\<succeq> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((Fun f ss, t) \\<in> S \\<or>\n            (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S) \\<Longrightarrow>\n    u \\<succeq> t", "case False"], ["proof (state)\nthis:\n  \\<not> ((Fun f ss, t) \\<in> S \\<or>\n          (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S)\n\ngoal (1 subgoal):\n 1. \\<not> ((Fun f ss, t) \\<in> S \\<or>\n            (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S) \\<Longrightarrow>\n    u \\<succeq> t", "from trans_NS_point[OF NS wpo_ns_imp_NS[OF ns]]"], ["proof (chain)\npicking this:\n  (u, t) \\<in> NS", "have utA: \"(u, t) \\<in> NS\""], ["proof (prove)\nusing this:\n  (u, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. (u, t) \\<in> NS", "."], ["proof (state)\nthis:\n  (u, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<not> ((Fun f ss, t) \\<in> S \\<or>\n            (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S) \\<Longrightarrow>\n    u \\<succeq> t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<succeq> t", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. t = Var x1 \\<Longrightarrow> u \\<succeq> t\n 2. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> u \\<succeq> t", "case t: (Var y)"], ["proof (state)\nthis:\n  t = Var y\n\ngoal (2 subgoals):\n 1. \\<And>x1. t = Var x1 \\<Longrightarrow> u \\<succeq> t\n 2. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> u \\<succeq> t", "with ns False ss"], ["proof (chain)\npicking this:\n  Fun f ss \\<succeq> t\n  \\<not> ((Fun f ss, t) \\<in> S \\<or>\n          (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S)\n  \\<sigma> (f, length ss) = []\n  t = Var y", "have *: \"ssimple\" \"large (f,length ss)\""], ["proof (prove)\nusing this:\n  Fun f ss \\<succeq> t\n  \\<not> ((Fun f ss, t) \\<in> S \\<or>\n          (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S)\n  \\<sigma> (f, length ss) = []\n  t = Var y\n\ngoal (1 subgoal):\n 1. ssimple &&& large (f, length ss)", "by (auto simp: wpo.simps split: if_splits)"], ["proof (state)\nthis:\n  ssimple\n  large (f, length ss)\n\ngoal (2 subgoals):\n 1. \\<And>x1. t = Var x1 \\<Longrightarrow> u \\<succeq> t\n 2. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> u \\<succeq> t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<succeq> t", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> u \\<succeq> t\n 2. x \\<noteq> y \\<Longrightarrow> u \\<succeq> t", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> u \\<succeq> t\n 2. x \\<noteq> y \\<Longrightarrow> u \\<succeq> t", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. u \\<succeq> t", "using ns * False utA ss"], ["proof (prove)\nusing this:\n  x = y\n  Fun f ss \\<succeq> t\n  ssimple\n  large (f, length ss)\n  \\<not> ((Fun f ss, t) \\<in> S \\<or>\n          (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S)\n  (u, t) \\<in> NS\n  \\<sigma> (f, length ss) = []\n\ngoal (1 subgoal):\n 1. u \\<succeq> t", "unfolding wpo.simps[of u t] wpo.simps[of \"Fun f ss\" t]"], ["proof (prove)\nusing this:\n  x = y\n  snd (case Fun f ss of\n       Var x \\<Rightarrow>\n         (False,\n          case t of Var xa \\<Rightarrow> x = xa\n          | Fun g ts \\<Rightarrow>\n              (Fun f ss, t) \\<in> NS \\<and>\n              \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n       | Fun fa ssa \\<Rightarrow>\n           if (Fun f ss, t) \\<in> S then (True, True)\n           else if (Fun f ss, t) \\<in> NS\n                then if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                           ssa ! i \\<succeq> t\n                     then (True, True)\n                     else case t of\n                          Var x \\<Rightarrow>\n                            (False, ssimple \\<and> large (fa, length ssa))\n                          | Fun g ts \\<Rightarrow>\n                              case prc (fa, length ssa) (g, length ts) of\n                              (prs, prns) \\<Rightarrow>\n                                if prns \\<and>\n                                   (\\<forall>j\n       \\<in>set (\\<sigma> (g, length ts)).\n Fun f ss \\<succ> ts ! j)\n                                then if prs then (True, True)\n                                     else let ss' =\n          map ((!) ssa) (\\<sigma> (fa, length ssa));\n        ts' = map ((!) ts) (\\<sigma> (g, length ts));\n        cf = c (fa, length ssa); cg = c (g, length ts)\n    in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n       else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n            else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                  length ts' = 0)\n                                else (False, False)\n                else (False, False))\n  ssimple\n  large (f, length ss)\n  \\<not> ((Fun f ss, t) \\<in> S \\<or>\n          (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S)\n  (u, t) \\<in> NS\n  \\<sigma> (f, length ss) = []\n\ngoal (1 subgoal):\n 1. snd (case u of\n         Var x \\<Rightarrow>\n           (False,\n            case t of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (u, t) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (u, t) \\<in> S then (True, True)\n             else if (u, t) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> t\n                       then (True, True)\n                       else case t of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   u \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "unfolding t u term.simps"], ["proof (prove)\nusing this:\n  x = y\n  snd (if (Fun f ss, Var y) \\<in> S then (True, True)\n       else if (Fun f ss, Var y) \\<in> NS\n            then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                       ss ! i \\<succeq> Var y\n                 then (True, True)\n                 else (False, ssimple \\<and> large (f, length ss))\n            else (False, False))\n  ssimple\n  large (f, length ss)\n  \\<not> ((Fun f ss, Var y) \\<in> S \\<or>\n          (Var x, Fun f ss) \\<in> S \\<or> (Var x, Var y) \\<in> S)\n  (Var x, Var y) \\<in> NS\n  \\<sigma> (f, length ss) = []\n\ngoal (1 subgoal):\n 1. snd (False, x = y)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  u \\<succeq> t\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> u \\<succeq> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> u \\<succeq> t", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> u \\<succeq> t", "from utA[unfolded t u]"], ["proof (chain)\npicking this:\n  (Var x, Var y) \\<in> NS", "have \"(Var x, Var y) \\<in> NS\""], ["proof (prove)\nusing this:\n  (Var x, Var y) \\<in> NS\n\ngoal (1 subgoal):\n 1. (Var x, Var y) \\<in> NS", "."], ["proof (state)\nthis:\n  (Var x, Var y) \\<in> NS\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> u \\<succeq> t", "from False subst_NS[OF this, of \"\\<lambda> z. if z = x then v else w\" for v w]"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  (Var x \\<cdot> (\\<lambda>z. if z = x then ?v2 else ?w2),\n   Var y \\<cdot> (\\<lambda>z. if z = x then ?v2 else ?w2))\n  \\<in> NS", "have \"(v,w) \\<in> NS\" for v w"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (Var x \\<cdot> (\\<lambda>z. if z = x then ?v2 else ?w2),\n   Var y \\<cdot> (\\<lambda>z. if z = x then ?v2 else ?w2))\n  \\<in> NS\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> NS", "by auto"], ["proof (state)\nthis:\n  (?v, ?w) \\<in> NS\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> u \\<succeq> t", "hence \"NS = UNIV\""], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> NS\n\ngoal (1 subgoal):\n 1. NS = UNIV", "by auto"], ["proof (state)\nthis:\n  NS = UNIV\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> u \\<succeq> t", "with ss_NS_not_UNIV[OF `ssimple`]"], ["proof (chain)\npicking this:\n  NS \\<noteq> UNIV\n  NS = UNIV", "have False"], ["proof (prove)\nusing this:\n  NS \\<noteq> UNIV\n  NS = UNIV\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> u \\<succeq> t", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. u \\<succeq> t", ".."], ["proof (state)\nthis:\n  u \\<succeq> t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<succeq> t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> u \\<succeq> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> u \\<succeq> t", "case (Fun g ts)"], ["proof (state)\nthis:\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> u \\<succeq> t", "let ?g = \"(g,length ts)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> u \\<succeq> t", "obtain s ns where \"prc ?f ?g = (s,ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s ns.\n        prc (f, length ss) (g, length ts) = (s, ns) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (f, length ss) (g, length ts) = (s, ns)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> u \\<succeq> t", "with prl2[OF \\<open>prl ?f\\<close>, of ?g]"], ["proof (chain)\npicking this:\n  fst (prc (f, length ss) (g, length ts)) = False\n  prc (f, length ss) (g, length ts) = (s, ns)", "have prc: \"prc ?f ?g = (False,ns)\""], ["proof (prove)\nusing this:\n  fst (prc (f, length ss) (g, length ts)) = False\n  prc (f, length ss) (g, length ts) = (s, ns)\n\ngoal (1 subgoal):\n 1. prc (f, length ss) (g, length ts) = (False, ns)", "by auto"], ["proof (state)\nthis:\n  prc (f, length ss) (g, length ts) = (False, ns)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. t = Fun x21 x22 \\<Longrightarrow> u \\<succeq> t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<succeq> t", "proof (cases \"\\<sigma> ?g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<sigma> (g, length ts) = [] \\<Longrightarrow> u \\<succeq> t\n 2. \\<And>a list.\n       \\<sigma> (g, length ts) = a # list \\<Longrightarrow> u \\<succeq> t", "case Nil"], ["proof (state)\nthis:\n  \\<sigma> (g, length ts) = []\n\ngoal (2 subgoals):\n 1. \\<sigma> (g, length ts) = [] \\<Longrightarrow> u \\<succeq> t\n 2. \\<And>a list.\n       \\<sigma> (g, length ts) = a # list \\<Longrightarrow> u \\<succeq> t", "with False Fun assms prc"], ["proof (chain)\npicking this:\n  \\<not> ((Fun f ss, t) \\<in> S \\<or>\n          (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S)\n  t = Fun g ts\n  prl (f, length ss)\n  Fun f ss \\<succeq> t\n  (u, Fun f ss) \\<in> NS\n  \\<sigma> (f, length ss) = []\n  (Fun f ss, ?x) \\<notin> S\n  u = Var x\n  prc (f, length ss) (g, length ts) = (False, ns)\n  \\<sigma> (g, length ts) = []", "have \"prc ?f ?g = (False,True)\""], ["proof (prove)\nusing this:\n  \\<not> ((Fun f ss, t) \\<in> S \\<or>\n          (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S)\n  t = Fun g ts\n  prl (f, length ss)\n  Fun f ss \\<succeq> t\n  (u, Fun f ss) \\<in> NS\n  \\<sigma> (f, length ss) = []\n  (Fun f ss, ?x) \\<notin> S\n  u = Var x\n  prc (f, length ss) (g, length ts) = (False, ns)\n  \\<sigma> (g, length ts) = []\n\ngoal (1 subgoal):\n 1. prc (f, length ss) (g, length ts) = (False, True)", "by (auto simp:  wpo.simps split: if_splits)"], ["proof (state)\nthis:\n  prc (f, length ss) (g, length ts) = (False, True)\n\ngoal (2 subgoals):\n 1. \\<sigma> (g, length ts) = [] \\<Longrightarrow> u \\<succeq> t\n 2. \\<And>a list.\n       \\<sigma> (g, length ts) = a # list \\<Longrightarrow> u \\<succeq> t", "with prl3[OF \\<open>prl ?f\\<close>, of ?g]"], ["proof (chain)\npicking this:\n  snd (prc (f, length ss) (g, length ts)) \\<Longrightarrow>\n  prl (g, length ts)\n  prc (f, length ss) (g, length ts) = (False, True)", "have \"prl ?g\""], ["proof (prove)\nusing this:\n  snd (prc (f, length ss) (g, length ts)) \\<Longrightarrow>\n  prl (g, length ts)\n  prc (f, length ss) (g, length ts) = (False, True)\n\ngoal (1 subgoal):\n 1. prl (g, length ts)", "by auto"], ["proof (state)\nthis:\n  prl (g, length ts)\n\ngoal (2 subgoals):\n 1. \\<sigma> (g, length ts) = [] \\<Longrightarrow> u \\<succeq> t\n 2. \\<And>a list.\n       \\<sigma> (g, length ts) = a # list \\<Longrightarrow> u \\<succeq> t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<succeq> t", "using utA"], ["proof (prove)\nusing this:\n  (u, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. u \\<succeq> t", "unfolding Fun"], ["proof (prove)\nusing this:\n  (u, Fun g ts) \\<in> NS\n\ngoal (1 subgoal):\n 1. u \\<succeq> Fun g ts", "by (rule wpo_least_1[OF \\<open>prl ?g\\<close>], simp add: Nil)"], ["proof (state)\nthis:\n  u \\<succeq> t\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<sigma> (g, length ts) = a # list \\<Longrightarrow> u \\<succeq> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<sigma> (g, length ts) = a # list \\<Longrightarrow> u \\<succeq> t", "case (Cons t1 tts)"], ["proof (state)\nthis:\n  \\<sigma> (g, length ts) = t1 # tts\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<sigma> (g, length ts) = a # list \\<Longrightarrow> u \\<succeq> t", "have \"\\<not> wpo_s (Fun f ss) (ts ! t1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Fun f ss \\<succ> ts ! t1", "by (rule wpo_least_2[OF \\<open>prl ?f\\<close> S ss])"], ["proof (state)\nthis:\n  \\<not> Fun f ss \\<succ> ts ! t1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<sigma> (g, length ts) = a # list \\<Longrightarrow> u \\<succeq> t", "with \\<open>wpo_ns (Fun f ss) t\\<close> False Fun Cons"], ["proof (chain)\npicking this:\n  Fun f ss \\<succeq> t\n  \\<not> ((Fun f ss, t) \\<in> S \\<or>\n          (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S)\n  t = Fun g ts\n  \\<sigma> (g, length ts) = t1 # tts\n  \\<not> Fun f ss \\<succ> ts ! t1", "have False"], ["proof (prove)\nusing this:\n  Fun f ss \\<succeq> t\n  \\<not> ((Fun f ss, t) \\<in> S \\<or>\n          (u, Fun f ss) \\<in> S \\<or> (u, t) \\<in> S)\n  t = Fun g ts\n  \\<sigma> (g, length ts) = t1 # tts\n  \\<not> Fun f ss \\<succ> ts ! t1\n\ngoal (1 subgoal):\n 1. False", "by (simp add: ss wpo.simps split: if_splits)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<sigma> (g, length ts) = a # list \\<Longrightarrow> u \\<succeq> t", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. u \\<succeq> t", ".."], ["proof (state)\nthis:\n  u \\<succeq> t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<succeq> t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<succeq> t\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Transitivity / compatibility of the orders *)"], ["", "lemma wpo_compat: \"\n  (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\" (is \"?tran s t u\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "proof (induct \"(s,t,u)\" arbitrary: s t u rule: wf_induct[OF wf_measures[of \"[\\<lambda> (s,t,u). size s, \\<lambda> (s,t,u). size t, \\<lambda> (s,t,u). size u]\"]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t u.\n       \\<forall>y.\n          (y, s, t, u)\n          \\<in> measures\n                 [\\<lambda>(s, t, u). size s, \\<lambda>(s, t, u). size t,\n                  \\<lambda>(s, t, y). size y] \\<longrightarrow>\n          (\\<forall>x xa xb.\n              y = (x, xa, xb) \\<longrightarrow>\n              (x \\<succeq> xa \\<and> xa \\<succ> xb \\<longrightarrow>\n               x \\<succ> xb) \\<and>\n              (x \\<succ> xa \\<and> xa \\<succeq> xb \\<longrightarrow>\n               x \\<succ> xb) \\<and>\n              (x \\<succeq> xa \\<and> xa \\<succeq> xb \\<longrightarrow>\n               x \\<succeq> xb)) \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "case 1"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, s, t, u)\n     \\<in> measures\n            [\\<lambda>(s, t, u). size s, \\<lambda>(s, t, u). size t,\n             \\<lambda>(s, t, y). size y] \\<longrightarrow>\n     (\\<forall>x xa xb.\n         y = (x, xa, xb) \\<longrightarrow>\n         (x \\<succeq> xa \\<and> xa \\<succ> xb \\<longrightarrow>\n          x \\<succ> xb) \\<and>\n         (x \\<succ> xa \\<and> xa \\<succeq> xb \\<longrightarrow>\n          x \\<succ> xb) \\<and>\n         (x \\<succeq> xa \\<and> xa \\<succeq> xb \\<longrightarrow>\n          x \\<succeq> xb))\n\ngoal (1 subgoal):\n 1. \\<And>s t u.\n       \\<forall>y.\n          (y, s, t, u)\n          \\<in> measures\n                 [\\<lambda>(s, t, u). size s, \\<lambda>(s, t, u). size t,\n                  \\<lambda>(s, t, y). size y] \\<longrightarrow>\n          (\\<forall>x xa xb.\n              y = (x, xa, xb) \\<longrightarrow>\n              (x \\<succeq> xa \\<and> xa \\<succ> xb \\<longrightarrow>\n               x \\<succ> xb) \\<and>\n              (x \\<succ> xa \\<and> xa \\<succeq> xb \\<longrightarrow>\n               x \\<succ> xb) \\<and>\n              (x \\<succeq> xa \\<and> xa \\<succeq> xb \\<longrightarrow>\n               x \\<succeq> xb)) \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "note ind = 1[simplified]"], ["proof (state)\nthis:\n  \\<forall>a aa b.\n     (size a < size s \\<longrightarrow>\n      (a \\<succeq> aa \\<and> aa \\<succ> b \\<longrightarrow>\n       a \\<succ> b) \\<and>\n      (a \\<succ> aa \\<and> aa \\<succeq> b \\<longrightarrow>\n       a \\<succ> b) \\<and>\n      (a \\<succeq> aa \\<and> aa \\<succeq> b \\<longrightarrow>\n       a \\<succeq> b)) \\<and>\n     (size a = size s \\<and>\n      (size aa < size t \\<or>\n       size aa = size t \\<and> size b < size u) \\<longrightarrow>\n      (a \\<succeq> aa \\<and> aa \\<succ> b \\<longrightarrow>\n       a \\<succ> b) \\<and>\n      (a \\<succ> aa \\<and> aa \\<succeq> b \\<longrightarrow>\n       a \\<succ> b) \\<and>\n      (a \\<succeq> aa \\<and> aa \\<succeq> b \\<longrightarrow>\n       a \\<succeq> b))\n\ngoal (1 subgoal):\n 1. \\<And>s t u.\n       \\<forall>y.\n          (y, s, t, u)\n          \\<in> measures\n                 [\\<lambda>(s, t, u). size s, \\<lambda>(s, t, u). size t,\n                  \\<lambda>(s, t, y). size y] \\<longrightarrow>\n          (\\<forall>x xa xb.\n              y = (x, xa, xb) \\<longrightarrow>\n              (x \\<succeq> xa \\<and> xa \\<succ> xb \\<longrightarrow>\n               x \\<succ> xb) \\<and>\n              (x \\<succ> xa \\<and> xa \\<succeq> xb \\<longrightarrow>\n               x \\<succ> xb) \\<and>\n              (x \\<succeq> xa \\<and> xa \\<succeq> xb \\<longrightarrow>\n               x \\<succeq> xb)) \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "show \"?tran s t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "proof (cases \"(s,t) \\<in> S \\<or> (t,u) \\<in> S \\<or> (s,u) \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (s, t) \\<in> S \\<or>\n    (t, u) \\<in> S \\<or> (s, u) \\<in> S \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<not> ((s, t) \\<in> S \\<or>\n            (t, u) \\<in> S \\<or> (s, u) \\<in> S) \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "case True"], ["proof (state)\nthis:\n  (s, t) \\<in> S \\<or> (t, u) \\<in> S \\<or> (s, u) \\<in> S\n\ngoal (2 subgoals):\n 1. (s, t) \\<in> S \\<or>\n    (t, u) \\<in> S \\<or> (s, u) \\<in> S \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<not> ((s, t) \\<in> S \\<or>\n            (t, u) \\<in> S \\<or> (s, u) \\<in> S) \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "{"], ["proof (state)\nthis:\n  (s, t) \\<in> S \\<or> (t, u) \\<in> S \\<or> (s, u) \\<in> S\n\ngoal (2 subgoals):\n 1. (s, t) \\<in> S \\<or>\n    (t, u) \\<in> S \\<or> (s, u) \\<in> S \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<not> ((s, t) \\<in> S \\<or>\n            (t, u) \\<in> S \\<or> (s, u) \\<in> S) \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "assume st: \"wpo_ns s t\" and tu: \"wpo_ns t u\""], ["proof (state)\nthis:\n  s \\<succeq> t\n  t \\<succeq> u\n\ngoal (2 subgoals):\n 1. (s, t) \\<in> S \\<or>\n    (t, u) \\<in> S \\<or> (s, u) \\<in> S \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<not> ((s, t) \\<in> S \\<or>\n            (t, u) \\<in> S \\<or> (s, u) \\<in> S) \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from wpo_ns_imp_NS[OF st] wpo_ns_imp_NS[OF tu]\n        True compat_NS_S_point compat_S_NS_point"], ["proof (chain)\npicking this:\n  (s, t) \\<in> NS\n  (t, u) \\<in> NS\n  (s, t) \\<in> S \\<or> (t, u) \\<in> S \\<or> (s, u) \\<in> S\n  \\<lbrakk>(?x, ?y) \\<in> NS; (?y, ?z) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> S\n  \\<lbrakk>(?x, ?y) \\<in> S; (?y, ?z) \\<in> NS\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> S", "have \"(s,u) \\<in> S\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> NS\n  (t, u) \\<in> NS\n  (s, t) \\<in> S \\<or> (t, u) \\<in> S \\<or> (s, u) \\<in> S\n  \\<lbrakk>(?x, ?y) \\<in> NS; (?y, ?z) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> S\n  \\<lbrakk>(?x, ?y) \\<in> S; (?y, ?z) \\<in> NS\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> S\n\ngoal (1 subgoal):\n 1. (s, u) \\<in> S", "by blast"], ["proof (state)\nthis:\n  (s, u) \\<in> S\n\ngoal (2 subgoals):\n 1. (s, t) \\<in> S \\<or>\n    (t, u) \\<in> S \\<or> (s, u) \\<in> S \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<not> ((s, t) \\<in> S \\<or>\n            (t, u) \\<in> S \\<or> (s, u) \\<in> S) \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from S_imp_wpo_s[OF this]"], ["proof (chain)\npicking this:\n  s \\<succ> u", "have \"wpo_s s u\""], ["proof (prove)\nusing this:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "."], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (2 subgoals):\n 1. (s, t) \\<in> S \\<or>\n    (t, u) \\<in> S \\<or> (s, u) \\<in> S \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<not> ((s, t) \\<in> S \\<or>\n            (t, u) \\<in> S \\<or> (s, u) \\<in> S) \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n  \\<Longrightarrow> s \\<succ> u\n\ngoal (2 subgoals):\n 1. (s, t) \\<in> S \\<or>\n    (t, u) \\<in> S \\<or> (s, u) \\<in> S \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<not> ((s, t) \\<in> S \\<or>\n            (t, u) \\<in> S \\<or> (s, u) \\<in> S) \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "with wpo_s_imp_ns"], ["proof (chain)\npicking this:\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n  \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n  \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\nusing this:\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n  \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n  \\<Longrightarrow> s \\<succ> u\n\ngoal (1 subgoal):\n 1. (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "by blast"], ["proof (state)\nthis:\n  (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n\ngoal (1 subgoal):\n 1. \\<not> ((s, t) \\<in> S \\<or>\n            (t, u) \\<in> S \\<or> (s, u) \\<in> S) \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((s, t) \\<in> S \\<or>\n            (t, u) \\<in> S \\<or> (s, u) \\<in> S) \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "case False"], ["proof (state)\nthis:\n  \\<not> ((s, t) \\<in> S \\<or> (t, u) \\<in> S \\<or> (s, u) \\<in> S)\n\ngoal (1 subgoal):\n 1. \\<not> ((s, t) \\<in> S \\<or>\n            (t, u) \\<in> S \\<or> (s, u) \\<in> S) \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "then"], ["proof (chain)\npicking this:\n  \\<not> ((s, t) \\<in> S \\<or> (t, u) \\<in> S \\<or> (s, u) \\<in> S)", "have stS: \"(s,t) \\<notin> S\" and tuS: \"(t,u) \\<notin> S\" and suS: \"(s,u) \\<notin> S\""], ["proof (prove)\nusing this:\n  \\<not> ((s, t) \\<in> S \\<or> (t, u) \\<in> S \\<or> (s, u) \\<in> S)\n\ngoal (1 subgoal):\n 1. (s, t) \\<notin> S &&& (t, u) \\<notin> S &&& (s, u) \\<notin> S", "by auto"], ["proof (state)\nthis:\n  (s, t) \\<notin> S\n  (t, u) \\<notin> S\n  (s, u) \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<not> ((s, t) \\<in> S \\<or>\n            (t, u) \\<in> S \\<or> (s, u) \\<in> S) \\<Longrightarrow>\n    (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = Var x1 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "note [simp] = wpo.simps[of s u] wpo.simps[of s t] wpo.simps[of t u]"], ["proof (state)\nthis:\n  wpo s u =\n  (case s of\n   Var x \\<Rightarrow>\n     (False,\n      case u of Var xa \\<Rightarrow> x = xa\n      | Fun g ts \\<Rightarrow>\n          (s, u) \\<in> NS \\<and>\n          \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n   | Fun f ss \\<Rightarrow>\n       if (s, u) \\<in> S then (True, True)\n       else if (s, u) \\<in> NS\n            then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                       ss ! i \\<succeq> u\n                 then (True, True)\n                 else case u of\n                      Var x \\<Rightarrow>\n                        (False, ssimple \\<and> large (f, length ss))\n                      | Fun g ts \\<Rightarrow>\n                          case prc (f, length ss) (g, length ts) of\n                          (prs, prns) \\<Rightarrow>\n                            if prns \\<and>\n                               (\\<forall>j\n   \\<in>set (\\<sigma> (g, length ts)).\n                                   s \\<succ> ts ! j)\n                            then if prs then (True, True)\n                                 else let ss' =\n      map ((!) ss) (\\<sigma> (f, length ss));\n    ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n    cg = c (g, length ts)\nin if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n   else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n        else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                            else (False, False)\n            else (False, False))\n  wpo s t =\n  (case s of\n   Var x \\<Rightarrow>\n     (False,\n      case t of Var xa \\<Rightarrow> x = xa\n      | Fun g ts \\<Rightarrow>\n          (s, t) \\<in> NS \\<and>\n          \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n   | Fun f ss \\<Rightarrow>\n       if (s, t) \\<in> S then (True, True)\n       else if (s, t) \\<in> NS\n            then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                       ss ! i \\<succeq> t\n                 then (True, True)\n                 else case t of\n                      Var x \\<Rightarrow>\n                        (False, ssimple \\<and> large (f, length ss))\n                      | Fun g ts \\<Rightarrow>\n                          case prc (f, length ss) (g, length ts) of\n                          (prs, prns) \\<Rightarrow>\n                            if prns \\<and>\n                               (\\<forall>j\n   \\<in>set (\\<sigma> (g, length ts)).\n                                   s \\<succ> ts ! j)\n                            then if prs then (True, True)\n                                 else let ss' =\n      map ((!) ss) (\\<sigma> (f, length ss));\n    ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n    cg = c (g, length ts)\nin if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n   else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n        else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                            else (False, False)\n            else (False, False))\n  wpo t u =\n  (case t of\n   Var x \\<Rightarrow>\n     (False,\n      case u of Var xa \\<Rightarrow> x = xa\n      | Fun g ts \\<Rightarrow>\n          (t, u) \\<in> NS \\<and>\n          \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n   | Fun f ss \\<Rightarrow>\n       if (t, u) \\<in> S then (True, True)\n       else if (t, u) \\<in> NS\n            then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                       ss ! i \\<succeq> u\n                 then (True, True)\n                 else case u of\n                      Var x \\<Rightarrow>\n                        (False, ssimple \\<and> large (f, length ss))\n                      | Fun g ts \\<Rightarrow>\n                          case prc (f, length ss) (g, length ts) of\n                          (prs, prns) \\<Rightarrow>\n                            if prns \\<and>\n                               (\\<forall>j\n   \\<in>set (\\<sigma> (g, length ts)).\n                                   t \\<succ> ts ! j)\n                            then if prs then (True, True)\n                                 else let ss' =\n      map ((!) ss) (\\<sigma> (f, length ss));\n    ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n    cg = c (g, length ts)\nin if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n   else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n        else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                            else (False, False)\n            else (False, False))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = Var x1 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "case (Var x)"], ["proof (state)\nthis:\n  t = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = Var x1 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "note wpo.simps[simp]"], ["proof (state)\nthis:\n  wpo ?s ?t =\n  (case ?s of\n   Var x \\<Rightarrow>\n     (False,\n      case ?t of Var xa \\<Rightarrow> x = xa\n      | Fun g ts \\<Rightarrow>\n          (?s, ?t) \\<in> NS \\<and>\n          \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n   | Fun f ss \\<Rightarrow>\n       if (?s, ?t) \\<in> S then (True, True)\n       else if (?s, ?t) \\<in> NS\n            then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                       ss ! i \\<succeq> ?t\n                 then (True, True)\n                 else case ?t of\n                      Var x \\<Rightarrow>\n                        (False, ssimple \\<and> large (f, length ss))\n                      | Fun g ts \\<Rightarrow>\n                          case prc (f, length ss) (g, length ts) of\n                          (prs, prns) \\<Rightarrow>\n                            if prns \\<and>\n                               (\\<forall>j\n   \\<in>set (\\<sigma> (g, length ts)).\n                                   ?s \\<succ> ts ! j)\n                            then if prs then (True, True)\n                                 else let ss' =\n      map ((!) ss) (\\<sigma> (f, length ss));\n    ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n    cg = c (g, length ts)\nin if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n   else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n        else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                            else (False, False)\n            else (False, False))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = Var x1 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 3. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "assume \"wpo_s t u\""], ["proof (state)\nthis:\n  t \\<succ> u\n\ngoal (3 subgoals):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 3. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "with Var"], ["proof (chain)\npicking this:\n  t = Var x\n  t \\<succ> u", "show \"wpo_s s u\""], ["proof (prove)\nusing this:\n  t = Var x\n  t \\<succ> u\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "by (cases u, auto)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "assume gr: \"wpo_s s t\" and ge: \"wpo_ns t u\""], ["proof (state)\nthis:\n  s \\<succ> t\n  t \\<succeq> u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "from wpo_s_imp_NS[OF gr]"], ["proof (chain)\npicking this:\n  (s, t) \\<in> NS", "have stA: \"(s,t) \\<in> NS\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> NS", "."], ["proof (state)\nthis:\n  (s, t) \\<in> NS\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "from wpo_ns_imp_NS[OF ge]"], ["proof (chain)\npicking this:\n  (t, u) \\<in> NS", "have tuA: \"(t,u) \\<in> NS\""], ["proof (prove)\nusing this:\n  (t, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. (t, u) \\<in> NS", "."], ["proof (state)\nthis:\n  (t, u) \\<in> NS\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "from trans_NS_point[OF stA tuA]"], ["proof (chain)\npicking this:\n  (s, u) \\<in> NS", "have suA: \"(s,u) \\<in> NS\""], ["proof (prove)\nusing this:\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. (s, u) \\<in> NS", "."], ["proof (state)\nthis:\n  (s, u) \\<in> NS\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "show \"wpo_s s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "case (Var y)"], ["proof (state)\nthis:\n  u = Var y\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "with ge \\<open>t = Var x\\<close>"], ["proof (chain)\npicking this:\n  t \\<succeq> u\n  t = Var x\n  u = Var y", "have \"t = u\""], ["proof (prove)\nusing this:\n  t \\<succeq> u\n  t = Var x\n  u = Var y\n\ngoal (1 subgoal):\n 1. t = u", "by auto"], ["proof (state)\nthis:\n  t = u\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "with gr"], ["proof (chain)\npicking this:\n  s \\<succ> t\n  t = u", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<succ> t\n  t = u\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "by auto"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "case (Fun h us)"], ["proof (state)\nthis:\n  u = Fun h us\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "let ?h = \"(h,length us)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from Fun ge Var"], ["proof (chain)\npicking this:\n  u = Fun h us\n  t \\<succeq> u\n  t = Var x", "have us: \"\\<sigma> ?h = []\" and pri: \"prl ?h\""], ["proof (prove)\nusing this:\n  u = Fun h us\n  t \\<succeq> u\n  t = Var x\n\ngoal (1 subgoal):\n 1. \\<sigma> (h, length us) = [] &&& prl (h, length us)", "by auto"], ["proof (state)\nthis:\n  \\<sigma> (h, length us) = []\n  prl (h, length us)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from gr Var"], ["proof (chain)\npicking this:\n  s \\<succ> t\n  t = Var x", "obtain f ss where s: \"s = Fun f ss\""], ["proof (prove)\nusing this:\n  s \\<succ> t\n  t = Var x\n\ngoal (1 subgoal):\n 1. (\\<And>f ss. s = Fun f ss \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s, auto)"], ["proof (state)\nthis:\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "let ?f = \"(f,length ss)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from s gr Var False"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  s \\<succ> t\n  t = Var x\n  \\<not> ((s, t) \\<in> S \\<or> (t, u) \\<in> S \\<or> (s, u) \\<in> S)", "obtain i where i: \"i \\<in> set (\\<sigma> ?f)\" and sit: \"ss ! i \\<succeq> t\""], ["proof (prove)\nusing this:\n  s = Fun f ss\n  s \\<succ> t\n  t = Var x\n  \\<not> ((s, t) \\<in> S \\<or> (t, u) \\<in> S \\<or> (s, u) \\<in> S)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> set (\\<sigma> (f, length ss));\n         ss ! i \\<succeq> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<succeq> t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from trans_NS_point[OF wpo_ns_imp_NS[OF sit] tuA]"], ["proof (chain)\npicking this:\n  (ss ! i, u) \\<in> NS", "have siu: \"(ss ! i,u) \\<in> NS\""], ["proof (prove)\nusing this:\n  (ss ! i, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. (ss ! i, u) \\<in> NS", "."], ["proof (state)\nthis:\n  (ss ! i, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from wpo_least_1[OF pri siu[unfolded Fun us] us]"], ["proof (chain)\npicking this:\n  ss ! i \\<succeq> Fun h us", "have \"ss ! i \\<succeq> u\""], ["proof (prove)\nusing this:\n  ss ! i \\<succeq> Fun h us\n\ngoal (1 subgoal):\n 1. ss ! i \\<succeq> u", "unfolding Fun us"], ["proof (prove)\nusing this:\n  ss ! i \\<succeq> Fun h us\n\ngoal (1 subgoal):\n 1. ss ! i \\<succeq> Fun h us", "."], ["proof (state)\nthis:\n  ss ! i \\<succeq> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "with i"], ["proof (chain)\npicking this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<succeq> u", "have \"\\<exists> i \\<in> set (\\<sigma> ?f). ss ! i \\<succeq> u\""], ["proof (prove)\nusing this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<succeq> u\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> u", "by auto"], ["proof (state)\nthis:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "with s suA"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  (s, u) \\<in> NS\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> u", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  (s, u) \\<in> NS\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> u\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "by simp"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "assume ge1: \"wpo_ns s t\" and ge2: \"wpo_ns t u\""], ["proof (state)\nthis:\n  s \\<succeq> t\n  t \\<succeq> u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "show \"wpo_ns s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> u", "proof (cases u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succeq> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "case (Var y)"], ["proof (state)\nthis:\n  u = Var y\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succeq> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "with ge2 \\<open>t = Var x\\<close>"], ["proof (chain)\npicking this:\n  t \\<succeq> u\n  t = Var x\n  u = Var y", "have \"t = u\""], ["proof (prove)\nusing this:\n  t \\<succeq> u\n  t = Var x\n  u = Var y\n\ngoal (1 subgoal):\n 1. t = u", "by auto"], ["proof (state)\nthis:\n  t = u\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succeq> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "with ge1"], ["proof (chain)\npicking this:\n  s \\<succeq> t\n  t = u", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<succeq> t\n  t = u\n\ngoal (1 subgoal):\n 1. s \\<succeq> u", "by auto"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "case (Fun h us)"], ["proof (state)\nthis:\n  u = Fun h us\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "let ?h = \"(h,length us)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from Fun ge2 Var"], ["proof (chain)\npicking this:\n  u = Fun h us\n  t \\<succeq> u\n  t = Var x", "have us: \"\\<sigma> ?h = []\" and pri: \"prl ?h\""], ["proof (prove)\nusing this:\n  u = Fun h us\n  t \\<succeq> u\n  t = Var x\n\ngoal (1 subgoal):\n 1. \\<sigma> (h, length us) = [] &&& prl (h, length us)", "by auto"], ["proof (state)\nthis:\n  \\<sigma> (h, length us) = []\n  prl (h, length us)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> u", "unfolding Fun us"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> Fun h us", "by (rule wpo_least_1[OF pri trans_NS_point[OF wpo_ns_imp_NS[OF ge1] \n                    wpo_ns_imp_NS[OF ge2[unfolded Fun us]]] us])"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "case (Fun g ts)"], ["proof (state)\nthis:\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?g = \"(g,length ts)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?ts = \"set (\\<sigma> ?g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?t = \"Fun g ts\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from Fun"], ["proof (chain)\npicking this:\n  t = Fun g ts", "have t: \"t = ?t\""], ["proof (prove)\nusing this:\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. t = Fun g ts", "."], ["proof (state)\nthis:\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Var x1 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "case (Var x)"], ["proof (state)\nthis:\n  s = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Var x1 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n 2. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 3. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "assume gr: \"wpo_s s t\""], ["proof (state)\nthis:\n  s \\<succ> t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 3. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "with Var Fun"], ["proof (chain)\npicking this:\n  s = Var x\n  t = Fun g ts\n  s \\<succ> t", "show \"wpo_s s u\""], ["proof (prove)\nusing this:\n  s = Var x\n  t = Fun g ts\n  s \\<succ> t\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "by (auto simp: wpo.simps)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "assume ge: \"wpo_ns s t\" and gr: \"wpo_s t u\""], ["proof (state)\nthis:\n  s \\<succeq> t\n  t \\<succ> u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "with Var Fun"], ["proof (chain)\npicking this:\n  s = Var x\n  t = Fun g ts\n  s \\<succeq> t\n  t \\<succ> u", "have pri: \"prl ?g\" and \"\\<sigma> ?g = []\""], ["proof (prove)\nusing this:\n  s = Var x\n  t = Fun g ts\n  s \\<succeq> t\n  t \\<succ> u\n\ngoal (1 subgoal):\n 1. prl (g, length ts) &&& \\<sigma> (g, length ts) = []", "by (auto simp: wpo.simps)"], ["proof (state)\nthis:\n  prl (g, length ts)\n  \\<sigma> (g, length ts) = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succ> u\n 2. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "with gr Fun"], ["proof (chain)\npicking this:\n  t \\<succ> u\n  t = Fun g ts\n  prl (g, length ts)\n  \\<sigma> (g, length ts) = []", "show \"wpo_s s u\""], ["proof (prove)\nusing this:\n  t \\<succ> u\n  t = Fun g ts\n  prl (g, length ts)\n  \\<sigma> (g, length ts) = []\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "using wpo_least_2[OF pri, of u] False"], ["proof (prove)\nusing this:\n  t \\<succ> u\n  t = Fun g ts\n  prl (g, length ts)\n  \\<sigma> (g, length ts) = []\n  \\<lbrakk>(Fun g ts, u) \\<notin> S; \\<sigma> (g, length ts) = []\\<rbrakk>\n  \\<Longrightarrow> \\<not> Fun g ts \\<succ> u\n  \\<not> ((s, t) \\<in> S \\<or> (t, u) \\<in> S \\<or> (s, u) \\<in> S)\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "by auto"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "assume ge1: \"wpo_ns s t\" and ge2: \"wpo_ns t u\""], ["proof (state)\nthis:\n  s \\<succeq> t\n  t \\<succeq> u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "with Var Fun"], ["proof (chain)\npicking this:\n  s = Var x\n  t = Fun g ts\n  s \\<succeq> t\n  t \\<succeq> u", "have pri: \"prl ?g\" and empty: \"\\<sigma> ?g = []\""], ["proof (prove)\nusing this:\n  s = Var x\n  t = Fun g ts\n  s \\<succeq> t\n  t \\<succeq> u\n\ngoal (1 subgoal):\n 1. prl (g, length ts) &&& \\<sigma> (g, length ts) = []", "by (auto simp: wpo.simps)"], ["proof (state)\nthis:\n  prl (g, length ts)\n  \\<sigma> (g, length ts) = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "from wpo_ns_imp_NS[OF ge1] Var Fun empty"], ["proof (chain)\npicking this:\n  (s, t) \\<in> NS\n  s = Var x\n  t = Fun g ts\n  \\<sigma> (g, length ts) = []", "have ns: \"(Var x, Fun g ts) \\<in> NS\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> NS\n  s = Var x\n  t = Fun g ts\n  \\<sigma> (g, length ts) = []\n\ngoal (1 subgoal):\n 1. (Var x, Fun g ts) \\<in> NS", "by simp"], ["proof (state)\nthis:\n  (Var x, Fun g ts) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<succeq> t; t \\<succeq> u\\<rbrakk>\n    \\<Longrightarrow> s \\<succeq> u", "show \"wpo_ns s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> u", "proof (rule wpo_least_3[OF pri ge2[unfolded Fun empty] \n                wpo_ns_imp_NS[OF ge1[unfolded Fun empty]] empty _ Var], rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (Fun g ts, x) \\<in> S \\<Longrightarrow> False", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (Fun g ts, x) \\<in> S \\<Longrightarrow> False", "assume S: \"(Fun g ts, v) \\<in> S\""], ["proof (state)\nthis:\n  (Fun g ts, v) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x. (Fun g ts, x) \\<in> S \\<Longrightarrow> False", "from SN_imp_minimal[OF SN, rule_format, of undefined UNIV]"], ["proof (chain)\npicking this:\n  undefined \\<in> UNIV \\<Longrightarrow>\n  \\<exists>z\\<in>UNIV.\n     \\<forall>y. (z, y) \\<in> S \\<longrightarrow> y \\<notin> UNIV", "obtain s where \"\\<And> u. (s,u) \\<notin> S\""], ["proof (prove)\nusing this:\n  undefined \\<in> UNIV \\<Longrightarrow>\n  \\<exists>z\\<in>UNIV.\n     \\<forall>y. (z, y) \\<in> S \\<longrightarrow> y \\<notin> UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        (\\<And>u. (s, u) \\<notin> S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (s, ?u) \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<And>x. (Fun g ts, x) \\<in> S \\<Longrightarrow> False", "with compat_NS_S_point[OF subst_NS[OF ns, of \"\\<lambda> _. s\"] subst_S[OF S, of \"\\<lambda> _. s\"]]"], ["proof (chain)\npicking this:\n  (Var x \\<cdot> (\\<lambda>_. s), v \\<cdot> (\\<lambda>_. s)) \\<in> S\n  (s, ?u) \\<notin> S", "show False"], ["proof (prove)\nusing this:\n  (Var x \\<cdot> (\\<lambda>_. s), v \\<cdot> (\\<lambda>_. s)) \\<in> S\n  (s, ?u) \\<notin> S\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "case (Fun f ss)"], ["proof (state)\nthis:\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?s = \"Fun f ss\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?f = \"(f,length ss)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?ss = \"set (\\<sigma> ?f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from Fun"], ["proof (chain)\npicking this:\n  s = Fun f ss", "have s: \"s = ?s\""], ["proof (prove)\nusing this:\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. s = Fun f ss", "."], ["proof (state)\nthis:\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?s1 = \"\\<exists> i \\<in> ?ss. ss ! i \\<succeq> t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?t1 = \"\\<exists> j \\<in> ?ts. ts ! j \\<succeq> u\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?ls = \"length ss\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?lt = \"length ts\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "obtain ps pns where prc: \"prc ?f ?g = (ps,pns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps pns.\n        prc (f, length ss) (g, length ts) = (ps, pns) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (f, length ss) (g, length ts) = (ps, pns)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?tran2 = \"\\<lambda> a b c.  \n           ((wpo_ns a b) \\<and> (wpo_s b c) \\<longrightarrow> (wpo_s a c)) \\<and>\n           ((wpo_s a b) \\<and> (wpo_ns b c) \\<longrightarrow> (wpo_s a c)) \\<and> \n           ((wpo_ns a b) \\<and> (wpo_ns b c) \\<longrightarrow> (wpo_ns a c)) \\<and> \n           ((wpo_s a b) \\<and> (wpo_s b c) \\<longrightarrow> (wpo_s a c))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from s"], ["proof (chain)\npicking this:\n  s = Fun f ss", "have \"\\<forall> s' \\<in> set ss. size s' < size s\""], ["proof (prove)\nusing this:\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. \\<forall>s'\\<in>set ss. size s' < size s", "by (auto simp: size_simps)"], ["proof (state)\nthis:\n  \\<forall>s'\\<in>set ss. size s' < size s\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "with ind"], ["proof (chain)\npicking this:\n  \\<forall>a aa b.\n     (size a < size s \\<longrightarrow>\n      (a \\<succeq> aa \\<and> aa \\<succ> b \\<longrightarrow>\n       a \\<succ> b) \\<and>\n      (a \\<succ> aa \\<and> aa \\<succeq> b \\<longrightarrow>\n       a \\<succ> b) \\<and>\n      (a \\<succeq> aa \\<and> aa \\<succeq> b \\<longrightarrow>\n       a \\<succeq> b)) \\<and>\n     (size a = size s \\<and>\n      (size aa < size t \\<or>\n       size aa = size t \\<and> size b < size u) \\<longrightarrow>\n      (a \\<succeq> aa \\<and> aa \\<succ> b \\<longrightarrow>\n       a \\<succ> b) \\<and>\n      (a \\<succ> aa \\<and> aa \\<succeq> b \\<longrightarrow>\n       a \\<succ> b) \\<and>\n      (a \\<succeq> aa \\<and> aa \\<succeq> b \\<longrightarrow>\n       a \\<succeq> b))\n  \\<forall>s'\\<in>set ss. size s' < size s", "have ind2: \"\\<And> s' t' u'. \\<lbrakk>s' \\<in> set ss\\<rbrakk> \\<Longrightarrow> ?tran s' t' u'\""], ["proof (prove)\nusing this:\n  \\<forall>a aa b.\n     (size a < size s \\<longrightarrow>\n      (a \\<succeq> aa \\<and> aa \\<succ> b \\<longrightarrow>\n       a \\<succ> b) \\<and>\n      (a \\<succ> aa \\<and> aa \\<succeq> b \\<longrightarrow>\n       a \\<succ> b) \\<and>\n      (a \\<succeq> aa \\<and> aa \\<succeq> b \\<longrightarrow>\n       a \\<succeq> b)) \\<and>\n     (size a = size s \\<and>\n      (size aa < size t \\<or>\n       size aa = size t \\<and> size b < size u) \\<longrightarrow>\n      (a \\<succeq> aa \\<and> aa \\<succ> b \\<longrightarrow>\n       a \\<succ> b) \\<and>\n      (a \\<succ> aa \\<and> aa \\<succeq> b \\<longrightarrow>\n       a \\<succ> b) \\<and>\n      (a \\<succeq> aa \\<and> aa \\<succeq> b \\<longrightarrow>\n       a \\<succeq> b))\n  \\<forall>s'\\<in>set ss. size s' < size s\n\ngoal (1 subgoal):\n 1. \\<And>s' t' u'.\n       s' \\<in> set ss \\<Longrightarrow>\n       (s' \\<succeq> t' \\<and> t' \\<succ> u' \\<longrightarrow>\n        s' \\<succ> u') \\<and>\n       (s' \\<succ> t' \\<and> t' \\<succeq> u' \\<longrightarrow>\n        s' \\<succ> u') \\<and>\n       (s' \\<succeq> t' \\<and> t' \\<succeq> u' \\<longrightarrow>\n        s' \\<succeq> u')", "by blast"], ["proof (state)\nthis:\n  ?s' \\<in> set ss \\<Longrightarrow>\n  (?s' \\<succeq> ?t' \\<and> ?t' \\<succ> ?u' \\<longrightarrow>\n   ?s' \\<succ> ?u') \\<and>\n  (?s' \\<succ> ?t' \\<and> ?t' \\<succeq> ?u' \\<longrightarrow>\n   ?s' \\<succ> ?u') \\<and>\n  (?s' \\<succeq> ?t' \\<and> ?t' \\<succeq> ?u' \\<longrightarrow>\n   ?s' \\<succeq> ?u')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "with wpo_s_imp_ns"], ["proof (chain)\npicking this:\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n  ?s' \\<in> set ss \\<Longrightarrow>\n  (?s' \\<succeq> ?t' \\<and> ?t' \\<succ> ?u' \\<longrightarrow>\n   ?s' \\<succ> ?u') \\<and>\n  (?s' \\<succ> ?t' \\<and> ?t' \\<succeq> ?u' \\<longrightarrow>\n   ?s' \\<succ> ?u') \\<and>\n  (?s' \\<succeq> ?t' \\<and> ?t' \\<succeq> ?u' \\<longrightarrow>\n   ?s' \\<succeq> ?u')", "have ind3: \"\\<And> us s' t' u'. \\<lbrakk>s' \\<in> set ss; t' \\<in> set ts\\<rbrakk> \\<Longrightarrow> ?tran2 s' t' u'\""], ["proof (prove)\nusing this:\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n  ?s' \\<in> set ss \\<Longrightarrow>\n  (?s' \\<succeq> ?t' \\<and> ?t' \\<succ> ?u' \\<longrightarrow>\n   ?s' \\<succ> ?u') \\<and>\n  (?s' \\<succ> ?t' \\<and> ?t' \\<succeq> ?u' \\<longrightarrow>\n   ?s' \\<succ> ?u') \\<and>\n  (?s' \\<succeq> ?t' \\<and> ?t' \\<succeq> ?u' \\<longrightarrow>\n   ?s' \\<succeq> ?u')\n\ngoal (1 subgoal):\n 1. \\<And>us s' t' u'.\n       \\<lbrakk>s' \\<in> set ss; t' \\<in> set ts\\<rbrakk>\n       \\<Longrightarrow> (s' \\<succeq> t' \\<and>\n                          t' \\<succ> u' \\<longrightarrow>\n                          s' \\<succ> u') \\<and>\n                         (s' \\<succ> t' \\<and>\n                          t' \\<succeq> u' \\<longrightarrow>\n                          s' \\<succ> u') \\<and>\n                         (s' \\<succeq> t' \\<and>\n                          t' \\<succeq> u' \\<longrightarrow>\n                          s' \\<succeq> u') \\<and>\n                         (s' \\<succ> t' \\<and>\n                          t' \\<succ> u' \\<longrightarrow>\n                          s' \\<succ> u')", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?s' \\<in> set ss; ?t' \\<in> set ts\\<rbrakk>\n  \\<Longrightarrow> (?s' \\<succeq> ?t' \\<and>\n                     ?t' \\<succ> ?u' \\<longrightarrow>\n                     ?s' \\<succ> ?u') \\<and>\n                    (?s' \\<succ> ?t' \\<and>\n                     ?t' \\<succeq> ?u' \\<longrightarrow>\n                     ?s' \\<succ> ?u') \\<and>\n                    (?s' \\<succeq> ?t' \\<and>\n                     ?t' \\<succeq> ?u' \\<longrightarrow>\n                     ?s' \\<succeq> ?u') \\<and>\n                    (?s' \\<succ> ?t' \\<and>\n                     ?t' \\<succ> ?u' \\<longrightarrow>\n                     ?s' \\<succ> ?u')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?mss = \"map (\\<lambda> i. ss ! i) (\\<sigma> ?f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "let ?mts = \"map (\\<lambda> j. ts ! j) (\\<sigma> ?g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "have ind3': \"\\<And> us s' t' u'. \\<lbrakk>s' \\<in> set ?mss; t' \\<in> set ?mts\\<rbrakk> \\<Longrightarrow> ?tran2 s' t' u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>us s' t' u'.\n       \\<lbrakk>s' \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n        t' \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)))\\<rbrakk>\n       \\<Longrightarrow> (s' \\<succeq> t' \\<and>\n                          t' \\<succ> u' \\<longrightarrow>\n                          s' \\<succ> u') \\<and>\n                         (s' \\<succ> t' \\<and>\n                          t' \\<succeq> u' \\<longrightarrow>\n                          s' \\<succ> u') \\<and>\n                         (s' \\<succeq> t' \\<and>\n                          t' \\<succeq> u' \\<longrightarrow>\n                          s' \\<succeq> u') \\<and>\n                         (s' \\<succ> t' \\<and>\n                          t' \\<succ> u' \\<longrightarrow>\n                          s' \\<succ> u')", "by (rule ind3, auto simp: status_aux)"], ["proof (state)\nthis:\n  \\<lbrakk>?s'1 \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n   ?t'1 \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (?s'1 \\<succeq> ?t'1 \\<and>\n                     ?t'1 \\<succ> ?u'1 \\<longrightarrow>\n                     ?s'1 \\<succ> ?u'1) \\<and>\n                    (?s'1 \\<succ> ?t'1 \\<and>\n                     ?t'1 \\<succeq> ?u'1 \\<longrightarrow>\n                     ?s'1 \\<succ> ?u'1) \\<and>\n                    (?s'1 \\<succeq> ?t'1 \\<and>\n                     ?t'1 \\<succeq> ?u'1 \\<longrightarrow>\n                     ?s'1 \\<succeq> ?u'1) \\<and>\n                    (?s'1 \\<succ> ?t'1 \\<and>\n                     ?t'1 \\<succ> ?u'1 \\<longrightarrow>\n                     ?s'1 \\<succ> ?u'1)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?s'1 \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n   ?t'1 \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (?s'1 \\<succeq> ?t'1 \\<and>\n                     ?t'1 \\<succ> ?u'1 \\<longrightarrow>\n                     ?s'1 \\<succ> ?u'1) \\<and>\n                    (?s'1 \\<succ> ?t'1 \\<and>\n                     ?t'1 \\<succeq> ?u'1 \\<longrightarrow>\n                     ?s'1 \\<succ> ?u'1) \\<and>\n                    (?s'1 \\<succeq> ?t'1 \\<and>\n                     ?t'1 \\<succeq> ?u'1 \\<longrightarrow>\n                     ?s'1 \\<succeq> ?u'1) \\<and>\n                    (?s'1 \\<succ> ?t'1 \\<and>\n                     ?t'1 \\<succ> ?u'1 \\<longrightarrow>\n                     ?s'1 \\<succ> ?u'1)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "assume ge1: \"s \\<succeq> t\" and ge2: \"t \\<succ> u\""], ["proof (state)\nthis:\n  s \\<succeq> t\n  t \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from wpo_ns_imp_NS[OF ge1]"], ["proof (chain)\npicking this:\n  (s, t) \\<in> NS", "have stA: \"(s,t) \\<in> NS\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> NS", "."], ["proof (state)\nthis:\n  (s, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from wpo_s_imp_NS[OF ge2]"], ["proof (chain)\npicking this:\n  (t, u) \\<in> NS", "have tuA: \"(t,u) \\<in> NS\""], ["proof (prove)\nusing this:\n  (t, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. (t, u) \\<in> NS", "."], ["proof (state)\nthis:\n  (t, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from trans_NS_point[OF stA tuA]"], ["proof (chain)\npicking this:\n  (s, u) \\<in> NS", "have suA: \"(s,u) \\<in> NS\""], ["proof (prove)\nusing this:\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. (s, u) \\<in> NS", "."], ["proof (state)\nthis:\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "have \"s \\<succ> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases ?s1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "case True"], ["proof (state)\nthis:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "from this"], ["proof (chain)\npicking this:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t", "obtain i where i: \"i \\<in> ?ss\" and ges: \"ss ! i \\<succeq> t\""], ["proof (prove)\nusing this:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> set (\\<sigma> (f, length ss));\n         ss ! i \\<succeq> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<succeq> t\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "from \\<sigma>E[OF i]"], ["proof (chain)\npicking this:\n  ss ! i \\<in> set ss", "have s': \"ss ! i \\<in> set ss\""], ["proof (prove)\nusing this:\n  ss ! i \\<in> set ss\n\ngoal (1 subgoal):\n 1. ss ! i \\<in> set ss", "."], ["proof (state)\nthis:\n  ss ! i \\<in> set ss\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "with i s s' ind2[of \"ss ! i\" t u, simplified] ges ge2"], ["proof (chain)\npicking this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  s = Fun f ss\n  ss ! i \\<in> set ss\n  ss ! i \\<in> set ss \\<Longrightarrow>\n  (ss ! i \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n   ss ! i \\<succ> u) \\<and>\n  (ss ! i \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n   ss ! i \\<succ> u) \\<and>\n  (ss ! i \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow>\n   ss ! i \\<succeq> u)\n  ss ! i \\<succeq> t\n  t \\<succ> u\n  ss ! i \\<in> set ss", "have \"ss ! i \\<succ> u\""], ["proof (prove)\nusing this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  s = Fun f ss\n  ss ! i \\<in> set ss\n  ss ! i \\<in> set ss \\<Longrightarrow>\n  (ss ! i \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n   ss ! i \\<succ> u) \\<and>\n  (ss ! i \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n   ss ! i \\<succ> u) \\<and>\n  (ss ! i \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow>\n   ss ! i \\<succeq> u)\n  ss ! i \\<succeq> t\n  t \\<succ> u\n  ss ! i \\<in> set ss\n\ngoal (1 subgoal):\n 1. ss ! i \\<succ> u", "by auto"], ["proof (state)\nthis:\n  ss ! i \\<succ> u\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "then"], ["proof (chain)\npicking this:\n  ss ! i \\<succ> u", "have \"ss ! i \\<succeq> u\""], ["proof (prove)\nusing this:\n  ss ! i \\<succ> u\n\ngoal (1 subgoal):\n 1. ss ! i \\<succeq> u", "by (rule wpo_s_imp_ns)"], ["proof (state)\nthis:\n  ss ! i \\<succeq> u\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "with i s suA"], ["proof (chain)\npicking this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  s = Fun f ss\n  (s, u) \\<in> NS\n  ss ! i \\<succeq> u", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  s = Fun f ss\n  (s, u) \\<in> NS\n  ss ! i \\<succeq> u\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "by (cases u, auto simp: wpo.simps)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases ?t1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n       ts ! j \\<succeq> u \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "case True"], ["proof (state)\nthis:\n  \\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u\n\ngoal (2 subgoals):\n 1. \\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n       ts ! j \\<succeq> u \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from this"], ["proof (chain)\npicking this:\n  \\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u", "obtain j where j: \"j \\<in> ?ts\" and ges: \"ts ! j \\<succeq> u\""], ["proof (prove)\nusing this:\n  \\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<in> set (\\<sigma> (g, length ts));\n         ts ! j \\<succeq> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<in> set (\\<sigma> (g, length ts))\n  ts ! j \\<succeq> u\n\ngoal (2 subgoals):\n 1. \\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n       ts ! j \\<succeq> u \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from \\<sigma>E[OF j]"], ["proof (chain)\npicking this:\n  ts ! j \\<in> set ts", "have t': \"ts ! j \\<in> set ts\""], ["proof (prove)\nusing this:\n  ts ! j \\<in> set ts\n\ngoal (1 subgoal):\n 1. ts ! j \\<in> set ts", "by auto"], ["proof (state)\nthis:\n  ts ! j \\<in> set ts\n\ngoal (2 subgoals):\n 1. \\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n       ts ! j \\<succeq> u \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from j t' t stS False ge1 s"], ["proof (chain)\npicking this:\n  j \\<in> set (\\<sigma> (g, length ts))\n  ts ! j \\<in> set ts\n  t = Fun g ts\n  (s, t) \\<notin> S\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  s \\<succeq> t\n  s = Fun f ss", "have ge1': \"s \\<succ> ts ! j\""], ["proof (prove)\nusing this:\n  j \\<in> set (\\<sigma> (g, length ts))\n  ts ! j \\<in> set ts\n  t = Fun g ts\n  (s, t) \\<notin> S\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  s \\<succeq> t\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. s \\<succ> ts ! j", "unfolding wpo.simps[of s t]"], ["proof (prove)\nusing this:\n  j \\<in> set (\\<sigma> (g, length ts))\n  ts ! j \\<in> set ts\n  t = Fun g ts\n  (s, t) \\<notin> S\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  snd (case s of\n       Var x \\<Rightarrow>\n         (False,\n          case t of Var xa \\<Rightarrow> x = xa\n          | Fun g ts \\<Rightarrow>\n              (s, t) \\<in> NS \\<and>\n              \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n       | Fun f ss \\<Rightarrow>\n           if (s, t) \\<in> S then (True, True)\n           else if (s, t) \\<in> NS\n                then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                           ss ! i \\<succeq> t\n                     then (True, True)\n                     else case t of\n                          Var x \\<Rightarrow>\n                            (False, ssimple \\<and> large (f, length ss))\n                          | Fun g ts \\<Rightarrow>\n                              case prc (f, length ss) (g, length ts) of\n                              (prs, prns) \\<Rightarrow>\n                                if prns \\<and>\n                                   (\\<forall>j\n       \\<in>set (\\<sigma> (g, length ts)).\n s \\<succ> ts ! j)\n                                then if prs then (True, True)\n                                     else let ss' =\n          map ((!) ss) (\\<sigma> (f, length ss));\n        ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n        cg = c (g, length ts)\n    in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n       else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n            else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                  length ts' = 0)\n                                else (False, False)\n                else (False, False))\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. s \\<succ> ts ! j", "by (auto split: if_splits prod.splits)"], ["proof (state)\nthis:\n  s \\<succ> ts ! j\n\ngoal (2 subgoals):\n 1. \\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n       ts ! j \\<succeq> u \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from t' s t ge1' ges ind[rule_format, of s \"ts ! j\" u, simplified]"], ["proof (chain)\npicking this:\n  ts ! j \\<in> set ts\n  s = Fun f ss\n  t = Fun g ts\n  s \\<succ> ts ! j\n  ts ! j \\<succeq> u\n  size (ts ! j) < size t \\<longrightarrow>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succ> u \\<longrightarrow>\n   s \\<succ> u) \\<and>\n  (s \\<succ> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   s \\<succ> u) \\<and>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   s \\<succeq> u)", "show \"s \\<succ> u\""], ["proof (prove)\nusing this:\n  ts ! j \\<in> set ts\n  s = Fun f ss\n  t = Fun g ts\n  s \\<succ> ts ! j\n  ts ! j \\<succeq> u\n  size (ts ! j) < size t \\<longrightarrow>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succ> u \\<longrightarrow>\n   s \\<succ> u) \\<and>\n  (s \\<succ> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   s \\<succ> u) \\<and>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   s \\<succeq> u)\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "using suA size_simps supt.intros"], ["proof (prove)\nusing this:\n  ts ! j \\<in> set ts\n  s = Fun f ss\n  t = Fun g ts\n  s \\<succ> ts ! j\n  ts ! j \\<succeq> u\n  size (ts ! j) < size t \\<longrightarrow>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succ> u \\<longrightarrow>\n   s \\<succ> u) \\<and>\n  (s \\<succ> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   s \\<succ> u) \\<and>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   s \\<succeq> u)\n  (s, u) \\<in> NS\n  ?t \\<in> set ?ts \\<Longrightarrow> size ?t < Suc (size_list size ?ts)\n  ?t \\<in> set ?ts \\<Longrightarrow>\n  size ?t < Suc (Suc (size ?s + size_list size ?ts))\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?x < Suc (size_list size ?xs)\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?y < Suc (size_list size ?ys)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<rhd> ?t; size ?t < size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t < Suc (size_list size ?ss)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<unrhd> ?t; size ?t \\<le> size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t \\<le> Suc (size_list size ?ss)\n  ?s \\<in> set ?ss \\<Longrightarrow> Fun ?f ?ss \\<rhd> ?s\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<rhd> ?t\\<rbrakk>\n  \\<Longrightarrow> Fun ?f ?ss \\<rhd> ?t\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  ts ! j \\<in> set ts\n  s = Fun f ss\n  t = Fun g ts\n  s \\<succ> ts ! j\n  ts ! j \\<succeq> u\n  size (ts ! j) < size t \\<longrightarrow>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succ> u \\<longrightarrow>\n   fst (case s of\n        Var x \\<Rightarrow>\n          (False,\n           case u of Var xa \\<Rightarrow> x = xa\n           | Fun g ts \\<Rightarrow>\n               (s, u) \\<in> NS \\<and>\n               \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n        | Fun f ss \\<Rightarrow>\n            if (s, u) \\<in> S then (True, True)\n            else if (s, u) \\<in> NS\n                 then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                            ss ! i \\<succeq> u\n                      then (True, True)\n                      else case u of\n                           Var x \\<Rightarrow>\n                             (False, ssimple \\<and> large (f, length ss))\n                           | Fun g ts \\<Rightarrow>\n                               case prc (f, length ss) (g, length ts) of\n                               (prs, prns) \\<Rightarrow>\n                                 if prns \\<and>\n                                    (\\<forall>j\n        \\<in>set (\\<sigma> (g, length ts)).\n  s \\<succ> ts ! j)\n                                 then if prs then (True, True)\nelse let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n         ts' = map ((!) ts) (\\<sigma> (g, length ts));\n         cf = c (f, length ss); cg = c (g, length ts)\n     in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n        else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n             else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                   length ts' = 0)\n                                 else (False, False)\n                 else (False, False))) \\<and>\n  (s \\<succ> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   fst (case s of\n        Var x \\<Rightarrow>\n          (False,\n           case u of Var xa \\<Rightarrow> x = xa\n           | Fun g ts \\<Rightarrow>\n               (s, u) \\<in> NS \\<and>\n               \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n        | Fun f ss \\<Rightarrow>\n            if (s, u) \\<in> S then (True, True)\n            else if (s, u) \\<in> NS\n                 then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                            ss ! i \\<succeq> u\n                      then (True, True)\n                      else case u of\n                           Var x \\<Rightarrow>\n                             (False, ssimple \\<and> large (f, length ss))\n                           | Fun g ts \\<Rightarrow>\n                               case prc (f, length ss) (g, length ts) of\n                               (prs, prns) \\<Rightarrow>\n                                 if prns \\<and>\n                                    (\\<forall>j\n        \\<in>set (\\<sigma> (g, length ts)).\n  s \\<succ> ts ! j)\n                                 then if prs then (True, True)\nelse let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n         ts' = map ((!) ts) (\\<sigma> (g, length ts));\n         cf = c (f, length ss); cg = c (g, length ts)\n     in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n        else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n             else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                   length ts' = 0)\n                                 else (False, False)\n                 else (False, False))) \\<and>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   snd (case s of\n        Var x \\<Rightarrow>\n          (False,\n           case u of Var xa \\<Rightarrow> x = xa\n           | Fun g ts \\<Rightarrow>\n               (s, u) \\<in> NS \\<and>\n               \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n        | Fun f ss \\<Rightarrow>\n            if (s, u) \\<in> S then (True, True)\n            else if (s, u) \\<in> NS\n                 then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                            ss ! i \\<succeq> u\n                      then (True, True)\n                      else case u of\n                           Var x \\<Rightarrow>\n                             (False, ssimple \\<and> large (f, length ss))\n                           | Fun g ts \\<Rightarrow>\n                               case prc (f, length ss) (g, length ts) of\n                               (prs, prns) \\<Rightarrow>\n                                 if prns \\<and>\n                                    (\\<forall>j\n        \\<in>set (\\<sigma> (g, length ts)).\n  s \\<succ> ts ! j)\n                                 then if prs then (True, True)\nelse let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n         ts' = map ((!) ts) (\\<sigma> (g, length ts));\n         cf = c (f, length ss); cg = c (g, length ts)\n     in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n        else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n             else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                   length ts' = 0)\n                                 else (False, False)\n                 else (False, False)))\n  (s, u) \\<in> NS\n  ?t \\<in> set ?ts \\<Longrightarrow> size ?t < Suc (size_list size ?ts)\n  ?t \\<in> set ?ts \\<Longrightarrow>\n  size ?t < Suc (Suc (size ?s + size_list size ?ts))\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?x < Suc (size_list size ?xs)\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?y < Suc (size_list size ?ys)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<rhd> ?t; size ?t < size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t < Suc (size_list size ?ss)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<unrhd> ?t; size ?t \\<le> size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t \\<le> Suc (size_list size ?ss)\n  ?s \\<in> set ?ss \\<Longrightarrow> Fun ?f ?ss \\<rhd> ?s\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<rhd> ?t\\<rbrakk>\n  \\<Longrightarrow> Fun ?f ?ss \\<rhd> ?t\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from t this ge2 tuS"], ["proof (chain)\npicking this:\n  t = Fun g ts\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  t \\<succ> u\n  (t, u) \\<notin> S", "obtain h us where u: \"u = Fun h us\""], ["proof (prove)\nusing this:\n  t = Fun g ts\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  t \\<succ> u\n  (t, u) \\<notin> S\n\ngoal (1 subgoal):\n 1. (\\<And>h us. u = Fun h us \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases u, auto simp: wpo.simps split: if_splits)"], ["proof (state)\nthis:\n  u = Fun h us\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "let ?u = \"Fun h us\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "let ?h = \"(h,length us)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "let ?us = \"set (\\<sigma> ?h)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "let ?mus = \"map (\\<lambda> k. us ! k) (\\<sigma> ?h)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from s t u ge1 ge2"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  t = Fun g ts\n  u = Fun h us\n  s \\<succeq> t\n  t \\<succ> u", "have ge1: \"?s \\<succeq> ?t\" and ge2: \"?t \\<succ> ?u\""], ["proof (prove)\nusing this:\n  s = Fun f ss\n  t = Fun g ts\n  u = Fun h us\n  s \\<succeq> t\n  t \\<succ> u\n\ngoal (1 subgoal):\n 1. Fun f ss \\<succeq> Fun g ts &&& Fun g ts \\<succ> Fun h us", "by auto"], ["proof (state)\nthis:\n  Fun f ss \\<succeq> Fun g ts\n  Fun g ts \\<succ> Fun h us\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from stA stS s t"], ["proof (chain)\npicking this:\n  (s, t) \\<in> NS\n  (s, t) \\<notin> S\n  s = Fun f ss\n  t = Fun g ts", "have stAS: \"((?s,?t) \\<in> S) = False\" \"((?s,?t) \\<in> NS) = True\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> NS\n  (s, t) \\<notin> S\n  s = Fun f ss\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. ((Fun f ss, Fun g ts) \\<in> S) = False &&&\n    ((Fun f ss, Fun g ts) \\<in> NS) = True", "by auto"], ["proof (state)\nthis:\n  ((Fun f ss, Fun g ts) \\<in> S) = False\n  ((Fun f ss, Fun g ts) \\<in> NS) = True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from tuA tuS t u"], ["proof (chain)\npicking this:\n  (t, u) \\<in> NS\n  (t, u) \\<notin> S\n  t = Fun g ts\n  u = Fun h us", "have tuAS: \"((?t,?u) \\<in> S) = False\" \"((?t,?u) \\<in> NS) = True\""], ["proof (prove)\nusing this:\n  (t, u) \\<in> NS\n  (t, u) \\<notin> S\n  t = Fun g ts\n  u = Fun h us\n\ngoal (1 subgoal):\n 1. ((Fun g ts, Fun h us) \\<in> S) = False &&&\n    ((Fun g ts, Fun h us) \\<in> NS) = True", "by auto"], ["proof (state)\nthis:\n  ((Fun g ts, Fun h us) \\<in> S) = False\n  ((Fun g ts, Fun h us) \\<in> NS) = True\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "note ge1 = ge1[unfolded wpo.simps[of ?s ?t] stAS, simplified]"], ["proof (state)\nthis:\n  snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "note ge2 = ge2[unfolded wpo.simps[of ?t ?u] tuAS, simplified]"], ["proof (state)\nthis:\n  fst (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "obtain ps2 pns2 where prc2: \"prc ?g ?h = (ps2,pns2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps2 pns2.\n        prc (g, length ts) (h, length us) = (ps2, pns2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "obtain ps3 pns3 where prc3: \"prc ?f ?h = (ps3,pns3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps3 pns3.\n        prc (f, length ss) (h, length us) = (ps3, pns3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from \\<open>\\<not> ?s1\\<close> t ge1"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))", "have st': \"\\<forall> j \\<in> ?ts. ?s \\<succ> ts ! j\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j", "by (auto split: if_splits prod.splits)"], ["proof (state)\nthis:\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from \\<open>\\<not> ?t1\\<close> t u ge2 tuS"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  t = Fun g ts\n  u = Fun h us\n  fst (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  (t, u) \\<notin> S", "have tu': \"\\<forall> k \\<in> ?us. ?t \\<succ> us ! k\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  t = Fun g ts\n  u = Fun h us\n  fst (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  (t, u) \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k", "by (auto split: if_splits prod.splits)"], ["proof (state)\nthis:\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from \\<open>\\<not> ?s1\\<close> s t ge1 stS st'"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  s = Fun f ss\n  t = Fun g ts\n  snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  (s, t) \\<notin> S\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j", "have fg: \"pns\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  s = Fun f ss\n  t = Fun g ts\n  snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  (s, t) \\<notin> S\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n\ngoal (1 subgoal):\n 1. pns", "by (cases ?thesis, auto simp: prc)"], ["proof (state)\nthis:\n  pns\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from \\<open>\\<not> ?t1\\<close> u ge2 tu'"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  u = Fun h us\n  fst (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k", "have gh: \"pns2\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  u = Fun h us\n  fst (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n\ngoal (1 subgoal):\n 1. pns2", "by (cases ?thesis, auto simp: prc2)"], ["proof (state)\nthis:\n  pns2\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from \\<open>\\<not> ?s1\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)", "have \"?s1 = False\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n\ngoal (1 subgoal):\n 1. (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t) =\n    False", "by simp"], ["proof (state)\nthis:\n  (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t) = False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "note ge1 = ge1[unfolded this[unfolded t] if_False term.simps prc split]"], ["proof (state)\nthis:\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from \\<open>\\<not> ?t1\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)", "have \"?t1 = False\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n\ngoal (1 subgoal):\n 1. (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u) =\n    False", "by simp"], ["proof (state)\nthis:\n  (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u) = False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "note ge2 = ge2[unfolded this[unfolded u] if_False term.simps prc2 split]"], ["proof (state)\nthis:\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "note compat = prc_compat[OF prc prc2 prc3]"], ["proof (state)\nthis:\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from fg gh compat"], ["proof (chain)\npicking this:\n  pns\n  pns2\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)", "have fh: \"pns3\""], ["proof (prove)\nusing this:\n  pns\n  pns2\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)\n\ngoal (1 subgoal):\n 1. pns3", "by simp"], ["proof (state)\nthis:\n  pns3\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "{"], ["proof (state)\nthis:\n  pns3\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "assume k: \"k \\<in> ?us\""], ["proof (state)\nthis:\n  k \\<in> set (\\<sigma> (h, length us))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from \\<sigma>E[OF this]"], ["proof (chain)\npicking this:\n  us ! k \\<in> set us", "have \"size (us ! k) < size u\""], ["proof (prove)\nusing this:\n  us ! k \\<in> set us\n\ngoal (1 subgoal):\n 1. size (us ! k) < size u", "unfolding u"], ["proof (prove)\nusing this:\n  us ! k \\<in> set us\n\ngoal (1 subgoal):\n 1. size (us ! k) < size (Fun h us)", "using size_simps"], ["proof (prove)\nusing this:\n  us ! k \\<in> set us\n  ?t \\<in> set ?ts \\<Longrightarrow> size ?t < Suc (size_list size ?ts)\n  ?t \\<in> set ?ts \\<Longrightarrow>\n  size ?t < Suc (Suc (size ?s + size_list size ?ts))\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?x < Suc (size_list size ?xs)\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?y < Suc (size_list size ?ys)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<rhd> ?t; size ?t < size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t < Suc (size_list size ?ss)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<unrhd> ?t; size ?t \\<le> size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t \\<le> Suc (size_list size ?ss)\n\ngoal (1 subgoal):\n 1. size (us ! k) < size (Fun h us)", "by auto"], ["proof (state)\nthis:\n  size (us ! k) < size u\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "with tu'[folded t] \\<open>s \\<succeq> t\\<close> \n                  ind[rule_format, of s t \"us ! k\"] k"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). t \\<succ> us ! k\n  s \\<succeq> t\n  (size s < size s \\<longrightarrow>\n   (s \\<succeq> t \\<and> t \\<succ> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succ> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succeq> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succeq> us ! k)) \\<and>\n  (size s = size s \\<and>\n   (size t < size t \\<or>\n    size t = size t \\<and> size (us ! k) < size u) \\<longrightarrow>\n   (s \\<succeq> t \\<and> t \\<succ> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succ> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succeq> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succeq> us ! k))\n  k \\<in> set (\\<sigma> (h, length us))\n  size (us ! k) < size u", "have \"s \\<succ> us ! k\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). t \\<succ> us ! k\n  s \\<succeq> t\n  (size s < size s \\<longrightarrow>\n   (s \\<succeq> t \\<and> t \\<succ> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succ> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succeq> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succeq> us ! k)) \\<and>\n  (size s = size s \\<and>\n   (size t < size t \\<or>\n    size t = size t \\<and> size (us ! k) < size u) \\<longrightarrow>\n   (s \\<succeq> t \\<and> t \\<succ> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succ> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succeq> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succeq> us ! k))\n  k \\<in> set (\\<sigma> (h, length us))\n  size (us ! k) < size u\n\ngoal (1 subgoal):\n 1. s \\<succ> us ! k", "by blast"], ["proof (state)\nthis:\n  s \\<succ> us ! k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "}"], ["proof (state)\nthis:\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "note su' = this"], ["proof (state)\nthis:\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases ps3)"], ["proof (state)\ngoal (2 subgoals):\n 1. ps3 \\<Longrightarrow> s \\<succ> u\n 2. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "case True"], ["proof (state)\nthis:\n  ps3\n\ngoal (2 subgoals):\n 1. ps3 \\<Longrightarrow> s \\<succ> u\n 2. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "with su' s u fh prc3 suA"], ["proof (chain)\npicking this:\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  (s, u) \\<in> NS\n  ps3", "show ?thesis"], ["proof (prove)\nusing this:\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  (s, u) \\<in> NS\n  ps3\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "by (auto simp: wpo.simps)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "case False"], ["proof (state)\nthis:\n  \\<not> ps3\n\ngoal (1 subgoal):\n 1. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "from False fg gh compat"], ["proof (chain)\npicking this:\n  \\<not> ps3\n  pns\n  pns2\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)", "have nfg: \"\\<not> ps\" and ngh: \"\\<not> ps2\" and *: \"ps = False\" \"ps2 = False\""], ["proof (prove)\nusing this:\n  \\<not> ps3\n  pns\n  pns2\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)\n\ngoal (1 subgoal):\n 1. \\<not> ps &&& \\<not> ps2 &&& ps = False &&& ps2 = False", "by blast+"], ["proof (state)\nthis:\n  \\<not> ps\n  \\<not> ps2\n  ps = False\n  ps2 = False\n\ngoal (1 subgoal):\n 1. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "note ge1 = ge1[unfolded * if_False]"], ["proof (state)\nthis:\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "note ge2 = ge2[unfolded * if_False]"], ["proof (state)\nthis:\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases \"c ?f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (f, length ss) = Mul \\<Longrightarrow> s \\<succ> u", "case Mul"], ["proof (state)\nthis:\n  c (f, length ss) = Mul\n\ngoal (2 subgoals):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (f, length ss) = Mul \\<Longrightarrow> s \\<succ> u", "note cf = this"], ["proof (state)\nthis:\n  c (f, length ss) = Mul\n\ngoal (2 subgoals):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (f, length ss) = Mul \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases \"c ?g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "case Mul"], ["proof (state)\nthis:\n  c (g, length ts) = Mul\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "note cg = this"], ["proof (state)\nthis:\n  c (g, length ts) = Mul\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases \"c ?h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "case Mul"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "from ge1[unfolded cf cg]"], ["proof (chain)\npicking this:\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = Mul;\n                cg = Mul\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))", "have mul1: \"snd (mul_ext wpo ?mss ?mts)\""], ["proof (prove)\nusing this:\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = Mul;\n                cg = Mul\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts))))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "from ge2[unfolded cg ch]"], ["proof (chain)\npicking this:\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us)); cf = Mul;\n                cg = Mul\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))", "have mul2: \"fst (mul_ext wpo ?mts ?mus)\""], ["proof (prove)\nusing this:\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us)); cf = Mul;\n                cg = Mul\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. fst (mul_ext wpo (map ((!) ts) (\\<sigma> (g, length ts)))\n          (map ((!) us) (\\<sigma> (h, length us))))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  fst (mul_ext wpo (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "from mul1 mul2 mul_ext_compat[OF ind3', of ?mss ?mts ?mus]"], ["proof (chain)\npicking this:\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n  fst (mul_ext wpo (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n  \\<lbrakk>\\<And>s t u.\n              \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n               t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n               u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n              \\<Longrightarrow> ?u'6 s\n                                \\<in> set\n (map ((!) ss) (\\<sigma> (f, length ss)));\n   \\<And>s t u.\n      \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n       t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n       u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n      \\<Longrightarrow> ?u'6 t\n                        \\<in> set (map ((!) ts)\n                                    (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us)))))", "have \"fst (mul_ext wpo ?mss ?mus)\""], ["proof (prove)\nusing this:\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n  fst (mul_ext wpo (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n  \\<lbrakk>\\<And>s t u.\n              \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n               t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n               u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n              \\<Longrightarrow> ?u'6 s\n                                \\<in> set\n (map ((!) ss) (\\<sigma> (f, length ss)));\n   \\<And>s t u.\n      \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n       t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n       u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n      \\<Longrightarrow> ?u'6 t\n                        \\<in> set (map ((!) ts)\n                                    (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us)))))\n\ngoal (1 subgoal):\n 1. fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) us) (\\<sigma> (h, length us))))", "by auto"], ["proof (state)\nthis:\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "with s u fh su' prc3 cf ch suA"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by simp"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "case Lex"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from gh u ge2 tu' prc2 ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Lex", "have us_e: \"?mus = []\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from gh u ge2 tu' prc2 ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Lex", "have ts_ne: \"?mts \\<noteq> []\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. map ((!) ts) (\\<sigma> (g, length ts)) \\<noteq> []", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  map ((!) ts) (\\<sigma> (g, length ts)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from ns_mul_ext_bottom_uniqueness[of \"mset ?mts\"]"], ["proof (chain)\npicking this:\n  ({#}, mset (map ((!) ts) (\\<sigma> (g, length ts))))\n  \\<in> ns_mul_ext ?ns ?s \\<Longrightarrow>\n  mset (map ((!) ts) (\\<sigma> (g, length ts))) = {#}", "have \"\\<And>f. snd (mul_ext f [] ?mts) \\<Longrightarrow> ?mts = []\""], ["proof (prove)\nusing this:\n  ({#}, mset (map ((!) ts) (\\<sigma> (g, length ts))))\n  \\<in> ns_mul_ext ?ns ?s \\<Longrightarrow>\n  mset (map ((!) ts) (\\<sigma> (g, length ts))) = {#}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       snd (mul_ext f []\n             (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n       map ((!) ts) (\\<sigma> (g, length ts)) = []", "unfolding mul_ext_def"], ["proof (prove)\nusing this:\n  ({#}, mset (map ((!) ts) (\\<sigma> (g, length ts))))\n  \\<in> ns_mul_ext ?ns ?s \\<Longrightarrow>\n  mset (map ((!) ts) (\\<sigma> (g, length ts))) = {#}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       snd (let s = {(x, y). fst (f x y)}; ns = {(x, y). snd (f x y)}\n            in ((mset [], mset (map ((!) ts) (\\<sigma> (g, length ts))))\n                \\<in> s_mul_ext ns s,\n                (mset [], mset (map ((!) ts) (\\<sigma> (g, length ts))))\n                \\<in> ns_mul_ext ns s)) \\<Longrightarrow>\n       map ((!) ts) (\\<sigma> (g, length ts)) = []", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  snd (mul_ext ?f2 []\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "with ts_ne fg \\<open>\\<not> ?s1\\<close> t ge1 st' prc nfg cf cg"], ["proof (chain)\npicking this:\n  map ((!) ts) (\\<sigma> (g, length ts)) \\<noteq> []\n  pns\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  snd (mul_ext ?f2 []\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  map ((!) ts) (\\<sigma> (g, length ts)) = []", "have ss_ne: \"?mss \\<noteq> []\""], ["proof (prove)\nusing this:\n  map ((!) ts) (\\<sigma> (g, length ts)) \\<noteq> []\n  pns\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  snd (mul_ext ?f2 []\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n\ngoal (1 subgoal):\n 1. map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "by (cases ss) auto"], ["proof (state)\nthis:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from us_e ss_ne s u fh su' prc3 cf cg ch suA"], ["proof (chain)\npicking this:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS", "show ?thesis"], ["proof (prove)\nusing this:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by simp"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "case Lex"], ["proof (state)\nthis:\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "note cg = this"], ["proof (state)\nthis:\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "from fg \\<open>\\<not> ?s1\\<close> t ge1 st' prc nfg cf cg"], ["proof (chain)\npicking this:\n  pns\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex", "have ts_e: \"?mts = []\""], ["proof (prove)\nusing this:\n  pns\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. map ((!) ts) (\\<sigma> (g, length ts)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "with gh \\<open>\\<not> ?t1\\<close> u ge2 tu' prc2 ngh cg"], ["proof (chain)\npicking this:\n  pns2\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n  \\<not> ps2\n  c (g, length ts) = Lex\n  map ((!) ts) (\\<sigma> (g, length ts)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  pns2\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n  \\<not> ps2\n  c (g, length ts) = Lex\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "by (cases \"c ?h\") (simp_all add: lex_ext_least_2)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u", "case Lex"], ["proof (state)\nthis:\n  c (f, length ss) = Lex\n\ngoal (1 subgoal):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u", "note cf = this"], ["proof (state)\nthis:\n  c (f, length ss) = Lex\n\ngoal (1 subgoal):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases \"c ?g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "case Mul"], ["proof (state)\nthis:\n  c (g, length ts) = Mul\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "note cg = this"], ["proof (state)\nthis:\n  c (g, length ts) = Mul\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "from fg \\<open>\\<not> ?s1\\<close> t ge1 st' prc nfg cf cg"], ["proof (chain)\npicking this:\n  pns\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul", "have ts_e: \"?mts = []\""], ["proof (prove)\nusing this:\n  pns\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n\ngoal (1 subgoal):\n 1. map ((!) ts) (\\<sigma> (g, length ts)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "with gh \\<open>\\<not> ?t1\\<close> u ge2 tu' prc2 ngh cg"], ["proof (chain)\npicking this:\n  pns2\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n  \\<not> ps2\n  c (g, length ts) = Mul\n  map ((!) ts) (\\<sigma> (g, length ts)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  pns2\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n  \\<not> ps2\n  c (g, length ts) = Mul\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "by (cases \"c ?h\") (auto simp: Let_def s_mul_ext_def s_mul_ext_bottom mul_ext_def elim: mult2_alt_sE)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "case Lex"], ["proof (state)\nthis:\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "note cg = this"], ["proof (state)\nthis:\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases \"c ?h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "case Mul"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "from gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Mul", "have us_e: \"?mus = []\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "from gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Mul", "have ts_ne: \"?mts \\<noteq> []\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n\ngoal (1 subgoal):\n 1. map ((!) ts) (\\<sigma> (g, length ts)) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  map ((!) ts) (\\<sigma> (g, length ts)) \\<noteq> []\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "from lex_ext_iff[of _ _ \"[]\" ?mts]"], ["proof (chain)\npicking this:\n  lex_ext ?f ?m [] (map ((!) ts) (\\<sigma> (g, length ts))) =\n  ((length [] = length (map ((!) ts) (\\<sigma> (g, length ts))) \\<or>\n    length (map ((!) ts) (\\<sigma> (g, length ts))) \\<le> ?m) \\<and>\n   ((\\<exists>i<length [].\n        i < length (map ((!) ts) (\\<sigma> (g, length ts))) \\<and>\n        (\\<forall>j<i.\n            snd (?f ([] ! j)\n                  (map ((!) ts) (\\<sigma> (g, length ts)) ! j))) \\<and>\n        fst (?f ([] ! i)\n              (map ((!) ts) (\\<sigma> (g, length ts)) ! i))) \\<or>\n    (\\<forall>i<length (map ((!) ts) (\\<sigma> (g, length ts))).\n        snd (?f ([] ! i)\n              (map ((!) ts) (\\<sigma> (g, length ts)) ! i))) \\<and>\n    length (map ((!) ts) (\\<sigma> (g, length ts))) < length []),\n   (length [] = length (map ((!) ts) (\\<sigma> (g, length ts))) \\<or>\n    length (map ((!) ts) (\\<sigma> (g, length ts))) \\<le> ?m) \\<and>\n   ((\\<exists>i<length [].\n        i < length (map ((!) ts) (\\<sigma> (g, length ts))) \\<and>\n        (\\<forall>j<i.\n            snd (?f ([] ! j)\n                  (map ((!) ts) (\\<sigma> (g, length ts)) ! j))) \\<and>\n        fst (?f ([] ! i)\n              (map ((!) ts) (\\<sigma> (g, length ts)) ! i))) \\<or>\n    (\\<forall>i<length (map ((!) ts) (\\<sigma> (g, length ts))).\n        snd (?f ([] ! i)\n              (map ((!) ts) (\\<sigma> (g, length ts)) ! i))) \\<and>\n    length (map ((!) ts) (\\<sigma> (g, length ts))) \\<le> length []))", "have \"\\<And>f. snd (lex_ext f n [] ?mts) \\<Longrightarrow> ?mts = []\""], ["proof (prove)\nusing this:\n  lex_ext ?f ?m [] (map ((!) ts) (\\<sigma> (g, length ts))) =\n  ((length [] = length (map ((!) ts) (\\<sigma> (g, length ts))) \\<or>\n    length (map ((!) ts) (\\<sigma> (g, length ts))) \\<le> ?m) \\<and>\n   ((\\<exists>i<length [].\n        i < length (map ((!) ts) (\\<sigma> (g, length ts))) \\<and>\n        (\\<forall>j<i.\n            snd (?f ([] ! j)\n                  (map ((!) ts) (\\<sigma> (g, length ts)) ! j))) \\<and>\n        fst (?f ([] ! i)\n              (map ((!) ts) (\\<sigma> (g, length ts)) ! i))) \\<or>\n    (\\<forall>i<length (map ((!) ts) (\\<sigma> (g, length ts))).\n        snd (?f ([] ! i)\n              (map ((!) ts) (\\<sigma> (g, length ts)) ! i))) \\<and>\n    length (map ((!) ts) (\\<sigma> (g, length ts))) < length []),\n   (length [] = length (map ((!) ts) (\\<sigma> (g, length ts))) \\<or>\n    length (map ((!) ts) (\\<sigma> (g, length ts))) \\<le> ?m) \\<and>\n   ((\\<exists>i<length [].\n        i < length (map ((!) ts) (\\<sigma> (g, length ts))) \\<and>\n        (\\<forall>j<i.\n            snd (?f ([] ! j)\n                  (map ((!) ts) (\\<sigma> (g, length ts)) ! j))) \\<and>\n        fst (?f ([] ! i)\n              (map ((!) ts) (\\<sigma> (g, length ts)) ! i))) \\<or>\n    (\\<forall>i<length (map ((!) ts) (\\<sigma> (g, length ts))).\n        snd (?f ([] ! i)\n              (map ((!) ts) (\\<sigma> (g, length ts)) ! i))) \\<and>\n    length (map ((!) ts) (\\<sigma> (g, length ts))) \\<le> length []))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       snd (lex_ext f n []\n             (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n       map ((!) ts) (\\<sigma> (g, length ts)) = []", "by simp"], ["proof (state)\nthis:\n  snd (lex_ext ?f2 n []\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "with ts_ne fg t ge1 st' nfg cf cg"], ["proof (chain)\npicking this:\n  map ((!) ts) (\\<sigma> (g, length ts)) \\<noteq> []\n  pns\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  snd (lex_ext ?f2 n []\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  map ((!) ts) (\\<sigma> (g, length ts)) = []", "have ss_ne: \"?mss \\<noteq> []\""], ["proof (prove)\nusing this:\n  map ((!) ts) (\\<sigma> (g, length ts)) \\<noteq> []\n  pns\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  snd (lex_ext ?f2 n []\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n\ngoal (1 subgoal):\n 1. map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "from us_e ss_ne s u fh su' prc3 cf cg ch suA"], ["proof (chain)\npicking this:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  (s, u) \\<in> NS", "show ?thesis"], ["proof (prove)\nusing this:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by simp"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "case Lex"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from fg t ge1 st' nfg cf cg"], ["proof (chain)\npicking this:\n  pns\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex", "have lex1: \"snd (lex_ext wpo n ?mss ?mts)\""], ["proof (prove)\nusing this:\n  pns\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts))))", "by auto"], ["proof (state)\nthis:\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Lex", "have lex2: \"fst (lex_ext wpo n ?mts ?mus)\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  fst (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n (map ((!) ts) (\\<sigma> (g, length ts)))\n          (map ((!) us) (\\<sigma> (h, length us))))", "by auto"], ["proof (state)\nthis:\n  fst (lex_ext wpo n (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from lex1 lex2 lex_ext_compat[OF ind3', of ?mss ?mts ?mus]"], ["proof (chain)\npicking this:\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n  fst (lex_ext wpo n (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n  \\<lbrakk>\\<And>s t u.\n              \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n               t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n               u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n              \\<Longrightarrow> ?u'6 s\n                                \\<in> set\n (map ((!) ss) (\\<sigma> (f, length ss)));\n   \\<And>s t u.\n      \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n       t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n       u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n      \\<Longrightarrow> ?u'6 t\n                        \\<in> set (map ((!) ts)\n                                    (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us)))))", "have \"fst (lex_ext wpo n ?mss ?mus)\""], ["proof (prove)\nusing this:\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n  fst (lex_ext wpo n (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n  \\<lbrakk>\\<And>s t u.\n              \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n               t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n               u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n              \\<Longrightarrow> ?u'6 s\n                                \\<in> set\n (map ((!) ss) (\\<sigma> (f, length ss)));\n   \\<And>s t u.\n      \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n       t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n       u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n      \\<Longrightarrow> ?u'6 t\n                        \\<in> set (map ((!) ts)\n                                    (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us)))))\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) us) (\\<sigma> (h, length us))))", "by auto"], ["proof (state)\nthis:\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "with s u fh su' prc3 cf cg ch suA"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by simp"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk> \\<Longrightarrow> s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk> \\<Longrightarrow> s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk> \\<Longrightarrow> s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "assume ge1: \"s \\<succ> t\" and ge2: \"t \\<succeq> u\""], ["proof (state)\nthis:\n  s \\<succ> t\n  t \\<succeq> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from wpo_s_imp_NS[OF ge1]"], ["proof (chain)\npicking this:\n  (s, t) \\<in> NS", "have stA: \"(s,t) \\<in> NS\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> NS", "."], ["proof (state)\nthis:\n  (s, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from wpo_ns_imp_NS[OF ge2]"], ["proof (chain)\npicking this:\n  (t, u) \\<in> NS", "have tuA: \"(t,u) \\<in> NS\""], ["proof (prove)\nusing this:\n  (t, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. (t, u) \\<in> NS", "."], ["proof (state)\nthis:\n  (t, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from trans_NS_point[OF stA tuA]"], ["proof (chain)\npicking this:\n  (s, u) \\<in> NS", "have suA: \"(s,u) \\<in> NS\""], ["proof (prove)\nusing this:\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. (s, u) \\<in> NS", "."], ["proof (state)\nthis:\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "have \"s \\<succ> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases ?s1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "case True"], ["proof (state)\nthis:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "from True"], ["proof (chain)\npicking this:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t", "obtain i where i: \"i \\<in> ?ss\" and ges: \"ss ! i \\<succeq> t\""], ["proof (prove)\nusing this:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> set (\\<sigma> (f, length ss));\n         ss ! i \\<succeq> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<succeq> t\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "from \\<sigma>E[OF i]"], ["proof (chain)\npicking this:\n  ss ! i \\<in> set ss", "have s': \"ss ! i \\<in> set ss\""], ["proof (prove)\nusing this:\n  ss ! i \\<in> set ss\n\ngoal (1 subgoal):\n 1. ss ! i \\<in> set ss", "by auto"], ["proof (state)\nthis:\n  ss ! i \\<in> set ss\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "with s s' ind2[of \"ss ! i\" t u, simplified] ges ge2"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  ss ! i \\<in> set ss\n  ss ! i \\<in> set ss \\<Longrightarrow>\n  (ss ! i \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n   ss ! i \\<succ> u) \\<and>\n  (ss ! i \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n   ss ! i \\<succ> u) \\<and>\n  (ss ! i \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow>\n   ss ! i \\<succeq> u)\n  ss ! i \\<succeq> t\n  t \\<succeq> u\n  ss ! i \\<in> set ss", "have \"ss ! i \\<succeq> u\""], ["proof (prove)\nusing this:\n  s = Fun f ss\n  ss ! i \\<in> set ss\n  ss ! i \\<in> set ss \\<Longrightarrow>\n  (ss ! i \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n   ss ! i \\<succ> u) \\<and>\n  (ss ! i \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n   ss ! i \\<succ> u) \\<and>\n  (ss ! i \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow>\n   ss ! i \\<succeq> u)\n  ss ! i \\<succeq> t\n  t \\<succeq> u\n  ss ! i \\<in> set ss\n\ngoal (1 subgoal):\n 1. ss ! i \\<succeq> u", "by auto"], ["proof (state)\nthis:\n  ss ! i \\<succeq> u\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "with i s' s suA"], ["proof (chain)\npicking this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<in> set ss\n  s = Fun f ss\n  (s, u) \\<in> NS\n  ss ! i \\<succeq> u", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<in> set ss\n  s = Fun f ss\n  (s, u) \\<in> NS\n  ss ! i \\<succeq> u\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "by (cases u, auto simp: wpo.simps)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases ?t1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n       ts ! j \\<succeq> u \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "case True"], ["proof (state)\nthis:\n  \\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u\n\ngoal (2 subgoals):\n 1. \\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n       ts ! j \\<succeq> u \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from this"], ["proof (chain)\npicking this:\n  \\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u", "obtain j where j: \"j \\<in> ?ts\" and ges: \"ts ! j \\<succeq> u\""], ["proof (prove)\nusing this:\n  \\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<in> set (\\<sigma> (g, length ts));\n         ts ! j \\<succeq> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<in> set (\\<sigma> (g, length ts))\n  ts ! j \\<succeq> u\n\ngoal (2 subgoals):\n 1. \\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n       ts ! j \\<succeq> u \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from \\<sigma>E[OF j]"], ["proof (chain)\npicking this:\n  ts ! j \\<in> set ts", "have t': \"ts ! j \\<in> set ts\""], ["proof (prove)\nusing this:\n  ts ! j \\<in> set ts\n\ngoal (1 subgoal):\n 1. ts ! j \\<in> set ts", "."], ["proof (state)\nthis:\n  ts ! j \\<in> set ts\n\ngoal (2 subgoals):\n 1. \\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n       ts ! j \\<succeq> u \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from j t' t stS False ge1 s"], ["proof (chain)\npicking this:\n  j \\<in> set (\\<sigma> (g, length ts))\n  ts ! j \\<in> set ts\n  t = Fun g ts\n  (s, t) \\<notin> S\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  s \\<succ> t\n  s = Fun f ss", "have ge1': \"s \\<succ> ts ! j\""], ["proof (prove)\nusing this:\n  j \\<in> set (\\<sigma> (g, length ts))\n  ts ! j \\<in> set ts\n  t = Fun g ts\n  (s, t) \\<notin> S\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  s \\<succ> t\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. s \\<succ> ts ! j", "unfolding wpo.simps[of s t]"], ["proof (prove)\nusing this:\n  j \\<in> set (\\<sigma> (g, length ts))\n  ts ! j \\<in> set ts\n  t = Fun g ts\n  (s, t) \\<notin> S\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  fst (case s of\n       Var x \\<Rightarrow>\n         (False,\n          case t of Var xa \\<Rightarrow> x = xa\n          | Fun g ts \\<Rightarrow>\n              (s, t) \\<in> NS \\<and>\n              \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n       | Fun f ss \\<Rightarrow>\n           if (s, t) \\<in> S then (True, True)\n           else if (s, t) \\<in> NS\n                then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                           ss ! i \\<succeq> t\n                     then (True, True)\n                     else case t of\n                          Var x \\<Rightarrow>\n                            (False, ssimple \\<and> large (f, length ss))\n                          | Fun g ts \\<Rightarrow>\n                              case prc (f, length ss) (g, length ts) of\n                              (prs, prns) \\<Rightarrow>\n                                if prns \\<and>\n                                   (\\<forall>j\n       \\<in>set (\\<sigma> (g, length ts)).\n s \\<succ> ts ! j)\n                                then if prs then (True, True)\n                                     else let ss' =\n          map ((!) ss) (\\<sigma> (f, length ss));\n        ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n        cg = c (g, length ts)\n    in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n       else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n            else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                  length ts' = 0)\n                                else (False, False)\n                else (False, False))\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. s \\<succ> ts ! j", "by (auto split: if_splits prod.splits)"], ["proof (state)\nthis:\n  s \\<succ> ts ! j\n\ngoal (2 subgoals):\n 1. \\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n       ts ! j \\<succeq> u \\<Longrightarrow>\n    s \\<succ> u\n 2. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "from t' s t ge1' ges ind[rule_format, of s \"ts ! j\" u, simplified]"], ["proof (chain)\npicking this:\n  ts ! j \\<in> set ts\n  s = Fun f ss\n  t = Fun g ts\n  s \\<succ> ts ! j\n  ts ! j \\<succeq> u\n  size (ts ! j) < size t \\<longrightarrow>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succ> u \\<longrightarrow>\n   s \\<succ> u) \\<and>\n  (s \\<succ> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   s \\<succ> u) \\<and>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   s \\<succeq> u)", "show \"s \\<succ> u\""], ["proof (prove)\nusing this:\n  ts ! j \\<in> set ts\n  s = Fun f ss\n  t = Fun g ts\n  s \\<succ> ts ! j\n  ts ! j \\<succeq> u\n  size (ts ! j) < size t \\<longrightarrow>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succ> u \\<longrightarrow>\n   s \\<succ> u) \\<and>\n  (s \\<succ> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   s \\<succ> u) \\<and>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   s \\<succeq> u)\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "using suA size_simps supt.intros"], ["proof (prove)\nusing this:\n  ts ! j \\<in> set ts\n  s = Fun f ss\n  t = Fun g ts\n  s \\<succ> ts ! j\n  ts ! j \\<succeq> u\n  size (ts ! j) < size t \\<longrightarrow>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succ> u \\<longrightarrow>\n   s \\<succ> u) \\<and>\n  (s \\<succ> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   s \\<succ> u) \\<and>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   s \\<succeq> u)\n  (s, u) \\<in> NS\n  ?t \\<in> set ?ts \\<Longrightarrow> size ?t < Suc (size_list size ?ts)\n  ?t \\<in> set ?ts \\<Longrightarrow>\n  size ?t < Suc (Suc (size ?s + size_list size ?ts))\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?x < Suc (size_list size ?xs)\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?y < Suc (size_list size ?ys)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<rhd> ?t; size ?t < size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t < Suc (size_list size ?ss)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<unrhd> ?t; size ?t \\<le> size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t \\<le> Suc (size_list size ?ss)\n  ?s \\<in> set ?ss \\<Longrightarrow> Fun ?f ?ss \\<rhd> ?s\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<rhd> ?t\\<rbrakk>\n  \\<Longrightarrow> Fun ?f ?ss \\<rhd> ?t\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  ts ! j \\<in> set ts\n  s = Fun f ss\n  t = Fun g ts\n  s \\<succ> ts ! j\n  ts ! j \\<succeq> u\n  size (ts ! j) < size t \\<longrightarrow>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succ> u \\<longrightarrow>\n   fst (case s of\n        Var x \\<Rightarrow>\n          (False,\n           case u of Var xa \\<Rightarrow> x = xa\n           | Fun g ts \\<Rightarrow>\n               (s, u) \\<in> NS \\<and>\n               \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n        | Fun f ss \\<Rightarrow>\n            if (s, u) \\<in> S then (True, True)\n            else if (s, u) \\<in> NS\n                 then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                            ss ! i \\<succeq> u\n                      then (True, True)\n                      else case u of\n                           Var x \\<Rightarrow>\n                             (False, ssimple \\<and> large (f, length ss))\n                           | Fun g ts \\<Rightarrow>\n                               case prc (f, length ss) (g, length ts) of\n                               (prs, prns) \\<Rightarrow>\n                                 if prns \\<and>\n                                    (\\<forall>j\n        \\<in>set (\\<sigma> (g, length ts)).\n  s \\<succ> ts ! j)\n                                 then if prs then (True, True)\nelse let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n         ts' = map ((!) ts) (\\<sigma> (g, length ts));\n         cf = c (f, length ss); cg = c (g, length ts)\n     in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n        else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n             else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                   length ts' = 0)\n                                 else (False, False)\n                 else (False, False))) \\<and>\n  (s \\<succ> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   fst (case s of\n        Var x \\<Rightarrow>\n          (False,\n           case u of Var xa \\<Rightarrow> x = xa\n           | Fun g ts \\<Rightarrow>\n               (s, u) \\<in> NS \\<and>\n               \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n        | Fun f ss \\<Rightarrow>\n            if (s, u) \\<in> S then (True, True)\n            else if (s, u) \\<in> NS\n                 then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                            ss ! i \\<succeq> u\n                      then (True, True)\n                      else case u of\n                           Var x \\<Rightarrow>\n                             (False, ssimple \\<and> large (f, length ss))\n                           | Fun g ts \\<Rightarrow>\n                               case prc (f, length ss) (g, length ts) of\n                               (prs, prns) \\<Rightarrow>\n                                 if prns \\<and>\n                                    (\\<forall>j\n        \\<in>set (\\<sigma> (g, length ts)).\n  s \\<succ> ts ! j)\n                                 then if prs then (True, True)\nelse let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n         ts' = map ((!) ts) (\\<sigma> (g, length ts));\n         cf = c (f, length ss); cg = c (g, length ts)\n     in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n        else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n             else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                   length ts' = 0)\n                                 else (False, False)\n                 else (False, False))) \\<and>\n  (s \\<succeq> ts ! j \\<and> ts ! j \\<succeq> u \\<longrightarrow>\n   snd (case s of\n        Var x \\<Rightarrow>\n          (False,\n           case u of Var xa \\<Rightarrow> x = xa\n           | Fun g ts \\<Rightarrow>\n               (s, u) \\<in> NS \\<and>\n               \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n        | Fun f ss \\<Rightarrow>\n            if (s, u) \\<in> S then (True, True)\n            else if (s, u) \\<in> NS\n                 then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                            ss ! i \\<succeq> u\n                      then (True, True)\n                      else case u of\n                           Var x \\<Rightarrow>\n                             (False, ssimple \\<and> large (f, length ss))\n                           | Fun g ts \\<Rightarrow>\n                               case prc (f, length ss) (g, length ts) of\n                               (prs, prns) \\<Rightarrow>\n                                 if prns \\<and>\n                                    (\\<forall>j\n        \\<in>set (\\<sigma> (g, length ts)).\n  s \\<succ> ts ! j)\n                                 then if prs then (True, True)\nelse let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n         ts' = map ((!) ts) (\\<sigma> (g, length ts));\n         cf = c (f, length ss); cg = c (g, length ts)\n     in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n        else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n             else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                   length ts' = 0)\n                                 else (False, False)\n                 else (False, False)))\n  (s, u) \\<in> NS\n  ?t \\<in> set ?ts \\<Longrightarrow> size ?t < Suc (size_list size ?ts)\n  ?t \\<in> set ?ts \\<Longrightarrow>\n  size ?t < Suc (Suc (size ?s + size_list size ?ts))\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?x < Suc (size_list size ?xs)\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?y < Suc (size_list size ?ys)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<rhd> ?t; size ?t < size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t < Suc (size_list size ?ss)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<unrhd> ?t; size ?t \\<le> size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t \\<le> Suc (size_list size ?ss)\n  ?s \\<in> set ?ss \\<Longrightarrow> Fun ?f ?ss \\<rhd> ?s\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<rhd> ?t\\<rbrakk>\n  \\<Longrightarrow> Fun ?f ?ss \\<rhd> ?t\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u) \\<Longrightarrow>\n    s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "case u: (Fun h us)"], ["proof (state)\nthis:\n  u = Fun h us\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "let ?u = \"Fun h us\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "let ?h = \"(h,length us)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "let ?us = \"set (\\<sigma> ?h)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "let ?mss = \"map (\\<lambda> i. ss ! i) (\\<sigma> ?f)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "let ?mts = \"map (\\<lambda> j. ts ! j) (\\<sigma> ?g)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "let ?mus = \"map (\\<lambda> k. us ! k) (\\<sigma> ?h)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "note \\<sigma>E =  \\<sigma>E[of _ f ss] \\<sigma>E[of _ g ts] \\<sigma>E[of _ h us]"], ["proof (state)\nthis:\n  ?i \\<in> set (\\<sigma> (f, length ss)) \\<Longrightarrow>\n  ss ! ?i \\<in> set ss\n  ?i \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  ts ! ?i \\<in> set ts\n  ?i \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  us ! ?i \\<in> set us\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from s t u ge1 ge2"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  t = Fun g ts\n  u = Fun h us\n  s \\<succ> t\n  t \\<succeq> u", "have ge1: \"?s \\<succ> ?t\" and ge2: \"?t \\<succeq> ?u\""], ["proof (prove)\nusing this:\n  s = Fun f ss\n  t = Fun g ts\n  u = Fun h us\n  s \\<succ> t\n  t \\<succeq> u\n\ngoal (1 subgoal):\n 1. Fun f ss \\<succ> Fun g ts &&& Fun g ts \\<succeq> Fun h us", "by auto"], ["proof (state)\nthis:\n  Fun f ss \\<succ> Fun g ts\n  Fun g ts \\<succeq> Fun h us\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from stA stS s t"], ["proof (chain)\npicking this:\n  (s, t) \\<in> NS\n  (s, t) \\<notin> S\n  s = Fun f ss\n  t = Fun g ts", "have stAS: \"((?s,?t) \\<in> S) = False\" \"((?s,?t) \\<in> NS) = True\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> NS\n  (s, t) \\<notin> S\n  s = Fun f ss\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. ((Fun f ss, Fun g ts) \\<in> S) = False &&&\n    ((Fun f ss, Fun g ts) \\<in> NS) = True", "by auto"], ["proof (state)\nthis:\n  ((Fun f ss, Fun g ts) \\<in> S) = False\n  ((Fun f ss, Fun g ts) \\<in> NS) = True\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from tuA tuS t u"], ["proof (chain)\npicking this:\n  (t, u) \\<in> NS\n  (t, u) \\<notin> S\n  t = Fun g ts\n  u = Fun h us", "have tuAS: \"((?t,?u) \\<in> S) = False\" \"((?t,?u) \\<in> NS) = True\""], ["proof (prove)\nusing this:\n  (t, u) \\<in> NS\n  (t, u) \\<notin> S\n  t = Fun g ts\n  u = Fun h us\n\ngoal (1 subgoal):\n 1. ((Fun g ts, Fun h us) \\<in> S) = False &&&\n    ((Fun g ts, Fun h us) \\<in> NS) = True", "by auto"], ["proof (state)\nthis:\n  ((Fun g ts, Fun h us) \\<in> S) = False\n  ((Fun g ts, Fun h us) \\<in> NS) = True\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "note ge1 = ge1[unfolded wpo.simps[of ?s ?t] stAS, simplified]"], ["proof (state)\nthis:\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "note ge2 = ge2[unfolded wpo.simps[of ?t ?u] tuAS, simplified]"], ["proof (state)\nthis:\n  snd (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "let ?lu = \"length us\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "obtain ps2 pns2 where prc2: \"prc ?g ?h = (ps2,pns2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps2 pns2.\n        prc (g, length ts) (h, length us) = (ps2, pns2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "obtain ps3 pns3 where prc3: \"prc ?f ?h = (ps3,pns3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps3 pns3.\n        prc (f, length ss) (h, length us) = (ps3, pns3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from \\<open>\\<not> ?s1\\<close> t ge1"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))", "have st': \"\\<forall> j \\<in> ?ts. ?s \\<succ> ts ! j\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j", "by (auto split: if_splits prod.splits)"], ["proof (state)\nthis:\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from \\<open>\\<not> ?t1\\<close> t u ge2 tuS"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  t = Fun g ts\n  u = Fun h us\n  snd (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  (t, u) \\<notin> S", "have tu': \"\\<forall> k \\<in> ?us. ?t \\<succ> us ! k\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  t = Fun g ts\n  u = Fun h us\n  snd (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  (t, u) \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k", "by (auto split: if_splits prod.splits)"], ["proof (state)\nthis:\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from \\<open>\\<not> ?s1\\<close> s t ge1 stS st'"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  s = Fun f ss\n  t = Fun g ts\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  (s, t) \\<notin> S\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j", "have fg: \"pns\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  s = Fun f ss\n  t = Fun g ts\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  (s, t) \\<notin> S\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n\ngoal (1 subgoal):\n 1. pns", "by (cases ?thesis, auto simp: prc)"], ["proof (state)\nthis:\n  pns\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from \\<open>\\<not> ?t1\\<close> u ge2 tu'"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  u = Fun h us\n  snd (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k", "have gh: \"pns2\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  u = Fun h us\n  snd (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n\ngoal (1 subgoal):\n 1. pns2", "by (cases ?thesis, auto simp: prc2)"], ["proof (state)\nthis:\n  pns2\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from \\<open>\\<not> ?s1\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)", "have \"?s1 = False\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n\ngoal (1 subgoal):\n 1. (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t) =\n    False", "by simp"], ["proof (state)\nthis:\n  (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t) = False\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "note ge1 = ge1[unfolded this[unfolded t] if_False term.simps prc split]"], ["proof (state)\nthis:\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from \\<open>\\<not> ?t1\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)", "have \"?t1 = False\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n\ngoal (1 subgoal):\n 1. (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u) =\n    False", "by simp"], ["proof (state)\nthis:\n  (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u) = False\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "note ge2 = ge2[unfolded this[unfolded u] if_False term.simps prc2 split]"], ["proof (state)\nthis:\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "note compat = prc_compat[OF prc prc2 prc3]"], ["proof (state)\nthis:\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from fg gh compat"], ["proof (chain)\npicking this:\n  pns\n  pns2\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)", "have fh: \"pns3\""], ["proof (prove)\nusing this:\n  pns\n  pns2\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)\n\ngoal (1 subgoal):\n 1. pns3", "by simp"], ["proof (state)\nthis:\n  pns3\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "{"], ["proof (state)\nthis:\n  pns3\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "assume k: \"k \\<in> ?us\""], ["proof (state)\nthis:\n  k \\<in> set (\\<sigma> (h, length us))\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "from \\<sigma>E(3)[OF this]"], ["proof (chain)\npicking this:\n  us ! k \\<in> set us", "have \"size (us ! k) < size u\""], ["proof (prove)\nusing this:\n  us ! k \\<in> set us\n\ngoal (1 subgoal):\n 1. size (us ! k) < size u", "unfolding u"], ["proof (prove)\nusing this:\n  us ! k \\<in> set us\n\ngoal (1 subgoal):\n 1. size (us ! k) < size (Fun h us)", "using size_simps"], ["proof (prove)\nusing this:\n  us ! k \\<in> set us\n  ?t \\<in> set ?ts \\<Longrightarrow> size ?t < Suc (size_list size ?ts)\n  ?t \\<in> set ?ts \\<Longrightarrow>\n  size ?t < Suc (Suc (size ?s + size_list size ?ts))\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?x < Suc (size_list size ?xs)\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?y < Suc (size_list size ?ys)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<rhd> ?t; size ?t < size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t < Suc (size_list size ?ss)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<unrhd> ?t; size ?t \\<le> size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t \\<le> Suc (size_list size ?ss)\n\ngoal (1 subgoal):\n 1. size (us ! k) < size (Fun h us)", "by auto"], ["proof (state)\nthis:\n  size (us ! k) < size u\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "with tu'[folded t] wpo_s_imp_ns[OF \\<open>s \\<succ> t\\<close>] \n                    ind[rule_format, of s t \"us ! k\"] k"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). t \\<succ> us ! k\n  s \\<succeq> t\n  (size s < size s \\<longrightarrow>\n   (s \\<succeq> t \\<and> t \\<succ> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succ> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succeq> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succeq> us ! k)) \\<and>\n  (size s = size s \\<and>\n   (size t < size t \\<or>\n    size t = size t \\<and> size (us ! k) < size u) \\<longrightarrow>\n   (s \\<succeq> t \\<and> t \\<succ> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succ> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succeq> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succeq> us ! k))\n  k \\<in> set (\\<sigma> (h, length us))\n  size (us ! k) < size u", "have \"s \\<succ> us ! k\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). t \\<succ> us ! k\n  s \\<succeq> t\n  (size s < size s \\<longrightarrow>\n   (s \\<succeq> t \\<and> t \\<succ> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succ> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succeq> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succeq> us ! k)) \\<and>\n  (size s = size s \\<and>\n   (size t < size t \\<or>\n    size t = size t \\<and> size (us ! k) < size u) \\<longrightarrow>\n   (s \\<succeq> t \\<and> t \\<succ> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succ> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succeq> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succeq> us ! k))\n  k \\<in> set (\\<sigma> (h, length us))\n  size (us ! k) < size u\n\ngoal (1 subgoal):\n 1. s \\<succ> us ! k", "by blast"], ["proof (state)\nthis:\n  s \\<succ> us ! k\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "}"], ["proof (state)\nthis:\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "note su' = this"], ["proof (state)\nthis:\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases ps3)"], ["proof (state)\ngoal (2 subgoals):\n 1. ps3 \\<Longrightarrow> s \\<succ> u\n 2. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "case True"], ["proof (state)\nthis:\n  ps3\n\ngoal (2 subgoals):\n 1. ps3 \\<Longrightarrow> s \\<succ> u\n 2. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "with su' s u fh prc3 suA"], ["proof (chain)\npicking this:\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  (s, u) \\<in> NS\n  ps3", "show ?thesis"], ["proof (prove)\nusing this:\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  (s, u) \\<in> NS\n  ps3\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "by (auto simp: wpo.simps)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "case False"], ["proof (state)\nthis:\n  \\<not> ps3\n\ngoal (1 subgoal):\n 1. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "from False fg gh compat"], ["proof (chain)\npicking this:\n  \\<not> ps3\n  pns\n  pns2\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)", "have nfg: \"\\<not> ps\" and ngh: \"\\<not> ps2\" and *: \"ps = False\" \"ps2 = False\""], ["proof (prove)\nusing this:\n  \\<not> ps3\n  pns\n  pns2\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)\n\ngoal (1 subgoal):\n 1. \\<not> ps &&& \\<not> ps2 &&& ps = False &&& ps2 = False", "by blast+"], ["proof (state)\nthis:\n  \\<not> ps\n  \\<not> ps2\n  ps = False\n  ps2 = False\n\ngoal (1 subgoal):\n 1. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "note ge1 = ge1[unfolded * if_False]"], ["proof (state)\nthis:\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "note ge2 = ge2[unfolded * if_False]"], ["proof (state)\nthis:\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. \\<not> ps3 \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases \"c ?f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (f, length ss) = Mul \\<Longrightarrow> s \\<succ> u", "case Mul"], ["proof (state)\nthis:\n  c (f, length ss) = Mul\n\ngoal (2 subgoals):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (f, length ss) = Mul \\<Longrightarrow> s \\<succ> u", "note cf = this"], ["proof (state)\nthis:\n  c (f, length ss) = Mul\n\ngoal (2 subgoals):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (f, length ss) = Mul \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases \"c ?g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "case Mul"], ["proof (state)\nthis:\n  c (g, length ts) = Mul\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "note cg = this"], ["proof (state)\nthis:\n  c (g, length ts) = Mul\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases \"c ?h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "case Mul"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "from fg t ge1 st' nfg cf cg"], ["proof (chain)\npicking this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul", "have mul1: \"fst (mul_ext wpo ?mss ?mts)\""], ["proof (prove)\nusing this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n\ngoal (1 subgoal):\n 1. fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts))))", "by auto"], ["proof (state)\nthis:\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "from gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Mul", "have mul2: \"snd (mul_ext wpo ?mts ?mus)\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Mul\n\ngoal (1 subgoal):\n 1. snd (mul_ext wpo (map ((!) ts) (\\<sigma> (g, length ts)))\n          (map ((!) us) (\\<sigma> (h, length us))))", "by auto"], ["proof (state)\nthis:\n  snd (mul_ext wpo (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "from mul1 mul2 mul_ext_compat[OF ind3', of ?mss ?mts ?mus]"], ["proof (chain)\npicking this:\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n  snd (mul_ext wpo (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n  \\<lbrakk>\\<And>s t u.\n              \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n               t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n               u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n              \\<Longrightarrow> ?u'6 s\n                                \\<in> set\n (map ((!) ss) (\\<sigma> (f, length ss)));\n   \\<And>s t u.\n      \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n       t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n       u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n      \\<Longrightarrow> ?u'6 t\n                        \\<in> set (map ((!) ts)\n                                    (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us)))))", "have \"fst (mul_ext wpo ?mss ?mus)\""], ["proof (prove)\nusing this:\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n  snd (mul_ext wpo (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n  \\<lbrakk>\\<And>s t u.\n              \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n               t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n               u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n              \\<Longrightarrow> ?u'6 s\n                                \\<in> set\n (map ((!) ss) (\\<sigma> (f, length ss)));\n   \\<And>s t u.\n      \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n       t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n       u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n      \\<Longrightarrow> ?u'6 t\n                        \\<in> set (map ((!) ts)\n                                    (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us)))))\n\ngoal (1 subgoal):\n 1. fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) us) (\\<sigma> (h, length us))))", "by auto"], ["proof (state)\nthis:\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "with s u fh su' prc3 cf ch suA"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by simp"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "case Lex"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Lex", "have us_e: \"?mus = []\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from fg t ge1 st' nfg cf cg s_mul_ext_bottom_strict"], ["proof (chain)\npicking this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  ({#}, ?A) \\<notin> s_mul_ext ?ns ?s", "have ss_ne: \"?mss \\<noteq> []\""], ["proof (prove)\nusing this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  ({#}, ?A) \\<notin> s_mul_ext ?ns ?s\n\ngoal (1 subgoal):\n 1. map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "by (cases ?mss) (auto simp: Let_def mul_ext_def)"], ["proof (state)\nthis:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from us_e ss_ne s u fh su' prc3 cf cg ch suA"], ["proof (chain)\npicking this:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS", "show ?thesis"], ["proof (prove)\nusing this:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by simp"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "case Lex"], ["proof (state)\nthis:\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "note cg = this"], ["proof (state)\nthis:\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "from fg t ge1 st' prc nfg cf cg s_mul_ext_bottom_strict"], ["proof (chain)\npicking this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  ({#}, ?A) \\<notin> s_mul_ext ?ns ?s", "have ss_ne: \"?mss \\<noteq> []\""], ["proof (prove)\nusing this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  ({#}, ?A) \\<notin> s_mul_ext ?ns ?s\n\ngoal (1 subgoal):\n 1. map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "by (auto simp: mul_ext_def)"], ["proof (state)\nthis:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "from fg t ge1 st' nfg cf cg"], ["proof (chain)\npicking this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex", "have ts_e: \"?mts = []\""], ["proof (prove)\nusing this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. map ((!) ts) (\\<sigma> (g, length ts)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases \"c ?h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "case Mul"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "with gh u ge2 tu' ngh cg ch ns_mul_ext_bottom_uniqueness"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  ({#}, ?A) \\<in> ns_mul_ext ?ns ?s \\<Longrightarrow> ?A = {#}\n  c (h, length us) = Mul", "have \"?mus = []\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  ({#}, ?A) \\<in> ns_mul_ext ?ns ?s \\<Longrightarrow> ?A = {#}\n  c (h, length us) = Mul\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "with ss_ne s u fh su' prc3 cf cg ch s_mul_ext_bottom suA"], ["proof (chain)\npicking this:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  ?A \\<noteq> {#} \\<Longrightarrow> (?A, {#}) \\<in> s_mul_ext ?ns ?s\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  ?A \\<noteq> {#} \\<Longrightarrow> (?A, {#}) \\<in> s_mul_ext ?ns ?s\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  ?A \\<noteq> {#} \\<Longrightarrow> (?A, {#}) \\<in> s_mul_ext ?ns ?s\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by (simp add: Let_def mul_ext_def s_mul_ext_def mult2_alt_s_def)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "case Lex"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from lex_ext_iff[of _ _ \"[]\" ?mus]"], ["proof (chain)\npicking this:\n  lex_ext ?f ?m [] (map ((!) us) (\\<sigma> (h, length us))) =\n  ((length [] = length (map ((!) us) (\\<sigma> (h, length us))) \\<or>\n    length (map ((!) us) (\\<sigma> (h, length us))) \\<le> ?m) \\<and>\n   ((\\<exists>i<length [].\n        i < length (map ((!) us) (\\<sigma> (h, length us))) \\<and>\n        (\\<forall>j<i.\n            snd (?f ([] ! j)\n                  (map ((!) us) (\\<sigma> (h, length us)) ! j))) \\<and>\n        fst (?f ([] ! i)\n              (map ((!) us) (\\<sigma> (h, length us)) ! i))) \\<or>\n    (\\<forall>i<length (map ((!) us) (\\<sigma> (h, length us))).\n        snd (?f ([] ! i)\n              (map ((!) us) (\\<sigma> (h, length us)) ! i))) \\<and>\n    length (map ((!) us) (\\<sigma> (h, length us))) < length []),\n   (length [] = length (map ((!) us) (\\<sigma> (h, length us))) \\<or>\n    length (map ((!) us) (\\<sigma> (h, length us))) \\<le> ?m) \\<and>\n   ((\\<exists>i<length [].\n        i < length (map ((!) us) (\\<sigma> (h, length us))) \\<and>\n        (\\<forall>j<i.\n            snd (?f ([] ! j)\n                  (map ((!) us) (\\<sigma> (h, length us)) ! j))) \\<and>\n        fst (?f ([] ! i)\n              (map ((!) us) (\\<sigma> (h, length us)) ! i))) \\<or>\n    (\\<forall>i<length (map ((!) us) (\\<sigma> (h, length us))).\n        snd (?f ([] ! i)\n              (map ((!) us) (\\<sigma> (h, length us)) ! i))) \\<and>\n    length (map ((!) us) (\\<sigma> (h, length us))) \\<le> length []))", "have \"\\<And>f. snd (lex_ext f n [] ?mus) \\<Longrightarrow> ?mus = []\""], ["proof (prove)\nusing this:\n  lex_ext ?f ?m [] (map ((!) us) (\\<sigma> (h, length us))) =\n  ((length [] = length (map ((!) us) (\\<sigma> (h, length us))) \\<or>\n    length (map ((!) us) (\\<sigma> (h, length us))) \\<le> ?m) \\<and>\n   ((\\<exists>i<length [].\n        i < length (map ((!) us) (\\<sigma> (h, length us))) \\<and>\n        (\\<forall>j<i.\n            snd (?f ([] ! j)\n                  (map ((!) us) (\\<sigma> (h, length us)) ! j))) \\<and>\n        fst (?f ([] ! i)\n              (map ((!) us) (\\<sigma> (h, length us)) ! i))) \\<or>\n    (\\<forall>i<length (map ((!) us) (\\<sigma> (h, length us))).\n        snd (?f ([] ! i)\n              (map ((!) us) (\\<sigma> (h, length us)) ! i))) \\<and>\n    length (map ((!) us) (\\<sigma> (h, length us))) < length []),\n   (length [] = length (map ((!) us) (\\<sigma> (h, length us))) \\<or>\n    length (map ((!) us) (\\<sigma> (h, length us))) \\<le> ?m) \\<and>\n   ((\\<exists>i<length [].\n        i < length (map ((!) us) (\\<sigma> (h, length us))) \\<and>\n        (\\<forall>j<i.\n            snd (?f ([] ! j)\n                  (map ((!) us) (\\<sigma> (h, length us)) ! j))) \\<and>\n        fst (?f ([] ! i)\n              (map ((!) us) (\\<sigma> (h, length us)) ! i))) \\<or>\n    (\\<forall>i<length (map ((!) us) (\\<sigma> (h, length us))).\n        snd (?f ([] ! i)\n              (map ((!) us) (\\<sigma> (h, length us)) ! i))) \\<and>\n    length (map ((!) us) (\\<sigma> (h, length us))) \\<le> length []))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       snd (lex_ext f n []\n             (map ((!) us) (\\<sigma> (h, length us)))) \\<Longrightarrow>\n       map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  snd (lex_ext ?f2 n []\n        (map ((!) us) (\\<sigma> (h, length us)))) \\<Longrightarrow>\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "with ts_e gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  snd (lex_ext ?f2 n []\n        (map ((!) us) (\\<sigma> (h, length us)))) \\<Longrightarrow>\n  map ((!) us) (\\<sigma> (h, length us)) = []", "have \"?mus = []\""], ["proof (prove)\nusing this:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  snd (lex_ext ?f2 n []\n        (map ((!) us) (\\<sigma> (h, length us)))) \\<Longrightarrow>\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "with ss_ne s u fh su' prc3 cf cg ch s_mul_ext_bottom suA"], ["proof (chain)\npicking this:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  ?A \\<noteq> {#} \\<Longrightarrow> (?A, {#}) \\<in> s_mul_ext ?ns ?s\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  ?A \\<noteq> {#} \\<Longrightarrow> (?A, {#}) \\<in> s_mul_ext ?ns ?s\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  ?A \\<noteq> {#} \\<Longrightarrow> (?A, {#}) \\<in> s_mul_ext ?ns ?s\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by (simp add: mul_ext_def)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u", "case Lex"], ["proof (state)\nthis:\n  c (f, length ss) = Lex\n\ngoal (1 subgoal):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u", "note cf = this"], ["proof (state)\nthis:\n  c (f, length ss) = Lex\n\ngoal (1 subgoal):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases \"c ?g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "case Mul"], ["proof (state)\nthis:\n  c (g, length ts) = Mul\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "note cg = this"], ["proof (state)\nthis:\n  c (g, length ts) = Mul\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "from fg t ge1 st' nfg cf cg"], ["proof (chain)\npicking this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul", "have ss_ne: \"?mss \\<noteq> []\""], ["proof (prove)\nusing this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n\ngoal (1 subgoal):\n 1. map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "from fg t ge1 st' nfg cf cg"], ["proof (chain)\npicking this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul", "have ts_e: \"?mts = []\""], ["proof (prove)\nusing this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n\ngoal (1 subgoal):\n 1. map ((!) ts) (\\<sigma> (g, length ts)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases \"c ?h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "case Mul"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "from ts_e gh u ge2 tu' ngh cg ch\n                          ns_mul_ext_bottom_uniqueness[of \"mset ?mus\"]"], ["proof (chain)\npicking this:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Mul\n  ({#}, mset (map ((!) us) (\\<sigma> (h, length us))))\n  \\<in> ns_mul_ext ?ns ?s \\<Longrightarrow>\n  mset (map ((!) us) (\\<sigma> (h, length us))) = {#}", "have \"?mus = []\""], ["proof (prove)\nusing this:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Mul\n  ({#}, mset (map ((!) us) (\\<sigma> (h, length us))))\n  \\<in> ns_mul_ext ?ns ?s \\<Longrightarrow>\n  mset (map ((!) us) (\\<sigma> (h, length us))) = {#}\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by (simp add: mul_ext_def Let_def)"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "with ss_ne s u fh su' prc3 cf cg ch s_mul_ext_bottom suA"], ["proof (chain)\npicking this:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n  c (h, length us) = Mul\n  ?A \\<noteq> {#} \\<Longrightarrow> (?A, {#}) \\<in> s_mul_ext ?ns ?s\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n  c (h, length us) = Mul\n  ?A \\<noteq> {#} \\<Longrightarrow> (?A, {#}) \\<in> s_mul_ext ?ns ?s\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n  c (h, length us) = Mul\n  ?A \\<noteq> {#} \\<Longrightarrow> (?A, {#}) \\<in> s_mul_ext ?ns ?s\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by (simp add: mul_ext_def)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "case Lex"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from gh u ge2 tu' prc2 ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Lex", "have \"?mus = []\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "with ss_ne s u fh su' prc3 cf cg ch suA"], ["proof (chain)\npicking this:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by (simp add: lex_ext_iff)"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "case Lex"], ["proof (state)\nthis:\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "note cg = this"], ["proof (state)\nthis:\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succ> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succ> u", "proof (cases \"c ?h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "case Mul"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "from gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Mul", "have us_e: \"?mus = []\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "have \"\\<And>f. fst (lex_ext f n ?mss ?mts) \\<Longrightarrow> ?mss \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       fst (lex_ext fa n (map ((!) ss) (\\<sigma> (f, length ss)))\n             (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n       map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "by (cases ?mss) (simp_all add: lex_ext_iff)"], ["proof (state)\nthis:\n  fst (lex_ext ?f2 n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "with fg t ge1 st' prc nfg cf cg"], ["proof (chain)\npicking this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  fst (lex_ext ?f2 n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "have ss_ne: \"?mss \\<noteq> []\""], ["proof (prove)\nusing this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  fst (lex_ext ?f2 n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succ> u", "with us_e s u fh su' prc3 cf cg ch suA"], ["proof (chain)\npicking this:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by simp"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "case Lex"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from fg t ge1 st' nfg cf cg"], ["proof (chain)\npicking this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex", "have lex1: \"fst (lex_ext wpo n ?mss ?mts)\""], ["proof (prove)\nusing this:\n  pns\n  t = Fun g ts\n  fst (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                cf = c (f, length ss); cg = c (g, length ts)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts))))", "by auto"], ["proof (state)\nthis:\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Lex", "have lex2: \"snd (lex_ext wpo n ?mts ?mus)\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                ts' = map ((!) us) (\\<sigma> (h, length us));\n                cf = c (g, length ts); cg = c (h, length us)\n            in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n               else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                    else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                          length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. snd (lex_ext wpo n (map ((!) ts) (\\<sigma> (g, length ts)))\n          (map ((!) us) (\\<sigma> (h, length us))))", "by auto"], ["proof (state)\nthis:\n  snd (lex_ext wpo n (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "from lex1 lex2 lex_ext_compat[OF ind3', of ?mss ?mts ?mus]"], ["proof (chain)\npicking this:\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n  snd (lex_ext wpo n (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n  \\<lbrakk>\\<And>s t u.\n              \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n               t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n               u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n              \\<Longrightarrow> ?u'6 s\n                                \\<in> set\n (map ((!) ss) (\\<sigma> (f, length ss)));\n   \\<And>s t u.\n      \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n       t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n       u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n      \\<Longrightarrow> ?u'6 t\n                        \\<in> set (map ((!) ts)\n                                    (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us)))))", "have \"fst (lex_ext wpo n ?mss ?mus)\""], ["proof (prove)\nusing this:\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n  snd (lex_ext wpo n (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n  \\<lbrakk>\\<And>s t u.\n              \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n               t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n               u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n              \\<Longrightarrow> ?u'6 s\n                                \\<in> set\n (map ((!) ss) (\\<sigma> (f, length ss)));\n   \\<And>s t u.\n      \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n       t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n       u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n      \\<Longrightarrow> ?u'6 t\n                        \\<in> set (map ((!) ts)\n                                    (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us)))))\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) us) (\\<sigma> (h, length us))))", "by auto"], ["proof (state)\nthis:\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succ> u", "with s u fh su' prc3 cf cg ch suA"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. s \\<succ> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. fst (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by simp"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u", "case (Var z)"], ["proof (state)\nthis:\n  u = Var z\n\ngoal (1 subgoal):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u", "from ge2 \\<open>\\<not> ?t1\\<close> tuS"], ["proof (chain)\npicking this:\n  t \\<succeq> u\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  (t, u) \\<notin> S", "have \"ssimple\" \"large ?g\""], ["proof (prove)\nusing this:\n  t \\<succeq> u\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  (t, u) \\<notin> S\n\ngoal (1 subgoal):\n 1. ssimple &&& large (g, length ts)", "unfolding Var t"], ["proof (prove)\nusing this:\n  Fun g ts \\<succeq> Var z\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n             ts ! j \\<succeq> Var z)\n  (Fun g ts, Var z) \\<notin> S\n\ngoal (1 subgoal):\n 1. ssimple &&& large (g, length ts)", "by (auto simp: wpo.simps split: if_splits)"], ["proof (state)\nthis:\n  ssimple\n  large (g, length ts)\n\ngoal (1 subgoal):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u", "from large[OF this, of ?f]"], ["proof (chain)\npicking this:\n  fst (prc (g, length ts) (f, length ss)) \\<or>\n  snd (prc (g, length ts) (f, length ss)) \\<and>\n  \\<sigma> (f, length ss) = []", "have large: \"fst (prc ?g ?f) \\<or> snd (prc ?g ?f) \\<and> \\<sigma> ?f = []\""], ["proof (prove)\nusing this:\n  fst (prc (g, length ts) (f, length ss)) \\<or>\n  snd (prc (g, length ts) (f, length ss)) \\<and>\n  \\<sigma> (f, length ss) = []\n\ngoal (1 subgoal):\n 1. fst (prc (g, length ts) (f, length ss)) \\<or>\n    snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = []", "by auto"], ["proof (state)\nthis:\n  fst (prc (g, length ts) (f, length ss)) \\<or>\n  snd (prc (g, length ts) (f, length ss)) \\<and>\n  \\<sigma> (f, length ss) = []\n\ngoal (1 subgoal):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u", "obtain fgs fgns where prc_fg: \"prc ?f ?g = (fgs,fgns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fgs fgns.\n        prc (f, length ss) (g, length ts) = (fgs, fgns) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"prc ?f ?g\", auto)"], ["proof (state)\nthis:\n  prc (f, length ss) (g, length ts) = (fgs, fgns)\n\ngoal (1 subgoal):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u", "from ge1 \\<open>\\<not> ?s1\\<close> stS"], ["proof (chain)\npicking this:\n  s \\<succ> t\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  (s, t) \\<notin> S", "have weak_fg: \"snd (prc ?f ?g)\""], ["proof (prove)\nusing this:\n  s \\<succ> t\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  (s, t) \\<notin> S\n\ngoal (1 subgoal):\n 1. snd (prc (f, length ss) (g, length ts))", "unfolding s t"], ["proof (prove)\nusing this:\n  Fun f ss \\<succ> Fun g ts\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts)\n  (Fun f ss, Fun g ts) \\<notin> S\n\ngoal (1 subgoal):\n 1. snd (prc (f, length ss) (g, length ts))", "using prc_fg"], ["proof (prove)\nusing this:\n  Fun f ss \\<succ> Fun g ts\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts)\n  (Fun f ss, Fun g ts) \\<notin> S\n  prc (f, length ss) (g, length ts) = (fgs, fgns)\n\ngoal (1 subgoal):\n 1. snd (prc (f, length ss) (g, length ts))", "by (auto simp: wpo.simps split: if_splits)"], ["proof (state)\nthis:\n  snd (prc (f, length ss) (g, length ts))\n\ngoal (1 subgoal):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u", "from refl_not_SN[of ?f] prc_SN"], ["proof (chain)\npicking this:\n  ((f, length ss), f, length ss) \\<in> ?R \\<Longrightarrow> \\<not> SN ?R\n  SN {(f, g). fst (prc f g)}", "have prc_irrefl: \"\\<not> fst (prc ?f ?f)\""], ["proof (prove)\nusing this:\n  ((f, length ss), f, length ss) \\<in> ?R \\<Longrightarrow> \\<not> SN ?R\n  SN {(f, g). fst (prc f g)}\n\ngoal (1 subgoal):\n 1. \\<not> fst (prc (f, length ss) (f, length ss))", "by auto"], ["proof (state)\nthis:\n  \\<not> fst (prc (f, length ss) (f, length ss))\n\ngoal (1 subgoal):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u", "from large"], ["proof (chain)\npicking this:\n  fst (prc (g, length ts) (f, length ss)) \\<or>\n  snd (prc (g, length ts) (f, length ss)) \\<and>\n  \\<sigma> (f, length ss) = []", "have False"], ["proof (prove)\nusing this:\n  fst (prc (g, length ts) (f, length ss)) \\<or>\n  snd (prc (g, length ts) (f, length ss)) \\<and>\n  \\<sigma> (f, length ss) = []\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (prc (g, length ts) (f, length ss)) \\<Longrightarrow> False\n 2. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "assume \"fst (prc ?g ?f)\""], ["proof (state)\nthis:\n  fst (prc (g, length ts) (f, length ss))\n\ngoal (2 subgoals):\n 1. fst (prc (g, length ts) (f, length ss)) \\<Longrightarrow> False\n 2. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "with weak_fg"], ["proof (chain)\npicking this:\n  snd (prc (f, length ss) (g, length ts))\n  fst (prc (g, length ts) (f, length ss))", "have \"fst (prc ?f ?f)\""], ["proof (prove)\nusing this:\n  snd (prc (f, length ss) (g, length ts))\n  fst (prc (g, length ts) (f, length ss))\n\ngoal (1 subgoal):\n 1. fst (prc (f, length ss) (f, length ss))", "by (metis prc_compat prod.collapse)"], ["proof (state)\nthis:\n  fst (prc (f, length ss) (f, length ss))\n\ngoal (2 subgoals):\n 1. fst (prc (g, length ts) (f, length ss)) \\<Longrightarrow> False\n 2. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "with prc_irrefl"], ["proof (chain)\npicking this:\n  \\<not> fst (prc (f, length ss) (f, length ss))\n  fst (prc (f, length ss) (f, length ss))", "show False"], ["proof (prove)\nusing this:\n  \\<not> fst (prc (f, length ss) (f, length ss))\n  fst (prc (f, length ss) (f, length ss))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "assume weak: \"snd (prc ?g ?f) \\<and> \\<sigma> ?f = []\""], ["proof (state)\nthis:\n  snd (prc (g, length ts) (f, length ss)) \\<and>\n  \\<sigma> (f, length ss) = []\n\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "let ?mss = \"map (\\<lambda> i. ss ! i) (\\<sigma> ?f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "let ?mts = \"map (\\<lambda> j. ts ! j) (\\<sigma> ?g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "assume \"fst (prc ?f ?g)\""], ["proof (state)\nthis:\n  fst (prc (f, length ss) (g, length ts))\n\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "with weak"], ["proof (chain)\npicking this:\n  snd (prc (g, length ts) (f, length ss)) \\<and>\n  \\<sigma> (f, length ss) = []\n  fst (prc (f, length ss) (g, length ts))", "have \"fst (prc ?f ?f)\""], ["proof (prove)\nusing this:\n  snd (prc (g, length ts) (f, length ss)) \\<and>\n  \\<sigma> (f, length ss) = []\n  fst (prc (f, length ss) (g, length ts))\n\ngoal (1 subgoal):\n 1. fst (prc (f, length ss) (f, length ss))", "by (metis prc_compat prod.collapse)"], ["proof (state)\nthis:\n  fst (prc (f, length ss) (f, length ss))\n\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "with prc_irrefl"], ["proof (chain)\npicking this:\n  \\<not> fst (prc (f, length ss) (f, length ss))\n  fst (prc (f, length ss) (f, length ss))", "have False"], ["proof (prove)\nusing this:\n  \\<not> fst (prc (f, length ss) (f, length ss))\n  fst (prc (f, length ss) (f, length ss))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  fst (prc (f, length ss) (g, length ts)) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "hence \"\\<not> fst (prc ?f ?g)\""], ["proof (prove)\nusing this:\n  fst (prc (f, length ss) (g, length ts)) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> fst (prc (f, length ss) (g, length ts))", "by auto"], ["proof (state)\nthis:\n  \\<not> fst (prc (f, length ss) (g, length ts))\n\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "with ge1 \\<open>\\<not> ?s1\\<close> stS prc_fg"], ["proof (chain)\npicking this:\n  s \\<succ> t\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  (s, t) \\<notin> S\n  prc (f, length ss) (g, length ts) = (fgs, fgns)\n  \\<not> fst (prc (f, length ss) (g, length ts))", "have \"fst (lex_ext wpo n ?mss ?mts) \\<or> fst (mul_ext wpo ?mss ?mts) \\<or> ?mss \\<noteq> []\""], ["proof (prove)\nusing this:\n  s \\<succ> t\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  (s, t) \\<notin> S\n  prc (f, length ss) (g, length ts) = (fgs, fgns)\n  \\<not> fst (prc (f, length ss) (g, length ts))\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n    fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n    map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "unfolding wpo.simps[of s t]"], ["proof (prove)\nusing this:\n  fst (case s of\n       Var x \\<Rightarrow>\n         (False,\n          case t of Var xa \\<Rightarrow> x = xa\n          | Fun g ts \\<Rightarrow>\n              (s, t) \\<in> NS \\<and>\n              \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n       | Fun f ss \\<Rightarrow>\n           if (s, t) \\<in> S then (True, True)\n           else if (s, t) \\<in> NS\n                then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                           ss ! i \\<succeq> t\n                     then (True, True)\n                     else case t of\n                          Var x \\<Rightarrow>\n                            (False, ssimple \\<and> large (f, length ss))\n                          | Fun g ts \\<Rightarrow>\n                              case prc (f, length ss) (g, length ts) of\n                              (prs, prns) \\<Rightarrow>\n                                if prns \\<and>\n                                   (\\<forall>j\n       \\<in>set (\\<sigma> (g, length ts)).\n s \\<succ> ts ! j)\n                                then if prs then (True, True)\n                                     else let ss' =\n          map ((!) ss) (\\<sigma> (f, length ss));\n        ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n        cg = c (g, length ts)\n    in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n       else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n            else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                  length ts' = 0)\n                                else (False, False)\n                else (False, False))\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  (s, t) \\<notin> S\n  prc (f, length ss) (g, length ts) = (fgs, fgns)\n  \\<not> fst (prc (f, length ss) (g, length ts))\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n    fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n    map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "unfolding s t"], ["proof (prove)\nusing this:\n  fst (case Fun f ss of\n       Var x \\<Rightarrow>\n         (False,\n          case Fun g ts of Var xa \\<Rightarrow> x = xa\n          | Fun ga tsa \\<Rightarrow>\n              (Fun f ss, Fun g ts) \\<in> NS \\<and>\n              \\<sigma> (ga, length tsa) = [] \\<and> prl (ga, length tsa))\n       | Fun fa ssa \\<Rightarrow>\n           if (Fun f ss, Fun g ts) \\<in> S then (True, True)\n           else if (Fun f ss, Fun g ts) \\<in> NS\n                then if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                           ssa ! i \\<succeq> Fun g ts\n                     then (True, True)\n                     else case Fun g ts of\n                          Var x \\<Rightarrow>\n                            (False, ssimple \\<and> large (fa, length ssa))\n                          | Fun g ts \\<Rightarrow>\n                              case prc (fa, length ssa) (g, length ts) of\n                              (prs, prns) \\<Rightarrow>\n                                if prns \\<and>\n                                   (\\<forall>j\n       \\<in>set (\\<sigma> (g, length ts)).\n Fun f ss \\<succ> ts ! j)\n                                then if prs then (True, True)\n                                     else let ss' =\n          map ((!) ssa) (\\<sigma> (fa, length ssa));\n        ts' = map ((!) ts) (\\<sigma> (g, length ts));\n        cf = c (fa, length ssa); cg = c (g, length ts)\n    in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n       else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n            else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                  length ts' = 0)\n                                else (False, False)\n                else (False, False))\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts)\n  (Fun f ss, Fun g ts) \\<notin> S\n  prc (f, length ss) (g, length ts) = (fgs, fgns)\n  \\<not> fst (prc (f, length ss) (g, length ts))\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n    fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n    map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "by (auto simp: Let_def split: if_splits)"], ["proof (state)\nthis:\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "with weak"], ["proof (chain)\npicking this:\n  snd (prc (g, length ts) (f, length ss)) \\<and>\n  \\<sigma> (f, length ss) = []\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []", "have \"fst (lex_ext wpo n [] ?mts) \\<or> fst (mul_ext wpo [] ?mts)\""], ["proof (prove)\nusing this:\n  snd (prc (g, length ts) (f, length ss)) \\<and>\n  \\<sigma> (f, length ss) = []\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n  map ((!) ss) (\\<sigma> (f, length ss)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n [] (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n    fst (mul_ext wpo [] (map ((!) ts) (\\<sigma> (g, length ts))))", "by auto"], ["proof (state)\nthis:\n  fst (lex_ext wpo n [] (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n  fst (mul_ext wpo [] (map ((!) ts) (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. snd (prc (g, length ts) (f, length ss)) \\<and>\n    \\<sigma> (f, length ss) = [] \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  fst (lex_ext wpo n [] (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n  fst (mul_ext wpo [] (map ((!) ts) (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. False", "using lex_ext_least_2"], ["proof (prove)\nusing this:\n  fst (lex_ext wpo n [] (map ((!) ts) (\\<sigma> (g, length ts)))) \\<or>\n  fst (mul_ext wpo [] (map ((!) ts) (\\<sigma> (g, length ts))))\n  \\<not> fst (lex_ext ?f ?m [] ?ys)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: mul_ext_def Let_def s_mul_ext_bottom_strict)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succ> u", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. s \\<succ> u", ".."], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk> \\<Longrightarrow> s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk> \\<Longrightarrow> s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk> \\<Longrightarrow> s \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "assume ge1: \"s \\<succeq> t\" and ge2: \"t \\<succeq> u\" and ngt1: \"\\<not> s \\<succ> t\" and ngt2: \"\\<not> t \\<succ> u\""], ["proof (state)\nthis:\n  s \\<succeq> t\n  t \\<succeq> u\n  \\<not> s \\<succ> t\n  \\<not> t \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from wpo_ns_imp_NS[OF ge1]"], ["proof (chain)\npicking this:\n  (s, t) \\<in> NS", "have stA: \"(s,t) \\<in> NS\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> NS", "."], ["proof (state)\nthis:\n  (s, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from wpo_ns_imp_NS[OF ge2]"], ["proof (chain)\npicking this:\n  (t, u) \\<in> NS", "have tuA: \"(t,u) \\<in> NS\""], ["proof (prove)\nusing this:\n  (t, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. (t, u) \\<in> NS", "."], ["proof (state)\nthis:\n  (t, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from trans_NS_point[OF stA tuA]"], ["proof (chain)\npicking this:\n  (s, u) \\<in> NS", "have suA: \"(s,u) \\<in> NS\""], ["proof (prove)\nusing this:\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. (s, u) \\<in> NS", "."], ["proof (state)\nthis:\n  (s, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from ngt1 stA"], ["proof (chain)\npicking this:\n  \\<not> s \\<succ> t\n  (s, t) \\<in> NS", "have \"\\<not> ?s1\""], ["proof (prove)\nusing this:\n  \\<not> s \\<succ> t\n  (s, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t)", "unfolding s t"], ["proof (prove)\nusing this:\n  \\<not> Fun f ss \\<succ> Fun g ts\n  (Fun f ss, Fun g ts) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> Fun g ts)", "by (auto simp: wpo.simps split: if_splits)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "from ngt2 tuA"], ["proof (chain)\npicking this:\n  \\<not> t \\<succ> u\n  (t, u) \\<in> NS", "have \"\\<not> ?t1\""], ["proof (prove)\nusing this:\n  \\<not> t \\<succ> u\n  (t, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u)", "unfolding t"], ["proof (prove)\nusing this:\n  \\<not> Fun g ts \\<succ> u\n  (Fun g ts, u) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n               ts ! j \\<succeq> u)", "by (cases u, auto simp: wpo.simps split: if_splits)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "have \"s \\<succeq> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> u", "proof (cases u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succeq> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "case u: (Var x)"], ["proof (state)\nthis:\n  u = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succeq> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from t \\<open>\\<not> ?t1\\<close> ge2 tuA ngt2"], ["proof (chain)\npicking this:\n  t = Fun g ts\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  t \\<succeq> u\n  (t, u) \\<in> NS\n  \\<not> t \\<succ> u", "have large: \"ssimple\" \"large ?g\""], ["proof (prove)\nusing this:\n  t = Fun g ts\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  t \\<succeq> u\n  (t, u) \\<in> NS\n  \\<not> t \\<succ> u\n\ngoal (1 subgoal):\n 1. ssimple &&& large (g, length ts)", "unfolding u"], ["proof (prove)\nusing this:\n  t = Fun g ts\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)).\n             ts ! j \\<succeq> Var x)\n  t \\<succeq> Var x\n  (t, Var x) \\<in> NS\n  \\<not> t \\<succ> Var x\n\ngoal (1 subgoal):\n 1. ssimple &&& large (g, length ts)", "by (auto simp: wpo.simps split: if_splits)"], ["proof (state)\nthis:\n  ssimple\n  large (g, length ts)\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succeq> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from s t ngt1 ge1"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  t = Fun g ts\n  \\<not> s \\<succ> t\n  s \\<succeq> t", "have \"snd (prc ?f ?g)\""], ["proof (prove)\nusing this:\n  s = Fun f ss\n  t = Fun g ts\n  \\<not> s \\<succ> t\n  s \\<succeq> t\n\ngoal (1 subgoal):\n 1. snd (prc (f, length ss) (g, length ts))", "by (auto simp: wpo.simps split: if_splits prod.splits)"], ["proof (state)\nthis:\n  snd (prc (f, length ss) (g, length ts))\n\ngoal (2 subgoals):\n 1. \\<And>x1. u = Var x1 \\<Longrightarrow> s \\<succeq> u\n 2. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from large_trans[OF large this] suA large"], ["proof (chain)\npicking this:\n  large (f, length ss)\n  (s, u) \\<in> NS\n  ssimple\n  large (g, length ts)", "show ?thesis"], ["proof (prove)\nusing this:\n  large (f, length ss)\n  (s, u) \\<in> NS\n  ssimple\n  large (g, length ts)\n\ngoal (1 subgoal):\n 1. s \\<succeq> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  large (f, length ss)\n  (s, u) \\<in> NS\n  ssimple\n  large (g, length ts)\n\ngoal (1 subgoal):\n 1. snd (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "using s u"], ["proof (prove)\nusing this:\n  large (f, length ss)\n  (s, u) \\<in> NS\n  ssimple\n  large (g, length ts)\n  s = Fun f ss\n  u = Var x\n\ngoal (1 subgoal):\n 1. snd (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by auto"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "case u: (Fun h us)"], ["proof (state)\nthis:\n  u = Fun h us\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "let ?u = \"Fun h us\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "let ?h = \"(h,length us)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "let ?us = \"set (\\<sigma> ?h)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "let ?mss = \"map (\\<lambda> i. ss ! i) (\\<sigma> ?f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "let ?mts = \"map (\\<lambda> j. ts ! j) (\\<sigma> ?g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "let ?mus = \"map (\\<lambda> k. us ! k) (\\<sigma> ?h)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from s t u ge1 ge2"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  t = Fun g ts\n  u = Fun h us\n  s \\<succeq> t\n  t \\<succeq> u", "have ge1: \"?s \\<succeq> ?t\" and ge2: \"?t \\<succeq> ?u\""], ["proof (prove)\nusing this:\n  s = Fun f ss\n  t = Fun g ts\n  u = Fun h us\n  s \\<succeq> t\n  t \\<succeq> u\n\ngoal (1 subgoal):\n 1. Fun f ss \\<succeq> Fun g ts &&& Fun g ts \\<succeq> Fun h us", "by auto"], ["proof (state)\nthis:\n  Fun f ss \\<succeq> Fun g ts\n  Fun g ts \\<succeq> Fun h us\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from stA stS s t"], ["proof (chain)\npicking this:\n  (s, t) \\<in> NS\n  (s, t) \\<notin> S\n  s = Fun f ss\n  t = Fun g ts", "have stAS: \"((?s,?t) \\<in> S) = False\" \"((?s,?t) \\<in> NS) = True\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> NS\n  (s, t) \\<notin> S\n  s = Fun f ss\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. ((Fun f ss, Fun g ts) \\<in> S) = False &&&\n    ((Fun f ss, Fun g ts) \\<in> NS) = True", "by auto"], ["proof (state)\nthis:\n  ((Fun f ss, Fun g ts) \\<in> S) = False\n  ((Fun f ss, Fun g ts) \\<in> NS) = True\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from tuA tuS t u"], ["proof (chain)\npicking this:\n  (t, u) \\<in> NS\n  (t, u) \\<notin> S\n  t = Fun g ts\n  u = Fun h us", "have tuAS: \"((?t,?u) \\<in> S) = False\" \"((?t,?u) \\<in> NS) = True\""], ["proof (prove)\nusing this:\n  (t, u) \\<in> NS\n  (t, u) \\<notin> S\n  t = Fun g ts\n  u = Fun h us\n\ngoal (1 subgoal):\n 1. ((Fun g ts, Fun h us) \\<in> S) = False &&&\n    ((Fun g ts, Fun h us) \\<in> NS) = True", "by auto"], ["proof (state)\nthis:\n  ((Fun g ts, Fun h us) \\<in> S) = False\n  ((Fun g ts, Fun h us) \\<in> NS) = True\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "note ge1 = ge1[unfolded wpo.simps[of ?s ?t] stAS, simplified]"], ["proof (state)\nthis:\n  snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "note ge2 = ge2[unfolded wpo.simps[of ?t ?u] tuAS, simplified]"], ["proof (state)\nthis:\n  snd (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from s t u ngt1 ngt2"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  t = Fun g ts\n  u = Fun h us\n  \\<not> s \\<succ> t\n  \\<not> t \\<succ> u", "have ngt1: \"\\<not> ?s \\<succ> ?t\" and ngt2: \"\\<not> ?t \\<succ> ?u\""], ["proof (prove)\nusing this:\n  s = Fun f ss\n  t = Fun g ts\n  u = Fun h us\n  \\<not> s \\<succ> t\n  \\<not> t \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<not> Fun f ss \\<succ> Fun g ts &&& \\<not> Fun g ts \\<succ> Fun h us", "by auto"], ["proof (state)\nthis:\n  \\<not> Fun f ss \\<succ> Fun g ts\n  \\<not> Fun g ts \\<succ> Fun h us\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "note ngt1 = ngt1[unfolded wpo.simps[of ?s ?t] stAS, simplified]"], ["proof (state)\nthis:\n  \\<not> fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts\n              then (True, True)\n              else case Fun g ts of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Fun f ss \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "note ngt2 = ngt2[unfolded wpo.simps[of ?t ?u] tuAS, simplified]"], ["proof (state)\nthis:\n  \\<not> fst (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n                    ts ! i \\<succeq> Fun h us\n              then (True, True)\n              else case Fun h us of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (g, length ts))\n                   | Fun ga tsa \\<Rightarrow>\n                       case prc (g, length ts) (ga, length tsa) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                                Fun g ts \\<succ> tsa ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ts) (\\<sigma> (g, length ts));\n ts' = map ((!) tsa) (\\<sigma> (ga, length tsa)); cf = c (g, length ts);\n cg = c (ga, length tsa)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from \\<open>\\<not> ?s1\\<close> t ge1"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))", "have st': \"\\<forall> j \\<in> ?ts. ?s \\<succ> ts ! j\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j", "by (cases ?thesis, auto)"], ["proof (state)\nthis:\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from \\<open>\\<not> ?t1\\<close> u ge2"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  u = Fun h us\n  snd (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))", "have tu': \"\\<forall> k \\<in> ?us. ?t \\<succ> us ! k\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  u = Fun h us\n  snd (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k", "by (cases ?thesis, auto)"], ["proof (state)\nthis:\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "let ?lu = \"length us\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "obtain ps2 pns2 where prc2: \"prc ?g ?h = (ps2,pns2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps2 pns2.\n        prc (g, length ts) (h, length us) = (ps2, pns2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "obtain ps3 pns3 where prc3: \"prc ?f ?h = (ps3,pns3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps3 pns3.\n        prc (f, length ss) (h, length us) = (ps3, pns3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from \\<open>\\<not> ?s1\\<close> t ge1 st'"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j", "have fg: \"pns\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  t = Fun g ts\n  snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else case Fun g ts of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         Fun f ss \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n\ngoal (1 subgoal):\n 1. pns", "by (cases ?thesis, auto simp: prc)"], ["proof (state)\nthis:\n  pns\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from \\<open>\\<not> ?t1\\<close> u ge2 tu'"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  u = Fun h us\n  snd (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k", "have gh: \"pns2\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  u = Fun h us\n  snd (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n             ts ! i \\<succeq> Fun h us\n       then (True, True)\n       else case Fun h us of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (g, length ts))\n            | Fun ga tsa \\<Rightarrow>\n                case prc (g, length ts) (ga, length tsa) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                         Fun g ts \\<succ> tsa ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                ts' =\n                                  map ((!) tsa) (\\<sigma> (ga, length tsa));\n                                cf = c (g, length ts);\n                                cg = c (ga, length tsa)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n\ngoal (1 subgoal):\n 1. pns2", "by (cases ?thesis, auto simp: prc2)"], ["proof (state)\nthis:\n  pns2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "note compat = prc_compat[OF prc prc2 prc3]"], ["proof (state)\nthis:\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from \\<open>\\<not> ?s1\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)", "have \"?s1 = False\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n\ngoal (1 subgoal):\n 1. (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t) =\n    False", "by simp"], ["proof (state)\nthis:\n  (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t) = False\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "note ge1 = ge1[unfolded this[unfolded t] if_False term.simps prc split]"], ["proof (state)\nthis:\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from \\<open>\\<not> ?t1\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)", "have \"?t1 = False\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n\ngoal (1 subgoal):\n 1. (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u) =\n    False", "by simp"], ["proof (state)\nthis:\n  (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u) = False\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "note ge2 = ge2[unfolded this[unfolded u] if_False term.simps prc2 split]"], ["proof (state)\nthis:\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from compat fg gh"], ["proof (chain)\npicking this:\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)\n  pns\n  pns2", "have fh: pns3"], ["proof (prove)\nusing this:\n  (pns \\<and> pns2 \\<longrightarrow> pns3) \\<and>\n  (pns \\<and> ps2 \\<longrightarrow> ps3) \\<and>\n  (ps \\<and> pns2 \\<longrightarrow> ps3)\n  pns\n  pns2\n\ngoal (1 subgoal):\n 1. pns3", "by blast"], ["proof (state)\nthis:\n  pns3\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "{"], ["proof (state)\nthis:\n  pns3\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "assume k: \"k \\<in> ?us\""], ["proof (state)\nthis:\n  k \\<in> set (\\<sigma> (h, length us))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from \\<sigma>E[OF this]"], ["proof (chain)\npicking this:\n  us ! k \\<in> set us", "have \"size (us ! k) < size u\""], ["proof (prove)\nusing this:\n  us ! k \\<in> set us\n\ngoal (1 subgoal):\n 1. size (us ! k) < size u", "unfolding u"], ["proof (prove)\nusing this:\n  us ! k \\<in> set us\n\ngoal (1 subgoal):\n 1. size (us ! k) < size (Fun h us)", "using size_simps"], ["proof (prove)\nusing this:\n  us ! k \\<in> set us\n  ?t \\<in> set ?ts \\<Longrightarrow> size ?t < Suc (size_list size ?ts)\n  ?t \\<in> set ?ts \\<Longrightarrow>\n  size ?t < Suc (Suc (size ?s + size_list size ?ts))\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?x < Suc (size_list size ?xs)\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow>\n  size ?y < Suc (size_list size ?ys)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<rhd> ?t; size ?t < size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t < Suc (size_list size ?ss)\n  \\<lbrakk>?s \\<in> set ?ss; ?s \\<unrhd> ?t; size ?t \\<le> size ?s\\<rbrakk>\n  \\<Longrightarrow> size ?t \\<le> Suc (size_list size ?ss)\n\ngoal (1 subgoal):\n 1. size (us ! k) < size (Fun h us)", "by auto"], ["proof (state)\nthis:\n  size (us ! k) < size u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "with tu'[folded t] \\<open>s \\<succeq> t\\<close>\n                ind[rule_format, of s t \"us ! k\"] k"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). t \\<succ> us ! k\n  s \\<succeq> t\n  (size s < size s \\<longrightarrow>\n   (s \\<succeq> t \\<and> t \\<succ> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succ> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succeq> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succeq> us ! k)) \\<and>\n  (size s = size s \\<and>\n   (size t < size t \\<or>\n    size t = size t \\<and> size (us ! k) < size u) \\<longrightarrow>\n   (s \\<succeq> t \\<and> t \\<succ> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succ> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succeq> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succeq> us ! k))\n  k \\<in> set (\\<sigma> (h, length us))\n  size (us ! k) < size u", "have \"s \\<succ> us ! k\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). t \\<succ> us ! k\n  s \\<succeq> t\n  (size s < size s \\<longrightarrow>\n   (s \\<succeq> t \\<and> t \\<succ> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succ> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succeq> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succeq> us ! k)) \\<and>\n  (size s = size s \\<and>\n   (size t < size t \\<or>\n    size t = size t \\<and> size (us ! k) < size u) \\<longrightarrow>\n   (s \\<succeq> t \\<and> t \\<succ> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succ> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succ> us ! k) \\<and>\n   (s \\<succeq> t \\<and> t \\<succeq> us ! k \\<longrightarrow>\n    s \\<succeq> us ! k))\n  k \\<in> set (\\<sigma> (h, length us))\n  size (us ! k) < size u\n\ngoal (1 subgoal):\n 1. s \\<succ> us ! k", "by blast"], ["proof (state)\nthis:\n  s \\<succ> us ! k\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "}"], ["proof (state)\nthis:\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "note su' = this"], ["proof (state)\nthis:\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from \\<open>\\<not> ?s1\\<close> st' ge1 ngt1 s t"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<not> fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts\n              then (True, True)\n              else case Fun g ts of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Fun f ss \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))\n  s = Fun f ss\n  t = Fun g ts", "have nfg: \"\\<not> ps\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<not> fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts\n              then (True, True)\n              else case Fun g ts of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Fun f ss \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))\n  s = Fun f ss\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. \\<not> ps", "by (simp, cases ?thesis, simp, cases ps, auto simp: prc fg)"], ["proof (state)\nthis:\n  \\<not> ps\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "from \\<open>\\<not> ?t1\\<close> tu' ge2 ngt2 t u"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<not> fst (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n                    ts ! i \\<succeq> Fun h us\n              then (True, True)\n              else case Fun h us of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (g, length ts))\n                   | Fun ga tsa \\<Rightarrow>\n                       case prc (g, length ts) (ga, length tsa) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                                Fun g ts \\<succ> tsa ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ts) (\\<sigma> (g, length ts));\n ts' = map ((!) tsa) (\\<sigma> (ga, length tsa)); cf = c (g, length ts);\n cg = c (ga, length tsa)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))\n  t = Fun g ts\n  u = Fun h us", "have ngh: \"\\<not> ps2\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j\\<in>set (\\<sigma> (g, length ts)). ts ! j \\<succeq> u)\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<not> fst (if \\<exists>i\\<in>set (\\<sigma> (g, length ts)).\n                    ts ! i \\<succeq> Fun h us\n              then (True, True)\n              else case Fun h us of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (g, length ts))\n                   | Fun ga tsa \\<Rightarrow>\n                       case prc (g, length ts) (ga, length tsa) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (ga, length tsa)).\n                                Fun g ts \\<succ> tsa ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ts) (\\<sigma> (g, length ts));\n ts' = map ((!) tsa) (\\<sigma> (ga, length tsa)); cf = c (g, length ts);\n cg = c (ga, length tsa)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))\n  t = Fun g ts\n  u = Fun h us\n\ngoal (1 subgoal):\n 1. \\<not> ps2", "by (simp, cases ?thesis, simp, cases ps2, auto simp: prc2 gh)"], ["proof (state)\nthis:\n  \\<not> ps2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. u = Fun x21 x22 \\<Longrightarrow> s \\<succeq> u", "show \"s \\<succeq> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> u", "proof (cases \"c ?f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (f, length ss) = Mul \\<Longrightarrow> s \\<succeq> u", "case Mul"], ["proof (state)\nthis:\n  c (f, length ss) = Mul\n\ngoal (2 subgoals):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (f, length ss) = Mul \\<Longrightarrow> s \\<succeq> u", "note cf = this"], ["proof (state)\nthis:\n  c (f, length ss) = Mul\n\ngoal (2 subgoals):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (f, length ss) = Mul \\<Longrightarrow> s \\<succeq> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> u", "proof (cases \"c ?g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succeq> u", "case Mul"], ["proof (state)\nthis:\n  c (g, length ts) = Mul\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succeq> u", "note cg = this"], ["proof (state)\nthis:\n  c (g, length ts) = Mul\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succeq> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> u", "proof (cases \"c ?h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "case Mul"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "from fg t ge1 st' nfg cf cg"], ["proof (chain)\npicking this:\n  pns\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul", "have mul1: \"snd (mul_ext wpo ?mss ?mts)\""], ["proof (prove)\nusing this:\n  pns\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n\ngoal (1 subgoal):\n 1. snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts))))", "by auto"], ["proof (state)\nthis:\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "from gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Mul", "have mul2: \"snd (mul_ext wpo ?mts ?mus)\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Mul\n\ngoal (1 subgoal):\n 1. snd (mul_ext wpo (map ((!) ts) (\\<sigma> (g, length ts)))\n          (map ((!) us) (\\<sigma> (h, length us))))", "by auto"], ["proof (state)\nthis:\n  snd (mul_ext wpo (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "from mul1 mul2 mul_ext_compat[OF ind3', of ?mss ?mts ?mus]"], ["proof (chain)\npicking this:\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n  snd (mul_ext wpo (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n  \\<lbrakk>\\<And>s t u.\n              \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n               t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n               u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n              \\<Longrightarrow> ?u'6 s\n                                \\<in> set\n (map ((!) ss) (\\<sigma> (f, length ss)));\n   \\<And>s t u.\n      \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n       t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n       u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n      \\<Longrightarrow> ?u'6 t\n                        \\<in> set (map ((!) ts)\n                                    (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us)))))", "have \"snd (mul_ext wpo ?mss ?mus)\""], ["proof (prove)\nusing this:\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n  snd (mul_ext wpo (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n  \\<lbrakk>\\<And>s t u.\n              \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n               t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n               u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n              \\<Longrightarrow> ?u'6 s\n                                \\<in> set\n (map ((!) ss) (\\<sigma> (f, length ss)));\n   \\<And>s t u.\n      \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n       t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n       u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n      \\<Longrightarrow> ?u'6 t\n                        \\<in> set (map ((!) ts)\n                                    (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     snd (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (mul_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t))\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us)))))\n\ngoal (1 subgoal):\n 1. snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) us) (\\<sigma> (h, length us))))", "by auto"], ["proof (state)\nthis:\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "with s u fh su' prc3 cf ch suA"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. s \\<succeq> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. snd (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by simp"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "case Lex"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "from gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Lex", "have us_e: \"?mus = []\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "with s u fh su' prc3 cf cg ch suA"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. s \\<succeq> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. snd (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by simp"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u", "case Lex"], ["proof (state)\nthis:\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u", "note cg = this"], ["proof (state)\nthis:\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u", "from fg t ge1 st' nfg cf cg"], ["proof (chain)\npicking this:\n  pns\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex", "have ts_e: \"?mts = []\""], ["proof (prove)\nusing this:\n  pns\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  \\<not> ps\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. map ((!) ts) (\\<sigma> (g, length ts)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> u", "proof (cases \"c ?h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "case Mul"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "with gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  c (h, length us) = Mul", "have \"?mus = []\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  c (h, length us) = Mul\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "with s u fh su' prc3 cf cg ch ns_mul_ext_bottom suA"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  (?A, {#}) \\<in> ns_mul_ext ?ns ?s\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  (?A, {#}) \\<in> ns_mul_ext ?ns ?s\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. s \\<succeq> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  (?A, {#}) \\<in> ns_mul_ext ?ns ?s\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. snd (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by (simp add: ns_mul_ext_def mul_ext_def Let_def mult2_alt_ns_def)"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "case Lex"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "have \"\\<And>f. snd (lex_ext f n [] ?mus) \\<Longrightarrow> ?mus = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       snd (lex_ext f n []\n             (map ((!) us) (\\<sigma> (h, length us)))) \\<Longrightarrow>\n       map ((!) us) (\\<sigma> (h, length us)) = []", "by (simp_all add: lex_ext_iff)"], ["proof (state)\nthis:\n  snd (lex_ext ?f2 n []\n        (map ((!) us) (\\<sigma> (h, length us)))) \\<Longrightarrow>\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "with ts_e gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  snd (lex_ext ?f2 n []\n        (map ((!) us) (\\<sigma> (h, length us)))) \\<Longrightarrow>\n  map ((!) us) (\\<sigma> (h, length us)) = []", "have \"?mus = []\""], ["proof (prove)\nusing this:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  snd (lex_ext ?f2 n []\n        (map ((!) us) (\\<sigma> (h, length us)))) \\<Longrightarrow>\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "with s u fh su' prc3 cf cg ch suA"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. s \\<succeq> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Mul\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. snd (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by simp"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal (1 subgoal):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succeq> u", "case Lex"], ["proof (state)\nthis:\n  c (f, length ss) = Lex\n\ngoal (1 subgoal):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succeq> u", "note cf = this"], ["proof (state)\nthis:\n  c (f, length ss) = Lex\n\ngoal (1 subgoal):\n 1. c (f, length ss) = Lex \\<Longrightarrow> s \\<succeq> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> u", "proof (cases \"c ?g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succeq> u", "case Mul"], ["proof (state)\nthis:\n  c (g, length ts) = Mul\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succeq> u", "note cg = this"], ["proof (state)\nthis:\n  c (g, length ts) = Mul\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succeq> u", "from fg t ge1 st' prc nfg cf cg"], ["proof (chain)\npicking this:\n  pns\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul", "have ts_e: \"?mts = []\""], ["proof (prove)\nusing this:\n  pns\n  t = Fun g ts\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n\ngoal (1 subgoal):\n 1. map ((!) ts) (\\<sigma> (g, length ts)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n\ngoal (2 subgoals):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (g, length ts) = Mul \\<Longrightarrow> s \\<succeq> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> u", "proof (cases \"c ?h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "case Mul"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "with ts_e gh u ge2 tu' ngh cg ch\n                    ns_mul_ext_bottom_uniqueness[of \"mset ?mus\"]"], ["proof (chain)\npicking this:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Mul\n  ({#}, mset (map ((!) us) (\\<sigma> (h, length us))))\n  \\<in> ns_mul_ext ?ns ?s \\<Longrightarrow>\n  mset (map ((!) us) (\\<sigma> (h, length us))) = {#}\n  c (h, length us) = Mul", "have \"?mus = []\""], ["proof (prove)\nusing this:\n  map ((!) ts) (\\<sigma> (g, length ts)) = []\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Mul\n  ({#}, mset (map ((!) us) (\\<sigma> (h, length us))))\n  \\<in> ns_mul_ext ?ns ?s \\<Longrightarrow>\n  mset (map ((!) us) (\\<sigma> (h, length us))) = {#}\n  c (h, length us) = Mul\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by (simp add: Let_def mul_ext_def)"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "with s u fh su' prc3 cf cg ch suA"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. s \\<succeq> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. snd (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by simp"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "case Lex"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "with gh u ge2 tu' prc2 ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  c (h, length us) = Lex", "have \"?mus = []\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  prc (g, length ts) (h, length us) = (ps2, pns2)\n  \\<not> ps2\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "with s u fh su' prc3 cf cg ch suA"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. s \\<succeq> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Mul\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. snd (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by (simp add: lex_ext_least_1)"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u", "case Lex"], ["proof (state)\nthis:\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u", "note cg = this"], ["proof (state)\nthis:\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. c (g, length ts) = Lex \\<Longrightarrow> s \\<succeq> u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> u", "proof (cases \"c ?h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "case Mul"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Mul\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "with gh u ge2 tu' ngh cg ch"], ["proof (chain)\npicking this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  c (h, length us) = Mul", "have \"?mus = []\""], ["proof (prove)\nusing this:\n  pns2\n  u = Fun h us\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  c (h, length us) = Mul\n\ngoal (1 subgoal):\n 1. map ((!) us) (\\<sigma> (h, length us)) = []", "by simp"], ["proof (state)\nthis:\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (2 subgoals):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u\n 2. c (h, length us) = Mul \\<Longrightarrow> s \\<succeq> u", "with s u fh su' prc3 cf cg ch suA"], ["proof (chain)\npicking this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. s \\<succeq> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  prc (f, length ss) (h, length us) = (ps3, pns3)\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Mul\n  (s, u) \\<in> NS\n  map ((!) us) (\\<sigma> (h, length us)) = []\n\ngoal (1 subgoal):\n 1. snd (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by (simp add: lex_ext_least_1)"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "case Lex"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "note ch = this"], ["proof (state)\nthis:\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "from st' ge1 s t fg nfg cf cg"], ["proof (chain)\npicking this:\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  s = Fun f ss\n  t = Fun g ts\n  pns\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex", "have lex1: \"snd (lex_ext wpo n ?mss ?mts)\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<in>set (\\<sigma> (g, length ts)). Fun f ss \\<succ> ts ! j\n  snd (if pns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if ps then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  s = Fun f ss\n  t = Fun g ts\n  pns\n  \\<not> ps\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n\ngoal (1 subgoal):\n 1. snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts))))", "by (auto simp: prc)"], ["proof (state)\nthis:\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "from tu' ge2 t u gh ngh cg ch"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  t = Fun g ts\n  u = Fun h us\n  pns2\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Lex", "have lex2: \"snd (lex_ext wpo n ?mts ?mus)\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>set (\\<sigma> (h, length us)). Fun g ts \\<succ> us ! k\n  snd (if pns2 \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (h, length us)).\n              Fun g ts \\<succ> us ! j)\n       then if ps2 then (True, True)\n            else let ss' = map ((!) ts) (\\<sigma> (g, length ts));\n                     ts' = map ((!) us) (\\<sigma> (h, length us));\n                     cf = c (g, length ts); cg = c (h, length us)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  t = Fun g ts\n  u = Fun h us\n  pns2\n  \\<not> ps2\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n\ngoal (1 subgoal):\n 1. snd (lex_ext wpo n (map ((!) ts) (\\<sigma> (g, length ts)))\n          (map ((!) us) (\\<sigma> (h, length us))))", "by (auto simp: prc2)"], ["proof (state)\nthis:\n  snd (lex_ext wpo n (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "from lex1 lex2 lex_ext_compat[OF ind3', of ?mss ?mts ?mus]"], ["proof (chain)\npicking this:\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n  snd (lex_ext wpo n (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n  \\<lbrakk>\\<And>s t u.\n              \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n               t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n               u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n              \\<Longrightarrow> ?u'6 s\n                                \\<in> set\n (map ((!) ss) (\\<sigma> (f, length ss)));\n   \\<And>s t u.\n      \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n       t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n       u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n      \\<Longrightarrow> ?u'6 t\n                        \\<in> set (map ((!) ts)\n                                    (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us)))))", "have \"snd (lex_ext wpo n ?mss ?mus)\""], ["proof (prove)\nusing this:\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n  snd (lex_ext wpo n (map ((!) ts) (\\<sigma> (g, length ts)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n  \\<lbrakk>\\<And>s t u.\n              \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n               t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n               u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n              \\<Longrightarrow> ?u'6 s\n                                \\<in> set\n (map ((!) ss) (\\<sigma> (f, length ss)));\n   \\<And>s t u.\n      \\<lbrakk>s \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n       t \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n       u \\<in> set (map ((!) us) (\\<sigma> (h, length us)))\\<rbrakk>\n      \\<Longrightarrow> ?u'6 t\n                        \\<in> set (map ((!) ts)\n                                    (\\<sigma> (g, length ts)))\\<rbrakk>\n  \\<Longrightarrow> (snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     snd (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us))))) \\<and>\n                    (fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) ts) (\\<sigma> (g, length ts)))) \\<and>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ts) (\\<sigma> (g, length ts)))\n                           (map ((!) us)\n                             (\\<sigma> (h, length us)))) \\<longrightarrow>\n                     fst (lex_ext (\\<lambda>s t. wpo (?u'6 s) (?u'6 t)) ?n\n                           (map ((!) ss) (\\<sigma> (f, length ss)))\n                           (map ((!) us) (\\<sigma> (h, length us)))))\n\ngoal (1 subgoal):\n 1. snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) us) (\\<sigma> (h, length us))))", "by auto"], ["proof (state)\nthis:\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. c (h, length us) = Lex \\<Longrightarrow> s \\<succeq> u", "with fg gh su' s u fh cf cg ch suA"], ["proof (chain)\npicking this:\n  pns\n  pns2\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))", "show ?thesis"], ["proof (prove)\nusing this:\n  pns\n  pns2\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. s \\<succeq> u", "unfolding wpo.simps[of s u]"], ["proof (prove)\nusing this:\n  pns\n  pns2\n  ?k4 \\<in> set (\\<sigma> (h, length us)) \\<Longrightarrow>\n  s \\<succ> us ! ?k4\n  s = Fun f ss\n  u = Fun h us\n  pns3\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  c (h, length us) = Lex\n  (s, u) \\<in> NS\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) us) (\\<sigma> (h, length us))))\n\ngoal (1 subgoal):\n 1. snd (case s of\n         Var x \\<Rightarrow>\n           (False,\n            case u of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                (s, u) \\<in> NS \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if (s, u) \\<in> S then (True, True)\n             else if (s, u) \\<in> NS\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> u\n                       then (True, True)\n                       else case u of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by (auto simp: prc3)"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succeq> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>s \\<succeq> t; t \\<succeq> u; \\<not> s \\<succ> t;\n   \\<not> t \\<succ> u\\<rbrakk>\n  \\<Longrightarrow> s \\<succeq> u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow>\n        s \\<succ> u) \\<and>\n       (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk> \\<Longrightarrow> s \\<succ> u\n  \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk> \\<Longrightarrow> s \\<succ> u\n  \\<lbrakk>s \\<succeq> t; t \\<succeq> u; \\<not> s \\<succ> t;\n   \\<not> t \\<succ> u\\<rbrakk>\n  \\<Longrightarrow> s \\<succeq> u", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk> \\<Longrightarrow> s \\<succ> u\n  \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk> \\<Longrightarrow> s \\<succ> u\n  \\<lbrakk>s \\<succeq> t; t \\<succeq> u; \\<not> s \\<succ> t;\n   \\<not> t \\<succ> u\\<rbrakk>\n  \\<Longrightarrow> s \\<succeq> u\n\ngoal (1 subgoal):\n 1. (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "using wpo_s_imp_ns"], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<succeq> t; t \\<succ> u\\<rbrakk> \\<Longrightarrow> s \\<succ> u\n  \\<lbrakk>s \\<succ> t; t \\<succeq> u\\<rbrakk> \\<Longrightarrow> s \\<succ> u\n  \\<lbrakk>s \\<succeq> t; t \\<succeq> u; \\<not> s \\<succ> t;\n   \\<not> t \\<succ> u\\<rbrakk>\n  \\<Longrightarrow> s \\<succeq> u\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n\ngoal (1 subgoal):\n 1. (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n    (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)", "by auto"], ["proof (state)\nthis:\n  (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succeq> t \\<and> t \\<succ> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succ> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succ> u) \\<and>\n  (s \\<succeq> t \\<and> t \\<succeq> u \\<longrightarrow> s \\<succeq> u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subterm_wpo_s_arg: assumes i: \"i \\<in> set (\\<sigma> (f,length ss))\"\n  shows \"Fun f ss \\<succ> ss ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f ss \\<succ> ss ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f ss \\<succ> ss ! i", "have refl: \"ss ! i \\<succeq> ss ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss ! i \\<succeq> ss ! i", "by (rule wpo_ns_refl)"], ["proof (state)\nthis:\n  ss ! i \\<succeq> ss ! i\n\ngoal (1 subgoal):\n 1. Fun f ss \\<succ> ss ! i", "with i"], ["proof (chain)\npicking this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<succeq> ss ! i", "have \"\\<exists> t \\<in> set (\\<sigma> (f,length ss)). ss ! i \\<succeq> ss ! i\""], ["proof (prove)\nusing this:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<succeq> ss ! i\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> ss ! i", "by auto"], ["proof (state)\nthis:\n  \\<exists>t\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> ss ! i\n\ngoal (1 subgoal):\n 1. Fun f ss \\<succ> ss ! i", "with NS_arg[OF i] i"], ["proof (chain)\npicking this:\n  (Fun f ss, ss ! i) \\<in> NS\n  i \\<in> set (\\<sigma> (f, length ss))\n  \\<exists>t\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> ss ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  (Fun f ss, ss ! i) \\<in> NS\n  i \\<in> set (\\<sigma> (f, length ss))\n  \\<exists>t\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> ss ! i\n\ngoal (1 subgoal):\n 1. Fun f ss \\<succ> ss ! i", "by (auto simp: wpo.simps)"], ["proof (state)\nthis:\n  Fun f ss \\<succ> ss ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subterm_wpo_ns_arg: assumes i: \"i \\<in> set (\\<sigma> (f,length ss))\"\n  shows \"Fun f ss \\<succeq> ss ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f ss \\<succeq> ss ! i", "by (rule wpo_s_imp_ns[OF subterm_wpo_s_arg[OF i]])"], ["", "lemma wpo_ns_pre_mono: fixes f and bef aft :: \"('f,'v)term list\"\n  defines \"\\<sigma>f \\<equiv> \\<sigma> (f, Suc (length bef + length aft))\"\n  assumes rel: \"(wpo_ns s t)\"\n  shows \"(\\<forall>j\\<in>set \\<sigma>f. Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j)\n    \\<and> (Fun f (bef @ s # aft), (Fun f (bef @ t # aft))) \\<in> NS\n    \\<and> (\\<forall> i < length \\<sigma>f. ((map ((!) (bef @ s # aft)) \\<sigma>f) ! i) \\<succeq> ((map ((!) (bef @ t # aft)) \\<sigma>f) ! i))\"\n    (is \"_ \\<and> _ \\<and> ?three\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "let ?ss = \"bef @ s # aft\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "let ?ts = \"bef @ t # aft\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "let ?s = \"Fun f ?ss\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "let ?t = \"Fun f ?ts\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "let ?len = \"Suc (length bef + length aft)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "let ?f = \"(f, ?len)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "let ?\\<sigma> = \"\\<sigma> ?f\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "from wpo_ns_imp_NS[OF rel]"], ["proof (chain)\npicking this:\n  (s, t) \\<in> NS", "have stA: \"(s,t) \\<in> NS\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> NS", "."], ["proof (state)\nthis:\n  (s, t) \\<in> NS\n\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "have ?three"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length \\<sigma>f.\n       map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n       map ((!) (bef @ t # aft)) \\<sigma>f ! i", "unfolding \\<sigma>f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (\\<sigma> (f, Suc (length bef + length aft))).\n       map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       i \\<succeq>\n       map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       i", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (\\<sigma> (f, Suc (length bef + length aft))) \\<Longrightarrow>\n       map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       i \\<succeq>\n       map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (\\<sigma> (f, Suc (length bef + length aft))) \\<Longrightarrow>\n       map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       i \\<succeq>\n       map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       i", "assume \"i < length ?\\<sigma>\""], ["proof (state)\nthis:\n  i < length (\\<sigma> (f, Suc (length bef + length aft)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (\\<sigma> (f, Suc (length bef + length aft))) \\<Longrightarrow>\n       map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       i \\<succeq>\n       map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       i", "then"], ["proof (chain)\npicking this:\n  i < length (\\<sigma> (f, Suc (length bef + length aft)))", "have id: \"\\<And> ss. (map ((!) ss) ?\\<sigma>) ! i = ss ! (?\\<sigma> ! i)\""], ["proof (prove)\nusing this:\n  i < length (\\<sigma> (f, Suc (length bef + length aft)))\n\ngoal (1 subgoal):\n 1. \\<And>ss.\n       map ((!) ss) (\\<sigma> (f, Suc (length bef + length aft))) ! i =\n       ss ! (\\<sigma> (f, Suc (length bef + length aft)) ! i)", "by auto"], ["proof (state)\nthis:\n  map ((!) ?ss) (\\<sigma> (f, Suc (length bef + length aft))) ! i =\n  ?ss ! (\\<sigma> (f, Suc (length bef + length aft)) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (\\<sigma> (f, Suc (length bef + length aft))) \\<Longrightarrow>\n       map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       i \\<succeq>\n       map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       i", "show \"wpo_ns ((map ((!) ?ss) ?\\<sigma>) ! i) ((map ((!) ?ts) ?\\<sigma>) ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succeq>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i", "proof (cases \"?\\<sigma> ! i = length bef\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<sigma> (f, Suc (length bef + length aft)) ! i =\n    length bef \\<Longrightarrow>\n    map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succeq>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i\n 2. \\<sigma> (f, Suc (length bef + length aft)) ! i \\<noteq>\n    length bef \\<Longrightarrow>\n    map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succeq>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i", "case True"], ["proof (state)\nthis:\n  \\<sigma> (f, Suc (length bef + length aft)) ! i = length bef\n\ngoal (2 subgoals):\n 1. \\<sigma> (f, Suc (length bef + length aft)) ! i =\n    length bef \\<Longrightarrow>\n    map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succeq>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i\n 2. \\<sigma> (f, Suc (length bef + length aft)) ! i \\<noteq>\n    length bef \\<Longrightarrow>\n    map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succeq>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i", "then"], ["proof (chain)\npicking this:\n  \\<sigma> (f, Suc (length bef + length aft)) ! i = length bef", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> (f, Suc (length bef + length aft)) ! i = length bef\n\ngoal (1 subgoal):\n 1. map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succeq>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i", "unfolding id"], ["proof (prove)\nusing this:\n  \\<sigma> (f, Suc (length bef + length aft)) ! i = length bef\n\ngoal (1 subgoal):\n 1. (bef @ s # aft) !\n    (\\<sigma> (f, Suc (length bef + length aft)) ! i) \\<succeq>\n    (bef @ t # aft) ! (\\<sigma> (f, Suc (length bef + length aft)) ! i)", "using rel"], ["proof (prove)\nusing this:\n  \\<sigma> (f, Suc (length bef + length aft)) ! i = length bef\n  s \\<succeq> t\n\ngoal (1 subgoal):\n 1. (bef @ s # aft) !\n    (\\<sigma> (f, Suc (length bef + length aft)) ! i) \\<succeq>\n    (bef @ t # aft) ! (\\<sigma> (f, Suc (length bef + length aft)) ! i)", "by auto"], ["proof (state)\nthis:\n  map ((!) (bef @ s # aft)) (\\<sigma> (f, Suc (length bef + length aft))) !\n  i \\<succeq>\n  map ((!) (bef @ t # aft)) (\\<sigma> (f, Suc (length bef + length aft))) !\n  i\n\ngoal (1 subgoal):\n 1. \\<sigma> (f, Suc (length bef + length aft)) ! i \\<noteq>\n    length bef \\<Longrightarrow>\n    map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succeq>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> (f, Suc (length bef + length aft)) ! i \\<noteq>\n    length bef \\<Longrightarrow>\n    map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succeq>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i", "case False"], ["proof (state)\nthis:\n  \\<sigma> (f, Suc (length bef + length aft)) ! i \\<noteq> length bef\n\ngoal (1 subgoal):\n 1. \\<sigma> (f, Suc (length bef + length aft)) ! i \\<noteq>\n    length bef \\<Longrightarrow>\n    map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succeq>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i", "from append_Cons_nth_not_middle[OF this, of s aft t] wpo_ns_refl"], ["proof (chain)\npicking this:\n  (bef @ s # aft) ! (\\<sigma> (f, Suc (length bef + length aft)) ! i) =\n  (bef @ t # aft) ! (\\<sigma> (f, Suc (length bef + length aft)) ! i)\n  ?s \\<succeq> ?s", "show ?thesis"], ["proof (prove)\nusing this:\n  (bef @ s # aft) ! (\\<sigma> (f, Suc (length bef + length aft)) ! i) =\n  (bef @ t # aft) ! (\\<sigma> (f, Suc (length bef + length aft)) ! i)\n  ?s \\<succeq> ?s\n\ngoal (1 subgoal):\n 1. map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succeq>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i", "unfolding id"], ["proof (prove)\nusing this:\n  (bef @ s # aft) ! (\\<sigma> (f, Suc (length bef + length aft)) ! i) =\n  (bef @ t # aft) ! (\\<sigma> (f, Suc (length bef + length aft)) ! i)\n  ?s \\<succeq> ?s\n\ngoal (1 subgoal):\n 1. (bef @ s # aft) !\n    (\\<sigma> (f, Suc (length bef + length aft)) ! i) \\<succeq>\n    (bef @ t # aft) ! (\\<sigma> (f, Suc (length bef + length aft)) ! i)", "by auto"], ["proof (state)\nthis:\n  map ((!) (bef @ s # aft)) (\\<sigma> (f, Suc (length bef + length aft))) !\n  i \\<succeq>\n  map ((!) (bef @ t # aft)) (\\<sigma> (f, Suc (length bef + length aft))) !\n  i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map ((!) (bef @ s # aft)) (\\<sigma> (f, Suc (length bef + length aft))) !\n  i \\<succeq>\n  map ((!) (bef @ t # aft)) (\\<sigma> (f, Suc (length bef + length aft))) !\n  i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length \\<sigma>f.\n     map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n     map ((!) (bef @ t # aft)) \\<sigma>f ! i\n\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "have \"\\<forall>j\\<in>set ?\\<sigma>. wpo_s ?s ((bef @ t # aft) ! j)\" (is ?one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>set (\\<sigma> (f, Suc (length bef + length aft))).\n       Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (\\<sigma>\n                     (f, Suc (length bef + length aft))) \\<Longrightarrow>\n       Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (\\<sigma>\n                     (f, Suc (length bef + length aft))) \\<Longrightarrow>\n       Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "assume j: \"j \\<in> set ?\\<sigma>\""], ["proof (state)\nthis:\n  j \\<in> set (\\<sigma> (f, Suc (length bef + length aft)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (\\<sigma>\n                     (f, Suc (length bef + length aft))) \\<Longrightarrow>\n       Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "then"], ["proof (chain)\npicking this:\n  j \\<in> set (\\<sigma> (f, Suc (length bef + length aft)))", "have \"j \\<in> set (\\<sigma> (f,length ?ss))\""], ["proof (prove)\nusing this:\n  j \\<in> set (\\<sigma> (f, Suc (length bef + length aft)))\n\ngoal (1 subgoal):\n 1. j \\<in> set (\\<sigma> (f, length (bef @ s # aft)))", "by simp"], ["proof (state)\nthis:\n  j \\<in> set (\\<sigma> (f, length (bef @ s # aft)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (\\<sigma>\n                     (f, Suc (length bef + length aft))) \\<Longrightarrow>\n       Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "from subterm_wpo_s_arg[OF this]"], ["proof (chain)\npicking this:\n  Fun f (bef @ s # aft) \\<succ> (bef @ s # aft) ! j", "have s: \"wpo_s ?s (?ss ! j)\""], ["proof (prove)\nusing this:\n  Fun f (bef @ s # aft) \\<succ> (bef @ s # aft) ! j\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> (bef @ s # aft) ! j", "."], ["proof (state)\nthis:\n  Fun f (bef @ s # aft) \\<succ> (bef @ s # aft) ! j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (\\<sigma>\n                     (f, Suc (length bef + length aft))) \\<Longrightarrow>\n       Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "show \"wpo_s ?s (?ts ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "proof (cases \"j = length bef\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = length bef \\<Longrightarrow>\n    Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j\n 2. j \\<noteq> length bef \\<Longrightarrow>\n    Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "case False"], ["proof (state)\nthis:\n  j \\<noteq> length bef\n\ngoal (2 subgoals):\n 1. j = length bef \\<Longrightarrow>\n    Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j\n 2. j \\<noteq> length bef \\<Longrightarrow>\n    Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "then"], ["proof (chain)\npicking this:\n  j \\<noteq> length bef", "have \"?ss ! j = ?ts ! j\""], ["proof (prove)\nusing this:\n  j \\<noteq> length bef\n\ngoal (1 subgoal):\n 1. (bef @ s # aft) ! j = (bef @ t # aft) ! j", "by (rule append_Cons_nth_not_middle)"], ["proof (state)\nthis:\n  (bef @ s # aft) ! j = (bef @ t # aft) ! j\n\ngoal (2 subgoals):\n 1. j = length bef \\<Longrightarrow>\n    Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j\n 2. j \\<noteq> length bef \\<Longrightarrow>\n    Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "with s"], ["proof (chain)\npicking this:\n  Fun f (bef @ s # aft) \\<succ> (bef @ s # aft) ! j\n  (bef @ s # aft) ! j = (bef @ t # aft) ! j", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun f (bef @ s # aft) \\<succ> (bef @ s # aft) ! j\n  (bef @ s # aft) ! j = (bef @ t # aft) ! j\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "by simp"], ["proof (state)\nthis:\n  Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j\n\ngoal (1 subgoal):\n 1. j = length bef \\<Longrightarrow>\n    Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j = length bef \\<Longrightarrow>\n    Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "case True"], ["proof (state)\nthis:\n  j = length bef\n\ngoal (1 subgoal):\n 1. j = length bef \\<Longrightarrow>\n    Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "with s"], ["proof (chain)\npicking this:\n  Fun f (bef @ s # aft) \\<succ> (bef @ s # aft) ! j\n  j = length bef", "have \"wpo_s ?s s\""], ["proof (prove)\nusing this:\n  Fun f (bef @ s # aft) \\<succ> (bef @ s # aft) ! j\n  j = length bef\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> s", "by simp"], ["proof (state)\nthis:\n  Fun f (bef @ s # aft) \\<succ> s\n\ngoal (1 subgoal):\n 1. j = length bef \\<Longrightarrow>\n    Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "with rel wpo_compat"], ["proof (chain)\npicking this:\n  s \\<succeq> t\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n  Fun f (bef @ s # aft) \\<succ> s", "have \"wpo_s ?s t\""], ["proof (prove)\nusing this:\n  s \\<succeq> t\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n  Fun f (bef @ s # aft) \\<succ> s\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> t", "by blast"], ["proof (state)\nthis:\n  Fun f (bef @ s # aft) \\<succ> t\n\ngoal (1 subgoal):\n 1. j = length bef \\<Longrightarrow>\n    Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "with True"], ["proof (chain)\npicking this:\n  j = length bef\n  Fun f (bef @ s # aft) \\<succ> t", "show ?thesis"], ["proof (prove)\nusing this:\n  j = length bef\n  Fun f (bef @ s # aft) \\<succ> t\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "by simp"], ["proof (state)\nthis:\n  Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j\\<in>set (\\<sigma> (f, Suc (length bef + length aft))).\n     Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j\n\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "with \\<open>?three\\<close> ctxt_NS[OF stA]"], ["proof (chain)\npicking this:\n  \\<forall>i<length \\<sigma>f.\n     map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n     map ((!) (bef @ t # aft)) \\<sigma>f ! i\n  (Fun ?f (?bef @ s # ?aft), Fun ?f (?bef @ t # ?aft)) \\<in> NS\n  \\<forall>j\\<in>set (\\<sigma> (f, Suc (length bef + length aft))).\n     Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length \\<sigma>f.\n     map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n     map ((!) (bef @ t # aft)) \\<sigma>f ! i\n  (Fun ?f (?bef @ s # ?aft), Fun ?f (?bef @ t # ?aft)) \\<in> NS\n  \\<forall>j\\<in>set (\\<sigma> (f, Suc (length bef + length aft))).\n     Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j\n\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set \\<sigma>f.\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length \\<sigma>f.\n        map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n        map ((!) (bef @ t # aft)) \\<sigma>f ! i)", "unfolding \\<sigma>f_def"], ["proof (prove)\nusing this:\n  \\<forall>i<length (\\<sigma> (f, Suc (length bef + length aft))).\n     map ((!) (bef @ s # aft))\n      (\\<sigma> (f, Suc (length bef + length aft))) !\n     i \\<succeq>\n     map ((!) (bef @ t # aft))\n      (\\<sigma> (f, Suc (length bef + length aft))) !\n     i\n  (Fun ?f (?bef @ s # ?aft), Fun ?f (?bef @ t # ?aft)) \\<in> NS\n  \\<forall>j\\<in>set (\\<sigma> (f, Suc (length bef + length aft))).\n     Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j\n\ngoal (1 subgoal):\n 1. (\\<forall>j\\<in>set (\\<sigma> (f, Suc (length bef + length aft))).\n        Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n    (\\<forall>i<length (\\<sigma> (f, Suc (length bef + length aft))).\n        map ((!) (bef @ s # aft))\n         (\\<sigma> (f, Suc (length bef + length aft))) !\n        i \\<succeq>\n        map ((!) (bef @ t # aft))\n         (\\<sigma> (f, Suc (length bef + length aft))) !\n        i)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>j\\<in>set \\<sigma>f.\n      Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) \\<and>\n  (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS \\<and>\n  (\\<forall>i<length \\<sigma>f.\n      map ((!) (bef @ s # aft)) \\<sigma>f ! i \\<succeq>\n      map ((!) (bef @ t # aft)) \\<sigma>f ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wpo_ns_mono:\n  assumes rel: \"s \\<succeq> t\"\n  shows \"Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "let ?ss = \"bef @ s # aft\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "let ?ts = \"bef @ t # aft\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "let ?s = \"Fun f ?ss\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "let ?t = \"Fun f ?ts\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "let ?len = \"Suc (length bef + length aft)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "let ?f = \"(f, ?len)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "let ?\\<sigma> = \"\\<sigma> ?f\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "from wpo_ns_pre_mono[OF rel]"], ["proof (chain)\npicking this:\n  (\\<forall>j\\<in>set (\\<sigma> (?f, Suc (length ?bef + length ?aft))).\n      Fun ?f (?bef @ s # ?aft) \\<succ> (?bef @ t # ?aft) ! j) \\<and>\n  (Fun ?f (?bef @ s # ?aft), Fun ?f (?bef @ t # ?aft)) \\<in> NS \\<and>\n  (\\<forall>i<length (\\<sigma> (?f, Suc (length ?bef + length ?aft))).\n      map ((!) (?bef @ s # ?aft))\n       (\\<sigma> (?f, Suc (length ?bef + length ?aft))) !\n      i \\<succeq>\n      map ((!) (?bef @ t # ?aft))\n       (\\<sigma> (?f, Suc (length ?bef + length ?aft))) !\n      i)", "have id: \"(\\<forall>j\\<in>set ?\\<sigma>. wpo_s ?s ((bef @ t # aft) ! j)) = True\" \n    \"((?s,?t) \\<in> NS) = True\" \n    \"length ?ss = ?len\" \"length ?ts = ?len\""], ["proof (prove)\nusing this:\n  (\\<forall>j\\<in>set (\\<sigma> (?f, Suc (length ?bef + length ?aft))).\n      Fun ?f (?bef @ s # ?aft) \\<succ> (?bef @ t # ?aft) ! j) \\<and>\n  (Fun ?f (?bef @ s # ?aft), Fun ?f (?bef @ t # ?aft)) \\<in> NS \\<and>\n  (\\<forall>i<length (\\<sigma> (?f, Suc (length ?bef + length ?aft))).\n      map ((!) (?bef @ s # ?aft))\n       (\\<sigma> (?f, Suc (length ?bef + length ?aft))) !\n      i \\<succeq>\n      map ((!) (?bef @ t # ?aft))\n       (\\<sigma> (?f, Suc (length ?bef + length ?aft))) !\n      i)\n\ngoal (1 subgoal):\n 1. ((\\<forall>j\\<in>set (\\<sigma> (f, Suc (length bef + length aft))).\n         Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) =\n     True &&&\n     ((Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS) = True) &&&\n    length (bef @ s # aft) = Suc (length bef + length aft) &&&\n    length (bef @ t # aft) = Suc (length bef + length aft)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>j\\<in>set (\\<sigma> (f, Suc (length bef + length aft))).\n      Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) =\n  True\n  ((Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS) = True\n  length (bef @ s # aft) = Suc (length bef + length aft)\n  length (bef @ t # aft) = Suc (length bef + length aft)\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "have \"snd (lex_ext wpo n (map ((!) ?ss) ?\\<sigma>) (map ((!) ?ts) ?\\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (lex_ext wpo n\n          (map ((!) (bef @ s # aft))\n            (\\<sigma> (f, Suc (length bef + length aft))))\n          (map ((!) (bef @ t # aft))\n            (\\<sigma> (f, Suc (length bef + length aft)))))", "by (rule all_nstri_imp_lex_nstri, intro allI impI, insert wpo_ns_pre_mono[OF rel], auto)"], ["proof (state)\nthis:\n  snd (lex_ext wpo n\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "moreover"], ["proof (state)\nthis:\n  snd (lex_ext wpo n\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "have \"snd (mul_ext wpo (map ((!) ?ss) ?\\<sigma>) (map ((!) ?ts) ?\\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mul_ext wpo\n          (map ((!) (bef @ s # aft))\n            (\\<sigma> (f, Suc (length bef + length aft))))\n          (map ((!) (bef @ t # aft))\n            (\\<sigma> (f, Suc (length bef + length aft)))))", "by (rule all_nstri_imp_mul_nstri, intro allI impI, insert wpo_ns_pre_mono[OF rel], auto)"], ["proof (state)\nthis:\n  snd (mul_ext wpo\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "ultimately"], ["proof (chain)\npicking this:\n  snd (lex_ext wpo n\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n  snd (mul_ext wpo\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (lex_ext wpo n\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n  snd (mul_ext wpo\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)", "unfolding wpo.simps[of ?s ?t] term.simps id prc_refl"], ["proof (prove)\nusing this:\n  snd (lex_ext wpo n\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n  snd (mul_ext wpo\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n\ngoal (1 subgoal):\n 1. snd (if (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> S\n         then (True, True)\n         else if True\n              then if \\<exists>i\\<in>set\n(\\<sigma> (f, Suc (length bef + length aft))).\n                         (bef @ s # aft) ! i \\<succeq> Fun f (bef @ t # aft)\n                   then (True, True)\n                   else case (False, True) of\n                        (prs, prns) \\<Rightarrow>\n                          if prns \\<and> True\n                          then if prs then (True, True)\n                               else let ss' =\n    map ((!) (bef @ s # aft)) (\\<sigma> (f, Suc (length bef + length aft)));\n  ts' =\n    map ((!) (bef @ t # aft)) (\\<sigma> (f, Suc (length bef + length aft)));\n  cf = c (f, Suc (length bef + length aft));\n  cg = c (f, Suc (length bef + length aft))\n                                    in if cf = Lex \\<and> cg = Lex\n then lex_ext wpo n ss' ts'\n else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n      else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                          else (False, False)\n              else (False, False))", "using order_tag.exhaust"], ["proof (prove)\nusing this:\n  snd (lex_ext wpo n\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n  snd (mul_ext wpo\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n  \\<lbrakk>?y = Lex \\<Longrightarrow> ?P;\n   ?y = Mul \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. snd (if (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> S\n         then (True, True)\n         else if True\n              then if \\<exists>i\\<in>set\n(\\<sigma> (f, Suc (length bef + length aft))).\n                         (bef @ s # aft) ! i \\<succeq> Fun f (bef @ t # aft)\n                   then (True, True)\n                   else case (False, True) of\n                        (prs, prns) \\<Rightarrow>\n                          if prns \\<and> True\n                          then if prs then (True, True)\n                               else let ss' =\n    map ((!) (bef @ s # aft)) (\\<sigma> (f, Suc (length bef + length aft)));\n  ts' =\n    map ((!) (bef @ t # aft)) (\\<sigma> (f, Suc (length bef + length aft)));\n  cf = c (f, Suc (length bef + length aft));\n  cg = c (f, Suc (length bef + length aft))\n                                    in if cf = Lex \\<and> cg = Lex\n then lex_ext wpo n ss' ts'\n else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n      else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                          else (False, False)\n              else (False, False))", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  Fun f (bef @ s # aft) \\<succeq> Fun f (bef @ t # aft)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wpo_stable: fixes \\<delta> :: \"('f,'v)subst\"\n  shows \"(s \\<succ> t \\<longrightarrow> s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and> (s \\<succeq> t \\<longrightarrow> s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\"\n    (is \"?p s t\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof (induct \"(s,t)\" arbitrary:s t rule: wf_induct[OF wf_measure[of \"\\<lambda> (s,t). size s + size t\"]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<forall>y.\n          (y, s, t)\n          \\<in> measure (\\<lambda>(s, t). size s + size t) \\<longrightarrow>\n          (\\<forall>x xa.\n              y = (x, xa) \\<longrightarrow>\n              (x \\<succ> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succ> xa \\<cdot> \\<delta>) \\<and>\n              (x \\<succeq> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succeq>\n               xa \\<cdot> \\<delta>)) \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case (1 s t)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, s, t)\n     \\<in> measure (\\<lambda>(s, t). size s + size t) \\<longrightarrow>\n     (\\<forall>x xa.\n         y = (x, xa) \\<longrightarrow>\n         (x \\<succ> xa \\<longrightarrow>\n          x \\<cdot> \\<delta> \\<succ> xa \\<cdot> \\<delta>) \\<and>\n         (x \\<succeq> xa \\<longrightarrow>\n          x \\<cdot> \\<delta> \\<succeq> xa \\<cdot> \\<delta>))\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<forall>y.\n          (y, s, t)\n          \\<in> measure (\\<lambda>(s, t). size s + size t) \\<longrightarrow>\n          (\\<forall>x xa.\n              y = (x, xa) \\<longrightarrow>\n              (x \\<succ> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succ> xa \\<cdot> \\<delta>) \\<and>\n              (x \\<succeq> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succeq>\n               xa \\<cdot> \\<delta>)) \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from 1"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     (y, s, t)\n     \\<in> measure (\\<lambda>(s, t). size s + size t) \\<longrightarrow>\n     (\\<forall>x xa.\n         y = (x, xa) \\<longrightarrow>\n         (x \\<succ> xa \\<longrightarrow>\n          x \\<cdot> \\<delta> \\<succ> xa \\<cdot> \\<delta>) \\<and>\n         (x \\<succeq> xa \\<longrightarrow>\n          x \\<cdot> \\<delta> \\<succeq> xa \\<cdot> \\<delta>))", "have \"\\<forall> s' t'. size s' + size t' < size s + size t \\<longrightarrow> ?p s' t'\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, s, t)\n     \\<in> measure (\\<lambda>(s, t). size s + size t) \\<longrightarrow>\n     (\\<forall>x xa.\n         y = (x, xa) \\<longrightarrow>\n         (x \\<succ> xa \\<longrightarrow>\n          x \\<cdot> \\<delta> \\<succ> xa \\<cdot> \\<delta>) \\<and>\n         (x \\<succeq> xa \\<longrightarrow>\n          x \\<cdot> \\<delta> \\<succeq> xa \\<cdot> \\<delta>))\n\ngoal (1 subgoal):\n 1. \\<forall>s' t'.\n       size s' + size t' < size s + size t \\<longrightarrow>\n       (s' \\<succ> t' \\<longrightarrow>\n        s' \\<cdot> \\<delta> \\<succ> t' \\<cdot> \\<delta>) \\<and>\n       (s' \\<succeq> t' \\<longrightarrow>\n        s' \\<cdot> \\<delta> \\<succeq> t' \\<cdot> \\<delta>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>s' t'.\n     size s' + size t' < size s + size t \\<longrightarrow>\n     (s' \\<succ> t' \\<longrightarrow>\n      s' \\<cdot> \\<delta> \\<succ> t' \\<cdot> \\<delta>) \\<and>\n     (s' \\<succeq> t' \\<longrightarrow>\n      s' \\<cdot> \\<delta> \\<succeq> t' \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<forall>y.\n          (y, s, t)\n          \\<in> measure (\\<lambda>(s, t). size s + size t) \\<longrightarrow>\n          (\\<forall>x xa.\n              y = (x, xa) \\<longrightarrow>\n              (x \\<succ> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succ> xa \\<cdot> \\<delta>) \\<and>\n              (x \\<succeq> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succeq>\n               xa \\<cdot> \\<delta>)) \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note IH = this[rule_format]"], ["proof (state)\nthis:\n  size ?s' + size ?t' < size s + size t \\<Longrightarrow>\n  (?s' \\<succ> ?t' \\<longrightarrow>\n   ?s' \\<cdot> \\<delta> \\<succ> ?t' \\<cdot> \\<delta>) \\<and>\n  (?s' \\<succeq> ?t' \\<longrightarrow>\n   ?s' \\<cdot> \\<delta> \\<succeq> ?t' \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<forall>y.\n          (y, s, t)\n          \\<in> measure (\\<lambda>(s, t). size s + size t) \\<longrightarrow>\n          (\\<forall>x xa.\n              y = (x, xa) \\<longrightarrow>\n              (x \\<succ> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succ> xa \\<cdot> \\<delta>) \\<and>\n              (x \\<succeq> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succeq>\n               xa \\<cdot> \\<delta>)) \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?s = \"s \\<cdot> \\<delta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<forall>y.\n          (y, s, t)\n          \\<in> measure (\\<lambda>(s, t). size s + size t) \\<longrightarrow>\n          (\\<forall>x xa.\n              y = (x, xa) \\<longrightarrow>\n              (x \\<succ> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succ> xa \\<cdot> \\<delta>) \\<and>\n              (x \\<succeq> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succeq>\n               xa \\<cdot> \\<delta>)) \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?t = \"t \\<cdot> \\<delta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<forall>y.\n          (y, s, t)\n          \\<in> measure (\\<lambda>(s, t). size s + size t) \\<longrightarrow>\n          (\\<forall>x xa.\n              y = (x, xa) \\<longrightarrow>\n              (x \\<succ> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succ> xa \\<cdot> \\<delta>) \\<and>\n              (x \\<succeq> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succeq>\n               xa \\<cdot> \\<delta>)) \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note simps = wpo.simps[of s t] wpo.simps[of ?s ?t]"], ["proof (state)\nthis:\n  wpo s t =\n  (case s of\n   Var x \\<Rightarrow>\n     (False,\n      case t of Var xa \\<Rightarrow> x = xa\n      | Fun g ts \\<Rightarrow>\n          (s, t) \\<in> NS \\<and>\n          \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n   | Fun f ss \\<Rightarrow>\n       if (s, t) \\<in> S then (True, True)\n       else if (s, t) \\<in> NS\n            then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                       ss ! i \\<succeq> t\n                 then (True, True)\n                 else case t of\n                      Var x \\<Rightarrow>\n                        (False, ssimple \\<and> large (f, length ss))\n                      | Fun g ts \\<Rightarrow>\n                          case prc (f, length ss) (g, length ts) of\n                          (prs, prns) \\<Rightarrow>\n                            if prns \\<and>\n                               (\\<forall>j\n   \\<in>set (\\<sigma> (g, length ts)).\n                                   s \\<succ> ts ! j)\n                            then if prs then (True, True)\n                                 else let ss' =\n      map ((!) ss) (\\<sigma> (f, length ss));\n    ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n    cg = c (g, length ts)\nin if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n   else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n        else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                            else (False, False)\n            else (False, False))\n  wpo (s \\<cdot> \\<delta>) (t \\<cdot> \\<delta>) =\n  (case s \\<cdot> \\<delta> of\n   Var x \\<Rightarrow>\n     (False,\n      case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n      | Fun g ts \\<Rightarrow>\n          (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS \\<and>\n          \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n   | Fun f ss \\<Rightarrow>\n       if (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S then (True, True)\n       else if (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n            then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                       ss ! i \\<succeq> t \\<cdot> \\<delta>\n                 then (True, True)\n                 else case t \\<cdot> \\<delta> of\n                      Var x \\<Rightarrow>\n                        (False, ssimple \\<and> large (f, length ss))\n                      | Fun g ts \\<Rightarrow>\n                          case prc (f, length ss) (g, length ts) of\n                          (prs, prns) \\<Rightarrow>\n                            if prns \\<and>\n                               (\\<forall>j\n   \\<in>set (\\<sigma> (g, length ts)).\n                                   s \\<cdot> \\<delta> \\<succ> ts ! j)\n                            then if prs then (True, True)\n                                 else let ss' =\n      map ((!) ss) (\\<sigma> (f, length ss));\n    ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n    cg = c (g, length ts)\nin if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n   else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n        else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                            else (False, False)\n            else (False, False))\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<forall>y.\n          (y, s, t)\n          \\<in> measure (\\<lambda>(s, t). size s + size t) \\<longrightarrow>\n          (\\<forall>x xa.\n              y = (x, xa) \\<longrightarrow>\n              (x \\<succ> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succ> xa \\<cdot> \\<delta>) \\<and>\n              (x \\<succeq> xa \\<longrightarrow>\n               x \\<cdot> \\<delta> \\<succeq>\n               xa \\<cdot> \\<delta>)) \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "show \"?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof (cases \"((s,t) \\<in> S \\<or> (?s,?t) \\<in> S) \\<or> ((s,t) \\<notin> NS \\<or> \\<not> wpo_ns s t)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ((s, t) \\<in> S \\<or>\n     (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n    (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (((s, t) \\<in> S \\<or>\n             (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n            (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case True"], ["proof (state)\nthis:\n  ((s, t) \\<in> S \\<or>\n   (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n  (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t\n\ngoal (2 subgoals):\n 1. ((s, t) \\<in> S \\<or>\n     (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n    (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (((s, t) \\<in> S \\<or>\n             (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n            (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  ((s, t) \\<in> S \\<or>\n   (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n  (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t", "show ?thesis"], ["proof (prove)\nusing this:\n  ((s, t) \\<in> S \\<or>\n   (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n  (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (s, t) \\<in> S \\<or>\n    (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "assume \"(s,t) \\<in> S \\<or> (?s,?t) \\<in> S\""], ["proof (state)\nthis:\n  (s, t) \\<in> S \\<or> (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S\n\ngoal (2 subgoals):\n 1. (s, t) \\<in> S \\<or>\n    (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with subst_S[of s t \\<delta>]"], ["proof (chain)\npicking this:\n  (s, t) \\<in> S \\<Longrightarrow>\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S\n  (s, t) \\<in> S \\<or> (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S", "have \"(?s,?t) \\<in> S\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> S \\<Longrightarrow>\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S\n  (s, t) \\<in> S \\<or> (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S\n\ngoal (1 subgoal):\n 1. (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S", "by blast"], ["proof (state)\nthis:\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S\n\ngoal (2 subgoals):\n 1. (s, t) \\<in> S \\<or>\n    (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from S_imp_wpo_s[OF this]"], ["proof (chain)\npicking this:\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>", "have \"wpo_s ?s ?t\""], ["proof (prove)\nusing this:\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>", "."], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>\n\ngoal (2 subgoals):\n 1. (s, t) \\<in> S \\<or>\n    (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with wpo_s_imp_ns[OF this]"], ["proof (chain)\npicking this:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "by blast"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "assume \"(s,t) \\<notin> NS \\<or> \\<not> wpo_ns s t\""], ["proof (state)\nthis:\n  (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t\n\ngoal (1 subgoal):\n 1. (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with wpo_ns_imp_NS"], ["proof (chain)\npicking this:\n  ?s \\<succeq> ?t \\<Longrightarrow> (?s, ?t) \\<in> NS\n  (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t", "have st: \"\\<not> wpo_ns s t\""], ["proof (prove)\nusing this:\n  ?s \\<succeq> ?t \\<Longrightarrow> (?s, ?t) \\<in> NS\n  (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t\n\ngoal (1 subgoal):\n 1. \\<not> s \\<succeq> t", "by auto"], ["proof (state)\nthis:\n  \\<not> s \\<succeq> t\n\ngoal (1 subgoal):\n 1. (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with wpo_s_imp_ns"], ["proof (chain)\npicking this:\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n  \\<not> s \\<succeq> t", "have \"\\<not> wpo_s s t\""], ["proof (prove)\nusing this:\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n  \\<not> s \\<succeq> t\n\ngoal (1 subgoal):\n 1. \\<not> s \\<succ> t", "by auto"], ["proof (state)\nthis:\n  \\<not> s \\<succ> t\n\ngoal (1 subgoal):\n 1. (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with st"], ["proof (chain)\npicking this:\n  \\<not> s \\<succeq> t\n  \\<not> s \\<succ> t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> s \\<succeq> t\n  \\<not> s \\<succ> t\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "by blast"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> (((s, t) \\<in> S \\<or>\n             (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n            (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (((s, t) \\<in> S \\<or>\n             (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n            (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case False"], ["proof (state)\nthis:\n  \\<not> (((s, t) \\<in> S \\<or>\n           (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n          (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t)\n\ngoal (1 subgoal):\n 1. \\<not> (((s, t) \\<in> S \\<or>\n             (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n            (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  \\<not> (((s, t) \\<in> S \\<or>\n           (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n          (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t)", "have not: \"((s,t) \\<in> S) = False\" \"((?s,?t) \\<in> S) = False\" \n      and stA: \"(s,t) \\<in> NS\" and ns: \"wpo_ns s t\""], ["proof (prove)\nusing this:\n  \\<not> (((s, t) \\<in> S \\<or>\n           (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n          (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t)\n\ngoal (1 subgoal):\n 1. (((s, t) \\<in> S) = False &&&\n     ((s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) = False) &&&\n    (s, t) \\<in> NS &&& s \\<succeq> t", "by auto"], ["proof (state)\nthis:\n  ((s, t) \\<in> S) = False\n  ((s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) = False\n  (s, t) \\<in> NS\n  s \\<succeq> t\n\ngoal (1 subgoal):\n 1. \\<not> (((s, t) \\<in> S \\<or>\n             (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n            (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from subst_NS[OF stA]"], ["proof (chain)\npicking this:\n  (s \\<cdot> ?\\<sigma>, t \\<cdot> ?\\<sigma>) \\<in> NS", "have sstsA: \"(?s,?t) \\<in> NS\""], ["proof (prove)\nusing this:\n  (s \\<cdot> ?\\<sigma>, t \\<cdot> ?\\<sigma>) \\<in> NS\n\ngoal (1 subgoal):\n 1. (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS", "by auto"], ["proof (state)\nthis:\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<not> (((s, t) \\<in> S \\<or>\n             (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n            (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from stA sstsA"], ["proof (chain)\npicking this:\n  (s, t) \\<in> NS\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS", "have id: \"((s,t) \\<in> NS) = True\" \"((?s,?t) \\<in> NS) = True\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> NS\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n\ngoal (1 subgoal):\n 1. ((s, t) \\<in> NS) = True &&&\n    ((s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS) = True", "by auto"], ["proof (state)\nthis:\n  ((s, t) \\<in> NS) = True\n  ((s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS) = True\n\ngoal (1 subgoal):\n 1. \\<not> (((s, t) \\<in> S \\<or>\n             (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n            (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note simps = simps[unfolded id not if_False if_True]"], ["proof (state)\nthis:\n  wpo s t =\n  (case s of\n   Var x \\<Rightarrow>\n     (False,\n      case t of Var xa \\<Rightarrow> x = xa\n      | Fun g ts \\<Rightarrow>\n          True \\<and>\n          \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n   | Fun f ss \\<Rightarrow>\n       if \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t\n       then (True, True)\n       else case t of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         s \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n  wpo (s \\<cdot> \\<delta>) (t \\<cdot> \\<delta>) =\n  (case s \\<cdot> \\<delta> of\n   Var x \\<Rightarrow>\n     (False,\n      case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n      | Fun g ts \\<Rightarrow>\n          True \\<and>\n          \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n   | Fun f ss \\<Rightarrow>\n       if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> t \\<cdot> \\<delta>\n       then (True, True)\n       else case t \\<cdot> \\<delta> of\n            Var x \\<Rightarrow> (False, ssimple \\<and> large (f, length ss))\n            | Fun g ts \\<Rightarrow>\n                case prc (f, length ss) (g, length ts) of\n                (prs, prns) \\<Rightarrow>\n                  if prns \\<and>\n                     (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                         s \\<cdot> \\<delta> \\<succ> ts ! j)\n                  then if prs then (True, True)\n                       else let ss' =\n                                  map ((!) ss) (\\<sigma> (f, length ss));\n                                ts' =\n                                  map ((!) ts) (\\<sigma> (g, length ts));\n                                cf = c (f, length ss); cg = c (g, length ts)\n                            in if cf = Lex \\<and> cg = Lex\n                               then lex_ext wpo n ss' ts'\n                               else if cf = Mul \\<and> cg = Mul\n                                    then mul_ext wpo ss' ts'\n                                    else (length ss' \\<noteq> 0 \\<and>\n    length ts' = 0,\n    length ts' = 0)\n                  else (False, False))\n\ngoal (1 subgoal):\n 1. \\<not> (((s, t) \\<in> S \\<or>\n             (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) \\<or>\n            (s, t) \\<notin> NS \\<or> \\<not> s \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Var x1 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case (Var x)"], ["proof (state)\nthis:\n  s = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Var x1 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note s = this"], ["proof (state)\nthis:\n  s = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Var x1 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = Var x1 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case (Var y)"], ["proof (state)\nthis:\n  t = Var y\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = Var x1 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note t = this"], ["proof (state)\nthis:\n  t = Var y\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = Var x1 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "unfolding simps(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (case s of\n          Var x \\<Rightarrow>\n            (False,\n             case t of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t\n              then (True, True)\n              else case t of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (snd (case s of\n          Var x \\<Rightarrow>\n            (False,\n             case t of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t\n              then (True, True)\n              else case t of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "unfolding s t"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (case Var x of\n          Var x \\<Rightarrow>\n            (False,\n             case Var y of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Var y\n              then (True, True)\n              else case Var y of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     Var x \\<cdot> \\<delta> \\<succ> Var y \\<cdot> \\<delta>) \\<and>\n    (snd (case Var x of\n          Var x \\<Rightarrow>\n            (False,\n             case Var y of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Var y\n              then (True, True)\n              else case Var y of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     Var x \\<cdot> \\<delta> \\<succeq> Var y \\<cdot> \\<delta>)", "using wpo_ns_refl[of \"\\<delta> y\"]"], ["proof (prove)\nusing this:\n  \\<delta> y \\<succeq> \\<delta> y\n\ngoal (1 subgoal):\n 1. (fst (case Var x of\n          Var x \\<Rightarrow>\n            (False,\n             case Var y of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Var y\n              then (True, True)\n              else case Var y of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     Var x \\<cdot> \\<delta> \\<succ> Var y \\<cdot> \\<delta>) \\<and>\n    (snd (case Var x of\n          Var x \\<Rightarrow>\n            (False,\n             case Var y of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Var y\n              then (True, True)\n              else case Var y of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     Var x \\<cdot> \\<delta> \\<succeq> Var y \\<cdot> \\<delta>)", "by auto"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case (Fun g ts)"], ["proof (state)\nthis:\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note t = this"], ["proof (state)\nthis:\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?g = \"(g,length ts)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof (cases \"\\<delta> x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<delta> x = Var x1 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<And>x21 x22.\n       \\<delta> x = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case (Var y)"], ["proof (state)\nthis:\n  \\<delta> x = Var y\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<delta> x = Var x1 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<And>x21 x22.\n       \\<delta> x = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  \\<delta> x = Var y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<delta> x = Var y\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "unfolding simps"], ["proof (prove)\nusing this:\n  \\<delta> x = Var y\n\ngoal (1 subgoal):\n 1. (fst (case s of\n          Var x \\<Rightarrow>\n            (False,\n             case t of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t\n              then (True, True)\n              else case t of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     fst (case s \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t \\<cdot> \\<delta>\n              then (True, True)\n              else case t \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))) \\<and>\n    (snd (case s of\n          Var x \\<Rightarrow>\n            (False,\n             case t of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t\n              then (True, True)\n              else case t of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     snd (case s \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t \\<cdot> \\<delta>\n              then (True, True)\n              else case t \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)))", "unfolding s t"], ["proof (prove)\nusing this:\n  \\<delta> x = Var y\n\ngoal (1 subgoal):\n 1. (fst (case Var x of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts\n              then (True, True)\n              else case Fun g ts of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     fst (case Var x \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts \\<cdot> \\<delta>\n              then (True, True)\n              else case Fun g ts \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))) \\<and>\n    (snd (case Var x of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts\n              then (True, True)\n              else case Fun g ts of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     snd (case Var x \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts \\<cdot> \\<delta>\n              then (True, True)\n              else case Fun g ts \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)))", "by simp"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> x = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> x = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case (Fun f ss)"], ["proof (state)\nthis:\n  \\<delta> x = Fun f ss\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> x = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?f = \"(f, length ss)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> x = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof (cases \"prl ?g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. prl (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> prl (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case False"], ["proof (state)\nthis:\n  \\<not> prl (g, length ts)\n\ngoal (2 subgoals):\n 1. prl (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> prl (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  \\<not> prl (g, length ts)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> prl (g, length ts)\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "unfolding simps"], ["proof (prove)\nusing this:\n  \\<not> prl (g, length ts)\n\ngoal (1 subgoal):\n 1. (fst (case s of\n          Var x \\<Rightarrow>\n            (False,\n             case t of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t\n              then (True, True)\n              else case t of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     fst (case s \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t \\<cdot> \\<delta>\n              then (True, True)\n              else case t \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))) \\<and>\n    (snd (case s of\n          Var x \\<Rightarrow>\n            (False,\n             case t of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t\n              then (True, True)\n              else case t of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     snd (case s \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t \\<cdot> \\<delta>\n              then (True, True)\n              else case t \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)))", "unfolding s t Fun"], ["proof (prove)\nusing this:\n  \\<not> prl (g, length ts)\n\ngoal (1 subgoal):\n 1. (fst (case Var x of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts\n              then (True, True)\n              else case Fun g ts of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     fst (case Var x \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts \\<cdot> \\<delta>\n              then (True, True)\n              else case Fun g ts \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))) \\<and>\n    (snd (case Var x of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts\n              then (True, True)\n              else case Fun g ts of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     snd (case Var x \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts \\<cdot> \\<delta>\n              then (True, True)\n              else case Fun g ts \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)))", "by auto"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. prl (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. prl (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case True"], ["proof (state)\nthis:\n  prl (g, length ts)\n\ngoal (1 subgoal):\n 1. prl (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "obtain s ns where \"prc ?f ?g = (s,ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s ns.\n        prc (f, length ss) (g, length ts) = (s, ns) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (f, length ss) (g, length ts) = (s, ns)\n\ngoal (1 subgoal):\n 1. prl (g, length ts) \\<Longrightarrow>\n    (sa__ \\<succ> t \\<longrightarrow>\n     sa__ \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (sa__ \\<succeq> t \\<longrightarrow>\n     sa__ \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with prl[OF True, of ?f]"], ["proof (chain)\npicking this:\n  snd (prc (f, length ss) (g, length ts)) = True\n  prc (f, length ss) (g, length ts) = (s, ns)", "have prc: \"prc ?f ?g = (s, True)\""], ["proof (prove)\nusing this:\n  snd (prc (f, length ss) (g, length ts)) = True\n  prc (f, length ss) (g, length ts) = (s, ns)\n\ngoal (1 subgoal):\n 1. prc (f, length ss) (g, length ts) = (s, True)", "by auto"], ["proof (state)\nthis:\n  prc (f, length ss) (g, length ts) = (s, True)\n\ngoal (1 subgoal):\n 1. prl (g, length ts) \\<Longrightarrow>\n    (sa__ \\<succ> t \\<longrightarrow>\n     sa__ \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (sa__ \\<succeq> t \\<longrightarrow>\n     sa__ \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa__ \\<succ> t \\<longrightarrow>\n     sa__ \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (sa__ \\<succeq> t \\<longrightarrow>\n     sa__ \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "unfolding simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (case sa__ of\n          Var x \\<Rightarrow>\n            (False,\n             case t of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t\n              then (True, True)\n              else case t of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                sa__ \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     fst (case sa__ \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t \\<cdot> \\<delta>\n              then (True, True)\n              else case t \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                sa__ \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))) \\<and>\n    (snd (case sa__ of\n          Var x \\<Rightarrow>\n            (False,\n             case t of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t\n              then (True, True)\n              else case t of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                sa__ \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     snd (case sa__ \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t \\<cdot> \\<delta>\n              then (True, True)\n              else case t \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                sa__ \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)))", "unfolding s t Fun"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (case Var x of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts\n              then (True, True)\n              else case Fun g ts of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     fst (case Var x \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts \\<cdot> \\<delta>\n              then (True, True)\n              else case Fun g ts \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))) \\<and>\n    (snd (case Var x of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts\n              then (True, True)\n              else case Fun g ts of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     snd (case Var x \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> Fun g ts \\<cdot> \\<delta>\n              then (True, True)\n              else case Fun g ts \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Var x \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)))", "by (auto simp: Fun prc mul_ext_def ns_mul_ext_bottom Let_def intro!: all_nstri_imp_lex_nstri[of \"[]\", simplified])"], ["proof (state)\nthis:\n  (sa__ \\<succ> t \\<longrightarrow>\n   sa__ \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (sa__ \\<succeq> t \\<longrightarrow>\n   sa__ \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case (Fun f ss)"], ["proof (state)\nthis:\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note s = this"], ["proof (state)\nthis:\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?f = \"(f,length ss)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?ss = \"set (\\<sigma> ?f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "assume i: \"i \\<in> ?ss\" and ns: \"wpo_ns (ss ! i) t\""], ["proof (state)\nthis:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<succeq> t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from IH[of \"ss ! i\" t] \\<sigma>E[OF i] ns"], ["proof (chain)\npicking this:\n  size (ss ! i) + size t < size s + size t \\<Longrightarrow>\n  (ss ! i \\<succ> t \\<longrightarrow>\n   ss ! i \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (ss ! i \\<succeq> t \\<longrightarrow>\n   ss ! i \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n  ss ! i \\<in> set ss\n  ss ! i \\<succeq> t", "have \"wpo_ns (ss ! i \\<cdot> \\<delta>) ?t\""], ["proof (prove)\nusing this:\n  size (ss ! i) + size t < size s + size t \\<Longrightarrow>\n  (ss ! i \\<succ> t \\<longrightarrow>\n   ss ! i \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (ss ! i \\<succeq> t \\<longrightarrow>\n   ss ! i \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n  ss ! i \\<in> set ss\n  ss ! i \\<succeq> t\n\ngoal (1 subgoal):\n 1. ss ! i \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "using s"], ["proof (prove)\nusing this:\n  size (ss ! i) + size t < size s + size t \\<Longrightarrow>\n  (ss ! i \\<succ> t \\<longrightarrow>\n   ss ! i \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (ss ! i \\<succeq> t \\<longrightarrow>\n   ss ! i \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n  ss ! i \\<in> set ss\n  ss ! i \\<succeq> t\n  s = Fun f ss\n\ngoal (1 subgoal):\n 1. ss ! i \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "by (auto simp: size_simps)"], ["proof (state)\nthis:\n  ss ! i \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  ss ! i \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "have \"wpo_s ?s ?t\""], ["proof (prove)\nusing this:\n  ss ! i \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>", "using i sstsA \\<sigma>[of f \"length ss\"]"], ["proof (prove)\nusing this:\n  ss ! i \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  i \\<in> set (\\<sigma> (f, length ss))\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  set (\\<sigma> (f, length ss)) \\<subseteq> {0..<length ss}\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>", "unfolding simps"], ["proof (prove)\nusing this:\n  ss ! i \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  i \\<in> set (\\<sigma> (f, length ss))\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  set (\\<sigma> (f, length ss)) \\<subseteq> {0..<length ss}\n\ngoal (1 subgoal):\n 1. fst (case s \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                   ss ! i \\<succeq> t \\<cdot> \\<delta>\n             then (True, True)\n             else case t \\<cdot> \\<delta> of\n                  Var x \\<Rightarrow>\n                    (False, ssimple \\<and> large (f, length ss))\n                  | Fun g ts \\<Rightarrow>\n                      case prc (f, length ss) (g, length ts) of\n                      (prs, prns) \\<Rightarrow>\n                        if prns \\<and>\n                           (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                               s \\<cdot> \\<delta> \\<succ> ts ! j)\n                        then if prs then (True, True)\n                             else let ss' =\n  map ((!) ss) (\\<sigma> (f, length ss));\nts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\ncg = c (g, length ts)\n                                  in if cf = Lex \\<and> cg = Lex\n                                     then lex_ext wpo n ss' ts'\n                                     else if cf = Mul \\<and> cg = Mul\n    then mul_ext wpo ss' ts'\n    else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                        else (False, False))", "unfolding s"], ["proof (prove)\nusing this:\n  ss ! i \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  i \\<in> set (\\<sigma> (f, length ss))\n  (Fun f ss \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  set (\\<sigma> (f, length ss)) \\<subseteq> {0..<length ss}\n\ngoal (1 subgoal):\n 1. fst (case Fun f ss \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun fa ssa \\<Rightarrow>\n             if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                   ssa ! i \\<succeq> t \\<cdot> \\<delta>\n             then (True, True)\n             else case t \\<cdot> \\<delta> of\n                  Var x \\<Rightarrow>\n                    (False, ssimple \\<and> large (fa, length ssa))\n                  | Fun g ts \\<Rightarrow>\n                      case prc (fa, length ssa) (g, length ts) of\n                      (prs, prns) \\<Rightarrow>\n                        if prns \\<and>\n                           (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                               Fun f ss \\<cdot> \\<delta> \\<succ> ts ! j)\n                        then if prs then (True, True)\n                             else let ss' =\n  map ((!) ssa) (\\<sigma> (fa, length ssa));\nts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (fa, length ssa);\ncg = c (g, length ts)\n                                  in if cf = Lex \\<and> cg = Lex\n                                     then lex_ext wpo n ss' ts'\n                                     else if cf = Mul \\<and> cg = Mul\n    then mul_ext wpo ss' ts'\n    else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                        else (False, False))", "by force"], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with wpo_s_imp_ns[OF this]"], ["proof (chain)\npicking this:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>", "have ?thesis"], ["proof (prove)\nusing this:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "by blast"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 \\<in> set (\\<sigma> (f, length ss));\n   ss ! ?i2 \\<succeq> t\\<rbrakk>\n  \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                    (s \\<succeq> t \\<longrightarrow>\n                     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note si_arg = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 \\<in> set (\\<sigma> (f, length ss));\n   ss ! ?i2 \\<succeq> t\\<rbrakk>\n  \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                    (s \\<succeq> t \\<longrightarrow>\n                     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       s = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = Var x1 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case t: (Var y)"], ["proof (state)\nthis:\n  t = Var y\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = Var x1 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof (cases \"\\<exists>i\\<in>?ss. wpo_ns (ss ! i) t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case True"], ["proof (state)\nthis:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t", "obtain i\n            where si: \"i \\<in> ?ss\" and ns: \"wpo_ns (ss ! i) t\""], ["proof (prove)\nusing this:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> set (\\<sigma> (f, length ss));\n         ss ! i \\<succeq> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding s t"], ["proof (prove)\nusing this:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> Var y\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> set (\\<sigma> (f, length ss));\n         ss ! i \\<succeq> Var y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<in> set (\\<sigma> (f, length ss))\n  ss ! i \\<succeq> t\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from si_arg[OF this]"], ["proof (chain)\npicking this:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "show ?thesis"], ["proof (prove)\nusing this:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "."], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with ns[unfolded simps] s t"], ["proof (chain)\npicking this:\n  snd (case s of\n       Var x \\<Rightarrow>\n         (False,\n          case t of Var xa \\<Rightarrow> x = xa\n          | Fun g ts \\<Rightarrow>\n              True \\<and>\n              \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n       | Fun f ss \\<Rightarrow>\n           if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                 ss ! i \\<succeq> t\n           then (True, True)\n           else case t of\n                Var x \\<Rightarrow>\n                  (False, ssimple \\<and> large (f, length ss))\n                | Fun g ts \\<Rightarrow>\n                    case prc (f, length ss) (g, length ts) of\n                    (prs, prns) \\<Rightarrow>\n                      if prns \\<and>\n                         (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                             s \\<succ> ts ! j)\n                      then if prs then (True, True)\n                           else let ss' =\nmap ((!) ss) (\\<sigma> (f, length ss));\n                                    ts' =\nmap ((!) ts) (\\<sigma> (g, length ts));\n                                    cf = c (f, length ss);\n                                    cg = c (g, length ts)\n                                in if cf = Lex \\<and> cg = Lex\n                                   then lex_ext wpo n ss' ts'\n                                   else if cf = Mul \\<and> cg = Mul\n  then mul_ext wpo ss' ts'\n  else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                      else (False, False))\n  s = Fun f ss\n  t = Var y\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)", "have ssimple and largef: \"large ?f\""], ["proof (prove)\nusing this:\n  snd (case s of\n       Var x \\<Rightarrow>\n         (False,\n          case t of Var xa \\<Rightarrow> x = xa\n          | Fun g ts \\<Rightarrow>\n              True \\<and>\n              \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n       | Fun f ss \\<Rightarrow>\n           if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                 ss ! i \\<succeq> t\n           then (True, True)\n           else case t of\n                Var x \\<Rightarrow>\n                  (False, ssimple \\<and> large (f, length ss))\n                | Fun g ts \\<Rightarrow>\n                    case prc (f, length ss) (g, length ts) of\n                    (prs, prns) \\<Rightarrow>\n                      if prns \\<and>\n                         (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                             s \\<succ> ts ! j)\n                      then if prs then (True, True)\n                           else let ss' =\nmap ((!) ss) (\\<sigma> (f, length ss));\n                                    ts' =\nmap ((!) ts) (\\<sigma> (g, length ts));\n                                    cf = c (f, length ss);\n                                    cg = c (g, length ts)\n                                in if cf = Lex \\<and> cg = Lex\n                                   then lex_ext wpo n ss' ts'\n                                   else if cf = Mul \\<and> cg = Mul\n  then mul_ext wpo ss' ts'\n  else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                      else (False, False))\n  s = Fun f ss\n  t = Var y\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n\ngoal (1 subgoal):\n 1. ssimple &&& large (f, length ss)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  ssimple\n  large (f, length ss)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from False s t not"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  s = Fun f ss\n  t = Var y\n  ((s, t) \\<in> S) = False\n  ((s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) = False", "have \"\\<not> wpo_s s t\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  s = Fun f ss\n  t = Var y\n  ((s, t) \\<in> S) = False\n  ((s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) = False\n\ngoal (1 subgoal):\n 1. \\<not> s \\<succ> t", "unfolding wpo.simps[of s t]"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n  s = Fun f ss\n  t = Var y\n  ((s, t) \\<in> S) = False\n  ((s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> S) = False\n\ngoal (1 subgoal):\n 1. \\<not> fst (case s of\n                Var x \\<Rightarrow>\n                  (False,\n                   case t of Var xa \\<Rightarrow> x = xa\n                   | Fun g ts \\<Rightarrow>\n                       (s, t) \\<in> NS \\<and>\n                       \\<sigma> (g, length ts) = [] \\<and>\n                       prl (g, length ts))\n                | Fun f ss \\<Rightarrow>\n                    if (s, t) \\<in> S then (True, True)\n                    else if (s, t) \\<in> NS\n                         then if \\<exists>i\n    \\<in>set (\\<sigma> (f, length ss)).\n                                    ss ! i \\<succeq> t\n                              then (True, True)\n                              else case t of\n                                   Var x \\<Rightarrow>\n                                     (False,\nssimple \\<and> large (f, length ss))\n                                   | Fun g ts \\<Rightarrow>\n case prc (f, length ss) (g, length ts) of\n (prs, prns) \\<Rightarrow>\n   if prns \\<and>\n      (\\<forall>j\\<in>set (\\<sigma> (g, length ts)). s \\<succ> ts ! j)\n   then if prs then (True, True)\n        else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                 ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                 cf = c (f, length ss); cg = c (g, length ts)\n             in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n                     else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                           length ts' = 0)\n   else (False, False)\n                         else (False, False))", "by auto"], ["proof (state)\nthis:\n  \\<not> s \\<succ> t\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "moreover"], ["proof (state)\nthis:\n  \\<not> s \\<succ> t\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "have \"wpo_ns ?s ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "proof (cases \"\\<delta> y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<delta> y = Var x1 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n 2. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "case (Var z)"], ["proof (state)\nthis:\n  \\<delta> y = Var z\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<delta> y = Var x1 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n 2. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "unfolding wpo.simps[of ?s ?t] not id"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (case s \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if False then (True, True)\n             else if True\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> t \\<cdot> \\<delta>\n                       then (True, True)\n                       else case t \\<cdot> \\<delta> of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<cdot> \\<delta> \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "unfolding s t"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (case Fun f ss \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case Var y \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun fa ssa \\<Rightarrow>\n             if False then (True, True)\n             else if True\n                  then if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                             ssa ! i \\<succeq> Var y \\<cdot> \\<delta>\n                       then (True, True)\n                       else case Var y \\<cdot> \\<delta> of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (fa, length ssa))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (fa, length ssa) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   Fun f ss \\<cdot> \\<delta> \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ssa) (\\<sigma> (fa, length ssa));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (fa, length ssa); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "using Var `ssimple` largef"], ["proof (prove)\nusing this:\n  \\<delta> y = Var z\n  ssimple\n  large (f, length ss)\n\ngoal (1 subgoal):\n 1. snd (case Fun f ss \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case Var y \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun fa ssa \\<Rightarrow>\n             if False then (True, True)\n             else if True\n                  then if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                             ssa ! i \\<succeq> Var y \\<cdot> \\<delta>\n                       then (True, True)\n                       else case Var y \\<cdot> \\<delta> of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (fa, length ssa))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (fa, length ssa) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   Fun f ss \\<cdot> \\<delta> \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ssa) (\\<sigma> (fa, length ssa));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (fa, length ssa); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by auto"], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "case (Fun g ts)"], ["proof (state)\nthis:\n  \\<delta> y = Fun g ts\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "let ?g = \"(g,length ts)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "obtain ps pns where prc: \"prc ?f ?g = (ps,pns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps pns.\n        prc (f, length ss) (g, length ts) = (ps, pns) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"prc ?f ?g\", auto)"], ["proof (state)\nthis:\n  prc (f, length ss) (g, length ts) = (ps, pns)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "from prc_stri_imp_nstri[of ?f ?g] prc"], ["proof (chain)\npicking this:\n  fst (prc (f, length ss) (g, length ts)) \\<Longrightarrow>\n  snd (prc (f, length ss) (g, length ts))\n  prc (f, length ss) (g, length ts) = (ps, pns)", "have ps: \"ps \\<Longrightarrow> pns\""], ["proof (prove)\nusing this:\n  fst (prc (f, length ss) (g, length ts)) \\<Longrightarrow>\n  snd (prc (f, length ss) (g, length ts))\n  prc (f, length ss) (g, length ts) = (ps, pns)\n\ngoal (1 subgoal):\n 1. ps \\<Longrightarrow> pns", "by auto"], ["proof (state)\nthis:\n  ps \\<Longrightarrow> pns\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "{"], ["proof (state)\nthis:\n  ps \\<Longrightarrow> pns\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "assume \"j \\<in> set (\\<sigma> ?g)\""], ["proof (state)\nthis:\n  j \\<in> set (\\<sigma> (g, length ts))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "with set_status_nth[OF refl this] ss_status[OF `ssimple` this] t Fun"], ["proof (chain)\npicking this:\n  j < length ts \\<and> ts ! j \\<in> set ts\n  simple_arg_pos S (g, length ts) j\n  t = Var y\n  \\<delta> y = Fun g ts\n  j \\<in> set (\\<sigma> (g, length ts))", "have \"(t \\<cdot> \\<delta>, ts ! j) \\<in> S\""], ["proof (prove)\nusing this:\n  j < length ts \\<and> ts ! j \\<in> set ts\n  simple_arg_pos S (g, length ts) j\n  t = Var y\n  \\<delta> y = Fun g ts\n  j \\<in> set (\\<sigma> (g, length ts))\n\ngoal (1 subgoal):\n 1. (t \\<cdot> \\<delta>, ts ! j) \\<in> S", "by (auto simp: simple_arg_pos_def)"], ["proof (state)\nthis:\n  (t \\<cdot> \\<delta>, ts ! j) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "with sstsA"], ["proof (chain)\npicking this:\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  (t \\<cdot> \\<delta>, ts ! j) \\<in> S", "have S: \"(s \\<cdot> \\<delta>, ts ! j) \\<in> S\""], ["proof (prove)\nusing this:\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  (t \\<cdot> \\<delta>, ts ! j) \\<in> S\n\ngoal (1 subgoal):\n 1. (s \\<cdot> \\<delta>, ts ! j) \\<in> S", "by (metis compat_NS_S_point)"], ["proof (state)\nthis:\n  (s \\<cdot> \\<delta>, ts ! j) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "hence \"wpo_s (s \\<cdot> \\<delta>) (ts ! j)\""], ["proof (prove)\nusing this:\n  (s \\<cdot> \\<delta>, ts ! j) \\<in> S\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succ> ts ! j", "by (rule S_imp_wpo_s)"], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succ> ts ! j\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "}"], ["proof (state)\nthis:\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> ts ! ?j2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "note ssimple = this"], ["proof (state)\nthis:\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> ts ! ?j2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "from large[OF `ssimple` largef, of ?g, unfolded prc]"], ["proof (chain)\npicking this:\n  fst (ps, pns) \\<or> snd (ps, pns) \\<and> \\<sigma> (g, length ts) = []", "have \"ps \\<or> pns \\<and>  \\<sigma> ?g = []\""], ["proof (prove)\nusing this:\n  fst (ps, pns) \\<or> snd (ps, pns) \\<and> \\<sigma> (g, length ts) = []\n\ngoal (1 subgoal):\n 1. ps \\<or> pns \\<and> \\<sigma> (g, length ts) = []", "by auto"], ["proof (state)\nthis:\n  ps \\<or> pns \\<and> \\<sigma> (g, length ts) = []\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<delta> y = Fun x21 x22 \\<Longrightarrow>\n       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps \\<or> pns \\<and> \\<sigma> (g, length ts) = []\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "using ssimple"], ["proof (prove)\nusing this:\n  ps \\<or> pns \\<and> \\<sigma> (g, length ts) = []\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> ts ! ?j2\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "unfolding wpo.simps[of ?s ?t] not id"], ["proof (prove)\nusing this:\n  ps \\<or> pns \\<and> \\<sigma> (g, length ts) = []\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> ts ! ?j2\n\ngoal (1 subgoal):\n 1. snd (case s \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if False then (True, True)\n             else if True\n                  then if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                             ss ! i \\<succeq> t \\<cdot> \\<delta>\n                       then (True, True)\n                       else case t \\<cdot> \\<delta> of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (f, length ss))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (f, length ss) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   s \\<cdot> \\<delta> \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (f, length ss); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "unfolding s t"], ["proof (prove)\nusing this:\n  ps \\<or> pns \\<and> \\<sigma> (g, length ts) = []\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  Fun f ss \\<cdot> \\<delta> \\<succ> ts ! ?j2\n\ngoal (1 subgoal):\n 1. snd (case Fun f ss \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case Var y \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun fa ssa \\<Rightarrow>\n             if False then (True, True)\n             else if True\n                  then if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                             ssa ! i \\<succeq> Var y \\<cdot> \\<delta>\n                       then (True, True)\n                       else case Var y \\<cdot> \\<delta> of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (fa, length ssa))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (fa, length ssa) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   Fun f ss \\<cdot> \\<delta> \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ssa) (\\<sigma> (fa, length ssa));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (fa, length ssa); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "using Fun prc ps"], ["proof (prove)\nusing this:\n  ps \\<or> pns \\<and> \\<sigma> (g, length ts) = []\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  Fun f ss \\<cdot> \\<delta> \\<succ> ts ! ?j2\n  \\<delta> y = Fun g ts\n  prc (f, length ss) (g, length ts) = (ps, pns)\n  ps \\<Longrightarrow> pns\n\ngoal (1 subgoal):\n 1. snd (case Fun f ss \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case Var y \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun fa ssa \\<Rightarrow>\n             if False then (True, True)\n             else if True\n                  then if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                             ssa ! i \\<succeq> Var y \\<cdot> \\<delta>\n                       then (True, True)\n                       else case Var y \\<cdot> \\<delta> of\n                            Var x \\<Rightarrow>\n                              (False, ssimple \\<and> large (fa, length ssa))\n                            | Fun g ts \\<Rightarrow>\n                                case prc (fa, length ssa) (g, length ts) of\n                                (prs, prns) \\<Rightarrow>\n                                  if prns \\<and>\n                                     (\\<forall>j\n         \\<in>set (\\<sigma> (g, length ts)).\n   Fun f ss \\<cdot> \\<delta> \\<succ> ts ! j)\n                                  then if prs then (True, True)\n else let ss' = map ((!) ssa) (\\<sigma> (fa, length ssa));\n          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n          cf = c (fa, length ssa); cg = c (g, length ts)\n      in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n         else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n              else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                    length ts' = 0)\n                                  else (False, False)\n                  else (False, False))", "by (auto simp: lex_ext_least_1 mul_ext_def Let_def ns_mul_ext_bottom)"], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> s \\<succ> t\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> s \\<succ> t\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "by blast"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case (Fun g ts)"], ["proof (state)\nthis:\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note t = this"], ["proof (state)\nthis:\n  t = Fun g ts\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?g = \"(g,length ts)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?ts = \"set (\\<sigma> ?g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "obtain prs prns where p: \"prc ?f ?g = (prs, prns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>prs prns.\n        prc (f, length ss) (g, length ts) = (prs, prns) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (f, length ss) (g, length ts) = (prs, prns)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note ns = ns[unfolded simps, unfolded s t p term.simps split]"], ["proof (state)\nthis:\n  snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts\n       then (True, True)\n       else if prns \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                   Fun f ss \\<succ> ts ! j)\n            then if prs then (True, True)\n                 else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                          cf = c (f, length ss); cg = c (g, length ts)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Fun x21 x22 \\<Longrightarrow>\n       (s \\<succ> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n       (s \\<succeq> t \\<longrightarrow>\n        s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof (cases \"\\<exists> i \\<in> ?ss. wpo_ns (ss ! i) t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case True"], ["proof (state)\nthis:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n       ss ! i \\<succeq> t \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with si_arg"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 \\<in> set (\\<sigma> (f, length ss));\n   ss ! ?i2 \\<succeq> t\\<rbrakk>\n  \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                    (s \\<succeq> t \\<longrightarrow>\n                     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 \\<in> set (\\<sigma> (f, length ss));\n   ss ! ?i2 \\<succeq> t\\<rbrakk>\n  \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                    (s \\<succeq> t \\<longrightarrow>\n                     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n  \\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "by blast"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)", "have id: \"(\\<exists> i \\<in> ?ss. wpo_ns (ss ! i) (Fun g ts)) = False\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)). ss ! i \\<succeq> t)\n\ngoal (1 subgoal):\n 1. (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n        ss ! i \\<succeq> Fun g ts) =\n    False", "unfolding t"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n             ss ! i \\<succeq> Fun g ts)\n\ngoal (1 subgoal):\n 1. (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n        ss ! i \\<succeq> Fun g ts) =\n    False", "by auto"], ["proof (state)\nthis:\n  (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n      ss ! i \\<succeq> Fun g ts) =\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note ns = ns[unfolded this if_False]"], ["proof (state)\nthis:\n  snd (if prns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if prs then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?mss = \"map (\\<lambda> s . s \\<cdot> \\<delta>) ss\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?mts = \"map (\\<lambda> t . t \\<cdot> \\<delta>) ts\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from ns"], ["proof (chain)\npicking this:\n  snd (if prns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if prs then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))", "have prns and s_tj: \"\\<And> j. j \\<in> ?ts \\<Longrightarrow> wpo_s (Fun f ss) (ts ! j)\""], ["proof (prove)\nusing this:\n  snd (if prns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if prs then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. prns &&&\n    (\\<And>j.\n        j \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n        Fun f ss \\<succ> ts ! j)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  prns\n  ?j \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  Fun f ss \\<succ> ts ! ?j\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "{"], ["proof (state)\nthis:\n  prns\n  ?j \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  Fun f ss \\<succ> ts ! ?j\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "assume j: \"j \\<in> ?ts\""], ["proof (state)\nthis:\n  j \\<in> set (\\<sigma> (g, length ts))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from \\<sigma>E[OF this]"], ["proof (chain)\npicking this:\n  ts ! j \\<in> set ts", "have \"size s + size (ts ! j) < size s + size t\""], ["proof (prove)\nusing this:\n  ts ! j \\<in> set ts\n\ngoal (1 subgoal):\n 1. size s + size (ts ! j) < size s + size t", "unfolding t"], ["proof (prove)\nusing this:\n  ts ! j \\<in> set ts\n\ngoal (1 subgoal):\n 1. size s + size (ts ! j) < size s + size (Fun g ts)", "by (auto simp: size_simps)"], ["proof (state)\nthis:\n  size s + size (ts ! j) < size s + size t\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from IH[OF this] s_tj[OF j, folded s]"], ["proof (chain)\npicking this:\n  (s \\<succ> ts ! j \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> ts ! j \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> ts ! j \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> ts ! j \\<cdot> \\<delta>)\n  s \\<succ> ts ! j", "have wpo: \"wpo_s ?s (ts ! j \\<cdot> \\<delta>)\""], ["proof (prove)\nusing this:\n  (s \\<succ> ts ! j \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> ts ! j \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> ts ! j \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> ts ! j \\<cdot> \\<delta>)\n  s \\<succ> ts ! j\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succ> ts ! j \\<cdot> \\<delta>", "by auto"], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succ> ts ! j \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from j \\<sigma>[of g \"length ts\"]"], ["proof (chain)\npicking this:\n  j \\<in> set (\\<sigma> (g, length ts))\n  set (\\<sigma> (g, length ts)) \\<subseteq> {0..<length ts}", "have \"j < length ts\""], ["proof (prove)\nusing this:\n  j \\<in> set (\\<sigma> (g, length ts))\n  set (\\<sigma> (g, length ts)) \\<subseteq> {0..<length ts}\n\ngoal (1 subgoal):\n 1. j < length ts", "by auto"], ["proof (state)\nthis:\n  j < length ts\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with wpo"], ["proof (chain)\npicking this:\n  s \\<cdot> \\<delta> \\<succ> ts ! j \\<cdot> \\<delta>\n  j < length ts", "have \"wpo_s ?s (?mts ! j)\""], ["proof (prove)\nusing this:\n  s \\<cdot> \\<delta> \\<succ> ts ! j \\<cdot> \\<delta>\n  j < length ts\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! j", "by auto"], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! j\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "}"], ["proof (state)\nthis:\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note ss_ts = this"], ["proof (state)\nthis:\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note \\<sigma>E = \\<sigma>E[of _ f ss] \\<sigma>E[of _ g ts]"], ["proof (state)\nthis:\n  ?i \\<in> set (\\<sigma> (f, length ss)) \\<Longrightarrow>\n  ss ! ?i \\<in> set ss\n  ?i \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  ts ! ?i \\<in> set ts\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n               ss ! i \\<succeq> t) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof (cases prs)"], ["proof (state)\ngoal (2 subgoals):\n 1. prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case True"], ["proof (state)\nthis:\n  prs\n\ngoal (2 subgoals):\n 1. prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with ss_ts sstsA p \\<open>prns\\<close>"], ["proof (chain)\npicking this:\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  prs", "have \"wpo_s ?s ?t\""], ["proof (prove)\nusing this:\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  prs\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>", "unfolding simps"], ["proof (prove)\nusing this:\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  prs\n\ngoal (1 subgoal):\n 1. fst (case s \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                   ss ! i \\<succeq> t \\<cdot> \\<delta>\n             then (True, True)\n             else case t \\<cdot> \\<delta> of\n                  Var x \\<Rightarrow>\n                    (False, ssimple \\<and> large (f, length ss))\n                  | Fun g ts \\<Rightarrow>\n                      case prc (f, length ss) (g, length ts) of\n                      (prs, prns) \\<Rightarrow>\n                        if prns \\<and>\n                           (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                               s \\<cdot> \\<delta> \\<succ> ts ! j)\n                        then if prs then (True, True)\n                             else let ss' =\n  map ((!) ss) (\\<sigma> (f, length ss));\nts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\ncg = c (g, length ts)\n                                  in if cf = Lex \\<and> cg = Lex\n                                     then lex_ext wpo n ss' ts'\n                                     else if cf = Mul \\<and> cg = Mul\n    then mul_ext wpo ss' ts'\n    else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                        else (False, False))", "unfolding s t"], ["proof (prove)\nusing this:\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  Fun f ss \\<cdot> \\<delta> \\<succ>\n  map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (Fun f ss \\<cdot> \\<delta>, Fun g ts \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  prs\n\ngoal (1 subgoal):\n 1. fst (case Fun f ss \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case Fun g ts \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun fa ssa \\<Rightarrow>\n             if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                   ssa ! i \\<succeq> Fun g ts \\<cdot> \\<delta>\n             then (True, True)\n             else case Fun g ts \\<cdot> \\<delta> of\n                  Var x \\<Rightarrow>\n                    (False, ssimple \\<and> large (fa, length ssa))\n                  | Fun g ts \\<Rightarrow>\n                      case prc (fa, length ssa) (g, length ts) of\n                      (prs, prns) \\<Rightarrow>\n                        if prns \\<and>\n                           (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                               Fun f ss \\<cdot> \\<delta> \\<succ> ts ! j)\n                        then if prs then (True, True)\n                             else let ss' =\n  map ((!) ssa) (\\<sigma> (fa, length ssa));\nts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (fa, length ssa);\ncg = c (g, length ts)\n                                  in if cf = Lex \\<and> cg = Lex\n                                     then lex_ext wpo n ss' ts'\n                                     else if cf = Mul \\<and> cg = Mul\n    then mul_ext wpo ss' ts'\n    else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                        else (False, False))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>\n\ngoal (2 subgoals):\n 1. prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with wpo_s_imp_ns[OF this]"], ["proof (chain)\npicking this:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "by blast"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case False"], ["proof (state)\nthis:\n  \\<not> prs\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?mmss = \"map ((!) ss) (\\<sigma> ?f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?mmts = \"map ((!) ts) (\\<sigma> ?g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?Mmss = \"map ((!) ?mss) (\\<sigma> ?f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?Mmts = \"map ((!) ?mts) (\\<sigma> ?g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "have id_map: \"?Mmss = map (\\<lambda> t. t \\<cdot> \\<delta>) ?mmss\" \"?Mmts = map (\\<lambda> t. t \\<cdot> \\<delta>) ?mmts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n     (\\<sigma> (f, length ss)) =\n    map (\\<lambda>t. t \\<cdot> \\<delta>)\n     (map ((!) ss) (\\<sigma> (f, length ss))) &&&\n    map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n     (\\<sigma> (g, length ts)) =\n    map (\\<lambda>t. t \\<cdot> \\<delta>)\n     (map ((!) ts) (\\<sigma> (g, length ts)))", "unfolding map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n     (\\<sigma> (f, length ss)) =\n    map (\\<lambda>x. ss ! x \\<cdot> \\<delta>) (\\<sigma> (f, length ss)) &&&\n    map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n     (\\<sigma> (g, length ts)) =\n    map (\\<lambda>x. ts ! x \\<cdot> \\<delta>) (\\<sigma> (g, length ts))", "by (auto simp: set_status_nth)"], ["proof (state)\nthis:\n  map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n   (\\<sigma> (f, length ss)) =\n  map (\\<lambda>t. t \\<cdot> \\<delta>)\n   (map ((!) ss) (\\<sigma> (f, length ss)))\n  map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n   (\\<sigma> (g, length ts)) =\n  map (\\<lambda>t. t \\<cdot> \\<delta>)\n   (map ((!) ts) (\\<sigma> (g, length ts)))\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?ls = \"length (\\<sigma> ?f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "let ?lt = \"length (\\<sigma> ?g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "fix si tj"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "assume *: \"si \\<in> set ?mmss\" \"tj \\<in> set ?mmts\""], ["proof (state)\nthis:\n  si \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)))\n  tj \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)))\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "have \"(wpo_s si tj \\<longrightarrow> wpo_s (si \\<cdot> \\<delta>) (tj \\<cdot> \\<delta>)) \\<and> (wpo_ns si tj \\<longrightarrow> wpo_ns (si \\<cdot> \\<delta>) (tj \\<cdot> \\<delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (si \\<succ> tj \\<longrightarrow>\n     si \\<cdot> \\<delta> \\<succ> tj \\<cdot> \\<delta>) \\<and>\n    (si \\<succeq> tj \\<longrightarrow>\n     si \\<cdot> \\<delta> \\<succeq> tj \\<cdot> \\<delta>)", "proof (intro IH add_strict_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. size si < size s\n 2. size tj < size t", "from *(1)"], ["proof (chain)\npicking this:\n  si \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)))", "have \"si \\<in> set ss\""], ["proof (prove)\nusing this:\n  si \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)))\n\ngoal (1 subgoal):\n 1. si \\<in> set ss", "using set_status_nth[of _ _ _ \\<sigma>\\<sigma>]"], ["proof (prove)\nusing this:\n  si \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)))\n  \\<lbrakk>length ?xs = ?n; ?i \\<in> set (\\<sigma> (?f, ?n))\\<rbrakk>\n  \\<Longrightarrow> ?i < length ?xs \\<and> ?xs ! ?i \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. si \\<in> set ss", "by auto"], ["proof (state)\nthis:\n  si \\<in> set ss\n\ngoal (2 subgoals):\n 1. size si < size s\n 2. size tj < size t", "then"], ["proof (chain)\npicking this:\n  si \\<in> set ss", "show \"size si < size s\""], ["proof (prove)\nusing this:\n  si \\<in> set ss\n\ngoal (1 subgoal):\n 1. size si < size s", "unfolding s"], ["proof (prove)\nusing this:\n  si \\<in> set ss\n\ngoal (1 subgoal):\n 1. size si < size (Fun f ss)", "by (auto simp: termination_simp)"], ["proof (state)\nthis:\n  size si < size s\n\ngoal (1 subgoal):\n 1. size tj < size t", "from *(2)"], ["proof (chain)\npicking this:\n  tj \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)))", "have \"tj \\<in> set ts\""], ["proof (prove)\nusing this:\n  tj \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)))\n\ngoal (1 subgoal):\n 1. tj \\<in> set ts", "using set_status_nth[of _ _ _ \\<sigma>\\<sigma>]"], ["proof (prove)\nusing this:\n  tj \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)))\n  \\<lbrakk>length ?xs = ?n; ?i \\<in> set (\\<sigma> (?f, ?n))\\<rbrakk>\n  \\<Longrightarrow> ?i < length ?xs \\<and> ?xs ! ?i \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. tj \\<in> set ts", "by auto"], ["proof (state)\nthis:\n  tj \\<in> set ts\n\ngoal (1 subgoal):\n 1. size tj < size t", "then"], ["proof (chain)\npicking this:\n  tj \\<in> set ts", "show \"size tj < size t\""], ["proof (prove)\nusing this:\n  tj \\<in> set ts\n\ngoal (1 subgoal):\n 1. size tj < size t", "unfolding t"], ["proof (prove)\nusing this:\n  tj \\<in> set ts\n\ngoal (1 subgoal):\n 1. size tj < size (Fun g ts)", "by (auto simp: termination_simp)"], ["proof (state)\nthis:\n  size tj < size t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (si \\<succ> tj \\<longrightarrow>\n   si \\<cdot> \\<delta> \\<succ> tj \\<cdot> \\<delta>) \\<and>\n  (si \\<succeq> tj \\<longrightarrow>\n   si \\<cdot> \\<delta> \\<succeq> tj \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "hence \"wpo_s si tj \\<Longrightarrow> wpo_s (si \\<cdot> \\<delta>) (tj \\<cdot> \\<delta>)\"\n                \"wpo_ns si tj \\<Longrightarrow> wpo_ns (si \\<cdot> \\<delta>) (tj \\<cdot> \\<delta>)\""], ["proof (prove)\nusing this:\n  (si \\<succ> tj \\<longrightarrow>\n   si \\<cdot> \\<delta> \\<succ> tj \\<cdot> \\<delta>) \\<and>\n  (si \\<succeq> tj \\<longrightarrow>\n   si \\<cdot> \\<delta> \\<succeq> tj \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. (si \\<succ> tj \\<Longrightarrow>\n     si \\<cdot> \\<delta> \\<succ> tj \\<cdot> \\<delta>) &&&\n    (si \\<succeq> tj \\<Longrightarrow>\n     si \\<cdot> \\<delta> \\<succeq> tj \\<cdot> \\<delta>)", "by blast+"], ["proof (state)\nthis:\n  si \\<succ> tj \\<Longrightarrow>\n  si \\<cdot> \\<delta> \\<succ> tj \\<cdot> \\<delta>\n  si \\<succeq> tj \\<Longrightarrow>\n  si \\<cdot> \\<delta> \\<succeq> tj \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?si2 \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n   ?tj2 \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n   ?si2 \\<succ> ?tj2\\<rbrakk>\n  \\<Longrightarrow> ?si2 \\<cdot> \\<delta> \\<succ> ?tj2 \\<cdot> \\<delta>\n  \\<lbrakk>?si2 \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n   ?tj2 \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n   ?si2 \\<succeq> ?tj2\\<rbrakk>\n  \\<Longrightarrow> ?si2 \\<cdot> \\<delta> \\<succeq> ?tj2 \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note IH' = this"], ["proof (state)\nthis:\n  \\<lbrakk>?si2 \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n   ?tj2 \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n   ?si2 \\<succ> ?tj2\\<rbrakk>\n  \\<Longrightarrow> ?si2 \\<cdot> \\<delta> \\<succ> ?tj2 \\<cdot> \\<delta>\n  \\<lbrakk>?si2 \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n   ?tj2 \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n   ?si2 \\<succeq> ?tj2\\<rbrakk>\n  \\<Longrightarrow> ?si2 \\<cdot> \\<delta> \\<succeq> ?tj2 \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?si2 \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n   ?tj2 \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n   ?si2 \\<succ> ?tj2\\<rbrakk>\n  \\<Longrightarrow> ?si2 \\<cdot> \\<delta> \\<succ> ?tj2 \\<cdot> \\<delta>\n  \\<lbrakk>?si2 \\<in> set (map ((!) ss) (\\<sigma> (f, length ss)));\n   ?tj2 \\<in> set (map ((!) ts) (\\<sigma> (g, length ts)));\n   ?si2 \\<succeq> ?tj2\\<rbrakk>\n  \\<Longrightarrow> ?si2 \\<cdot> \\<delta> \\<succeq> ?tj2 \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "assume \"i < ?ls\" \"i < ?lt\""], ["proof (state)\nthis:\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))", "have i_f: \"i < length (\\<sigma> ?f)\" and i_g: \"i < length (\\<sigma> ?g)\""], ["proof (prove)\nusing this:\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))\n\ngoal (1 subgoal):\n 1. i < length (\\<sigma> (f, length ss)) &&&\n    i < length (\\<sigma> (g, length ts))", "by auto"], ["proof (state)\nthis:\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with \\<sigma>[of f \"length ss\"] \\<sigma>[of g \"length ts\"]"], ["proof (chain)\npicking this:\n  set (\\<sigma> (f, length ss)) \\<subseteq> {0..<length ss}\n  set (\\<sigma> (g, length ts)) \\<subseteq> {0..<length ts}\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))", "have i: \"\\<sigma> ?f ! i < length ss\" \"\\<sigma> ?g ! i < length ts\""], ["proof (prove)\nusing this:\n  set (\\<sigma> (f, length ss)) \\<subseteq> {0..<length ss}\n  set (\\<sigma> (g, length ts)) \\<subseteq> {0..<length ts}\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))\n\ngoal (1 subgoal):\n 1. \\<sigma> (f, length ss) ! i < length ss &&&\n    \\<sigma> (g, length ts) ! i < length ts", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  {\\<sigma> (f, length ss) ! i |i. i < length (\\<sigma> (f, length ss))}\n  \\<subseteq> {0..<length ss}\n  {\\<sigma> (g, length ts) ! i |i. i < length (\\<sigma> (g, length ts))}\n  \\<subseteq> {0..<length ts}\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))\n\ngoal (1 subgoal):\n 1. \\<sigma> (f, length ss) ! i < length ss &&&\n    \\<sigma> (g, length ts) ! i < length ts", "by auto"], ["proof (state)\nthis:\n  \\<sigma> (f, length ss) ! i < length ss\n  \\<sigma> (g, length ts) ! i < length ts\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  \\<sigma> (f, length ss) ! i < length ss\n  \\<sigma> (g, length ts) ! i < length ts", "have \"size (ss ! (\\<sigma> ?f ! i)) < size s\" \"size (ts ! (\\<sigma> ?g ! i)) < size t\""], ["proof (prove)\nusing this:\n  \\<sigma> (f, length ss) ! i < length ss\n  \\<sigma> (g, length ts) ! i < length ts\n\ngoal (1 subgoal):\n 1. size (ss ! (\\<sigma> (f, length ss) ! i)) < size s &&&\n    size (ts ! (\\<sigma> (g, length ts) ! i)) < size t", "unfolding s t"], ["proof (prove)\nusing this:\n  \\<sigma> (f, length ss) ! i < length ss\n  \\<sigma> (g, length ts) ! i < length ts\n\ngoal (1 subgoal):\n 1. size (ss ! (\\<sigma> (f, length ss) ! i)) < size (Fun f ss) &&&\n    size (ts ! (\\<sigma> (g, length ts) ! i)) < size (Fun g ts)", "by (auto simp: size_simps)"], ["proof (state)\nthis:\n  size (ss ! (\\<sigma> (f, length ss) ! i)) < size s\n  size (ts ! (\\<sigma> (g, length ts) ! i)) < size t\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  size (ss ! (\\<sigma> (f, length ss) ! i)) < size s\n  size (ts ! (\\<sigma> (g, length ts) ! i)) < size t", "have \"size (ss ! (\\<sigma> ?f ! i)) + size (ts ! (\\<sigma> ?g ! i)) < size s + size t\""], ["proof (prove)\nusing this:\n  size (ss ! (\\<sigma> (f, length ss) ! i)) < size s\n  size (ts ! (\\<sigma> (g, length ts) ! i)) < size t\n\ngoal (1 subgoal):\n 1. size (ss ! (\\<sigma> (f, length ss) ! i)) +\n    size (ts ! (\\<sigma> (g, length ts) ! i))\n    < size s + size t", "by simp"], ["proof (state)\nthis:\n  size (ss ! (\\<sigma> (f, length ss) ! i)) +\n  size (ts ! (\\<sigma> (g, length ts) ! i))\n  < size s + size t\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from IH[OF this] i i_f i_g"], ["proof (chain)\npicking this:\n  (ss ! (\\<sigma> (f, length ss) ! i) \\<succ>\n   ts ! (\\<sigma> (g, length ts) ! i) \\<longrightarrow>\n   ss ! (\\<sigma> (f, length ss) ! i) \\<cdot> \\<delta> \\<succ>\n   ts ! (\\<sigma> (g, length ts) ! i) \\<cdot> \\<delta>) \\<and>\n  (ss ! (\\<sigma> (f, length ss) ! i) \\<succeq>\n   ts ! (\\<sigma> (g, length ts) ! i) \\<longrightarrow>\n   ss ! (\\<sigma> (f, length ss) ! i) \\<cdot> \\<delta> \\<succeq>\n   ts ! (\\<sigma> (g, length ts) ! i) \\<cdot> \\<delta>)\n  \\<sigma> (f, length ss) ! i < length ss\n  \\<sigma> (g, length ts) ! i < length ts\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))", "have \"(wpo_s (?mmss ! i) (?mmts ! i) \\<Longrightarrow>\n                     wpo_s (?mss ! (\\<sigma> ?f ! i)) (?mts ! (\\<sigma> ?g ! i)))\" \n                \"(wpo_ns (?mmss ! i) (?mmts ! i) \\<Longrightarrow>\n                     wpo_ns (?mss ! (\\<sigma> ?f ! i)) (?mts ! (\\<sigma> ?g ! i)))\""], ["proof (prove)\nusing this:\n  (ss ! (\\<sigma> (f, length ss) ! i) \\<succ>\n   ts ! (\\<sigma> (g, length ts) ! i) \\<longrightarrow>\n   ss ! (\\<sigma> (f, length ss) ! i) \\<cdot> \\<delta> \\<succ>\n   ts ! (\\<sigma> (g, length ts) ! i) \\<cdot> \\<delta>) \\<and>\n  (ss ! (\\<sigma> (f, length ss) ! i) \\<succeq>\n   ts ! (\\<sigma> (g, length ts) ! i) \\<longrightarrow>\n   ss ! (\\<sigma> (f, length ss) ! i) \\<cdot> \\<delta> \\<succeq>\n   ts ! (\\<sigma> (g, length ts) ! i) \\<cdot> \\<delta>)\n  \\<sigma> (f, length ss) ! i < length ss\n  \\<sigma> (g, length ts) ! i < length ts\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))\n\ngoal (1 subgoal):\n 1. (map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n     map ((!) ts) (\\<sigma> (g, length ts)) ! i \\<Longrightarrow>\n     map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n     (\\<sigma> (f, length ss) ! i) \\<succ>\n     map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n     (\\<sigma> (g, length ts) ! i)) &&&\n    (map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n     map ((!) ts) (\\<sigma> (g, length ts)) ! i \\<Longrightarrow>\n     map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n     (\\<sigma> (f, length ss) ! i) \\<succeq>\n     map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n     (\\<sigma> (g, length ts) ! i))", "by auto"], ["proof (state)\nthis:\n  map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n  map ((!) ts) (\\<sigma> (g, length ts)) ! i \\<Longrightarrow>\n  map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n  (\\<sigma> (f, length ss) ! i) \\<succ>\n  map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! (\\<sigma> (g, length ts) ! i)\n  map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n  map ((!) ts) (\\<sigma> (g, length ts)) ! i \\<Longrightarrow>\n  map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n  (\\<sigma> (f, length ss) ! i) \\<succeq>\n  map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! (\\<sigma> (g, length ts) ! i)\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succ>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succ>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succeq>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succeq>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note IH = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succ>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succ>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succeq>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succeq>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "consider (Lex) \"c ?f = Lex\" \"c ?g = Lex\" | (Mul) \"c ?f = Mul\" \"c ?g = Mul\" | (Diff) \"c ?f \\<noteq> c ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>c (f, length ss) = Lex;\n              c (g, length ts) = Lex\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     c (f, length ss) \\<noteq> c (g, length ts) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases \"c ?f\"; cases \"c ?g\", auto)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>c (f, length ss) = Lex; c (g, length ts) = Lex\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   c (f, length ss) \\<noteq> c (g, length ts) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> prs \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>c (f, length ss) = Lex; c (g, length ts) = Lex\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   c (f, length ss) \\<noteq> c (g, length ts) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>c (f, length ss) = Lex; c (g, length ts) = Lex\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 3. c (f, length ss) \\<noteq> c (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case Lex"], ["proof (state)\nthis:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n\ngoal (3 subgoals):\n 1. \\<lbrakk>c (f, length ss) = Lex; c (g, length ts) = Lex\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 3. c (f, length ss) \\<noteq> c (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from Lex False ns"], ["proof (chain)\npicking this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  \\<not> prs\n  snd (if prns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if prs then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))", "have \"snd (lex_ext wpo n ?mmss ?mmts)\""], ["proof (prove)\nusing this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  \\<not> prs\n  snd (if prns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if prs then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts))))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  snd (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>c (f, length ss) = Lex; c (g, length ts) = Lex\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 3. c (f, length ss) \\<noteq> c (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from this[unfolded lex_ext_iff snd_conv]"], ["proof (chain)\npicking this:\n  (length (map ((!) ss) (\\<sigma> (f, length ss))) =\n   length (map ((!) ts) (\\<sigma> (g, length ts))) \\<or>\n   length (map ((!) ts) (\\<sigma> (g, length ts))) \\<le> n) \\<and>\n  ((\\<exists>i<length (map ((!) ss) (\\<sigma> (f, length ss))).\n       i < length (map ((!) ts) (\\<sigma> (g, length ts))) \\<and>\n       (\\<forall>j<i.\n           map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n           map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<or>\n   (\\<forall>i<length (map ((!) ts) (\\<sigma> (g, length ts))).\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n   length (map ((!) ts) (\\<sigma> (g, length ts)))\n   \\<le> length (map ((!) ss) (\\<sigma> (f, length ss))))", "have len: \"(?ls = ?lt \\<or> ?lt \\<le> n)\"\n                and choice: \"(\\<exists>i< ?ls.\n               i < ?lt \\<and> (\\<forall>j<i. wpo_ns (?mmss ! j) (?mmts ! j)) \\<and> wpo_s (?mmss ! i) (?mmts ! i)) \\<or>\n               (\\<forall>i< ?lt. wpo_ns (?mmss ! i) (?mmts ! i)) \\<and> ?lt \\<le> ?ls\" (is \"?stri \\<or> ?nstri\")"], ["proof (prove)\nusing this:\n  (length (map ((!) ss) (\\<sigma> (f, length ss))) =\n   length (map ((!) ts) (\\<sigma> (g, length ts))) \\<or>\n   length (map ((!) ts) (\\<sigma> (g, length ts))) \\<le> n) \\<and>\n  ((\\<exists>i<length (map ((!) ss) (\\<sigma> (f, length ss))).\n       i < length (map ((!) ts) (\\<sigma> (g, length ts))) \\<and>\n       (\\<forall>j<i.\n           map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n           map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<or>\n   (\\<forall>i<length (map ((!) ts) (\\<sigma> (g, length ts))).\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n   length (map ((!) ts) (\\<sigma> (g, length ts)))\n   \\<le> length (map ((!) ss) (\\<sigma> (f, length ss))))\n\ngoal (1 subgoal):\n 1. length (\\<sigma> (f, length ss)) =\n    length (\\<sigma> (g, length ts)) \\<or>\n    length (\\<sigma> (g, length ts)) \\<le> n &&&\n    (\\<exists>i<length (\\<sigma> (f, length ss)).\n        i < length (\\<sigma> (g, length ts)) \\<and>\n        (\\<forall>j<i.\n            map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n            map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<or>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))", "by auto"], ["proof (state)\nthis:\n  length (\\<sigma> (f, length ss)) = length (\\<sigma> (g, length ts)) \\<or>\n  length (\\<sigma> (g, length ts)) \\<le> n\n  (\\<exists>i<length (\\<sigma> (f, length ss)).\n      i < length (\\<sigma> (g, length ts)) \\<and>\n      (\\<forall>j<i.\n          map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n          map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<or>\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>c (f, length ss) = Lex; c (g, length ts) = Lex\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 3. c (f, length ss) \\<noteq> c (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from choice"], ["proof (chain)\npicking this:\n  (\\<exists>i<length (\\<sigma> (f, length ss)).\n      i < length (\\<sigma> (g, length ts)) \\<and>\n      (\\<forall>j<i.\n          map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n          map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<or>\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))", "have \"?stri \\<or> (\\<not> ?stri \\<and> ?nstri)\""], ["proof (prove)\nusing this:\n  (\\<exists>i<length (\\<sigma> (f, length ss)).\n      i < length (\\<sigma> (g, length ts)) \\<and>\n      (\\<forall>j<i.\n          map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n          map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<or>\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. (\\<exists>i<length (\\<sigma> (f, length ss)).\n        i < length (\\<sigma> (g, length ts)) \\<and>\n        (\\<forall>j<i.\n            map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n            map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<or>\n    \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>i<length (\\<sigma> (f, length ss)).\n      i < length (\\<sigma> (g, length ts)) \\<and>\n      (\\<forall>j<i.\n          map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n          map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<or>\n  \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n             i < length (\\<sigma> (g, length ts)) \\<and>\n             (\\<forall>j<i.\n                 map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                 map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n             map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n             map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>c (f, length ss) = Lex; c (g, length ts) = Lex\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 3. c (f, length ss) \\<noteq> c (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  (\\<exists>i<length (\\<sigma> (f, length ss)).\n      i < length (\\<sigma> (g, length ts)) \\<and>\n      (\\<forall>j<i.\n          map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n          map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<or>\n  \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n             i < length (\\<sigma> (g, length ts)) \\<and>\n             (\\<forall>j<i.\n                 map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                 map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n             map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n             map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>i<length (\\<sigma> (f, length ss)).\n      i < length (\\<sigma> (g, length ts)) \\<and>\n      (\\<forall>j<i.\n          map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n          map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<or>\n  \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n             i < length (\\<sigma> (g, length ts)) \\<and>\n             (\\<forall>j<i.\n                 map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                 map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n             map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n             map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i<length (\\<sigma> (f, length ss)).\n       i < length (\\<sigma> (g, length ts)) \\<and>\n       (\\<forall>j<i.\n           map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n           map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "assume ?stri"], ["proof (state)\nthis:\n  \\<exists>i<length (\\<sigma> (f, length ss)).\n     i < length (\\<sigma> (g, length ts)) \\<and>\n     (\\<forall>j<i.\n         map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n         map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n     map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n     map ((!) ts) (\\<sigma> (g, length ts)) ! i\n\ngoal (2 subgoals):\n 1. \\<exists>i<length (\\<sigma> (f, length ss)).\n       i < length (\\<sigma> (g, length ts)) \\<and>\n       (\\<forall>j<i.\n           map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n           map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i<length (\\<sigma> (f, length ss)).\n     i < length (\\<sigma> (g, length ts)) \\<and>\n     (\\<forall>j<i.\n         map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n         map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n     map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n     map ((!) ts) (\\<sigma> (g, length ts)) ! i", "obtain i where i: \"i < ?ls\" \"i < ?lt\"\n                  and NS: \"(\\<forall>j<i. wpo_ns (?mmss ! j) (?mmts ! j))\" and S: \"wpo_s (?mmss ! i) (?mmts ! i)\""], ["proof (prove)\nusing this:\n  \\<exists>i<length (\\<sigma> (f, length ss)).\n     i < length (\\<sigma> (g, length ts)) \\<and>\n     (\\<forall>j<i.\n         map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n         map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n     map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n     map ((!) ts) (\\<sigma> (g, length ts)) ! i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length (\\<sigma> (f, length ss));\n         i < length (\\<sigma> (g, length ts));\n         \\<forall>j<i.\n            map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n            map ((!) ts) (\\<sigma> (g, length ts)) ! j;\n         map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n         map ((!) ts) (\\<sigma> (g, length ts)) ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))\n  \\<forall>j<i.\n     map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n     map ((!) ts) (\\<sigma> (g, length ts)) ! j\n  map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n  map ((!) ts) (\\<sigma> (g, length ts)) ! i\n\ngoal (2 subgoals):\n 1. \\<exists>i<length (\\<sigma> (f, length ss)).\n       i < length (\\<sigma> (g, length ts)) \\<and>\n       (\\<forall>j<i.\n           map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n           map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with IH"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succ>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succ>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succeq>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succeq>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))\n  \\<forall>j<i.\n     map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n     map ((!) ts) (\\<sigma> (g, length ts)) ! j\n  map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n  map ((!) ts) (\\<sigma> (g, length ts)) ! i", "have \"(\\<forall>j<i. wpo_ns (?Mmss ! j) (?Mmts ! j))\" \"wpo_s (?Mmss ! i) (?Mmts ! i)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succ>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succ>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succeq>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succeq>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))\n  \\<forall>j<i.\n     map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n     map ((!) ts) (\\<sigma> (g, length ts)) ! j\n  map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n  map ((!) ts) (\\<sigma> (g, length ts)) ! i\n\ngoal (1 subgoal):\n 1. \\<forall>j<i.\n       map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n        (\\<sigma> (f, length ss)) !\n       j \\<succeq>\n       map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n        (\\<sigma> (g, length ts)) !\n       j &&&\n    map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n     (\\<sigma> (f, length ss)) !\n    i \\<succ>\n    map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n     (\\<sigma> (g, length ts)) !\n    i", "by auto"], ["proof (state)\nthis:\n  \\<forall>j<i.\n     map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n      (\\<sigma> (f, length ss)) !\n     j \\<succeq>\n     map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n      (\\<sigma> (g, length ts)) !\n     j\n  map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n   (\\<sigma> (f, length ss)) !\n  i \\<succ>\n  map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n   (\\<sigma> (g, length ts)) !\n  i\n\ngoal (2 subgoals):\n 1. \\<exists>i<length (\\<sigma> (f, length ss)).\n       i < length (\\<sigma> (g, length ts)) \\<and>\n       (\\<forall>j<i.\n           map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n           map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with i len"], ["proof (chain)\npicking this:\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))\n  length (\\<sigma> (f, length ss)) = length (\\<sigma> (g, length ts)) \\<or>\n  length (\\<sigma> (g, length ts)) \\<le> n\n  \\<forall>j<i.\n     map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n      (\\<sigma> (f, length ss)) !\n     j \\<succeq>\n     map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n      (\\<sigma> (g, length ts)) !\n     j\n  map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n   (\\<sigma> (f, length ss)) !\n  i \\<succ>\n  map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n   (\\<sigma> (g, length ts)) !\n  i", "have \"fst (lex_ext wpo n ?Mmss ?Mmts)\""], ["proof (prove)\nusing this:\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))\n  length (\\<sigma> (f, length ss)) = length (\\<sigma> (g, length ts)) \\<or>\n  length (\\<sigma> (g, length ts)) \\<le> n\n  \\<forall>j<i.\n     map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n      (\\<sigma> (f, length ss)) !\n     j \\<succeq>\n     map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n      (\\<sigma> (g, length ts)) !\n     j\n  map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n   (\\<sigma> (f, length ss)) !\n  i \\<succ>\n  map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n   (\\<sigma> (g, length ts)) !\n  i\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n\n          (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n            (\\<sigma> (f, length ss)))\n          (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n            (\\<sigma> (g, length ts))))", "unfolding lex_ext_iff"], ["proof (prove)\nusing this:\n  i < length (\\<sigma> (f, length ss))\n  i < length (\\<sigma> (g, length ts))\n  length (\\<sigma> (f, length ss)) = length (\\<sigma> (g, length ts)) \\<or>\n  length (\\<sigma> (g, length ts)) \\<le> n\n  \\<forall>j<i.\n     map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n      (\\<sigma> (f, length ss)) !\n     j \\<succeq>\n     map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n      (\\<sigma> (g, length ts)) !\n     j\n  map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n   (\\<sigma> (f, length ss)) !\n  i \\<succ>\n  map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n   (\\<sigma> (g, length ts)) !\n  i\n\ngoal (1 subgoal):\n 1. fst ((length\n           (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n             (\\<sigma> (f, length ss))) =\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts))) \\<or>\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts)))\n          \\<le> n) \\<and>\n         ((\\<exists>i<length\n                       (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                         (\\<sigma> (f, length ss))).\n              i < length\n                   (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                     (\\<sigma> (g, length ts))) \\<and>\n              (\\<forall>j<i.\n                  map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                   (\\<sigma> (f, length ss)) !\n                  j \\<succeq>\n                  map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                   (\\<sigma> (g, length ts)) !\n                  j) \\<and>\n              map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)) !\n              i \\<succ>\n              map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n               (\\<sigma> (g, length ts)) !\n              i) \\<or>\n          (\\<forall>i<length\n                       (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                         (\\<sigma> (g, length ts))).\n              map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)) !\n              i \\<succeq>\n              map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n               (\\<sigma> (g, length ts)) !\n              i) \\<and>\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts)))\n          < length\n             (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)))),\n         (length\n           (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n             (\\<sigma> (f, length ss))) =\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts))) \\<or>\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts)))\n          \\<le> n) \\<and>\n         ((\\<exists>i<length\n                       (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                         (\\<sigma> (f, length ss))).\n              i < length\n                   (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                     (\\<sigma> (g, length ts))) \\<and>\n              (\\<forall>j<i.\n                  map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                   (\\<sigma> (f, length ss)) !\n                  j \\<succeq>\n                  map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                   (\\<sigma> (g, length ts)) !\n                  j) \\<and>\n              map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)) !\n              i \\<succ>\n              map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n               (\\<sigma> (g, length ts)) !\n              i) \\<or>\n          (\\<forall>i<length\n                       (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                         (\\<sigma> (g, length ts))).\n              map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)) !\n              i \\<succeq>\n              map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n               (\\<sigma> (g, length ts)) !\n              i) \\<and>\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts)))\n          \\<le> length\n                 (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                   (\\<sigma> (f, length ss)))))", "by auto"], ["proof (state)\nthis:\n  fst (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (2 subgoals):\n 1. \\<exists>i<length (\\<sigma> (f, length ss)).\n       i < length (\\<sigma> (g, length ts)) \\<and>\n       (\\<forall>j<i.\n           map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n           map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with Lex ss_ts sstsA p \\<open>prns\\<close>"], ["proof (chain)\npicking this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  fst (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))", "have \"wpo_s ?s ?t\""], ["proof (prove)\nusing this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  fst (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>", "unfolding simps"], ["proof (prove)\nusing this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  fst (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. fst (case s \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                   ss ! i \\<succeq> t \\<cdot> \\<delta>\n             then (True, True)\n             else case t \\<cdot> \\<delta> of\n                  Var x \\<Rightarrow>\n                    (False, ssimple \\<and> large (f, length ss))\n                  | Fun g ts \\<Rightarrow>\n                      case prc (f, length ss) (g, length ts) of\n                      (prs, prns) \\<Rightarrow>\n                        if prns \\<and>\n                           (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                               s \\<cdot> \\<delta> \\<succ> ts ! j)\n                        then if prs then (True, True)\n                             else let ss' =\n  map ((!) ss) (\\<sigma> (f, length ss));\nts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\ncg = c (g, length ts)\n                                  in if cf = Lex \\<and> cg = Lex\n                                     then lex_ext wpo n ss' ts'\n                                     else if cf = Mul \\<and> cg = Mul\n    then mul_ext wpo ss' ts'\n    else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                        else (False, False))", "unfolding s t"], ["proof (prove)\nusing this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  Fun f ss \\<cdot> \\<delta> \\<succ>\n  map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (Fun f ss \\<cdot> \\<delta>, Fun g ts \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  fst (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. fst (case Fun f ss \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case Fun g ts \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun fa ssa \\<Rightarrow>\n             if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                   ssa ! i \\<succeq> Fun g ts \\<cdot> \\<delta>\n             then (True, True)\n             else case Fun g ts \\<cdot> \\<delta> of\n                  Var x \\<Rightarrow>\n                    (False, ssimple \\<and> large (fa, length ssa))\n                  | Fun g ts \\<Rightarrow>\n                      case prc (fa, length ssa) (g, length ts) of\n                      (prs, prns) \\<Rightarrow>\n                        if prns \\<and>\n                           (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                               Fun f ss \\<cdot> \\<delta> \\<succ> ts ! j)\n                        then if prs then (True, True)\n                             else let ss' =\n  map ((!) ssa) (\\<sigma> (fa, length ssa));\nts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (fa, length ssa);\ncg = c (g, length ts)\n                                  in if cf = Lex \\<and> cg = Lex\n                                     then lex_ext wpo n ss' ts'\n                                     else if cf = Mul \\<and> cg = Mul\n    then mul_ext wpo ss' ts'\n    else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                        else (False, False))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>\n\ngoal (2 subgoals):\n 1. \\<exists>i<length (\\<sigma> (f, length ss)).\n       i < length (\\<sigma> (g, length ts)) \\<and>\n       (\\<forall>j<i.\n           map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n           map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with wpo_s_imp_ns[OF this]"], ["proof (chain)\npicking this:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "by blast"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "assume \"\\<not> ?stri \\<and> ?nstri\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n             i < length (\\<sigma> (g, length ts)) \\<and>\n             (\\<forall>j<i.\n                 map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                 map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n             map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n             map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n             i < length (\\<sigma> (g, length ts)) \\<and>\n             (\\<forall>j<i.\n                 map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                 map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n             map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n             map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))", "have ?nstri and nstri: \"\\<not> ?stri\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n             i < length (\\<sigma> (g, length ts)) \\<and>\n             (\\<forall>j<i.\n                 map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                 map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n             map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n             map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) &&&\n    \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i)", "by blast+"], ["proof (state)\nthis:\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))\n  \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n             i < length (\\<sigma> (g, length ts)) \\<and>\n             (\\<forall>j<i.\n                 map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                 map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n             map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n             map ((!) ts) (\\<sigma> (g, length ts)) ! i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with IH"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succ>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succ>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succeq>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succeq>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))\n  \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n             i < length (\\<sigma> (g, length ts)) \\<and>\n             (\\<forall>j<i.\n                 map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                 map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n             map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n             map ((!) ts) (\\<sigma> (g, length ts)) ! i)", "have \"(\\<forall>i< ?lt. wpo_ns (?Mmss ! i) (?Mmts ! i)) \\<and> ?lt \\<le> ?ls\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succ>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succ>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succeq>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succeq>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))\n  \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n             i < length (\\<sigma> (g, length ts)) \\<and>\n             (\\<forall>j<i.\n                 map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                 map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n             map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n             map ((!) ts) (\\<sigma> (g, length ts)) ! i)\n\ngoal (1 subgoal):\n 1. (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n         (\\<sigma> (f, length ss)) !\n        i \\<succeq>\n        map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n         (\\<sigma> (g, length ts)) !\n        i) \\<and>\n    length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n       (\\<sigma> (f, length ss)) !\n      i \\<succeq>\n      map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n       (\\<sigma> (g, length ts)) !\n      i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with len"], ["proof (chain)\npicking this:\n  length (\\<sigma> (f, length ss)) = length (\\<sigma> (g, length ts)) \\<or>\n  length (\\<sigma> (g, length ts)) \\<le> n\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n       (\\<sigma> (f, length ss)) !\n      i \\<succeq>\n      map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n       (\\<sigma> (g, length ts)) !\n      i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))", "have \"snd (lex_ext wpo n ?Mmss ?Mmts)\""], ["proof (prove)\nusing this:\n  length (\\<sigma> (f, length ss)) = length (\\<sigma> (g, length ts)) \\<or>\n  length (\\<sigma> (g, length ts)) \\<le> n\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n       (\\<sigma> (f, length ss)) !\n      i \\<succeq>\n      map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n       (\\<sigma> (g, length ts)) !\n      i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. snd (lex_ext wpo n\n          (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n            (\\<sigma> (f, length ss)))\n          (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n            (\\<sigma> (g, length ts))))", "unfolding lex_ext_iff"], ["proof (prove)\nusing this:\n  length (\\<sigma> (f, length ss)) = length (\\<sigma> (g, length ts)) \\<or>\n  length (\\<sigma> (g, length ts)) \\<le> n\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n       (\\<sigma> (f, length ss)) !\n      i \\<succeq>\n      map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n       (\\<sigma> (g, length ts)) !\n      i) \\<and>\n  length (\\<sigma> (g, length ts)) \\<le> length (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. snd ((length\n           (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n             (\\<sigma> (f, length ss))) =\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts))) \\<or>\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts)))\n          \\<le> n) \\<and>\n         ((\\<exists>i<length\n                       (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                         (\\<sigma> (f, length ss))).\n              i < length\n                   (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                     (\\<sigma> (g, length ts))) \\<and>\n              (\\<forall>j<i.\n                  map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                   (\\<sigma> (f, length ss)) !\n                  j \\<succeq>\n                  map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                   (\\<sigma> (g, length ts)) !\n                  j) \\<and>\n              map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)) !\n              i \\<succ>\n              map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n               (\\<sigma> (g, length ts)) !\n              i) \\<or>\n          (\\<forall>i<length\n                       (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                         (\\<sigma> (g, length ts))).\n              map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)) !\n              i \\<succeq>\n              map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n               (\\<sigma> (g, length ts)) !\n              i) \\<and>\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts)))\n          < length\n             (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)))),\n         (length\n           (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n             (\\<sigma> (f, length ss))) =\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts))) \\<or>\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts)))\n          \\<le> n) \\<and>\n         ((\\<exists>i<length\n                       (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                         (\\<sigma> (f, length ss))).\n              i < length\n                   (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                     (\\<sigma> (g, length ts))) \\<and>\n              (\\<forall>j<i.\n                  map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                   (\\<sigma> (f, length ss)) !\n                  j \\<succeq>\n                  map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                   (\\<sigma> (g, length ts)) !\n                  j) \\<and>\n              map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)) !\n              i \\<succ>\n              map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n               (\\<sigma> (g, length ts)) !\n              i) \\<or>\n          (\\<forall>i<length\n                       (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                         (\\<sigma> (g, length ts))).\n              map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)) !\n              i \\<succeq>\n              map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n               (\\<sigma> (g, length ts)) !\n              i) \\<and>\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts)))\n          \\<le> length\n                 (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                   (\\<sigma> (f, length ss)))))", "by auto"], ["proof (state)\nthis:\n  snd (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with Lex ss_ts sstsA p \\<open>prns\\<close>"], ["proof (chain)\npicking this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  snd (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))", "have ns: \"wpo_ns ?s ?t\""], ["proof (prove)\nusing this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  snd (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>", "unfolding simps"], ["proof (prove)\nusing this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  snd (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. snd (case s \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                   ss ! i \\<succeq> t \\<cdot> \\<delta>\n             then (True, True)\n             else case t \\<cdot> \\<delta> of\n                  Var x \\<Rightarrow>\n                    (False, ssimple \\<and> large (f, length ss))\n                  | Fun g ts \\<Rightarrow>\n                      case prc (f, length ss) (g, length ts) of\n                      (prs, prns) \\<Rightarrow>\n                        if prns \\<and>\n                           (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                               s \\<cdot> \\<delta> \\<succ> ts ! j)\n                        then if prs then (True, True)\n                             else let ss' =\n  map ((!) ss) (\\<sigma> (f, length ss));\nts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\ncg = c (g, length ts)\n                                  in if cf = Lex \\<and> cg = Lex\n                                     then lex_ext wpo n ss' ts'\n                                     else if cf = Mul \\<and> cg = Mul\n    then mul_ext wpo ss' ts'\n    else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                        else (False, False))", "unfolding s t"], ["proof (prove)\nusing this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  Fun f ss \\<cdot> \\<delta> \\<succ>\n  map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (Fun f ss \\<cdot> \\<delta>, Fun g ts \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  snd (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. snd (case Fun f ss \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case Fun g ts \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun fa ssa \\<Rightarrow>\n             if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                   ssa ! i \\<succeq> Fun g ts \\<cdot> \\<delta>\n             then (True, True)\n             else case Fun g ts \\<cdot> \\<delta> of\n                  Var x \\<Rightarrow>\n                    (False, ssimple \\<and> large (fa, length ssa))\n                  | Fun g ts \\<Rightarrow>\n                      case prc (fa, length ssa) (g, length ts) of\n                      (prs, prns) \\<Rightarrow>\n                        if prns \\<and>\n                           (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                               Fun f ss \\<cdot> \\<delta> \\<succ> ts ! j)\n                        then if prs then (True, True)\n                             else let ss' =\n  map ((!) ssa) (\\<sigma> (fa, length ssa));\nts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (fa, length ssa);\ncg = c (g, length ts)\n                                  in if cf = Lex \\<and> cg = Lex\n                                     then lex_ext wpo n ss' ts'\n                                     else if cf = Mul \\<and> cg = Mul\n    then mul_ext wpo ss' ts'\n    else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                        else (False, False))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "{"], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "assume \"wpo_s s t\""], ["proof (state)\nthis:\n  s \\<succ> t\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from Lex this[unfolded simps, unfolded s t term.simps p split id] False"], ["proof (chain)\npicking this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  fst (if False then (True, True)\n       else if prns \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                   Fun f ss \\<succ> ts ! j)\n            then if prs then (True, True)\n                 else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                          cf = c (f, length ss); cg = c (g, length ts)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n  \\<not> prs", "have \"fst (lex_ext wpo n ?mmss ?mmts)\""], ["proof (prove)\nusing this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  fst (if False then (True, True)\n       else if prns \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                   Fun f ss \\<succ> ts ! j)\n            then if prs then (True, True)\n                 else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                          ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                          cf = c (f, length ss); cg = c (g, length ts)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n  \\<not> prs\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts))))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  fst (lex_ext wpo n (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from this[unfolded lex_ext_iff fst_conv] nstri"], ["proof (chain)\npicking this:\n  (length (map ((!) ss) (\\<sigma> (f, length ss))) =\n   length (map ((!) ts) (\\<sigma> (g, length ts))) \\<or>\n   length (map ((!) ts) (\\<sigma> (g, length ts))) \\<le> n) \\<and>\n  ((\\<exists>i<length (map ((!) ss) (\\<sigma> (f, length ss))).\n       i < length (map ((!) ts) (\\<sigma> (g, length ts))) \\<and>\n       (\\<forall>j<i.\n           map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n           map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<or>\n   (\\<forall>i<length (map ((!) ts) (\\<sigma> (g, length ts))).\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n   length (map ((!) ts) (\\<sigma> (g, length ts)))\n   < length (map ((!) ss) (\\<sigma> (f, length ss))))\n  \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n             i < length (\\<sigma> (g, length ts)) \\<and>\n             (\\<forall>j<i.\n                 map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                 map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n             map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n             map ((!) ts) (\\<sigma> (g, length ts)) ! i)", "have \"(\\<forall>i< ?lt. wpo_ns (?mmss ! i) (?mmts ! i)) \\<and> ?lt < ?ls\""], ["proof (prove)\nusing this:\n  (length (map ((!) ss) (\\<sigma> (f, length ss))) =\n   length (map ((!) ts) (\\<sigma> (g, length ts))) \\<or>\n   length (map ((!) ts) (\\<sigma> (g, length ts))) \\<le> n) \\<and>\n  ((\\<exists>i<length (map ((!) ss) (\\<sigma> (f, length ss))).\n       i < length (map ((!) ts) (\\<sigma> (g, length ts))) \\<and>\n       (\\<forall>j<i.\n           map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n           map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<or>\n   (\\<forall>i<length (map ((!) ts) (\\<sigma> (g, length ts))).\n       map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n       map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n   length (map ((!) ts) (\\<sigma> (g, length ts)))\n   < length (map ((!) ss) (\\<sigma> (f, length ss))))\n  \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n             i < length (\\<sigma> (g, length ts)) \\<and>\n             (\\<forall>j<i.\n                 map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                 map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n             map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n             map ((!) ts) (\\<sigma> (g, length ts)) ! i)\n\ngoal (1 subgoal):\n 1. (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts)) < length (\\<sigma> (f, length ss))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) < length (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with IH"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succ>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succ>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succeq>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succeq>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) < length (\\<sigma> (f, length ss))", "have \"(\\<forall>i< ?lt. wpo_ns (?Mmss ! i) (?Mmts ! i)) \\<and> ?lt < ?ls\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succ>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succ>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  \\<lbrakk>?i2 < length (\\<sigma> (f, length ss));\n   ?i2 < length (\\<sigma> (g, length ts));\n   map ((!) ss) (\\<sigma> (f, length ss)) ! ?i2 \\<succeq>\n   map ((!) ts) (\\<sigma> (g, length ts)) ! ?i2\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>s. s \\<cdot> \\<delta>) ss !\n                    (\\<sigma> (f, length ss) ! ?i2) \\<succeq>\n                    map (\\<lambda>t. t \\<cdot> \\<delta>) ts !\n                    (\\<sigma> (g, length ts) ! ?i2)\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n      map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n  length (\\<sigma> (g, length ts)) < length (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n         (\\<sigma> (f, length ss)) !\n        i \\<succeq>\n        map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n         (\\<sigma> (g, length ts)) !\n        i) \\<and>\n    length (\\<sigma> (g, length ts)) < length (\\<sigma> (f, length ss))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n       (\\<sigma> (f, length ss)) !\n      i \\<succeq>\n      map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n       (\\<sigma> (g, length ts)) !\n      i) \\<and>\n  length (\\<sigma> (g, length ts)) < length (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n       (\\<sigma> (f, length ss)) !\n      i \\<succeq>\n      map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n       (\\<sigma> (g, length ts)) !\n      i) \\<and>\n  length (\\<sigma> (g, length ts)) < length (\\<sigma> (f, length ss))", "have \"fst (lex_ext wpo n ?Mmss ?Mmts)\""], ["proof (prove)\nusing this:\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n       (\\<sigma> (f, length ss)) !\n      i \\<succeq>\n      map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n       (\\<sigma> (g, length ts)) !\n      i) \\<and>\n  length (\\<sigma> (g, length ts)) < length (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n\n          (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n            (\\<sigma> (f, length ss)))\n          (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n            (\\<sigma> (g, length ts))))", "using len"], ["proof (prove)\nusing this:\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n       (\\<sigma> (f, length ss)) !\n      i \\<succeq>\n      map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n       (\\<sigma> (g, length ts)) !\n      i) \\<and>\n  length (\\<sigma> (g, length ts)) < length (\\<sigma> (f, length ss))\n  length (\\<sigma> (f, length ss)) = length (\\<sigma> (g, length ts)) \\<or>\n  length (\\<sigma> (g, length ts)) \\<le> n\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n\n          (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n            (\\<sigma> (f, length ss)))\n          (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n            (\\<sigma> (g, length ts))))", "unfolding lex_ext_iff"], ["proof (prove)\nusing this:\n  (\\<forall>i<length (\\<sigma> (g, length ts)).\n      map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n       (\\<sigma> (f, length ss)) !\n      i \\<succeq>\n      map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n       (\\<sigma> (g, length ts)) !\n      i) \\<and>\n  length (\\<sigma> (g, length ts)) < length (\\<sigma> (f, length ss))\n  length (\\<sigma> (f, length ss)) = length (\\<sigma> (g, length ts)) \\<or>\n  length (\\<sigma> (g, length ts)) \\<le> n\n\ngoal (1 subgoal):\n 1. fst ((length\n           (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n             (\\<sigma> (f, length ss))) =\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts))) \\<or>\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts)))\n          \\<le> n) \\<and>\n         ((\\<exists>i<length\n                       (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                         (\\<sigma> (f, length ss))).\n              i < length\n                   (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                     (\\<sigma> (g, length ts))) \\<and>\n              (\\<forall>j<i.\n                  map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                   (\\<sigma> (f, length ss)) !\n                  j \\<succeq>\n                  map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                   (\\<sigma> (g, length ts)) !\n                  j) \\<and>\n              map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)) !\n              i \\<succ>\n              map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n               (\\<sigma> (g, length ts)) !\n              i) \\<or>\n          (\\<forall>i<length\n                       (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                         (\\<sigma> (g, length ts))).\n              map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)) !\n              i \\<succeq>\n              map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n               (\\<sigma> (g, length ts)) !\n              i) \\<and>\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts)))\n          < length\n             (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)))),\n         (length\n           (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n             (\\<sigma> (f, length ss))) =\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts))) \\<or>\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts)))\n          \\<le> n) \\<and>\n         ((\\<exists>i<length\n                       (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                         (\\<sigma> (f, length ss))).\n              i < length\n                   (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                     (\\<sigma> (g, length ts))) \\<and>\n              (\\<forall>j<i.\n                  map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                   (\\<sigma> (f, length ss)) !\n                  j \\<succeq>\n                  map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                   (\\<sigma> (g, length ts)) !\n                  j) \\<and>\n              map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)) !\n              i \\<succ>\n              map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n               (\\<sigma> (g, length ts)) !\n              i) \\<or>\n          (\\<forall>i<length\n                       (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                         (\\<sigma> (g, length ts))).\n              map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n               (\\<sigma> (f, length ss)) !\n              i \\<succeq>\n              map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n               (\\<sigma> (g, length ts)) !\n              i) \\<and>\n          length\n           (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n             (\\<sigma> (g, length ts)))\n          \\<le> length\n                 (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n                   (\\<sigma> (f, length ss)))))", "by auto"], ["proof (state)\nthis:\n  fst (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with Lex ss_ts sstsA p \\<open>prns\\<close>"], ["proof (chain)\npicking this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  fst (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))", "have ns: \"wpo_s ?s ?t\""], ["proof (prove)\nusing this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  fst (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>", "unfolding simps"], ["proof (prove)\nusing this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  fst (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. fst (case s \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun f ss \\<Rightarrow>\n             if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                   ss ! i \\<succeq> t \\<cdot> \\<delta>\n             then (True, True)\n             else case t \\<cdot> \\<delta> of\n                  Var x \\<Rightarrow>\n                    (False, ssimple \\<and> large (f, length ss))\n                  | Fun g ts \\<Rightarrow>\n                      case prc (f, length ss) (g, length ts) of\n                      (prs, prns) \\<Rightarrow>\n                        if prns \\<and>\n                           (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                               s \\<cdot> \\<delta> \\<succ> ts ! j)\n                        then if prs then (True, True)\n                             else let ss' =\n  map ((!) ss) (\\<sigma> (f, length ss));\nts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\ncg = c (g, length ts)\n                                  in if cf = Lex \\<and> cg = Lex\n                                     then lex_ext wpo n ss' ts'\n                                     else if cf = Mul \\<and> cg = Mul\n    then mul_ext wpo ss' ts'\n    else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                        else (False, False))", "unfolding s t"], ["proof (prove)\nusing this:\n  c (f, length ss) = Lex\n  c (g, length ts) = Lex\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  Fun f ss \\<cdot> \\<delta> \\<succ>\n  map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (Fun f ss \\<cdot> \\<delta>, Fun g ts \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n  fst (lex_ext wpo n\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. fst (case Fun f ss \\<cdot> \\<delta> of\n         Var x \\<Rightarrow>\n           (False,\n            case Fun g ts \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n            | Fun g ts \\<Rightarrow>\n                True \\<and>\n                \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n         | Fun fa ssa \\<Rightarrow>\n             if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                   ssa ! i \\<succeq> Fun g ts \\<cdot> \\<delta>\n             then (True, True)\n             else case Fun g ts \\<cdot> \\<delta> of\n                  Var x \\<Rightarrow>\n                    (False, ssimple \\<and> large (fa, length ssa))\n                  | Fun g ts \\<Rightarrow>\n                      case prc (fa, length ssa) (g, length ts) of\n                      (prs, prns) \\<Rightarrow>\n                        if prns \\<and>\n                           (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                               Fun f ss \\<cdot> \\<delta> \\<succ> ts ! j)\n                        then if prs then (True, True)\n                             else let ss' =\n  map ((!) ssa) (\\<sigma> (fa, length ssa));\nts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (fa, length ssa);\ncg = c (g, length ts)\n                                  in if cf = Lex \\<and> cg = Lex\n                                     then lex_ext wpo n ss' ts'\n                                     else if cf = Mul \\<and> cg = Mul\n    then mul_ext wpo ss' ts'\n    else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                        else (False, False))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "}"], ["proof (state)\nthis:\n  s \\<succ> t \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (\\<sigma> (f, length ss)).\n               i < length (\\<sigma> (g, length ts)) \\<and>\n               (\\<forall>j<i.\n                   map ((!) ss) (\\<sigma> (f, length ss)) ! j \\<succeq>\n                   map ((!) ts) (\\<sigma> (g, length ts)) ! j) \\<and>\n               map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succ>\n               map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    (\\<forall>i<length (\\<sigma> (g, length ts)).\n        map ((!) ss) (\\<sigma> (f, length ss)) ! i \\<succeq>\n        map ((!) ts) (\\<sigma> (g, length ts)) ! i) \\<and>\n    length (\\<sigma> (g, length ts))\n    \\<le> length (\\<sigma> (f, length ss)) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "with ns"], ["proof (chain)\npicking this:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  s \\<succ> t \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>\n  s \\<succ> t \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "by blast"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. c (f, length ss) \\<noteq> c (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. c (f, length ss) \\<noteq> c (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case Diff"], ["proof (state)\nthis:\n  c (f, length ss) \\<noteq> c (g, length ts)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n 2. c (f, length ss) \\<noteq> c (g, length ts) \\<Longrightarrow>\n    (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  c (f, length ss) \\<noteq> c (g, length ts)\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "using ns ss_ts sstsA p \\<open>prns\\<close>"], ["proof (prove)\nusing this:\n  c (f, length ss) \\<noteq> c (g, length ts)\n  snd (if prns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if prs then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "unfolding simps"], ["proof (prove)\nusing this:\n  c (f, length ss) \\<noteq> c (g, length ts)\n  snd (if prns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if prs then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (s \\<cdot> \\<delta>, t \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n\ngoal (1 subgoal):\n 1. (fst (case s of\n          Var x \\<Rightarrow>\n            (False,\n             case t of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t\n              then (True, True)\n              else case t of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     fst (case s \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t \\<cdot> \\<delta>\n              then (True, True)\n              else case t \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))) \\<and>\n    (snd (case s of\n          Var x \\<Rightarrow>\n            (False,\n             case t of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t\n              then (True, True)\n              else case t of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     snd (case s \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t \\<cdot> \\<delta>\n              then (True, True)\n              else case t \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)))", "unfolding s t"], ["proof (prove)\nusing this:\n  c (f, length ss) \\<noteq> c (g, length ts)\n  snd (if prns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if prs then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  Fun f ss \\<cdot> \\<delta> \\<succ>\n  map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  (Fun f ss \\<cdot> \\<delta>, Fun g ts \\<cdot> \\<delta>) \\<in> NS\n  prc (f, length ss) (g, length ts) = (prs, prns)\n  prns\n\ngoal (1 subgoal):\n 1. (fst (case Fun f ss of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun fa ssa \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                    ssa ! i \\<succeq> Fun g ts\n              then (True, True)\n              else case Fun g ts of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (fa, length ssa))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (fa, length ssa) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Fun f ss \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ssa) (\\<sigma> (fa, length ssa));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (fa, length ssa);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     fst (case Fun f ss \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun fa ssa \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                    ssa ! i \\<succeq> Fun g ts \\<cdot> \\<delta>\n              then (True, True)\n              else case Fun g ts \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (fa, length ssa))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (fa, length ssa) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Fun f ss \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ssa) (\\<sigma> (fa, length ssa));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (fa, length ssa);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))) \\<and>\n    (snd (case Fun f ss of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun fa ssa \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                    ssa ! i \\<succeq> Fun g ts\n              then (True, True)\n              else case Fun g ts of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (fa, length ssa))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (fa, length ssa) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Fun f ss \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ssa) (\\<sigma> (fa, length ssa));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (fa, length ssa);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     snd (case Fun f ss \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case Fun g ts \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun fa ssa \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (fa, length ssa)).\n                    ssa ! i \\<succeq> Fun g ts \\<cdot> \\<delta>\n              then (True, True)\n              else case Fun g ts \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (fa, length ssa))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (fa, length ssa) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                Fun f ss \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ssa) (\\<sigma> (fa, length ssa));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (fa, length ssa);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)))", "by (auto simp: Let_def split: if_splits)"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "case Mul"], ["proof (state)\nthis:\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from Mul False ns"], ["proof (chain)\npicking this:\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  \\<not> prs\n  snd (if prns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if prs then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))", "have ge: \"snd (mul_ext wpo ?mmss ?mmts)\""], ["proof (prove)\nusing this:\n  c (f, length ss) = Mul\n  c (g, length ts) = Mul\n  \\<not> prs\n  snd (if prns \\<and>\n          (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n              Fun f ss \\<succ> ts ! j)\n       then if prs then (True, True)\n            else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                     ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                     cf = c (f, length ss); cg = c (g, length ts)\n                 in if cf = Lex \\<and> cg = Lex then lex_ext wpo n ss' ts'\n                    else if cf = Mul \\<and> cg = Mul\n                         then mul_ext wpo ss' ts'\n                         else (length ss' \\<noteq> 0 \\<and> length ts' = 0,\n                               length ts' = 0)\n       else (False, False))\n\ngoal (1 subgoal):\n 1. snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n          (map ((!) ts) (\\<sigma> (g, length ts))))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  snd (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "have ge: \"snd (mul_ext wpo ?Mmss ?Mmts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mul_ext wpo\n          (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n            (\\<sigma> (f, length ss)))\n          (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n            (\\<sigma> (g, length ts))))", "unfolding id_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mul_ext wpo\n          (map (\\<lambda>t. t \\<cdot> \\<delta>)\n            (map ((!) ss) (\\<sigma> (f, length ss))))\n          (map (\\<lambda>t. t \\<cdot> \\<delta>)\n            (map ((!) ts) (\\<sigma> (g, length ts)))))", "by (rule nstri_mul_ext_map[OF _ _ ge], (intro IH', auto)+)"], ["proof (state)\nthis:\n  snd (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "{"], ["proof (state)\nthis:\n  snd (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "assume gr: \"fst (mul_ext wpo ?mmss ?mmts)\""], ["proof (state)\nthis:\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "have gr\\<sigma>: \"fst (mul_ext wpo ?Mmss ?Mmts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (mul_ext wpo\n          (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n            (\\<sigma> (f, length ss)))\n          (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n            (\\<sigma> (g, length ts))))", "unfolding id_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (mul_ext wpo\n          (map (\\<lambda>t. t \\<cdot> \\<delta>)\n            (map ((!) ss) (\\<sigma> (f, length ss))))\n          (map (\\<lambda>t. t \\<cdot> \\<delta>)\n            (map ((!) ts) (\\<sigma> (g, length ts)))))", "by (rule stri_mul_ext_map[OF _ _ gr], (intro IH', auto)+)"], ["proof (state)\nthis:\n  fst (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "}"], ["proof (state)\nthis:\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  fst (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "note gr = this"], ["proof (state)\nthis:\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  fst (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ss) = Mul; c (g, length ts) = Mul\\<rbrakk>\n    \\<Longrightarrow> (s \\<succ> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n                      (s \\<succeq> t \\<longrightarrow>\n                       s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "from ge gr"], ["proof (chain)\npicking this:\n  snd (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  fst (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  fst (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "using ss_ts \\<open>prns\\<close>"], ["proof (prove)\nusing this:\n  snd (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  fst (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  prns\n\ngoal (1 subgoal):\n 1. (s \\<succ> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n    (s \\<succeq> t \\<longrightarrow>\n     s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)", "unfolding simps"], ["proof (prove)\nusing this:\n  snd (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  fst (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  s \\<cdot> \\<delta> \\<succ> map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  prns\n\ngoal (1 subgoal):\n 1. (fst (case s of\n          Var x \\<Rightarrow>\n            (False,\n             case t of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t\n              then (True, True)\n              else case t of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     fst (case s \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t \\<cdot> \\<delta>\n              then (True, True)\n              else case t \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False))) \\<and>\n    (snd (case s of\n          Var x \\<Rightarrow>\n            (False,\n             case t of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t\n              then (True, True)\n              else case t of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)) \\<longrightarrow>\n     snd (case s \\<cdot> \\<delta> of\n          Var x \\<Rightarrow>\n            (False,\n             case t \\<cdot> \\<delta> of Var xa \\<Rightarrow> x = xa\n             | Fun g ts \\<Rightarrow>\n                 True \\<and>\n                 \\<sigma> (g, length ts) = [] \\<and> prl (g, length ts))\n          | Fun f ss \\<Rightarrow>\n              if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                    ss ! i \\<succeq> t \\<cdot> \\<delta>\n              then (True, True)\n              else case t \\<cdot> \\<delta> of\n                   Var x \\<Rightarrow>\n                     (False, ssimple \\<and> large (f, length ss))\n                   | Fun g ts \\<Rightarrow>\n                       case prc (f, length ss) (g, length ts) of\n                       (prs, prns) \\<Rightarrow>\n                         if prns \\<and>\n                            (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                                s \\<cdot> \\<delta> \\<succ> ts ! j)\n                         then if prs then (True, True)\n                              else let ss' =\n   map ((!) ss) (\\<sigma> (f, length ss));\n ts' = map ((!) ts) (\\<sigma> (g, length ts)); cf = c (f, length ss);\n cg = c (g, length ts)\n                                   in if cf = Lex \\<and> cg = Lex\nthen lex_ext wpo n ss' ts'\nelse if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n     else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                         else (False, False)))", "unfolding s t term.simps p split subst_apply_term.simps length_map Mul"], ["proof (prove)\nusing this:\n  snd (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n  fst (mul_ext wpo (map ((!) ss) (\\<sigma> (f, length ss)))\n        (map ((!) ts) (\\<sigma> (g, length ts)))) \\<Longrightarrow>\n  fst (mul_ext wpo\n        (map ((!) (map (\\<lambda>s. s \\<cdot> \\<delta>) ss))\n          (\\<sigma> (f, length ss)))\n        (map ((!) (map (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n          (\\<sigma> (g, length ts))))\n  ?j2 \\<in> set (\\<sigma> (g, length ts)) \\<Longrightarrow>\n  Fun f (map (\\<lambda>t. t \\<cdot> \\<delta>) ss) \\<succ>\n  map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! ?j2\n  prns\n\ngoal (1 subgoal):\n 1. (fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                ss ! i \\<succeq> Fun g ts\n          then (True, True)\n          else if prns \\<and>\n                  (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                      Fun f ss \\<succ> ts ! j)\n               then if prs then (True, True)\n                    else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                             ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                             cf = Mul; cg = Mul\n                         in if cf = Lex \\<and> cg = Lex\n                            then lex_ext wpo n ss' ts'\n                            else if cf = Mul \\<and> cg = Mul\n                                 then mul_ext wpo ss' ts'\n                                 else (length ss' \\<noteq> 0 \\<and>\n length ts' = 0,\n length ts' = 0)\n               else (False, False)) \\<longrightarrow>\n     fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                map (\\<lambda>t. t \\<cdot> \\<delta>) ss ! i \\<succeq>\n                Fun g (map (\\<lambda>t. t \\<cdot> \\<delta>) ts)\n          then (True, True)\n          else if prns \\<and>\n                  (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                      Fun f\n                       (map (\\<lambda>t. t \\<cdot> \\<delta>) ss) \\<succ>\n                      map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! j)\n               then if prs then (True, True)\n                    else let ss' =\n                               map ((!) (map\n    (\\<lambda>t. t \\<cdot> \\<delta>) ss))\n                                (\\<sigma> (f, length ss));\n                             ts' =\n                               map ((!) (map\n    (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                                (\\<sigma> (g, length ts));\n                             cf = Mul; cg = Mul\n                         in if cf = Lex \\<and> cg = Lex\n                            then lex_ext wpo n ss' ts'\n                            else if cf = Mul \\<and> cg = Mul\n                                 then mul_ext wpo ss' ts'\n                                 else (length ss' \\<noteq> 0 \\<and>\n length ts' = 0,\n length ts' = 0)\n               else (False, False))) \\<and>\n    (snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                ss ! i \\<succeq> Fun g ts\n          then (True, True)\n          else if prns \\<and>\n                  (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                      Fun f ss \\<succ> ts ! j)\n               then if prs then (True, True)\n                    else let ss' = map ((!) ss) (\\<sigma> (f, length ss));\n                             ts' = map ((!) ts) (\\<sigma> (g, length ts));\n                             cf = Mul; cg = Mul\n                         in if cf = Lex \\<and> cg = Lex\n                            then lex_ext wpo n ss' ts'\n                            else if cf = Mul \\<and> cg = Mul\n                                 then mul_ext wpo ss' ts'\n                                 else (length ss' \\<noteq> 0 \\<and>\n length ts' = 0,\n length ts' = 0)\n               else (False, False)) \\<longrightarrow>\n     snd (if \\<exists>i\\<in>set (\\<sigma> (f, length ss)).\n                map (\\<lambda>t. t \\<cdot> \\<delta>) ss ! i \\<succeq>\n                Fun g (map (\\<lambda>t. t \\<cdot> \\<delta>) ts)\n          then (True, True)\n          else if prns \\<and>\n                  (\\<forall>j\\<in>set (\\<sigma> (g, length ts)).\n                      Fun f\n                       (map (\\<lambda>t. t \\<cdot> \\<delta>) ss) \\<succ>\n                      map (\\<lambda>t. t \\<cdot> \\<delta>) ts ! j)\n               then if prs then (True, True)\n                    else let ss' =\n                               map ((!) (map\n    (\\<lambda>t. t \\<cdot> \\<delta>) ss))\n                                (\\<sigma> (f, length ss));\n                             ts' =\n                               map ((!) (map\n    (\\<lambda>t. t \\<cdot> \\<delta>) ts))\n                                (\\<sigma> (g, length ts));\n                             cf = Mul; cg = Mul\n                         in if cf = Lex \\<and> cg = Lex\n                            then lex_ext wpo n ss' ts'\n                            else if cf = Mul \\<and> cg = Mul\n                                 then mul_ext wpo ss' ts'\n                                 else (length ss' \\<noteq> 0 \\<and>\n length ts' = 0,\n length ts' = 0)\n               else (False, False)))", "by (simp add: id_map id)"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<succ> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succ> t \\<cdot> \\<delta>) \\<and>\n  (s \\<succeq> t \\<longrightarrow>\n   s \\<cdot> \\<delta> \\<succeq> t \\<cdot> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WPO_S_SN: \"SN WPO_S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN WPO_S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SN WPO_S", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. SN WPO_S", "fix t :: \"('f,'v)term\""], ["proof (state)\ngoal (1 subgoal):\n 1. SN WPO_S", "let ?S = \"\\<lambda>x. SN_on WPO_S {x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. SN WPO_S", "note iff = SN_on_all_reducts_SN_on_conv[of WPO_S]"], ["proof (state)\nthis:\n  SN_on WPO_S {?a} =\n  (\\<forall>b. (?a, b) \\<in> WPO_S \\<longrightarrow> SN_on WPO_S {b})\n\ngoal (1 subgoal):\n 1. SN WPO_S", "{"], ["proof (state)\nthis:\n  SN_on WPO_S {?a} =\n  (\\<forall>b. (?a, b) \\<in> WPO_S \\<longrightarrow> SN_on WPO_S {b})\n\ngoal (1 subgoal):\n 1. SN WPO_S", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. SN WPO_S", "have \"?S (Var x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN_on WPO_S {Var x}", "unfolding iff[of \"Var x\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b. (Var x, b) \\<in> WPO_S \\<longrightarrow> SN_on WPO_S {b}", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b. (Var x, b) \\<in> WPO_S \\<Longrightarrow> SN_on WPO_S {b}", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b. (Var x, b) \\<in> WPO_S \\<Longrightarrow> SN_on WPO_S {b}", "assume \"(Var x, s) \\<in> WPO_S\""], ["proof (state)\nthis:\n  (Var x, s) \\<in> WPO_S\n\ngoal (1 subgoal):\n 1. \\<And>b. (Var x, b) \\<in> WPO_S \\<Longrightarrow> SN_on WPO_S {b}", "then"], ["proof (chain)\npicking this:\n  (Var x, s) \\<in> WPO_S", "have False"], ["proof (prove)\nusing this:\n  (Var x, s) \\<in> WPO_S\n\ngoal (1 subgoal):\n 1. False", "by (cases s, auto simp: wpo.simps)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>b. (Var x, b) \\<in> WPO_S \\<Longrightarrow> SN_on WPO_S {b}", "then"], ["proof (chain)\npicking this:\n  False", "show \"?S s\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {s}", ".."], ["proof (state)\nthis:\n  SN_on WPO_S {s}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SN_on WPO_S {Var x}\n\ngoal (1 subgoal):\n 1. SN WPO_S", "}"], ["proof (state)\nthis:\n  SN_on WPO_S {Var ?x2}\n\ngoal (1 subgoal):\n 1. SN WPO_S", "note var_SN = this"], ["proof (state)\nthis:\n  SN_on WPO_S {Var ?x2}\n\ngoal (1 subgoal):\n 1. SN WPO_S", "have \"?S t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN_on WPO_S {t}", "proof (induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. SN_on WPO_S {Var x}\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "case (Var x)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x. SN_on WPO_S {Var x}\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. SN_on WPO_S {Var x}", "by (rule var_SN)"], ["proof (state)\nthis:\n  SN_on WPO_S {Var x}\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "case (Fun f ts)"], ["proof (state)\nthis:\n  ?x2a \\<in> set ts \\<Longrightarrow> SN_on WPO_S {?x2a}\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?Slist = \"\\<lambda> f ys. \\<forall> i \\<in> set (\\<sigma> f). ?S (ys ! i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?r3 = \"{((f,ab), (g,ab')). ((c f = c g) \\<longrightarrow> (?Slist f ab \\<and> \n          (c f = Mul \\<longrightarrow> fst (mul_ext wpo (map ((!) ab) (\\<sigma> f)) (map ((!) ab') (\\<sigma> g)))) \\<and>\n          (c f = Lex \\<longrightarrow> fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f)) (map ((!) ab') (\\<sigma> g))))))\n       \\<and> ((c f \\<noteq> c g) \\<longrightarrow> (map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and> (map ((!) ab') (\\<sigma> g)) = []))}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?r0 = \"lex_two {(f,g). fst (prc f g)} {(f,g). snd (prc f g)} ?r3\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "fix ab"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "assume \"\\<exists>S. S 0 = ab \\<and> (\\<forall>i. (S i, S (Suc i)) \\<in> ?r3)\""], ["proof (state)\nthis:\n  \\<exists>S.\n     S 0 = ab \\<and>\n     (\\<forall>i.\n         (S i, S (Suc i))\n         \\<in> {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])})\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "then"], ["proof (chain)\npicking this:\n  \\<exists>S.\n     S 0 = ab \\<and>\n     (\\<forall>i.\n         (S i, S (Suc i))\n         \\<in> {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])})", "obtain S where\n            S0: \"S 0 = ab\" and\n            SS: \"\\<forall>i. (S i, S (Suc i)) \\<in> ?r3\""], ["proof (prove)\nusing this:\n  \\<exists>S.\n     S 0 = ab \\<and>\n     (\\<forall>i.\n         (S i, S (Suc i))\n         \\<in> {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])})\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S 0 = ab;\n         \\<forall>i.\n            (S i, S (Suc i))\n            \\<in> {((f, ab), g, ab').\n                   (c f = c g \\<longrightarrow>\n                    (\\<forall>i\\<in>set (\\<sigma> f).\n                        SN_on WPO_S {ab ! i}) \\<and>\n                    (c f = Mul \\<longrightarrow>\n                     fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                           (map ((!) ab') (\\<sigma> g)))) \\<and>\n                    (c f = Lex \\<longrightarrow>\n                     fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                           (map ((!) ab') (\\<sigma> g))))) \\<and>\n                   (c f \\<noteq> c g \\<longrightarrow>\n                    map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                    map ((!) ab') (\\<sigma> g) = [])}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S 0 = ab\n  \\<forall>i.\n     (S i, S (Suc i))\n     \\<in> {((f, ab), g, ab').\n            (c f = c g \\<longrightarrow>\n             (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n             (c f = Mul \\<longrightarrow>\n              fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                    (map ((!) ab') (\\<sigma> g)))) \\<and>\n             (c f = Lex \\<longrightarrow>\n              fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                    (map ((!) ab') (\\<sigma> g))))) \\<and>\n            (c f \\<noteq> c g \\<longrightarrow>\n             map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n             map ((!) ab') (\\<sigma> g) = [])}\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?Sf = \"\\<lambda>i. fst (fst (S i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?Sn = \"\\<lambda>i. snd (fst (S i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?Sfn = \"\\<lambda> i. fst (S i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?Sts = \"\\<lambda>i. snd (S i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?Sts\\<sigma> = \"\\<lambda>i. map ((!) (?Sts i)) (\\<sigma> (?Sfn i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "have False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"\\<forall>i. c (?Sfn i) = Mul\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Mul \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  \\<forall>i. c (fst (S i)) = Mul\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Mul \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "let ?r' = \"{((f,ys), (g,xs)).\n                (\\<forall> yi \\<in>set ((map ((!) ys) (\\<sigma> f))). SN_on WPO_S {yi})\n                \\<and> fst (mul_ext wpo (map ((!) ys) (\\<sigma> f)) (map ((!) xs) (\\<sigma> g)))}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Mul \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Mul \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Mul \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "from True[rule_format, of i] and True[rule_format, of \"Suc i\"]\n                and SS[rule_format, of i]"], ["proof (chain)\npicking this:\n  c (fst (S i)) = Mul\n  c (fst (S (Suc i))) = Mul\n  (S i, S (Suc i))\n  \\<in> {((f, ab), g, ab').\n         (c f = c g \\<longrightarrow>\n          (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n          (c f = Mul \\<longrightarrow>\n           fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g)))) \\<and>\n          (c f = Lex \\<longrightarrow>\n           fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g))))) \\<and>\n         (c f \\<noteq> c g \\<longrightarrow>\n          map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n          map ((!) ab') (\\<sigma> g) = [])}", "have \"(S i, S (Suc i)) \\<in> ?r'\""], ["proof (prove)\nusing this:\n  c (fst (S i)) = Mul\n  c (fst (S (Suc i))) = Mul\n  (S i, S (Suc i))\n  \\<in> {((f, ab), g, ab').\n         (c f = c g \\<longrightarrow>\n          (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n          (c f = Mul \\<longrightarrow>\n           fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g)))) \\<and>\n          (c f = Lex \\<longrightarrow>\n           fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g))))) \\<and>\n         (c f \\<noteq> c g \\<longrightarrow>\n          map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n          map ((!) ab') (\\<sigma> g) = [])}\n\ngoal (1 subgoal):\n 1. (S i, S (Suc i))\n    \\<in> {((f, ys), g, xs).\n           (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n               SN_on WPO_S {yi}) \\<and>\n           fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n                 (map ((!) xs) (\\<sigma> g)))}", "by auto"], ["proof (state)\nthis:\n  (S i, S (Suc i))\n  \\<in> {((f, ys), g, xs).\n         (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n             SN_on WPO_S {yi}) \\<and>\n         fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n               (map ((!) xs) (\\<sigma> g)))}\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Mul \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  (S ?i2, S (Suc ?i2))\n  \\<in> {((f, ys), g, xs).\n         (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n             SN_on WPO_S {yi}) \\<and>\n         fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n               (map ((!) xs) (\\<sigma> g)))}\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Mul \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (S ?i2, S (Suc ?i2))\n  \\<in> {((f, ys), g, xs).\n         (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n             SN_on WPO_S {yi}) \\<and>\n         fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n               (map ((!) xs) (\\<sigma> g)))}", "have Hf: \"\\<not> SN_on ?r' {S 0}\""], ["proof (prove)\nusing this:\n  (S ?i2, S (Suc ?i2))\n  \\<in> {((f, ys), g, xs).\n         (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n             SN_on WPO_S {yi}) \\<and>\n         fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n               (map ((!) xs) (\\<sigma> g)))}\n\ngoal (1 subgoal):\n 1. \\<not> SN_on\n            {((f, ys), g, xs).\n             (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n                 SN_on WPO_S {yi}) \\<and>\n             fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n                   (map ((!) xs) (\\<sigma> g)))}\n            {S 0}", "unfolding SN_on_def"], ["proof (prove)\nusing this:\n  (S ?i2, S (Suc ?i2))\n  \\<in> {((f, ys), g, xs).\n         (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n             \\<nexists>f.\n                f 0 \\<in> {yi} \\<and>\n                (\\<forall>i. (f i, f (Suc i)) \\<in> WPO_S)) \\<and>\n         fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n               (map ((!) xs) (\\<sigma> g)))}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<nexists>f.\n               f 0 \\<in> {S 0} \\<and>\n               (\\<forall>i.\n                   (f i, f (Suc i))\n                   \\<in> {((f, ys), g, xs).\n                          (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n                              \\<nexists>f.\n                                 f 0 \\<in> {yi} \\<and>\n                                 (\\<forall>i.\n                                     (f i, f (Suc i)) \\<in> WPO_S)) \\<and>\n                          fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n                                (map ((!) xs) (\\<sigma> g)))}))", "by auto"], ["proof (state)\nthis:\n  \\<not> SN_on\n          {((f, ys), g, xs).\n           (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n               SN_on WPO_S {yi}) \\<and>\n           fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n                 (map ((!) xs) (\\<sigma> g)))}\n          {S 0}\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Mul \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "from mul_ext_SN[of wpo, rule_format, OF wpo_ns_refl]\n              and wpo_compat wpo_s_imp_ns"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y z.\n              \\<lbrakk>x \\<succ> y; y \\<succeq> z\\<rbrakk>\n              \\<Longrightarrow> x \\<succ> z;\n   \\<And>x y z.\n      \\<lbrakk>x \\<succeq> y; y \\<succ> z\\<rbrakk>\n      \\<Longrightarrow> x \\<succ> z;\n   \\<And>x y z.\n      \\<lbrakk>x \\<succeq> y; y \\<succeq> z\\<rbrakk>\n      \\<Longrightarrow> x \\<succeq> z;\n   \\<And>x y z.\n      \\<lbrakk>x \\<succ> y; y \\<succ> z\\<rbrakk>\n      \\<Longrightarrow> x \\<succ> z\\<rbrakk>\n  \\<Longrightarrow> SN {(ys, xs).\n                        (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n                        fst (mul_ext wpo ys xs)}\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t", "have tmp: \"SN {(ys, xs). (\\<forall>y\\<in>set ys. SN_on {(s, t). wpo_s s t} {y}) \\<and> fst (mul_ext wpo ys xs)}\" \n              (is \"SN ?R\")"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y z.\n              \\<lbrakk>x \\<succ> y; y \\<succeq> z\\<rbrakk>\n              \\<Longrightarrow> x \\<succ> z;\n   \\<And>x y z.\n      \\<lbrakk>x \\<succeq> y; y \\<succ> z\\<rbrakk>\n      \\<Longrightarrow> x \\<succ> z;\n   \\<And>x y z.\n      \\<lbrakk>x \\<succeq> y; y \\<succeq> z\\<rbrakk>\n      \\<Longrightarrow> x \\<succeq> z;\n   \\<And>x y z.\n      \\<lbrakk>x \\<succ> y; y \\<succ> z\\<rbrakk>\n      \\<Longrightarrow> x \\<succ> z\\<rbrakk>\n  \\<Longrightarrow> SN {(ys, xs).\n                        (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n                        fst (mul_ext wpo ys xs)}\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n\ngoal (1 subgoal):\n 1. SN {(ys, xs).\n        (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n        fst (mul_ext wpo ys xs)}", "by blast"], ["proof (state)\nthis:\n  SN {(ys, xs).\n      (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n      fst (mul_ext wpo ys xs)}\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Mul \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "have id: \"?r' = inv_image ?R (\\<lambda> (f,ys). map ((!) ys) (\\<sigma> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {((f, ys), g, xs).\n     (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n         SN_on WPO_S {yi}) \\<and>\n     fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n           (map ((!) xs) (\\<sigma> g)))} =\n    inv_image\n     {(ys, xs).\n      (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n      fst (mul_ext wpo ys xs)}\n     (\\<lambda>(f, ys). map ((!) ys) (\\<sigma> f))", "by auto"], ["proof (state)\nthis:\n  {((f, ys), g, xs).\n   (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n       SN_on WPO_S {yi}) \\<and>\n   fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n         (map ((!) xs) (\\<sigma> g)))} =\n  inv_image\n   {(ys, xs).\n    (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and> fst (mul_ext wpo ys xs)}\n   (\\<lambda>(f, ys). map ((!) ys) (\\<sigma> f))\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Mul \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "from SN_inv_image[OF tmp]"], ["proof (chain)\npicking this:\n  SN (inv_image\n       {(ys, xs).\n        (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n        fst (mul_ext wpo ys xs)}\n       ?f)", "have \"SN ?r'\""], ["proof (prove)\nusing this:\n  SN (inv_image\n       {(ys, xs).\n        (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n        fst (mul_ext wpo ys xs)}\n       ?f)\n\ngoal (1 subgoal):\n 1. SN {((f, ys), g, xs).\n        (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n            SN_on WPO_S {yi}) \\<and>\n        fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n              (map ((!) xs) (\\<sigma> g)))}", "unfolding id"], ["proof (prove)\nusing this:\n  SN (inv_image\n       {(ys, xs).\n        (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n        fst (mul_ext wpo ys xs)}\n       ?f)\n\ngoal (1 subgoal):\n 1. SN (inv_image\n         {(ys, xs).\n          (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n          fst (mul_ext wpo ys xs)}\n         (\\<lambda>(f, ys). map ((!) ys) (\\<sigma> f)))", "."], ["proof (state)\nthis:\n  SN {((f, ys), g, xs).\n      (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n          SN_on WPO_S {yi}) \\<and>\n      fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n            (map ((!) xs) (\\<sigma> g)))}\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Mul \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "from SN_on_subset2[OF subset_UNIV[of \"{S 0}\"], OF this]"], ["proof (chain)\npicking this:\n  SN_on\n   {((f, ys), g, xs).\n    (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n        SN_on WPO_S {yi}) \\<and>\n    fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n          (map ((!) xs) (\\<sigma> g)))}\n   {S 0}", "have \"SN_on ?r' {(S 0)}\""], ["proof (prove)\nusing this:\n  SN_on\n   {((f, ys), g, xs).\n    (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n        SN_on WPO_S {yi}) \\<and>\n    fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n          (map ((!) xs) (\\<sigma> g)))}\n   {S 0}\n\ngoal (1 subgoal):\n 1. SN_on\n     {((f, ys), g, xs).\n      (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n          SN_on WPO_S {yi}) \\<and>\n      fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n            (map ((!) xs) (\\<sigma> g)))}\n     {S 0}", "."], ["proof (state)\nthis:\n  SN_on\n   {((f, ys), g, xs).\n    (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n        SN_on WPO_S {yi}) \\<and>\n    fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n          (map ((!) xs) (\\<sigma> g)))}\n   {S 0}\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Mul \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "with Hf"], ["proof (chain)\npicking this:\n  \\<not> SN_on\n          {((f, ys), g, xs).\n           (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n               SN_on WPO_S {yi}) \\<and>\n           fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n                 (map ((!) xs) (\\<sigma> g)))}\n          {S 0}\n  SN_on\n   {((f, ys), g, xs).\n    (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n        SN_on WPO_S {yi}) \\<and>\n    fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n          (map ((!) xs) (\\<sigma> g)))}\n   {S 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> SN_on\n          {((f, ys), g, xs).\n           (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n               SN_on WPO_S {yi}) \\<and>\n           fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n                 (map ((!) xs) (\\<sigma> g)))}\n          {S 0}\n  SN_on\n   {((f, ys), g, xs).\n    (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n        SN_on WPO_S {yi}) \\<and>\n    fst (mul_ext wpo (map ((!) ys) (\\<sigma> f))\n          (map ((!) xs) (\\<sigma> g)))}\n   {S 0}\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i. c (fst (S i)) = Mul)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "note HMul = this"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i. c (fst (S i)) = Mul)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. c (fst (S i)) = Mul) \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"\\<forall>i. c (?Sfn i) = Lex\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  \\<forall>i. c (fst (S i)) = Lex\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "let ?r' = \"{((f,ys), (g,xs)).\n                (\\<forall> yi \\<in>set ((map ((!) ys) (\\<sigma> f))). SN_on WPO_S {yi})\n                \\<and> fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f)) (map ((!) xs) (\\<sigma> g)))}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "from SS[rule_format, of i] True[rule_format, of i] True[rule_format, of \"Suc i\"]"], ["proof (chain)\npicking this:\n  (S i, S (Suc i))\n  \\<in> {((f, ab), g, ab').\n         (c f = c g \\<longrightarrow>\n          (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n          (c f = Mul \\<longrightarrow>\n           fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g)))) \\<and>\n          (c f = Lex \\<longrightarrow>\n           fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g))))) \\<and>\n         (c f \\<noteq> c g \\<longrightarrow>\n          map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n          map ((!) ab') (\\<sigma> g) = [])}\n  c (fst (S i)) = Lex\n  c (fst (S (Suc i))) = Lex", "have \"(S i, S (Suc i)) \\<in> ?r'\""], ["proof (prove)\nusing this:\n  (S i, S (Suc i))\n  \\<in> {((f, ab), g, ab').\n         (c f = c g \\<longrightarrow>\n          (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n          (c f = Mul \\<longrightarrow>\n           fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g)))) \\<and>\n          (c f = Lex \\<longrightarrow>\n           fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g))))) \\<and>\n         (c f \\<noteq> c g \\<longrightarrow>\n          map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n          map ((!) ab') (\\<sigma> g) = [])}\n  c (fst (S i)) = Lex\n  c (fst (S (Suc i))) = Lex\n\ngoal (1 subgoal):\n 1. (S i, S (Suc i))\n    \\<in> {((f, ys), g, xs).\n           (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n               SN_on WPO_S {yi}) \\<and>\n           fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n                 (map ((!) xs) (\\<sigma> g)))}", "by auto"], ["proof (state)\nthis:\n  (S i, S (Suc i))\n  \\<in> {((f, ys), g, xs).\n         (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n             SN_on WPO_S {yi}) \\<and>\n         fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n               (map ((!) xs) (\\<sigma> g)))}\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  (S ?i2, S (Suc ?i2))\n  \\<in> {((f, ys), g, xs).\n         (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n             SN_on WPO_S {yi}) \\<and>\n         fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n               (map ((!) xs) (\\<sigma> g)))}\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (S ?i2, S (Suc ?i2))\n  \\<in> {((f, ys), g, xs).\n         (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n             SN_on WPO_S {yi}) \\<and>\n         fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n               (map ((!) xs) (\\<sigma> g)))}", "have Hf: \"\\<not> SN_on ?r' {S 0}\""], ["proof (prove)\nusing this:\n  (S ?i2, S (Suc ?i2))\n  \\<in> {((f, ys), g, xs).\n         (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n             SN_on WPO_S {yi}) \\<and>\n         fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n               (map ((!) xs) (\\<sigma> g)))}\n\ngoal (1 subgoal):\n 1. \\<not> SN_on\n            {((f, ys), g, xs).\n             (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n                 SN_on WPO_S {yi}) \\<and>\n             fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n                   (map ((!) xs) (\\<sigma> g)))}\n            {S 0}", "unfolding SN_on_def"], ["proof (prove)\nusing this:\n  (S ?i2, S (Suc ?i2))\n  \\<in> {((f, ys), g, xs).\n         (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n             \\<nexists>f.\n                f 0 \\<in> {yi} \\<and>\n                (\\<forall>i. (f i, f (Suc i)) \\<in> WPO_S)) \\<and>\n         fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n               (map ((!) xs) (\\<sigma> g)))}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<nexists>f.\n               f 0 \\<in> {S 0} \\<and>\n               (\\<forall>i.\n                   (f i, f (Suc i))\n                   \\<in> {((f, ys), g, xs).\n                          (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n                              \\<nexists>f.\n                                 f 0 \\<in> {yi} \\<and>\n                                 (\\<forall>i.\n                                     (f i, f (Suc i)) \\<in> WPO_S)) \\<and>\n                          fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n                                (map ((!) xs) (\\<sigma> g)))}))", "by auto"], ["proof (state)\nthis:\n  \\<not> SN_on\n          {((f, ys), g, xs).\n           (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n               SN_on WPO_S {yi}) \\<and>\n           fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n                 (map ((!) xs) (\\<sigma> g)))}\n          {S 0}\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "from wpo_compat"], ["proof (chain)\npicking this:\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)", "have \"\\<And> x y z. wpo_ns x y \\<Longrightarrow> wpo_s y z \\<Longrightarrow> wpo_s x z\""], ["proof (prove)\nusing this:\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<succeq> y; y \\<succ> z\\<rbrakk>\n       \\<Longrightarrow> x \\<succ> z", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<succeq> ?y; ?y \\<succ> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<succ> ?z\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "from lex_ext_SN[of \"wpo\" n, OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y z.\n              \\<lbrakk>x \\<succeq> y; y \\<succ> z\\<rbrakk>\n              \\<Longrightarrow> x \\<succeq> ?y x y z;\n   \\<And>x y z.\n      \\<lbrakk>x \\<succeq> y; y \\<succ> z\\<rbrakk>\n      \\<Longrightarrow> ?y x y z \\<succ> z\\<rbrakk>\n  \\<Longrightarrow> SN {(ys, xs).\n                        (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n                        fst (lex_ext wpo n ys xs)}", "have tmp: \"SN {(ys, xs). (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and> fst (lex_ext wpo n ys xs)}\" \n                (is \"SN ?R\")"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y z.\n              \\<lbrakk>x \\<succeq> y; y \\<succ> z\\<rbrakk>\n              \\<Longrightarrow> x \\<succeq> ?y x y z;\n   \\<And>x y z.\n      \\<lbrakk>x \\<succeq> y; y \\<succ> z\\<rbrakk>\n      \\<Longrightarrow> ?y x y z \\<succ> z\\<rbrakk>\n  \\<Longrightarrow> SN {(ys, xs).\n                        (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n                        fst (lex_ext wpo n ys xs)}\n\ngoal (1 subgoal):\n 1. SN {(ys, xs).\n        (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n        fst (lex_ext wpo n ys xs)}", "."], ["proof (state)\nthis:\n  SN {(ys, xs).\n      (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n      fst (lex_ext wpo n ys xs)}\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "have id: \"?r' = inv_image ?R (\\<lambda> (f,ys). map ((!) ys) (\\<sigma> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {((f, ys), g, xs).\n     (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n         SN_on WPO_S {yi}) \\<and>\n     fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n           (map ((!) xs) (\\<sigma> g)))} =\n    inv_image\n     {(ys, xs).\n      (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n      fst (lex_ext wpo n ys xs)}\n     (\\<lambda>(f, ys). map ((!) ys) (\\<sigma> f))", "by auto"], ["proof (state)\nthis:\n  {((f, ys), g, xs).\n   (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n       SN_on WPO_S {yi}) \\<and>\n   fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n         (map ((!) xs) (\\<sigma> g)))} =\n  inv_image\n   {(ys, xs).\n    (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n    fst (lex_ext wpo n ys xs)}\n   (\\<lambda>(f, ys). map ((!) ys) (\\<sigma> f))\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "from SN_inv_image[OF tmp]"], ["proof (chain)\npicking this:\n  SN (inv_image\n       {(ys, xs).\n        (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n        fst (lex_ext wpo n ys xs)}\n       ?f)", "have \"SN ?r'\""], ["proof (prove)\nusing this:\n  SN (inv_image\n       {(ys, xs).\n        (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n        fst (lex_ext wpo n ys xs)}\n       ?f)\n\ngoal (1 subgoal):\n 1. SN {((f, ys), g, xs).\n        (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n            SN_on WPO_S {yi}) \\<and>\n        fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n              (map ((!) xs) (\\<sigma> g)))}", "unfolding id"], ["proof (prove)\nusing this:\n  SN (inv_image\n       {(ys, xs).\n        (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n        fst (lex_ext wpo n ys xs)}\n       ?f)\n\ngoal (1 subgoal):\n 1. SN (inv_image\n         {(ys, xs).\n          (\\<forall>y\\<in>set ys. SN_on WPO_S {y}) \\<and>\n          fst (lex_ext wpo n ys xs)}\n         (\\<lambda>(f, ys). map ((!) ys) (\\<sigma> f)))", "."], ["proof (state)\nthis:\n  SN {((f, ys), g, xs).\n      (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n          SN_on WPO_S {yi}) \\<and>\n      fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n            (map ((!) xs) (\\<sigma> g)))}\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  SN {((f, ys), g, xs).\n      (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n          SN_on WPO_S {yi}) \\<and>\n      fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n            (map ((!) xs) (\\<sigma> g)))}", "have \"SN_on ?r' {(S 0)}\""], ["proof (prove)\nusing this:\n  SN {((f, ys), g, xs).\n      (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n          SN_on WPO_S {yi}) \\<and>\n      fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n            (map ((!) xs) (\\<sigma> g)))}\n\ngoal (1 subgoal):\n 1. SN_on\n     {((f, ys), g, xs).\n      (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n          SN_on WPO_S {yi}) \\<and>\n      fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n            (map ((!) xs) (\\<sigma> g)))}\n     {S 0}", "unfolding SN_defs"], ["proof (prove)\nusing this:\n  \\<nexists>f.\n     f 0 \\<in> UNIV \\<and>\n     (\\<forall>i.\n         (f i, f (Suc i))\n         \\<in> {((f, ys), g, xs).\n                (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n                    \\<nexists>f.\n                       f 0 \\<in> {yi} \\<and>\n                       (\\<forall>i. (f i, f (Suc i)) \\<in> WPO_S)) \\<and>\n                fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n                      (map ((!) xs) (\\<sigma> g)))})\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       f 0 \\<in> {S 0} \\<and>\n       (\\<forall>i.\n           (f i, f (Suc i))\n           \\<in> {((f, ys), g, xs).\n                  (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n                      \\<nexists>f.\n                         f 0 \\<in> {yi} \\<and>\n                         (\\<forall>i. (f i, f (Suc i)) \\<in> WPO_S)) \\<and>\n                  fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n                        (map ((!) xs) (\\<sigma> g)))})", "by blast"], ["proof (state)\nthis:\n  SN_on\n   {((f, ys), g, xs).\n    (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n        SN_on WPO_S {yi}) \\<and>\n    fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n          (map ((!) xs) (\\<sigma> g)))}\n   {S 0}\n\ngoal (2 subgoals):\n 1. \\<forall>i. c (fst (S i)) = Lex \\<Longrightarrow> False\n 2. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "with Hf"], ["proof (chain)\npicking this:\n  \\<not> SN_on\n          {((f, ys), g, xs).\n           (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n               SN_on WPO_S {yi}) \\<and>\n           fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n                 (map ((!) xs) (\\<sigma> g)))}\n          {S 0}\n  SN_on\n   {((f, ys), g, xs).\n    (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n        SN_on WPO_S {yi}) \\<and>\n    fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n          (map ((!) xs) (\\<sigma> g)))}\n   {S 0}", "show False"], ["proof (prove)\nusing this:\n  \\<not> SN_on\n          {((f, ys), g, xs).\n           (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n               SN_on WPO_S {yi}) \\<and>\n           fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n                 (map ((!) xs) (\\<sigma> g)))}\n          {S 0}\n  SN_on\n   {((f, ys), g, xs).\n    (\\<forall>yi\\<in>set (map ((!) ys) (\\<sigma> f)).\n        SN_on WPO_S {yi}) \\<and>\n    fst (lex_ext wpo n (map ((!) ys) (\\<sigma> f))\n          (map ((!) xs) (\\<sigma> g)))}\n   {S 0}\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i. c (fst (S i)) = Lex)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "note HLex = this"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i. c (fst (S i)) = Lex)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "from HMul and HLex"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i. c (fst (S i)) = Mul)\n  \\<not> (\\<forall>i. c (fst (S i)) = Lex)", "have \"\\<exists>i. c (?Sfn i) \\<noteq> c (?Sfn (Suc i))\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i. c (fst (S i)) = Mul)\n  \\<not> (\\<forall>i. c (fst (S i)) = Lex)\n\ngoal (1 subgoal):\n 1. \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "proof (cases ?thesis, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>i. c (fst (S i)) = Mul);\n     \\<not> (\\<forall>i. c (fst (S i)) = Lex);\n     \\<nexists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "case False"], ["proof (state)\nthis:\n  \\<nexists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>i. c (fst (S i)) = Mul);\n     \\<not> (\\<forall>i. c (fst (S i)) = Lex);\n     \\<nexists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "then"], ["proof (chain)\npicking this:\n  \\<nexists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "have T: \"\\<forall>i. c (?Sfn i) = c (?Sfn (Suc i))\""], ["proof (prove)\nusing this:\n  \\<nexists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<forall>i. c (fst (S i)) = c (fst (S (Suc i)))", "by simp"], ["proof (state)\nthis:\n  \\<forall>i. c (fst (S i)) = c (fst (S (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>i. c (fst (S i)) = Mul);\n     \\<not> (\\<forall>i. c (fst (S i)) = Lex);\n     \\<nexists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "{"], ["proof (state)\nthis:\n  \\<forall>i. c (fst (S i)) = c (fst (S (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>i. c (fst (S i)) = Mul);\n     \\<not> (\\<forall>i. c (fst (S i)) = Lex);\n     \\<nexists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>i. c (fst (S i)) = Mul);\n     \\<not> (\\<forall>i. c (fst (S i)) = Lex);\n     \\<nexists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "have \"c (?Sfn i) = c (?Sfn 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c (fst (S i)) = c (fst (S 0))", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. c (fst (S 0)) = c (fst (S 0))\n 2. \\<And>i.\n       c (fst (S i)) = c (fst (S 0)) \\<Longrightarrow>\n       c (fst (S (Suc i))) = c (fst (S 0))", "case (Suc j)"], ["proof (state)\nthis:\n  c (fst (S j)) = c (fst (S 0))\n\ngoal (2 subgoals):\n 1. c (fst (S 0)) = c (fst (S 0))\n 2. \\<And>i.\n       c (fst (S i)) = c (fst (S 0)) \\<Longrightarrow>\n       c (fst (S (Suc i))) = c (fst (S 0))", "then"], ["proof (chain)\npicking this:\n  c (fst (S j)) = c (fst (S 0))", "show ?case"], ["proof (prove)\nusing this:\n  c (fst (S j)) = c (fst (S 0))\n\ngoal (1 subgoal):\n 1. c (fst (S (Suc j))) = c (fst (S 0))", "by (simp add: T[rule_format, of j])"], ["proof (state)\nthis:\n  c (fst (S (Suc j))) = c (fst (S 0))\n\ngoal (1 subgoal):\n 1. c (fst (S 0)) = c (fst (S 0))", "qed simp"], ["proof (state)\nthis:\n  c (fst (S i)) = c (fst (S 0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>i. c (fst (S i)) = Mul);\n     \\<not> (\\<forall>i. c (fst (S i)) = Lex);\n     \\<nexists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "}"], ["proof (state)\nthis:\n  c (fst (S ?i2)) = c (fst (S 0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (\\<forall>i. c (fst (S i)) = Mul);\n     \\<not> (\\<forall>i. c (fst (S i)) = Lex);\n     \\<nexists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "then"], ["proof (chain)\npicking this:\n  c (fst (S ?i2)) = c (fst (S 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  c (fst (S ?i2)) = c (fst (S 0))\n\ngoal (1 subgoal):\n 1. \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "using HMul HLex"], ["proof (prove)\nusing this:\n  c (fst (S ?i2)) = c (fst (S 0))\n  \\<not> (\\<forall>i. c (fst (S i)) = Mul)\n  \\<not> (\\<forall>i. c (fst (S i)) = Lex)\n\ngoal (1 subgoal):\n 1. \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "by (cases \"c (?Sfn 0)\") auto"], ["proof (state)\nthis:\n  \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "obtain i where\n                Hdiff: \"c (?Sfn i) \\<noteq> c (?Sfn (Suc i))\""], ["proof (prove)\nusing this:\n  \\<exists>i. c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        c (fst (S i)) \\<noteq> c (fst (S (Suc i))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "from Hdiff"], ["proof (chain)\npicking this:\n  c (fst (S i)) \\<noteq> c (fst (S (Suc i)))", "have Hf: \"?Sts\\<sigma> (Suc i) = []\""], ["proof (prove)\nusing this:\n  c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\n\ngoal (1 subgoal):\n 1. map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))) = []", "using SS[rule_format, of i]"], ["proof (prove)\nusing this:\n  c (fst (S i)) \\<noteq> c (fst (S (Suc i)))\n  (S i, S (Suc i))\n  \\<in> {((f, ab), g, ab').\n         (c f = c g \\<longrightarrow>\n          (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n          (c f = Mul \\<longrightarrow>\n           fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g)))) \\<and>\n          (c f = Lex \\<longrightarrow>\n           fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g))))) \\<and>\n         (c f \\<noteq> c g \\<longrightarrow>\n          map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n          map ((!) ab') (\\<sigma> g) = [])}\n\ngoal (1 subgoal):\n 1. map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))) = []", "by auto"], ["proof (state)\nthis:\n  map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))) = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. c (fst (S i)) = Lex) \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"c (?Sfn (Suc i)) = c (?Sfn (Suc (Suc i)))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (fst (S (Suc i))) = c (fst (S (Suc (Suc i)))) \\<Longrightarrow> False\n 2. c (fst (S (Suc i))) \\<noteq> c (fst (S (Suc (Suc i)))) \\<Longrightarrow>\n    False", "case False"], ["proof (state)\nthis:\n  c (fst (S (Suc i))) \\<noteq> c (fst (S (Suc (Suc i))))\n\ngoal (2 subgoals):\n 1. c (fst (S (Suc i))) = c (fst (S (Suc (Suc i)))) \\<Longrightarrow> False\n 2. c (fst (S (Suc i))) \\<noteq> c (fst (S (Suc (Suc i)))) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  c (fst (S (Suc i))) \\<noteq> c (fst (S (Suc (Suc i))))", "show ?thesis"], ["proof (prove)\nusing this:\n  c (fst (S (Suc i))) \\<noteq> c (fst (S (Suc (Suc i))))\n\ngoal (1 subgoal):\n 1. False", "using Hf and SS[rule_format, of \"Suc i\"]"], ["proof (prove)\nusing this:\n  c (fst (S (Suc i))) \\<noteq> c (fst (S (Suc (Suc i))))\n  map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))) = []\n  (S (Suc i), S (Suc (Suc i)))\n  \\<in> {((f, ab), g, ab').\n         (c f = c g \\<longrightarrow>\n          (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n          (c f = Mul \\<longrightarrow>\n           fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g)))) \\<and>\n          (c f = Lex \\<longrightarrow>\n           fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g))))) \\<and>\n         (c f \\<noteq> c g \\<longrightarrow>\n          map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n          map ((!) ab') (\\<sigma> g) = [])}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. c (fst (S (Suc i))) = c (fst (S (Suc (Suc i)))) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (fst (S (Suc i))) = c (fst (S (Suc (Suc i)))) \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  c (fst (S (Suc i))) = c (fst (S (Suc (Suc i))))\n\ngoal (1 subgoal):\n 1. c (fst (S (Suc i))) = c (fst (S (Suc (Suc i)))) \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"c (?Sfn (Suc i))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c (fst (S (Suc i))) = Lex \\<Longrightarrow> False\n 2. c (fst (S (Suc i))) = Mul \\<Longrightarrow> False", "case Mul"], ["proof (state)\nthis:\n  c (fst (S (Suc i))) = Mul\n\ngoal (2 subgoals):\n 1. c (fst (S (Suc i))) = Lex \\<Longrightarrow> False\n 2. c (fst (S (Suc i))) = Mul \\<Longrightarrow> False", "with True and SS[rule_format, of \"Suc i\"]"], ["proof (chain)\npicking this:\n  c (fst (S (Suc i))) = c (fst (S (Suc (Suc i))))\n  (S (Suc i), S (Suc (Suc i)))\n  \\<in> {((f, ab), g, ab').\n         (c f = c g \\<longrightarrow>\n          (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n          (c f = Mul \\<longrightarrow>\n           fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g)))) \\<and>\n          (c f = Lex \\<longrightarrow>\n           fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g))))) \\<and>\n         (c f \\<noteq> c g \\<longrightarrow>\n          map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n          map ((!) ab') (\\<sigma> g) = [])}\n  c (fst (S (Suc i))) = Mul", "have \"fst (mul_ext wpo (?Sts\\<sigma> (Suc i)) (?Sts\\<sigma> (Suc (Suc i))))\""], ["proof (prove)\nusing this:\n  c (fst (S (Suc i))) = c (fst (S (Suc (Suc i))))\n  (S (Suc i), S (Suc (Suc i)))\n  \\<in> {((f, ab), g, ab').\n         (c f = c g \\<longrightarrow>\n          (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n          (c f = Mul \\<longrightarrow>\n           fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g)))) \\<and>\n          (c f = Lex \\<longrightarrow>\n           fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g))))) \\<and>\n         (c f \\<noteq> c g \\<longrightarrow>\n          map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n          map ((!) ab') (\\<sigma> g) = [])}\n  c (fst (S (Suc i))) = Mul\n\ngoal (1 subgoal):\n 1. fst (mul_ext wpo\n          (map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))))\n          (map ((!) (snd (S (Suc (Suc i)))))\n            (\\<sigma> (fst (S (Suc (Suc i)))))))", "by auto"], ["proof (state)\nthis:\n  fst (mul_ext wpo\n        (map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))))\n        (map ((!) (snd (S (Suc (Suc i)))))\n          (\\<sigma> (fst (S (Suc (Suc i)))))))\n\ngoal (2 subgoals):\n 1. c (fst (S (Suc i))) = Lex \\<Longrightarrow> False\n 2. c (fst (S (Suc i))) = Mul \\<Longrightarrow> False", "with Hf and s_mul_ext_bottom_strict"], ["proof (chain)\npicking this:\n  map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))) = []\n  ({#}, ?A) \\<notin> s_mul_ext ?ns ?s\n  fst (mul_ext wpo\n        (map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))))\n        (map ((!) (snd (S (Suc (Suc i)))))\n          (\\<sigma> (fst (S (Suc (Suc i)))))))", "show ?thesis"], ["proof (prove)\nusing this:\n  map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))) = []\n  ({#}, ?A) \\<notin> s_mul_ext ?ns ?s\n  fst (mul_ext wpo\n        (map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))))\n        (map ((!) (snd (S (Suc (Suc i)))))\n          (\\<sigma> (fst (S (Suc (Suc i)))))))\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Let_def mul_ext_def s_mul_ext_bottom_strict)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. c (fst (S (Suc i))) = Lex \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c (fst (S (Suc i))) = Lex \\<Longrightarrow> False", "case Lex"], ["proof (state)\nthis:\n  c (fst (S (Suc i))) = Lex\n\ngoal (1 subgoal):\n 1. c (fst (S (Suc i))) = Lex \\<Longrightarrow> False", "with True and SS[rule_format, of \"Suc i\"]"], ["proof (chain)\npicking this:\n  c (fst (S (Suc i))) = c (fst (S (Suc (Suc i))))\n  (S (Suc i), S (Suc (Suc i)))\n  \\<in> {((f, ab), g, ab').\n         (c f = c g \\<longrightarrow>\n          (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n          (c f = Mul \\<longrightarrow>\n           fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g)))) \\<and>\n          (c f = Lex \\<longrightarrow>\n           fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g))))) \\<and>\n         (c f \\<noteq> c g \\<longrightarrow>\n          map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n          map ((!) ab') (\\<sigma> g) = [])}\n  c (fst (S (Suc i))) = Lex", "have \"fst (lex_ext wpo n (?Sts\\<sigma> (Suc i)) (?Sts\\<sigma> (Suc (Suc i))))\""], ["proof (prove)\nusing this:\n  c (fst (S (Suc i))) = c (fst (S (Suc (Suc i))))\n  (S (Suc i), S (Suc (Suc i)))\n  \\<in> {((f, ab), g, ab').\n         (c f = c g \\<longrightarrow>\n          (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n          (c f = Mul \\<longrightarrow>\n           fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g)))) \\<and>\n          (c f = Lex \\<longrightarrow>\n           fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                 (map ((!) ab') (\\<sigma> g))))) \\<and>\n         (c f \\<noteq> c g \\<longrightarrow>\n          map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n          map ((!) ab') (\\<sigma> g) = [])}\n  c (fst (S (Suc i))) = Lex\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n\n          (map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))))\n          (map ((!) (snd (S (Suc (Suc i)))))\n            (\\<sigma> (fst (S (Suc (Suc i)))))))", "by auto"], ["proof (state)\nthis:\n  fst (lex_ext wpo n\n        (map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))))\n        (map ((!) (snd (S (Suc (Suc i)))))\n          (\\<sigma> (fst (S (Suc (Suc i)))))))\n\ngoal (1 subgoal):\n 1. c (fst (S (Suc i))) = Lex \\<Longrightarrow> False", "with Hf"], ["proof (chain)\npicking this:\n  map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))) = []\n  fst (lex_ext wpo n\n        (map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))))\n        (map ((!) (snd (S (Suc (Suc i)))))\n          (\\<sigma> (fst (S (Suc (Suc i)))))))", "show ?thesis"], ["proof (prove)\nusing this:\n  map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))) = []\n  fst (lex_ext wpo n\n        (map ((!) (snd (S (Suc i)))) (\\<sigma> (fst (S (Suc i)))))\n        (map ((!) (snd (S (Suc (Suc i)))))\n          (\\<sigma> (fst (S (Suc (Suc i)))))))\n\ngoal (1 subgoal):\n 1. False", "by (simp add: lex_ext_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "}"], ["proof (state)\nthis:\n  \\<exists>S.\n     S 0 = ab \\<and>\n     (\\<forall>i.\n         (S i, S (Suc i))\n         \\<in> {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])}) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "}"], ["proof (state)\nthis:\n  \\<exists>S.\n     S 0 = ?ab2 \\<and>\n     (\\<forall>i.\n         (S i, S (Suc i))\n         \\<in> {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])}) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "then"], ["proof (chain)\npicking this:\n  \\<exists>S.\n     S 0 = ?ab2 \\<and>\n     (\\<forall>i.\n         (S i, S (Suc i))\n         \\<in> {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])}) \\<Longrightarrow>\n  False", "have \"SN ?r3\""], ["proof (prove)\nusing this:\n  \\<exists>S.\n     S 0 = ?ab2 \\<and>\n     (\\<forall>i.\n         (S i, S (Suc i))\n         \\<in> {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])}) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. SN {((f, ab), g, ab').\n        (c f = c g \\<longrightarrow>\n         (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n         (c f = Mul \\<longrightarrow>\n          fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                (map ((!) ab') (\\<sigma> g)))) \\<and>\n         (c f = Lex \\<longrightarrow>\n          fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                (map ((!) ab') (\\<sigma> g))))) \\<and>\n        (c f \\<noteq> c g \\<longrightarrow>\n         map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n         map ((!) ab') (\\<sigma> g) = [])}", "unfolding SN_on_def"], ["proof (prove)\nusing this:\n  \\<exists>S.\n     S 0 = ?ab2 \\<and>\n     (\\<forall>i.\n         (S i, S (Suc i))\n         \\<in> {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     \\<nexists>f.\n                        f 0 \\<in> {ab ! i} \\<and>\n                        (\\<forall>i. (f i, f (Suc i)) \\<in> WPO_S)) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])}) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       f 0 \\<in> UNIV \\<and>\n       (\\<forall>i.\n           (f i, f (Suc i))\n           \\<in> {((f, ab), g, ab').\n                  (c f = c g \\<longrightarrow>\n                   (\\<forall>i\\<in>set (\\<sigma> f).\n                       \\<nexists>f.\n                          f 0 \\<in> {ab ! i} \\<and>\n                          (\\<forall>i. (f i, f (Suc i)) \\<in> WPO_S)) \\<and>\n                   (c f = Mul \\<longrightarrow>\n                    fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                          (map ((!) ab') (\\<sigma> g)))) \\<and>\n                   (c f = Lex \\<longrightarrow>\n                    fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                          (map ((!) ab') (\\<sigma> g))))) \\<and>\n                  (c f \\<noteq> c g \\<longrightarrow>\n                   map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                   map ((!) ab') (\\<sigma> g) = [])})", "by blast"], ["proof (state)\nthis:\n  SN {((f, ab), g, ab').\n      (c f = c g \\<longrightarrow>\n       (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n       (c f = Mul \\<longrightarrow>\n        fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n              (map ((!) ab') (\\<sigma> g)))) \\<and>\n       (c f = Lex \\<longrightarrow>\n        fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n              (map ((!) ab') (\\<sigma> g))))) \\<and>\n      (c f \\<noteq> c g \\<longrightarrow>\n       map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n       map ((!) ab') (\\<sigma> g) = [])}\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "have SN1:\"SN ?r0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN (lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n         {((f, ab), g, ab').\n          (c f = c g \\<longrightarrow>\n           (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n           (c f = Mul \\<longrightarrow>\n            fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                  (map ((!) ab') (\\<sigma> g)))) \\<and>\n           (c f = Lex \\<longrightarrow>\n            fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                  (map ((!) ab') (\\<sigma> g))))) \\<and>\n          (c f \\<noteq> c g \\<longrightarrow>\n           map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n           map ((!) ab') (\\<sigma> g) = [])})", "proof (rule lex_two[OF _ prc_SN \\<open>SN ?r3\\<close>])"], ["proof (state)\ngoal (1 subgoal):\n 1. {(f, g). snd (prc f g)} O {(f, g). fst (prc f g)}\n    \\<subseteq> {(f, g). fst (prc f g)}", "let ?r' = \"{(f,g). fst (prc f g)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(f, g). snd (prc f g)} O {(f, g). fst (prc f g)}\n    \\<subseteq> {(f, g). fst (prc f g)}", "let ?r = \"{(f,g). snd (prc f g)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. {(f, g). snd (prc f g)} O {(f, g). fst (prc f g)}\n    \\<subseteq> {(f, g). fst (prc f g)}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {(f, g). snd (prc f g)} O {(f, g). fst (prc f g)}\n    \\<subseteq> {(f, g). fst (prc f g)}", "fix a1 a2 a3"], ["proof (state)\ngoal (1 subgoal):\n 1. {(f, g). snd (prc f g)} O {(f, g). fst (prc f g)}\n    \\<subseteq> {(f, g). fst (prc f g)}", "assume \"(a1,a2) \\<in> ?r\" \"(a2,a3) \\<in> ?r'\""], ["proof (state)\nthis:\n  (a1, a2) \\<in> {(f, g). snd (prc f g)}\n  (a2, a3) \\<in> {(f, g). fst (prc f g)}\n\ngoal (1 subgoal):\n 1. {(f, g). snd (prc f g)} O {(f, g). fst (prc f g)}\n    \\<subseteq> {(f, g). fst (prc f g)}", "then"], ["proof (chain)\npicking this:\n  (a1, a2) \\<in> {(f, g). snd (prc f g)}\n  (a2, a3) \\<in> {(f, g). fst (prc f g)}", "have \"(a1,a3) \\<in> ?r'\""], ["proof (prove)\nusing this:\n  (a1, a2) \\<in> {(f, g). snd (prc f g)}\n  (a2, a3) \\<in> {(f, g). fst (prc f g)}\n\ngoal (1 subgoal):\n 1. (a1, a3) \\<in> {(f, g). fst (prc f g)}", "by (cases \"prc a1 a2\", cases \"prc a2 a3\", cases \"prc a1 a3\", \n                insert prc_compat[of a1 a2 _ _ a3], force)"], ["proof (state)\nthis:\n  (a1, a3) \\<in> {(f, g). fst (prc f g)}\n\ngoal (1 subgoal):\n 1. {(f, g). snd (prc f g)} O {(f, g). fst (prc f g)}\n    \\<subseteq> {(f, g). fst (prc f g)}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a1.2, ?a2.2) \\<in> {(f, g). snd (prc f g)};\n   (?a2.2, ?a3.2) \\<in> {(f, g). fst (prc f g)}\\<rbrakk>\n  \\<Longrightarrow> (?a1.2, ?a3.2) \\<in> {(f, g). fst (prc f g)}\n\ngoal (1 subgoal):\n 1. {(f, g). snd (prc f g)} O {(f, g). fst (prc f g)}\n    \\<subseteq> {(f, g). fst (prc f g)}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?a1.2, ?a2.2) \\<in> {(f, g). snd (prc f g)};\n   (?a2.2, ?a3.2) \\<in> {(f, g). fst (prc f g)}\\<rbrakk>\n  \\<Longrightarrow> (?a1.2, ?a3.2) \\<in> {(f, g). fst (prc f g)}", "show \"?r O ?r' \\<subseteq> ?r'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a1.2, ?a2.2) \\<in> {(f, g). snd (prc f g)};\n   (?a2.2, ?a3.2) \\<in> {(f, g). fst (prc f g)}\\<rbrakk>\n  \\<Longrightarrow> (?a1.2, ?a3.2) \\<in> {(f, g). fst (prc f g)}\n\ngoal (1 subgoal):\n 1. {(f, g). snd (prc f g)} O {(f, g). fst (prc f g)}\n    \\<subseteq> {(f, g). fst (prc f g)}", "by auto"], ["proof (state)\nthis:\n  {(f, g). snd (prc f g)} O {(f, g). fst (prc f g)}\n  \\<subseteq> {(f, g). fst (prc f g)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SN (lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n       {((f, ab), g, ab').\n        (c f = c g \\<longrightarrow>\n         (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n         (c f = Mul \\<longrightarrow>\n          fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                (map ((!) ab') (\\<sigma> g)))) \\<and>\n         (c f = Lex \\<longrightarrow>\n          fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                (map ((!) ab') (\\<sigma> g))))) \\<and>\n        (c f \\<noteq> c g \\<longrightarrow>\n         map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n         map ((!) ab') (\\<sigma> g) = [])})\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?m = \"\\<lambda> (f,ts). ((f,length ts), ((f, length ts), ts))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?r = \"{(a,b). (?m a, ?m b) \\<in> ?r0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "have SN_r: \"SN ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN {(a, b).\n        (case a of\n         (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n         case b of\n         (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n        \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n               {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])}}", "using SN_inv_image[OF SN1, of ?m]"], ["proof (prove)\nusing this:\n  SN (inv_image\n       (lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n         {((f, ab), g, ab').\n          (c f = c g \\<longrightarrow>\n           (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n           (c f = Mul \\<longrightarrow>\n            fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                  (map ((!) ab') (\\<sigma> g)))) \\<and>\n           (c f = Lex \\<longrightarrow>\n            fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                  (map ((!) ab') (\\<sigma> g))))) \\<and>\n          (c f \\<noteq> c g \\<longrightarrow>\n           map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n           map ((!) ab') (\\<sigma> g) = [])})\n       (\\<lambda>(f, ts). ((f, length ts), (f, length ts), ts)))\n\ngoal (1 subgoal):\n 1. SN {(a, b).\n        (case a of\n         (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n         case b of\n         (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n        \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n               {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])}}", "unfolding inv_image_def"], ["proof (prove)\nusing this:\n  SN {(x, y).\n      (case x of (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n       case y of (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n      \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n             {((f, ab), g, ab').\n              (c f = c g \\<longrightarrow>\n               (\\<forall>i\\<in>set (\\<sigma> f).\n                   SN_on WPO_S {ab ! i}) \\<and>\n               (c f = Mul \\<longrightarrow>\n                fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                      (map ((!) ab') (\\<sigma> g)))) \\<and>\n               (c f = Lex \\<longrightarrow>\n                fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                      (map ((!) ab') (\\<sigma> g))))) \\<and>\n              (c f \\<noteq> c g \\<longrightarrow>\n               map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n               map ((!) ab') (\\<sigma> g) = [])}}\n\ngoal (1 subgoal):\n 1. SN {(a, b).\n        (case a of\n         (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n         case b of\n         (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n        \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n               {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])}}", "by fast"], ["proof (state)\nthis:\n  SN {(a, b).\n      (case a of (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n       case b of (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n      \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n             {((f, ab), g, ab').\n              (c f = c g \\<longrightarrow>\n               (\\<forall>i\\<in>set (\\<sigma> f).\n                   SN_on WPO_S {ab ! i}) \\<and>\n               (c f = Mul \\<longrightarrow>\n                fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                      (map ((!) ab') (\\<sigma> g)))) \\<and>\n               (c f = Lex \\<longrightarrow>\n                fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                      (map ((!) ab') (\\<sigma> g))))) \\<and>\n              (c f \\<noteq> c g \\<longrightarrow>\n               map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n               map ((!) ab') (\\<sigma> g) = [])}}\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?SA = \"(\\<lambda> x y. (x,y) \\<in> S)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?NSA = \"(\\<lambda> x y. (x,y) \\<in> NS)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?rr = \"lex_two S NS ?r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "define rr where \"rr = ?rr\""], ["proof (state)\nthis:\n  rr =\n  lex_two S NS\n   {(a, b).\n    (case a of (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n     case b of (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n    \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n           {((f, ab), g, ab').\n            (c f = c g \\<longrightarrow>\n             (\\<forall>i\\<in>set (\\<sigma> f). SN_on WPO_S {ab ! i}) \\<and>\n             (c f = Mul \\<longrightarrow>\n              fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                    (map ((!) ab') (\\<sigma> g)))) \\<and>\n             (c f = Lex \\<longrightarrow>\n              fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                    (map ((!) ab') (\\<sigma> g))))) \\<and>\n            (c f \\<noteq> c g \\<longrightarrow>\n             map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n             map ((!) ab') (\\<sigma> g) = [])}}\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "from lex_two[OF compat_NS_S SN SN_r]"], ["proof (chain)\npicking this:\n  SN (lex_two S NS\n       {(a, b).\n        (case a of\n         (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n         case b of\n         (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n        \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n               {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])}})", "have SN_rr: \"SN rr\""], ["proof (prove)\nusing this:\n  SN (lex_two S NS\n       {(a, b).\n        (case a of\n         (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n         case b of\n         (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n        \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n               {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])}})\n\ngoal (1 subgoal):\n 1. SN rr", "unfolding rr_def"], ["proof (prove)\nusing this:\n  SN (lex_two S NS\n       {(a, b).\n        (case a of\n         (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n         case b of\n         (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n        \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n               {((f, ab), g, ab').\n                (c f = c g \\<longrightarrow>\n                 (\\<forall>i\\<in>set (\\<sigma> f).\n                     SN_on WPO_S {ab ! i}) \\<and>\n                 (c f = Mul \\<longrightarrow>\n                  fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g)))) \\<and>\n                 (c f = Lex \\<longrightarrow>\n                  fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                        (map ((!) ab') (\\<sigma> g))))) \\<and>\n                (c f \\<noteq> c g \\<longrightarrow>\n                 map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                 map ((!) ab') (\\<sigma> g) = [])}})\n\ngoal (1 subgoal):\n 1. SN (lex_two S NS\n         {(a, b).\n          (case a of\n           (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n           case b of\n           (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n          \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                 {((f, ab), g, ab').\n                  (c f = c g \\<longrightarrow>\n                   (\\<forall>i\\<in>set (\\<sigma> f).\n                       SN_on WPO_S {ab ! i}) \\<and>\n                   (c f = Mul \\<longrightarrow>\n                    fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                          (map ((!) ab') (\\<sigma> g)))) \\<and>\n                   (c f = Lex \\<longrightarrow>\n                    fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                          (map ((!) ab') (\\<sigma> g))))) \\<and>\n                  (c f \\<noteq> c g \\<longrightarrow>\n                   map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                   map ((!) ab') (\\<sigma> g) = [])}})", "by auto"], ["proof (state)\nthis:\n  SN rr\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?rrr = \"inv_image rr (\\<lambda> (f,ts). (Fun f ts, (f,ts)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "have SN_rrr: \"SN ?rrr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN (inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)))", "by (rule SN_inv_image[OF SN_rr])"], ["proof (state)\nthis:\n  SN (inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)))\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "let ?ind = \"\\<lambda> (f,ts). ?Slist (f,length ts) ts \\<longrightarrow> ?S (Fun f ts)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "have \"?ind (f,ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case (f, ts) of\n    (f, ts) \\<Rightarrow>\n      (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n          SN_on WPO_S {ts ! i}) \\<longrightarrow>\n      SN_on WPO_S {Fun f ts}", "proof (rule SN_induct[OF SN_rrr, of ?ind])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image rr\n                  (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n           case b of\n           (f, ts) \\<Rightarrow>\n             (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n                 SN_on WPO_S {ts ! i}) \\<longrightarrow>\n             SN_on WPO_S {Fun f ts}) \\<Longrightarrow>\n       case a of\n       (f, ts) \\<Rightarrow>\n         (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n             SN_on WPO_S {ts ! i}) \\<longrightarrow>\n         SN_on WPO_S {Fun f ts}", "fix fts"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image rr\n                  (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n           case b of\n           (f, ts) \\<Rightarrow>\n             (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n                 SN_on WPO_S {ts ! i}) \\<longrightarrow>\n             SN_on WPO_S {Fun f ts}) \\<Longrightarrow>\n       case a of\n       (f, ts) \\<Rightarrow>\n         (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n             SN_on WPO_S {ts ! i}) \\<longrightarrow>\n         SN_on WPO_S {Fun f ts}", "assume ind: \"\\<And> gss. (fts,gss) \\<in> ?rrr \\<Longrightarrow> ?ind gss\""], ["proof (state)\nthis:\n  (fts, ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image rr\n                  (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n           case b of\n           (f, ts) \\<Rightarrow>\n             (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n                 SN_on WPO_S {ts ! i}) \\<longrightarrow>\n             SN_on WPO_S {Fun f ts}) \\<Longrightarrow>\n       case a of\n       (f, ts) \\<Rightarrow>\n         (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n             SN_on WPO_S {ts ! i}) \\<longrightarrow>\n         SN_on WPO_S {Fun f ts}", "obtain f ts where Pair: \"fts = (f,ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f ts. fts = (f, ts) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  fts = (f, ts)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image rr\n                  (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n           case b of\n           (f, ts) \\<Rightarrow>\n             (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n                 SN_on WPO_S {ts ! i}) \\<longrightarrow>\n             SN_on WPO_S {Fun f ts}) \\<Longrightarrow>\n       case a of\n       (f, ts) \\<Rightarrow>\n         (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n             SN_on WPO_S {ts ! i}) \\<longrightarrow>\n         SN_on WPO_S {Fun f ts}", "let ?f = \"(f,length ts)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image rr\n                  (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n           case b of\n           (f, ts) \\<Rightarrow>\n             (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n                 SN_on WPO_S {ts ! i}) \\<longrightarrow>\n             SN_on WPO_S {Fun f ts}) \\<Longrightarrow>\n       case a of\n       (f, ts) \\<Rightarrow>\n         (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n             SN_on WPO_S {ts ! i}) \\<longrightarrow>\n         SN_on WPO_S {Fun f ts}", "note ind = ind[unfolded Pair]"], ["proof (state)\nthis:\n  ((f, ts), ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image rr\n                  (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n           case b of\n           (f, ts) \\<Rightarrow>\n             (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n                 SN_on WPO_S {ts ! i}) \\<longrightarrow>\n             SN_on WPO_S {Fun f ts}) \\<Longrightarrow>\n       case a of\n       (f, ts) \\<Rightarrow>\n         (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n             SN_on WPO_S {ts ! i}) \\<longrightarrow>\n         SN_on WPO_S {Fun f ts}", "show \"?ind fts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case fts of\n    (f, ts) \\<Rightarrow>\n      (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n          SN_on WPO_S {ts ! i}) \\<longrightarrow>\n      SN_on WPO_S {Fun f ts}", "unfolding Pair split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}", "proof (intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n       SN_on WPO_S {ts ! i} \\<Longrightarrow>\n    SN_on WPO_S {Fun f ts}", "assume ts: \"?Slist ?f ts\""], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (\\<sigma> (f, length ts)). SN_on WPO_S {ts ! i}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n       SN_on WPO_S {ts ! i} \\<Longrightarrow>\n    SN_on WPO_S {Fun f ts}", "let ?t = \"Fun f ts\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n       SN_on WPO_S {ts ! i} \\<Longrightarrow>\n    SN_on WPO_S {Fun f ts}", "show \"?S ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun f ts}", "proof (simp only: iff[of ?t], intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b. (Fun f ts, b) \\<in> WPO_S \\<Longrightarrow> SN_on WPO_S {b}", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b. (Fun f ts, b) \\<in> WPO_S \\<Longrightarrow> SN_on WPO_S {b}", "assume \"(?t,s) \\<in> WPO_S\""], ["proof (state)\nthis:\n  (Fun f ts, s) \\<in> WPO_S\n\ngoal (1 subgoal):\n 1. \\<And>b. (Fun f ts, b) \\<in> WPO_S \\<Longrightarrow> SN_on WPO_S {b}", "then"], ["proof (chain)\npicking this:\n  (Fun f ts, s) \\<in> WPO_S", "have \"?t \\<succ> s\""], ["proof (prove)\nusing this:\n  (Fun f ts, s) \\<in> WPO_S\n\ngoal (1 subgoal):\n 1. Fun f ts \\<succ> s", "by simp"], ["proof (state)\nthis:\n  Fun f ts \\<succ> s\n\ngoal (1 subgoal):\n 1. \\<And>b. (Fun f ts, b) \\<in> WPO_S \\<Longrightarrow> SN_on WPO_S {b}", "then"], ["proof (chain)\npicking this:\n  Fun f ts \\<succ> s", "show \"?S s\""], ["proof (prove)\nusing this:\n  Fun f ts \\<succ> s\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {s}", "proof (induct s, simp add: var_SN)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; Fun f ts \\<succ> x2a\\<rbrakk>\n                   \\<Longrightarrow> SN_on WPO_S {x2a};\n        Fun f ts \\<succ> Fun x1a x2\\<rbrakk>\n       \\<Longrightarrow> SN_on WPO_S {Fun x1a x2}", "case (Fun g ss)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a1 \\<in> set ss; Fun f ts \\<succ> ?x2a1\\<rbrakk>\n  \\<Longrightarrow> SN_on WPO_S {?x2a1}\n  Fun f ts \\<succ> Fun g ss\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; Fun f ts \\<succ> x2a\\<rbrakk>\n                   \\<Longrightarrow> SN_on WPO_S {x2a};\n        Fun f ts \\<succ> Fun x1a x2\\<rbrakk>\n       \\<Longrightarrow> SN_on WPO_S {Fun x1a x2}", "note IH = this"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a1 \\<in> set ss; Fun f ts \\<succ> ?x2a1\\<rbrakk>\n  \\<Longrightarrow> SN_on WPO_S {?x2a1}\n  Fun f ts \\<succ> Fun g ss\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; Fun f ts \\<succ> x2a\\<rbrakk>\n                   \\<Longrightarrow> SN_on WPO_S {x2a};\n        Fun f ts \\<succ> Fun x1a x2\\<rbrakk>\n       \\<Longrightarrow> SN_on WPO_S {Fun x1a x2}", "let ?s = \"Fun g ss\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; Fun f ts \\<succ> x2a\\<rbrakk>\n                   \\<Longrightarrow> SN_on WPO_S {x2a};\n        Fun f ts \\<succ> Fun x1a x2\\<rbrakk>\n       \\<Longrightarrow> SN_on WPO_S {Fun x1a x2}", "let ?g = \"(g,length ss)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; Fun f ts \\<succ> x2a\\<rbrakk>\n                   \\<Longrightarrow> SN_on WPO_S {x2a};\n        Fun f ts \\<succ> Fun x1a x2\\<rbrakk>\n       \\<Longrightarrow> SN_on WPO_S {Fun x1a x2}", "from Fun"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a1 \\<in> set ss; Fun f ts \\<succ> ?x2a1\\<rbrakk>\n  \\<Longrightarrow> SN_on WPO_S {?x2a1}\n  Fun f ts \\<succ> Fun g ss", "have t_gr_s: \"?t \\<succ> ?s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a1 \\<in> set ss; Fun f ts \\<succ> ?x2a1\\<rbrakk>\n  \\<Longrightarrow> SN_on WPO_S {?x2a1}\n  Fun f ts \\<succ> Fun g ss\n\ngoal (1 subgoal):\n 1. Fun f ts \\<succ> Fun g ss", "by auto"], ["proof (state)\nthis:\n  Fun f ts \\<succ> Fun g ss\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; Fun f ts \\<succ> x2a\\<rbrakk>\n                   \\<Longrightarrow> SN_on WPO_S {x2a};\n        Fun f ts \\<succ> Fun x1a x2\\<rbrakk>\n       \\<Longrightarrow> SN_on WPO_S {Fun x1a x2}", "show \"?S ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun g ss}", "proof (cases \"\\<exists> i \\<in> set (\\<sigma> ?f). ts ! i \\<succeq> ?s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n       ts ! i \\<succeq> Fun g ss \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n               ts ! i \\<succeq> Fun g ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}", "case True"], ["proof (state)\nthis:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ts)). ts ! i \\<succeq> Fun g ss\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n       ts ! i \\<succeq> Fun g ss \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n               ts ! i \\<succeq> Fun g ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}", "then"], ["proof (chain)\npicking this:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ts)). ts ! i \\<succeq> Fun g ss", "obtain i where \"i \\<in> set (\\<sigma> ?f)\" and ge: \"ts ! i \\<succeq> ?s\""], ["proof (prove)\nusing this:\n  \\<exists>i\\<in>set (\\<sigma> (f, length ts)). ts ! i \\<succeq> Fun g ss\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> set (\\<sigma> (f, length ts));\n         ts ! i \\<succeq> Fun g ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<in> set (\\<sigma> (f, length ts))\n  ts ! i \\<succeq> Fun g ss\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n       ts ! i \\<succeq> Fun g ss \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n               ts ! i \\<succeq> Fun g ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}", "with ts"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>set (\\<sigma> (f, length ts)). SN_on WPO_S {ts ! i}\n  i \\<in> set (\\<sigma> (f, length ts))\n  ts ! i \\<succeq> Fun g ss", "have \"?S (ts ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (\\<sigma> (f, length ts)). SN_on WPO_S {ts ! i}\n  i \\<in> set (\\<sigma> (f, length ts))\n  ts ! i \\<succeq> Fun g ss\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {ts ! i}", "by auto"], ["proof (state)\nthis:\n  SN_on WPO_S {ts ! i}\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n       ts ! i \\<succeq> Fun g ss \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}\n 2. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n               ts ! i \\<succeq> Fun g ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}", "show \"?S ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun g ss}", "proof (unfold iff[of ?s], intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b. (Fun g ss, b) \\<in> WPO_S \\<Longrightarrow> SN_on WPO_S {b}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b. (Fun g ss, b) \\<in> WPO_S \\<Longrightarrow> SN_on WPO_S {b}", "assume \"(?s,u) \\<in> WPO_S\""], ["proof (state)\nthis:\n  (Fun g ss, u) \\<in> WPO_S\n\ngoal (1 subgoal):\n 1. \\<And>b. (Fun g ss, b) \\<in> WPO_S \\<Longrightarrow> SN_on WPO_S {b}", "with wpo_compat ge"], ["proof (chain)\npicking this:\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n  ts ! i \\<succeq> Fun g ss\n  (Fun g ss, u) \\<in> WPO_S", "have u: \"ts ! i \\<succ> u\""], ["proof (prove)\nusing this:\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n  ts ! i \\<succeq> Fun g ss\n  (Fun g ss, u) \\<in> WPO_S\n\ngoal (1 subgoal):\n 1. ts ! i \\<succ> u", "by blast"], ["proof (state)\nthis:\n  ts ! i \\<succ> u\n\ngoal (1 subgoal):\n 1. \\<And>b. (Fun g ss, b) \\<in> WPO_S \\<Longrightarrow> SN_on WPO_S {b}", "with \\<open>?S (ts ! i)\\<close>[unfolded iff[of \"ts ! i\"]]"], ["proof (chain)\npicking this:\n  \\<forall>b. (ts ! i, b) \\<in> WPO_S \\<longrightarrow> SN_on WPO_S {b}\n  ts ! i \\<succ> u", "show \"?S u\""], ["proof (prove)\nusing this:\n  \\<forall>b. (ts ! i, b) \\<in> WPO_S \\<longrightarrow> SN_on WPO_S {b}\n  ts ! i \\<succ> u\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {u}", "by simp"], ["proof (state)\nthis:\n  SN_on WPO_S {u}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SN_on WPO_S {Fun g ss}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n               ts ! i \\<succeq> Fun g ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n               ts ! i \\<succeq> Fun g ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n               ts ! i \\<succeq> Fun g ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}", "note oFalse = this"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n               ts ! i \\<succeq> Fun g ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}", "from wpo_s_imp_NS[OF t_gr_s]"], ["proof (chain)\npicking this:\n  (Fun f ts, Fun g ss) \\<in> NS", "have t_NS_s: \"(?t,?s) \\<in> NS\""], ["proof (prove)\nusing this:\n  (Fun f ts, Fun g ss) \\<in> NS\n\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<in> NS", "."], ["proof (state)\nthis:\n  (Fun f ts, Fun g ss) \\<in> NS\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n               ts ! i \\<succeq> Fun g ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun g ss}", "proof (cases \"(?t,?s) \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (Fun f ts, Fun g ss) \\<in> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "case True"], ["proof (state)\nthis:\n  (Fun f ts, Fun g ss) \\<in> S\n\ngoal (2 subgoals):\n 1. (Fun f ts, Fun g ss) \\<in> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "then"], ["proof (chain)\npicking this:\n  (Fun f ts, Fun g ss) \\<in> S", "have \"((f,ts),(g,ss)) \\<in> ?rrr\""], ["proof (prove)\nusing this:\n  (Fun f ts, Fun g ss) \\<in> S\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))", "unfolding rr_def"], ["proof (prove)\nusing this:\n  (Fun f ts, Fun g ss) \\<in> S\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> inv_image\n           (lex_two S NS\n             {(a, b).\n              (case a of\n               (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n               case b of\n               (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n              \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                     {((f, ab), g, ab').\n                      (c f = c g \\<longrightarrow>\n                       (\\<forall>i\\<in>set (\\<sigma> f).\n                           SN_on WPO_S {ab ! i}) \\<and>\n                       (c f = Mul \\<longrightarrow>\n                        fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                              (map ((!) ab') (\\<sigma> g)))) \\<and>\n                       (c f = Lex \\<longrightarrow>\n                        fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                              (map ((!) ab') (\\<sigma> g))))) \\<and>\n                      (c f \\<noteq> c g \\<longrightarrow>\n                       map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                       map ((!) ab') (\\<sigma> g) = [])}})\n           (\\<lambda>(f, ts). (Fun f ts, f, ts))", "by auto"], ["proof (state)\nthis:\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))\n\ngoal (2 subgoals):\n 1. (Fun f ts, Fun g ss) \\<in> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with ind"], ["proof (chain)\npicking this:\n  ((f, ts), ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))", "have ind: \"?ind (g,ss)\""], ["proof (prove)\nusing this:\n  ((f, ts), ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))\n\ngoal (1 subgoal):\n 1. case (g, ss) of\n    (f, ts) \\<Rightarrow>\n      (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n          SN_on WPO_S {ts ! i}) \\<longrightarrow>\n      SN_on WPO_S {Fun f ts}", "by auto"], ["proof (state)\nthis:\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (2 subgoals):\n 1. (Fun f ts, Fun g ss) \\<in> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "{"], ["proof (state)\nthis:\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (2 subgoals):\n 1. (Fun f ts, Fun g ss) \\<in> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. (Fun f ts, Fun g ss) \\<in> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "assume i: \"i \\<in> set (\\<sigma> ?g)\""], ["proof (state)\nthis:\n  i \\<in> set (\\<sigma> (g, length ss))\n\ngoal (2 subgoals):\n 1. (Fun f ts, Fun g ss) \\<in> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "have \"?s \\<succeq> ss ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun g ss \\<succeq> ss ! i", "by (rule subterm_wpo_ns_arg[OF i])"], ["proof (state)\nthis:\n  Fun g ss \\<succeq> ss ! i\n\ngoal (2 subgoals):\n 1. (Fun f ts, Fun g ss) \\<in> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with t_gr_s"], ["proof (chain)\npicking this:\n  Fun f ts \\<succ> Fun g ss\n  Fun g ss \\<succeq> ss ! i", "have ts: \"?t \\<succ> ss ! i\""], ["proof (prove)\nusing this:\n  Fun f ts \\<succ> Fun g ss\n  Fun g ss \\<succeq> ss ! i\n\ngoal (1 subgoal):\n 1. Fun f ts \\<succ> ss ! i", "using wpo_compat"], ["proof (prove)\nusing this:\n  Fun f ts \\<succ> Fun g ss\n  Fun g ss \\<succeq> ss ! i\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n\ngoal (1 subgoal):\n 1. Fun f ts \\<succ> ss ! i", "by blast"], ["proof (state)\nthis:\n  Fun f ts \\<succ> ss ! i\n\ngoal (2 subgoals):\n 1. (Fun f ts, Fun g ss) \\<in> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "have \"?S (ss ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN_on WPO_S {ss ! i}", "using IH(1)[OF \\<sigma>E[OF i] ts]"], ["proof (prove)\nusing this:\n  SN_on WPO_S {ss ! i}\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {ss ! i}", "by auto"], ["proof (state)\nthis:\n  SN_on WPO_S {ss ! i}\n\ngoal (2 subgoals):\n 1. (Fun f ts, Fun g ss) \\<in> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "}"], ["proof (state)\nthis:\n  ?i3 \\<in> set (\\<sigma> (g, length ss)) \\<Longrightarrow>\n  SN_on WPO_S {ss ! ?i3}\n\ngoal (2 subgoals):\n 1. (Fun f ts, Fun g ss) \\<in> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "note SN_ss = this"], ["proof (state)\nthis:\n  ?i3 \\<in> set (\\<sigma> (g, length ss)) \\<Longrightarrow>\n  SN_on WPO_S {ss ! ?i3}\n\ngoal (2 subgoals):\n 1. (Fun f ts, Fun g ss) \\<in> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "from ind SN_ss"], ["proof (chain)\npicking this:\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ?i3 \\<in> set (\\<sigma> (g, length ss)) \\<Longrightarrow>\n  SN_on WPO_S {ss ! ?i3}", "show ?thesis"], ["proof (prove)\nusing this:\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ?i3 \\<in> set (\\<sigma> (g, length ss)) \\<Longrightarrow>\n  SN_on WPO_S {ss ! ?i3}\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun g ss}", "by auto"], ["proof (state)\nthis:\n  SN_on WPO_S {Fun g ss}\n\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "case False"], ["proof (state)\nthis:\n  (Fun f ts, Fun g ss) \\<notin> S\n\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with t_NS_s oFalse"], ["proof (chain)\npicking this:\n  (Fun f ts, Fun g ss) \\<in> NS\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  (Fun f ts, Fun g ss) \\<notin> S", "have id: \"(?t,?s) \\<in> S = False\" \"(?t,?s) \\<in> NS = True\""], ["proof (prove)\nusing this:\n  (Fun f ts, Fun g ss) \\<in> NS\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  (Fun f ts, Fun g ss) \\<notin> S\n\ngoal (1 subgoal):\n 1. ((Fun f ts, Fun g ss) \\<in> S) = False &&&\n    ((Fun f ts, Fun g ss) \\<in> NS) = True", "by simp_all"], ["proof (state)\nthis:\n  ((Fun f ts, Fun g ss) \\<in> S) = False\n  ((Fun f ts, Fun g ss) \\<in> NS) = True\n\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "let ?ls = \"length ss\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "let ?lt = \"length ts\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "let ?f = \"(f,?lt)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "let ?g = \"(g,?ls)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "obtain s1 ns1 where prc1: \"prc ?f ?g = (s1,ns1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s1 ns1.\n        prc (f, length ts) (g, length ss) = (s1, ns1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prc (f, length ts) (g, length ss) = (s1, ns1)\n\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "note t_gr_s = t_gr_s[unfolded wpo.simps[of ?t ?s], \n                      unfolded term.simps id if_True if_False prc1 split]"], ["proof (state)\nthis:\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss\n       then (True, True)\n       else if ns1 \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ss)).\n                   Fun f ts \\<succ> ss ! j)\n            then if s1 then (True, True)\n                 else let ss' = map ((!) ts) (\\<sigma> (f, length ts));\n                          ts' = map ((!) ss) (\\<sigma> (g, length ss));\n                          cf = c (f, length ts); cg = c (g, length ss)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "from oFalse t_gr_s"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss\n       then (True, True)\n       else if ns1 \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ss)).\n                   Fun f ts \\<succ> ss ! j)\n            then if s1 then (True, True)\n                 else let ss' = map ((!) ts) (\\<sigma> (f, length ts));\n                          ts' = map ((!) ss) (\\<sigma> (g, length ss));\n                          cf = c (f, length ts); cg = c (g, length ss)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))", "have f_ge_g: \"ns1\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss\n       then (True, True)\n       else if ns1 \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ss)).\n                   Fun f ts \\<succ> ss ! j)\n            then if s1 then (True, True)\n                 else let ss' = map ((!) ts) (\\<sigma> (f, length ts));\n                          ts' = map ((!) ss) (\\<sigma> (g, length ss));\n                          cf = c (f, length ts); cg = c (g, length ss)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n\ngoal (1 subgoal):\n 1. ns1", "by (cases ?thesis, auto)"], ["proof (state)\nthis:\n  ns1\n\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "from oFalse t_gr_s f_ge_g"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss\n       then (True, True)\n       else if ns1 \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ss)).\n                   Fun f ts \\<succ> ss ! j)\n            then if s1 then (True, True)\n                 else let ss' = map ((!) ts) (\\<sigma> (f, length ts));\n                          ts' = map ((!) ss) (\\<sigma> (g, length ss));\n                          cf = c (f, length ts); cg = c (g, length ss)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n  ns1", "have small_ss: \"\\<forall> i \\<in> set (\\<sigma> ?g). ?t \\<succ> ss ! i\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss\n       then (True, True)\n       else if ns1 \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ss)).\n                   Fun f ts \\<succ> ss ! j)\n            then if s1 then (True, True)\n                 else let ss' = map ((!) ts) (\\<sigma> (f, length ts));\n                          ts' = map ((!) ss) (\\<sigma> (g, length ss));\n                          cf = c (f, length ts); cg = c (g, length ss)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n  ns1\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (\\<sigma> (g, length ss)). Fun f ts \\<succ> ss ! i", "by (cases ?thesis, auto)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). Fun f ts \\<succ> ss ! i\n\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with Fun \\<sigma>E[of _ g ss]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a1 \\<in> set ss; Fun f ts \\<succ> ?x2a1\\<rbrakk>\n  \\<Longrightarrow> SN_on WPO_S {?x2a1}\n  Fun f ts \\<succ> Fun g ss\n  ?i \\<in> set (\\<sigma> (g, length ss)) \\<Longrightarrow>\n  ss ! ?i \\<in> set ss\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). Fun f ts \\<succ> ss ! i", "have ss_S: \"?Slist ?g ss\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a1 \\<in> set ss; Fun f ts \\<succ> ?x2a1\\<rbrakk>\n  \\<Longrightarrow> SN_on WPO_S {?x2a1}\n  Fun f ts \\<succ> Fun g ss\n  ?i \\<in> set (\\<sigma> (g, length ss)) \\<Longrightarrow>\n  ss ! ?i \\<in> set ss\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). Fun f ts \\<succ> ss ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (\\<sigma> (g, length ss)). SN_on WPO_S {ss ! i}", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). SN_on WPO_S {ss ! i}\n\ngoal (1 subgoal):\n 1. (Fun f ts, Fun g ss) \\<notin> S \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun g ss}", "proof (cases s1)"], ["proof (state)\ngoal (2 subgoals):\n 1. s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. \\<not> s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "case True"], ["proof (state)\nthis:\n  s1\n\ngoal (2 subgoals):\n 1. s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. \\<not> s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "then"], ["proof (chain)\npicking this:\n  s1", "have \"((f,ts),(g,ss)) \\<in> ?r\""], ["proof (prove)\nusing this:\n  s1\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> {(a, b).\n           (case a of\n            (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n            case b of\n            (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n           \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                  {((f, ab), g, ab').\n                   (c f = c g \\<longrightarrow>\n                    (\\<forall>i\\<in>set (\\<sigma> f).\n                        SN_on WPO_S {ab ! i}) \\<and>\n                    (c f = Mul \\<longrightarrow>\n                     fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                           (map ((!) ab') (\\<sigma> g)))) \\<and>\n                    (c f = Lex \\<longrightarrow>\n                     fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                           (map ((!) ab') (\\<sigma> g))))) \\<and>\n                   (c f \\<noteq> c g \\<longrightarrow>\n                    map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                    map ((!) ab') (\\<sigma> g) = [])}}", "by (simp add: prc1)"], ["proof (state)\nthis:\n  ((f, ts), g, ss)\n  \\<in> {(a, b).\n         (case a of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n          case b of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n         \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                {((f, ab), g, ab').\n                 (c f = c g \\<longrightarrow>\n                  (\\<forall>i\\<in>set (\\<sigma> f).\n                      SN_on WPO_S {ab ! i}) \\<and>\n                  (c f = Mul \\<longrightarrow>\n                   fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g)))) \\<and>\n                  (c f = Lex \\<longrightarrow>\n                   fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g))))) \\<and>\n                 (c f \\<noteq> c g \\<longrightarrow>\n                  map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                  map ((!) ab') (\\<sigma> g) = [])}}\n\ngoal (2 subgoals):\n 1. s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. \\<not> s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with t_NS_s"], ["proof (chain)\npicking this:\n  (Fun f ts, Fun g ss) \\<in> NS\n  ((f, ts), g, ss)\n  \\<in> {(a, b).\n         (case a of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n          case b of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n         \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                {((f, ab), g, ab').\n                 (c f = c g \\<longrightarrow>\n                  (\\<forall>i\\<in>set (\\<sigma> f).\n                      SN_on WPO_S {ab ! i}) \\<and>\n                  (c f = Mul \\<longrightarrow>\n                   fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g)))) \\<and>\n                  (c f = Lex \\<longrightarrow>\n                   fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g))))) \\<and>\n                 (c f \\<noteq> c g \\<longrightarrow>\n                  map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                  map ((!) ab') (\\<sigma> g) = [])}}", "have \"((f,ts),(g,ss)) \\<in> ?rrr\""], ["proof (prove)\nusing this:\n  (Fun f ts, Fun g ss) \\<in> NS\n  ((f, ts), g, ss)\n  \\<in> {(a, b).\n         (case a of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n          case b of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n         \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                {((f, ab), g, ab').\n                 (c f = c g \\<longrightarrow>\n                  (\\<forall>i\\<in>set (\\<sigma> f).\n                      SN_on WPO_S {ab ! i}) \\<and>\n                  (c f = Mul \\<longrightarrow>\n                   fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g)))) \\<and>\n                  (c f = Lex \\<longrightarrow>\n                   fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g))))) \\<and>\n                 (c f \\<noteq> c g \\<longrightarrow>\n                  map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                  map ((!) ab') (\\<sigma> g) = [])}}\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))", "unfolding rr_def"], ["proof (prove)\nusing this:\n  (Fun f ts, Fun g ss) \\<in> NS\n  ((f, ts), g, ss)\n  \\<in> {(a, b).\n         (case a of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n          case b of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n         \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                {((f, ab), g, ab').\n                 (c f = c g \\<longrightarrow>\n                  (\\<forall>i\\<in>set (\\<sigma> f).\n                      SN_on WPO_S {ab ! i}) \\<and>\n                  (c f = Mul \\<longrightarrow>\n                   fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g)))) \\<and>\n                  (c f = Lex \\<longrightarrow>\n                   fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g))))) \\<and>\n                 (c f \\<noteq> c g \\<longrightarrow>\n                  map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                  map ((!) ab') (\\<sigma> g) = [])}}\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> inv_image\n           (lex_two S NS\n             {(a, b).\n              (case a of\n               (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n               case b of\n               (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n              \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                     {((f, ab), g, ab').\n                      (c f = c g \\<longrightarrow>\n                       (\\<forall>i\\<in>set (\\<sigma> f).\n                           SN_on WPO_S {ab ! i}) \\<and>\n                       (c f = Mul \\<longrightarrow>\n                        fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                              (map ((!) ab') (\\<sigma> g)))) \\<and>\n                       (c f = Lex \\<longrightarrow>\n                        fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                              (map ((!) ab') (\\<sigma> g))))) \\<and>\n                      (c f \\<noteq> c g \\<longrightarrow>\n                       map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                       map ((!) ab') (\\<sigma> g) = [])}})\n           (\\<lambda>(f, ts). (Fun f ts, f, ts))", "by auto"], ["proof (state)\nthis:\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))\n\ngoal (2 subgoals):\n 1. s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. \\<not> s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with ind"], ["proof (chain)\npicking this:\n  ((f, ts), ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))", "have \"?ind (g,ss)\""], ["proof (prove)\nusing this:\n  ((f, ts), ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))\n\ngoal (1 subgoal):\n 1. case (g, ss) of\n    (f, ts) \\<Rightarrow>\n      (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n          SN_on WPO_S {ts ! i}) \\<longrightarrow>\n      SN_on WPO_S {Fun f ts}", "by auto"], ["proof (state)\nthis:\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (2 subgoals):\n 1. s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. \\<not> s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with ss_S"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). SN_on WPO_S {ss ! i}\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). SN_on WPO_S {ss ! i}\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun g ss}", "by auto"], ["proof (state)\nthis:\n  SN_on WPO_S {Fun g ss}\n\ngoal (1 subgoal):\n 1. \\<not> s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "case False"], ["proof (state)\nthis:\n  \\<not> s1\n\ngoal (1 subgoal):\n 1. \\<not> s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "consider (Diff) \"c ?f \\<noteq> c ?g\" | (Lex) \"c ?f = Lex\" \"c ?g = Lex\" | (Mul) \"c ?f = Mul\" \"c ?g = Mul\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ts) \\<noteq> c (g, length ss) \\<Longrightarrow>\n             thesis;\n     \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases \"c ?f\"; cases \"c ?g\", auto)"], ["proof (state)\nthis:\n  \\<lbrakk>c (f, length ts) \\<noteq> c (g, length ss) \\<Longrightarrow>\n           ?thesis1;\n   \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n   \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<not> s1 \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>c (f, length ts) \\<noteq> c (g, length ss) \\<Longrightarrow>\n           ?thesis1;\n   \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n   \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun g ss}", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. c (f, length ts) \\<noteq> c (g, length ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}\n 2. \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 3. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "case Diff"], ["proof (state)\nthis:\n  c (f, length ts) \\<noteq> c (g, length ss)\n\ngoal (3 subgoals):\n 1. c (f, length ts) \\<noteq> c (g, length ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}\n 2. \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 3. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with False oFalse f_ge_g t_gr_s small_ss prc1 t_NS_s"], ["proof (chain)\npicking this:\n  \\<not> s1\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  ns1\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss\n       then (True, True)\n       else if ns1 \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ss)).\n                   Fun f ts \\<succ> ss ! j)\n            then if s1 then (True, True)\n                 else let ss' = map ((!) ts) (\\<sigma> (f, length ts));\n                          ts' = map ((!) ss) (\\<sigma> (g, length ss));\n                          cf = c (f, length ts); cg = c (g, length ss)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). Fun f ts \\<succ> ss ! i\n  prc (f, length ts) (g, length ss) = (s1, ns1)\n  (Fun f ts, Fun g ss) \\<in> NS\n  c (f, length ts) \\<noteq> c (g, length ss)", "have \"((f,ts),(g,ss)) \\<in> ?rrr\""], ["proof (prove)\nusing this:\n  \\<not> s1\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  ns1\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss\n       then (True, True)\n       else if ns1 \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ss)).\n                   Fun f ts \\<succ> ss ! j)\n            then if s1 then (True, True)\n                 else let ss' = map ((!) ts) (\\<sigma> (f, length ts));\n                          ts' = map ((!) ss) (\\<sigma> (g, length ss));\n                          cf = c (f, length ts); cg = c (g, length ss)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). Fun f ts \\<succ> ss ! i\n  prc (f, length ts) (g, length ss) = (s1, ns1)\n  (Fun f ts, Fun g ss) \\<in> NS\n  c (f, length ts) \\<noteq> c (g, length ss)\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))", "unfolding rr_def"], ["proof (prove)\nusing this:\n  \\<not> s1\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  ns1\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss\n       then (True, True)\n       else if ns1 \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ss)).\n                   Fun f ts \\<succ> ss ! j)\n            then if s1 then (True, True)\n                 else let ss' = map ((!) ts) (\\<sigma> (f, length ts));\n                          ts' = map ((!) ss) (\\<sigma> (g, length ss));\n                          cf = c (f, length ts); cg = c (g, length ss)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). Fun f ts \\<succ> ss ! i\n  prc (f, length ts) (g, length ss) = (s1, ns1)\n  (Fun f ts, Fun g ss) \\<in> NS\n  c (f, length ts) \\<noteq> c (g, length ss)\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> inv_image\n           (lex_two S NS\n             {(a, b).\n              (case a of\n               (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n               case b of\n               (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n              \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                     {((f, ab), g, ab').\n                      (c f = c g \\<longrightarrow>\n                       (\\<forall>i\\<in>set (\\<sigma> f).\n                           SN_on WPO_S {ab ! i}) \\<and>\n                       (c f = Mul \\<longrightarrow>\n                        fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                              (map ((!) ab') (\\<sigma> g)))) \\<and>\n                       (c f = Lex \\<longrightarrow>\n                        fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                              (map ((!) ab') (\\<sigma> g))))) \\<and>\n                      (c f \\<noteq> c g \\<longrightarrow>\n                       map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                       map ((!) ab') (\\<sigma> g) = [])}})\n           (\\<lambda>(f, ts). (Fun f ts, f, ts))", "by (cases \"c ?f\"; cases \"c ?g\", auto)"], ["proof (state)\nthis:\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))\n\ngoal (3 subgoals):\n 1. c (f, length ts) \\<noteq> c (g, length ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}\n 2. \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 3. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with ind"], ["proof (chain)\npicking this:\n  ((f, ts), ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))", "have \"?ind (g,ss)\""], ["proof (prove)\nusing this:\n  ((f, ts), ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))\n\ngoal (1 subgoal):\n 1. case (g, ss) of\n    (f, ts) \\<Rightarrow>\n      (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n          SN_on WPO_S {ts ! i}) \\<longrightarrow>\n      SN_on WPO_S {Fun f ts}", "using Pair"], ["proof (prove)\nusing this:\n  ((f, ts), ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))\n  fts = (f, ts)\n\ngoal (1 subgoal):\n 1. case (g, ss) of\n    (f, ts) \\<Rightarrow>\n      (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n          SN_on WPO_S {ts ! i}) \\<longrightarrow>\n      SN_on WPO_S {Fun f ts}", "by auto"], ["proof (state)\nthis:\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (3 subgoals):\n 1. c (f, length ts) \\<noteq> c (g, length ss) \\<Longrightarrow>\n    SN_on WPO_S {Fun g ss}\n 2. \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 3. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with ss_S"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). SN_on WPO_S {ss ! i}\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). SN_on WPO_S {ss ! i}\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun g ss}", "by simp"], ["proof (state)\nthis:\n  SN_on WPO_S {Fun g ss}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "case Lex"], ["proof (state)\nthis:\n  c (f, length ts) = Lex\n  c (g, length ss) = Lex\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "from False oFalse t_gr_s small_ss f_ge_g Lex"], ["proof (chain)\npicking this:\n  \\<not> s1\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss\n       then (True, True)\n       else if ns1 \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ss)).\n                   Fun f ts \\<succ> ss ! j)\n            then if s1 then (True, True)\n                 else let ss' = map ((!) ts) (\\<sigma> (f, length ts));\n                          ts' = map ((!) ss) (\\<sigma> (g, length ss));\n                          cf = c (f, length ts); cg = c (g, length ss)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). Fun f ts \\<succ> ss ! i\n  ns1\n  c (f, length ts) = Lex\n  c (g, length ss) = Lex", "have lex: \"fst (lex_ext wpo n (map ((!) ts) (\\<sigma> ?f)) (map ((!) ss) (\\<sigma> ?g)))\""], ["proof (prove)\nusing this:\n  \\<not> s1\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss\n       then (True, True)\n       else if ns1 \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ss)).\n                   Fun f ts \\<succ> ss ! j)\n            then if s1 then (True, True)\n                 else let ss' = map ((!) ts) (\\<sigma> (f, length ts));\n                          ts' = map ((!) ss) (\\<sigma> (g, length ss));\n                          cf = c (f, length ts); cg = c (g, length ss)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). Fun f ts \\<succ> ss ! i\n  ns1\n  c (f, length ts) = Lex\n  c (g, length ss) = Lex\n\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n (map ((!) ts) (\\<sigma> (f, length ts)))\n          (map ((!) ss) (\\<sigma> (g, length ss))))", "by auto"], ["proof (state)\nthis:\n  fst (lex_ext wpo n (map ((!) ts) (\\<sigma> (f, length ts)))\n        (map ((!) ss) (\\<sigma> (g, length ss))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "from False lex ts f_ge_g Lex"], ["proof (chain)\npicking this:\n  \\<not> s1\n  fst (lex_ext wpo n (map ((!) ts) (\\<sigma> (f, length ts)))\n        (map ((!) ss) (\\<sigma> (g, length ss))))\n  \\<forall>i\\<in>set (\\<sigma> (f, length ts)). SN_on WPO_S {ts ! i}\n  ns1\n  c (f, length ts) = Lex\n  c (g, length ss) = Lex", "have \"((f,ts),(g,ss)) \\<in> ?r\""], ["proof (prove)\nusing this:\n  \\<not> s1\n  fst (lex_ext wpo n (map ((!) ts) (\\<sigma> (f, length ts)))\n        (map ((!) ss) (\\<sigma> (g, length ss))))\n  \\<forall>i\\<in>set (\\<sigma> (f, length ts)). SN_on WPO_S {ts ! i}\n  ns1\n  c (f, length ts) = Lex\n  c (g, length ss) = Lex\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> {(a, b).\n           (case a of\n            (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n            case b of\n            (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n           \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                  {((f, ab), g, ab').\n                   (c f = c g \\<longrightarrow>\n                    (\\<forall>i\\<in>set (\\<sigma> f).\n                        SN_on WPO_S {ab ! i}) \\<and>\n                    (c f = Mul \\<longrightarrow>\n                     fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                           (map ((!) ab') (\\<sigma> g)))) \\<and>\n                    (c f = Lex \\<longrightarrow>\n                     fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                           (map ((!) ab') (\\<sigma> g))))) \\<and>\n                   (c f \\<noteq> c g \\<longrightarrow>\n                    map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                    map ((!) ab') (\\<sigma> g) = [])}}", "by (simp add: prc1)"], ["proof (state)\nthis:\n  ((f, ts), g, ss)\n  \\<in> {(a, b).\n         (case a of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n          case b of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n         \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                {((f, ab), g, ab').\n                 (c f = c g \\<longrightarrow>\n                  (\\<forall>i\\<in>set (\\<sigma> f).\n                      SN_on WPO_S {ab ! i}) \\<and>\n                  (c f = Mul \\<longrightarrow>\n                   fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g)))) \\<and>\n                  (c f = Lex \\<longrightarrow>\n                   fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g))))) \\<and>\n                 (c f \\<noteq> c g \\<longrightarrow>\n                  map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                  map ((!) ab') (\\<sigma> g) = [])}}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with t_NS_s"], ["proof (chain)\npicking this:\n  (Fun f ts, Fun g ss) \\<in> NS\n  ((f, ts), g, ss)\n  \\<in> {(a, b).\n         (case a of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n          case b of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n         \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                {((f, ab), g, ab').\n                 (c f = c g \\<longrightarrow>\n                  (\\<forall>i\\<in>set (\\<sigma> f).\n                      SN_on WPO_S {ab ! i}) \\<and>\n                  (c f = Mul \\<longrightarrow>\n                   fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g)))) \\<and>\n                  (c f = Lex \\<longrightarrow>\n                   fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g))))) \\<and>\n                 (c f \\<noteq> c g \\<longrightarrow>\n                  map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                  map ((!) ab') (\\<sigma> g) = [])}}", "have \"((f,ts),(g,ss)) \\<in> ?rrr\""], ["proof (prove)\nusing this:\n  (Fun f ts, Fun g ss) \\<in> NS\n  ((f, ts), g, ss)\n  \\<in> {(a, b).\n         (case a of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n          case b of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n         \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                {((f, ab), g, ab').\n                 (c f = c g \\<longrightarrow>\n                  (\\<forall>i\\<in>set (\\<sigma> f).\n                      SN_on WPO_S {ab ! i}) \\<and>\n                  (c f = Mul \\<longrightarrow>\n                   fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g)))) \\<and>\n                  (c f = Lex \\<longrightarrow>\n                   fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g))))) \\<and>\n                 (c f \\<noteq> c g \\<longrightarrow>\n                  map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                  map ((!) ab') (\\<sigma> g) = [])}}\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))", "unfolding rr_def"], ["proof (prove)\nusing this:\n  (Fun f ts, Fun g ss) \\<in> NS\n  ((f, ts), g, ss)\n  \\<in> {(a, b).\n         (case a of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n          case b of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n         \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                {((f, ab), g, ab').\n                 (c f = c g \\<longrightarrow>\n                  (\\<forall>i\\<in>set (\\<sigma> f).\n                      SN_on WPO_S {ab ! i}) \\<and>\n                  (c f = Mul \\<longrightarrow>\n                   fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g)))) \\<and>\n                  (c f = Lex \\<longrightarrow>\n                   fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g))))) \\<and>\n                 (c f \\<noteq> c g \\<longrightarrow>\n                  map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                  map ((!) ab') (\\<sigma> g) = [])}}\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> inv_image\n           (lex_two S NS\n             {(a, b).\n              (case a of\n               (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n               case b of\n               (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n              \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                     {((f, ab), g, ab').\n                      (c f = c g \\<longrightarrow>\n                       (\\<forall>i\\<in>set (\\<sigma> f).\n                           SN_on WPO_S {ab ! i}) \\<and>\n                       (c f = Mul \\<longrightarrow>\n                        fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                              (map ((!) ab') (\\<sigma> g)))) \\<and>\n                       (c f = Lex \\<longrightarrow>\n                        fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                              (map ((!) ab') (\\<sigma> g))))) \\<and>\n                      (c f \\<noteq> c g \\<longrightarrow>\n                       map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                       map ((!) ab') (\\<sigma> g) = [])}})\n           (\\<lambda>(f, ts). (Fun f ts, f, ts))", "by auto"], ["proof (state)\nthis:\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with ind"], ["proof (chain)\npicking this:\n  ((f, ts), ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))", "have \"?ind (g,ss)\""], ["proof (prove)\nusing this:\n  ((f, ts), ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))\n\ngoal (1 subgoal):\n 1. case (g, ss) of\n    (f, ts) \\<Rightarrow>\n      (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n          SN_on WPO_S {ts ! i}) \\<longrightarrow>\n      SN_on WPO_S {Fun f ts}", "by auto"], ["proof (state)\nthis:\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c (f, length ts) = Lex; c (g, length ss) = Lex\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}\n 2. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with ss_S"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). SN_on WPO_S {ss ! i}\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). SN_on WPO_S {ss ! i}\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun g ss}", "by auto"], ["proof (state)\nthis:\n  SN_on WPO_S {Fun g ss}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "case Mul"], ["proof (state)\nthis:\n  c (f, length ts) = Mul\n  c (g, length ss) = Mul\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "from False oFalse t_gr_s small_ss f_ge_g Mul"], ["proof (chain)\npicking this:\n  \\<not> s1\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss\n       then (True, True)\n       else if ns1 \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ss)).\n                   Fun f ts \\<succ> ss ! j)\n            then if s1 then (True, True)\n                 else let ss' = map ((!) ts) (\\<sigma> (f, length ts));\n                          ts' = map ((!) ss) (\\<sigma> (g, length ss));\n                          cf = c (f, length ts); cg = c (g, length ss)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). Fun f ts \\<succ> ss ! i\n  ns1\n  c (f, length ts) = Mul\n  c (g, length ss) = Mul", "have mul: \"fst (mul_ext wpo (map ((!) ts) (\\<sigma> ?f)) (map ((!) ss) (\\<sigma> ?g)))\""], ["proof (prove)\nusing this:\n  \\<not> s1\n  \\<not> (\\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss)\n  fst (if \\<exists>i\\<in>set (\\<sigma> (f, length ts)).\n             ts ! i \\<succeq> Fun g ss\n       then (True, True)\n       else if ns1 \\<and>\n               (\\<forall>j\\<in>set (\\<sigma> (g, length ss)).\n                   Fun f ts \\<succ> ss ! j)\n            then if s1 then (True, True)\n                 else let ss' = map ((!) ts) (\\<sigma> (f, length ts));\n                          ts' = map ((!) ss) (\\<sigma> (g, length ss));\n                          cf = c (f, length ts); cg = c (g, length ss)\n                      in if cf = Lex \\<and> cg = Lex\n                         then lex_ext wpo n ss' ts'\n                         else if cf = Mul \\<and> cg = Mul\n                              then mul_ext wpo ss' ts'\n                              else (length ss' \\<noteq> 0 \\<and>\n                                    length ts' = 0,\n                                    length ts' = 0)\n            else (False, False))\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). Fun f ts \\<succ> ss ! i\n  ns1\n  c (f, length ts) = Mul\n  c (g, length ss) = Mul\n\ngoal (1 subgoal):\n 1. fst (mul_ext wpo (map ((!) ts) (\\<sigma> (f, length ts)))\n          (map ((!) ss) (\\<sigma> (g, length ss))))", "by auto"], ["proof (state)\nthis:\n  fst (mul_ext wpo (map ((!) ts) (\\<sigma> (f, length ts)))\n        (map ((!) ss) (\\<sigma> (g, length ss))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "from False mul ts f_ge_g Mul"], ["proof (chain)\npicking this:\n  \\<not> s1\n  fst (mul_ext wpo (map ((!) ts) (\\<sigma> (f, length ts)))\n        (map ((!) ss) (\\<sigma> (g, length ss))))\n  \\<forall>i\\<in>set (\\<sigma> (f, length ts)). SN_on WPO_S {ts ! i}\n  ns1\n  c (f, length ts) = Mul\n  c (g, length ss) = Mul", "have \"((f,ts),(g,ss)) \\<in> ?r\""], ["proof (prove)\nusing this:\n  \\<not> s1\n  fst (mul_ext wpo (map ((!) ts) (\\<sigma> (f, length ts)))\n        (map ((!) ss) (\\<sigma> (g, length ss))))\n  \\<forall>i\\<in>set (\\<sigma> (f, length ts)). SN_on WPO_S {ts ! i}\n  ns1\n  c (f, length ts) = Mul\n  c (g, length ss) = Mul\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> {(a, b).\n           (case a of\n            (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n            case b of\n            (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n           \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                  {((f, ab), g, ab').\n                   (c f = c g \\<longrightarrow>\n                    (\\<forall>i\\<in>set (\\<sigma> f).\n                        SN_on WPO_S {ab ! i}) \\<and>\n                    (c f = Mul \\<longrightarrow>\n                     fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                           (map ((!) ab') (\\<sigma> g)))) \\<and>\n                    (c f = Lex \\<longrightarrow>\n                     fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                           (map ((!) ab') (\\<sigma> g))))) \\<and>\n                   (c f \\<noteq> c g \\<longrightarrow>\n                    map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                    map ((!) ab') (\\<sigma> g) = [])}}", "by (simp add: prc1)"], ["proof (state)\nthis:\n  ((f, ts), g, ss)\n  \\<in> {(a, b).\n         (case a of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n          case b of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n         \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                {((f, ab), g, ab').\n                 (c f = c g \\<longrightarrow>\n                  (\\<forall>i\\<in>set (\\<sigma> f).\n                      SN_on WPO_S {ab ! i}) \\<and>\n                  (c f = Mul \\<longrightarrow>\n                   fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g)))) \\<and>\n                  (c f = Lex \\<longrightarrow>\n                   fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g))))) \\<and>\n                 (c f \\<noteq> c g \\<longrightarrow>\n                  map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                  map ((!) ab') (\\<sigma> g) = [])}}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with t_NS_s"], ["proof (chain)\npicking this:\n  (Fun f ts, Fun g ss) \\<in> NS\n  ((f, ts), g, ss)\n  \\<in> {(a, b).\n         (case a of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n          case b of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n         \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                {((f, ab), g, ab').\n                 (c f = c g \\<longrightarrow>\n                  (\\<forall>i\\<in>set (\\<sigma> f).\n                      SN_on WPO_S {ab ! i}) \\<and>\n                  (c f = Mul \\<longrightarrow>\n                   fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g)))) \\<and>\n                  (c f = Lex \\<longrightarrow>\n                   fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g))))) \\<and>\n                 (c f \\<noteq> c g \\<longrightarrow>\n                  map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                  map ((!) ab') (\\<sigma> g) = [])}}", "have \"((f,ts),(g,ss)) \\<in> ?rrr\""], ["proof (prove)\nusing this:\n  (Fun f ts, Fun g ss) \\<in> NS\n  ((f, ts), g, ss)\n  \\<in> {(a, b).\n         (case a of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n          case b of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n         \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                {((f, ab), g, ab').\n                 (c f = c g \\<longrightarrow>\n                  (\\<forall>i\\<in>set (\\<sigma> f).\n                      SN_on WPO_S {ab ! i}) \\<and>\n                  (c f = Mul \\<longrightarrow>\n                   fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g)))) \\<and>\n                  (c f = Lex \\<longrightarrow>\n                   fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g))))) \\<and>\n                 (c f \\<noteq> c g \\<longrightarrow>\n                  map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                  map ((!) ab') (\\<sigma> g) = [])}}\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))", "unfolding rr_def"], ["proof (prove)\nusing this:\n  (Fun f ts, Fun g ss) \\<in> NS\n  ((f, ts), g, ss)\n  \\<in> {(a, b).\n         (case a of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n          case b of\n          (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n         \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                {((f, ab), g, ab').\n                 (c f = c g \\<longrightarrow>\n                  (\\<forall>i\\<in>set (\\<sigma> f).\n                      SN_on WPO_S {ab ! i}) \\<and>\n                  (c f = Mul \\<longrightarrow>\n                   fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g)))) \\<and>\n                  (c f = Lex \\<longrightarrow>\n                   fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                         (map ((!) ab') (\\<sigma> g))))) \\<and>\n                 (c f \\<noteq> c g \\<longrightarrow>\n                  map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                  map ((!) ab') (\\<sigma> g) = [])}}\n\ngoal (1 subgoal):\n 1. ((f, ts), g, ss)\n    \\<in> inv_image\n           (lex_two S NS\n             {(a, b).\n              (case a of\n               (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts),\n               case b of\n               (f, ts) \\<Rightarrow> ((f, length ts), (f, length ts), ts))\n              \\<in> lex_two {(f, g). fst (prc f g)} {(f, g). snd (prc f g)}\n                     {((f, ab), g, ab').\n                      (c f = c g \\<longrightarrow>\n                       (\\<forall>i\\<in>set (\\<sigma> f).\n                           SN_on WPO_S {ab ! i}) \\<and>\n                       (c f = Mul \\<longrightarrow>\n                        fst (mul_ext wpo (map ((!) ab) (\\<sigma> f))\n                              (map ((!) ab') (\\<sigma> g)))) \\<and>\n                       (c f = Lex \\<longrightarrow>\n                        fst (lex_ext wpo n (map ((!) ab) (\\<sigma> f))\n                              (map ((!) ab') (\\<sigma> g))))) \\<and>\n                      (c f \\<noteq> c g \\<longrightarrow>\n                       map ((!) ab) (\\<sigma> f) \\<noteq> [] \\<and>\n                       map ((!) ab') (\\<sigma> g) = [])}})\n           (\\<lambda>(f, ts). (Fun f ts, f, ts))", "by auto"], ["proof (state)\nthis:\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with ind"], ["proof (chain)\npicking this:\n  ((f, ts), ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))", "have \"?ind (g,ss)\""], ["proof (prove)\nusing this:\n  ((f, ts), ?gss1)\n  \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts)) \\<Longrightarrow>\n  case ?gss1 of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ((f, ts), g, ss) \\<in> inv_image rr (\\<lambda>(f, ts). (Fun f ts, f, ts))\n\ngoal (1 subgoal):\n 1. case (g, ss) of\n    (f, ts) \\<Rightarrow>\n      (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n          SN_on WPO_S {ts ! i}) \\<longrightarrow>\n      SN_on WPO_S {Fun f ts}", "by auto"], ["proof (state)\nthis:\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c (f, length ts) = Mul; c (g, length ss) = Mul\\<rbrakk>\n    \\<Longrightarrow> SN_on WPO_S {Fun g ss}", "with ss_S"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). SN_on WPO_S {ss ! i}\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (\\<sigma> (g, length ss)). SN_on WPO_S {ss ! i}\n  case (g, ss) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun g ss}", "by auto"], ["proof (state)\nthis:\n  SN_on WPO_S {Fun g ss}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SN_on WPO_S {Fun g ss}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SN_on WPO_S {Fun g ss}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SN_on WPO_S {Fun g ss}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SN_on WPO_S {Fun g ss}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SN_on WPO_S {s}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SN_on WPO_S {Fun f ts}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case fts of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case (f, ts) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           SN_on WPO_S {x2a}) \\<Longrightarrow>\n       SN_on WPO_S {Fun x1a x2}", "with Fun"], ["proof (chain)\npicking this:\n  ?x2a \\<in> set ts \\<Longrightarrow> SN_on WPO_S {?x2a}\n  case (f, ts) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}", "show ?case"], ["proof (prove)\nusing this:\n  ?x2a \\<in> set ts \\<Longrightarrow> SN_on WPO_S {?x2a}\n  case (f, ts) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun f ts}", "using \\<sigma>E[of _ f ts]"], ["proof (prove)\nusing this:\n  ?x2a \\<in> set ts \\<Longrightarrow> SN_on WPO_S {?x2a}\n  case (f, ts) of\n  (f, ts) \\<Rightarrow>\n    (\\<forall>i\\<in>set (\\<sigma> (f, length ts)).\n        SN_on WPO_S {ts ! i}) \\<longrightarrow>\n    SN_on WPO_S {Fun f ts}\n  ?i \\<in> set (\\<sigma> (f, length ts)) \\<Longrightarrow>\n  ts ! ?i \\<in> set ts\n\ngoal (1 subgoal):\n 1. SN_on WPO_S {Fun f ts}", "by simp"], ["proof (state)\nthis:\n  SN_on WPO_S {Fun f ts}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SN_on WPO_S {t}\n\ngoal (1 subgoal):\n 1. SN WPO_S", "}"], ["proof (state)\nthis:\n  SN_on WPO_S {?t2}\n\ngoal (1 subgoal):\n 1. SN WPO_S", "from SN_I[OF this]"], ["proof (chain)\npicking this:\n  SN WPO_S", "show \"SN {(s::('f, 'v)term, t). fst (wpo s t)}\""], ["proof (prove)\nusing this:\n  SN WPO_S\n\ngoal (1 subgoal):\n 1. SN WPO_S", "."], ["proof (state)\nthis:\n  SN WPO_S\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem WPO_SN_order_pair: \"SN_order_pair WPO_S WPO_NS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN_order_pair WPO_S WPO_NS", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. refl WPO_NS\n 2. trans WPO_S\n 3. trans WPO_NS\n 4. WPO_NS O WPO_S \\<subseteq> WPO_S\n 5. WPO_S O WPO_NS \\<subseteq> WPO_S\n 6. SN WPO_S", "show \"refl WPO_NS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl WPO_NS", "using wpo_ns_refl"], ["proof (prove)\nusing this:\n  ?s \\<succeq> ?s\n\ngoal (1 subgoal):\n 1. refl WPO_NS", "unfolding refl_on_def"], ["proof (prove)\nusing this:\n  ?s \\<succeq> ?s\n\ngoal (1 subgoal):\n 1. WPO_NS \\<subseteq> UNIV \\<times> UNIV \\<and>\n    (\\<forall>x\\<in>UNIV. (x, x) \\<in> WPO_NS)", "by auto"], ["proof (state)\nthis:\n  refl WPO_NS\n\ngoal (5 subgoals):\n 1. trans WPO_S\n 2. trans WPO_NS\n 3. WPO_NS O WPO_S \\<subseteq> WPO_S\n 4. WPO_S O WPO_NS \\<subseteq> WPO_S\n 5. SN WPO_S", "show \"trans WPO_NS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans WPO_NS", "using wpo_compat"], ["proof (prove)\nusing this:\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n\ngoal (1 subgoal):\n 1. trans WPO_NS", "unfolding trans_def"], ["proof (prove)\nusing this:\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> WPO_NS \\<longrightarrow>\n       (y, z) \\<in> WPO_NS \\<longrightarrow> (x, z) \\<in> WPO_NS", "by blast"], ["proof (state)\nthis:\n  trans WPO_NS\n\ngoal (4 subgoals):\n 1. trans WPO_S\n 2. WPO_NS O WPO_S \\<subseteq> WPO_S\n 3. WPO_S O WPO_NS \\<subseteq> WPO_S\n 4. SN WPO_S", "show \"trans WPO_S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans WPO_S", "using wpo_compat wpo_s_imp_ns"], ["proof (prove)\nusing this:\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n\ngoal (1 subgoal):\n 1. trans WPO_S", "unfolding trans_def"], ["proof (prove)\nusing this:\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> WPO_S \\<longrightarrow>\n       (y, z) \\<in> WPO_S \\<longrightarrow> (x, z) \\<in> WPO_S", "by blast"], ["proof (state)\nthis:\n  trans WPO_S\n\ngoal (3 subgoals):\n 1. WPO_NS O WPO_S \\<subseteq> WPO_S\n 2. WPO_S O WPO_NS \\<subseteq> WPO_S\n 3. SN WPO_S", "show \"WPO_NS O WPO_S \\<subseteq> WPO_S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WPO_NS O WPO_S \\<subseteq> WPO_S", "using wpo_compat"], ["proof (prove)\nusing this:\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n\ngoal (1 subgoal):\n 1. WPO_NS O WPO_S \\<subseteq> WPO_S", "by blast"], ["proof (state)\nthis:\n  WPO_NS O WPO_S \\<subseteq> WPO_S\n\ngoal (2 subgoals):\n 1. WPO_S O WPO_NS \\<subseteq> WPO_S\n 2. SN WPO_S", "show \"WPO_S O WPO_NS \\<subseteq> WPO_S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WPO_S O WPO_NS \\<subseteq> WPO_S", "using wpo_compat"], ["proof (prove)\nusing this:\n  (?s \\<succeq> ?t \\<and> ?t \\<succ> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succ> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow>\n   ?s \\<succ> ?u) \\<and>\n  (?s \\<succeq> ?t \\<and> ?t \\<succeq> ?u \\<longrightarrow> ?s \\<succeq> ?u)\n\ngoal (1 subgoal):\n 1. WPO_S O WPO_NS \\<subseteq> WPO_S", "by blast"], ["proof (state)\nthis:\n  WPO_S O WPO_NS \\<subseteq> WPO_S\n\ngoal (1 subgoal):\n 1. SN WPO_S", "show \"SN WPO_S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN WPO_S", "using WPO_S_SN"], ["proof (prove)\nusing this:\n  SN WPO_S\n\ngoal (1 subgoal):\n 1. SN WPO_S", "."], ["proof (state)\nthis:\n  SN WPO_S\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem WPO_S_subst: \"(s,t) \\<in> WPO_S \\<Longrightarrow> (s \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>) \\<in> WPO_S\" for \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, t) \\<in> WPO_S \\<Longrightarrow>\n    (s \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>) \\<in> WPO_S", "using wpo_stable"], ["proof (prove)\nusing this:\n  (?s \\<succ> ?t \\<longrightarrow>\n   ?s \\<cdot> ?\\<delta> \\<succ> ?t \\<cdot> ?\\<delta>) \\<and>\n  (?s \\<succeq> ?t \\<longrightarrow>\n   ?s \\<cdot> ?\\<delta> \\<succeq> ?t \\<cdot> ?\\<delta>)\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> WPO_S \\<Longrightarrow>\n    (s \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>) \\<in> WPO_S", "by auto"], ["", "theorem WPO_NS_subst: \"(s,t) \\<in> WPO_NS \\<Longrightarrow> (s \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>) \\<in> WPO_NS\" for \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, t) \\<in> WPO_NS \\<Longrightarrow>\n    (s \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>) \\<in> WPO_NS", "using wpo_stable"], ["proof (prove)\nusing this:\n  (?s \\<succ> ?t \\<longrightarrow>\n   ?s \\<cdot> ?\\<delta> \\<succ> ?t \\<cdot> ?\\<delta>) \\<and>\n  (?s \\<succeq> ?t \\<longrightarrow>\n   ?s \\<cdot> ?\\<delta> \\<succeq> ?t \\<cdot> ?\\<delta>)\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> WPO_NS \\<Longrightarrow>\n    (s \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>) \\<in> WPO_NS", "by auto"], ["", "theorem WPO_NS_ctxt: \"(s,t) \\<in> WPO_NS \\<Longrightarrow> (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> WPO_NS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, t) \\<in> WPO_NS \\<Longrightarrow>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> WPO_NS", "using wpo_ns_mono"], ["proof (prove)\nusing this:\n  ?s \\<succeq> ?t \\<Longrightarrow>\n  Fun ?f (?bef @ ?s # ?aft) \\<succeq> Fun ?f (?bef @ ?t # ?aft)\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> WPO_NS \\<Longrightarrow>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> WPO_NS", "by blast"], ["", "theorem WPO_S_subset_WPO_NS: \"WPO_S \\<subseteq> WPO_NS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WPO_S \\<subseteq> WPO_NS", "using wpo_s_imp_ns"], ["proof (prove)\nusing this:\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n\ngoal (1 subgoal):\n 1. WPO_S \\<subseteq> WPO_NS", "by blast"], ["", "context (* if \\<sigma> is the full status, then WPO_S is a simplification order *)\n  assumes \\<sigma>_full: \"\\<And> f k. set (\\<sigma> (f,k)) = {0 ..< k}\"\nbegin"], ["", "lemma subterm_wpo_s: \"s \\<rhd> t \\<Longrightarrow> s \\<succ> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<rhd> t \\<Longrightarrow> s \\<succ> t", "proof (induct s t rule: supt.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s ss f. s \\<in> set ss \\<Longrightarrow> Fun f ss \\<succ> s\n 2. \\<And>s ss t f.\n       \\<lbrakk>s \\<in> set ss; s \\<rhd> t; s \\<succ> t\\<rbrakk>\n       \\<Longrightarrow> Fun f ss \\<succ> t", "case (arg s ss f)"], ["proof (state)\nthis:\n  s \\<in> set ss\n\ngoal (2 subgoals):\n 1. \\<And>s ss f. s \\<in> set ss \\<Longrightarrow> Fun f ss \\<succ> s\n 2. \\<And>s ss t f.\n       \\<lbrakk>s \\<in> set ss; s \\<rhd> t; s \\<succ> t\\<rbrakk>\n       \\<Longrightarrow> Fun f ss \\<succ> t", "from arg[unfolded set_conv_nth]"], ["proof (chain)\npicking this:\n  s \\<in> {ss ! i |i. i < length ss}", "obtain i where i: \"i < length ss\" and s: \"s = ss ! i\""], ["proof (prove)\nusing this:\n  s \\<in> {ss ! i |i. i < length ss}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length ss; s = ss ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length ss\n  s = ss ! i\n\ngoal (2 subgoals):\n 1. \\<And>s ss f. s \\<in> set ss \\<Longrightarrow> Fun f ss \\<succ> s\n 2. \\<And>s ss t f.\n       \\<lbrakk>s \\<in> set ss; s \\<rhd> t; s \\<succ> t\\<rbrakk>\n       \\<Longrightarrow> Fun f ss \\<succ> t", "from \\<sigma>_full[of f \"length ss\"] i"], ["proof (chain)\npicking this:\n  set (\\<sigma> (f, length ss)) = {0..<length ss}\n  i < length ss", "have ii: \"i \\<in> set (\\<sigma> (f,length ss))\""], ["proof (prove)\nusing this:\n  set (\\<sigma> (f, length ss)) = {0..<length ss}\n  i < length ss\n\ngoal (1 subgoal):\n 1. i \\<in> set (\\<sigma> (f, length ss))", "by auto"], ["proof (state)\nthis:\n  i \\<in> set (\\<sigma> (f, length ss))\n\ngoal (2 subgoals):\n 1. \\<And>s ss f. s \\<in> set ss \\<Longrightarrow> Fun f ss \\<succ> s\n 2. \\<And>s ss t f.\n       \\<lbrakk>s \\<in> set ss; s \\<rhd> t; s \\<succ> t\\<rbrakk>\n       \\<Longrightarrow> Fun f ss \\<succ> t", "from subterm_wpo_s_arg[OF ii] s"], ["proof (chain)\npicking this:\n  Fun f ss \\<succ> ss ! i\n  s = ss ! i", "show ?case"], ["proof (prove)\nusing this:\n  Fun f ss \\<succ> ss ! i\n  s = ss ! i\n\ngoal (1 subgoal):\n 1. Fun f ss \\<succ> s", "by auto"], ["proof (state)\nthis:\n  Fun f ss \\<succ> s\n\ngoal (1 subgoal):\n 1. \\<And>s ss t f.\n       \\<lbrakk>s \\<in> set ss; s \\<rhd> t; s \\<succ> t\\<rbrakk>\n       \\<Longrightarrow> Fun f ss \\<succ> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s ss t f.\n       \\<lbrakk>s \\<in> set ss; s \\<rhd> t; s \\<succ> t\\<rbrakk>\n       \\<Longrightarrow> Fun f ss \\<succ> t", "case (subt s ss t f)"], ["proof (state)\nthis:\n  s \\<in> set ss\n  s \\<rhd> t\n  s \\<succ> t\n\ngoal (1 subgoal):\n 1. \\<And>s ss t f.\n       \\<lbrakk>s \\<in> set ss; s \\<rhd> t; s \\<succ> t\\<rbrakk>\n       \\<Longrightarrow> Fun f ss \\<succ> t", "from subt wpo_s_imp_ns"], ["proof (chain)\npicking this:\n  s \\<in> set ss\n  s \\<rhd> t\n  s \\<succ> t\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t", "have \"\\<exists> s \\<in> set ss. wpo_ns s t\""], ["proof (prove)\nusing this:\n  s \\<in> set ss\n  s \\<rhd> t\n  s \\<succ> t\n  ?s \\<succ> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>set ss. s \\<succeq> t", "by blast"], ["proof (state)\nthis:\n  \\<exists>s\\<in>set ss. s \\<succeq> t\n\ngoal (1 subgoal):\n 1. \\<And>s ss t f.\n       \\<lbrakk>s \\<in> set ss; s \\<rhd> t; s \\<succ> t\\<rbrakk>\n       \\<Longrightarrow> Fun f ss \\<succ> t", "from this[unfolded set_conv_nth]"], ["proof (chain)\npicking this:\n  \\<exists>s\\<in>{ss ! i |i. i < length ss}. s \\<succeq> t", "obtain i where ns: \"ss ! i \\<succeq> t\" and i: \"i < length ss\""], ["proof (prove)\nusing this:\n  \\<exists>s\\<in>{ss ! i |i. i < length ss}. s \\<succeq> t\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>ss ! i \\<succeq> t; i < length ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ss ! i \\<succeq> t\n  i < length ss\n\ngoal (1 subgoal):\n 1. \\<And>s ss t f.\n       \\<lbrakk>s \\<in> set ss; s \\<rhd> t; s \\<succ> t\\<rbrakk>\n       \\<Longrightarrow> Fun f ss \\<succ> t", "from \\<sigma>_full[of f \"length ss\"] i"], ["proof (chain)\npicking this:\n  set (\\<sigma> (f, length ss)) = {0..<length ss}\n  i < length ss", "have ii: \"i \\<in> set (\\<sigma> (f,length ss))\""], ["proof (prove)\nusing this:\n  set (\\<sigma> (f, length ss)) = {0..<length ss}\n  i < length ss\n\ngoal (1 subgoal):\n 1. i \\<in> set (\\<sigma> (f, length ss))", "by auto"], ["proof (state)\nthis:\n  i \\<in> set (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. \\<And>s ss t f.\n       \\<lbrakk>s \\<in> set ss; s \\<rhd> t; s \\<succ> t\\<rbrakk>\n       \\<Longrightarrow> Fun f ss \\<succ> t", "from subt"], ["proof (chain)\npicking this:\n  s \\<in> set ss\n  s \\<rhd> t\n  s \\<succ> t", "have \"Fun f ss \\<unrhd> t\""], ["proof (prove)\nusing this:\n  s \\<in> set ss\n  s \\<rhd> t\n  s \\<succ> t\n\ngoal (1 subgoal):\n 1. Fun f ss \\<unrhd> t", "by auto"], ["proof (state)\nthis:\n  Fun f ss \\<unrhd> t\n\ngoal (1 subgoal):\n 1. \\<And>s ss t f.\n       \\<lbrakk>s \\<in> set ss; s \\<rhd> t; s \\<succ> t\\<rbrakk>\n       \\<Longrightarrow> Fun f ss \\<succ> t", "from NS_subterm[OF \\<sigma>_full this] ns ii"], ["proof (chain)\npicking this:\n  (Fun f ss, t) \\<in> NS\n  ss ! i \\<succeq> t\n  i \\<in> set (\\<sigma> (f, length ss))", "show ?case"], ["proof (prove)\nusing this:\n  (Fun f ss, t) \\<in> NS\n  ss ! i \\<succeq> t\n  i \\<in> set (\\<sigma> (f, length ss))\n\ngoal (1 subgoal):\n 1. Fun f ss \\<succ> t", "by (auto simp: wpo.simps)"], ["proof (state)\nthis:\n  Fun f ss \\<succ> t\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Compatibility of the subterm relation with the order relation:\n    a subterm is smaller *)"], ["", "lemma subterm_wpo_ns: assumes supteq: \"s \\<unrhd> t\" shows \"s \\<succeq> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<succeq> t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<succeq> t", "from supteq"], ["proof (chain)\npicking this:\n  s \\<unrhd> t", "have \"s = t \\<or> s \\<rhd> t\""], ["proof (prove)\nusing this:\n  s \\<unrhd> t\n\ngoal (1 subgoal):\n 1. s = t \\<or> s \\<rhd> t", "by auto"], ["proof (state)\nthis:\n  s = t \\<or> s \\<rhd> t\n\ngoal (1 subgoal):\n 1. s \\<succeq> t", "then"], ["proof (chain)\npicking this:\n  s = t \\<or> s \\<rhd> t", "show ?thesis"], ["proof (prove)\nusing this:\n  s = t \\<or> s \\<rhd> t\n\ngoal (1 subgoal):\n 1. s \\<succeq> t", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s = t \\<Longrightarrow> s \\<succeq> t\n 2. s \\<rhd> t \\<Longrightarrow> s \\<succeq> t", "assume \"s = t\""], ["proof (state)\nthis:\n  s = t\n\ngoal (2 subgoals):\n 1. s = t \\<Longrightarrow> s \\<succeq> t\n 2. s \\<rhd> t \\<Longrightarrow> s \\<succeq> t", "then"], ["proof (chain)\npicking this:\n  s = t", "show ?thesis"], ["proof (prove)\nusing this:\n  s = t\n\ngoal (1 subgoal):\n 1. s \\<succeq> t", "using wpo_ns_refl"], ["proof (prove)\nusing this:\n  s = t\n  ?s \\<succeq> ?s\n\ngoal (1 subgoal):\n 1. s \\<succeq> t", "by blast"], ["proof (state)\nthis:\n  s \\<succeq> t\n\ngoal (1 subgoal):\n 1. s \\<rhd> t \\<Longrightarrow> s \\<succeq> t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<rhd> t \\<Longrightarrow> s \\<succeq> t", "assume \"s \\<rhd> t\""], ["proof (state)\nthis:\n  s \\<rhd> t\n\ngoal (1 subgoal):\n 1. s \\<rhd> t \\<Longrightarrow> s \\<succeq> t", "from wpo_s_imp_ns[OF subterm_wpo_s[OF this]]"], ["proof (chain)\npicking this:\n  s \\<succeq> t", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<succeq> t\n\ngoal (1 subgoal):\n 1. s \\<succeq> t", "."], ["proof (state)\nthis:\n  s \\<succeq> t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<succeq> t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wpo_s_mono: assumes rels: \"s \\<succ> t\"\n  shows \"Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?ss = \"bef @ s # aft\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?ts = \"bef @ t # aft\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?s = \"Fun f ?ss\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?t = \"Fun f ?ts\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?len = \"Suc (length bef + length aft)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?f = \"(f, ?len)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?\\<sigma> = \"\\<sigma> ?f\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "from wpo_s_imp_ns[OF rels]"], ["proof (chain)\npicking this:\n  s \\<succeq> t", "have rel: \"wpo_ns s t\""], ["proof (prove)\nusing this:\n  s \\<succeq> t\n\ngoal (1 subgoal):\n 1. s \\<succeq> t", "."], ["proof (state)\nthis:\n  s \\<succeq> t\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "from wpo_ns_pre_mono[OF rel]"], ["proof (chain)\npicking this:\n  (\\<forall>j\\<in>set (\\<sigma> (?f, Suc (length ?bef + length ?aft))).\n      Fun ?f (?bef @ s # ?aft) \\<succ> (?bef @ t # ?aft) ! j) \\<and>\n  (Fun ?f (?bef @ s # ?aft), Fun ?f (?bef @ t # ?aft)) \\<in> NS \\<and>\n  (\\<forall>i<length (\\<sigma> (?f, Suc (length ?bef + length ?aft))).\n      map ((!) (?bef @ s # ?aft))\n       (\\<sigma> (?f, Suc (length ?bef + length ?aft))) !\n      i \\<succeq>\n      map ((!) (?bef @ t # ?aft))\n       (\\<sigma> (?f, Suc (length ?bef + length ?aft))) !\n      i)", "have id: \"(\\<forall>j\\<in>set ?\\<sigma>. wpo_s ?s ((bef @ t # aft) ! j)) = True\" \n    \"((?s,?t) \\<in> NS) = True\" \n    \"length ?ss = ?len\" \"length ?ts = ?len\""], ["proof (prove)\nusing this:\n  (\\<forall>j\\<in>set (\\<sigma> (?f, Suc (length ?bef + length ?aft))).\n      Fun ?f (?bef @ s # ?aft) \\<succ> (?bef @ t # ?aft) ! j) \\<and>\n  (Fun ?f (?bef @ s # ?aft), Fun ?f (?bef @ t # ?aft)) \\<in> NS \\<and>\n  (\\<forall>i<length (\\<sigma> (?f, Suc (length ?bef + length ?aft))).\n      map ((!) (?bef @ s # ?aft))\n       (\\<sigma> (?f, Suc (length ?bef + length ?aft))) !\n      i \\<succeq>\n      map ((!) (?bef @ t # ?aft))\n       (\\<sigma> (?f, Suc (length ?bef + length ?aft))) !\n      i)\n\ngoal (1 subgoal):\n 1. ((\\<forall>j\\<in>set (\\<sigma> (f, Suc (length bef + length aft))).\n         Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) =\n     True &&&\n     ((Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS) = True) &&&\n    length (bef @ s # aft) = Suc (length bef + length aft) &&&\n    length (bef @ t # aft) = Suc (length bef + length aft)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>j\\<in>set (\\<sigma> (f, Suc (length bef + length aft))).\n      Fun f (bef @ s # aft) \\<succ> (bef @ t # aft) ! j) =\n  True\n  ((Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> NS) = True\n  length (bef @ s # aft) = Suc (length bef + length aft)\n  length (bef @ t # aft) = Suc (length bef + length aft)\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?lb = \"length bef\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "from \\<sigma>_full[of f ?len]"], ["proof (chain)\npicking this:\n  set (\\<sigma> (f, Suc (length bef + length aft))) =\n  {0..<Suc (length bef + length aft)}", "have lb_mem: \"?lb \\<in> set ?\\<sigma>\""], ["proof (prove)\nusing this:\n  set (\\<sigma> (f, Suc (length bef + length aft))) =\n  {0..<Suc (length bef + length aft)}\n\ngoal (1 subgoal):\n 1. length bef \\<in> set (\\<sigma> (f, Suc (length bef + length aft)))", "by auto"], ["proof (state)\nthis:\n  length bef \\<in> set (\\<sigma> (f, Suc (length bef + length aft)))\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "then"], ["proof (chain)\npicking this:\n  length bef \\<in> set (\\<sigma> (f, Suc (length bef + length aft)))", "obtain i where \\<sigma>i: \"?\\<sigma> ! i = ?lb\" and i: \"i < length ?\\<sigma>\""], ["proof (prove)\nusing this:\n  length bef \\<in> set (\\<sigma> (f, Suc (length bef + length aft)))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>\\<sigma> (f, Suc (length bef + length aft)) ! i =\n                 length bef;\n         i < length (\\<sigma> (f, Suc (length bef + length aft)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  length bef\n  \\<in> {\\<sigma> (f, Suc (length bef + length aft)) ! i |i.\n         i < length (\\<sigma> (f, Suc (length bef + length aft)))}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>\\<sigma> (f, Suc (length bef + length aft)) ! i =\n                 length bef;\n         i < length (\\<sigma> (f, Suc (length bef + length aft)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  \\<sigma> (f, Suc (length bef + length aft)) ! i = length bef\n  i < length (\\<sigma> (f, Suc (length bef + length aft)))\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?mss = \"map ((!) ?ss) ?\\<sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?mts = \"map ((!) ?ts) ?\\<sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "have \"fst (lex_ext wpo n ?mss ?mts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (lex_ext wpo n\n          (map ((!) (bef @ s # aft))\n            (\\<sigma> (f, Suc (length bef + length aft))))\n          (map ((!) (bef @ t # aft))\n            (\\<sigma> (f, Suc (length bef + length aft)))))", "unfolding lex_ext_iff fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length\n      (map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft)))) =\n     length\n      (map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft)))) \\<or>\n     length\n      (map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))))\n     \\<le> n) \\<and>\n    ((\\<exists>i<length\n                  (map ((!) (bef @ s # aft))\n                    (\\<sigma> (f, Suc (length bef + length aft)))).\n         i < length\n              (map ((!) (bef @ t # aft))\n                (\\<sigma> (f, Suc (length bef + length aft)))) \\<and>\n         (\\<forall>j<i.\n             map ((!) (bef @ s # aft))\n              (\\<sigma> (f, Suc (length bef + length aft))) !\n             j \\<succeq>\n             map ((!) (bef @ t # aft))\n              (\\<sigma> (f, Suc (length bef + length aft))) !\n             j) \\<and>\n         map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))) !\n         i \\<succ>\n         map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))) !\n         i) \\<or>\n     (\\<forall>i<length\n                  (map ((!) (bef @ t # aft))\n                    (\\<sigma> (f, Suc (length bef + length aft)))).\n         map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))) !\n         i \\<succeq>\n         map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))) !\n         i) \\<and>\n     length\n      (map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))))\n     < length\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))", "proof (intro conjI, force, rule disjI1, unfold length_map id, intro exI conjI, rule i, rule i, \n      intro allI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       j < i \\<Longrightarrow>\n       map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       j \\<succeq>\n       map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       j\n 2. map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succ>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i", "show \"wpo_s (?mss ! i) (?mts ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succ>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i", "using \\<sigma>i i rels"], ["proof (prove)\nusing this:\n  \\<sigma> (f, Suc (length bef + length aft)) ! i = length bef\n  i < length (\\<sigma> (f, Suc (length bef + length aft)))\n  s \\<succ> t\n\ngoal (1 subgoal):\n 1. map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i \\<succ>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    i", "by simp"], ["proof (state)\nthis:\n  map ((!) (bef @ s # aft)) (\\<sigma> (f, Suc (length bef + length aft))) !\n  i \\<succ>\n  map ((!) (bef @ t # aft)) (\\<sigma> (f, Suc (length bef + length aft))) !\n  i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < i \\<Longrightarrow>\n       map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       j \\<succeq>\n       map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < i \\<Longrightarrow>\n       map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       j \\<succeq>\n       map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       j", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < i \\<Longrightarrow>\n       map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       j \\<succeq>\n       map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       j", "assume \"j < i\""], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < i \\<Longrightarrow>\n       map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       j \\<succeq>\n       map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       j", "with i"], ["proof (chain)\npicking this:\n  i < length (\\<sigma> (f, Suc (length bef + length aft)))\n  j < i", "have j: \"j < length ?\\<sigma>\""], ["proof (prove)\nusing this:\n  i < length (\\<sigma> (f, Suc (length bef + length aft)))\n  j < i\n\ngoal (1 subgoal):\n 1. j < length (\\<sigma> (f, Suc (length bef + length aft)))", "by auto"], ["proof (state)\nthis:\n  j < length (\\<sigma> (f, Suc (length bef + length aft)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < i \\<Longrightarrow>\n       map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       j \\<succeq>\n       map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft))) !\n       j", "with wpo_ns_pre_mono[OF rel]"], ["proof (chain)\npicking this:\n  (\\<forall>j\\<in>set (\\<sigma> (?f, Suc (length ?bef + length ?aft))).\n      Fun ?f (?bef @ s # ?aft) \\<succ> (?bef @ t # ?aft) ! j) \\<and>\n  (Fun ?f (?bef @ s # ?aft), Fun ?f (?bef @ t # ?aft)) \\<in> NS \\<and>\n  (\\<forall>i<length (\\<sigma> (?f, Suc (length ?bef + length ?aft))).\n      map ((!) (?bef @ s # ?aft))\n       (\\<sigma> (?f, Suc (length ?bef + length ?aft))) !\n      i \\<succeq>\n      map ((!) (?bef @ t # ?aft))\n       (\\<sigma> (?f, Suc (length ?bef + length ?aft))) !\n      i)\n  j < length (\\<sigma> (f, Suc (length bef + length aft)))", "show \"?mss ! j \\<succeq> ?mts ! j\""], ["proof (prove)\nusing this:\n  (\\<forall>j\\<in>set (\\<sigma> (?f, Suc (length ?bef + length ?aft))).\n      Fun ?f (?bef @ s # ?aft) \\<succ> (?bef @ t # ?aft) ! j) \\<and>\n  (Fun ?f (?bef @ s # ?aft), Fun ?f (?bef @ t # ?aft)) \\<in> NS \\<and>\n  (\\<forall>i<length (\\<sigma> (?f, Suc (length ?bef + length ?aft))).\n      map ((!) (?bef @ s # ?aft))\n       (\\<sigma> (?f, Suc (length ?bef + length ?aft))) !\n      i \\<succeq>\n      map ((!) (?bef @ t # ?aft))\n       (\\<sigma> (?f, Suc (length ?bef + length ?aft))) !\n      i)\n  j < length (\\<sigma> (f, Suc (length bef + length aft)))\n\ngoal (1 subgoal):\n 1. map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    j \\<succeq>\n    map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft))) !\n    j", "by blast"], ["proof (state)\nthis:\n  map ((!) (bef @ s # aft)) (\\<sigma> (f, Suc (length bef + length aft))) !\n  j \\<succeq>\n  map ((!) (bef @ t # aft)) (\\<sigma> (f, Suc (length bef + length aft))) !\n  j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (lex_ext wpo n\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "moreover"], ["proof (state)\nthis:\n  fst (lex_ext wpo n\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "obtain lb nlb where part: \"partition ((=) ?lb) ?\\<sigma> = (lb, nlb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb nlb.\n        partition ((=) (length bef))\n         (\\<sigma> (f, Suc (length bef + length aft))) =\n        (lb, nlb) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  partition ((=) (length bef))\n   (\\<sigma> (f, Suc (length bef + length aft))) =\n  (lb, nlb)\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "hence mset_\\<sigma>: \"mset ?\\<sigma> = mset lb + mset nlb\""], ["proof (prove)\nusing this:\n  partition ((=) (length bef))\n   (\\<sigma> (f, Suc (length bef + length aft))) =\n  (lb, nlb)\n\ngoal (1 subgoal):\n 1. mset (\\<sigma> (f, Suc (length bef + length aft))) = mset lb + mset nlb", "by (induct ?\\<sigma>, auto)"], ["proof (state)\nthis:\n  mset (\\<sigma> (f, Suc (length bef + length aft))) = mset lb + mset nlb\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?mlbs = \"map ((!) ?ss) lb\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?mnlbs = \"map ((!) ?ss) nlb\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?mlbt = \"map ((!) ?ts) lb\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "let ?mnlbt = \"map ((!) ?ts) nlb\""], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "have id1: \"mset ?mss = mset ?mnlbs + mset ?mlbs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (map ((!) (bef @ s # aft))\n       (\\<sigma> (f, Suc (length bef + length aft)))) =\n    mset (map ((!) (bef @ s # aft)) nlb) +\n    mset (map ((!) (bef @ s # aft)) lb)", "using mset_\\<sigma>"], ["proof (prove)\nusing this:\n  mset (\\<sigma> (f, Suc (length bef + length aft))) = mset lb + mset nlb\n\ngoal (1 subgoal):\n 1. mset\n     (map ((!) (bef @ s # aft))\n       (\\<sigma> (f, Suc (length bef + length aft)))) =\n    mset (map ((!) (bef @ s # aft)) nlb) +\n    mset (map ((!) (bef @ s # aft)) lb)", "by auto"], ["proof (state)\nthis:\n  mset\n   (map ((!) (bef @ s # aft))\n     (\\<sigma> (f, Suc (length bef + length aft)))) =\n  mset (map ((!) (bef @ s # aft)) nlb) + mset (map ((!) (bef @ s # aft)) lb)\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "have id2: \"mset ?mts = mset ?mnlbt + mset ?mlbt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (map ((!) (bef @ t # aft))\n       (\\<sigma> (f, Suc (length bef + length aft)))) =\n    mset (map ((!) (bef @ t # aft)) nlb) +\n    mset (map ((!) (bef @ t # aft)) lb)", "using mset_\\<sigma>"], ["proof (prove)\nusing this:\n  mset (\\<sigma> (f, Suc (length bef + length aft))) = mset lb + mset nlb\n\ngoal (1 subgoal):\n 1. mset\n     (map ((!) (bef @ t # aft))\n       (\\<sigma> (f, Suc (length bef + length aft)))) =\n    mset (map ((!) (bef @ t # aft)) nlb) +\n    mset (map ((!) (bef @ t # aft)) lb)", "by auto"], ["proof (state)\nthis:\n  mset\n   (map ((!) (bef @ t # aft))\n     (\\<sigma> (f, Suc (length bef + length aft)))) =\n  mset (map ((!) (bef @ t # aft)) nlb) + mset (map ((!) (bef @ t # aft)) lb)\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "from part lb_mem"], ["proof (chain)\npicking this:\n  partition ((=) (length bef))\n   (\\<sigma> (f, Suc (length bef + length aft))) =\n  (lb, nlb)\n  length bef \\<in> set (\\<sigma> (f, Suc (length bef + length aft)))", "have lb: \"?lb \\<in> set lb\""], ["proof (prove)\nusing this:\n  partition ((=) (length bef))\n   (\\<sigma> (f, Suc (length bef + length aft))) =\n  (lb, nlb)\n  length bef \\<in> set (\\<sigma> (f, Suc (length bef + length aft)))\n\ngoal (1 subgoal):\n 1. length bef \\<in> set lb", "by auto"], ["proof (state)\nthis:\n  length bef \\<in> set lb\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "have \"fst (mul_ext wpo ?mss ?mts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (mul_ext wpo\n          (map ((!) (bef @ s # aft))\n            (\\<sigma> (f, Suc (length bef + length aft))))\n          (map ((!) (bef @ t # aft))\n            (\\<sigma> (f, Suc (length bef + length aft)))))", "unfolding mul_ext_def Let_def fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset\n      (map ((!) (bef @ s # aft))\n        (\\<sigma> (f, Suc (length bef + length aft)))),\n     mset\n      (map ((!) (bef @ t # aft))\n        (\\<sigma> (f, Suc (length bef + length aft)))))\n    \\<in> s_mul_ext WPO_NS WPO_S", "proof (intro s_mul_extI_old, rule id1, rule id2)"], ["proof (state)\ngoal (4 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>i.\n       i < length (map ((!) (bef @ t # aft)) nlb) \\<Longrightarrow>\n       (map ((!) (bef @ s # aft)) nlb ! i,\n        map ((!) (bef @ t # aft)) nlb ! i)\n       \\<in> WPO_NS\n 3. mset (map ((!) (bef @ s # aft)) lb) \\<noteq> {#}\n 4. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "from lb"], ["proof (chain)\npicking this:\n  length bef \\<in> set lb", "show \"mset ?mlbs \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  length bef \\<in> set lb\n\ngoal (1 subgoal):\n 1. mset (map ((!) (bef @ s # aft)) lb) \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  mset (map ((!) (bef @ s # aft)) lb) \\<noteq> {#}\n\ngoal (3 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>i.\n       i < length (map ((!) (bef @ t # aft)) nlb) \\<Longrightarrow>\n       (map ((!) (bef @ s # aft)) nlb ! i,\n        map ((!) (bef @ t # aft)) nlb ! i)\n       \\<in> WPO_NS\n 3. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "{"], ["proof (state)\nthis:\n  mset (map ((!) (bef @ s # aft)) lb) \\<noteq> {#}\n\ngoal (3 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>i.\n       i < length (map ((!) (bef @ t # aft)) nlb) \\<Longrightarrow>\n       (map ((!) (bef @ s # aft)) nlb ! i,\n        map ((!) (bef @ t # aft)) nlb ! i)\n       \\<in> WPO_NS\n 3. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>i.\n       i < length (map ((!) (bef @ t # aft)) nlb) \\<Longrightarrow>\n       (map ((!) (bef @ s # aft)) nlb ! i,\n        map ((!) (bef @ t # aft)) nlb ! i)\n       \\<in> WPO_NS\n 3. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "assume \"i < length ?mnlbt\""], ["proof (state)\nthis:\n  i < length (map ((!) (bef @ t # aft)) nlb)\n\ngoal (3 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>i.\n       i < length (map ((!) (bef @ t # aft)) nlb) \\<Longrightarrow>\n       (map ((!) (bef @ s # aft)) nlb ! i,\n        map ((!) (bef @ t # aft)) nlb ! i)\n       \\<in> WPO_NS\n 3. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "then"], ["proof (chain)\npicking this:\n  i < length (map ((!) (bef @ t # aft)) nlb)", "obtain j where id: \"?mnlbs ! i = ?ss ! j\" \"?mnlbt ! i = ?ts ! j\" \"j \\<in> set nlb\""], ["proof (prove)\nusing this:\n  i < length (map ((!) (bef @ t # aft)) nlb)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>map ((!) (bef @ s # aft)) nlb ! i = (bef @ s # aft) ! j;\n         map ((!) (bef @ t # aft)) nlb ! i = (bef @ t # aft) ! j;\n         j \\<in> set nlb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  map ((!) (bef @ s # aft)) nlb ! i = (bef @ s # aft) ! j\n  map ((!) (bef @ t # aft)) nlb ! i = (bef @ t # aft) ! j\n  j \\<in> set nlb\n\ngoal (3 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>i.\n       i < length (map ((!) (bef @ t # aft)) nlb) \\<Longrightarrow>\n       (map ((!) (bef @ s # aft)) nlb ! i,\n        map ((!) (bef @ t # aft)) nlb ! i)\n       \\<in> WPO_NS\n 3. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "with part"], ["proof (chain)\npicking this:\n  partition ((=) (length bef))\n   (\\<sigma> (f, Suc (length bef + length aft))) =\n  (lb, nlb)\n  map ((!) (bef @ s # aft)) nlb ! i = (bef @ s # aft) ! j\n  map ((!) (bef @ t # aft)) nlb ! i = (bef @ t # aft) ! j\n  j \\<in> set nlb", "have \"j \\<noteq> ?lb\""], ["proof (prove)\nusing this:\n  partition ((=) (length bef))\n   (\\<sigma> (f, Suc (length bef + length aft))) =\n  (lb, nlb)\n  map ((!) (bef @ s # aft)) nlb ! i = (bef @ s # aft) ! j\n  map ((!) (bef @ t # aft)) nlb ! i = (bef @ t # aft) ! j\n  j \\<in> set nlb\n\ngoal (1 subgoal):\n 1. j \\<noteq> length bef", "by auto"], ["proof (state)\nthis:\n  j \\<noteq> length bef\n\ngoal (3 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>i.\n       i < length (map ((!) (bef @ t # aft)) nlb) \\<Longrightarrow>\n       (map ((!) (bef @ s # aft)) nlb ! i,\n        map ((!) (bef @ t # aft)) nlb ! i)\n       \\<in> WPO_NS\n 3. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "hence \"?ss ! j = ?ts ! j\""], ["proof (prove)\nusing this:\n  j \\<noteq> length bef\n\ngoal (1 subgoal):\n 1. (bef @ s # aft) ! j = (bef @ t # aft) ! j", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  (bef @ s # aft) ! j = (bef @ t # aft) ! j\n\ngoal (3 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>i.\n       i < length (map ((!) (bef @ t # aft)) nlb) \\<Longrightarrow>\n       (map ((!) (bef @ s # aft)) nlb ! i,\n        map ((!) (bef @ t # aft)) nlb ! i)\n       \\<in> WPO_NS\n 3. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "thus \"(?mnlbs ! i, ?mnlbt ! i) \\<in> WPO_NS\""], ["proof (prove)\nusing this:\n  (bef @ s # aft) ! j = (bef @ t # aft) ! j\n\ngoal (1 subgoal):\n 1. (map ((!) (bef @ s # aft)) nlb ! i, map ((!) (bef @ t # aft)) nlb ! i)\n    \\<in> WPO_NS", "unfolding id"], ["proof (prove)\nusing this:\n  (bef @ s # aft) ! j = (bef @ t # aft) ! j\n\ngoal (1 subgoal):\n 1. ((bef @ s # aft) ! j, (bef @ t # aft) ! j) \\<in> WPO_NS", "using wpo_ns_refl"], ["proof (prove)\nusing this:\n  (bef @ s # aft) ! j = (bef @ t # aft) ! j\n  ?s \\<succeq> ?s\n\ngoal (1 subgoal):\n 1. ((bef @ s # aft) ! j, (bef @ t # aft) ! j) \\<in> WPO_NS", "by auto"], ["proof (state)\nthis:\n  (map ((!) (bef @ s # aft)) nlb ! i, map ((!) (bef @ t # aft)) nlb ! i)\n  \\<in> WPO_NS\n\ngoal (2 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "}"], ["proof (state)\nthis:\n  ?ia2 < length (map ((!) (bef @ t # aft)) nlb) \\<Longrightarrow>\n  (map ((!) (bef @ s # aft)) nlb ! ?ia2,\n   map ((!) (bef @ t # aft)) nlb ! ?ia2)\n  \\<in> WPO_NS\n\ngoal (2 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "assume \"u \\<in># mset ?mlbt\""], ["proof (state)\nthis:\n  u \\<in># mset (map ((!) (bef @ t # aft)) lb)\n\ngoal (2 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "hence \"u = t\""], ["proof (prove)\nusing this:\n  u \\<in># mset (map ((!) (bef @ t # aft)) lb)\n\ngoal (1 subgoal):\n 1. u = t", "using part"], ["proof (prove)\nusing this:\n  u \\<in># mset (map ((!) (bef @ t # aft)) lb)\n  partition ((=) (length bef))\n   (\\<sigma> (f, Suc (length bef + length aft))) =\n  (lb, nlb)\n\ngoal (1 subgoal):\n 1. u = t", "by auto"], ["proof (state)\nthis:\n  u = t\n\ngoal (2 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "moreover"], ["proof (state)\nthis:\n  u = t\n\ngoal (2 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "have \"s \\<in># mset ?mlbs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in># mset (map ((!) (bef @ s # aft)) lb)", "using lb"], ["proof (prove)\nusing this:\n  length bef \\<in> set lb\n\ngoal (1 subgoal):\n 1. s \\<in># mset (map ((!) (bef @ s # aft)) lb)", "by force"], ["proof (state)\nthis:\n  s \\<in># mset (map ((!) (bef @ s # aft)) lb)\n\ngoal (2 subgoals):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)\n 2. \\<And>b.\n       b \\<in># mset (map ((!) (bef @ t # aft)) lb) \\<Longrightarrow>\n       \\<exists>a.\n          a \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n          (a, b) \\<in> WPO_S", "ultimately"], ["proof (chain)\npicking this:\n  u = t\n  s \\<in># mset (map ((!) (bef @ s # aft)) lb)", "show \"\\<exists> v. v \\<in>#  mset ?mlbs \\<and> (v,u) \\<in> WPO_S\""], ["proof (prove)\nusing this:\n  u = t\n  s \\<in># mset (map ((!) (bef @ s # aft)) lb)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n       (v, u) \\<in> WPO_S", "using rels"], ["proof (prove)\nusing this:\n  u = t\n  s \\<in># mset (map ((!) (bef @ s # aft)) lb)\n  s \\<succ> t\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and>\n       (v, u) \\<in> WPO_S", "by force"], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<in># mset (map ((!) (bef @ s # aft)) lb) \\<and> (v, u) \\<in> WPO_S\n\ngoal (1 subgoal):\n 1. length (map ((!) (bef @ s # aft)) nlb) =\n    length (map ((!) (bef @ t # aft)) nlb)", "qed auto"], ["proof (state)\nthis:\n  fst (mul_ext wpo\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "ultimately"], ["proof (chain)\npicking this:\n  fst (lex_ext wpo n\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n  fst (mul_ext wpo\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (lex_ext wpo n\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n  fst (mul_ext wpo\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n\ngoal (1 subgoal):\n 1. Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)", "unfolding wpo.simps[of ?s ?t] term.simps id prc_refl"], ["proof (prove)\nusing this:\n  fst (lex_ext wpo n\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n  fst (mul_ext wpo\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n\ngoal (1 subgoal):\n 1. fst (if (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> S\n         then (True, True)\n         else if True\n              then if \\<exists>i\\<in>set\n(\\<sigma> (f, Suc (length bef + length aft))).\n                         (bef @ s # aft) ! i \\<succeq> Fun f (bef @ t # aft)\n                   then (True, True)\n                   else case (False, True) of\n                        (prs, prns) \\<Rightarrow>\n                          if prns \\<and> True\n                          then if prs then (True, True)\n                               else let ss' =\n    map ((!) (bef @ s # aft)) (\\<sigma> (f, Suc (length bef + length aft)));\n  ts' =\n    map ((!) (bef @ t # aft)) (\\<sigma> (f, Suc (length bef + length aft)));\n  cf = c (f, Suc (length bef + length aft));\n  cg = c (f, Suc (length bef + length aft))\n                                    in if cf = Lex \\<and> cg = Lex\n then lex_ext wpo n ss' ts'\n else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n      else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                          else (False, False)\n              else (False, False))", "using order_tag.exhaust"], ["proof (prove)\nusing this:\n  fst (lex_ext wpo n\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n  fst (mul_ext wpo\n        (map ((!) (bef @ s # aft))\n          (\\<sigma> (f, Suc (length bef + length aft))))\n        (map ((!) (bef @ t # aft))\n          (\\<sigma> (f, Suc (length bef + length aft)))))\n  \\<lbrakk>?y = Lex \\<Longrightarrow> ?P;\n   ?y = Mul \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. fst (if (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> S\n         then (True, True)\n         else if True\n              then if \\<exists>i\\<in>set\n(\\<sigma> (f, Suc (length bef + length aft))).\n                         (bef @ s # aft) ! i \\<succeq> Fun f (bef @ t # aft)\n                   then (True, True)\n                   else case (False, True) of\n                        (prs, prns) \\<Rightarrow>\n                          if prns \\<and> True\n                          then if prs then (True, True)\n                               else let ss' =\n    map ((!) (bef @ s # aft)) (\\<sigma> (f, Suc (length bef + length aft)));\n  ts' =\n    map ((!) (bef @ t # aft)) (\\<sigma> (f, Suc (length bef + length aft)));\n  cf = c (f, Suc (length bef + length aft));\n  cg = c (f, Suc (length bef + length aft))\n                                    in if cf = Lex \\<and> cg = Lex\n then lex_ext wpo n ss' ts'\n else if cf = Mul \\<and> cg = Mul then mul_ext wpo ss' ts'\n      else (length ss' \\<noteq> 0 \\<and> length ts' = 0, length ts' = 0)\n                          else (False, False)\n              else (False, False))", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  Fun f (bef @ s # aft) \\<succ> Fun f (bef @ t # aft)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem WPO_S_ctxt: \"(s,t) \\<in> WPO_S \\<Longrightarrow> (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> WPO_S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, t) \\<in> WPO_S \\<Longrightarrow>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> WPO_S", "using wpo_s_mono"], ["proof (prove)\nusing this:\n  ?s \\<succ> ?t \\<Longrightarrow>\n  Fun ?f (?bef @ ?s # ?aft) \\<succ> Fun ?f (?bef @ ?t # ?aft)\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> WPO_S \\<Longrightarrow>\n    (Fun f (bef @ s # aft), Fun f (bef @ t # aft)) \\<in> WPO_S", "by blast"], ["", "theorem supt_subset_WPO_S: \"{\\<rhd>} \\<subseteq> WPO_S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<rhd>} \\<subseteq> WPO_S", "using subterm_wpo_s"], ["proof (prove)\nusing this:\n  ?s \\<rhd> ?t \\<Longrightarrow> ?s \\<succ> ?t\n\ngoal (1 subgoal):\n 1. {\\<rhd>} \\<subseteq> WPO_S", "by blast"], ["", "theorem supteq_subset_WPO_NS: \"{\\<unrhd>} \\<subseteq> WPO_NS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<unrhd>} \\<subseteq> WPO_NS", "using subterm_wpo_ns"], ["proof (prove)\nusing this:\n  ?s \\<unrhd> ?t \\<Longrightarrow> ?s \\<succeq> ?t\n\ngoal (1 subgoal):\n 1. {\\<unrhd>} \\<subseteq> WPO_NS", "by blast"], ["", "end"], ["", "end"], ["", "end"]]}