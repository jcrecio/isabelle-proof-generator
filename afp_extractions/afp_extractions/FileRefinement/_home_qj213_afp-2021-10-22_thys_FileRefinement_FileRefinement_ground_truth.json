{"file_name": "/home/qj213/afp-2021-10-22/thys/FileRefinement/FileRefinement.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FileRefinement", "problem_names": ["lemma nextFreeBlockInvariant1:\n  \"nextFreeBlockInvariant makeCF\"", "lemma unallocatedBlocksInvariant1:\n  \"unallocatedBlocksInvariant makeCF\"", "lemma lastBlockInvariant1:\n  \"lastBlockInvariant makeCF\"", "lemma makeCFpreserves: \"reachabilityInvariant makeCF\"", "lemma cfWriteNoExtendPreservesFileSize:\n  \"[| index < fileSize cfile1;\n      cfWrite cfile1 index value = Some cfile2\n   |] ==> \n   fileSize cfile2 = fileSize cfile1\"", "lemma cfWriteExtendFileSize:\n  \"[| ~ index < fileSize cfile1;\n      cfWrite cfile1 index value = Some cfile2\n   |] ==> fileSize cfile2 = Suc index\"", "lemma fileSizeIncreases:\n  \"cfWrite cfile1 index value = Some cfile2\n   ==> fileSize cfile1 <= fileSize cfile2\"", "lemma nextFreeBlockIncreases:\n  \"[| nextFreeBlockInvariant cfile1;\n      cfWrite cfile1 index value = Some cfile2\n   |] ==> nextFreeBlock cfile1 <= nextFreeBlock cfile2\"", "lemma cfWritePreservesNextFreeBlockInvariant:\n   \"[| reachabilityInvariant cfile1;\n       cfWrite cfile1 byteIndex value = Some cfile2\n    |] ==> nextFreeBlockInvariant cfile2\"", "lemma modInequalityLemma:\n  \"(a::nat) ~= b & a mod c = b mod c ==> a div c ~= b div c\"", "lemma mod_round_lt:\n  \"[| 0 < (c::nat);\n      a < b\n   |] ==> a div c < (b + c - 1) div c\"", "lemma blockNumNELemma:\n  \"!!blockNum i.\n       [| nextFreeBlockInvariant cfile1;\n          cfile1\n          (| data :=\n               writeCArray (data cfile1) (byteIndex div blockSize)\n                (writeCArray\n                  (readCArray (data cfile1) (byteIndex div blockSize))\n                  (byteIndex mod blockSize) value) |) =\n          cfile2;\n          ~ blockNum < nextFreeBlock cfile2; blockNum < numBlocks;\n          i < blockSize; byteIndex div blockSize < numBlocks;\n          byteIndex < fileSize cfile1 |]\n       ==> blockNum ~= byteIndex div blockSize\"", "lemma cfWritePreservesUnallocatedBlocksInvariant:\n   \"[| reachabilityInvariant cfile1;\n       cfWrite cfile1 byteIndex value = Some cfile2\n    |] ==> unallocatedBlocksInvariant cfile2\"", "lemma cfWritePreservesLastBlockInvariant:\n   \"[| reachabilityInvariant cfile1;\n       cfWrite cfile1 byteIndex value = Some cfile2 |] ==> \n    lastBlockInvariant cfile2\"", "lemma cfWritePreserves: \n   \"[| reachabilityInvariant cfile1;\n       cfWrite cfile1 byteIndex value = Some cfile2 |] ==> \n    reachabilityInvariant cfile2\"", "lemma makeCFCorrect: \"abstFn makeCF = makeAF\"", "lemma fileSizeCorrect:\n  \"cfSize cfile = afSize (abstFn cfile)\"", "lemma readCorrect:\n  \"cfRead cfile = afRead (abstFn cfile)\"", "lemma writeNoExtendCorrect:\n  \"[| index < fileSize cfile1;\n      Some cfile2 = cfWrite cfile1 index value\n   |] ==> Some (abstFn cfile2) = afWrite (abstFn cfile1) index value\"", "lemma writeExtendCorrect:\n  \"[| nextFreeBlockInvariant cfile1;\n      unallocatedBlocksInvariant cfile1;\n      lastBlockInvariant cfile1;\n      ~ index < fileSize cfile1;\n      Some cfile2 = cfWrite cfile1 index value\n   |] ==> Some (abstFn cfile2) = afWrite (abstFn cfile1) index value\"", "lemma writeSucceedCorrect:\n  \"[| nextFreeBlockInvariant cfile1;\n      unallocatedBlocksInvariant cfile1;\n      lastBlockInvariant cfile1;\n      Some cfile2 = cfWrite cfile1 index value\n   |] ==> Some (abstFn cfile2) = afWrite (abstFn cfile1) index value\"", "lemma writeFailCorrect:\n  \"cfWrite cfile1 index value = None ==> \n   afWrite (abstFn cfile1) index value = None\"", "lemma writeCorrect:\n  \"reachabilityInvariant cfile1 ==>\n   oAbstFn (cfWrite cfile1 index value) = afWrite (abstFn cfile1) index value\""], "translations": [["", "lemma nextFreeBlockInvariant1:\n  \"nextFreeBlockInvariant makeCF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextFreeBlockInvariant makeCF", "apply (simp add: nextFreeBlockInvariant_def makeCF_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (blockSize - Suc 0) div blockSize = 0", "apply (simp add: nonZeroBlockSize)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unallocatedBlocksInvariant1:\n  \"unallocatedBlocksInvariant makeCF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unallocatedBlocksInvariant makeCF", "apply (simp add: unallocatedBlocksInvariant_def makeCF_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>blockNum i.\n       blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n       makeCArray numBlocks (makeCArray blockSize fillByte) blockNum i =\n       fillByte", "apply (simp add: makeCArray_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lastBlockInvariant1:\n  \"lastBlockInvariant makeCF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lastBlockInvariant makeCF", "by (simp add: lastBlockInvariant_def makeCF_def)"], ["", "lemma makeCFpreserves: \"reachabilityInvariant makeCF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachabilityInvariant makeCF", "by (simp add: reachabilityInvariant_def\n              nextFreeBlockInvariant1\n              unallocatedBlocksInvariant1\n              lastBlockInvariant1)"], ["", "(* ---------------------------------------------------------------*)"], ["", "subsection \\<open>Properties of Concrete File Operations\\<close>"], ["", "lemma cfWriteNoExtendPreservesFileSize:\n  \"[| index < fileSize cfile1;\n      cfWrite cfile1 index value = Some cfile2\n   |] ==> \n   fileSize cfile2 = fileSize cfile1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index < fileSize cfile1;\n     cfWrite cfile1 index value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile2 = fileSize cfile1", "apply (simp add: cfWrite_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index < fileSize cfile1;\n     (if index div blockSize < numBlocks\n      then if index < fileSize cfile1\n           then Some (cfWriteNoExtend cfile1 index value)\n           else Some\n                 (cfWriteNoExtend (cfExtendFile cfile1 index) index value)\n      else None) =\n     Some cfile2\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile2 = fileSize cfile1", "apply (case_tac \"index div blockSize < numBlocks\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index < fileSize cfile1;\n     cfWriteNoExtend cfile1 index value = cfile2;\n     index div blockSize < numBlocks\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile2 = fileSize cfile1", "apply (simp add: cfWriteNoExtend_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index < fileSize cfile1;\n     cfile1\n     \\<lparr>data :=\n               writeCArray (data cfile1) (index div blockSize)\n                (writeCArray\n                  (readCArray (data cfile1) (index div blockSize))\n                  (index mod blockSize) value)\\<rparr> =\n     cfile2;\n     index div blockSize < numBlocks\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile2 = fileSize cfile1", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cfWriteExtendFileSize:\n  \"[| ~ index < fileSize cfile1;\n      cfWrite cfile1 index value = Some cfile2\n   |] ==> fileSize cfile2 = Suc index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> index < fileSize cfile1;\n     cfWrite cfile1 index value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile2 = Suc index", "apply (simp add: cfWrite_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> index < fileSize cfile1;\n     (if index div blockSize < numBlocks\n      then if index < fileSize cfile1\n           then Some (cfWriteNoExtend cfile1 index value)\n           else Some\n                 (cfWriteNoExtend (cfExtendFile cfile1 index) index value)\n      else None) =\n     Some cfile2\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile2 = Suc index", "apply (case_tac \"index div blockSize < numBlocks\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> index < fileSize cfile1;\n     cfWriteNoExtend (cfExtendFile cfile1 index) index value = cfile2;\n     index div blockSize < numBlocks\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile2 = Suc index", "apply (simp add: cfWriteNoExtend_def cfExtendFile_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> index < fileSize cfile1;\n     cfile1\n     \\<lparr>fileSize := Suc index,\n        nextFreeBlock := Suc (index div blockSize),\n        data :=\n          writeCArray (data cfile1) (index div blockSize)\n           (writeCArray (readCArray (data cfile1) (index div blockSize))\n             (index mod blockSize) value)\\<rparr> =\n     cfile2;\n     index div blockSize < numBlocks\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile2 = Suc index", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fileSizeIncreases:\n  \"cfWrite cfile1 index value = Some cfile2\n   ==> fileSize cfile1 <= fileSize cfile2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfWrite cfile1 index value = Some cfile2 \\<Longrightarrow>\n    fileSize cfile1 \\<le> fileSize cfile2", "apply (simp add: cfWrite_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if index div blockSize < numBlocks\n     then if index < fileSize cfile1\n          then Some (cfWriteNoExtend cfile1 index value)\n          else Some\n                (cfWriteNoExtend (cfExtendFile cfile1 index) index value)\n     else None) =\n    Some cfile2 \\<Longrightarrow>\n    fileSize cfile1 \\<le> fileSize cfile2", "apply (case_tac \"index div blockSize < numBlocks\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if index < fileSize cfile1\n              then Some (cfWriteNoExtend cfile1 index value)\n              else Some\n                    (cfWriteNoExtend (cfExtendFile cfile1 index) index\n                      value)) =\n             Some cfile2;\n     index div blockSize < numBlocks\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile1 \\<le> fileSize cfile2", "apply (case_tac \"index < fileSize cfile1\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cfWriteNoExtend cfile1 index value = cfile2;\n     index div blockSize < numBlocks; index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile1 \\<le> fileSize cfile2\n 2. \\<lbrakk>cfWriteNoExtend (cfExtendFile cfile1 index) index value =\n             cfile2;\n     index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile1 \\<le> fileSize cfile2", "apply (simp_all add: cfWriteNoExtend_def cfExtendFile_def Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cfile1\n             \\<lparr>data :=\n                       writeCArray (data cfile1) (index div blockSize)\n                        (writeCArray\n                          (readCArray (data cfile1) (index div blockSize))\n                          (index mod blockSize) value)\\<rparr> =\n             cfile2;\n     index div blockSize < numBlocks; index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile1 \\<le> fileSize cfile2\n 2. \\<lbrakk>cfile1\n             \\<lparr>fileSize := Suc index,\n                nextFreeBlock := Suc (index div blockSize),\n                data :=\n                  writeCArray (data cfile1) (index div blockSize)\n                   (writeCArray\n                     (readCArray (data cfile1) (index div blockSize))\n                     (index mod blockSize) value)\\<rparr> =\n             cfile2;\n     index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile1 \\<le> fileSize cfile2", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfile1\n             \\<lparr>fileSize := Suc index,\n                nextFreeBlock := Suc (index div blockSize),\n                data :=\n                  writeCArray (data cfile1) (index div blockSize)\n                   (writeCArray\n                     (readCArray (data cfile1) (index div blockSize))\n                     (index mod blockSize) value)\\<rparr> =\n             cfile2;\n     index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile1 \\<le> fileSize cfile2", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nextFreeBlockIncreases:\n  \"[| nextFreeBlockInvariant cfile1;\n      cfWrite cfile1 index value = Some cfile2\n   |] ==> nextFreeBlock cfile1 <= nextFreeBlock cfile2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     cfWrite cfile1 index value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp add: cfWrite_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     (if index div blockSize < numBlocks\n      then if index < fileSize cfile1\n           then Some (cfWriteNoExtend cfile1 index value)\n           else Some\n                 (cfWriteNoExtend (cfExtendFile cfile1 index) index value)\n      else None) =\n     Some cfile2\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (case_tac \"index div blockSize < numBlocks\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     (if index < fileSize cfile1\n      then Some (cfWriteNoExtend cfile1 index value)\n      else Some (cfWriteNoExtend (cfExtendFile cfile1 index) index value)) =\n     Some cfile2;\n     index div blockSize < numBlocks\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (case_tac \"index < fileSize cfile1\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     cfWriteNoExtend cfile1 index value = cfile2;\n     index div blockSize < numBlocks; index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2\n 2. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     cfWriteNoExtend (cfExtendFile cfile1 index) index value = cfile2;\n     index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp_all add: cfWriteNoExtend_def cfExtendFile_def Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     cfile1\n     \\<lparr>data :=\n               writeCArray (data cfile1) (index div blockSize)\n                (writeCArray\n                  (readCArray (data cfile1) (index div blockSize))\n                  (index mod blockSize) value)\\<rparr> =\n     cfile2;\n     index div blockSize < numBlocks; index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2\n 2. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     cfile1\n     \\<lparr>fileSize := Suc index,\n        nextFreeBlock := Suc (index div blockSize),\n        data :=\n          writeCArray (data cfile1) (index div blockSize)\n           (writeCArray (readCArray (data cfile1) (index div blockSize))\n             (index mod blockSize) value)\\<rparr> =\n     cfile2;\n     index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     cfile1\n     \\<lparr>fileSize := Suc index,\n        nextFreeBlock := Suc (index div blockSize),\n        data :=\n          writeCArray (data cfile1) (index div blockSize)\n           (writeCArray (readCArray (data cfile1) (index div blockSize))\n             (index mod blockSize) value)\\<rparr> =\n     cfile2;\n     index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp add: nextFreeBlockInvariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n             nextFreeBlock cfile1;\n     cfile1\n     \\<lparr>fileSize := Suc index,\n        nextFreeBlock := Suc (index div blockSize),\n        data :=\n          writeCArray (data cfile1) (index div blockSize)\n           (writeCArray (readCArray (data cfile1) (index div blockSize))\n             (index mod blockSize) value)\\<rparr> =\n     cfile2;\n     index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n             nextFreeBlock cfile1;\n     index div blockSize < numBlocks; \\<not> index < fileSize cfile1;\n     cfile2 = cfile1\n     \\<lparr>fileSize := Suc index,\n        nextFreeBlock := Suc (index div blockSize),\n        data :=\n          writeCArray (data cfile1) (index div blockSize)\n           (writeCArray (readCArray (data cfile1) (index div blockSize))\n             (index mod blockSize) value)\\<rparr>\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> Suc (index div blockSize)", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n             nextFreeBlock cfile1;\n     index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> Suc (index div blockSize)", "apply (subgoal_tac \"nextFreeBlock cfile1 = \n  (fileSize cfile1 + blockSize - Suc 0) div blockSize\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1;\n     nextFreeBlock cfile1 =\n     (fileSize cfile1 + blockSize - Suc 0) div blockSize\\<rbrakk>\n    \\<Longrightarrow> (fileSize cfile1 + blockSize - Suc 0) div blockSize\n                      \\<le> Suc (index div blockSize)", "apply (subgoal_tac \"Suc (index div blockSize) = \n  (index + blockSize) div blockSize\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1;\n     nextFreeBlock cfile1 =\n     (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n     Suc (index div blockSize) = (index + blockSize) div blockSize\\<rbrakk>\n    \\<Longrightarrow> (fileSize cfile1 + blockSize - Suc 0) div blockSize\n                      \\<le> (index + blockSize) div blockSize\n 2. \\<lbrakk>index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1;\n     nextFreeBlock cfile1 =\n     (fileSize cfile1 + blockSize - Suc 0) div blockSize\\<rbrakk>\n    \\<Longrightarrow> Suc (index div blockSize) =\n                      (index + blockSize) div blockSize", "apply (subgoal_tac \"(fileSize cfile1 + blockSize - Suc 0) <= \n  (index + blockSize)\", simp add: div_le_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1;\n     nextFreeBlock cfile1 =\n     (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n     Suc (index div blockSize) = (index + blockSize) div blockSize\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile1 + blockSize - Suc 0\n                      \\<le> index + blockSize\n 2. \\<lbrakk>index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1;\n     nextFreeBlock cfile1 =\n     (fileSize cfile1 + blockSize - Suc 0) div blockSize\\<rbrakk>\n    \\<Longrightarrow> Suc (index div blockSize) =\n                      (index + blockSize) div blockSize", "apply (subgoal_tac \"(fileSize cfile1 + blockSize - Suc 0) < \n  (fileSize cfile1 + blockSize)\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1;\n     nextFreeBlock cfile1 =\n     (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n     Suc (index div blockSize) = (index + blockSize) div blockSize\\<rbrakk>\n    \\<Longrightarrow> fileSize cfile1 + blockSize - Suc 0\n                      < fileSize cfile1 + blockSize\n 2. \\<lbrakk>index div blockSize < numBlocks;\n     \\<not> index < fileSize cfile1;\n     nextFreeBlock cfile1 =\n     (fileSize cfile1 + blockSize - Suc 0) div blockSize\\<rbrakk>\n    \\<Longrightarrow> Suc (index div blockSize) =\n                      (index + blockSize) div blockSize", "apply (simp_all add: nonZeroBlockSize)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* ---------------------------------------------------------------*)"], ["", "subsection \\<open>Concrete File Operations Preserve Invariants\\<close>"], ["", "text \\<open>There is only one top-level concrete operation: write, and we\nshow that it preserves all reachability invariants.\\<close>"], ["", "lemma cfWritePreservesNextFreeBlockInvariant:\n   \"[| reachabilityInvariant cfile1;\n       cfWrite cfile1 byteIndex value = Some cfile2\n    |] ==> nextFreeBlockInvariant cfile2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachabilityInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlockInvariant cfile2", "apply (simp add: reachabilityInvariant_def\n                 cfWrite_def\n                 nextFreeBlockInvariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n             nextFreeBlock cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     (if byteIndex div blockSize < numBlocks\n      then if byteIndex < fileSize cfile1\n           then Some (cfWriteNoExtend cfile1 byteIndex value)\n           else Some\n                 (cfWriteNoExtend (cfExtendFile cfile1 byteIndex) byteIndex\n                   value)\n      else None) =\n     Some cfile2\\<rbrakk>\n    \\<Longrightarrow> (fileSize cfile2 + blockSize - Suc 0) div blockSize =\n                      nextFreeBlock cfile2", "apply (case_tac \"byteIndex div blockSize < numBlocks\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n             nextFreeBlock cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     (if byteIndex < fileSize cfile1\n      then Some (cfWriteNoExtend cfile1 byteIndex value)\n      else Some\n            (cfWriteNoExtend (cfExtendFile cfile1 byteIndex) byteIndex\n              value)) =\n     Some cfile2;\n     byteIndex div blockSize < numBlocks\\<rbrakk>\n    \\<Longrightarrow> (fileSize cfile2 + blockSize - Suc 0) div blockSize =\n                      nextFreeBlock cfile2", "apply (case_tac \"byteIndex < fileSize cfile1\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n             nextFreeBlock cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfWriteNoExtend cfile1 byteIndex value = cfile2;\n     byteIndex div blockSize < numBlocks;\n     byteIndex < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> (fileSize cfile2 + blockSize - Suc 0) div blockSize =\n                      nextFreeBlock cfile2\n 2. \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n             nextFreeBlock cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfWriteNoExtend (cfExtendFile cfile1 byteIndex) byteIndex value =\n     cfile2;\n     byteIndex div blockSize < numBlocks;\n     \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> (fileSize cfile2 + blockSize - Suc 0) div blockSize =\n                      nextFreeBlock cfile2", "apply (simp_all add: cfWriteNoExtend_def cfExtendFile_def Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n             nextFreeBlock cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfile1\n     \\<lparr>data :=\n               writeCArray (data cfile1) (byteIndex div blockSize)\n                (writeCArray\n                  (readCArray (data cfile1) (byteIndex div blockSize))\n                  (byteIndex mod blockSize) value)\\<rparr> =\n     cfile2;\n     byteIndex div blockSize < numBlocks;\n     byteIndex < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> (fileSize cfile2 + blockSize - Suc 0) div blockSize =\n                      nextFreeBlock cfile2\n 2. \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n             nextFreeBlock cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfile1\n     \\<lparr>fileSize := Suc byteIndex,\n        nextFreeBlock := Suc (byteIndex div blockSize),\n        data :=\n          writeCArray (data cfile1) (byteIndex div blockSize)\n           (writeCArray (readCArray (data cfile1) (byteIndex div blockSize))\n             (byteIndex mod blockSize) value)\\<rparr> =\n     cfile2;\n     byteIndex div blockSize < numBlocks;\n     \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> (fileSize cfile2 + blockSize - Suc 0) div blockSize =\n                      nextFreeBlock cfile2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>byteIndex div blockSize < numBlocks;\n     \\<not> byteIndex < fileSize cfile1;\n     cfile2 = cfile1\n     \\<lparr>fileSize := Suc byteIndex,\n        nextFreeBlock := Suc (byteIndex div blockSize),\n        data :=\n          writeCArray (data cfile1) (byteIndex div blockSize)\n           (writeCArray (readCArray (data cfile1) (byteIndex div blockSize))\n             (byteIndex mod blockSize) value)\\<rparr>;\n     (fileSize cfile1 + blockSize - Suc 0) div blockSize =\n     nextFreeBlock cfile1;\n     unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> (byteIndex + blockSize) div blockSize =\n                      Suc (byteIndex div blockSize)", "apply (simp add: nonZeroBlockSize)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma modInequalityLemma:\n  \"(a::nat) ~= b & a mod c = b mod c ==> a div c ~= b div c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n    a div c \\<noteq> b div c", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; a mod c = b mod c; a div c = b div c\\<rbrakk>\n    \\<Longrightarrow> False", "apply (insert div_mult_mod_eq [of \"a\" \"c\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; a mod c = b mod c; a div c = b div c;\n     a div c * c + a mod c = a\\<rbrakk>\n    \\<Longrightarrow> False", "apply (insert div_mult_mod_eq [of \"b\" \"c\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; a mod c = b mod c; a div c = b div c;\n     a div c * c + a mod c = a; b div c * c + b mod c = b\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mod_round_lt:\n  \"[| 0 < (c::nat);\n      a < b\n   |] ==> a div c < (b + c - 1) div c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c; a < b\\<rbrakk>\n    \\<Longrightarrow> a div c < (b + c - 1) div c", "apply (subgoal_tac \"a <= b - 1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c; a < b; a \\<le> b - 1\\<rbrakk>\n    \\<Longrightarrow> a div c < (b + c - 1) div c\n 2. \\<lbrakk>0 < c; a < b\\<rbrakk> \\<Longrightarrow> a \\<le> b - 1", "apply (subgoal_tac \"a div c <= (b - 1) div c\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < c; a < b; a \\<le> b - 1;\n     a div c \\<le> (b - 1) div c\\<rbrakk>\n    \\<Longrightarrow> a div c < (b + c - 1) div c\n 2. \\<lbrakk>0 < c; a < b; a \\<le> b - 1\\<rbrakk>\n    \\<Longrightarrow> a div c \\<le> (b - 1) div c\n 3. \\<lbrakk>0 < c; a < b\\<rbrakk> \\<Longrightarrow> a \\<le> b - 1", "apply (insert div_add_self2 [of c \"b - 1\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < c; a < b; a \\<le> b - 1; a div c \\<le> (b - 1) div c;\n     c \\<noteq> 0 \\<Longrightarrow>\n     (b - 1 + c) div c = (b - 1) div c + 1\\<rbrakk>\n    \\<Longrightarrow> a div c < (b + c - 1) div c\n 2. \\<lbrakk>0 < c; a < b; a \\<le> b - 1;\n     c \\<noteq> 0 \\<Longrightarrow>\n     (b - 1 + c) div c = (b - 1) div c + 1\\<rbrakk>\n    \\<Longrightarrow> a div c \\<le> (b - 1) div c\n 3. \\<lbrakk>0 < c; a < b;\n     c \\<noteq> 0 \\<Longrightarrow>\n     (b - 1 + c) div c = (b - 1) div c + 1\\<rbrakk>\n    \\<Longrightarrow> a \\<le> b - 1", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < c; a < b; a \\<le> b - 1;\n     c \\<noteq> 0 \\<Longrightarrow>\n     (b - 1 + c) div c = (b - 1) div c + 1\\<rbrakk>\n    \\<Longrightarrow> a div c \\<le> (b - 1) div c\n 2. \\<lbrakk>0 < c; a < b;\n     c \\<noteq> 0 \\<Longrightarrow>\n     (b - 1 + c) div c = (b - 1) div c + 1\\<rbrakk>\n    \\<Longrightarrow> a \\<le> b - 1", "apply (simp add: div_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c; a < b;\n     c \\<noteq> 0 \\<Longrightarrow>\n     (b - 1 + c) div c = (b - 1) div c + 1\\<rbrakk>\n    \\<Longrightarrow> a \\<le> b - 1", "apply (insert less_Suc_eq_le [of a \"b - 1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c; a < b;\n     c \\<noteq> 0 \\<Longrightarrow> (b - 1 + c) div c = (b - 1) div c + 1;\n     (a < Suc (b - 1)) = (a \\<le> b - 1)\\<rbrakk>\n    \\<Longrightarrow> a \\<le> b - 1", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma blockNumNELemma:\n  \"!!blockNum i.\n       [| nextFreeBlockInvariant cfile1;\n          cfile1\n          (| data :=\n               writeCArray (data cfile1) (byteIndex div blockSize)\n                (writeCArray\n                  (readCArray (data cfile1) (byteIndex div blockSize))\n                  (byteIndex mod blockSize) value) |) =\n          cfile2;\n          ~ blockNum < nextFreeBlock cfile2; blockNum < numBlocks;\n          i < blockSize; byteIndex div blockSize < numBlocks;\n          byteIndex < fileSize cfile1 |]\n       ==> blockNum ~= byteIndex div blockSize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>blockNum i.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        cfile1\n        \\<lparr>data :=\n                  writeCArray (data cfile1) (byteIndex div blockSize)\n                   (writeCArray\n                     (readCArray (data cfile1) (byteIndex div blockSize))\n                     (byteIndex mod blockSize) value)\\<rparr> =\n        cfile2;\n        \\<not> blockNum < nextFreeBlock cfile2; blockNum < numBlocks;\n        i < blockSize; byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> blockNum \\<noteq> byteIndex div blockSize", "apply (simp add: nextFreeBlockInvariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>blockNum i.\n       \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n                nextFreeBlock cfile1;\n        cfile1\n        \\<lparr>data :=\n                  writeCArray (data cfile1) (byteIndex div blockSize)\n                   (writeCArray\n                     (readCArray (data cfile1) (byteIndex div blockSize))\n                     (byteIndex mod blockSize) value)\\<rparr> =\n        cfile2;\n        \\<not> blockNum < nextFreeBlock cfile2; blockNum < numBlocks;\n        i < blockSize; byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> blockNum \\<noteq> byteIndex div blockSize", "apply (subgoal_tac \"byteIndex div blockSize < nextFreeBlock cfile1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>blockNum i.\n       \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n                nextFreeBlock cfile1;\n        cfile1\n        \\<lparr>data :=\n                  writeCArray (data cfile1) (byteIndex div blockSize)\n                   (writeCArray\n                     (readCArray (data cfile1) (byteIndex div blockSize))\n                     (byteIndex mod blockSize) value)\\<rparr> =\n        cfile2;\n        \\<not> blockNum < nextFreeBlock cfile2; blockNum < numBlocks;\n        i < blockSize; byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1;\n        byteIndex div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> blockNum \\<noteq> byteIndex div blockSize\n 2. \\<And>blockNum i.\n       \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n                nextFreeBlock cfile1;\n        cfile1\n        \\<lparr>data :=\n                  writeCArray (data cfile1) (byteIndex div blockSize)\n                   (writeCArray\n                     (readCArray (data cfile1) (byteIndex div blockSize))\n                     (byteIndex mod blockSize) value)\\<rparr> =\n        cfile2;\n        \\<not> blockNum < nextFreeBlock cfile2; blockNum < numBlocks;\n        i < blockSize; byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> byteIndex div blockSize < nextFreeBlock cfile1", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>blockNum i.\n       \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n                nextFreeBlock cfile1;\n        cfile1\n        \\<lparr>data :=\n                  writeCArray (data cfile1) (byteIndex div blockSize)\n                   (writeCArray\n                     (readCArray (data cfile1) (byteIndex div blockSize))\n                     (byteIndex mod blockSize) value)\\<rparr> =\n        cfile2;\n        \\<not> blockNum < nextFreeBlock cfile2; blockNum < numBlocks;\n        i < blockSize; byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> byteIndex div blockSize < nextFreeBlock cfile1", "apply (subgoal_tac \"nextFreeBlock cfile1 = \n  (fileSize cfile1 + blockSize - Suc 0) div blockSize\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>data :=\n                          writeCArray (data cfile1)\n                           (byteIndex div blockSize)\n                           (writeCArray\n                             (readCArray (data cfile1)\n                               (byteIndex div blockSize))\n                             (byteIndex mod blockSize) value)\\<rparr> =\n                cfile2;\n        \\<not> blockNum < nextFreeBlock cfile2; blockNum < numBlocks;\n        i < blockSize; byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1;\n        nextFreeBlock cfile1 =\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\\<rbrakk>\n       \\<Longrightarrow> byteIndex div blockSize\n                         < (fileSize cfile1 + blockSize - Suc 0) div\n                           blockSize", "apply (insert mod_round_lt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>data :=\n                          writeCArray (data cfile1)\n                           (byteIndex div blockSize)\n                           (writeCArray\n                             (readCArray (data cfile1)\n                               (byteIndex div blockSize))\n                             (byteIndex mod blockSize) value)\\<rparr> =\n                cfile2;\n        \\<not> blockNum < nextFreeBlock cfile2; blockNum < numBlocks;\n        i < blockSize; byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1;\n        nextFreeBlock cfile1 =\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n        \\<And>c a b.\n           \\<lbrakk>0 < c; a < b\\<rbrakk>\n           \\<Longrightarrow> a div c < (b + c - 1) div c\\<rbrakk>\n       \\<Longrightarrow> byteIndex div blockSize\n                         < (fileSize cfile1 + blockSize - Suc 0) div\n                           blockSize", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cfWritePreservesUnallocatedBlocksInvariant:\n   \"[| reachabilityInvariant cfile1;\n       cfWrite cfile1 byteIndex value = Some cfile2\n    |] ==> unallocatedBlocksInvariant cfile2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachabilityInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> unallocatedBlocksInvariant cfile2", "apply (simp add: reachabilityInvariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> unallocatedBlocksInvariant cfile2", "apply (subgoal_tac \"nextFreeBlock cfile1 <= nextFreeBlock cfile2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2\\<rbrakk>\n    \\<Longrightarrow> unallocatedBlocksInvariant cfile2\n 2. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp add: unallocatedBlocksInvariant_def cfWrite_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             (\\<forall>blockNum i.\n                 \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n                 blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n                 data cfile1 blockNum i = fillByte) \\<and>\n             lastBlockInvariant cfile1;\n     (if byteIndex div blockSize < numBlocks\n      then if byteIndex < fileSize cfile1\n           then Some (cfWriteNoExtend cfile1 byteIndex value)\n           else Some\n                 (cfWriteNoExtend (cfExtendFile cfile1 byteIndex) byteIndex\n                   value)\n      else None) =\n     Some cfile2;\n     nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>blockNum i.\n                         \\<not> blockNum < nextFreeBlock cfile2 \\<and>\n                         blockNum < numBlocks \\<and>\n                         i < blockSize \\<longrightarrow>\n                         data cfile2 blockNum i = fillByte\n 2. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>blockNum i.\n       \\<lbrakk>(if byteIndex div blockSize < numBlocks\n                 then if byteIndex < fileSize cfile1\n                      then Some (cfWriteNoExtend cfile1 byteIndex value)\n                      else Some\n                            (cfWriteNoExtend (cfExtendFile cfile1 byteIndex)\n                              byteIndex value)\n                 else None) =\n                Some cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 2. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (case_tac \"byteIndex div blockSize < numBlocks\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>blockNum i.\n       \\<lbrakk>(if byteIndex < fileSize cfile1\n                 then Some (cfWriteNoExtend cfile1 byteIndex value)\n                 else Some\n                       (cfWriteNoExtend (cfExtendFile cfile1 byteIndex)\n                         byteIndex value)) =\n                Some cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 2. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (case_tac \"byteIndex < fileSize cfile1\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>blockNum i.\n       \\<lbrakk>cfWriteNoExtend cfile1 byteIndex value = cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 2. \\<And>blockNum i.\n       \\<lbrakk>cfWriteNoExtend (cfExtendFile cfile1 byteIndex) byteIndex\n                 value =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 3. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp_all add: cfWriteNoExtend_def cfExtendFile_def Let_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>data :=\n                          writeCArray (data cfile1)\n                           (byteIndex div blockSize)\n                           (writeCArray\n                             (readCArray (data cfile1)\n                               (byteIndex div blockSize))\n                             (byteIndex mod blockSize) value)\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 2. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data :=\n                     writeCArray (data cfile1) (byteIndex div blockSize)\n                      (writeCArray\n                        (readCArray (data cfile1) (byteIndex div blockSize))\n                        (byteIndex mod blockSize) value)\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 3. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp_all add: writeCArray_def readCArray_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 2. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 3. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (subgoal_tac \"blockNum ~= byteIndex div blockSize\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks; byteIndex < fileSize cfile1;\n        blockNum \\<noteq> byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 2. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> blockNum \\<noteq> byteIndex div blockSize\n 3. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 4. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply force"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> blockNum \\<noteq> byteIndex div blockSize\n 2. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 3. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp add: blockNumNELemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 2. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (subgoal_tac \"~ blockNum < nextFreeBlock cfile1\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<not> blockNum < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 2. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> \\<not> blockNum < nextFreeBlock cfile1\n 3. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (subgoal_tac \"blockNum ~= byteIndex div blockSize\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<not> blockNum < nextFreeBlock cfile1;\n        blockNum \\<noteq> byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile2 blockNum i = fillByte\n 2. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<not> blockNum < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> blockNum \\<noteq> byteIndex div blockSize\n 3. \\<And>blockNum i.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2;\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> blockNum < nextFreeBlock cfile2;\n        blockNum < numBlocks; i < blockSize;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> \\<not> blockNum < nextFreeBlock cfile1\n 4. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp add: nextFreeBlockIncreases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cfWritePreservesLastBlockInvariant:\n   \"[| reachabilityInvariant cfile1;\n       cfWrite cfile1 byteIndex value = Some cfile2 |] ==> \n    lastBlockInvariant cfile2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachabilityInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> lastBlockInvariant cfile2", "apply (simp add: reachabilityInvariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> lastBlockInvariant cfile2", "apply (subgoal_tac \"nextFreeBlock cfile1 <= nextFreeBlock cfile2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2\\<rbrakk>\n    \\<Longrightarrow> lastBlockInvariant cfile2\n 2. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp add: cfWrite_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     (if byteIndex div blockSize < numBlocks\n      then if byteIndex < fileSize cfile1\n           then Some (cfWriteNoExtend cfile1 byteIndex value)\n           else Some\n                 (cfWriteNoExtend (cfExtendFile cfile1 byteIndex) byteIndex\n                   value)\n      else None) =\n     Some cfile2;\n     nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2\\<rbrakk>\n    \\<Longrightarrow> lastBlockInvariant cfile2\n 2. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp (no_asm) add: lastBlockInvariant_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     (if byteIndex div blockSize < numBlocks\n      then if byteIndex < fileSize cfile1\n           then Some (cfWriteNoExtend cfile1 byteIndex value)\n           else Some\n                 (cfWriteNoExtend (cfExtendFile cfile1 byteIndex) byteIndex\n                   value)\n      else None) =\n     Some cfile2;\n     nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>index.\n                         \\<not> index < fileSize cfile2 \\<and>\n                         nextFreeBlock cfile2 =\n                         Suc (index div blockSize) \\<longrightarrow>\n                         data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>(if byteIndex div blockSize < numBlocks\n                 then if byteIndex < fileSize cfile1\n                      then Some (cfWriteNoExtend cfile1 byteIndex value)\n                      else Some\n                            (cfWriteNoExtend (cfExtendFile cfile1 byteIndex)\n                              byteIndex value)\n                 else None) =\n                Some cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize)\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (case_tac \"byteIndex div blockSize < numBlocks\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>(if byteIndex < fileSize cfile1\n                 then Some (cfWriteNoExtend cfile1 byteIndex value)\n                 else Some\n                       (cfWriteNoExtend (cfExtendFile cfile1 byteIndex)\n                         byteIndex value)) =\n                Some cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (case_tac \"byteIndex < fileSize cfile1\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfWriteNoExtend cfile1 byteIndex value = cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfWriteNoExtend (cfExtendFile cfile1 byteIndex) byteIndex\n                 value =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 3. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp_all add: cfWriteNoExtend_def Let_def cfExtendFile_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data :=\n                          writeCArray (data cfile1)\n                           (byteIndex div blockSize)\n                           (writeCArray\n                             (readCArray (data cfile1)\n                               (byteIndex div blockSize))\n                             (byteIndex mod blockSize) value)\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data :=\n                     writeCArray (data cfile1) (byteIndex div blockSize)\n                      (writeCArray\n                        (readCArray (data cfile1) (byteIndex div blockSize))\n                        (byteIndex mod blockSize) value)\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 3. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp_all add: writeCArray_def readCArray_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 3. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp add: lastBlockInvariant_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 3. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (subgoal_tac \"index ~= byteIndex\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks; byteIndex < fileSize cfile1;\n        index \\<noteq> byteIndex\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 3. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 4. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (case_tac \"index div blockSize ~= byteIndex div blockSize\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks; byteIndex < fileSize cfile1;\n        index \\<noteq> byteIndex;\n        index div blockSize \\<noteq> byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks; byteIndex < fileSize cfile1;\n        index \\<noteq> byteIndex;\n        \\<not> index div blockSize \\<noteq> byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 3. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 4. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 5. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply force"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks; byteIndex < fileSize cfile1;\n        index \\<noteq> byteIndex;\n        \\<not> index div blockSize \\<noteq> byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 3. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 4. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (subgoal_tac \"index mod blockSize ~= byteIndex mod blockSize\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks; byteIndex < fileSize cfile1;\n        index \\<noteq> byteIndex;\n        \\<not> index div blockSize \\<noteq> byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks; byteIndex < fileSize cfile1;\n        index \\<noteq> byteIndex;\n        \\<not> index div blockSize \\<noteq> byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> index mod blockSize \\<noteq>\n                         byteIndex mod blockSize\n 3. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 4. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 5. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply force"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks; byteIndex < fileSize cfile1;\n        index \\<noteq> byteIndex;\n        \\<not> index div blockSize \\<noteq> byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> index mod blockSize \\<noteq>\n                         byteIndex mod blockSize\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 3. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 4. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (insert modInequalityLemma)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks; byteIndex < fileSize cfile1;\n        index \\<noteq> byteIndex;\n        \\<not> index div blockSize \\<noteq> byteIndex div blockSize;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> index mod blockSize \\<noteq>\n                         byteIndex mod blockSize\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks; byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 3. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 4. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply force"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>data := (data cfile1)\n                          (byteIndex div blockSize :=\n                             (data cfile1 (byteIndex div blockSize))\n                             (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks; byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 3. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (subgoal_tac \"index ~= byteIndex\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 3. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (case_tac \"index div blockSize ~= byteIndex div blockSize\", simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize \\<noteq> byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (index div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 3. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 4. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply force"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 3. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (subgoal_tac \"index mod blockSize ~= byteIndex mod blockSize\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> index mod blockSize \\<noteq>\n                         byteIndex mod blockSize\n 3. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 4. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (case_tac \"nextFreeBlock cfile1 = Suc (index div blockSize)\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize;\n        nextFreeBlock cfile1 = Suc (index div blockSize)\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize;\n        nextFreeBlock cfile1 \\<noteq> Suc (index div blockSize)\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 3. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> index mod blockSize \\<noteq>\n                         byteIndex mod blockSize\n 4. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 5. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (subgoal_tac \"~ index < fileSize cfile1\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize;\n        nextFreeBlock cfile1 = Suc (index div blockSize);\n        \\<not> index < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize;\n        nextFreeBlock cfile1 = Suc (index div blockSize)\\<rbrakk>\n       \\<Longrightarrow> \\<not> index < fileSize cfile1\n 3. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize;\n        nextFreeBlock cfile1 \\<noteq> Suc (index div blockSize)\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 4. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> index mod blockSize \\<noteq>\n                         byteIndex mod blockSize\n 5. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 6. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp add: lastBlockInvariant_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           byteIndex div blockSize = index div blockSize \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize;\n        nextFreeBlock cfile1 = Suc (byteIndex div blockSize);\n        \\<not> index < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize;\n        nextFreeBlock cfile1 = Suc (index div blockSize)\\<rbrakk>\n       \\<Longrightarrow> \\<not> index < fileSize cfile1\n 3. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize;\n        nextFreeBlock cfile1 \\<noteq> Suc (index div blockSize)\\<rbrakk>\n       \\<Longrightarrow> data cfile2 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 4. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (byteIndex div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index \\<noteq> byteIndex;\n        index div blockSize = byteIndex div blockSize\\<rbrakk>\n       \\<Longrightarrow> index mod blockSize \\<noteq>\n                         byteIndex mod blockSize\n 5. \\<And>index.\n       \\<lbrakk>cfile1\n                \\<lparr>fileSize := Suc byteIndex,\n                   nextFreeBlock := Suc (byteIndex div blockSize),\n                   data := (data cfile1)\n                     (byteIndex div blockSize :=\n                        (data cfile1 (byteIndex div blockSize))\n                        (byteIndex mod blockSize := value))\\<rparr> =\n                cfile2;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < fileSize cfile2;\n        nextFreeBlock cfile2 = Suc (index div blockSize);\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c\\<rbrakk>\n       \\<Longrightarrow> index \\<noteq> byteIndex\n 6. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n        lastBlockInvariant cfile1; \\<not> index < Suc byteIndex;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize;\n        nextFreeBlock cfile1 \\<noteq> Suc (byteIndex div blockSize);\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc byteIndex,\n           nextFreeBlock := Suc (byteIndex div blockSize),\n           data := (data cfile1)\n             (byteIndex div blockSize :=\n                (data cfile1 (byteIndex div blockSize))\n                (byteIndex mod blockSize := value))\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp add: unallocatedBlocksInvariant_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        lastBlockInvariant cfile1; \\<not> index < Suc byteIndex;\n        byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize;\n        nextFreeBlock cfile1 \\<noteq> Suc (byteIndex div blockSize);\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc byteIndex,\n           nextFreeBlock := Suc (byteIndex div blockSize),\n           data := (data cfile1)\n             (byteIndex div blockSize :=\n                (data cfile1 (byteIndex div blockSize))\n                (byteIndex mod blockSize := value))\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (erule_tac x=\"index div blockSize\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < Suc byteIndex; byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize;\n        nextFreeBlock cfile1 \\<noteq> Suc (byteIndex div blockSize);\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc byteIndex,\n           nextFreeBlock := Suc (byteIndex div blockSize),\n           data := (data cfile1)\n             (byteIndex div blockSize :=\n                (data cfile1 (byteIndex div blockSize))\n                (byteIndex mod blockSize := value))\\<rparr>;\n        \\<forall>i.\n           \\<not> index div blockSize < nextFreeBlock cfile1 \\<and>\n           index div blockSize < numBlocks \\<and>\n           i < blockSize \\<longrightarrow>\n           data cfile1 (index div blockSize) i = fillByte\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (erule_tac x=\"index mod blockSize\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>index.\n       \\<lbrakk>nextFreeBlock cfile1 \\<le> Suc (byteIndex div blockSize);\n        nextFreeBlockInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < Suc byteIndex; byteIndex div blockSize < numBlocks;\n        \\<not> byteIndex < fileSize cfile1;\n        \\<And>a b c.\n           a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n           a div c \\<noteq> b div c;\n        index div blockSize = byteIndex div blockSize;\n        index mod blockSize \\<noteq> byteIndex mod blockSize;\n        nextFreeBlock cfile1 \\<noteq> Suc (byteIndex div blockSize);\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc byteIndex,\n           nextFreeBlock := Suc (byteIndex div blockSize),\n           data := (data cfile1)\n             (byteIndex div blockSize :=\n                (data cfile1 (byteIndex div blockSize))\n                (byteIndex mod blockSize := value))\\<rparr>;\n        \\<not> index div blockSize < nextFreeBlock cfile1 \\<and>\n        index div blockSize < numBlocks \\<and>\n        index mod blockSize < blockSize \\<longrightarrow>\n        data cfile1 (index div blockSize) (index mod blockSize) =\n        fillByte\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (byteIndex div blockSize)\n                          (index mod blockSize) =\n                         fillByte\n 2. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp add: nonZeroBlockSize)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (insert modInequalityLemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfWrite cfile1 byteIndex value = Some cfile2;\n     nextFreeBlockInvariant cfile1; unallocatedBlocksInvariant cfile1;\n     lastBlockInvariant cfile1;\n     \\<And>a b c.\n        a \\<noteq> b \\<and> a mod c = b mod c \\<Longrightarrow>\n        a div c \\<noteq> b div c\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2", "apply (simp add: nextFreeBlockIncreases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Final statement that all invariants are preserved.\\<close>"], ["", "lemma cfWritePreserves: \n   \"[| reachabilityInvariant cfile1;\n       cfWrite cfile1 byteIndex value = Some cfile2 |] ==> \n    reachabilityInvariant cfile2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachabilityInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> reachabilityInvariant cfile2", "apply (simp (no_asm) add: reachabilityInvariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachabilityInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> nextFreeBlockInvariant cfile2 \\<and>\n                      unallocatedBlocksInvariant cfile2 \\<and>\n                      lastBlockInvariant cfile2", "apply (simp add: cfWritePreservesNextFreeBlockInvariant)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachabilityInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> unallocatedBlocksInvariant cfile2 \\<and>\n                      lastBlockInvariant cfile2", "apply (simp add: cfWritePreservesUnallocatedBlocksInvariant)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachabilityInvariant cfile1;\n     cfWrite cfile1 byteIndex value = Some cfile2\\<rbrakk>\n    \\<Longrightarrow> lastBlockInvariant cfile2", "apply (simp add: cfWritePreservesLastBlockInvariant)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* ---------------------------------------------------------------*)"], ["", "subsection \\<open>Commuting Diagrams for Simulation Relation\\<close>"], ["", "text \\<open>Here we show correctness of file system operations.\\<close>"], ["", "(* ---------------------------------------------------------------*)"], ["", "subsubsection \\<open>Abstraction Function\\<close>"], ["", "definition abstFn :: \"CFile => AFile\" where\n  \"abstFn cfile == (fileSize cfile, \n                    % index . case cfRead cfile index of\n                                None       => fillByte\n                              | Some value => value)\""], ["", "primrec oAbstFn :: \"CFile option => AFile option\" where\n  \"oAbstFn None = None\"\n| \"oAbstFn (Some s) = Some (abstFn s)\""], ["", "(* ---------------------------------------------------------------*)"], ["", "subsubsection \\<open>Creating a File\\<close>"], ["", "lemma makeCFCorrect: \"abstFn makeCF = makeAF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abstFn makeCF = makeAF", "by (simp add: makeCF_def makeAF_def abstFn_def cfRead_def\n    split: bool.splits option.splits)"], ["", "subsubsection \\<open>File Size\\<close>"], ["", "lemma fileSizeCorrect:\n  \"cfSize cfile = afSize (abstFn cfile)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfSize cfile = afSize (abstFn cfile)", "by (simp add: cfSize_def afSize_def abstFn_def)"], ["", "subsubsection \\<open>Read Operation\\<close>"], ["", "lemma readCorrect:\n  \"cfRead cfile = afRead (abstFn cfile)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfRead cfile = afRead (abstFn cfile)", "apply (simp add: abstFn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfRead cfile =\n    afRead\n     (fileSize cfile,\n      \\<lambda>index.\n         case cfRead cfile index of None \\<Rightarrow> fillByte\n         | Some value \\<Rightarrow> value)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       cfRead cfile x =\n       afRead\n        (fileSize cfile,\n         \\<lambda>index.\n            case cfRead cfile index of None \\<Rightarrow> fillByte\n            | Some value \\<Rightarrow> value)\n        x", "apply (simp add: cfRead_def afRead_def Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Write Operation\\<close>"], ["", "lemma writeNoExtendCorrect:\n  \"[| index < fileSize cfile1;\n      Some cfile2 = cfWrite cfile1 index value\n   |] ==> Some (abstFn cfile2) = afWrite (abstFn cfile1) index value\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index < fileSize cfile1;\n     Some cfile2 = cfWrite cfile1 index value\\<rbrakk>\n    \\<Longrightarrow> Some (abstFn cfile2) =\n                      afWrite (abstFn cfile1) index value", "apply (simp add: abstFn_def afWrite_def raWrite_def Let_def cfWrite_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index < fileSize cfile1;\n     Some cfile2 =\n     (if index div blockSize < numBlocks\n      then if index < fileSize cfile1\n           then Some (cfWriteNoExtend cfile1 index value)\n           else Some\n                 (cfWriteNoExtend (cfExtendFile cfile1 index) index value)\n      else None)\\<rbrakk>\n    \\<Longrightarrow> (index div blockSize < numBlocks \\<longrightarrow>\n                       fileSize cfile2 = fileSize cfile1 \\<and>\n                       (\\<lambda>index.\n                           case cfRead cfile2 index of\n                           None \\<Rightarrow> fillByte\n                           | Some value \\<Rightarrow> value) =\n                       (\\<lambda>index.\n                           case cfRead cfile1 index of\n                           None \\<Rightarrow> fillByte\n                           | Some value \\<Rightarrow> value)\n                       (index := value)) \\<and>\n                      index div blockSize < numBlocks", "apply (case_tac \"index div blockSize < numBlocks\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index < fileSize cfile1;\n     cfile2 = cfWriteNoExtend cfile1 index value;\n     index div blockSize < numBlocks\\<rbrakk>\n    \\<Longrightarrow> fileSize (cfWriteNoExtend cfile1 index value) =\n                      fileSize cfile1 \\<and>\n                      (\\<lambda>indexa.\n                          case cfRead (cfWriteNoExtend cfile1 index value)\n                                indexa of\n                          None \\<Rightarrow> fillByte\n                          | Some value \\<Rightarrow> value) =\n                      (\\<lambda>index.\n                          case cfRead cfile1 index of\n                          None \\<Rightarrow> fillByte\n                          | Some value \\<Rightarrow> value)\n                      (index := value)", "apply (simp_all add: cfWriteNoExtend_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index < fileSize cfile1;\n     cfile2 = cfile1\n     \\<lparr>data :=\n               writeCArray (data cfile1) (index div blockSize)\n                (writeCArray\n                  (readCArray (data cfile1) (index div blockSize))\n                  (index mod blockSize) value)\\<rparr>;\n     index div blockSize < numBlocks\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>indexa.\n                          case cfRead\n                                (cfile1\n                                 \\<lparr>data :=\n     writeCArray (data cfile1) (index div blockSize)\n      (writeCArray (readCArray (data cfile1) (index div blockSize))\n        (index mod blockSize) value)\\<rparr>)\n                                indexa of\n                          None \\<Rightarrow> fillByte\n                          | Some value \\<Rightarrow> value) =\n                      (\\<lambda>index.\n                          case cfRead cfile1 index of\n                          None \\<Rightarrow> fillByte\n                          | Some value \\<Rightarrow> value)\n                      (index := value)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>data :=\n                  writeCArray (data cfile1) (index div blockSize)\n                   (writeCArray\n                     (readCArray (data cfile1) (index div blockSize))\n                     (index mod blockSize) value)\\<rparr>;\n        index div blockSize < numBlocks\\<rbrakk>\n       \\<Longrightarrow> (case cfRead\n                                (cfile1\n                                 \\<lparr>data :=\n     writeCArray (data cfile1) (index div blockSize)\n      (writeCArray (readCArray (data cfile1) (index div blockSize))\n        (index mod blockSize) value)\\<rparr>)\n                                indexa of\n                          None \\<Rightarrow> fillByte\n                          | Some value \\<Rightarrow> value) =\n                         ((\\<lambda>index.\n                              case cfRead cfile1 index of\n                              None \\<Rightarrow> fillByte\n                              | Some value \\<Rightarrow> value)\n                          (index := value))\n                          indexa", "apply (simp add: cfRead_def writeCArray_def readCArray_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>data := (data cfile1)\n                  (index div blockSize :=\n                     (data cfile1 (index div blockSize))\n                     (index mod blockSize := value))\\<rparr>;\n        index div blockSize < numBlocks\\<rbrakk>\n       \\<Longrightarrow> indexa mod blockSize =\n                         index mod blockSize \\<longrightarrow>\n                         indexa div blockSize =\n                         index div blockSize \\<longrightarrow>\n                         indexa < fileSize cfile1 \\<longrightarrow>\n                         indexa \\<noteq> index \\<longrightarrow>\n                         value =\n                         data cfile1 (index div blockSize)\n                          (index mod blockSize)", "apply (case_tac \"indexa < fileSize cfile1\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>data := (data cfile1)\n                  (index div blockSize :=\n                     (data cfile1 (index div blockSize))\n                     (index mod blockSize := value))\\<rparr>;\n        index div blockSize < numBlocks; indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa mod blockSize =\n                         index mod blockSize \\<longrightarrow>\n                         indexa div blockSize =\n                         index div blockSize \\<longrightarrow>\n                         indexa \\<noteq> index \\<longrightarrow>\n                         value =\n                         data cfile1 (index div blockSize)\n                          (index mod blockSize)", "apply (case_tac \"indexa = index\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>data := (data cfile1)\n                  (index div blockSize :=\n                     (data cfile1 (index div blockSize))\n                     (index mod blockSize := value))\\<rparr>;\n        index div blockSize < numBlocks; indexa < fileSize cfile1;\n        indexa \\<noteq> index\\<rbrakk>\n       \\<Longrightarrow> indexa mod blockSize =\n                         index mod blockSize \\<longrightarrow>\n                         indexa div blockSize =\n                         index div blockSize \\<longrightarrow>\n                         value =\n                         data cfile1 (index div blockSize)\n                          (index mod blockSize)", "apply (case_tac \"indexa mod blockSize = index mod blockSize\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>data := (data cfile1)\n                  (index div blockSize :=\n                     (data cfile1 (index div blockSize))\n                     (index mod blockSize := value))\\<rparr>;\n        index div blockSize < numBlocks; indexa < fileSize cfile1;\n        indexa \\<noteq> index;\n        indexa mod blockSize = index mod blockSize\\<rbrakk>\n       \\<Longrightarrow> indexa div blockSize =\n                         index div blockSize \\<longrightarrow>\n                         value =\n                         data cfile1 (index div blockSize)\n                          (index mod blockSize)", "apply (subgoal_tac \"indexa div blockSize ~= index div blockSize\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>data := (data cfile1)\n                  (index div blockSize :=\n                     (data cfile1 (index div blockSize))\n                     (index mod blockSize := value))\\<rparr>;\n        index div blockSize < numBlocks; indexa < fileSize cfile1;\n        indexa \\<noteq> index;\n        indexa mod blockSize = index mod blockSize\\<rbrakk>\n       \\<Longrightarrow> indexa div blockSize \\<noteq> index div blockSize", "apply (simp_all add: modInequalityLemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma writeExtendCorrect:\n  \"[| nextFreeBlockInvariant cfile1;\n      unallocatedBlocksInvariant cfile1;\n      lastBlockInvariant cfile1;\n      ~ index < fileSize cfile1;\n      Some cfile2 = cfWrite cfile1 index value\n   |] ==> Some (abstFn cfile2) = afWrite (abstFn cfile1) index value\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n     \\<not> index < fileSize cfile1;\n     Some cfile2 = cfWrite cfile1 index value\\<rbrakk>\n    \\<Longrightarrow> Some (abstFn cfile2) =\n                      afWrite (abstFn cfile1) index value", "apply (insert nextFreeBlockIncreases [of cfile1 index \"value\" cfile2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n     \\<not> index < fileSize cfile1;\n     Some cfile2 = cfWrite cfile1 index value;\n     \\<lbrakk>nextFreeBlockInvariant cfile1;\n      cfWrite cfile1 index value = Some cfile2\\<rbrakk>\n     \\<Longrightarrow> nextFreeBlock cfile1\n                       \\<le> nextFreeBlock cfile2\\<rbrakk>\n    \\<Longrightarrow> Some (abstFn cfile2) =\n                      afWrite (abstFn cfile1) index value", "apply (simp add: abstFn_def afWrite_def raWrite_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n     \\<not> index < fileSize cfile1;\n     Some cfile2 = cfWrite cfile1 index value;\n     nextFreeBlock cfile1 \\<le> nextFreeBlock cfile2\\<rbrakk>\n    \\<Longrightarrow> (index div blockSize < numBlocks \\<longrightarrow>\n                       fileSize cfile2 = Suc index \\<and>\n                       (\\<lambda>index.\n                           case cfRead cfile2 index of\n                           None \\<Rightarrow> fillByte\n                           | Some value \\<Rightarrow> value) =\n                       fillAndUpdate (fileSize cfile1)\n                        (\\<lambda>index.\n                            case cfRead cfile1 index of\n                            None \\<Rightarrow> fillByte\n                            | Some value \\<Rightarrow> value)\n                        index value fillByte) \\<and>\n                      index div blockSize < numBlocks", "apply (case_tac \"~ index div blockSize < numBlocks\",\n  simp_all add: cfWrite_def cfWriteNoExtend_def cfExtendFile_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n     \\<not> index < fileSize cfile1;\n     cfile2 = cfile1\n     \\<lparr>fileSize := Suc index,\n        nextFreeBlock := Suc (index div blockSize),\n        data :=\n          writeCArray (data cfile1) (index div blockSize)\n           (writeCArray (readCArray (data cfile1) (index div blockSize))\n             (index mod blockSize) value)\\<rparr>;\n     nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n     index div blockSize < numBlocks\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>indexa.\n                          case cfRead\n                                (cfile1\n                                 \\<lparr>fileSize := Suc index,\n                                    nextFreeBlock :=\nSuc (index div blockSize),\n                                    data :=\nwriteCArray (data cfile1) (index div blockSize)\n (writeCArray (readCArray (data cfile1) (index div blockSize))\n   (index mod blockSize) value)\\<rparr>)\n                                indexa of\n                          None \\<Rightarrow> fillByte\n                          | Some value \\<Rightarrow> value) =\n                      fillAndUpdate (fileSize cfile1)\n                       (\\<lambda>index.\n                           case cfRead cfile1 index of\n                           None \\<Rightarrow> fillByte\n                           | Some value \\<Rightarrow> value)\n                       index value fillByte", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks\\<rbrakk>\n       \\<Longrightarrow> (case cfRead\n                                (cfile1\n                                 \\<lparr>fileSize := Suc index,\n                                    nextFreeBlock :=\nSuc (index div blockSize),\n                                    data :=\nwriteCArray (data cfile1) (index div blockSize)\n (writeCArray (readCArray (data cfile1) (index div blockSize))\n   (index mod blockSize) value)\\<rparr>)\n                                indexa of\n                          None \\<Rightarrow> fillByte\n                          | Some value \\<Rightarrow> value) =\n                         fillAndUpdate (fileSize cfile1)\n                          (\\<lambda>index.\n                              case cfRead cfile1 index of\n                              None \\<Rightarrow> fillByte\n                              | Some value \\<Rightarrow> value)\n                          index value fillByte indexa", "apply (simp add: cfRead_def fillAndUpdate_def Let_def writeCArrayCorrect1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks\\<rbrakk>\n       \\<Longrightarrow> (indexa < fileSize cfile1 \\<longrightarrow>\n                          readCArray\n                           (readCArray\n                             (writeCArray (data cfile1)\n                               (index div blockSize)\n                               (writeCArray\n                                 (readCArray (data cfile1)\n                                   (index div blockSize))\n                                 (index mod blockSize) value))\n                             (indexa div blockSize))\n                           (indexa mod blockSize) =\n                          readCArray\n                           (readCArray (data cfile1) (indexa div blockSize))\n                           (indexa mod blockSize)) \\<and>\n                         (\\<not> indexa < fileSize cfile1 \\<longrightarrow>\n                          indexa < index \\<longrightarrow>\n                          readCArray\n                           (readCArray\n                             (writeCArray (data cfile1)\n                               (index div blockSize)\n                               (writeCArray\n                                 (readCArray (data cfile1)\n                                   (index div blockSize))\n                                 (index mod blockSize) value))\n                             (indexa div blockSize))\n                           (indexa mod blockSize) =\n                          fillByte)", "apply (case_tac \"indexa < fileSize cfile1\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         readCArray\n                          (readCArray (data cfile1) (indexa div blockSize))\n                          (indexa mod blockSize)\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks;\n        \\<not> indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa < index \\<longrightarrow>\n                         readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "(* 2 subgoals *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         readCArray\n                          (readCArray (data cfile1) (indexa div blockSize))\n                          (indexa mod blockSize)\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks;\n        \\<not> indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa < index \\<longrightarrow>\n                         readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "apply (subgoal_tac \"indexa ~= index\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         readCArray\n                          (readCArray (data cfile1) (indexa div blockSize))\n                          (indexa mod blockSize)\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks;\n        \\<not> indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa < index \\<longrightarrow>\n                         readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "apply (case_tac \"indexa div blockSize = index div blockSize\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; indexa < fileSize cfile1;\n        indexa div blockSize = index div blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         readCArray\n                          (readCArray (data cfile1) (indexa div blockSize))\n                          (indexa mod blockSize)\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; indexa < fileSize cfile1;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         readCArray\n                          (readCArray (data cfile1) (indexa div blockSize))\n                          (indexa mod blockSize)\n 3. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks;\n        \\<not> indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa < index \\<longrightarrow>\n                         readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "(* 3 subgoals *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; indexa < fileSize cfile1;\n        indexa div blockSize = index div blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         readCArray\n                          (readCArray (data cfile1) (indexa div blockSize))\n                          (indexa mod blockSize)\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; indexa < fileSize cfile1;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         readCArray\n                          (readCArray (data cfile1) (indexa div blockSize))\n                          (indexa mod blockSize)\n 3. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks;\n        \\<not> indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa < index \\<longrightarrow>\n                         readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "apply (case_tac \"indexa mod blockSize = index mod blockSize\",\n  simp add: modInequalityLemma)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; indexa < fileSize cfile1;\n        indexa div blockSize = index div blockSize;\n        indexa mod blockSize \\<noteq> index mod blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         readCArray\n                          (readCArray (data cfile1) (indexa div blockSize))\n                          (indexa mod blockSize)\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; indexa < fileSize cfile1;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         readCArray\n                          (readCArray (data cfile1) (indexa div blockSize))\n                          (indexa mod blockSize)\n 3. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks;\n        \\<not> indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa < index \\<longrightarrow>\n                         readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "(* 3 subgoals *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; indexa < fileSize cfile1;\n        indexa div blockSize = index div blockSize;\n        indexa mod blockSize \\<noteq> index mod blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         readCArray\n                          (readCArray (data cfile1) (indexa div blockSize))\n                          (indexa mod blockSize)\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; indexa < fileSize cfile1;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         readCArray\n                          (readCArray (data cfile1) (indexa div blockSize))\n                          (indexa mod blockSize)\n 3. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks;\n        \\<not> indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa < index \\<longrightarrow>\n                         readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "apply (simp_all add: writeCArrayCorrect1 writeCArrayCorrect2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks;\n        \\<not> indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa < index \\<longrightarrow>\n                         readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "(* 1 subgoal *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        \\<not> index < fileSize cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks;\n        \\<not> indexa < fileSize cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa < index \\<longrightarrow>\n                         readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "apply (case_tac \"indexa < index\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "apply (case_tac \"indexa div blockSize = index div blockSize\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize = index div blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "(* 2 subgoals *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize = index div blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "apply (case_tac \"indexa mod blockSize = index mod blockSize\",\n  simp add: modInequalityLemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize = index div blockSize;\n        indexa mod blockSize \\<noteq> index mod blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data :=\n             writeCArray (data cfile1) (index div blockSize)\n              (writeCArray (readCArray (data cfile1) (index div blockSize))\n                (index mod blockSize) value)\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> readCArray\n                          (readCArray\n                            (writeCArray (data cfile1) (index div blockSize)\n                              (writeCArray\n                                (readCArray (data cfile1)\n                                  (index div blockSize))\n                                (index mod blockSize) value))\n                            (indexa div blockSize))\n                          (indexa mod blockSize) =\n                         fillByte", "apply (simp_all add: readCArray_def writeCArray_def lastBlockInvariant_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize = index div blockSize;\n        indexa mod blockSize \\<noteq> index mod blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (index div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply (erule_tac x=indexa in allE, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize = index div blockSize;\n        indexa mod blockSize \\<noteq> index mod blockSize;\n        nextFreeBlock cfile1 = Suc (index div blockSize) \\<longrightarrow>\n        data cfile1 (index div blockSize) (indexa mod blockSize) =\n        fillByte\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (index div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply (case_tac \"nextFreeBlock cfile1 = nextFreeBlock cfile2\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize = index div blockSize;\n        indexa mod blockSize \\<noteq> index mod blockSize;\n        nextFreeBlock cfile1 \\<noteq> Suc (index div blockSize)\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (index div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply (simp add: unallocatedBlocksInvariant_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize = index div blockSize;\n        indexa mod blockSize \\<noteq> index mod blockSize;\n        nextFreeBlock cfile1 \\<noteq> Suc (index div blockSize)\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (index div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply (subgoal_tac \"~ indexa div blockSize < nextFreeBlock cfile1\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize = index div blockSize;\n        indexa mod blockSize \\<noteq> index mod blockSize;\n        \\<not> index div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (index div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply (subgoal_tac \"indexa mod blockSize < blockSize\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize = index div blockSize;\n        indexa mod blockSize \\<noteq> index mod blockSize;\n        \\<not> index div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa mod blockSize < blockSize\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index;\n        indexa div blockSize \\<noteq> index div blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply (insert nonZeroBlockSize)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize = index div blockSize;\n        indexa mod blockSize \\<noteq> index mod blockSize;\n        \\<not> index div blockSize < nextFreeBlock cfile1;\n        0 < blockSize\\<rbrakk>\n       \\<Longrightarrow> indexa mod blockSize < blockSize\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "(* 1 subgoal *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        unallocatedBlocksInvariant cfile1;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply (simp add: unallocatedBlocksInvariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply (case_tac \"~ indexa div blockSize < nextFreeBlock cfile1\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize;\n        \\<not> indexa div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize; indexa div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply (subgoal_tac \"indexa div blockSize < numBlocks\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize;\n        \\<not> indexa div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa div blockSize < numBlocks\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize; indexa div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "(* 2 subgoals *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize;\n        \\<not> indexa div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa div blockSize < numBlocks\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize; indexa div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply (subgoal_tac \"indexa div blockSize <= index div blockSize\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize;\n        \\<not> indexa div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> indexa div blockSize \\<le> index div blockSize\n 2. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize; indexa div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply (simp add: div_le_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize; indexa div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "(* 1 subgoal *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize; indexa div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> data cfile1 (indexa div blockSize)\n                          (indexa mod blockSize) =\n                         fillByte", "apply (subgoal_tac \"nextFreeBlock cfile1 = Suc (indexa div blockSize)\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>nextFreeBlockInvariant cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize; indexa div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> nextFreeBlock cfile1 = Suc (indexa div blockSize)", "apply (simp add: nextFreeBlockInvariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>(fileSize cfile1 + blockSize - Suc 0) div blockSize =\n                nextFreeBlock cfile1;\n        \\<forall>blockNum i.\n           \\<not> blockNum < nextFreeBlock cfile1 \\<and>\n           blockNum < numBlocks \\<and> i < blockSize \\<longrightarrow>\n           data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           nextFreeBlock cfile1 =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        nextFreeBlock cfile1 \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize; indexa div blockSize < nextFreeBlock cfile1\\<rbrakk>\n       \\<Longrightarrow> nextFreeBlock cfile1 = Suc (indexa div blockSize)", "apply (subgoal_tac \"nextFreeBlock cfile1 = \n  (fileSize cfile1 + blockSize - Suc 0) div blockSize\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>\\<forall>blockNum i.\n                   \\<not> blockNum\n                          < (fileSize cfile1 + blockSize - Suc 0) div\n                            blockSize \\<and>\n                   blockNum < numBlocks \\<and>\n                   i < blockSize \\<longrightarrow>\n                   data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           (fileSize cfile1 + blockSize - Suc 0) div blockSize =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\n        \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize;\n        indexa div blockSize\n        < (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n        nextFreeBlock cfile1 =\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\\<rbrakk>\n       \\<Longrightarrow> (fileSize cfile1 + blockSize - Suc 0) div\n                         blockSize =\n                         Suc (indexa div blockSize)", "apply (subgoal_tac \"(fileSize cfile1 + blockSize - Suc 0) div blockSize <=\n  Suc (indexa div blockSize)\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>\\<forall>blockNum i.\n                   \\<not> blockNum\n                          < (fileSize cfile1 + blockSize - Suc 0) div\n                            blockSize \\<and>\n                   blockNum < numBlocks \\<and>\n                   i < blockSize \\<longrightarrow>\n                   data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           (fileSize cfile1 + blockSize - Suc 0) div blockSize =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\n        \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize;\n        indexa div blockSize\n        < (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n        nextFreeBlock cfile1 =\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\\<rbrakk>\n       \\<Longrightarrow> (fileSize cfile1 + blockSize - Suc 0) div blockSize\n                         \\<le> Suc (indexa div blockSize)", "apply (subgoal_tac \"Suc (indexa div blockSize) = \n  (indexa + blockSize) div blockSize\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>\\<forall>blockNum i.\n                   \\<not> blockNum\n                          < (fileSize cfile1 + blockSize - Suc 0) div\n                            blockSize \\<and>\n                   blockNum < numBlocks \\<and>\n                   i < blockSize \\<longrightarrow>\n                   data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           (fileSize cfile1 + blockSize - Suc 0) div blockSize =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\n        \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize;\n        indexa div blockSize\n        < (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n        nextFreeBlock cfile1 =\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n        Suc (indexa div blockSize) =\n        (indexa + blockSize) div blockSize\\<rbrakk>\n       \\<Longrightarrow> (fileSize cfile1 + blockSize - Suc 0) div blockSize\n                         \\<le> Suc (indexa div blockSize)\n 2. \\<And>indexa.\n       \\<lbrakk>\\<forall>blockNum i.\n                   \\<not> blockNum\n                          < (fileSize cfile1 + blockSize - Suc 0) div\n                            blockSize \\<and>\n                   blockNum < numBlocks \\<and>\n                   i < blockSize \\<longrightarrow>\n                   data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           (fileSize cfile1 + blockSize - Suc 0) div blockSize =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\n        \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize;\n        indexa div blockSize\n        < (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n        nextFreeBlock cfile1 =\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\\<rbrakk>\n       \\<Longrightarrow> Suc (indexa div blockSize) =\n                         (indexa + blockSize) div blockSize", "apply (simp only:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>\\<forall>blockNum i.\n                   \\<not> blockNum\n                          < (fileSize cfile1 + blockSize - Suc 0) div\n                            blockSize \\<and>\n                   blockNum < numBlocks \\<and>\n                   i < blockSize \\<longrightarrow>\n                   data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           (fileSize cfile1 + blockSize - Suc 0) div blockSize =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\n        \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize;\n        indexa div blockSize\n        < (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n        nextFreeBlock cfile1 =\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n        Suc (indexa div blockSize) =\n        (indexa + blockSize) div blockSize\\<rbrakk>\n       \\<Longrightarrow> (fileSize cfile1 + blockSize - Suc 0) div blockSize\n                         \\<le> (indexa + blockSize) div blockSize\n 2. \\<And>indexa.\n       \\<lbrakk>\\<forall>blockNum i.\n                   \\<not> blockNum\n                          < (fileSize cfile1 + blockSize - Suc 0) div\n                            blockSize \\<and>\n                   blockNum < numBlocks \\<and>\n                   i < blockSize \\<longrightarrow>\n                   data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           (fileSize cfile1 + blockSize - Suc 0) div blockSize =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\n        \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize;\n        indexa div blockSize\n        < (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n        nextFreeBlock cfile1 =\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\\<rbrakk>\n       \\<Longrightarrow> Suc (indexa div blockSize) =\n                         (indexa + blockSize) div blockSize", "apply (rule div_le_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>indexa.\n       \\<lbrakk>\\<forall>blockNum i.\n                   \\<not> blockNum\n                          < (fileSize cfile1 + blockSize - Suc 0) div\n                            blockSize \\<and>\n                   blockNum < numBlocks \\<and>\n                   i < blockSize \\<longrightarrow>\n                   data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           (fileSize cfile1 + blockSize - Suc 0) div blockSize =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\n        \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize;\n        indexa div blockSize\n        < (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n        nextFreeBlock cfile1 =\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n        Suc (indexa div blockSize) =\n        (indexa + blockSize) div blockSize\\<rbrakk>\n       \\<Longrightarrow> fileSize cfile1 + blockSize - Suc 0\n                         \\<le> indexa + blockSize\n 2. \\<And>indexa.\n       \\<lbrakk>\\<forall>blockNum i.\n                   \\<not> blockNum\n                          < (fileSize cfile1 + blockSize - Suc 0) div\n                            blockSize \\<and>\n                   blockNum < numBlocks \\<and>\n                   i < blockSize \\<longrightarrow>\n                   data cfile1 blockNum i = fillByte;\n        \\<forall>index.\n           \\<not> index < fileSize cfile1 \\<and>\n           (fileSize cfile1 + blockSize - Suc 0) div blockSize =\n           Suc (index div blockSize) \\<longrightarrow>\n           data cfile1 (index div blockSize) (index mod blockSize) =\n           fillByte;\n        cfile2 = cfile1\n        \\<lparr>fileSize := Suc index,\n           nextFreeBlock := Suc (index div blockSize),\n           data := (data cfile1)\n             (index div blockSize := (data cfile1 (index div blockSize))\n                (index mod blockSize := value))\\<rparr>;\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\n        \\<le> Suc (index div blockSize);\n        index div blockSize < numBlocks; \\<not> indexa < fileSize cfile1;\n        indexa < index; indexa div blockSize \\<noteq> index div blockSize;\n        0 < blockSize;\n        indexa div blockSize\n        < (fileSize cfile1 + blockSize - Suc 0) div blockSize;\n        nextFreeBlock cfile1 =\n        (fileSize cfile1 + blockSize - Suc 0) div blockSize\\<rbrakk>\n       \\<Longrightarrow> Suc (indexa div blockSize) =\n                         (indexa + blockSize) div blockSize", "apply (simp_all add: le_diff_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma writeSucceedCorrect:\n  \"[| nextFreeBlockInvariant cfile1;\n      unallocatedBlocksInvariant cfile1;\n      lastBlockInvariant cfile1;\n      Some cfile2 = cfWrite cfile1 index value\n   |] ==> Some (abstFn cfile2) = afWrite (abstFn cfile1) index value\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n     Some cfile2 = cfWrite cfile1 index value\\<rbrakk>\n    \\<Longrightarrow> Some (abstFn cfile2) =\n                      afWrite (abstFn cfile1) index value", "apply (case_tac \"index < fileSize cfile1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n     Some cfile2 = cfWrite cfile1 index value;\n     index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> Some (abstFn cfile2) =\n                      afWrite (abstFn cfile1) index value\n 2. \\<lbrakk>nextFreeBlockInvariant cfile1;\n     unallocatedBlocksInvariant cfile1; lastBlockInvariant cfile1;\n     Some cfile2 = cfWrite cfile1 index value;\n     \\<not> index < fileSize cfile1\\<rbrakk>\n    \\<Longrightarrow> Some (abstFn cfile2) =\n                      afWrite (abstFn cfile1) index value", "apply (simp_all add: writeExtendCorrect writeNoExtendCorrect)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma writeFailCorrect:\n  \"cfWrite cfile1 index value = None ==> \n   afWrite (abstFn cfile1) index value = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfWrite cfile1 index value = None \\<Longrightarrow>\n    afWrite (abstFn cfile1) index value = None", "apply (simp add: abstFn_def cfWrite_def afWrite_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if index div blockSize < numBlocks\n     then if index < fileSize cfile1\n          then Some (cfWriteNoExtend cfile1 index value)\n          else Some\n                (cfWriteNoExtend (cfExtendFile cfile1 index) index value)\n     else None) =\n    None \\<Longrightarrow>\n    \\<not> index div blockSize < numBlocks", "apply (case_tac \"index div blockSize < numBlocks\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if index < fileSize cfile1\n              then Some (cfWriteNoExtend cfile1 index value)\n              else Some\n                    (cfWriteNoExtend (cfExtendFile cfile1 index) index\n                      value)) =\n             None;\n     index div blockSize < numBlocks\\<rbrakk>\n    \\<Longrightarrow> False", "apply (case_tac \"index < fileSize cfile1\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma writeCorrect:\n  \"reachabilityInvariant cfile1 ==>\n   oAbstFn (cfWrite cfile1 index value) = afWrite (abstFn cfile1) index value\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachabilityInvariant cfile1 \\<Longrightarrow>\n    oAbstFn (cfWrite cfile1 index value) =\n    afWrite (abstFn cfile1) index value", "apply (simp add: reachabilityInvariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nextFreeBlockInvariant cfile1 \\<and>\n    unallocatedBlocksInvariant cfile1 \\<and>\n    lastBlockInvariant cfile1 \\<Longrightarrow>\n    oAbstFn (cfWrite cfile1 index value) =\n    afWrite (abstFn cfile1) index value", "apply (case_tac \"cfWrite cfile1 index value\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n             unallocatedBlocksInvariant cfile1 \\<and>\n             lastBlockInvariant cfile1;\n     cfWrite cfile1 index value = None\\<rbrakk>\n    \\<Longrightarrow> oAbstFn (cfWrite cfile1 index value) =\n                      afWrite (abstFn cfile1) index value\n 2. \\<And>a.\n       \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n                unallocatedBlocksInvariant cfile1 \\<and>\n                lastBlockInvariant cfile1;\n        cfWrite cfile1 index value = Some a\\<rbrakk>\n       \\<Longrightarrow> oAbstFn (cfWrite cfile1 index value) =\n                         afWrite (abstFn cfile1) index value", "apply (simp add: writeFailCorrect)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>nextFreeBlockInvariant cfile1 \\<and>\n                unallocatedBlocksInvariant cfile1 \\<and>\n                lastBlockInvariant cfile1;\n        cfWrite cfile1 index value = Some a\\<rbrakk>\n       \\<Longrightarrow> oAbstFn (cfWrite cfile1 index value) =\n                         afWrite (abstFn cfile1) index value", "apply (simp add: writeSucceedCorrect)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}