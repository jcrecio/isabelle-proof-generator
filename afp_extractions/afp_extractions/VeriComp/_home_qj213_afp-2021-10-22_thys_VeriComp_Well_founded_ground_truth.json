{"file_name": "/home/qj213/afp-2021-10-22/thys/VeriComp/Well_founded.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VeriComp", "problem_names": ["lemmas induct = wfP_induct_rule[OF wf]", "lemma wfP_unit: \"wfP (\\<lambda>() (). False)\"", "lemma lex_prodp_lex_prod:\n  shows \"lex_prodp x y \\<longleftrightarrow> (x, y) \\<in> lex_prod { (x, y). r1 x y } { (x, y). r2 x y }\"", "lemma lex_prodp_wfP:\n  assumes\n    \"wfP r1\" and\n    \"wfP r2\"\n  shows \"wfP lex_prodp\"", "lemma lex_prodp_well_founded:\n  assumes\n    \"well_founded r1\" and\n    \"well_founded r2\"\n  shows \"well_founded (lex_prodp r1 r2)\"", "lemma lexp_prepend: \"lexp order ys zs \\<Longrightarrow> lexp order (xs @ ys) (xs @ zs)\"", "lemma lexp_lex: \"lexp order xs ys \\<longleftrightarrow> (xs, ys) \\<in> lex {(x, y). order x y}\"", "lemma lex_list_wfP: \"wfP order \\<Longrightarrow> wfP (lexp order)\"", "lemma lex_list_well_founded:\n  assumes \"well_founded order\"\n  shows \"well_founded (lexp order)\""], "translations": [["", "lemmas induct = wfP_induct_rule[OF wf]"], ["", "end"], ["", "subsection \\<open>Unit\\<close>"], ["", "lemma wfP_unit: \"wfP (\\<lambda>() (). False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>() (). False)", "by (simp add: Nitpick.case_unit_unfold wfP_eq_minimal)"], ["", "interpretation well_founded \"\\<lambda>() (). False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_founded (\\<lambda>() (). False)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>() (). False)", "by (auto intro: wfP_unit)"], ["", "subsection \\<open>Lexicographic product\\<close>"], ["", "context\n  fixes\n    r1 :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and\n    r2 :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\"\nbegin"], ["", "definition lex_prodp :: \"'a \\<times> 'b \\<Rightarrow> 'a \\<times> 'b \\<Rightarrow> bool\" where\n  \"lex_prodp x y \\<equiv> r1 (fst x) (fst y) \\<or> fst x = fst y \\<and> r2 (snd x) (snd y)\""], ["", "lemma lex_prodp_lex_prod:\n  shows \"lex_prodp x y \\<longleftrightarrow> (x, y) \\<in> lex_prod { (x, y). r1 x y } { (x, y). r2 x y }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lex_prodp x y =\n    ((x, y) \\<in> {(x, y). r1 x y} <*lex*> {(x, y). r2 x y})", "by (auto simp: lex_prod_def lex_prodp_def)"], ["", "lemma lex_prodp_wfP:\n  assumes\n    \"wfP r1\" and\n    \"wfP r2\"\n  shows \"wfP lex_prodp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP local.lex_prodp", "proof (rule wfPUNIVI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              local.lex_prodp y x \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P x", "show \"\\<And>P. \\<forall>x. (\\<forall>y. lex_prodp y x \\<longrightarrow> P y) \\<longrightarrow> P x \\<Longrightarrow> (\\<And>x. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<forall>x.\n          (\\<forall>y.\n              local.lex_prodp y x \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       (\\<And>x. P x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<forall>x.\n          (\\<forall>y.\n              local.lex_prodp y x \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       (\\<And>x. P x)", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<forall>x.\n          (\\<forall>y.\n              local.lex_prodp y x \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       (\\<And>x. P x)", "assume \"\\<forall>x. (\\<forall>y. lex_prodp y x \\<longrightarrow> P y) \\<longrightarrow> P x\""], ["proof (state)\nthis:\n  \\<forall>x.\n     (\\<forall>y.\n         local.lex_prodp y x \\<longrightarrow> P y) \\<longrightarrow>\n     P x\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<forall>x.\n          (\\<forall>y.\n              local.lex_prodp y x \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       (\\<And>x. P x)", "hence hyps: \"(\\<And>y1 y2. lex_prodp (y1, y2) (x1, x2) \\<Longrightarrow> P (y1, y2)) \\<Longrightarrow> P (x1, x2)\" for x1 x2"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (\\<forall>y.\n         local.lex_prodp y x \\<longrightarrow> P y) \\<longrightarrow>\n     P x\n\ngoal (1 subgoal):\n 1. (\\<And>y1 y2.\n        local.lex_prodp (y1, y2) (x1, x2) \\<Longrightarrow>\n        P (y1, y2)) \\<Longrightarrow>\n    P (x1, x2)", "by fast"], ["proof (state)\nthis:\n  (\\<And>y1 y2.\n      local.lex_prodp (y1, y2) (?x1.0, ?x2.0) \\<Longrightarrow>\n      P (y1, y2)) \\<Longrightarrow>\n  P (?x1.0, ?x2.0)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<forall>x.\n          (\\<forall>y.\n              local.lex_prodp y x \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       (\\<And>x. P x)", "show \"(\\<And>x. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. P x", "apply (simp only: split_paired_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. P (a, b)", "apply (atomize (full))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. P (a, b)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. \\<forall>b. P (a, b)", "apply (rule wfP_induct_rule[OF assms(1), of \"\\<lambda>y. \\<forall>b. P (y, b)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       (\\<And>y.\n           r1 y x \\<Longrightarrow> \\<forall>b. P (y, b)) \\<Longrightarrow>\n       \\<forall>b. P (x, b)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x b.\n       (\\<And>y.\n           r1 y x \\<Longrightarrow> \\<forall>b. P (y, b)) \\<Longrightarrow>\n       P (x, b)", "apply (rule wfP_induct_rule[OF assms(2), of \"\\<lambda>b. P (x, b)\" for x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x b xa.\n       \\<lbrakk>\\<And>y. r1 y x \\<Longrightarrow> \\<forall>b. P (y, b);\n        \\<And>y. r2 y xa \\<Longrightarrow> P (x, y)\\<rbrakk>\n       \\<Longrightarrow> P (x, xa)", "using hyps[unfolded lex_prodp_def, simplified]"], ["proof (prove)\nusing this:\n  (\\<And>y1 y2.\n      r1 y1 ?x1.0 \\<or> y1 = ?x1.0 \\<and> r2 y2 ?x2.0 \\<Longrightarrow>\n      P (y1, y2)) \\<Longrightarrow>\n  P (?x1.0, ?x2.0)\n\ngoal (1 subgoal):\n 1. \\<And>a x b xa.\n       \\<lbrakk>\\<And>y. r1 y x \\<Longrightarrow> \\<forall>b. P (y, b);\n        \\<And>y. r2 y xa \\<Longrightarrow> P (x, y)\\<rbrakk>\n       \\<Longrightarrow> P (x, xa)", "by blast"], ["proof (state)\nthis:\n  P ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     (\\<forall>y.\n         local.lex_prodp y x \\<longrightarrow> ?P y) \\<longrightarrow>\n     ?P x \\<Longrightarrow>\n  ?P ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma lex_prodp_well_founded:\n  assumes\n    \"well_founded r1\" and\n    \"well_founded r2\"\n  shows \"well_founded (lex_prodp r1 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_founded (lex_prodp r1 r2)", "using well_founded.intro lex_prodp_wfP assms[THEN well_founded.wf]"], ["proof (prove)\nusing this:\n  wfP ?R \\<Longrightarrow> well_founded ?R\n  \\<lbrakk>wfP ?r1.0; wfP ?r2.0\\<rbrakk>\n  \\<Longrightarrow> wfP (lex_prodp ?r1.0 ?r2.0)\n  wfP r1\n  wfP r2\n\ngoal (1 subgoal):\n 1. well_founded (lex_prodp r1 r2)", "by auto"], ["", "subsection \\<open>Lexicographic list\\<close>"], ["", "context\n  fixes order :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\nbegin"], ["", "inductive lexp :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n  lexp_head: \"order x y \\<Longrightarrow> length xs = length ys \\<Longrightarrow> lexp (x # xs) (y # ys)\" |\n  lexp_tail: \"lexp xs ys \\<Longrightarrow> lexp (x # xs) (x # ys)\""], ["", "end"], ["", "lemma lexp_prepend: \"lexp order ys zs \\<Longrightarrow> lexp order (xs @ ys) (xs @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lexp order ys zs \\<Longrightarrow> lexp order (xs @ ys) (xs @ zs)", "by (induction xs) (simp_all add: lexp_tail)"], ["", "lemma lexp_lex: \"lexp order xs ys \\<longleftrightarrow> (xs, ys) \\<in> lex {(x, y). order x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lexp order xs ys = ((xs, ys) \\<in> lex {(x, y). order x y})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lexp order xs ys \\<Longrightarrow>\n    (xs, ys) \\<in> lex {(x, y). order x y}\n 2. (xs, ys) \\<in> lex {(x, y). order x y} \\<Longrightarrow>\n    lexp order xs ys", "assume \"lexp order xs ys\""], ["proof (state)\nthis:\n  lexp order xs ys\n\ngoal (2 subgoals):\n 1. lexp order xs ys \\<Longrightarrow>\n    (xs, ys) \\<in> lex {(x, y). order x y}\n 2. (xs, ys) \\<in> lex {(x, y). order x y} \\<Longrightarrow>\n    lexp order xs ys", "thus \"(xs, ys) \\<in> lex {(x, y). order x y}\""], ["proof (prove)\nusing this:\n  lexp order xs ys\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> lex {(x, y). order x y}", "by (induction xs ys rule: lexp.induct) simp_all"], ["proof (state)\nthis:\n  (xs, ys) \\<in> lex {(x, y). order x y}\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> lex {(x, y). order x y} \\<Longrightarrow>\n    lexp order xs ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> lex {(x, y). order x y} \\<Longrightarrow>\n    lexp order xs ys", "assume \"(xs, ys) \\<in> lex {(x, y). order x y}\""], ["proof (state)\nthis:\n  (xs, ys) \\<in> lex {(x, y). order x y}\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> lex {(x, y). order x y} \\<Longrightarrow>\n    lexp order xs ys", "thus \"lexp order xs ys\""], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> lex {(x, y). order x y}\n\ngoal (1 subgoal):\n 1. lexp order xs ys", "by (auto intro!: lexp_prepend intro: lexp_head simp: lex_conv)"], ["proof (state)\nthis:\n  lexp order xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lex_list_wfP: \"wfP order \\<Longrightarrow> wfP (lexp order)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP order \\<Longrightarrow> wfP (lexp order)", "by (simp add: lexp_lex wf_lex wfP_def)"], ["", "lemma lex_list_well_founded:\n  assumes \"well_founded order\"\n  shows \"well_founded (lexp order)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_founded (lexp order)", "using well_founded.intro assms(1)[THEN well_founded.wf, THEN lex_list_wfP]"], ["proof (prove)\nusing this:\n  wfP ?R \\<Longrightarrow> well_founded ?R\n  wfP (lexp order)\n\ngoal (1 subgoal):\n 1. well_founded (lexp order)", "by auto"], ["", "end"]]}