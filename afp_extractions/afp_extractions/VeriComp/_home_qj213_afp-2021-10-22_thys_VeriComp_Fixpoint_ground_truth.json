{"file_name": "/home/qj213/afp-2021-10-22/thys/VeriComp/Fixpoint.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VeriComp", "problem_names": ["lemma fixpoint_to_comp_pow:\n  \"fixpoint m f x = y \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y\"", "lemma fixpoint_eq_comp_pow:\n  \"\\<exists>n. fixpoint m f x = option_comp_pow f n x\"", "lemma compiler_composition_fixpoint:\n  assumes\n    \"compiler step step final final load load order match compile\"\n  shows \"compiler step step final final load load\n    (lexp order\\<^sup>+\\<^sup>+) (rel_comp_pow match) (fixpoint m compile)\""], "translations": [["", "lemma fixpoint_to_comp_pow:\n  \"fixpoint m f x = y \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixpoint m f x = y \\<Longrightarrow>\n    \\<exists>n. option_comp_pow f n x = y", "proof (induction x arbitrary: y rule: fixpoint.induct[where f = f and m = m])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>x2 y.\n                   \\<lbrakk>f x = Some x2; m x2 < m x;\n                    fixpoint m f x2 = y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>n. option_comp_pow f n x2 = y;\n        fixpoint m f x = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "case (1 x)"], ["proof (state)\nthis:\n  \\<lbrakk>f x = Some ?x2.0; m ?x2.0 < m x; fixpoint m f ?x2.0 = ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. option_comp_pow f n ?x2.0 = ?y\n  fixpoint m f x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>x2 y.\n                   \\<lbrakk>f x = Some x2; m x2 < m x;\n                    fixpoint m f x2 = y\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>n. option_comp_pow f n x2 = y;\n        fixpoint m f x = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. option_comp_pow f n x = y", "proof (cases \"f x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f x = None \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y\n 2. \\<And>a.\n       f x = Some a \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "case None"], ["proof (state)\nthis:\n  f x = None\n\ngoal (2 subgoals):\n 1. f x = None \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y\n 2. \\<And>a.\n       f x = Some a \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "then"], ["proof (chain)\npicking this:\n  f x = None", "show ?thesis"], ["proof (prove)\nusing this:\n  f x = None\n\ngoal (1 subgoal):\n 1. \\<exists>n. option_comp_pow f n x = y", "using \"1.prems\""], ["proof (prove)\nusing this:\n  f x = None\n  fixpoint m f x = y\n\ngoal (1 subgoal):\n 1. \\<exists>n. option_comp_pow f n x = y", "by (metis (no_types, lifting) fixpoint.simps option.case_eq_if option_comp_pow.simps(1))"], ["proof (state)\nthis:\n  \\<exists>n. option_comp_pow f n x = y\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       f x = Some a \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       f x = Some a \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "case (Some a)"], ["proof (state)\nthis:\n  f x = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       f x = Some a \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. option_comp_pow f n x = y", "proof (cases \"m a < m x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m a < m x \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y\n 2. \\<not> m a < m x \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "case True"], ["proof (state)\nthis:\n  m a < m x\n\ngoal (2 subgoals):\n 1. m a < m x \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y\n 2. \\<not> m a < m x \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "hence \"fixpoint m f a = y\""], ["proof (prove)\nusing this:\n  m a < m x\n\ngoal (1 subgoal):\n 1. fixpoint m f a = y", "using \"1.prems\" Some"], ["proof (prove)\nusing this:\n  m a < m x\n  fixpoint m f x = y\n  f x = Some a\n\ngoal (1 subgoal):\n 1. fixpoint m f a = y", "by simp"], ["proof (state)\nthis:\n  fixpoint m f a = y\n\ngoal (2 subgoals):\n 1. m a < m x \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y\n 2. \\<not> m a < m x \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "then"], ["proof (chain)\npicking this:\n  fixpoint m f a = y", "show ?thesis"], ["proof (prove)\nusing this:\n  fixpoint m f a = y\n\ngoal (1 subgoal):\n 1. \\<exists>n. option_comp_pow f n x = y", "using \"1.IH\"[OF Some True]"], ["proof (prove)\nusing this:\n  fixpoint m f a = y\n  fixpoint m f a = ?y \\<Longrightarrow>\n  \\<exists>n. option_comp_pow f n a = ?y\n\ngoal (1 subgoal):\n 1. \\<exists>n. option_comp_pow f n x = y", "by (metis Some bind.simps(2) old.nat.exhaust option_comp_def option_comp_pow.simps(1,3))"], ["proof (state)\nthis:\n  \\<exists>n. option_comp_pow f n x = y\n\ngoal (1 subgoal):\n 1. \\<not> m a < m x \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> m a < m x \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "case False"], ["proof (state)\nthis:\n  \\<not> m a < m x\n\ngoal (1 subgoal):\n 1. \\<not> m a < m x \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "then"], ["proof (chain)\npicking this:\n  \\<not> m a < m x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> m a < m x\n\ngoal (1 subgoal):\n 1. \\<exists>n. option_comp_pow f n x = y", "using \"1.prems\" Some"], ["proof (prove)\nusing this:\n  \\<not> m a < m x\n  fixpoint m f x = y\n  f x = Some a\n\ngoal (1 subgoal):\n 1. \\<exists>n. option_comp_pow f n x = y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> m a < m x; Some a = y; f x = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. option_comp_pow f n x = y", "by (metis option_comp_pow.simps(2))"], ["proof (state)\nthis:\n  \\<exists>n. option_comp_pow f n x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n. option_comp_pow f n x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n. option_comp_pow f n x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fixpoint_eq_comp_pow:\n  \"\\<exists>n. fixpoint m f x = option_comp_pow f n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. fixpoint m f x = option_comp_pow f n x", "by (metis fixpoint_to_comp_pow)"], ["", "lemma compiler_composition_fixpoint:\n  assumes\n    \"compiler step step final final load load order match compile\"\n  shows \"compiler step step final final load load\n    (lexp order\\<^sup>+\\<^sup>+) (rel_comp_pow match) (fixpoint m compile)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (fixpoint m compile)", "proof (rule compiler.intro)"], ["proof (state)\ngoal (4 subgoals):\n 1. language step final\n 2. language step final\n 3. backward_simulation step step final final (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match)\n 4. compiler_axioms load load (rel_comp_pow match) (fixpoint m compile)", "show \"compiler_axioms load load (rel_comp_pow match) (fixpoint m compile)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler_axioms load load (rel_comp_pow match) (fixpoint m compile)", "proof unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>fixpoint m compile p1 = Some p2; load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "fix p1 p2 s2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>fixpoint m compile p1 = Some p2; load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "assume \"fixpoint m compile p1 = Some p2\" and \"load p2 s2\""], ["proof (state)\nthis:\n  fixpoint m compile p1 = Some p2\n  load p2 s2\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>fixpoint m compile p1 = Some p2; load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "obtain n where \"fixpoint m compile p1 = option_comp_pow compile n p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        fixpoint m compile p1 =\n        option_comp_pow compile n p1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using fixpoint_eq_comp_pow"], ["proof (prove)\nusing this:\n  \\<exists>n. fixpoint ?m ?f ?x = option_comp_pow ?f n ?x\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        fixpoint m compile p1 =\n        option_comp_pow compile n p1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  fixpoint m compile p1 = option_comp_pow compile n p1\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>fixpoint m compile p1 = Some p2; load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "thus \"\\<exists>s1 i. load p1 s1 \\<and> rel_comp_pow match i s1 s2\""], ["proof (prove)\nusing this:\n  fixpoint m compile p1 = option_comp_pow compile n p1\n\ngoal (1 subgoal):\n 1. \\<exists>s1 i. load p1 s1 \\<and> rel_comp_pow match i s1 s2", "using \\<open>fixpoint m compile p1 = Some p2\\<close> assms compiler.compile_load compiler_composition_pow"], ["proof (prove)\nusing this:\n  fixpoint m compile p1 = option_comp_pow compile n p1\n  fixpoint m compile p1 = Some p2\n  compiler step step final final load load order match compile\n  \\<lbrakk>compiler ?step1.0 ?step2.0 ?final1.0 ?final2.0 ?load1.0 ?load2.0\n            ?order ?match ?compile;\n   ?compile ?p1.0 = Some ?p2.0; ?load2.0 ?p2.0 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1 i.\n                       ?load1.0 ?p1.0 s1 \\<and> ?match i s1 ?s2.0\n  compiler ?step ?step ?final ?final ?load ?load ?order ?match\n   ?compile \\<Longrightarrow>\n  compiler ?step ?step ?final ?final ?load ?load\n   (lexp ?order\\<^sup>+\\<^sup>+) (rel_comp_pow ?match)\n   (option_comp_pow ?compile ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>s1 i. load p1 s1 \\<and> rel_comp_pow match i s1 s2", "using \\<open>load p2 s2\\<close>"], ["proof (prove)\nusing this:\n  fixpoint m compile p1 = option_comp_pow compile n p1\n  fixpoint m compile p1 = Some p2\n  compiler step step final final load load order match compile\n  \\<lbrakk>compiler ?step1.0 ?step2.0 ?final1.0 ?final2.0 ?load1.0 ?load2.0\n            ?order ?match ?compile;\n   ?compile ?p1.0 = Some ?p2.0; ?load2.0 ?p2.0 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1 i.\n                       ?load1.0 ?p1.0 s1 \\<and> ?match i s1 ?s2.0\n  compiler ?step ?step ?final ?final ?load ?load ?order ?match\n   ?compile \\<Longrightarrow>\n  compiler ?step ?step ?final ?final ?load ?load\n   (lexp ?order\\<^sup>+\\<^sup>+) (rel_comp_pow ?match)\n   (option_comp_pow ?compile ?n)\n  load p2 s2\n\ngoal (1 subgoal):\n 1. \\<exists>s1 i. load p1 s1 \\<and> rel_comp_pow match i s1 s2", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>s1 i. load p1 s1 \\<and> rel_comp_pow match i s1 s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compiler_axioms load load (rel_comp_pow match) (fixpoint m compile)\n\ngoal (3 subgoals):\n 1. language step final\n 2. language step final\n 3. backward_simulation step step final final (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match)", "qed (auto intro: assms compiler.axioms backward_simulation_pow)"], ["", "end"]]}