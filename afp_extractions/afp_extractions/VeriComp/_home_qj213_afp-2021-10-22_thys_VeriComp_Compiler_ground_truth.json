{"file_name": "/home/qj213/afp-2021-10-22/thys/VeriComp/Compiler.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VeriComp", "problem_names": ["lemma compiler_composition:\n  assumes\n    \"compiler step1 step2 final1 final2 load1 load2 order1 match1 compile1\" and\n    \"compiler step2 step3 final2 final3 load2 load3 order2 match2 compile2\"\n  shows \"compiler step1 step3 final1 final3 load1 load3\n    (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2) (compile2 \\<Lleftarrow> compile1)\"", "lemma compiler_composition_pow:\n  assumes\n    \"compiler step step final final load load order match compile\"\n  shows \"compiler step step final final load load\n    (lexp order\\<^sup>+\\<^sup>+) (rel_comp_pow match) (option_comp_pow compile n)\""], "translations": [["", "lemma compiler_composition:\n  assumes\n    \"compiler step1 step2 final1 final2 load1 load2 order1 match1 compile1\" and\n    \"compiler step2 step3 final2 final3 load2 load3 order2 match2 compile2\"\n  shows \"compiler step1 step3 final1 final3 load1 load3\n    (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2) (compile2 \\<Lleftarrow> compile1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler step1 step3 final1 final3 load1 load3\n     (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2)\n     (compile2 \\<Lleftarrow> compile1)", "proof (rule compiler.intro)"], ["proof (state)\ngoal (4 subgoals):\n 1. language step1 final1\n 2. language step3 final3\n 3. backward_simulation step1 step3 final1 final3\n     (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2)\n 4. compiler_axioms load1 load3 (rel_comp match1 match2)\n     (compile2 \\<Lleftarrow> compile1)", "show \"language step1 final1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language step1 final1", "using assms(1)[THEN compiler.axioms(1)]"], ["proof (prove)\nusing this:\n  language step1 final1\n\ngoal (1 subgoal):\n 1. language step1 final1", "."], ["proof (state)\nthis:\n  language step1 final1\n\ngoal (3 subgoals):\n 1. language step3 final3\n 2. backward_simulation step1 step3 final1 final3\n     (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2)\n 3. compiler_axioms load1 load3 (rel_comp match1 match2)\n     (compile2 \\<Lleftarrow> compile1)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. language step3 final3\n 2. backward_simulation step1 step3 final1 final3\n     (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2)\n 3. compiler_axioms load1 load3 (rel_comp match1 match2)\n     (compile2 \\<Lleftarrow> compile1)", "show \"language step3 final3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language step3 final3", "using assms(2)[THEN compiler.axioms(2)]"], ["proof (prove)\nusing this:\n  language step3 final3\n\ngoal (1 subgoal):\n 1. language step3 final3", "."], ["proof (state)\nthis:\n  language step3 final3\n\ngoal (2 subgoals):\n 1. backward_simulation step1 step3 final1 final3\n     (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2)\n 2. compiler_axioms load1 load3 (rel_comp match1 match2)\n     (compile2 \\<Lleftarrow> compile1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. backward_simulation step1 step3 final1 final3\n     (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2)\n 2. compiler_axioms load1 load3 (rel_comp match1 match2)\n     (compile2 \\<Lleftarrow> compile1)", "show \"backward_simulation step1 step3 final1 final3\n     (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_simulation step1 step3 final1 final3\n     (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2)", "using backward_simulation_composition[OF assms[THEN compiler.axioms(3)]]"], ["proof (prove)\nusing this:\n  backward_simulation step1 step3 final1 final3\n   (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2)\n\ngoal (1 subgoal):\n 1. backward_simulation step1 step3 final1 final3\n     (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2)", "."], ["proof (state)\nthis:\n  backward_simulation step1 step3 final1 final3\n   (lex_prodp order1\\<^sup>+\\<^sup>+ order2) (rel_comp match1 match2)\n\ngoal (1 subgoal):\n 1. compiler_axioms load1 load3 (rel_comp match1 match2)\n     (compile2 \\<Lleftarrow> compile1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. compiler_axioms load1 load3 (rel_comp match1 match2)\n     (compile2 \\<Lleftarrow> compile1)", "show \"compiler_axioms load1 load3 (rel_comp match1 match2) (compile2 \\<Lleftarrow> compile1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler_axioms load1 load3 (rel_comp match1 match2)\n     (compile2 \\<Lleftarrow> compile1)", "proof unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>(compile2 \\<Lleftarrow> compile1) p1 = Some p2;\n        load3 p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load1 p1 s1 \\<and>\n                            rel_comp match1 match2 i s1 s2", "fix p1 p3 s3"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>(compile2 \\<Lleftarrow> compile1) p1 = Some p2;\n        load3 p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load1 p1 s1 \\<and>\n                            rel_comp match1 match2 i s1 s2", "assume\n      compile: \"(compile2 \\<Lleftarrow> compile1) p1 = Some p3\" and\n      load: \"load3 p3 s3\""], ["proof (state)\nthis:\n  (compile2 \\<Lleftarrow> compile1) p1 = Some p3\n  load3 p3 s3\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>(compile2 \\<Lleftarrow> compile1) p1 = Some p2;\n        load3 p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load1 p1 s1 \\<and>\n                            rel_comp match1 match2 i s1 s2", "obtain p2 where c1: \"compile1 p1 = Some p2\" and c2: \"compile2 p2 = Some p3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2.\n        \\<lbrakk>compile1 p1 = Some p2; compile2 p2 = Some p3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using compile"], ["proof (prove)\nusing this:\n  (compile2 \\<Lleftarrow> compile1) p1 = Some p3\n\ngoal (1 subgoal):\n 1. (\\<And>p2.\n        \\<lbrakk>compile1 p1 = Some p2; compile2 p2 = Some p3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: bind_eq_Some_conv option_comp_def)"], ["proof (state)\nthis:\n  compile1 p1 = Some p2\n  compile2 p2 = Some p3\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>(compile2 \\<Lleftarrow> compile1) p1 = Some p2;\n        load3 p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load1 p1 s1 \\<and>\n                            rel_comp match1 match2 i s1 s2", "obtain s2 i' where l2: \"load2 p2 s2\" and \"match2 i' s2 s3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s2 i'.\n        \\<lbrakk>load2 p2 s2; match2 i' s2 s3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)[THEN compiler.compile_load, OF c2 load]"], ["proof (prove)\nusing this:\n  \\<exists>s1 i. load2 p2 s1 \\<and> match2 i s1 s3\n\ngoal (1 subgoal):\n 1. (\\<And>s2 i'.\n        \\<lbrakk>load2 p2 s2; match2 i' s2 s3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  load2 p2 s2\n  match2 i' s2 s3\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>(compile2 \\<Lleftarrow> compile1) p1 = Some p2;\n        load3 p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load1 p1 s1 \\<and>\n                            rel_comp match1 match2 i s1 s2", "moreover"], ["proof (state)\nthis:\n  load2 p2 s2\n  match2 i' s2 s3\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>(compile2 \\<Lleftarrow> compile1) p1 = Some p2;\n        load3 p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load1 p1 s1 \\<and>\n                            rel_comp match1 match2 i s1 s2", "obtain s1 i where \"load1 p1 s1\" and \"match1 i s1 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s1 i.\n        \\<lbrakk>load1 p1 s1; match1 i s1 s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)[THEN compiler.compile_load, OF c1 l2]"], ["proof (prove)\nusing this:\n  \\<exists>s1 i. load1 p1 s1 \\<and> match1 i s1 s2\n\ngoal (1 subgoal):\n 1. (\\<And>s1 i.\n        \\<lbrakk>load1 p1 s1; match1 i s1 s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  load1 p1 s1\n  match1 i s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>(compile2 \\<Lleftarrow> compile1) p1 = Some p2;\n        load3 p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load1 p1 s1 \\<and>\n                            rel_comp match1 match2 i s1 s2", "ultimately"], ["proof (chain)\npicking this:\n  load2 p2 s2\n  match2 i' s2 s3\n  load1 p1 s1\n  match1 i s1 s2", "show \"\\<exists>s1 i. load1 p1 s1 \\<and> rel_comp match1 match2 i s1 s3\""], ["proof (prove)\nusing this:\n  load2 p2 s2\n  match2 i' s2 s3\n  load1 p1 s1\n  match1 i s1 s2\n\ngoal (1 subgoal):\n 1. \\<exists>s1 i. load1 p1 s1 \\<and> rel_comp match1 match2 i s1 s3", "unfolding rel_comp_def"], ["proof (prove)\nusing this:\n  load2 p2 s2\n  match2 i' s2 s3\n  load1 p1 s1\n  match1 i s1 s2\n\ngoal (1 subgoal):\n 1. \\<exists>s1 i.\n       load1 p1 s1 \\<and> (match1 (fst i) OO match2 (snd i)) s1 s3", "by auto"], ["proof (state)\nthis:\n  \\<exists>s1 i. load1 p1 s1 \\<and> rel_comp match1 match2 i s1 s3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compiler_axioms load1 load3 (rel_comp match1 match2)\n   (compile2 \\<Lleftarrow> compile1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compiler_composition_pow:\n  assumes\n    \"compiler step step final final load load order match compile\"\n  shows \"compiler step step final final load load\n    (lexp order\\<^sup>+\\<^sup>+) (rel_comp_pow match) (option_comp_pow compile n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (option_comp_pow compile n)", "proof (induction n rule: option_comp_pow.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (option_comp_pow compile 0)\n 2. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (option_comp_pow compile (Suc 0))\n 3. \\<And>v.\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match)\n        (option_comp_pow compile (Suc v)) \\<Longrightarrow>\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match) (option_comp_pow compile (Suc (Suc v)))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (option_comp_pow compile 0)\n 2. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (option_comp_pow compile (Suc 0))\n 3. \\<And>v.\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match)\n        (option_comp_pow compile (Suc v)) \\<Longrightarrow>\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match) (option_comp_pow compile (Suc (Suc v)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (option_comp_pow compile 0)", "using assms"], ["proof (prove)\nusing this:\n  compiler step step final final load load order match compile\n\ngoal (1 subgoal):\n 1. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (option_comp_pow compile 0)", "by (auto intro: compiler.axioms compiler.intro compiler_axioms.intro backward_simulation_pow)"], ["proof (state)\nthis:\n  compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n   (rel_comp_pow match) (option_comp_pow compile 0)\n\ngoal (2 subgoals):\n 1. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (option_comp_pow compile (Suc 0))\n 2. \\<And>v.\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match)\n        (option_comp_pow compile (Suc v)) \\<Longrightarrow>\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match) (option_comp_pow compile (Suc (Suc v)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (option_comp_pow compile (Suc 0))\n 2. \\<And>v.\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match)\n        (option_comp_pow compile (Suc v)) \\<Longrightarrow>\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match) (option_comp_pow compile (Suc (Suc v)))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (option_comp_pow compile (Suc 0))\n 2. \\<And>v.\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match)\n        (option_comp_pow compile (Suc v)) \\<Longrightarrow>\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match) (option_comp_pow compile (Suc (Suc v)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (option_comp_pow compile (Suc 0))", "proof (rule compiler.intro)"], ["proof (state)\ngoal (4 subgoals):\n 1. language step final\n 2. language step final\n 3. backward_simulation step step final final (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match)\n 4. compiler_axioms load load (rel_comp_pow match)\n     (option_comp_pow compile (Suc 0))", "show \"compiler_axioms load load (rel_comp_pow match) (option_comp_pow compile (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler_axioms load load (rel_comp_pow match)\n     (option_comp_pow compile (Suc 0))", "proof unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>option_comp_pow compile (Suc 0) p1 = Some p2;\n        load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "fix p1 p2 s2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>option_comp_pow compile (Suc 0) p1 = Some p2;\n        load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "assume\n        \"option_comp_pow compile (Suc 0) p1 = Some p2\" and\n        \"load p2 s2\""], ["proof (state)\nthis:\n  option_comp_pow compile (Suc 0) p1 = Some p2\n  load p2 s2\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>option_comp_pow compile (Suc 0) p1 = Some p2;\n        load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "thus \"\\<exists>s1 i. load p1 s1 \\<and> rel_comp_pow match i s1 s2\""], ["proof (prove)\nusing this:\n  option_comp_pow compile (Suc 0) p1 = Some p2\n  load p2 s2\n\ngoal (1 subgoal):\n 1. \\<exists>s1 i. load p1 s1 \\<and> rel_comp_pow match i s1 s2", "using compiler.compile_load[OF assms(1)]"], ["proof (prove)\nusing this:\n  option_comp_pow compile (Suc 0) p1 = Some p2\n  load p2 s2\n  \\<lbrakk>compile ?p1.0 = Some ?p2.0; load ?p2.0 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1 i. load ?p1.0 s1 \\<and> match i s1 ?s2.0\n\ngoal (1 subgoal):\n 1. \\<exists>s1 i. load p1 s1 \\<and> rel_comp_pow match i s1 s2", "by (metis option_comp_pow.simps(2) rel_comp_pow.simps(2))"], ["proof (state)\nthis:\n  \\<exists>s1 i. load p1 s1 \\<and> rel_comp_pow match i s1 s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compiler_axioms load load (rel_comp_pow match)\n   (option_comp_pow compile (Suc 0))\n\ngoal (3 subgoals):\n 1. language step final\n 2. language step final\n 3. backward_simulation step step final final (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match)", "qed (auto intro: assms compiler.axioms backward_simulation_pow)"], ["proof (state)\nthis:\n  compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n   (rel_comp_pow match) (option_comp_pow compile (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match)\n        (option_comp_pow compile (Suc v)) \\<Longrightarrow>\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match) (option_comp_pow compile (Suc (Suc v)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match)\n        (option_comp_pow compile (Suc v)) \\<Longrightarrow>\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match) (option_comp_pow compile (Suc (Suc v)))", "case (3 n')"], ["proof (state)\nthis:\n  compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n   (rel_comp_pow match) (option_comp_pow compile (Suc n'))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match)\n        (option_comp_pow compile (Suc v)) \\<Longrightarrow>\n       compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n        (rel_comp_pow match) (option_comp_pow compile (Suc (Suc v)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match) (option_comp_pow compile (Suc (Suc n')))", "proof (rule compiler.intro)"], ["proof (state)\ngoal (4 subgoals):\n 1. language step final\n 2. language step final\n 3. backward_simulation step step final final (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match)\n 4. compiler_axioms load load (rel_comp_pow match)\n     (option_comp_pow compile (Suc (Suc n')))", "show \"compiler_axioms load load (rel_comp_pow match) (option_comp_pow compile (Suc (Suc n')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler_axioms load load (rel_comp_pow match)\n     (option_comp_pow compile (Suc (Suc n')))", "proof unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>option_comp_pow compile (Suc (Suc n')) p1 = Some p2;\n        load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "fix p1 p3 s3"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>option_comp_pow compile (Suc (Suc n')) p1 = Some p2;\n        load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "assume\n        \"option_comp_pow compile  (Suc (Suc n')) p1 = Some p3\" and\n        \"load p3 s3\""], ["proof (state)\nthis:\n  option_comp_pow compile (Suc (Suc n')) p1 = Some p3\n  load p3 s3\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>option_comp_pow compile (Suc (Suc n')) p1 = Some p2;\n        load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "then"], ["proof (chain)\npicking this:\n  option_comp_pow compile (Suc (Suc n')) p1 = Some p3\n  load p3 s3", "obtain p2 where\n        comp: \"compile p1 = Some p2\" and\n        comp_IH: \"option_comp_pow compile (Suc n') p2 = Some p3\""], ["proof (prove)\nusing this:\n  option_comp_pow compile (Suc (Suc n')) p1 = Some p3\n  load p3 s3\n\ngoal (1 subgoal):\n 1. (\\<And>p2.\n        \\<lbrakk>compile p1 = Some p2;\n         option_comp_pow compile (Suc n') p2 = Some p3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: option_comp_def bind_eq_Some_conv)"], ["proof (state)\nthis:\n  compile p1 = Some p2\n  option_comp_pow compile (Suc n') p2 = Some p3\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>option_comp_pow compile (Suc (Suc n')) p1 = Some p2;\n        load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "obtain s2 i' where \"load p2 s2\" and \"rel_comp_pow match i' s2 s3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s2 i'.\n        \\<lbrakk>load p2 s2; rel_comp_pow match i' s2 s3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using compiler.compile_load[OF \"3.IH\" comp_IH \\<open>load p3 s3\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>s1 i. load p2 s1 \\<and> rel_comp_pow match i s1 s3\n\ngoal (1 subgoal):\n 1. (\\<And>s2 i'.\n        \\<lbrakk>load p2 s2; rel_comp_pow match i' s2 s3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  load p2 s2\n  rel_comp_pow match i' s2 s3\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>option_comp_pow compile (Suc (Suc n')) p1 = Some p2;\n        load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "moreover"], ["proof (state)\nthis:\n  load p2 s2\n  rel_comp_pow match i' s2 s3\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>option_comp_pow compile (Suc (Suc n')) p1 = Some p2;\n        load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "obtain s1 i where \"load p1 s1\" and \"match i s1 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s1 i.\n        \\<lbrakk>load p1 s1; match i s1 s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using compiler.compile_load[OF assms comp \\<open>load p2 s2\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>s1 i. load p1 s1 \\<and> match i s1 s2\n\ngoal (1 subgoal):\n 1. (\\<And>s1 i.\n        \\<lbrakk>load p1 s1; match i s1 s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  load p1 s1\n  match i s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>option_comp_pow compile (Suc (Suc n')) p1 = Some p2;\n        load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "moreover"], ["proof (state)\nthis:\n  load p1 s1\n  match i s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>option_comp_pow compile (Suc (Suc n')) p1 = Some p2;\n        load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "have \"rel_comp_pow match (i # i') s1 s3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_comp_pow match (i # i') s1 s3", "using \\<open>rel_comp_pow match i' s2 s3\\<close> \\<open>match i s1 s2\\<close> rel_comp_pow.elims(2)"], ["proof (prove)\nusing this:\n  rel_comp_pow match i' s2 s3\n  match i s1 s2\n  \\<lbrakk>rel_comp_pow ?r ?x ?xa ?xb;\n   \\<And>i x y.\n      \\<lbrakk>?x = [i]; ?xa = x; ?xb = y; ?r i x y\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>i v va x z.\n      \\<lbrakk>?x = i # v # va; ?xa = x; ?xb = z;\n       \\<exists>y. ?r i x y \\<and> rel_comp_pow ?r (v # va) y z\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. rel_comp_pow match (i # i') s1 s3", "by fastforce"], ["proof (state)\nthis:\n  rel_comp_pow match (i # i') s1 s3\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 s2.\n       \\<lbrakk>option_comp_pow compile (Suc (Suc n')) p1 = Some p2;\n        load p2 s2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1 i.\n                            load p1 s1 \\<and> rel_comp_pow match i s1 s2", "ultimately"], ["proof (chain)\npicking this:\n  load p2 s2\n  rel_comp_pow match i' s2 s3\n  load p1 s1\n  match i s1 s2\n  rel_comp_pow match (i # i') s1 s3", "show \"\\<exists>s1 i. load p1 s1 \\<and> rel_comp_pow match i s1 s3\""], ["proof (prove)\nusing this:\n  load p2 s2\n  rel_comp_pow match i' s2 s3\n  load p1 s1\n  match i s1 s2\n  rel_comp_pow match (i # i') s1 s3\n\ngoal (1 subgoal):\n 1. \\<exists>s1 i. load p1 s1 \\<and> rel_comp_pow match i s1 s3", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1 i. load p1 s1 \\<and> rel_comp_pow match i s1 s3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compiler_axioms load load (rel_comp_pow match)\n   (option_comp_pow compile (Suc (Suc n')))\n\ngoal (3 subgoals):\n 1. language step final\n 2. language step final\n 3. backward_simulation step step final final (lexp order\\<^sup>+\\<^sup>+)\n     (rel_comp_pow match)", "qed (auto intro: assms compiler.axioms backward_simulation_pow)"], ["proof (state)\nthis:\n  compiler step step final final load load (lexp order\\<^sup>+\\<^sup>+)\n   (rel_comp_pow match) (option_comp_pow compile (Suc (Suc n')))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}