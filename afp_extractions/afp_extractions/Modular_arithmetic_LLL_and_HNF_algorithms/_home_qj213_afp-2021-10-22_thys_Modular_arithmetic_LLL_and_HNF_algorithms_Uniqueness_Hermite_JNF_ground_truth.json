{"file_name": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms/Uniqueness_Hermite_JNF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms", "problem_names": ["lemma echelon_form_def': \n\"echelon_form A = (\n    (\\<forall>i. is_zero_row i A \\<longrightarrow> \\<not> (\\<exists>j. j>i \\<and> \\<not> is_zero_row j A)) \n    \\<and>  \n    (\\<forall>i j. i<j \\<and> \\<not> (is_zero_row i A) \\<and> \\<not> (is_zero_row j A) \n          \\<longrightarrow> ((LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0))))\"", "lemma HMA_is_zero_row_mod_type[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_I) ===> (Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'n :: mod_type ^ 'm :: mod_type \\<Rightarrow> _) \n    ===> (=)) is_zero_row_JNF is_zero_row\"", "lemma HMA_echelon_form_mod_type[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a ::bezout_ring ^ 'n :: mod_type ^ 'm :: mod_type \\<Rightarrow> _) ===> (=))\n  echelon_form_JNF echelon_form\"", "lemma HMA_LEAST[transfer_rule]:\n  assumes AA': \"(Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'n :: mod_type ^ 'm :: mod_type \\<Rightarrow> _) A A'\"\n  and ii': \"Mod_Type_Connect.HMA_I i i'\" and zero_i: \"\\<not> is_zero_row_JNF i A\"\nshows \"Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> 0) (LEAST n. index_hma A' i' n \\<noteq> 0)\"", "lemma element_least_not_zero_eq_HMA_JNF:\n  fixes A':: \"'a :: comm_ring_1 ^ 'n :: mod_type ^ 'm :: mod_type\"\n  assumes AA': \"Mod_Type_Connect.HMA_M A A'\" and jj': \"Mod_Type_Connect.HMA_I j j'\"\n    and ii': \"Mod_Type_Connect.HMA_I i i'\" and zero_i': \"\\<not> is_zero_row i' A'\"\n  shows \"A $$ (j, LEAST n. A $$ (i, n) \\<noteq> 0) = A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> 0)\"", "lemma HMA_Hermite[transfer_rule]:\n  shows \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: {bezout_ring_div,normalization_semidom} ^ 'n :: mod_type ^ 'm :: mod_type \\<Rightarrow> _) ===> (=)) \n  (Hermite_JNF associates residues) (Hermite associates residues)\"", "lemma Hermite_unique_JNF':\n  fixes A::\"'a::{bezout_ring_div,normalization_euclidean_semiring,unique_euclidean_ring} mat\"\n  assumes \"A \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"P \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"H \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"Q \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"K \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n  assumes \"A = P * H\"\n    and \"A = Q * K\" and \"invertible_mat A\" and \"invertible_mat P\" \n    and \"invertible_mat Q\" and \"Hermite_JNF associates res H\" and \"Hermite_JNF associates res K\"\nshows \"H = K\"", "lemma type_to_set:\n  shows \"class.nontriv TYPE('b)\" (is ?a) and \"n=CARD('b)\" (is ?b)", "lemma Hermite_unique_JNF_aux:\n  fixes A::\"'a::{bezout_ring_div,normalization_euclidean_semiring,unique_euclidean_ring} mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n    \"P \\<in> carrier_mat n n\"\n    \"H \\<in> carrier_mat n n\"\n    \"Q \\<in> carrier_mat n n \"\n    \"K \\<in> carrier_mat n n\"\n  assumes \"A = P * H\"\n    and \"A = Q * K\" and \"invertible_mat A\" and \"invertible_mat P\" \n    and \"invertible_mat Q\" and \"Hermite_JNF associates res H\" and \"Hermite_JNF associates res K\"\nshows \"H = K\"", "lemma Hermite_unique_JNF:\n  fixes A::\"'a::{bezout_ring_div,normalization_euclidean_semiring,unique_euclidean_ring} mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and P: \"P \\<in> carrier_mat n n\" and H: \"H \\<in> carrier_mat n n\"\n   and Q: \"Q \\<in> carrier_mat n n\" and K: \"K \\<in> carrier_mat n n\"\n assumes A_PH: \"A = P * H\" and A_QK: \"A = Q * K\"\n   and inv_A: \"invertible_mat A\" and inv_P: \"invertible_mat P\" and inv_Q: \"invertible_mat Q\"\n   and HNF_H: \"Hermite_JNF associates res H\" and HNF_K: \"Hermite_JNF associates res K\"\n  shows \"H = K\"", "lemma HMA_map_matrix [transfer_rule]: \n  \"((=) ===> Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M) map_mat map_matrix\"", "lemma Hermite_unique_generalized_JNF':\n  fixes A::\"int mat\"\n  assumes \"A \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"P \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"H \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"Q \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"K \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n  assumes \"A = P * H\"\n    and \"A = Q * K\" and \"invertible_mat (map_mat rat_of_int A)\" and \"invertible_mat P\" \n    and \"invertible_mat Q\" and \"Hermite_JNF associates res H\" and \"Hermite_JNF associates res K\"\nshows \"H = K\"", "lemma type_to_set2:\n  shows \"class.nontriv TYPE('b)\" (is ?a) and \"p=CARD('b)\" (is ?b)", "lemma Hermite_unique_generalized_JNF_aux:\n  fixes A::\"int mat\"\n  assumes \"A \\<in> carrier_mat p p\"\n    \"P \\<in> carrier_mat p p\"\n    \"H \\<in> carrier_mat p p\"\n    \"Q \\<in> carrier_mat p p\"\n    \"K \\<in> carrier_mat p p\"\n  assumes \"A = P * H\"\n    and \"A = Q * K\" and \"invertible_mat (map_mat rat_of_int A)\" and \"invertible_mat P\" \n    and \"invertible_mat Q\" and \"Hermite_JNF associates res H\" and \"Hermite_JNF associates res K\"\nshows \"H = K\"", "lemma HNF_unique_generalized_JNF:\n  fixes A::\"int mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and P: \"P \\<in> carrier_mat n n\" and H: \"H \\<in> carrier_mat n n\"\n   and Q: \"Q \\<in> carrier_mat n n\" and K: \"K \\<in> carrier_mat n n\"\n assumes A_PH: \"A = P * H\" and A_QK: \"A = Q * K\"\n   and inv_A: \"invertible_mat (map_mat rat_of_int A)\" and inv_P: \"invertible_mat P\" and inv_Q: \"invertible_mat Q\"\n   and HNF_H: \"Hermite_JNF associates res H\" and HNF_K: \"Hermite_JNF associates res K\"\n  shows \"H = K\""], "translations": [["", "lemma echelon_form_def': \n\"echelon_form A = (\n    (\\<forall>i. is_zero_row i A \\<longrightarrow> \\<not> (\\<exists>j. j>i \\<and> \\<not> is_zero_row j A)) \n    \\<and>  \n    (\\<forall>i j. i<j \\<and> \\<not> (is_zero_row i A) \\<and> \\<not> (is_zero_row j A) \n          \\<longrightarrow> ((LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form A =\n    ((\\<forall>i.\n         is_zero_row i A \\<longrightarrow>\n         \\<not> (\\<exists>j>i. \\<not> is_zero_row j A)) \\<and>\n     (\\<forall>i j.\n         i < j \\<and>\n         \\<not> is_zero_row i A \\<and>\n         \\<not> is_zero_row j A \\<longrightarrow>\n         (LEAST n. A $h i $h n \\<noteq> (0::'a))\n         < (LEAST n. A $h j $h n \\<noteq> (0::'a))))", "unfolding echelon_form_def echelon_form_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>i.\n         is_zero_row_upt_k i (ncols A) A \\<longrightarrow>\n         \\<not> (\\<exists>j>i.\n                    \\<not> is_zero_row_upt_k j (ncols A) A)) \\<and>\n     (\\<forall>i j.\n         i < j \\<and>\n         \\<not> is_zero_row_upt_k i (ncols A) A \\<and>\n         \\<not> is_zero_row_upt_k j (ncols A) A \\<longrightarrow>\n         (LEAST n. A $h i $h n \\<noteq> (0::'a))\n         < (LEAST n. A $h j $h n \\<noteq> (0::'a)))) =\n    ((\\<forall>i.\n         is_zero_row i A \\<longrightarrow>\n         \\<not> (\\<exists>j>i. \\<not> is_zero_row j A)) \\<and>\n     (\\<forall>i j.\n         i < j \\<and>\n         \\<not> is_zero_row i A \\<and>\n         \\<not> is_zero_row j A \\<longrightarrow>\n         (LEAST n. A $h i $h n \\<noteq> (0::'a))\n         < (LEAST n. A $h j $h n \\<noteq> (0::'a))))", "unfolding is_zero_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>i.\n         is_zero_row_upt_k i (ncols A) A \\<longrightarrow>\n         \\<not> (\\<exists>j>i.\n                    \\<not> is_zero_row_upt_k j (ncols A) A)) \\<and>\n     (\\<forall>i j.\n         i < j \\<and>\n         \\<not> is_zero_row_upt_k i (ncols A) A \\<and>\n         \\<not> is_zero_row_upt_k j (ncols A) A \\<longrightarrow>\n         (LEAST n. A $h i $h n \\<noteq> (0::'a))\n         < (LEAST n. A $h j $h n \\<noteq> (0::'a)))) =\n    ((\\<forall>i.\n         is_zero_row_upt_k i (ncols A) A \\<longrightarrow>\n         \\<not> (\\<exists>j>i.\n                    \\<not> is_zero_row_upt_k j (ncols A) A)) \\<and>\n     (\\<forall>i j.\n         i < j \\<and>\n         \\<not> is_zero_row_upt_k i (ncols A) A \\<and>\n         \\<not> is_zero_row_upt_k j (ncols A) A \\<longrightarrow>\n         (LEAST n. A $h i $h n \\<noteq> (0::'a))\n         < (LEAST n. A $h j $h n \\<noteq> (0::'a))))", "by auto"], ["", "definition \n  echelon_form_JNF :: \"'a::{bezout_ring} mat \\<Rightarrow> bool\" \n  where \n  \"echelon_form_JNF A = (\n    (\\<forall>i<dim_row A. is_zero_row_JNF i A \\<longrightarrow> \\<not> (\\<exists>j. j < dim_row A \\<and> j>i \\<and> \\<not> is_zero_row_JNF j A)) \n    \\<and>  \n    (\\<forall>i j. i<j \\<and> j<dim_row A \\<and> \\<not> (is_zero_row_JNF i A) \\<and> \\<not> (is_zero_row_JNF j A) \n          \\<longrightarrow> ((LEAST n. A $$ (i, n) \\<noteq> 0) < (LEAST n. A $$ (j, n) \\<noteq> 0))))\""], ["", "text \\<open>Now, we connect the existing definitions in HOL Analysis to the ones just defined in JNF by\nmeans of transfer rules.\\<close>"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma HMA_is_zero_row_mod_type[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_I) ===> (Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'n :: mod_type ^ 'm :: mod_type \\<Rightarrow> _) \n    ===> (=)) is_zero_row_JNF is_zero_row\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_I ===> Mod_Type_Connect.HMA_M ===> (=))\n     is_zero_row_JNF is_zero_row", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_I x y;\n        Mod_Type_Connect.HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF x xa = is_zero_row y ya", "case (1 i i' A A')"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I i i'\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_I x y;\n        Mod_Type_Connect.HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF x xa = is_zero_row y ya", "note ii' = \"1\"(1)[transfer_rule]"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I i i'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_I x y;\n        Mod_Type_Connect.HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF x xa = is_zero_row y ya", "note AA' = \"1\"(2)[transfer_rule]"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_I x y;\n        Mod_Type_Connect.HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF x xa = is_zero_row y ya", "have \"(\\<forall>j<dim_col A. A $$ (i, j) = 0) = (\\<forall>j. A' $h i' $h j = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>j<dim_col A. A $$ (i, j) = (0::'a)) =\n    (\\<forall>j. A' $h i' $h j = (0::'a))", "proof (rule;rule+)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<forall>j<dim_col A. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n       A' $h i' $h j = (0::'a)\n 2. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "fix j'::'n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<forall>j<dim_col A. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n       A' $h i' $h j = (0::'a)\n 2. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "assume Aij_0: \"\\<forall>j<dim_col A. A $$ (i, j) = 0\""], ["proof (state)\nthis:\n  \\<forall>j<dim_col A. A $$ (i, j) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<forall>j<dim_col A. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n       A' $h i' $h j = (0::'a)\n 2. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "define j where \"j = mod_type_class.to_nat j'\""], ["proof (state)\nthis:\n  j = mod_type_class.to_nat j'\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<forall>j<dim_col A. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n       A' $h i' $h j = (0::'a)\n 2. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I j j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I j j'", "unfolding Mod_Type_Connect.HMA_I_def j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j' = mod_type_class.to_nat j'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I j j'\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<forall>j<dim_col A. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n       A' $h i' $h j = (0::'a)\n 2. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have A_ij0': \"A $$ (i,j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a)", "using Aij_0"], ["proof (prove)\nusing this:\n  \\<forall>j<dim_col A. A $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a)", "unfolding j_def"], ["proof (prove)\nusing this:\n  \\<forall>j<dim_col A. A $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, mod_type_class.to_nat j') = (0::'a)", "by (metis AA' Mod_Type_Connect.HMA_M_def Mod_Type_Connect.from_hma\\<^sub>m_def \n          dim_col_mat(1) mod_type_class.to_nat_less_card)"], ["proof (state)\nthis:\n  A $$ (i, j) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<forall>j<dim_col A. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n       A' $h i' $h j = (0::'a)\n 2. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "hence \"index_hma A' i' j' = 0\""], ["proof (prove)\nusing this:\n  A $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. index_hma A' i' j' = (0::'a)", "by transfer"], ["proof (state)\nthis:\n  index_hma A' i' j' = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<forall>j<dim_col A. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n       A' $h i' $h j = (0::'a)\n 2. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "thus \"A' $h i' $h j' = 0\""], ["proof (prove)\nusing this:\n  index_hma A' i' j' = (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h i' $h j' = (0::'a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  A' $h i' $h j' = (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h i' $h j' = (0::'a)", "by simp"], ["proof (state)\nthis:\n  A' $h i' $h j' = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "assume 1: \"\\<forall>j'. A' $h i' $h j' = 0\" and 2: \"j < dim_col A\""], ["proof (state)\nthis:\n  \\<forall>j'. A' $h i' $h j' = (0::'a)\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "define j'::'n where \"j' = mod_type_class.from_nat j\""], ["proof (state)\nthis:\n  j' = mod_type_class.from_nat j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I j j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I j j'", "unfolding Mod_Type_Connect.HMA_I_def j'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j = mod_type_class.to_nat (mod_type_class.from_nat j)", "using Mod_Type.to_nat_from_nat_id[of j, where ?'a = 'n] 2"], ["proof (prove)\nusing this:\n  j < CARD('n) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat j) = j\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. j = mod_type_class.to_nat (mod_type_class.from_nat j)", "using AA' Mod_Type_Connect.dim_col_transfer_rule"], ["proof (prove)\nusing this:\n  j < CARD('n) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat j) = j\n  j < dim_col A\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n\ngoal (1 subgoal):\n 1. j = mod_type_class.to_nat (mod_type_class.from_nat j)", "by force"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I j j'\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have \"A' $h i' $h j' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h i' $h j' = (0::'a)", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>j'. A' $h i' $h j' = (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h i' $h j' = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A' $h i' $h j' = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "hence \"index_hma A' i' j' = 0\""], ["proof (prove)\nusing this:\n  A' $h i' $h j' = (0::'a)\n\ngoal (1 subgoal):\n 1. index_hma A' i' j' = (0::'a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  A' $h i' $h j' = (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h i' $h j' = (0::'a)", "by simp"], ["proof (state)\nthis:\n  index_hma A' i' j' = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>j. A' $h i' $h j = (0::'a); j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "thus \"A $$ (i, j) = 0\""], ["proof (prove)\nusing this:\n  index_hma A' i' j' = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a)", "by transfer"], ["proof (state)\nthis:\n  A $$ (i, j) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>j<dim_col A. A $$ (i, j) = (0::'a)) =\n  (\\<forall>j. A' $h i' $h j = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>Mod_Type_Connect.HMA_I x y;\n        Mod_Type_Connect.HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF x xa = is_zero_row y ya", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<forall>j<dim_col A. A $$ (i, j) = (0::'a)) =\n  (\\<forall>j. A' $h i' $h j = (0::'a))\n\ngoal (1 subgoal):\n 1. is_zero_row_JNF i A = is_zero_row i' A'", "unfolding is_zero_row_def' is_zero_row_JNF_def"], ["proof (prove)\nusing this:\n  (\\<forall>j<dim_col A. A $$ (i, j) = (0::'a)) =\n  (\\<forall>j. A' $h i' $h j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<forall>j<dim_col A. A $$ (i, j) = (0::'a)) =\n    (\\<forall>j. A' $h i' $h j = (0::'a))", "by auto"], ["proof (state)\nthis:\n  is_zero_row_JNF i A = is_zero_row i' A'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_echelon_form_mod_type[transfer_rule]: \n  \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a ::bezout_ring ^ 'n :: mod_type ^ 'm :: mod_type \\<Rightarrow> _) ===> (=))\n  echelon_form_JNF echelon_form\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) echelon_form_JNF echelon_form", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       echelon_form_JNF x = echelon_form y", "case (1 A A')"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       echelon_form_JNF x = echelon_form y", "note AA' = \"1\"(1)[transfer_rule]"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       echelon_form_JNF x = echelon_form y", "have 1: \"(\\<forall>i<dim_row A. is_zero_row_JNF i A \\<longrightarrow> \\<not> (\\<exists>j < dim_row A. j>i \\<and> \\<not> is_zero_row_JNF j A))\n    = (\\<forall>i. is_zero_row i A' \\<longrightarrow> \\<not> (\\<exists>j>i. \\<not> is_zero_row j A'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<dim_row A.\n        is_zero_row_JNF i A \\<longrightarrow>\n        \\<not> (\\<exists>j<dim_row A.\n                   i < j \\<and> \\<not> is_zero_row_JNF j A)) =\n    (\\<forall>i.\n        is_zero_row i A' \\<longrightarrow>\n        \\<not> (\\<exists>j>i. \\<not> is_zero_row j A'))", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i<dim_row A.\n                   is_zero_row_JNF i A \\<longrightarrow>\n                   (\\<forall>j>i.\n                       j < dim_row A \\<longrightarrow> is_zero_row_JNF j A);\n        is_zero_row i A'; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j A'\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "fix i' j'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i<dim_row A.\n                   is_zero_row_JNF i A \\<longrightarrow>\n                   (\\<forall>j>i.\n                       j < dim_row A \\<longrightarrow> is_zero_row_JNF j A);\n        is_zero_row i A'; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j A'\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "assume 1: \"\\<forall>i<dim_row A. is_zero_row_JNF i A \\<longrightarrow> (\\<forall>j>i. j < dim_row A \\<longrightarrow> is_zero_row_JNF j A)\"\n      and 2: \"is_zero_row i' A'\" and 3: \"i' < j'\""], ["proof (state)\nthis:\n  \\<forall>i<dim_row A.\n     is_zero_row_JNF i A \\<longrightarrow>\n     (\\<forall>j>i. j < dim_row A \\<longrightarrow> is_zero_row_JNF j A)\n  is_zero_row i' A'\n  i' < j'\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i<dim_row A.\n                   is_zero_row_JNF i A \\<longrightarrow>\n                   (\\<forall>j>i.\n                       j < dim_row A \\<longrightarrow> is_zero_row_JNF j A);\n        is_zero_row i A'; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j A'\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "let ?i = \"Mod_Type.to_nat i'\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i<dim_row A.\n                   is_zero_row_JNF i A \\<longrightarrow>\n                   (\\<forall>j>i.\n                       j < dim_row A \\<longrightarrow> is_zero_row_JNF j A);\n        is_zero_row i A'; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j A'\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "let ?j = \"Mod_Type.to_nat j'\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i<dim_row A.\n                   is_zero_row_JNF i A \\<longrightarrow>\n                   (\\<forall>j>i.\n                       j < dim_row A \\<longrightarrow> is_zero_row_JNF j A);\n        is_zero_row i A'; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j A'\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "have ii'[transfer_rule]: \"Mod_Type_Connect.HMA_I ?i i'\" and jj'[transfer_rule]: \"Mod_Type_Connect.HMA_I ?j j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (mod_type_class.to_nat i') i' &&&\n    Mod_Type_Connect.HMA_I (mod_type_class.to_nat j') j'", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i' = mod_type_class.to_nat i' &&&\n    mod_type_class.to_nat j' = mod_type_class.to_nat j'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (mod_type_class.to_nat i') i'\n  Mod_Type_Connect.HMA_I (mod_type_class.to_nat j') j'\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i<dim_row A.\n                   is_zero_row_JNF i A \\<longrightarrow>\n                   (\\<forall>j>i.\n                       j < dim_row A \\<longrightarrow> is_zero_row_JNF j A);\n        is_zero_row i A'; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j A'\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "have \"is_zero_row_JNF ?i A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_JNF (mod_type_class.to_nat i') A", "using 2"], ["proof (prove)\nusing this:\n  is_zero_row i' A'\n\ngoal (1 subgoal):\n 1. is_zero_row_JNF (mod_type_class.to_nat i') A", "by transfer'"], ["proof (state)\nthis:\n  is_zero_row_JNF (mod_type_class.to_nat i') A\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i<dim_row A.\n                   is_zero_row_JNF i A \\<longrightarrow>\n                   (\\<forall>j>i.\n                       j < dim_row A \\<longrightarrow> is_zero_row_JNF j A);\n        is_zero_row i A'; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j A'\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "hence \"is_zero_row_JNF ?j A\""], ["proof (prove)\nusing this:\n  is_zero_row_JNF (mod_type_class.to_nat i') A\n\ngoal (1 subgoal):\n 1. is_zero_row_JNF (mod_type_class.to_nat j') A", "using 1 3 to_nat_mono"], ["proof (prove)\nusing this:\n  is_zero_row_JNF (mod_type_class.to_nat i') A\n  \\<forall>i<dim_row A.\n     is_zero_row_JNF i A \\<longrightarrow>\n     (\\<forall>j>i. j < dim_row A \\<longrightarrow> is_zero_row_JNF j A)\n  i' < j'\n  ?a < ?b \\<Longrightarrow>\n  mod_type_class.to_nat ?a < mod_type_class.to_nat ?b\n\ngoal (1 subgoal):\n 1. is_zero_row_JNF (mod_type_class.to_nat j') A", "by (metis AA' Mod_Type_Connect.HMA_M_def Mod_Type_Connect.from_hma\\<^sub>m_def\n          dim_row_mat(1) mod_type_class.to_nat_less_card)"], ["proof (state)\nthis:\n  is_zero_row_JNF (mod_type_class.to_nat j') A\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i<dim_row A.\n                   is_zero_row_JNF i A \\<longrightarrow>\n                   (\\<forall>j>i.\n                       j < dim_row A \\<longrightarrow> is_zero_row_JNF j A);\n        is_zero_row i A'; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row j A'\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "thus \"is_zero_row j' A'\""], ["proof (prove)\nusing this:\n  is_zero_row_JNF (mod_type_class.to_nat j') A\n\ngoal (1 subgoal):\n 1. is_zero_row j' A'", "by transfer'"], ["proof (state)\nthis:\n  is_zero_row j' A'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "assume 1: \"\\<forall>i'. is_zero_row i' A' \\<longrightarrow> (\\<forall>j'>i'. is_zero_row j' A')\"\n      and 2: \"is_zero_row_JNF i A\" and 3: \"i < j\" and 4: \"j<dim_row A\""], ["proof (state)\nthis:\n  \\<forall>i'.\n     is_zero_row i' A' \\<longrightarrow> (\\<forall>j'>i'. is_zero_row j' A')\n  is_zero_row_JNF i A\n  i < j\n  j < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "let ?i' = \"Mod_Type.from_nat i::'m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "let ?j' = \"Mod_Type.from_nat j::'m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "have ii'[transfer_rule]: \"Mod_Type_Connect.HMA_I i ?i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I i (mod_type_class.from_nat i)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = mod_type_class.to_nat (mod_type_class.from_nat i)", "using Mod_Type.to_nat_from_nat_id[of i]"], ["proof (prove)\nusing this:\n  i < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat i) = i\n\ngoal (1 subgoal):\n 1. i = mod_type_class.to_nat (mod_type_class.from_nat i)", "using 3 4 AA' Mod_Type_Connect.dim_row_transfer_rule less_trans"], ["proof (prove)\nusing this:\n  i < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat i) = i\n  i < j\n  j < dim_row A\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. i = mod_type_class.to_nat (mod_type_class.from_nat i)", "by fastforce"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I i (mod_type_class.from_nat i)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "have jj'[transfer_rule]: \"Mod_Type_Connect.HMA_I j ?j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I j (mod_type_class.from_nat j)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j = mod_type_class.to_nat (mod_type_class.from_nat j)", "using Mod_Type.to_nat_from_nat_id[of j]"], ["proof (prove)\nusing this:\n  j < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat j) = j\n\ngoal (1 subgoal):\n 1. j = mod_type_class.to_nat (mod_type_class.from_nat j)", "using 3 4 AA' Mod_Type_Connect.dim_row_transfer_rule less_trans"], ["proof (prove)\nusing this:\n  j < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat j) = j\n  i < j\n  j < dim_row A\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. j = mod_type_class.to_nat (mod_type_class.from_nat j)", "by fastforce"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I j (mod_type_class.from_nat j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "have \"is_zero_row ?i' A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row (mod_type_class.from_nat i) A'", "using 2"], ["proof (prove)\nusing this:\n  is_zero_row_JNF i A\n\ngoal (1 subgoal):\n 1. is_zero_row (mod_type_class.from_nat i) A'", "by transfer"], ["proof (state)\nthis:\n  is_zero_row (mod_type_class.from_nat i) A'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "moreover"], ["proof (state)\nthis:\n  is_zero_row (mod_type_class.from_nat i) A'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "have \"?i' < ?j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat j", "using 3 4 AA' Mod_Type_Connect.dim_row_transfer_rule from_nat_mono"], ["proof (prove)\nusing this:\n  i < j\n  j < dim_row A\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  \\<lbrakk>?i < ?j; ?j < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat ?i < mod_type_class.from_nat ?j\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat j", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.from_nat i < mod_type_class.from_nat j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "ultimately"], ["proof (chain)\npicking this:\n  is_zero_row (mod_type_class.from_nat i) A'\n  mod_type_class.from_nat i < mod_type_class.from_nat j", "have \"is_zero_row ?j' A'\""], ["proof (prove)\nusing this:\n  is_zero_row (mod_type_class.from_nat i) A'\n  mod_type_class.from_nat i < mod_type_class.from_nat j\n\ngoal (1 subgoal):\n 1. is_zero_row (mod_type_class.from_nat j) A'", "using 1 3"], ["proof (prove)\nusing this:\n  is_zero_row (mod_type_class.from_nat i) A'\n  mod_type_class.from_nat i < mod_type_class.from_nat j\n  \\<forall>i'.\n     is_zero_row i' A' \\<longrightarrow> (\\<forall>j'>i'. is_zero_row j' A')\n  i < j\n\ngoal (1 subgoal):\n 1. is_zero_row (mod_type_class.from_nat j) A'", "by auto"], ["proof (state)\nthis:\n  is_zero_row (mod_type_class.from_nat j) A'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i.\n                   is_zero_row i A' \\<longrightarrow>\n                   (\\<forall>j>i. is_zero_row j A');\n        is_zero_row_JNF i A; i < j; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_JNF j A", "thus \"is_zero_row_JNF j A\""], ["proof (prove)\nusing this:\n  is_zero_row (mod_type_class.from_nat j) A'\n\ngoal (1 subgoal):\n 1. is_zero_row_JNF j A", "by transfer"], ["proof (state)\nthis:\n  is_zero_row_JNF j A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>i<dim_row A.\n      is_zero_row_JNF i A \\<longrightarrow>\n      \\<not> (\\<exists>j<dim_row A.\n                 i < j \\<and> \\<not> is_zero_row_JNF j A)) =\n  (\\<forall>i.\n      is_zero_row i A' \\<longrightarrow>\n      \\<not> (\\<exists>j>i. \\<not> is_zero_row j A'))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       echelon_form_JNF x = echelon_form y", "have 2: \"((\\<forall>i j. i<j \\<and> \\<not> (is_zero_row i A') \\<and> \\<not> (is_zero_row j A') \n    \\<longrightarrow> ((LEAST n. A' $h i $h n \\<noteq> 0) < (LEAST n. A' $h j $h n \\<noteq> 0)))) \n    = (\\<forall>i j. i<j \\<and> j<dim_row A \\<and> \\<not> (is_zero_row_JNF i A) \\<and> \\<not> (is_zero_row_JNF j A) \n    \\<longrightarrow> ((LEAST n. A $$ (i, n) \\<noteq> 0) < (LEAST n. A $$ (j, n) \\<noteq> 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i j.\n        i < j \\<and>\n        \\<not> is_zero_row i A' \\<and>\n        \\<not> is_zero_row j A' \\<longrightarrow>\n        (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n        < (LEAST n. A' $h j $h n \\<noteq> (0::'a))) =\n    (\\<forall>i j.\n        i < j \\<and>\n        j < dim_row A \\<and>\n        \\<not> is_zero_row_JNF i A \\<and>\n        \\<not> is_zero_row_JNF j A \\<longrightarrow>\n        (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n        < (LEAST n. A $$ (j, n) \\<noteq> (0::'a)))", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "fix i j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "assume 1: \"\\<forall>i' j'. i' < j' \\<and> \\<not> is_zero_row i' A' \\<and> \\<not> is_zero_row j' A' \n      \\<longrightarrow> (LEAST n'. A' $h i' $h n' \\<noteq> 0) < (LEAST n'. A' $h j' $h n' \\<noteq> 0)\"\n      and ij: \"i < j\" and j: \"j < dim_row A\" and i0: \"\\<not> is_zero_row_JNF i A\"\n      and j0: \"\\<not> is_zero_row_JNF j A\""], ["proof (state)\nthis:\n  \\<forall>i' j'.\n     i' < j' \\<and>\n     \\<not> is_zero_row i' A' \\<and>\n     \\<not> is_zero_row j' A' \\<longrightarrow>\n     (LEAST n'. A' $h i' $h n' \\<noteq> (0::'a))\n     < (LEAST n'. A' $h j' $h n' \\<noteq> (0::'a))\n  i < j\n  j < dim_row A\n  \\<not> is_zero_row_JNF i A\n  \\<not> is_zero_row_JNF j A\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "let ?i' = \"Mod_Type.from_nat i::'m\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "let ?j' = \"Mod_Type.from_nat j::'m\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have ii'[transfer_rule]: \"Mod_Type_Connect.HMA_I i ?i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I i (mod_type_class.from_nat i)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = mod_type_class.to_nat (mod_type_class.from_nat i)", "using Mod_Type.to_nat_from_nat_id[of i]"], ["proof (prove)\nusing this:\n  i < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat i) = i\n\ngoal (1 subgoal):\n 1. i = mod_type_class.to_nat (mod_type_class.from_nat i)", "using ij j AA' Mod_Type_Connect.dim_row_transfer_rule less_trans"], ["proof (prove)\nusing this:\n  i < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat i) = i\n  i < j\n  j < dim_row A\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. i = mod_type_class.to_nat (mod_type_class.from_nat i)", "by fastforce"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I i (mod_type_class.from_nat i)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have jj'[transfer_rule]: \"Mod_Type_Connect.HMA_I j ?j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I j (mod_type_class.from_nat j)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j = mod_type_class.to_nat (mod_type_class.from_nat j)", "using Mod_Type.to_nat_from_nat_id[of j]"], ["proof (prove)\nusing this:\n  j < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat j) = j\n\ngoal (1 subgoal):\n 1. j = mod_type_class.to_nat (mod_type_class.from_nat j)", "using ij j AA' Mod_Type_Connect.dim_row_transfer_rule less_trans"], ["proof (prove)\nusing this:\n  j < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat j) = j\n  i < j\n  j < dim_row A\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. j = mod_type_class.to_nat (mod_type_class.from_nat j)", "by fastforce"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I j (mod_type_class.from_nat j)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have i'0: \"\\<not> is_zero_row ?i' A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat i) A'", "using i0"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_JNF i A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat i) A'", "by transfer"], ["proof (state)\nthis:\n  \\<not> is_zero_row (mod_type_class.from_nat i) A'\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have j'0: \"\\<not> is_zero_row ?j' A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat j) A'", "using j0"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_JNF j A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat j) A'", "by transfer"], ["proof (state)\nthis:\n  \\<not> is_zero_row (mod_type_class.from_nat j) A'\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have i'j': \"?i' < ?j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat j", "using AA' Mod_Type_Connect.dim_row_transfer_rule from_nat_mono ij j"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  \\<lbrakk>?i < ?j; ?j < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat ?i < mod_type_class.from_nat ?j\n  i < j\n  j < dim_row A\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat j", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.from_nat i < mod_type_class.from_nat j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have l1l2: \"(LEAST n'. A' $h ?i' $h n' \\<noteq> 0) < (LEAST n'. A' $h ?j' $h n' \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n'. A' $h mod_type_class.from_nat i $h n' \\<noteq> (0::'a))\n    < (LEAST n'. A' $h mod_type_class.from_nat j $h n' \\<noteq> (0::'a))", "using 1 i'0 j'0 i'j'"], ["proof (prove)\nusing this:\n  \\<forall>i' j'.\n     i' < j' \\<and>\n     \\<not> is_zero_row i' A' \\<and>\n     \\<not> is_zero_row j' A' \\<longrightarrow>\n     (LEAST n'. A' $h i' $h n' \\<noteq> (0::'a))\n     < (LEAST n'. A' $h j' $h n' \\<noteq> (0::'a))\n  \\<not> is_zero_row (mod_type_class.from_nat i) A'\n  \\<not> is_zero_row (mod_type_class.from_nat j) A'\n  mod_type_class.from_nat i < mod_type_class.from_nat j\n\ngoal (1 subgoal):\n 1. (LEAST n'. A' $h mod_type_class.from_nat i $h n' \\<noteq> (0::'a))\n    < (LEAST n'. A' $h mod_type_class.from_nat j $h n' \\<noteq> (0::'a))", "by auto"], ["proof (state)\nthis:\n  (LEAST n'. A' $h mod_type_class.from_nat i $h n' \\<noteq> (0::'a))\n  < (LEAST n'. A' $h mod_type_class.from_nat j $h n' \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "define l1 where \"l1 = (LEAST n'. A' $h ?i' $h n' \\<noteq> 0)\""], ["proof (state)\nthis:\n  l1 = (LEAST n'. A' $h mod_type_class.from_nat i $h n' \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "define l2 where \"l2 = (LEAST n'. A' $h ?j' $h n' \\<noteq> 0)\""], ["proof (state)\nthis:\n  l2 = (LEAST n'. A' $h mod_type_class.from_nat j $h n' \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "let ?least_n1 = \"Mod_Type.to_nat l1\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "let ?least_n2 = \"Mod_Type.to_nat l2\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have l1[transfer_rule]: \"Mod_Type_Connect.HMA_I ?least_n1 l1\" and [transfer_rule]: \"Mod_Type_Connect.HMA_I ?least_n2 l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (mod_type_class.to_nat l1) l1 &&&\n    Mod_Type_Connect.HMA_I (mod_type_class.to_nat l2) l2", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l1 = mod_type_class.to_nat l1 &&&\n    mod_type_class.to_nat l2 = mod_type_class.to_nat l2", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (mod_type_class.to_nat l1) l1\n  Mod_Type_Connect.HMA_I (mod_type_class.to_nat l2) l2\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have \"(LEAST n. A $$ (i, n) \\<noteq> 0) = ?least_n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l1", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "obtain n' where n'1: \"A $$ (i,n') \\<noteq> 0\" and n'2: \"n'<dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>A $$ (i, n') \\<noteq> (0::'a); n' < dim_col A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using i0"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_JNF i A\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>A $$ (i, n') \\<noteq> (0::'a); n' < dim_col A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_JNF_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j<dim_col A. A $$ (i, j) = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>A $$ (i, n') \\<noteq> (0::'a); n' < dim_col A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A $$ (i, n') \\<noteq> (0::'a)\n  n' < dim_col A\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "let ?n' = \"Mod_Type.from_nat n'::'n\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "have n'n'[transfer_rule]: \"Mod_Type_Connect.HMA_I n' ?n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I n' (mod_type_class.from_nat n')", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n' = mod_type_class.to_nat (mod_type_class.from_nat n')", "using Mod_Type.to_nat_from_nat_id n'2"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  n' < dim_col A\n\ngoal (1 subgoal):\n 1. n' = mod_type_class.to_nat (mod_type_class.from_nat n')", "using AA' Mod_Type_Connect.dim_col_transfer_rule"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  n' < dim_col A\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n\ngoal (1 subgoal):\n 1. n' = mod_type_class.to_nat (mod_type_class.from_nat n')", "by fastforce"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I n' (mod_type_class.from_nat n')\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "have \"index_hma A' ?i' ?n' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' (mod_type_class.from_nat i)\n     (mod_type_class.from_nat n') \\<noteq>\n    (0::'a)", "using n'1"], ["proof (prove)\nusing this:\n  A $$ (i, n') \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. index_hma A' (mod_type_class.from_nat i)\n     (mod_type_class.from_nat n') \\<noteq>\n    (0::'a)", "by transfer"], ["proof (state)\nthis:\n  index_hma A' (mod_type_class.from_nat i)\n   (mod_type_class.from_nat n') \\<noteq>\n  (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "hence A'i'n': \"A' $h ?i' $h ?n' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  index_hma A' (mod_type_class.from_nat i)\n   (mod_type_class.from_nat n') \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat i $h mod_type_class.from_nat n' \\<noteq>\n    (0::'a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  A' $h mod_type_class.from_nat i $h mod_type_class.from_nat n' \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat i $h mod_type_class.from_nat n' \\<noteq>\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  A' $h mod_type_class.from_nat i $h mod_type_class.from_nat n' \\<noteq>\n  (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "have least_le_n': \"(LEAST n. A $$ (i, n) \\<noteq> 0)  \\<le> n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<le> n'", "by (simp add: Least_le n'1)"], ["proof (state)\nthis:\n  (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<le> n'\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "have l1_le_n': \"l1 \\<le> ?n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l1 \\<le> mod_type_class.from_nat n'", "by (simp add: A'i'n' Least_le l1_def)"], ["proof (state)\nthis:\n  l1 \\<le> mod_type_class.from_nat n'\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "have \"A $$ (i, ?least_n1) = index_hma A' ?i' l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, mod_type_class.to_nat l1) =\n    index_hma A' (mod_type_class.from_nat i) l1", "by (transfer, simp)"], ["proof (state)\nthis:\n  A $$ (i, mod_type_class.to_nat l1) =\n  index_hma A' (mod_type_class.from_nat i) l1\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "also"], ["proof (state)\nthis:\n  A $$ (i, mod_type_class.to_nat l1) =\n  index_hma A' (mod_type_class.from_nat i) l1\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "have \"... = A' $h mod_type_class.from_nat i $h l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' (mod_type_class.from_nat i) l1 =\n    A' $h mod_type_class.from_nat i $h l1", "unfolding index_hma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat i $h l1 =\n    A' $h mod_type_class.from_nat i $h l1", "by simp"], ["proof (state)\nthis:\n  index_hma A' (mod_type_class.from_nat i) l1 =\n  A' $h mod_type_class.from_nat i $h l1\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "also"], ["proof (state)\nthis:\n  index_hma A' (mod_type_class.from_nat i) l1 =\n  A' $h mod_type_class.from_nat i $h l1\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat i $h l1 \\<noteq> (0::'a)", "unfolding l1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat i $h\n    (LEAST n'.\n        A' $h mod_type_class.from_nat i $h n' \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) LeastI i'0 is_zero_row_def')"], ["proof (state)\nthis:\n  A' $h mod_type_class.from_nat i $h l1 \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "finally"], ["proof (chain)\npicking this:\n  A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)", "show \"A $$ (i, mod_type_class.to_nat l1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  A $$ (i, mod_type_class.to_nat l1) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "assume Aiy: \"A $$ (i, y) \\<noteq> 0\""], ["proof (state)\nthis:\n  A $$ (i, y) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "let ?y' = \"Mod_Type.from_nat y::'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l1 \\<le> y", "show \"Mod_Type.to_nat l1 \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l1 \\<le> y", "proof (cases \"y\\<le>n'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y", "case True"], ["proof (state)\nthis:\n  y \\<le> n'\n\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y", "hence y: \"y < dim_col A\""], ["proof (prove)\nusing this:\n  y \\<le> n'\n\ngoal (1 subgoal):\n 1. y < dim_col A", "using n'2"], ["proof (prove)\nusing this:\n  y \\<le> n'\n  n' < dim_col A\n\ngoal (1 subgoal):\n 1. y < dim_col A", "by auto"], ["proof (state)\nthis:\n  y < dim_col A\n\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y", "have yy'[transfer_rule]: \"Mod_Type_Connect.HMA_I y ?y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I y (mod_type_class.from_nat y)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = mod_type_class.to_nat (mod_type_class.from_nat y)", "apply (rule Mod_Type.to_nat_from_nat_id[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. y < CARD('n)", "using y Mod_Type_Connect.dim_col_transfer_rule[OF AA']"], ["proof (prove)\nusing this:\n  y < dim_col A\n  dim_col A = CARD('n)\n\ngoal (1 subgoal):\n 1. y < CARD('n)", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I y (mod_type_class.from_nat y)\n\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y", "have \"Mod_Type.to_nat l1 \\<le> Mod_Type.to_nat ?y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l1\n    \\<le> mod_type_class.to_nat (mod_type_class.from_nat y)", "proof (rule to_nat_mono')"], ["proof (state)\ngoal (1 subgoal):\n 1. l1 \\<le> mod_type_class.from_nat y", "have \"index_hma A' ?i' ?y' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' (mod_type_class.from_nat i)\n     (mod_type_class.from_nat y) \\<noteq>\n    (0::'a)", "using Aiy"], ["proof (prove)\nusing this:\n  A $$ (i, y) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. index_hma A' (mod_type_class.from_nat i)\n     (mod_type_class.from_nat y) \\<noteq>\n    (0::'a)", "by transfer"], ["proof (state)\nthis:\n  index_hma A' (mod_type_class.from_nat i)\n   (mod_type_class.from_nat y) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. l1 \\<le> mod_type_class.from_nat y", "hence \"A' $h ?i' $h ?y' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  index_hma A' (mod_type_class.from_nat i)\n   (mod_type_class.from_nat y) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat i $h mod_type_class.from_nat y \\<noteq>\n    (0::'a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  A' $h mod_type_class.from_nat i $h mod_type_class.from_nat y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat i $h mod_type_class.from_nat y \\<noteq>\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  A' $h mod_type_class.from_nat i $h mod_type_class.from_nat y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. l1 \\<le> mod_type_class.from_nat y", "thus \"l1 \\<le> ?y'\""], ["proof (prove)\nusing this:\n  A' $h mod_type_class.from_nat i $h mod_type_class.from_nat y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. l1 \\<le> mod_type_class.from_nat y", "unfolding l1_def"], ["proof (prove)\nusing this:\n  A' $h mod_type_class.from_nat i $h mod_type_class.from_nat y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n'. A' $h mod_type_class.from_nat i $h n' \\<noteq> (0::'a))\n    \\<le> mod_type_class.from_nat y", "by (simp add: Least_le)"], ["proof (state)\nthis:\n  l1 \\<le> mod_type_class.from_nat y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.to_nat l1\n  \\<le> mod_type_class.to_nat (mod_type_class.from_nat y)\n\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y", "then"], ["proof (chain)\npicking this:\n  mod_type_class.to_nat l1\n  \\<le> mod_type_class.to_nat (mod_type_class.from_nat y)", "show ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat l1\n  \\<le> mod_type_class.to_nat (mod_type_class.from_nat y)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l1 \\<le> y", "by (metis Mod_Type_Connect.HMA_I_def yy')"], ["proof (state)\nthis:\n  mod_type_class.to_nat l1 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> y \\<le> n'\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y", "hence \"n' < y\""], ["proof (prove)\nusing this:\n  \\<not> y \\<le> n'\n\ngoal (1 subgoal):\n 1. n' < y", "by auto"], ["proof (state)\nthis:\n  n' < y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l1 \\<le> y", "then"], ["proof (chain)\npicking this:\n  n' < y", "show ?thesis"], ["proof (prove)\nusing this:\n  n' < y\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l1 \\<le> y", "by (metis False Mod_Type_Connect.HMA_I_def dual_order.trans l1_le_n' linear n'n' to_nat_mono')"], ["proof (state)\nthis:\n  mod_type_class.to_nat l1 \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.to_nat l1 \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l1\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "moreover"], ["proof (state)\nthis:\n  (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l1\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have \"(LEAST n. A $$ (j, n) \\<noteq> 0) = ?least_n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $$ (j, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l2", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "obtain n' where n'1: \"A $$ (j,n') \\<noteq> 0\" and n'2: \"n'<dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>A $$ (j, n') \\<noteq> (0::'a); n' < dim_col A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using j0"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_JNF j A\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>A $$ (j, n') \\<noteq> (0::'a); n' < dim_col A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_JNF_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>ja<dim_col A. A $$ (j, ja) = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>A $$ (j, n') \\<noteq> (0::'a); n' < dim_col A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A $$ (j, n') \\<noteq> (0::'a)\n  n' < dim_col A\n\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "let ?n' = \"Mod_Type.from_nat n'::'n\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "have n'n'[transfer_rule]: \"Mod_Type_Connect.HMA_I n' ?n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I n' (mod_type_class.from_nat n')", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n' = mod_type_class.to_nat (mod_type_class.from_nat n')", "using Mod_Type.to_nat_from_nat_id n'2"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  n' < dim_col A\n\ngoal (1 subgoal):\n 1. n' = mod_type_class.to_nat (mod_type_class.from_nat n')", "using AA' Mod_Type_Connect.dim_col_transfer_rule"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  n' < dim_col A\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n\ngoal (1 subgoal):\n 1. n' = mod_type_class.to_nat (mod_type_class.from_nat n')", "by fastforce"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I n' (mod_type_class.from_nat n')\n\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "have \"index_hma A' ?j' ?n' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' (mod_type_class.from_nat j)\n     (mod_type_class.from_nat n') \\<noteq>\n    (0::'a)", "using n'1"], ["proof (prove)\nusing this:\n  A $$ (j, n') \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. index_hma A' (mod_type_class.from_nat j)\n     (mod_type_class.from_nat n') \\<noteq>\n    (0::'a)", "by transfer"], ["proof (state)\nthis:\n  index_hma A' (mod_type_class.from_nat j)\n   (mod_type_class.from_nat n') \\<noteq>\n  (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "hence A'i'n': \"A' $h ?j' $h ?n' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  index_hma A' (mod_type_class.from_nat j)\n   (mod_type_class.from_nat n') \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat j $h mod_type_class.from_nat n' \\<noteq>\n    (0::'a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  A' $h mod_type_class.from_nat j $h mod_type_class.from_nat n' \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat j $h mod_type_class.from_nat n' \\<noteq>\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  A' $h mod_type_class.from_nat j $h mod_type_class.from_nat n' \\<noteq>\n  (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "have least_le_n': \"(LEAST n. A $$ (j, n) \\<noteq> 0)  \\<le> n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $$ (j, n) \\<noteq> (0::'a)) \\<le> n'", "by (simp add: Least_le n'1)"], ["proof (state)\nthis:\n  (LEAST n. A $$ (j, n) \\<noteq> (0::'a)) \\<le> n'\n\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "have l1_le_n': \"l2 \\<le> ?n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l2 \\<le> mod_type_class.from_nat n'", "by (simp add: A'i'n' Least_le l2_def)"], ["proof (state)\nthis:\n  l2 \\<le> mod_type_class.from_nat n'\n\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "have \"A $$ (j, ?least_n2) = index_hma A' ?j' l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (j, mod_type_class.to_nat l2) =\n    index_hma A' (mod_type_class.from_nat j) l2", "by (transfer, simp)"], ["proof (state)\nthis:\n  A $$ (j, mod_type_class.to_nat l2) =\n  index_hma A' (mod_type_class.from_nat j) l2\n\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "also"], ["proof (state)\nthis:\n  A $$ (j, mod_type_class.to_nat l2) =\n  index_hma A' (mod_type_class.from_nat j) l2\n\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "have \"... = A' $h ?j' $h l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' (mod_type_class.from_nat j) l2 =\n    A' $h mod_type_class.from_nat j $h l2", "unfolding index_hma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat j $h l2 =\n    A' $h mod_type_class.from_nat j $h l2", "by simp"], ["proof (state)\nthis:\n  index_hma A' (mod_type_class.from_nat j) l2 =\n  A' $h mod_type_class.from_nat j $h l2\n\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "also"], ["proof (state)\nthis:\n  index_hma A' (mod_type_class.from_nat j) l2 =\n  A' $h mod_type_class.from_nat j $h l2\n\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat j $h l2 \\<noteq> (0::'a)", "unfolding l2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat j $h\n    (LEAST n'.\n        A' $h mod_type_class.from_nat j $h n' \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by (metis (mono_tags, lifting) LeastI j'0 is_zero_row_def')"], ["proof (state)\nthis:\n  A' $h mod_type_class.from_nat j $h l2 \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "finally"], ["proof (chain)\npicking this:\n  A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)", "show \"A $$ (j, mod_type_class.to_nat l2) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  A $$ (j, mod_type_class.to_nat l2) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "assume Aiy: \"A $$ (j, y) \\<noteq> 0\""], ["proof (state)\nthis:\n  A $$ (j, y) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "let ?y' = \"Mod_Type.from_nat y::'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $$ (j, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l2 \\<le> y", "show \"Mod_Type.to_nat l2 \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l2 \\<le> y", "proof (cases \"y\\<le>n'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y", "case True"], ["proof (state)\nthis:\n  y \\<le> n'\n\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y", "hence y: \"y < dim_col A\""], ["proof (prove)\nusing this:\n  y \\<le> n'\n\ngoal (1 subgoal):\n 1. y < dim_col A", "using n'2"], ["proof (prove)\nusing this:\n  y \\<le> n'\n  n' < dim_col A\n\ngoal (1 subgoal):\n 1. y < dim_col A", "by auto"], ["proof (state)\nthis:\n  y < dim_col A\n\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y", "have yy'[transfer_rule]: \"Mod_Type_Connect.HMA_I y ?y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I y (mod_type_class.from_nat y)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = mod_type_class.to_nat (mod_type_class.from_nat y)", "apply (rule Mod_Type.to_nat_from_nat_id[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. y < CARD('n)", "using y Mod_Type_Connect.dim_col_transfer_rule[OF AA']"], ["proof (prove)\nusing this:\n  y < dim_col A\n  dim_col A = CARD('n)\n\ngoal (1 subgoal):\n 1. y < CARD('n)", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I y (mod_type_class.from_nat y)\n\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y", "have \"Mod_Type.to_nat l2 \\<le> Mod_Type.to_nat ?y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l2\n    \\<le> mod_type_class.to_nat (mod_type_class.from_nat y)", "proof (rule to_nat_mono')"], ["proof (state)\ngoal (1 subgoal):\n 1. l2 \\<le> mod_type_class.from_nat y", "have \"index_hma A' ?j' ?y' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' (mod_type_class.from_nat j)\n     (mod_type_class.from_nat y) \\<noteq>\n    (0::'a)", "using Aiy"], ["proof (prove)\nusing this:\n  A $$ (j, y) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. index_hma A' (mod_type_class.from_nat j)\n     (mod_type_class.from_nat y) \\<noteq>\n    (0::'a)", "by transfer"], ["proof (state)\nthis:\n  index_hma A' (mod_type_class.from_nat j)\n   (mod_type_class.from_nat y) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. l2 \\<le> mod_type_class.from_nat y", "hence \"A' $h ?j' $h ?y' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  index_hma A' (mod_type_class.from_nat j)\n   (mod_type_class.from_nat y) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat j $h mod_type_class.from_nat y \\<noteq>\n    (0::'a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  A' $h mod_type_class.from_nat j $h mod_type_class.from_nat y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat j $h mod_type_class.from_nat y \\<noteq>\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  A' $h mod_type_class.from_nat j $h mod_type_class.from_nat y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. l2 \\<le> mod_type_class.from_nat y", "thus \"l2 \\<le> ?y'\""], ["proof (prove)\nusing this:\n  A' $h mod_type_class.from_nat j $h mod_type_class.from_nat y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. l2 \\<le> mod_type_class.from_nat y", "unfolding l2_def"], ["proof (prove)\nusing this:\n  A' $h mod_type_class.from_nat j $h mod_type_class.from_nat y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n'. A' $h mod_type_class.from_nat j $h n' \\<noteq> (0::'a))\n    \\<le> mod_type_class.from_nat y", "by (simp add: Least_le)"], ["proof (state)\nthis:\n  l2 \\<le> mod_type_class.from_nat y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.to_nat l2\n  \\<le> mod_type_class.to_nat (mod_type_class.from_nat y)\n\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y", "then"], ["proof (chain)\npicking this:\n  mod_type_class.to_nat l2\n  \\<le> mod_type_class.to_nat (mod_type_class.from_nat y)", "show ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat l2\n  \\<le> mod_type_class.to_nat (mod_type_class.from_nat y)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l2 \\<le> y", "by (metis Mod_Type_Connect.HMA_I_def yy')"], ["proof (state)\nthis:\n  mod_type_class.to_nat l2 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> y \\<le> n'\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y", "hence \"n' < y\""], ["proof (prove)\nusing this:\n  \\<not> y \\<le> n'\n\ngoal (1 subgoal):\n 1. n' < y", "by auto"], ["proof (state)\nthis:\n  n' < y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l2 \\<le> y", "then"], ["proof (chain)\npicking this:\n  n' < y", "show ?thesis"], ["proof (prove)\nusing this:\n  n' < y\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l2 \\<le> y", "by (metis False Mod_Type_Connect.HMA_I_def dual_order.trans l1_le_n' linear n'n' to_nat_mono')"], ["proof (state)\nthis:\n  mod_type_class.to_nat l2 \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.to_nat l2 \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $$ (j, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l2\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   \\<not> is_zero_row i A' \\<and>\n                   \\<not> is_zero_row j A' \\<longrightarrow>\n                   (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                   < (LEAST n. A' $h j $h n \\<noteq> (0::'a));\n        i < j; j < dim_row A; \\<not> is_zero_row_JNF i A;\n        \\<not> is_zero_row_JNF j A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "ultimately"], ["proof (chain)\npicking this:\n  (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l1\n  (LEAST n. A $$ (j, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l2", "show \"(LEAST n. A $$ (i, n) \\<noteq> 0) < (LEAST n. A $$ (j, n) \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l1\n  (LEAST n. A $$ (j, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l2\n\ngoal (1 subgoal):\n 1. (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n    < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))", "using l1l2"], ["proof (prove)\nusing this:\n  (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l1\n  (LEAST n. A $$ (j, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l2\n  (LEAST n'. A' $h mod_type_class.from_nat i $h n' \\<noteq> (0::'a))\n  < (LEAST n'. A' $h mod_type_class.from_nat j $h n' \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n    < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))", "unfolding l1_def l2_def"], ["proof (prove)\nusing this:\n  (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n  mod_type_class.to_nat\n   (LEAST n'. A' $h mod_type_class.from_nat i $h n' \\<noteq> (0::'a))\n  (LEAST n. A $$ (j, n) \\<noteq> (0::'a)) =\n  mod_type_class.to_nat\n   (LEAST n'. A' $h mod_type_class.from_nat j $h n' \\<noteq> (0::'a))\n  (LEAST n'. A' $h mod_type_class.from_nat i $h n' \\<noteq> (0::'a))\n  < (LEAST n'. A' $h mod_type_class.from_nat j $h n' \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n    < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))", "by (simp add: to_nat_mono)"], ["proof (state)\nthis:\n  (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n  < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "fix i' j'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "assume 1: \"\\<forall>i j. i < j \\<and> j < dim_row A \\<and> \\<not> is_zero_row_JNF i A \\<and> \\<not> is_zero_row_JNF j A \n      \\<longrightarrow> (LEAST n. A $$ (i, n) \\<noteq> 0) < (LEAST n. A $$ (j, n) \\<noteq> 0)\"\n       and i'j': \"i' < j'\" and i': \"\\<not> is_zero_row i' A'\" and j': \"\\<not> is_zero_row j' A'\""], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < j \\<and>\n     j < dim_row A \\<and>\n     \\<not> is_zero_row_JNF i A \\<and>\n     \\<not> is_zero_row_JNF j A \\<longrightarrow>\n     (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n     < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n  i' < j'\n  \\<not> is_zero_row i' A'\n  \\<not> is_zero_row j' A'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "let ?i = \"Mod_Type.to_nat i'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "let ?j = \"Mod_Type.to_nat j'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I ?i i'\" \n        and [transfer_rule]: \"Mod_Type_Connect.HMA_I ?j j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (mod_type_class.to_nat i') i' &&&\n    Mod_Type_Connect.HMA_I (mod_type_class.to_nat j') j'", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i' = mod_type_class.to_nat i' &&&\n    mod_type_class.to_nat j' = mod_type_class.to_nat j'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (mod_type_class.to_nat i') i'\n  Mod_Type_Connect.HMA_I (mod_type_class.to_nat j') j'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have i: \"\\<not> is_zero_row_JNF ?i A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_JNF (mod_type_class.to_nat i') A", "using i'"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i' A'\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_JNF (mod_type_class.to_nat i') A", "by transfer'"], ["proof (state)\nthis:\n  \\<not> is_zero_row_JNF (mod_type_class.to_nat i') A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have j: \"\\<not> is_zero_row_JNF ?j A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_JNF (mod_type_class.to_nat j') A", "using j'"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row j' A'\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_JNF (mod_type_class.to_nat j') A", "by transfer'"], ["proof (state)\nthis:\n  \\<not> is_zero_row_JNF (mod_type_class.to_nat j') A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have ij: \"?i < ?j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i' < mod_type_class.to_nat j'", "using i'j' to_nat_mono"], ["proof (prove)\nusing this:\n  i' < j'\n  ?a < ?b \\<Longrightarrow>\n  mod_type_class.to_nat ?a < mod_type_class.to_nat ?b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i' < mod_type_class.to_nat j'", "by blast"], ["proof (state)\nthis:\n  mod_type_class.to_nat i' < mod_type_class.to_nat j'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have j_dim_row: \"?j < dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j' < dim_row A", "using AA' Mod_Type_Connect.dim_row_transfer_rule mod_type_class.to_nat_less_card"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  mod_type_class.to_nat ?j < CARD(?'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j' < dim_row A", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.to_nat j' < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have least_ij: \"(LEAST n. A $$ (?i, n) \\<noteq> 0) < (LEAST n. A $$ (?j, n) \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n    < (LEAST n. A $$ (mod_type_class.to_nat j', n) \\<noteq> (0::'a))", "using i j ij j_dim_row 1"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_JNF (mod_type_class.to_nat i') A\n  \\<not> is_zero_row_JNF (mod_type_class.to_nat j') A\n  mod_type_class.to_nat i' < mod_type_class.to_nat j'\n  mod_type_class.to_nat j' < dim_row A\n  \\<forall>i j.\n     i < j \\<and>\n     j < dim_row A \\<and>\n     \\<not> is_zero_row_JNF i A \\<and>\n     \\<not> is_zero_row_JNF j A \\<longrightarrow>\n     (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n     < (LEAST n. A $$ (j, n) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n    < (LEAST n. A $$ (mod_type_class.to_nat j', n) \\<noteq> (0::'a))", "by auto"], ["proof (state)\nthis:\n  (LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n  < (LEAST n. A $$ (mod_type_class.to_nat j', n) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "define l1 where \"l1 = (LEAST n'. A $$ (?i, n') \\<noteq> 0)\""], ["proof (state)\nthis:\n  l1 = (LEAST n'. A $$ (mod_type_class.to_nat i', n') \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "define l2 where \"l2 = (LEAST n'. A $$ (?j, n') \\<noteq> 0)\""], ["proof (state)\nthis:\n  l2 = (LEAST n'. A $$ (mod_type_class.to_nat j', n') \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "let ?least_n1 = \"Mod_Type.from_nat l1::'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "let ?least_n2 = \"Mod_Type.from_nat l2::'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have l1_dim_col: \"l1 < dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l1 < dim_col A", "by (smt is_zero_row_JNF_def j l1_def leI le_less_trans least_ij less_trans not_less_Least)"], ["proof (state)\nthis:\n  l1 < dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have l2_dim_col: \"l2 < dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l2 < dim_col A", "by (metis (mono_tags, lifting) Least_le is_zero_row_JNF_def j l2_def le_less_trans)"], ["proof (state)\nthis:\n  l2 < dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I l1 ?least_n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I l1 (mod_type_class.from_nat l1)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l1 = mod_type_class.to_nat (mod_type_class.from_nat l1)", "using AA' Mod_Type_Connect.dim_col_transfer_rule l1_dim_col Mod_Type.to_nat_from_nat_id"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n  l1 < dim_col A\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n\ngoal (1 subgoal):\n 1. l1 = mod_type_class.to_nat (mod_type_class.from_nat l1)", "by fastforce"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I l1 (mod_type_class.from_nat l1)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I l2 ?least_n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I l2 (mod_type_class.from_nat l2)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l2 = mod_type_class.to_nat (mod_type_class.from_nat l2)", "using AA' Mod_Type_Connect.dim_col_transfer_rule l2_dim_col Mod_Type.to_nat_from_nat_id"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n  l2 < dim_col A\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n\ngoal (1 subgoal):\n 1. l2 = mod_type_class.to_nat (mod_type_class.from_nat l2)", "by fastforce"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I l2 (mod_type_class.from_nat l2)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have \"(LEAST n. A' $h i' $h n \\<noteq> 0) = ?least_n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) = mod_type_class.from_nat l1", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A' $h i' $h mod_type_class.from_nat l1 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "obtain n' where n'1: \"A' $h i' $h n' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        A' $h i' $h n' \\<noteq> (0::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using i'"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i' A'\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        A' $h i' $h n' \\<noteq> (0::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_def'"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j. A' $h i' $h j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        A' $h i' $h n' \\<noteq> (0::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A' $h i' $h n' \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A' $h i' $h mod_type_class.from_nat l1 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "have \"A' $h i' $h ?least_n1 = index_hma A' i' ?least_n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h i' $h mod_type_class.from_nat l1 =\n    index_hma A' i' (mod_type_class.from_nat l1)", "unfolding index_hma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h i' $h mod_type_class.from_nat l1 =\n    A' $h i' $h mod_type_class.from_nat l1", "by simp"], ["proof (state)\nthis:\n  A' $h i' $h mod_type_class.from_nat l1 =\n  index_hma A' i' (mod_type_class.from_nat l1)\n\ngoal (2 subgoals):\n 1. A' $h i' $h mod_type_class.from_nat l1 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "also"], ["proof (state)\nthis:\n  A' $h i' $h mod_type_class.from_nat l1 =\n  index_hma A' i' (mod_type_class.from_nat l1)\n\ngoal (2 subgoals):\n 1. A' $h i' $h mod_type_class.from_nat l1 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "have \"... = A$$ (?i, l1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' i' (mod_type_class.from_nat l1) =\n    A $$ (mod_type_class.to_nat i', l1)", "by (transfer, simp)"], ["proof (state)\nthis:\n  index_hma A' i' (mod_type_class.from_nat l1) =\n  A $$ (mod_type_class.to_nat i', l1)\n\ngoal (2 subgoals):\n 1. A' $h i' $h mod_type_class.from_nat l1 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "also"], ["proof (state)\nthis:\n  index_hma A' i' (mod_type_class.from_nat l1) =\n  A $$ (mod_type_class.to_nat i', l1)\n\ngoal (2 subgoals):\n 1. A' $h i' $h mod_type_class.from_nat l1 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (mod_type_class.to_nat i', l1) \\<noteq> (0::'a)", "by (metis (mono_tags, lifting) LeastI i is_zero_row_JNF_def l1_def)"], ["proof (state)\nthis:\n  A $$ (mod_type_class.to_nat i', l1) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A' $h i' $h mod_type_class.from_nat l1 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "finally"], ["proof (chain)\npicking this:\n  A' $h i' $h mod_type_class.from_nat l1 \\<noteq> (0::'a)", "show \"A' $h i' $h ?least_n1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A' $h i' $h mod_type_class.from_nat l1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h i' $h mod_type_class.from_nat l1 \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  A' $h i' $h mod_type_class.from_nat l1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "assume y: \"A' $h i' $h y \\<noteq> 0\""], ["proof (state)\nthis:\n  A' $h i' $h y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "let ?y' = \"Mod_Type.to_nat y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I ?y' y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (mod_type_class.to_nat y) y", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y = mod_type_class.to_nat y", "by simp"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (mod_type_class.to_nat y) y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "have \"?least_n1 \\<le> Mod_Type.from_nat ?y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat l1\n    \\<le> mod_type_class.from_nat (mod_type_class.to_nat y)", "proof (unfold l1_def, rule from_nat_mono')"], ["proof (state)\ngoal (2 subgoals):\n 1. (LEAST n'. A $$ (mod_type_class.to_nat i', n') \\<noteq> (0::'a))\n    \\<le> mod_type_class.to_nat y\n 2. mod_type_class.to_nat y < CARD('n)", "show \"Mod_Type.to_nat y < CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < CARD('n)", "by (simp add: mod_type_class.to_nat_less_card)"], ["proof (state)\nthis:\n  mod_type_class.to_nat y < CARD('n)\n\ngoal (1 subgoal):\n 1. (LEAST n'. A $$ (mod_type_class.to_nat i', n') \\<noteq> (0::'a))\n    \\<le> mod_type_class.to_nat y", "have *: \"A $$ (mod_type_class.to_nat i', mod_type_class.to_nat y) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (mod_type_class.to_nat i', mod_type_class.to_nat y) \\<noteq>\n    (0::'a)", "using y[unfolded index_hma_def[symmetric]]"], ["proof (prove)\nusing this:\n  index_hma A' i' y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (mod_type_class.to_nat i', mod_type_class.to_nat y) \\<noteq>\n    (0::'a)", "by transfer'"], ["proof (state)\nthis:\n  A $$ (mod_type_class.to_nat i', mod_type_class.to_nat y) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n'. A $$ (mod_type_class.to_nat i', n') \\<noteq> (0::'a))\n    \\<le> mod_type_class.to_nat y", "show \"(LEAST n'. A $$ (mod_type_class.to_nat i', n') \\<noteq> 0) \\<le> mod_type_class.to_nat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n'. A $$ (mod_type_class.to_nat i', n') \\<noteq> (0::'a))\n    \\<le> mod_type_class.to_nat y", "by (rule Least_le, simp add: *)"], ["proof (state)\nthis:\n  (LEAST n'. A $$ (mod_type_class.to_nat i', n') \\<noteq> (0::'a))\n  \\<le> mod_type_class.to_nat y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat l1\n  \\<le> mod_type_class.from_nat (mod_type_class.to_nat y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "also"], ["proof (state)\nthis:\n  mod_type_class.from_nat l1\n  \\<le> mod_type_class.from_nat (mod_type_class.to_nat y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "have \"... = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (mod_type_class.to_nat y) = y", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat y) = y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h i' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l1 \\<le> y", "finally"], ["proof (chain)\npicking this:\n  mod_type_class.from_nat l1 \\<le> y", "show \"?least_n1 \\<le> y\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat l1 \\<le> y\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat l1 \\<le> y", "."], ["proof (state)\nthis:\n  mod_type_class.from_nat l1 \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) = mod_type_class.from_nat l1\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "moreover"], ["proof (state)\nthis:\n  (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) = mod_type_class.from_nat l1\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "have \"(LEAST n. A' $h j' $h n \\<noteq> 0) = ?least_n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A' $h j' $h n \\<noteq> (0::'a)) = mod_type_class.from_nat l2", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A' $h j' $h mod_type_class.from_nat l2 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "obtain n' where n'1: \"A' $h j' $h n' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        A' $h j' $h n' \\<noteq> (0::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using j'"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row j' A'\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        A' $h j' $h n' \\<noteq> (0::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_def'"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j. A' $h j' $h j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        A' $h j' $h n' \\<noteq> (0::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A' $h j' $h n' \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A' $h j' $h mod_type_class.from_nat l2 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "have \"A' $h j' $h ?least_n2 = index_hma A' j' ?least_n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h j' $h mod_type_class.from_nat l2 =\n    index_hma A' j' (mod_type_class.from_nat l2)", "unfolding index_hma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h j' $h mod_type_class.from_nat l2 =\n    A' $h j' $h mod_type_class.from_nat l2", "by simp"], ["proof (state)\nthis:\n  A' $h j' $h mod_type_class.from_nat l2 =\n  index_hma A' j' (mod_type_class.from_nat l2)\n\ngoal (2 subgoals):\n 1. A' $h j' $h mod_type_class.from_nat l2 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "also"], ["proof (state)\nthis:\n  A' $h j' $h mod_type_class.from_nat l2 =\n  index_hma A' j' (mod_type_class.from_nat l2)\n\ngoal (2 subgoals):\n 1. A' $h j' $h mod_type_class.from_nat l2 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "have \"... = A$$ (?j, l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' j' (mod_type_class.from_nat l2) =\n    A $$ (mod_type_class.to_nat j', l2)", "by (transfer, simp)"], ["proof (state)\nthis:\n  index_hma A' j' (mod_type_class.from_nat l2) =\n  A $$ (mod_type_class.to_nat j', l2)\n\ngoal (2 subgoals):\n 1. A' $h j' $h mod_type_class.from_nat l2 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "also"], ["proof (state)\nthis:\n  index_hma A' j' (mod_type_class.from_nat l2) =\n  A $$ (mod_type_class.to_nat j', l2)\n\ngoal (2 subgoals):\n 1. A' $h j' $h mod_type_class.from_nat l2 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (mod_type_class.to_nat j', l2) \\<noteq> (0::'a)", "by (metis (mono_tags, lifting) LeastI j is_zero_row_JNF_def l2_def)"], ["proof (state)\nthis:\n  A $$ (mod_type_class.to_nat j', l2) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A' $h j' $h mod_type_class.from_nat l2 \\<noteq> (0::'a)\n 2. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "finally"], ["proof (chain)\npicking this:\n  A' $h j' $h mod_type_class.from_nat l2 \\<noteq> (0::'a)", "show \"A' $h j' $h ?least_n2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A' $h j' $h mod_type_class.from_nat l2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h j' $h mod_type_class.from_nat l2 \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  A' $h j' $h mod_type_class.from_nat l2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "assume y: \"A' $h j' $h y \\<noteq> 0\""], ["proof (state)\nthis:\n  A' $h j' $h y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "let ?y' = \"Mod_Type.to_nat y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I ?y' y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (mod_type_class.to_nat y) y", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y = mod_type_class.to_nat y", "by simp"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (mod_type_class.to_nat y) y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "have \"?least_n2 \\<le> Mod_Type.from_nat ?y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat l2\n    \\<le> mod_type_class.from_nat (mod_type_class.to_nat y)", "proof (unfold l2_def, rule from_nat_mono')"], ["proof (state)\ngoal (2 subgoals):\n 1. (LEAST n'. A $$ (mod_type_class.to_nat j', n') \\<noteq> (0::'a))\n    \\<le> mod_type_class.to_nat y\n 2. mod_type_class.to_nat y < CARD('n)", "show \"Mod_Type.to_nat y < CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < CARD('n)", "by (simp add: mod_type_class.to_nat_less_card)"], ["proof (state)\nthis:\n  mod_type_class.to_nat y < CARD('n)\n\ngoal (1 subgoal):\n 1. (LEAST n'. A $$ (mod_type_class.to_nat j', n') \\<noteq> (0::'a))\n    \\<le> mod_type_class.to_nat y", "have *: \"A $$ (mod_type_class.to_nat j', mod_type_class.to_nat y) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (mod_type_class.to_nat j', mod_type_class.to_nat y) \\<noteq>\n    (0::'a)", "using y[unfolded index_hma_def[symmetric]]"], ["proof (prove)\nusing this:\n  index_hma A' j' y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (mod_type_class.to_nat j', mod_type_class.to_nat y) \\<noteq>\n    (0::'a)", "by transfer'"], ["proof (state)\nthis:\n  A $$ (mod_type_class.to_nat j', mod_type_class.to_nat y) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n'. A $$ (mod_type_class.to_nat j', n') \\<noteq> (0::'a))\n    \\<le> mod_type_class.to_nat y", "show \"(LEAST n'. A $$ (mod_type_class.to_nat j', n') \\<noteq> 0) \\<le> mod_type_class.to_nat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n'. A $$ (mod_type_class.to_nat j', n') \\<noteq> (0::'a))\n    \\<le> mod_type_class.to_nat y", "by (rule Least_le, simp add: *)"], ["proof (state)\nthis:\n  (LEAST n'. A $$ (mod_type_class.to_nat j', n') \\<noteq> (0::'a))\n  \\<le> mod_type_class.to_nat y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat l2\n  \\<le> mod_type_class.from_nat (mod_type_class.to_nat y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "also"], ["proof (state)\nthis:\n  mod_type_class.from_nat l2\n  \\<le> mod_type_class.from_nat (mod_type_class.to_nat y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "have \"... = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (mod_type_class.to_nat y) = y", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat (mod_type_class.to_nat y) = y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A' $h j' $h y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat l2 \\<le> y", "finally"], ["proof (chain)\npicking this:\n  mod_type_class.from_nat l2 \\<le> y", "show \"?least_n2 \\<le> y\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat l2 \\<le> y\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat l2 \\<le> y", "."], ["proof (state)\nthis:\n  mod_type_class.from_nat l2 \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A' $h j' $h n \\<noteq> (0::'a)) = mod_type_class.from_nat l2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i j.\n                   i < j \\<and>\n                   j < dim_row A \\<and>\n                   \\<not> is_zero_row_JNF i A \\<and>\n                   \\<not> is_zero_row_JNF j A \\<longrightarrow>\n                   (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                   < (LEAST n. A $$ (j, n) \\<noteq> (0::'a));\n        i < j; \\<not> is_zero_row i A'; \\<not> is_zero_row j A'\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))", "ultimately"], ["proof (chain)\npicking this:\n  (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) = mod_type_class.from_nat l1\n  (LEAST n. A' $h j' $h n \\<noteq> (0::'a)) = mod_type_class.from_nat l2", "show \"(LEAST n. A' $h i' $h n \\<noteq> 0) < (LEAST n. A' $h j' $h n \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) = mod_type_class.from_nat l1\n  (LEAST n. A' $h j' $h n \\<noteq> (0::'a)) = mod_type_class.from_nat l2\n\ngoal (1 subgoal):\n 1. (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n    < (LEAST n. A' $h j' $h n \\<noteq> (0::'a))", "using least_ij"], ["proof (prove)\nusing this:\n  (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) = mod_type_class.from_nat l1\n  (LEAST n. A' $h j' $h n \\<noteq> (0::'a)) = mod_type_class.from_nat l2\n  (LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n  < (LEAST n. A $$ (mod_type_class.to_nat j', n) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n    < (LEAST n. A' $h j' $h n \\<noteq> (0::'a))", "unfolding l1_def l2_def"], ["proof (prove)\nusing this:\n  (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) =\n  mod_type_class.from_nat\n   (LEAST n'. A $$ (mod_type_class.to_nat i', n') \\<noteq> (0::'a))\n  (LEAST n. A' $h j' $h n \\<noteq> (0::'a)) =\n  mod_type_class.from_nat\n   (LEAST n'. A $$ (mod_type_class.to_nat j', n') \\<noteq> (0::'a))\n  (LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n  < (LEAST n. A $$ (mod_type_class.to_nat j', n) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n    < (LEAST n. A' $h j' $h n \\<noteq> (0::'a))", "using AA' Mod_Type_Connect.dim_col_transfer_rule from_nat_mono l2_def l2_dim_col"], ["proof (prove)\nusing this:\n  (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) =\n  mod_type_class.from_nat\n   (LEAST n'. A $$ (mod_type_class.to_nat i', n') \\<noteq> (0::'a))\n  (LEAST n. A' $h j' $h n \\<noteq> (0::'a)) =\n  mod_type_class.from_nat\n   (LEAST n'. A $$ (mod_type_class.to_nat j', n') \\<noteq> (0::'a))\n  (LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n  < (LEAST n. A $$ (mod_type_class.to_nat j', n) \\<noteq> (0::'a))\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n  \\<lbrakk>?i < ?j; ?j < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat ?i < mod_type_class.from_nat ?j\n  l2 = (LEAST n'. A $$ (mod_type_class.to_nat j', n') \\<noteq> (0::'a))\n  l2 < dim_col A\n\ngoal (1 subgoal):\n 1. (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n    < (LEAST n. A' $h j' $h n \\<noteq> (0::'a))", "by fastforce"], ["proof (state)\nthis:\n  (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n  < (LEAST n. A' $h j' $h n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>i j.\n      i < j \\<and>\n      \\<not> is_zero_row i A' \\<and>\n      \\<not> is_zero_row j A' \\<longrightarrow>\n      (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n      < (LEAST n. A' $h j $h n \\<noteq> (0::'a))) =\n  (\\<forall>i j.\n      i < j \\<and>\n      j < dim_row A \\<and>\n      \\<not> is_zero_row_JNF i A \\<and>\n      \\<not> is_zero_row_JNF j A \\<longrightarrow>\n      (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n      < (LEAST n. A $$ (j, n) \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       echelon_form_JNF x = echelon_form y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form_JNF A = echelon_form A'", "unfolding echelon_form_JNF_def echelon_form_def'"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>i<dim_row A.\n         is_zero_row_JNF i A \\<longrightarrow>\n         \\<not> (\\<exists>j<dim_row A.\n                    i < j \\<and> \\<not> is_zero_row_JNF j A)) \\<and>\n     (\\<forall>i j.\n         i < j \\<and>\n         j < dim_row A \\<and>\n         \\<not> is_zero_row_JNF i A \\<and>\n         \\<not> is_zero_row_JNF j A \\<longrightarrow>\n         (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a)))) =\n    ((\\<forall>i.\n         is_zero_row i A' \\<longrightarrow>\n         \\<not> (\\<exists>j>i. \\<not> is_zero_row j A')) \\<and>\n     (\\<forall>i j.\n         i < j \\<and>\n         \\<not> is_zero_row i A' \\<and>\n         \\<not> is_zero_row j A' \\<longrightarrow>\n         (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))))", "using 1 2"], ["proof (prove)\nusing this:\n  (\\<forall>i<dim_row A.\n      is_zero_row_JNF i A \\<longrightarrow>\n      \\<not> (\\<exists>j<dim_row A.\n                 i < j \\<and> \\<not> is_zero_row_JNF j A)) =\n  (\\<forall>i.\n      is_zero_row i A' \\<longrightarrow>\n      \\<not> (\\<exists>j>i. \\<not> is_zero_row j A'))\n  (\\<forall>i j.\n      i < j \\<and>\n      \\<not> is_zero_row i A' \\<and>\n      \\<not> is_zero_row j A' \\<longrightarrow>\n      (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n      < (LEAST n. A' $h j $h n \\<noteq> (0::'a))) =\n  (\\<forall>i j.\n      i < j \\<and>\n      j < dim_row A \\<and>\n      \\<not> is_zero_row_JNF i A \\<and>\n      \\<not> is_zero_row_JNF j A \\<longrightarrow>\n      (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n      < (LEAST n. A $$ (j, n) \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. ((\\<forall>i<dim_row A.\n         is_zero_row_JNF i A \\<longrightarrow>\n         \\<not> (\\<exists>j<dim_row A.\n                    i < j \\<and> \\<not> is_zero_row_JNF j A)) \\<and>\n     (\\<forall>i j.\n         i < j \\<and>\n         j < dim_row A \\<and>\n         \\<not> is_zero_row_JNF i A \\<and>\n         \\<not> is_zero_row_JNF j A \\<longrightarrow>\n         (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n         < (LEAST n. A $$ (j, n) \\<noteq> (0::'a)))) =\n    ((\\<forall>i.\n         is_zero_row i A' \\<longrightarrow>\n         \\<not> (\\<exists>j>i. \\<not> is_zero_row j A')) \\<and>\n     (\\<forall>i j.\n         i < j \\<and>\n         \\<not> is_zero_row i A' \\<and>\n         \\<not> is_zero_row j A' \\<longrightarrow>\n         (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n         < (LEAST n. A' $h j $h n \\<noteq> (0::'a))))", "by auto"], ["proof (state)\nthis:\n  echelon_form_JNF A = echelon_form A'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Hermite_JNF :: \"'a::{bezout_ring_div,normalization_semidom} set \\<Rightarrow> ('a \\<Rightarrow> 'a set) \\<Rightarrow> 'a mat \\<Rightarrow> bool\"\n  where \"Hermite_JNF associates residues A = (\n  Complete_set_non_associates associates \\<and> (Complete_set_residues residues) \\<and> echelon_form_JNF A \n  \\<and> (\\<forall>i<dim_row A. \\<not> is_zero_row_JNF i A \\<longrightarrow> A $$ (i, LEAST n. A $$ (i, n) \\<noteq> 0) \\<in> associates)\n  \\<and> (\\<forall>i<dim_row A. \\<not> is_zero_row_JNF i A \\<longrightarrow> (\\<forall>j. j<i \\<longrightarrow> A $$ (j, (LEAST n. A $$ (i, n) \\<noteq> 0)) \n     \\<in> residues (A $$ (i,(LEAST n. A $$ (i,n) \\<noteq> 0)))\n  )))\""], ["", "lemma HMA_LEAST[transfer_rule]:\n  assumes AA': \"(Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'n :: mod_type ^ 'm :: mod_type \\<Rightarrow> _) A A'\"\n  and ii': \"Mod_Type_Connect.HMA_I i i'\" and zero_i: \"\\<not> is_zero_row_JNF i A\"\nshows \"Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> 0) (LEAST n. index_hma A' i' n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n     (LEAST n. index_hma A' i' n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n     (LEAST n. index_hma A' i' n \\<noteq> (0::'a))", "define l where \"l = (LEAST n'. A' $h i' $h n' \\<noteq> 0)\""], ["proof (state)\nthis:\n  l = (LEAST n'. A' $h i' $h n' \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n     (LEAST n. index_hma A' i' n \\<noteq> (0::'a))", "let ?least_n2 = \"Mod_Type.to_nat l\""], ["proof (state)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n     (LEAST n. index_hma A' i' n \\<noteq> (0::'a))", "note AA'[transfer_rule] ii'[transfer_rule]"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_I i i'\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n     (LEAST n. index_hma A' i' n \\<noteq> (0::'a))", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I ?least_n2 l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (mod_type_class.to_nat l) l", "by (simp add: Mod_Type_Connect.HMA_I_def)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (mod_type_class.to_nat l) l\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n     (LEAST n. index_hma A' i' n \\<noteq> (0::'a))", "have zero_i': \"\\<not> is_zero_row i' A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i' A'", "using zero_i"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_JNF i A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i' A'", "by transfer"], ["proof (state)\nthis:\n  \\<not> is_zero_row i' A'\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n     (LEAST n. index_hma A' i' n \\<noteq> (0::'a))", "have \"(LEAST n. A $$ (i, n) \\<noteq> 0) = ?least_n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "obtain n' where n'1: \"A $$ (i,n') \\<noteq> 0\" and n'2: \"n'<dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>A $$ (i, n') \\<noteq> (0::'a); n' < dim_col A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using zero_i"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_JNF i A\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>A $$ (i, n') \\<noteq> (0::'a); n' < dim_col A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_JNF_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j<dim_col A. A $$ (i, j) = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>A $$ (i, n') \\<noteq> (0::'a); n' < dim_col A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A $$ (i, n') \\<noteq> (0::'a)\n  n' < dim_col A\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "let ?n' = \"Mod_Type.from_nat n'::'n\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "have n'n'[transfer_rule]: \"Mod_Type_Connect.HMA_I n' ?n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I n' (mod_type_class.from_nat n')", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n' = mod_type_class.to_nat (mod_type_class.from_nat n')", "using Mod_Type.to_nat_from_nat_id n'2"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  n' < dim_col A\n\ngoal (1 subgoal):\n 1. n' = mod_type_class.to_nat (mod_type_class.from_nat n')", "using AA' Mod_Type_Connect.dim_col_transfer_rule"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  n' < dim_col A\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_col ?A = CARD(?'nc)\n\ngoal (1 subgoal):\n 1. n' = mod_type_class.to_nat (mod_type_class.from_nat n')", "by fastforce"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I n' (mod_type_class.from_nat n')\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "have \"index_hma A' i' ?n' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' i' (mod_type_class.from_nat n') \\<noteq> (0::'a)", "using n'1"], ["proof (prove)\nusing this:\n  A $$ (i, n') \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. index_hma A' i' (mod_type_class.from_nat n') \\<noteq> (0::'a)", "by transfer"], ["proof (state)\nthis:\n  index_hma A' i' (mod_type_class.from_nat n') \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "hence A'i'n': \"A' $h i' $h ?n' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  index_hma A' i' (mod_type_class.from_nat n') \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h i' $h mod_type_class.from_nat n' \\<noteq> (0::'a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  A' $h i' $h mod_type_class.from_nat n' \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h i' $h mod_type_class.from_nat n' \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  A' $h i' $h mod_type_class.from_nat n' \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "have least_le_n': \"(LEAST n. A $$ (i, n) \\<noteq> 0)  \\<le> n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<le> n'", "by (simp add: Least_le n'1)"], ["proof (state)\nthis:\n  (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<le> n'\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "have l1_le_n': \"l \\<le> ?n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> mod_type_class.from_nat n'", "by (simp add: A'i'n' Least_le l_def)"], ["proof (state)\nthis:\n  l \\<le> mod_type_class.from_nat n'\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "have \"A $$ (i, ?least_n2) = index_hma A' i' l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, mod_type_class.to_nat l) = index_hma A' i' l", "by (transfer, simp)"], ["proof (state)\nthis:\n  A $$ (i, mod_type_class.to_nat l) = index_hma A' i' l\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "also"], ["proof (state)\nthis:\n  A $$ (i, mod_type_class.to_nat l) = index_hma A' i' l\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "have \"... = A' $h i' $h l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' i' l = A' $h i' $h l", "unfolding index_hma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h i' $h l = A' $h i' $h l", "by simp"], ["proof (state)\nthis:\n  index_hma A' i' l = A' $h i' $h l\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "also"], ["proof (state)\nthis:\n  index_hma A' i' l = A' $h i' $h l\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h i' $h l \\<noteq> (0::'a)", "unfolding l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h i' $h (LEAST n'. A' $h i' $h n' \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (metis (mono_tags) A'i'n' LeastI)"], ["proof (state)\nthis:\n  A' $h i' $h l \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "finally"], ["proof (chain)\npicking this:\n  A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)", "show \"A $$ (i, mod_type_class.to_nat l) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  A $$ (i, mod_type_class.to_nat l) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "assume Aiy: \"A $$ (i, y) \\<noteq> 0\""], ["proof (state)\nthis:\n  A $$ (i, y) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "let ?y' = \"Mod_Type.from_nat y::'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $$ (i, y) \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.to_nat l \\<le> y", "show \"Mod_Type.to_nat l \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l \\<le> y", "proof (cases \"y\\<le>n'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y", "case True"], ["proof (state)\nthis:\n  y \\<le> n'\n\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y", "hence y: \"y < dim_col A\""], ["proof (prove)\nusing this:\n  y \\<le> n'\n\ngoal (1 subgoal):\n 1. y < dim_col A", "using n'2"], ["proof (prove)\nusing this:\n  y \\<le> n'\n  n' < dim_col A\n\ngoal (1 subgoal):\n 1. y < dim_col A", "by auto"], ["proof (state)\nthis:\n  y < dim_col A\n\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y", "have yy'[transfer_rule]: \"Mod_Type_Connect.HMA_I y ?y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I y (mod_type_class.from_nat y)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = mod_type_class.to_nat (mod_type_class.from_nat y)", "apply (rule Mod_Type.to_nat_from_nat_id[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. y < CARD('n)", "using y Mod_Type_Connect.dim_col_transfer_rule[OF AA']"], ["proof (prove)\nusing this:\n  y < dim_col A\n  dim_col A = CARD('n)\n\ngoal (1 subgoal):\n 1. y < CARD('n)", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I y (mod_type_class.from_nat y)\n\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y", "have \"Mod_Type.to_nat l \\<le> Mod_Type.to_nat ?y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l\n    \\<le> mod_type_class.to_nat (mod_type_class.from_nat y)", "proof (rule to_nat_mono')"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<le> mod_type_class.from_nat y", "have \"index_hma A' i' ?y' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' i' (mod_type_class.from_nat y) \\<noteq> (0::'a)", "using Aiy"], ["proof (prove)\nusing this:\n  A $$ (i, y) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. index_hma A' i' (mod_type_class.from_nat y) \\<noteq> (0::'a)", "by transfer"], ["proof (state)\nthis:\n  index_hma A' i' (mod_type_class.from_nat y) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. l \\<le> mod_type_class.from_nat y", "hence \"A' $h i' $h ?y' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  index_hma A' i' (mod_type_class.from_nat y) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h i' $h mod_type_class.from_nat y \\<noteq> (0::'a)", "unfolding index_hma_def"], ["proof (prove)\nusing this:\n  A' $h i' $h mod_type_class.from_nat y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A' $h i' $h mod_type_class.from_nat y \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  A' $h i' $h mod_type_class.from_nat y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. l \\<le> mod_type_class.from_nat y", "thus \"l \\<le> ?y'\""], ["proof (prove)\nusing this:\n  A' $h i' $h mod_type_class.from_nat y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. l \\<le> mod_type_class.from_nat y", "unfolding l_def"], ["proof (prove)\nusing this:\n  A' $h i' $h mod_type_class.from_nat y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n'. A' $h i' $h n' \\<noteq> (0::'a))\n    \\<le> mod_type_class.from_nat y", "by (simp add: Least_le)"], ["proof (state)\nthis:\n  l \\<le> mod_type_class.from_nat y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.to_nat l\n  \\<le> mod_type_class.to_nat (mod_type_class.from_nat y)\n\ngoal (2 subgoals):\n 1. y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y\n 2. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y", "then"], ["proof (chain)\npicking this:\n  mod_type_class.to_nat l\n  \\<le> mod_type_class.to_nat (mod_type_class.from_nat y)", "show ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat l\n  \\<le> mod_type_class.to_nat (mod_type_class.from_nat y)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l \\<le> y", "by (metis Mod_Type_Connect.HMA_I_def yy')"], ["proof (state)\nthis:\n  mod_type_class.to_nat l \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> y \\<le> n'\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y", "hence \"n' < y\""], ["proof (prove)\nusing this:\n  \\<not> y \\<le> n'\n\ngoal (1 subgoal):\n 1. n' < y", "by auto"], ["proof (state)\nthis:\n  n' < y\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> n' \\<Longrightarrow> mod_type_class.to_nat l \\<le> y", "then"], ["proof (chain)\npicking this:\n  n' < y", "show ?thesis"], ["proof (prove)\nusing this:\n  n' < y\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat l \\<le> y", "by (metis False Mod_Type_Connect.HMA_I_def dual_order.trans l1_le_n' linear n'n' to_nat_mono')"], ["proof (state)\nthis:\n  mod_type_class.to_nat l \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.to_nat l \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n     (LEAST n. index_hma A' i' n \\<noteq> (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) = mod_type_class.to_nat l\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n     (LEAST n. index_hma A' i' n \\<noteq> (0::'a))", "unfolding Mod_Type_Connect.HMA_I_def l_def index_hma_def"], ["proof (prove)\nusing this:\n  (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n  mod_type_class.to_nat (LEAST n'. A' $h i' $h n' \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n    mod_type_class.to_nat (LEAST n. A' $h i' $h n \\<noteq> (0::'a))", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n   (LEAST n. index_hma A' i' n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma element_least_not_zero_eq_HMA_JNF:\n  fixes A':: \"'a :: comm_ring_1 ^ 'n :: mod_type ^ 'm :: mod_type\"\n  assumes AA': \"Mod_Type_Connect.HMA_M A A'\" and jj': \"Mod_Type_Connect.HMA_I j j'\"\n    and ii': \"Mod_Type_Connect.HMA_I i i'\" and zero_i': \"\\<not> is_zero_row i' A'\"\n  shows \"A $$ (j, LEAST n. A $$ (i, n) \\<noteq> 0) = A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n    A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n    A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))", "note AA'[transfer_rule] jj'[transfer_rule] ii'[transfer_rule]"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_I j j'\n  Mod_Type_Connect.HMA_I i i'\n\ngoal (1 subgoal):\n 1. A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n    A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> 0) (LEAST n. index_hma A' i' n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n     (LEAST n. index_hma A' i' n \\<noteq> (0::'a))", "by (rule HMA_LEAST[OF AA' ii'], insert zero_i', transfer, simp)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n   (LEAST n. index_hma A' i' n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n    A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))", "have \"A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> 0) = index_hma A' j' (LEAST n. index_hma A' i' n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) =\n    index_hma A' j' (LEAST n. index_hma A' i' n \\<noteq> (0::'a))", "unfolding index_hma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) =\n    A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) =\n  index_hma A' j' (LEAST n. index_hma A' i' n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n    A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))", "also"], ["proof (state)\nthis:\n  A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) =\n  index_hma A' j' (LEAST n. index_hma A' i' n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n    A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))", "have \"... = A $$ (j, LEAST n. A $$ (i, n) \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_hma A' j' (LEAST n. index_hma A' i' n \\<noteq> (0::'a)) =\n    A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))", "by (transfer', simp)"], ["proof (state)\nthis:\n  index_hma A' j' (LEAST n. index_hma A' i' n \\<noteq> (0::'a)) =\n  A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n    A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))", "finally"], ["proof (chain)\npicking this:\n  A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) =\n  A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) =\n  A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n    A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n  A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_Hermite[transfer_rule]:\n  shows \"((Mod_Type_Connect.HMA_M :: _ \\<Rightarrow> 'a :: {bezout_ring_div,normalization_semidom} ^ 'n :: mod_type ^ 'm :: mod_type \\<Rightarrow> _) ===> (=)) \n  (Hermite_JNF associates residues) (Hermite associates residues)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mod_Type_Connect.HMA_M ===> (=)) (Hermite_JNF associates residues)\n     (Hermite associates residues)", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       Hermite_JNF associates residues x = Hermite associates residues y", "case (1 A A')"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       Hermite_JNF associates residues x = Hermite associates residues y", "note AA' = \"1\"(1)[transfer_rule]"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       Hermite_JNF associates residues x = Hermite associates residues y", "have 1: \"echelon_form A' = echelon_form_JNF A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. echelon_form A' = echelon_form_JNF A", "by (transfer, simp)"], ["proof (state)\nthis:\n  echelon_form A' = echelon_form_JNF A\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       Hermite_JNF associates residues x = Hermite associates residues y", "have 2: \"(\\<forall>i<dim_row A. \\<not> is_zero_row_JNF i A \\<longrightarrow> A $$ (i, LEAST n. A $$ (i, n) \\<noteq> 0) \\<in> associates) =\n  (\\<forall>i. \\<not> is_zero_row i A' \\<longrightarrow> A' $h i $h (LEAST n. A' $h i $h n \\<noteq> 0) \\<in> associates)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<dim_row A.\n        \\<not> is_zero_row_JNF i A \\<longrightarrow>\n        A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates) =\n    (\\<forall>i.\n        \\<not> is_zero_row i A' \\<longrightarrow>\n        A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n        \\<in> associates)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n       \\<in> associates \\<Longrightarrow>\n    \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates\n 2. \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n       \\<in> associates \\<Longrightarrow>\n    \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates", "assume lhs: \"?lhs\""], ["proof (state)\nthis:\n  \\<forall>i<dim_row A.\n     \\<not> is_zero_row_JNF i A \\<longrightarrow>\n     A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates\n\ngoal (2 subgoals):\n 1. \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n       \\<in> associates \\<Longrightarrow>\n    \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates\n 2. \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n       \\<in> associates \\<Longrightarrow>\n    \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates", "show \"?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row i A' \\<Longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row i A' \\<Longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates", "assume zero_i': \"\\<not> is_zero_row i' A'\""], ["proof (state)\nthis:\n  \\<not> is_zero_row i' A'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row i A' \\<Longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates", "let ?i = \"Mod_Type.to_nat i'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row i A' \\<Longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates", "have ii'[transfer_rule]: \"Mod_Type_Connect.HMA_I ?i i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (mod_type_class.to_nat i') i'", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i' = mod_type_class.to_nat i'", "by simp"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (mod_type_class.to_nat i') i'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row i A' \\<Longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates", "have [simp]: \"?i < dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i' < dim_row A", "using Mod_Type.to_nat_less_card[of i']"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i' < CARD('m)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i' < dim_row A", "using AA' Mod_Type_Connect.dim_row_transfer_rule"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i' < CARD('m)\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i' < dim_row A", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.to_nat i' < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row i A' \\<Longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates", "have zero_i: \"\\<not> is_zero_row_JNF ?i A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_JNF (mod_type_class.to_nat i') A", "using zero_i'"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i' A'\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_JNF (mod_type_class.to_nat i') A", "by transfer"], ["proof (state)\nthis:\n  \\<not> is_zero_row_JNF (mod_type_class.to_nat i') A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row i A' \\<Longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates", "have [transfer_rule]: \"Mod_Type_Connect.HMA_I (LEAST n. A $$ (?i, n) \\<noteq> 0) (LEAST n. index_hma A' i' n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I\n     (LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n     (LEAST n. index_hma A' i' n \\<noteq> (0::'a))", "by (rule HMA_LEAST[OF AA' ii'], insert zero_i', transfer, simp)"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I\n   (LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n   (LEAST n. index_hma A' i' n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row i A' \\<Longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates", "have \"A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> 0) = A $$ (?i, LEAST n. A $$ (?i, n) \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) =\n    A $$\n    (mod_type_class.to_nat i',\n     LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))", "by (rule element_least_not_zero_eq_HMA_JNF[OF AA' ii' ii' zero_i', symmetric])"], ["proof (state)\nthis:\n  A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) =\n  A $$\n  (mod_type_class.to_nat i',\n   LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row i A' \\<Longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates", "also"], ["proof (state)\nthis:\n  A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) =\n  A $$\n  (mod_type_class.to_nat i',\n   LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row i A' \\<Longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates", "have \"... \\<in> associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$\n    (mod_type_class.to_nat i',\n     LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n    \\<in> associates", "using lhs zero_i"], ["proof (prove)\nusing this:\n  \\<forall>i<dim_row A.\n     \\<not> is_zero_row_JNF i A \\<longrightarrow>\n     A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates\n  \\<not> is_zero_row_JNF (mod_type_class.to_nat i') A\n\ngoal (1 subgoal):\n 1. A $$\n    (mod_type_class.to_nat i',\n     LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n    \\<in> associates", "by simp"], ["proof (state)\nthis:\n  A $$\n  (mod_type_class.to_nat i',\n   LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a))\n  \\<in> associates\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row i A' \\<Longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates", "finally"], ["proof (chain)\npicking this:\n  A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) \\<in> associates", "show \"A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> 0) \\<in> associates\""], ["proof (prove)\nusing this:\n  A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) \\<in> associates\n\ngoal (1 subgoal):\n 1. A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) \\<in> associates", "."], ["proof (state)\nthis:\n  A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)) \\<in> associates\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<not> is_zero_row i A' \\<longrightarrow>\n     A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n       \\<in> associates \\<Longrightarrow>\n    \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n       \\<in> associates \\<Longrightarrow>\n    \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates", "assume rhs: \"?rhs\""], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<not> is_zero_row i A' \\<longrightarrow>\n     A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n       \\<in> associates \\<Longrightarrow>\n    \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates", "show \"?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates", "proof (rule allI, rule impI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> associates", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> associates", "assume zero_i: \"\\<not> is_zero_row_JNF i A\" and i: \"i < dim_row A\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_JNF i A\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> associates", "let ?i' = \"Mod_Type.from_nat i :: 'm\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> associates", "have ii'[transfer_rule]: \"Mod_Type_Connect.HMA_I i ?i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I i (mod_type_class.from_nat i)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = mod_type_class.to_nat (mod_type_class.from_nat i)", "using Mod_Type.to_nat_from_nat_id AA' Mod_Type_Connect.dim_row_transfer_rule i"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. i = mod_type_class.to_nat (mod_type_class.from_nat i)", "by fastforce"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I i (mod_type_class.from_nat i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> associates", "have zero_i': \"\\<not> is_zero_row ?i' A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat i) A'", "using zero_i"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_JNF i A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat i) A'", "by transfer"], ["proof (state)\nthis:\n  \\<not> is_zero_row (mod_type_class.from_nat i) A'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> associates", "have \"A $$ (i, LEAST n. A $$ (i, n) \\<noteq> 0) = A' $h ?i' $h (LEAST n. A' $h ?i' $h n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n    A' $h mod_type_class.from_nat i $h\n    (LEAST n. A' $h mod_type_class.from_nat i $h n \\<noteq> (0::'a))", "by (rule element_least_not_zero_eq_HMA_JNF[OF AA' ii' ii' zero_i'])"], ["proof (state)\nthis:\n  A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n  A' $h mod_type_class.from_nat i $h\n  (LEAST n. A' $h mod_type_class.from_nat i $h n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> associates", "also"], ["proof (state)\nthis:\n  A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n  A' $h mod_type_class.from_nat i $h\n  (LEAST n. A' $h mod_type_class.from_nat i $h n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> associates", "have \"... \\<in> associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat i $h\n    (LEAST n. A' $h mod_type_class.from_nat i $h n \\<noteq> (0::'a))\n    \\<in> associates", "using rhs zero_i' i"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row i A' \\<longrightarrow>\n     A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates\n  \\<not> is_zero_row (mod_type_class.from_nat i) A'\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. A' $h mod_type_class.from_nat i $h\n    (LEAST n. A' $h mod_type_class.from_nat i $h n \\<noteq> (0::'a))\n    \\<in> associates", "by simp"], ["proof (state)\nthis:\n  A' $h mod_type_class.from_nat i $h\n  (LEAST n. A' $h mod_type_class.from_nat i $h n \\<noteq> (0::'a))\n  \\<in> associates\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> associates", "finally"], ["proof (chain)\npicking this:\n  A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates", "show \"A $$ (i, LEAST n. A $$ (i, n) \\<noteq> 0) \\<in> associates\""], ["proof (prove)\nusing this:\n  A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates\n\ngoal (1 subgoal):\n 1. A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates", "."], ["proof (state)\nthis:\n  A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<dim_row A.\n     \\<not> is_zero_row_JNF i A \\<longrightarrow>\n     A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>i<dim_row A.\n      \\<not> is_zero_row_JNF i A \\<longrightarrow>\n      A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates) =\n  (\\<forall>i.\n      \\<not> is_zero_row i A' \\<longrightarrow>\n      A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       Hermite_JNF associates residues x = Hermite associates residues y", "have 3: \"(\\<forall>i<dim_row A. \\<not> is_zero_row_JNF i A \\<longrightarrow> (\\<forall>j<i. A $$ (j, LEAST n. A $$ (i, n) \\<noteq> 0) \n            \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> 0)))) =\n            (\\<forall>i. \\<not> is_zero_row i A' \\<longrightarrow> (\\<forall>j<i. A' $h j $h (LEAST n. A' $h i $h n \\<noteq> 0)\n            \\<in> residues (A' $h i $h (LEAST n. A' $h i $h n \\<noteq> 0))))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<dim_row A.\n        \\<not> is_zero_row_JNF i A \\<longrightarrow>\n        (\\<forall>j<i.\n            A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n            \\<in> residues\n                   (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))))) =\n    (\\<forall>i.\n        \\<not> is_zero_row i A' \\<longrightarrow>\n        (\\<forall>j<i.\n            A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n            \\<in> residues\n                   (A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)))))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       (\\<forall>j<i.\n           A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n           \\<in> residues\n                  (A $$\n                   (i, LEAST n.\n                          A $$ (i, n) \\<noteq> (0::'a)))) \\<Longrightarrow>\n    \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       (\\<forall>j<i.\n           A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n           \\<in> residues\n                  (A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))))\n 2. \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       (\\<forall>j<i.\n           A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n           \\<in> residues\n                  (A' $h i $h\n                   (LEAST n.\n                       A' $h i $h n \\<noteq> (0::'a)))) \\<Longrightarrow>\n    \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       (\\<forall>j<i.\n           A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n           \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))))", "assume lhs: \"?lhs\""], ["proof (state)\nthis:\n  \\<forall>i<dim_row A.\n     \\<not> is_zero_row_JNF i A \\<longrightarrow>\n     (\\<forall>j<i.\n         A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n         \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))))\n\ngoal (2 subgoals):\n 1. \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       (\\<forall>j<i.\n           A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n           \\<in> residues\n                  (A $$\n                   (i, LEAST n.\n                          A $$ (i, n) \\<noteq> (0::'a)))) \\<Longrightarrow>\n    \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       (\\<forall>j<i.\n           A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n           \\<in> residues\n                  (A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))))\n 2. \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       (\\<forall>j<i.\n           A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n           \\<in> residues\n                  (A' $h i $h\n                   (LEAST n.\n                       A' $h i $h n \\<noteq> (0::'a)))) \\<Longrightarrow>\n    \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       (\\<forall>j<i.\n           A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n           \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))))", "show \"?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       (\\<forall>j<i.\n           A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n           \\<in> residues\n                  (A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))))", "proof (rule allI, rule impI, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i A'; j < i\\<rbrakk>\n       \\<Longrightarrow> A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A' $h i $h\n                                 (LEAST n. A' $h i $h n \\<noteq> (0::'a)))", "fix i' j' :: 'm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i A'; j < i\\<rbrakk>\n       \\<Longrightarrow> A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A' $h i $h\n                                 (LEAST n. A' $h i $h n \\<noteq> (0::'a)))", "assume zero_i': \"\\<not> is_zero_row i' A'\" and j'i': \"j' < i'\""], ["proof (state)\nthis:\n  \\<not> is_zero_row i' A'\n  j' < i'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i A'; j < i\\<rbrakk>\n       \\<Longrightarrow> A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A' $h i $h\n                                 (LEAST n. A' $h i $h n \\<noteq> (0::'a)))", "let ?i = \"Mod_Type.to_nat i'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i A'; j < i\\<rbrakk>\n       \\<Longrightarrow> A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A' $h i $h\n                                 (LEAST n. A' $h i $h n \\<noteq> (0::'a)))", "have ii'[transfer_rule]: \"Mod_Type_Connect.HMA_I ?i i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (mod_type_class.to_nat i') i'", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i' = mod_type_class.to_nat i'", "by simp"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (mod_type_class.to_nat i') i'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i A'; j < i\\<rbrakk>\n       \\<Longrightarrow> A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A' $h i $h\n                                 (LEAST n. A' $h i $h n \\<noteq> (0::'a)))", "have i: \"?i < dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i' < dim_row A", "using AA' Mod_Type_Connect.dim_row_transfer_rule mod_type_class.to_nat_less_card"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  mod_type_class.to_nat ?j < CARD(?'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i' < dim_row A", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.to_nat i' < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i A'; j < i\\<rbrakk>\n       \\<Longrightarrow> A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A' $h i $h\n                                 (LEAST n. A' $h i $h n \\<noteq> (0::'a)))", "have zero_i: \"\\<not> is_zero_row_JNF ?i A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_JNF (mod_type_class.to_nat i') A", "using zero_i'"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i' A'\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_JNF (mod_type_class.to_nat i') A", "by transfer'"], ["proof (state)\nthis:\n  \\<not> is_zero_row_JNF (mod_type_class.to_nat i') A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i A'; j < i\\<rbrakk>\n       \\<Longrightarrow> A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A' $h i $h\n                                 (LEAST n. A' $h i $h n \\<noteq> (0::'a)))", "let ?j = \"Mod_Type.to_nat j'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i A'; j < i\\<rbrakk>\n       \\<Longrightarrow> A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A' $h i $h\n                                 (LEAST n. A' $h i $h n \\<noteq> (0::'a)))", "have jj'[transfer_rule]: \"Mod_Type_Connect.HMA_I ?j j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I (mod_type_class.to_nat j') j'", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j' = mod_type_class.to_nat j'", "by simp"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I (mod_type_class.to_nat j') j'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i A'; j < i\\<rbrakk>\n       \\<Longrightarrow> A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A' $h i $h\n                                 (LEAST n. A' $h i $h n \\<noteq> (0::'a)))", "have ji: \"?j<?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j' < mod_type_class.to_nat i'", "using j'i' to_nat_mono"], ["proof (prove)\nusing this:\n  j' < i'\n  ?a < ?b \\<Longrightarrow>\n  mod_type_class.to_nat ?a < mod_type_class.to_nat ?b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j' < mod_type_class.to_nat i'", "by blast"], ["proof (state)\nthis:\n  mod_type_class.to_nat j' < mod_type_class.to_nat i'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i A'; j < i\\<rbrakk>\n       \\<Longrightarrow> A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A' $h i $h\n                                 (LEAST n. A' $h i $h n \\<noteq> (0::'a)))", "have eq1: \"A $$ (?j, LEAST n. A $$ (?i, n) \\<noteq> 0) = A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$\n    (mod_type_class.to_nat j',\n     LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a)) =\n    A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))", "by (rule element_least_not_zero_eq_HMA_JNF[OF AA' jj' ii' zero_i'])"], ["proof (state)\nthis:\n  A $$\n  (mod_type_class.to_nat j',\n   LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a)) =\n  A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i A'; j < i\\<rbrakk>\n       \\<Longrightarrow> A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A' $h i $h\n                                 (LEAST n. A' $h i $h n \\<noteq> (0::'a)))", "have eq2: \"A $$ (?i, LEAST n. A $$ (?i, n) \\<noteq> 0) = A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$\n    (mod_type_class.to_nat i',\n     LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a)) =\n    A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))", "by (rule element_least_not_zero_eq_HMA_JNF[OF AA' ii' ii' zero_i'])"], ["proof (state)\nthis:\n  A $$\n  (mod_type_class.to_nat i',\n   LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a)) =\n  A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row i A'; j < i\\<rbrakk>\n       \\<Longrightarrow> A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A' $h i $h\n                                 (LEAST n. A' $h i $h n \\<noteq> (0::'a)))", "show \"A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> 0) \\<in> residues (A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n    \\<in> residues (A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)))", "using lhs eq1 eq2 ji i zero_i"], ["proof (prove)\nusing this:\n  \\<forall>i<dim_row A.\n     \\<not> is_zero_row_JNF i A \\<longrightarrow>\n     (\\<forall>j<i.\n         A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n         \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))))\n  A $$\n  (mod_type_class.to_nat j',\n   LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a)) =\n  A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n  A $$\n  (mod_type_class.to_nat i',\n   LEAST n. A $$ (mod_type_class.to_nat i', n) \\<noteq> (0::'a)) =\n  A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n  mod_type_class.to_nat j' < mod_type_class.to_nat i'\n  mod_type_class.to_nat i' < dim_row A\n  \\<not> is_zero_row_JNF (mod_type_class.to_nat i') A\n\ngoal (1 subgoal):\n 1. A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n    \\<in> residues (A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)))", "by fastforce"], ["proof (state)\nthis:\n  A' $h j' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a))\n  \\<in> residues (A' $h i' $h (LEAST n. A' $h i' $h n \\<noteq> (0::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<not> is_zero_row i A' \\<longrightarrow>\n     (\\<forall>j<i.\n         A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n         \\<in> residues\n                (A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       (\\<forall>j<i.\n           A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n           \\<in> residues\n                  (A' $h i $h\n                   (LEAST n.\n                       A' $h i $h n \\<noteq> (0::'a)))) \\<Longrightarrow>\n    \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       (\\<forall>j<i.\n           A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n           \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       (\\<forall>j<i.\n           A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n           \\<in> residues\n                  (A' $h i $h\n                   (LEAST n.\n                       A' $h i $h n \\<noteq> (0::'a)))) \\<Longrightarrow>\n    \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       (\\<forall>j<i.\n           A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n           \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))))", "assume rhs: \"?rhs\""], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<not> is_zero_row i A' \\<longrightarrow>\n     (\\<forall>j<i.\n         A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n         \\<in> residues\n                (A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<not> is_zero_row i A' \\<longrightarrow>\n       (\\<forall>j<i.\n           A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n           \\<in> residues\n                  (A' $h i $h\n                   (LEAST n.\n                       A' $h i $h n \\<noteq> (0::'a)))) \\<Longrightarrow>\n    \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       (\\<forall>j<i.\n           A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n           \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))))", "show \"?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_row A.\n       \\<not> is_zero_row_JNF i A \\<longrightarrow>\n       (\\<forall>j<i.\n           A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n           \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))))", "proof (safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A; j < i\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A $$\n                                 (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A; j < i\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A $$\n                                 (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "assume i: \"i < dim_row A\" and zero_i: \"\\<not> is_zero_row_JNF i A\" and ji: \"j < i\""], ["proof (state)\nthis:\n  i < dim_row A\n  \\<not> is_zero_row_JNF i A\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A; j < i\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A $$\n                                 (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "let ?i' = \"Mod_Type.from_nat i :: 'm\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A; j < i\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A $$\n                                 (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "have ii'[transfer_rule]: \"Mod_Type_Connect.HMA_I i ?i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I i (mod_type_class.from_nat i)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = mod_type_class.to_nat (mod_type_class.from_nat i)", "using Mod_Type.to_nat_from_nat_id AA' Mod_Type_Connect.dim_row_transfer_rule i"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. i = mod_type_class.to_nat (mod_type_class.from_nat i)", "by fastforce"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I i (mod_type_class.from_nat i)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A; j < i\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A $$\n                                 (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "have zero_i': \"\\<not> is_zero_row ?i' A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat i) A'", "using zero_i"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_JNF i A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat i) A'", "by transfer"], ["proof (state)\nthis:\n  \\<not> is_zero_row (mod_type_class.from_nat i) A'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A; j < i\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A $$\n                                 (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "let ?j' = \"Mod_Type.from_nat j :: 'm\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A; j < i\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A $$\n                                 (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "have j'i': \"?j' < ?i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat j < mod_type_class.from_nat i", "using AA' Mod_Type_Connect.dim_row_transfer_rule from_nat_mono i ji"], ["proof (prove)\nusing this:\n  Mod_Type_Connect.HMA_M A A'\n  Mod_Type_Connect.HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n  \\<lbrakk>?i < ?j; ?j < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat ?i < mod_type_class.from_nat ?j\n  i < dim_row A\n  j < i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat j < mod_type_class.from_nat i", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.from_nat j < mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A; j < i\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A $$\n                                 (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "have jj'[transfer_rule]: \"Mod_Type_Connect.HMA_I j ?j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_I j (mod_type_class.from_nat j)", "unfolding Mod_Type_Connect.HMA_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j = mod_type_class.to_nat (mod_type_class.from_nat j)", "using Mod_Type.to_nat_from_nat_id[of j, where ?'a='m] AA' \n          Mod_Type_Connect.dim_row_transfer_rule[OF AA'] j'i' i ji"], ["proof (prove)\nusing this:\n  j < CARD('m) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat j) = j\n  Mod_Type_Connect.HMA_M A A'\n  dim_row A = CARD('m)\n  mod_type_class.from_nat j < mod_type_class.from_nat i\n  i < dim_row A\n  j < i\n\ngoal (1 subgoal):\n 1. j = mod_type_class.to_nat (mod_type_class.from_nat j)", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_I j (mod_type_class.from_nat j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A; j < i\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A $$\n                                 (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "have zero_i': \"\\<not> is_zero_row ?i' A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat i) A'", "using zero_i"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_JNF i A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row (mod_type_class.from_nat i) A'", "by transfer"], ["proof (state)\nthis:\n  \\<not> is_zero_row (mod_type_class.from_nat i) A'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A; j < i\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A $$\n                                 (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "have eq1: \"A $$ (j, LEAST n. A $$ (i, n) \\<noteq> 0) = A' $h ?j' $h (LEAST n. A' $h ?i' $h n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n    A' $h mod_type_class.from_nat j $h\n    (LEAST n. A' $h mod_type_class.from_nat i $h n \\<noteq> (0::'a))", "by (rule element_least_not_zero_eq_HMA_JNF[OF AA' jj' ii' zero_i'])"], ["proof (state)\nthis:\n  A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n  A' $h mod_type_class.from_nat j $h\n  (LEAST n. A' $h mod_type_class.from_nat i $h n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A; j < i\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A $$\n                                 (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "have eq2: \"A $$ (i, LEAST n. A $$ (i, n) \\<noteq> 0) = A' $h ?i' $h (LEAST n. A' $h ?i' $h n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n    A' $h mod_type_class.from_nat i $h\n    (LEAST n. A' $h mod_type_class.from_nat i $h n \\<noteq> (0::'a))", "by (rule element_least_not_zero_eq_HMA_JNF[OF AA' ii' ii' zero_i'])"], ["proof (state)\nthis:\n  A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n  A' $h mod_type_class.from_nat i $h\n  (LEAST n. A' $h mod_type_class.from_nat i $h n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; \\<not> is_zero_row_JNF i A; j < i\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n                         \\<in> residues\n                                (A $$\n                                 (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "show \"A $$ (j, LEAST n. A $$ (i, n) \\<noteq> 0) \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n    \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "using rhs eq1 eq2 j'i' i zero_i'"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row i A' \\<longrightarrow>\n     (\\<forall>j<i.\n         A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n         \\<in> residues\n                (A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))))\n  A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n  A' $h mod_type_class.from_nat j $h\n  (LEAST n. A' $h mod_type_class.from_nat i $h n \\<noteq> (0::'a))\n  A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) =\n  A' $h mod_type_class.from_nat i $h\n  (LEAST n. A' $h mod_type_class.from_nat i $h n \\<noteq> (0::'a))\n  mod_type_class.from_nat j < mod_type_class.from_nat i\n  i < dim_row A\n  \\<not> is_zero_row (mod_type_class.from_nat i) A'\n\ngoal (1 subgoal):\n 1. A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n    \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))", "by fastforce"], ["proof (state)\nthis:\n  A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n  \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<dim_row A.\n     \\<not> is_zero_row_JNF i A \\<longrightarrow>\n     (\\<forall>j<i.\n         A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n         \\<in> residues (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>i<dim_row A.\n      \\<not> is_zero_row_JNF i A \\<longrightarrow>\n      (\\<forall>j<i.\n          A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n          \\<in> residues\n                 (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))))) =\n  (\\<forall>i.\n      \\<not> is_zero_row i A' \\<longrightarrow>\n      (\\<forall>j<i.\n          A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n          \\<in> residues\n                 (A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       Mod_Type_Connect.HMA_M x y \\<Longrightarrow>\n       Hermite_JNF associates residues x = Hermite associates residues y", "show \"Hermite_JNF associates residues A = Hermite associates residues A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_JNF associates residues A = Hermite associates residues A'", "unfolding Hermite_def Hermite_JNF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Complete_set_non_associates associates \\<and>\n     Complete_set_residues residues \\<and>\n     echelon_form_JNF A \\<and>\n     (\\<forall>i<dim_row A.\n         \\<not> is_zero_row_JNF i A \\<longrightarrow>\n         A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n         \\<in> associates) \\<and>\n     (\\<forall>i<dim_row A.\n         \\<not> is_zero_row_JNF i A \\<longrightarrow>\n         (\\<forall>j<i.\n             A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n             \\<in> residues\n                    (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))))) =\n    (Complete_set_non_associates associates \\<and>\n     Complete_set_residues residues \\<and>\n     echelon_form A' \\<and>\n     (\\<forall>i.\n         \\<not> is_zero_row i A' \\<longrightarrow>\n         A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n         \\<in> associates) \\<and>\n     (\\<forall>i.\n         \\<not> is_zero_row i A' \\<longrightarrow>\n         (\\<forall>j<i.\n             A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n             \\<in> residues\n                    (A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))))))", "using 1 2 3"], ["proof (prove)\nusing this:\n  echelon_form A' = echelon_form_JNF A\n  (\\<forall>i<dim_row A.\n      \\<not> is_zero_row_JNF i A \\<longrightarrow>\n      A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)) \\<in> associates) =\n  (\\<forall>i.\n      \\<not> is_zero_row i A' \\<longrightarrow>\n      A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)) \\<in> associates)\n  (\\<forall>i<dim_row A.\n      \\<not> is_zero_row_JNF i A \\<longrightarrow>\n      (\\<forall>j<i.\n          A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n          \\<in> residues\n                 (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))))) =\n  (\\<forall>i.\n      \\<not> is_zero_row i A' \\<longrightarrow>\n      (\\<forall>j<i.\n          A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n          \\<in> residues\n                 (A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a)))))\n\ngoal (1 subgoal):\n 1. (Complete_set_non_associates associates \\<and>\n     Complete_set_residues residues \\<and>\n     echelon_form_JNF A \\<and>\n     (\\<forall>i<dim_row A.\n         \\<not> is_zero_row_JNF i A \\<longrightarrow>\n         A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n         \\<in> associates) \\<and>\n     (\\<forall>i<dim_row A.\n         \\<not> is_zero_row_JNF i A \\<longrightarrow>\n         (\\<forall>j<i.\n             A $$ (j, LEAST n. A $$ (i, n) \\<noteq> (0::'a))\n             \\<in> residues\n                    (A $$ (i, LEAST n. A $$ (i, n) \\<noteq> (0::'a)))))) =\n    (Complete_set_non_associates associates \\<and>\n     Complete_set_residues residues \\<and>\n     echelon_form A' \\<and>\n     (\\<forall>i.\n         \\<not> is_zero_row i A' \\<longrightarrow>\n         A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n         \\<in> associates) \\<and>\n     (\\<forall>i.\n         \\<not> is_zero_row i A' \\<longrightarrow>\n         (\\<forall>j<i.\n             A' $h j $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))\n             \\<in> residues\n                    (A' $h i $h (LEAST n. A' $h i $h n \\<noteq> (0::'a))))))", "by auto"], ["proof (state)\nthis:\n  Hermite_JNF associates residues A = Hermite associates residues A'\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary HMA_Hermite2[transfer_rule]:\n  shows \"((=) ===> (=) ===> (Mod_Type_Connect.HMA_M :: _ \n  \\<Rightarrow> 'a :: {bezout_ring_div,normalization_semidom} ^ 'n :: mod_type ^ 'm :: mod_type \\<Rightarrow> _) ===> (=)) \n  (Hermite_JNF) (Hermite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> Mod_Type_Connect.HMA_M ===> (=)) Hermite_JNF Hermite", "by (simp add: HMA_Hermite rel_funI)"], ["", "text \\<open>Once the definitions of both libraries are connected, we start to move the theorem about\nthe uniqueness of the Hermite normal form (stated in HOL Analysis, named @{text \"Hermite_unique\"})\nto JNF.\\<close>"], ["", "text \\<open>Using the previous transfer rules, we get an statement in JNF. However, the matrices\nhave @{text \"CARD('n::mod_type)\"} rows and columns. We want to get rid of that type variable and\njust state that they are of dimension $n \\times n$ (expressed via the predicate @{text \"carrier_mat\"}\\<close>"], ["", "lemma Hermite_unique_JNF':\n  fixes A::\"'a::{bezout_ring_div,normalization_euclidean_semiring,unique_euclidean_ring} mat\"\n  assumes \"A \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"P \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"H \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"Q \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"K \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n  assumes \"A = P * H\"\n    and \"A = Q * K\" and \"invertible_mat A\" and \"invertible_mat P\" \n    and \"invertible_mat Q\" and \"Hermite_JNF associates res H\" and \"Hermite_JNF associates res K\"\nshows \"H = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H = K", "define A' where \"A' = (Mod_Type_Connect.to_hma\\<^sub>m A :: 'a ^'n :: mod_type ^'n :: mod_type)\""], ["proof (state)\nthis:\n  A' = Mod_Type_Connect.to_hma\\<^sub>m A\n\ngoal (1 subgoal):\n 1. H = K", "define P' where \"P' = (Mod_Type_Connect.to_hma\\<^sub>m P :: 'a ^'n :: mod_type ^'n :: mod_type)\""], ["proof (state)\nthis:\n  P' = Mod_Type_Connect.to_hma\\<^sub>m P\n\ngoal (1 subgoal):\n 1. H = K", "define H' where \"H' = (Mod_Type_Connect.to_hma\\<^sub>m H :: 'a ^'n :: mod_type ^'n :: mod_type)\""], ["proof (state)\nthis:\n  H' = Mod_Type_Connect.to_hma\\<^sub>m H\n\ngoal (1 subgoal):\n 1. H = K", "define Q' where \"Q' = (Mod_Type_Connect.to_hma\\<^sub>m Q :: 'a ^'n :: mod_type ^'n :: mod_type)\""], ["proof (state)\nthis:\n  Q' = Mod_Type_Connect.to_hma\\<^sub>m Q\n\ngoal (1 subgoal):\n 1. H = K", "define K' where \"K' = (Mod_Type_Connect.to_hma\\<^sub>m K :: 'a ^'n :: mod_type ^'n :: mod_type)\""], ["proof (state)\nthis:\n  K' = Mod_Type_Connect.to_hma\\<^sub>m K\n\ngoal (1 subgoal):\n 1. H = K", "have AA'[transfer_rule]: \"Mod_Type_Connect.HMA_M A A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A A'", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = Mod_Type_Connect.from_hma\\<^sub>m A'", "using assms A'_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n  A' = Mod_Type_Connect.to_hma\\<^sub>m A\n\ngoal (1 subgoal):\n 1. A = Mod_Type_Connect.from_hma\\<^sub>m A'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. H = K", "have PP'[transfer_rule]: \"Mod_Type_Connect.HMA_M P P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M P P'", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Mod_Type_Connect.from_hma\\<^sub>m P'", "using assms P'_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n  P' = Mod_Type_Connect.to_hma\\<^sub>m P\n\ngoal (1 subgoal):\n 1. P = Mod_Type_Connect.from_hma\\<^sub>m P'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M P P'\n\ngoal (1 subgoal):\n 1. H = K", "have HH'[transfer_rule]: \"Mod_Type_Connect.HMA_M H H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M H H'", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. H = Mod_Type_Connect.from_hma\\<^sub>m H'", "using assms H'_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n  H' = Mod_Type_Connect.to_hma\\<^sub>m H\n\ngoal (1 subgoal):\n 1. H = Mod_Type_Connect.from_hma\\<^sub>m H'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M H H'\n\ngoal (1 subgoal):\n 1. H = K", "have QQ'[transfer_rule]: \"Mod_Type_Connect.HMA_M Q Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M Q Q'", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q = Mod_Type_Connect.from_hma\\<^sub>m Q'", "using assms Q'_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n  Q' = Mod_Type_Connect.to_hma\\<^sub>m Q\n\ngoal (1 subgoal):\n 1. Q = Mod_Type_Connect.from_hma\\<^sub>m Q'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M Q Q'\n\ngoal (1 subgoal):\n 1. H = K", "have KK'[transfer_rule]: \"Mod_Type_Connect.HMA_M K K'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M K K'", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. K = Mod_Type_Connect.from_hma\\<^sub>m K'", "using assms K'_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n  K' = Mod_Type_Connect.to_hma\\<^sub>m K\n\ngoal (1 subgoal):\n 1. K = Mod_Type_Connect.from_hma\\<^sub>m K'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M K K'\n\ngoal (1 subgoal):\n 1. H = K", "have A_PH: \"A' = P' ** H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = P' ** H'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. A' = P' ** H'", "by transfer"], ["proof (state)\nthis:\n  A' = P' ** H'\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  A' = P' ** H'\n\ngoal (1 subgoal):\n 1. H = K", "have A_QK: \"A' = Q' ** K'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = Q' ** K'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. A' = Q' ** K'", "by transfer"], ["proof (state)\nthis:\n  A' = Q' ** K'\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  A' = Q' ** K'\n\ngoal (1 subgoal):\n 1. H = K", "have inv_A: \"invertible A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible A'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. invertible A'", "by transfer"], ["proof (state)\nthis:\n  invertible A'\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  invertible A'\n\ngoal (1 subgoal):\n 1. H = K", "have inv_P: \"invertible P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible P'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. invertible P'", "by transfer"], ["proof (state)\nthis:\n  invertible P'\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  invertible P'\n\ngoal (1 subgoal):\n 1. H = K", "have inv_Q: \"invertible Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible Q'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. invertible Q'", "by transfer"], ["proof (state)\nthis:\n  invertible Q'\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  invertible Q'\n\ngoal (1 subgoal):\n 1. H = K", "have H: \"Hermite associates res H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite associates res H'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. Hermite associates res H'", "by transfer"], ["proof (state)\nthis:\n  Hermite associates res H'\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  Hermite associates res H'\n\ngoal (1 subgoal):\n 1. H = K", "have K: \"Hermite associates res K'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite associates res K'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. Hermite associates res K'", "by transfer"], ["proof (state)\nthis:\n  Hermite associates res K'\n\ngoal (1 subgoal):\n 1. H = K", "ultimately"], ["proof (chain)\npicking this:\n  A' = P' ** H'\n  A' = Q' ** K'\n  invertible A'\n  invertible P'\n  invertible Q'\n  Hermite associates res H'\n  Hermite associates res K'", "have \"H' = K'\""], ["proof (prove)\nusing this:\n  A' = P' ** H'\n  A' = Q' ** K'\n  invertible A'\n  invertible P'\n  invertible Q'\n  Hermite associates res H'\n  Hermite associates res K'\n\ngoal (1 subgoal):\n 1. H' = K'", "using Hermite_unique"], ["proof (prove)\nusing this:\n  A' = P' ** H'\n  A' = Q' ** K'\n  invertible A'\n  invertible P'\n  invertible Q'\n  Hermite associates res H'\n  Hermite associates res K'\n  \\<lbrakk>?A = ?P ** ?H; ?A = ?Q ** ?K; invertible ?A; invertible ?P;\n   invertible ?Q; Hermite ?associates ?residues ?H;\n   Hermite ?associates ?residues ?K\\<rbrakk>\n  \\<Longrightarrow> ?H = ?K\n\ngoal (1 subgoal):\n 1. H' = K'", "by blast"], ["proof (state)\nthis:\n  H' = K'\n\ngoal (1 subgoal):\n 1. H = K", "thus \"H=K\""], ["proof (prove)\nusing this:\n  H' = K'\n\ngoal (1 subgoal):\n 1. H = K", "by transfer"], ["proof (state)\nthis:\n  H = K\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Since the @{text \"mod_type\"} restriction relies on many things, the shortcut is to use \nthe @{text \"mod_ring\"} typedef developed in the Berlekamp-Zassenhaus development. \nThis type definition allows us to apply local type definitions easily.\nSince @{text \"mod_ring\"} is just an instance of @{text \"mod_type\"}, it is straightforward to\nobtain the following lemma, where @{text \"CARD('n::mod_type)\"} has now been substituted by\n@{text \"CARD('n::nontriv mod_ring)\"}\\<close>"], ["", "corollary Hermite_unique_JNF_with_nontriv_mod_ring:\n  fixes A::\"'a::{bezout_ring_div,normalization_euclidean_semiring,unique_euclidean_ring} mat\"\n  assumes \"A \\<in> carrier_mat CARD('n) CARD('n::nontriv mod_ring)\"\n    \"P \\<in> carrier_mat CARD('n) CARD('n)\"\n    \"H \\<in> carrier_mat CARD('n) CARD('n)\"\n    \"Q \\<in> carrier_mat CARD('n) CARD('n)\"\n    \"K \\<in> carrier_mat CARD('n) CARD('n)\"\n  assumes \"A = P * H\"\n    and \"A = Q * K\" and \"invertible_mat A\" and \"invertible_mat P\" \n    and \"invertible_mat Q\" and \"Hermite_JNF associates res H\" and \"Hermite_JNF associates res K\"\nshows \"H = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "using Hermite_unique_JNF' assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat CARD(?'n) CARD(?'n);\n   ?P \\<in> carrier_mat CARD(?'n) CARD(?'n);\n   ?H \\<in> carrier_mat CARD(?'n) CARD(?'n);\n   ?Q \\<in> carrier_mat CARD(?'n) CARD(?'n);\n   ?K \\<in> carrier_mat CARD(?'n) CARD(?'n); ?A = ?P * ?H; ?A = ?Q * ?K;\n   invertible_mat ?A; invertible_mat ?P; invertible_mat ?Q;\n   Hermite_JNF ?associates ?res ?H; Hermite_JNF ?associates ?res ?K\\<rbrakk>\n  \\<Longrightarrow> ?H = ?K\n  A \\<in> carrier_mat CARD('n) CARD('n mod_ring)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. H = K", "by (smt CARD_mod_ring)"], ["", "text \\<open>Now, we assume in a context that there exists a type text @{text \"'b\"} of cardinality $n$\nand we prove inside this context the lemma.\\<close>"], ["", "context\n  fixes n::nat\n  assumes local_typedef: \"\\<exists>(Rep :: ('b \\<Rightarrow> int)) Abs. type_definition Rep Abs {0..<n :: int}\"\n  and p: \"n>1\"\nbegin"], ["", "private"], ["", "lemma type_to_set:\n  shows \"class.nontriv TYPE('b)\" (is ?a) and \"n=CARD('b)\" (is ?b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b) &&& n = CARD('b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. n = CARD('b)", "from local_typedef"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<int n}", "obtain Rep::\"('b \\<Rightarrow> int)\" and Abs \n    where t: \"type_definition Rep Abs {0..<n :: int}\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<int n}\n\ngoal (1 subgoal):\n 1. (\\<And>Rep Abs.\n        type_definition Rep Abs {0..<int n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  type_definition Rep Abs {0..<int n}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. n = CARD('b)", "have \"card (UNIV :: 'b set) = card {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('b) = card {0..<n}", "using t type_definition.card"], ["proof (prove)\nusing this:\n  type_definition Rep Abs {0..<int n}\n  type_definition ?Rep ?Abs ?A \\<Longrightarrow> CARD(?'b) = card ?A\n\ngoal (1 subgoal):\n 1. CARD('b) = card {0..<n}", "by fastforce"], ["proof (state)\nthis:\n  CARD('b) = card {0..<n}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. n = CARD('b)", "also"], ["proof (state)\nthis:\n  CARD('b) = card {0..<n}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. n = CARD('b)", "have \"... = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<n} = n", "by auto"], ["proof (state)\nthis:\n  card {0..<n} = n\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. n = CARD('b)", "finally"], ["proof (chain)\npicking this:\n  CARD('b) = n", "show ?b"], ["proof (prove)\nusing this:\n  CARD('b) = n\n\ngoal (1 subgoal):\n 1. n = CARD('b)", ".."], ["proof (state)\nthis:\n  n = CARD('b)\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b)", "then"], ["proof (chain)\npicking this:\n  n = CARD('b)", "show ?a"], ["proof (prove)\nusing this:\n  n = CARD('b)\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b)", "unfolding class.nontriv_def"], ["proof (prove)\nusing this:\n  n = CARD('b)\n\ngoal (1 subgoal):\n 1. 1 < CARD('b)", "using p"], ["proof (prove)\nusing this:\n  n = CARD('b)\n  1 < n\n\ngoal (1 subgoal):\n 1. 1 < CARD('b)", "by auto"], ["proof (state)\nthis:\n  class.nontriv TYPE('b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_unique_JNF_aux:\n  fixes A::\"'a::{bezout_ring_div,normalization_euclidean_semiring,unique_euclidean_ring} mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n    \"P \\<in> carrier_mat n n\"\n    \"H \\<in> carrier_mat n n\"\n    \"Q \\<in> carrier_mat n n \"\n    \"K \\<in> carrier_mat n n\"\n  assumes \"A = P * H\"\n    and \"A = Q * K\" and \"invertible_mat A\" and \"invertible_mat P\" \n    and \"invertible_mat Q\" and \"Hermite_JNF associates res H\" and \"Hermite_JNF associates res K\"\nshows \"H = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "using Hermite_unique_JNF_with_nontriv_mod_ring[unfolded CARD_mod_ring,\n      internalize_sort \"'n::nontriv\", where ?'a='b]"], ["proof (prove)\nusing this:\n  \\<lbrakk>class.nontriv TYPE('b); ?A \\<in> carrier_mat CARD('b) CARD('b);\n   ?P \\<in> carrier_mat CARD('b) CARD('b);\n   ?H \\<in> carrier_mat CARD('b) CARD('b);\n   ?Q \\<in> carrier_mat CARD('b) CARD('b);\n   ?K \\<in> carrier_mat CARD('b) CARD('b); ?A = ?P * ?H; ?A = ?Q * ?K;\n   invertible_mat ?A; invertible_mat ?P; invertible_mat ?Q;\n   Hermite_JNF ?associates ?res ?H; Hermite_JNF ?associates ?res ?K\\<rbrakk>\n  \\<Longrightarrow> ?H = ?K\n\ngoal (1 subgoal):\n 1. H = K", "unfolding type_to_set(2)[symmetric]"], ["proof (prove)\nusing this:\n  \\<lbrakk>class.nontriv TYPE('b); ?A \\<in> carrier_mat n n;\n   ?P \\<in> carrier_mat n n; ?H \\<in> carrier_mat n n;\n   ?Q \\<in> carrier_mat n n; ?K \\<in> carrier_mat n n; ?A = ?P * ?H;\n   ?A = ?Q * ?K; invertible_mat ?A; invertible_mat ?P; invertible_mat ?Q;\n   Hermite_JNF ?associates ?res ?H; Hermite_JNF ?associates ?res ?K\\<rbrakk>\n  \\<Longrightarrow> ?H = ?K\n\ngoal (1 subgoal):\n 1. H = K", "using type_to_set(1) assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>class.nontriv TYPE('b); ?A \\<in> carrier_mat n n;\n   ?P \\<in> carrier_mat n n; ?H \\<in> carrier_mat n n;\n   ?Q \\<in> carrier_mat n n; ?K \\<in> carrier_mat n n; ?A = ?P * ?H;\n   ?A = ?Q * ?K; invertible_mat ?A; invertible_mat ?P; invertible_mat ?Q;\n   Hermite_JNF ?associates ?res ?H; Hermite_JNF ?associates ?res ?K\\<rbrakk>\n  \\<Longrightarrow> ?H = ?K\n  class.nontriv TYPE('b)\n  A \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  H \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  K \\<in> carrier_mat n n\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. H = K", "by blast"], ["", "end"], ["", "text \\<open>Now, we cancel the local type definition of the previous context. \nSince the @{text \"mod_type\"} restriction imposes the type to have cardinality greater than 1, \nthe cases $n=0$ and $n=1$ must be proved separately (they are trivial)\\<close>"], ["", "lemma Hermite_unique_JNF:\n  fixes A::\"'a::{bezout_ring_div,normalization_euclidean_semiring,unique_euclidean_ring} mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and P: \"P \\<in> carrier_mat n n\" and H: \"H \\<in> carrier_mat n n\"\n   and Q: \"Q \\<in> carrier_mat n n\" and K: \"K \\<in> carrier_mat n n\"\n assumes A_PH: \"A = P * H\" and A_QK: \"A = Q * K\"\n   and inv_A: \"invertible_mat A\" and inv_P: \"invertible_mat P\" and inv_Q: \"invertible_mat Q\"\n   and HNF_H: \"Hermite_JNF associates res H\" and HNF_K: \"Hermite_JNF associates res K\"\n  shows \"H = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "proof (cases \"n=0 \\<or> n=1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<or> n = 1 \\<Longrightarrow> H = K\n 2. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "case True"], ["proof (state)\nthis:\n  n = 0 \\<or> n = 1\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> n = 1 \\<Longrightarrow> H = K\n 2. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "note zero_or_one = True"], ["proof (state)\nthis:\n  n = 0 \\<or> n = 1\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> n = 1 \\<Longrightarrow> H = K\n 2. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "proof (cases \"n=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> H = K\n 2. n \\<noteq> 0 \\<Longrightarrow> H = K", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> H = K\n 2. n \\<noteq> 0 \\<Longrightarrow> H = K", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. H = K", "using assms"], ["proof (prove)\nusing this:\n  n = 0\n  A \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  H \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  K \\<in> carrier_mat n n\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. H = K", "by auto"], ["proof (state)\nthis:\n  H = K\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have CS_A: \"Complete_set_non_associates associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_set_non_associates associates", "using HNF_H"], ["proof (prove)\nusing this:\n  Hermite_JNF associates res H\n\ngoal (1 subgoal):\n 1. Complete_set_non_associates associates", "unfolding Hermite_JNF_def"], ["proof (prove)\nusing this:\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues res \\<and>\n  echelon_form_JNF H \\<and>\n  (\\<forall>i<dim_row H.\n      \\<not> is_zero_row_JNF i H \\<longrightarrow>\n      H $$ (i, LEAST n. H $$ (i, n) \\<noteq> (0::'a))\n      \\<in> associates) \\<and>\n  (\\<forall>i<dim_row H.\n      \\<not> is_zero_row_JNF i H \\<longrightarrow>\n      (\\<forall>j<i.\n          H $$ (j, LEAST n. H $$ (i, n) \\<noteq> (0::'a))\n          \\<in> res (H $$ (i, LEAST n. H $$ (i, n) \\<noteq> (0::'a)))))\n\ngoal (1 subgoal):\n 1. Complete_set_non_associates associates", "by simp"], ["proof (state)\nthis:\n  Complete_set_non_associates associates\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have H: \"H \\<in> carrier_mat 1 1\" and K: \"K\\<in> carrier_mat 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<in> carrier_mat 1 1 &&& K \\<in> carrier_mat 1 1", "using False zero_or_one assms"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  n = 0 \\<or> n = 1\n  A \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  H \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  K \\<in> carrier_mat n n\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. H \\<in> carrier_mat 1 1 &&& K \\<in> carrier_mat 1 1", "by auto"], ["proof (state)\nthis:\n  H \\<in> carrier_mat 1 1\n  K \\<in> carrier_mat 1 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have det_P_dvd_1: \"Determinant.det P dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (Determinant.det P)", "using invertible_iff_is_unit_JNF inv_P P"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat ?A = (Determinant.det ?A dvd (1::?'a))\n  invertible_mat P\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. is_unit (Determinant.det P)", "by blast"], ["proof (state)\nthis:\n  is_unit (Determinant.det P)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have det_Q_dvd_1: \"Determinant.det Q dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (Determinant.det Q)", "using invertible_iff_is_unit_JNF inv_Q Q"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat ?A = (Determinant.det ?A dvd (1::?'a))\n  invertible_mat Q\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. is_unit (Determinant.det Q)", "by blast"], ["proof (state)\nthis:\n  is_unit (Determinant.det Q)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have PH_QK: \"Determinant.det P * Determinant.det H = Determinant.det Q * Determinant.det K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det P * Determinant.det H =\n    Determinant.det Q * Determinant.det K", "using Determinant.det_mult assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> Determinant.det (?A * ?B) =\n                    Determinant.det ?A * Determinant.det ?B\n  A \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  H \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  K \\<in> carrier_mat n n\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. Determinant.det P * Determinant.det H =\n    Determinant.det Q * Determinant.det K", "by metis"], ["proof (state)\nthis:\n  Determinant.det P * Determinant.det H =\n  Determinant.det Q * Determinant.det K\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "hence \"Determinant.det P * H $$ (0,0) = Determinant.det Q * K $$ (0,0)\""], ["proof (prove)\nusing this:\n  Determinant.det P * Determinant.det H =\n  Determinant.det Q * Determinant.det K\n\ngoal (1 subgoal):\n 1. Determinant.det P * H $$ (0, 0) = Determinant.det Q * K $$ (0, 0)", "by (metis H K determinant_one_element)"], ["proof (state)\nthis:\n  Determinant.det P * H $$ (0, 0) = Determinant.det Q * K $$ (0, 0)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "obtain u where uH_K: \"u * H $$(0,0) = K $$ (0,0)\" and unit_u: \"is_unit u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u * H $$ (0, 0) = K $$ (0, 0); is_unit u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, hide_lams) H K PH_QK algebraic_semidom_class.dvd_mult_unit_iff det_P_dvd_1 \n          det_Q_dvd_1 det_singleton dvdE dvd_mult_cancel_left mult.commute mult.right_neutral one_dvd)"], ["proof (state)\nthis:\n  u * H $$ (0, 0) = K $$ (0, 0)\n  is_unit u\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have H00_not_0: \"H $$ (0,0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<noteq> (0::'a)", "by (metis A A_PH Determinant.det_mult False H P determinant_one_element inv_A\n          invertible_iff_is_unit_JNF mult_not_zero not_is_unit_0 zero_or_one)"], ["proof (state)\nthis:\n  H $$ (0, 0) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "hence LEAST_H: \"(LEAST n. H $$ (0,n) \\<noteq> 0) = 0\""], ["proof (prove)\nusing this:\n  H $$ (0, 0) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. H $$ (0, n) \\<noteq> (0::'a)) = 0", "by simp"], ["proof (state)\nthis:\n  (LEAST n. H $$ (0, n) \\<noteq> (0::'a)) = 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have H00: \"H $$ (0,0) \\<in> associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<in> associates", "using HNF_H LEAST_H H H00_not_0"], ["proof (prove)\nusing this:\n  Hermite_JNF associates res H\n  (LEAST n. H $$ (0, n) \\<noteq> (0::'a)) = 0\n  H \\<in> carrier_mat 1 1\n  H $$ (0, 0) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<in> associates", "unfolding Hermite_JNF_def is_zero_row_JNF_def"], ["proof (prove)\nusing this:\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues res \\<and>\n  echelon_form_JNF H \\<and>\n  (\\<forall>i<dim_row H.\n      \\<not> (\\<forall>j<dim_col H. H $$ (i, j) = (0::'a)) \\<longrightarrow>\n      H $$ (i, LEAST n. H $$ (i, n) \\<noteq> (0::'a))\n      \\<in> associates) \\<and>\n  (\\<forall>i<dim_row H.\n      \\<not> (\\<forall>j<dim_col H. H $$ (i, j) = (0::'a)) \\<longrightarrow>\n      (\\<forall>j<i.\n          H $$ (j, LEAST n. H $$ (i, n) \\<noteq> (0::'a))\n          \\<in> res (H $$ (i, LEAST n. H $$ (i, n) \\<noteq> (0::'a)))))\n  (LEAST n. H $$ (0, n) \\<noteq> (0::'a)) = 0\n  H \\<in> carrier_mat 1 1\n  H $$ (0, 0) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<in> associates", "by auto"], ["proof (state)\nthis:\n  H $$ (0, 0) \\<in> associates\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have K00_not_0: \"K $$ (0,0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<noteq> (0::'a)", "by (metis A A_QK Determinant.det_mult False K Q determinant_one_element inv_A\n          invertible_iff_is_unit_JNF mult_not_zero not_is_unit_0 zero_or_one)"], ["proof (state)\nthis:\n  K $$ (0, 0) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "hence LEAST_K: \"(LEAST n. K $$ (0,n) \\<noteq> 0) = 0\""], ["proof (prove)\nusing this:\n  K $$ (0, 0) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST n. K $$ (0, n) \\<noteq> (0::'a)) = 0", "by simp"], ["proof (state)\nthis:\n  (LEAST n. K $$ (0, n) \\<noteq> (0::'a)) = 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have K00: \"K $$ (0,0) \\<in> associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<in> associates", "using HNF_K LEAST_K K K00_not_0"], ["proof (prove)\nusing this:\n  Hermite_JNF associates res K\n  (LEAST n. K $$ (0, n) \\<noteq> (0::'a)) = 0\n  K \\<in> carrier_mat 1 1\n  K $$ (0, 0) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<in> associates", "unfolding Hermite_JNF_def is_zero_row_JNF_def"], ["proof (prove)\nusing this:\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues res \\<and>\n  echelon_form_JNF K \\<and>\n  (\\<forall>i<dim_row K.\n      \\<not> (\\<forall>j<dim_col K. K $$ (i, j) = (0::'a)) \\<longrightarrow>\n      K $$ (i, LEAST n. K $$ (i, n) \\<noteq> (0::'a))\n      \\<in> associates) \\<and>\n  (\\<forall>i<dim_row K.\n      \\<not> (\\<forall>j<dim_col K. K $$ (i, j) = (0::'a)) \\<longrightarrow>\n      (\\<forall>j<i.\n          K $$ (j, LEAST n. K $$ (i, n) \\<noteq> (0::'a))\n          \\<in> res (K $$ (i, LEAST n. K $$ (i, n) \\<noteq> (0::'a)))))\n  (LEAST n. K $$ (0, n) \\<noteq> (0::'a)) = 0\n  K \\<in> carrier_mat 1 1\n  K $$ (0, 0) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<in> associates", "by auto"], ["proof (state)\nthis:\n  K $$ (0, 0) \\<in> associates\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have ass_H00_K00: \"normalize (H $$ (0,0)) = normalize (K $$ (0,0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (H $$ (0, 0)) = normalize (K $$ (0, 0))", "by (metis normalize_mult_unit_left uH_K unit_u)"], ["proof (state)\nthis:\n  normalize (H $$ (0, 0)) = normalize (K $$ (0, 0))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have H00_eq_K00: \"H $$ (0,0) = K $$ (0,0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $$ (0, 0) = K $$ (0, 0)", "using in_Ass_not_associated[OF CS_A H00 K00] ass_H00_K00"], ["proof (prove)\nusing this:\n  H $$ (0, 0) \\<noteq> K $$ (0, 0) \\<Longrightarrow>\n  normalize (H $$ (0, 0)) \\<noteq> normalize (K $$ (0, 0))\n  normalize (H $$ (0, 0)) = normalize (K $$ (0, 0))\n\ngoal (1 subgoal):\n 1. H $$ (0, 0) = K $$ (0, 0)", "by auto"], ["proof (state)\nthis:\n  H $$ (0, 0) = K $$ (0, 0)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "by (rule eq_matI, insert H K H00_eq_K00, auto)"], ["proof (state)\nthis:\n  H = K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H = K\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "case False"], ["proof (state)\nthis:\n  \\<not> (n = 0 \\<or> n = 1)\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "hence \"{0..<int n} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> (n = 0 \\<or> n = 1)\n\ngoal (1 subgoal):\n 1. {0..<int n} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {0..<int n} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "moreover"], ["proof (state)\nthis:\n  {0..<int n} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "have \"n>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n", "using False"], ["proof (prove)\nusing this:\n  \\<not> (n = 0 \\<or> n = 1)\n\ngoal (1 subgoal):\n 1. 1 < n", "by simp"], ["proof (state)\nthis:\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "ultimately"], ["proof (chain)\npicking this:\n  {0..<int n} \\<noteq> {}\n  1 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  {0..<int n} \\<noteq> {}\n  1 < n\n\ngoal (1 subgoal):\n 1. H = K", "using Hermite_unique_JNF_aux[cancel_type_definition] assms"], ["proof (prove)\nusing this:\n  {0..<int n} \\<noteq> {}\n  1 < n\n  \\<lbrakk>{0..<int ?n} \\<noteq> {}; 1 < ?n; ?A \\<in> carrier_mat ?n ?n;\n   ?P \\<in> carrier_mat ?n ?n; ?H \\<in> carrier_mat ?n ?n;\n   ?Q \\<in> carrier_mat ?n ?n; ?K \\<in> carrier_mat ?n ?n; ?A = ?P * ?H;\n   ?A = ?Q * ?K; invertible_mat ?A; invertible_mat ?P; invertible_mat ?Q;\n   Hermite_JNF ?associates ?res ?H; Hermite_JNF ?associates ?res ?K\\<rbrakk>\n  \\<Longrightarrow> ?H = ?K\n  A \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  H \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  K \\<in> carrier_mat n n\n  A = P * H\n  A = Q * K\n  invertible_mat A\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. H = K", "by metis"], ["proof (state)\nthis:\n  H = K\n\ngoal:\nNo subgoals!", "(*Cancel local type definition*)"], ["proof (state)\nthis:\n  H = K\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>From here on, we apply the same approach to move the new generalized statement about\nthe uniqueness Hermite normal form, i.e., the version restricted to integer matrices, but imposing\ninvertibility over the rationals.\\<close>"], ["", "(*TODO: move to Mod_Type_Connect in SNF development. \n  There are two definitions of map_matrix, one in HMA_Connect and one in Finite_Cartesian_Product, \n  but they are the same.*)"], ["", "lemma HMA_map_matrix [transfer_rule]: \n  \"((=) ===> Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M) map_mat map_matrix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> Mod_Type_Connect.HMA_M ===> Mod_Type_Connect.HMA_M) map_mat\n     HMA_Connect.map_matrix", "unfolding map_vector_def map_matrix_def[abs_def] map_mat_def[abs_def] \n    Mod_Type_Connect.HMA_M_def Mod_Type_Connect.from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     (\\<lambda>a b.\n         a =\n         Matrix.mat CARD('d) CARD('c)\n          (\\<lambda>(i, j).\n              b $h mod_type_class.from_nat i $h\n              mod_type_class.from_nat j)) ===>\n     (\\<lambda>a b.\n         a =\n         Matrix.mat CARD('d) CARD('c)\n          (\\<lambda>(i, j).\n              b $h mod_type_class.from_nat i $h mod_type_class.from_nat j)))\n     (\\<lambda>f A.\n         Matrix.mat (dim_row A) (dim_col A) (\\<lambda>ij. f (A $$ ij)))\n     (\\<lambda>f A. \\<chi>i ia. f (A $h i $h ia))", "by auto"], ["", "lemma Hermite_unique_generalized_JNF':\n  fixes A::\"int mat\"\n  assumes \"A \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"P \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"H \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"Q \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n    \"K \\<in> carrier_mat CARD('n::mod_type) CARD('n::mod_type)\"\n  assumes \"A = P * H\"\n    and \"A = Q * K\" and \"invertible_mat (map_mat rat_of_int A)\" and \"invertible_mat P\" \n    and \"invertible_mat Q\" and \"Hermite_JNF associates res H\" and \"Hermite_JNF associates res K\"\nshows \"H = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H = K", "define A' where \"A' = (Mod_Type_Connect.to_hma\\<^sub>m A :: int ^'n :: mod_type ^'n :: mod_type)\""], ["proof (state)\nthis:\n  A' = Mod_Type_Connect.to_hma\\<^sub>m A\n\ngoal (1 subgoal):\n 1. H = K", "define P' where \"P' = (Mod_Type_Connect.to_hma\\<^sub>m P :: int ^'n :: mod_type ^'n :: mod_type)\""], ["proof (state)\nthis:\n  P' = Mod_Type_Connect.to_hma\\<^sub>m P\n\ngoal (1 subgoal):\n 1. H = K", "define H' where \"H' = (Mod_Type_Connect.to_hma\\<^sub>m H :: int ^'n :: mod_type ^'n :: mod_type)\""], ["proof (state)\nthis:\n  H' = Mod_Type_Connect.to_hma\\<^sub>m H\n\ngoal (1 subgoal):\n 1. H = K", "define Q' where \"Q' = (Mod_Type_Connect.to_hma\\<^sub>m Q :: int ^'n :: mod_type ^'n :: mod_type)\""], ["proof (state)\nthis:\n  Q' = Mod_Type_Connect.to_hma\\<^sub>m Q\n\ngoal (1 subgoal):\n 1. H = K", "define K' where \"K' = (Mod_Type_Connect.to_hma\\<^sub>m K :: int ^'n :: mod_type ^'n :: mod_type)\""], ["proof (state)\nthis:\n  K' = Mod_Type_Connect.to_hma\\<^sub>m K\n\ngoal (1 subgoal):\n 1. H = K", "have AA'[transfer_rule]: \"Mod_Type_Connect.HMA_M A A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A A'", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = Mod_Type_Connect.from_hma\\<^sub>m A'", "using assms A'_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n  A' = Mod_Type_Connect.to_hma\\<^sub>m A\n\ngoal (1 subgoal):\n 1. A = Mod_Type_Connect.from_hma\\<^sub>m A'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A A'\n\ngoal (1 subgoal):\n 1. H = K", "have PP'[transfer_rule]: \"Mod_Type_Connect.HMA_M P P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M P P'", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Mod_Type_Connect.from_hma\\<^sub>m P'", "using assms P'_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n  P' = Mod_Type_Connect.to_hma\\<^sub>m P\n\ngoal (1 subgoal):\n 1. P = Mod_Type_Connect.from_hma\\<^sub>m P'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M P P'\n\ngoal (1 subgoal):\n 1. H = K", "have HH'[transfer_rule]: \"Mod_Type_Connect.HMA_M H H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M H H'", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. H = Mod_Type_Connect.from_hma\\<^sub>m H'", "using assms H'_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n  H' = Mod_Type_Connect.to_hma\\<^sub>m H\n\ngoal (1 subgoal):\n 1. H = Mod_Type_Connect.from_hma\\<^sub>m H'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M H H'\n\ngoal (1 subgoal):\n 1. H = K", "have QQ'[transfer_rule]: \"Mod_Type_Connect.HMA_M Q Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M Q Q'", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q = Mod_Type_Connect.from_hma\\<^sub>m Q'", "using assms Q'_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n  Q' = Mod_Type_Connect.to_hma\\<^sub>m Q\n\ngoal (1 subgoal):\n 1. Q = Mod_Type_Connect.from_hma\\<^sub>m Q'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M Q Q'\n\ngoal (1 subgoal):\n 1. H = K", "have KK'[transfer_rule]: \"Mod_Type_Connect.HMA_M K K'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M K K'", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. K = Mod_Type_Connect.from_hma\\<^sub>m K'", "using assms K'_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n  K' = Mod_Type_Connect.to_hma\\<^sub>m K\n\ngoal (1 subgoal):\n 1. K = Mod_Type_Connect.from_hma\\<^sub>m K'", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M K K'\n\ngoal (1 subgoal):\n 1. H = K", "have A_PH: \"A' = P' ** H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = P' ** H'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. A' = P' ** H'", "by transfer"], ["proof (state)\nthis:\n  A' = P' ** H'\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  A' = P' ** H'\n\ngoal (1 subgoal):\n 1. H = K", "have A_QK: \"A' = Q' ** K'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' = Q' ** K'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. A' = Q' ** K'", "by transfer"], ["proof (state)\nthis:\n  A' = Q' ** K'\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  A' = Q' ** K'\n\ngoal (1 subgoal):\n 1. H = K", "have inv_A: \"invertible (map_matrix rat_of_int A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (HMA_Connect.map_matrix rat_of_int A')", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. invertible (HMA_Connect.map_matrix rat_of_int A')", "by transfer"], ["proof (state)\nthis:\n  invertible (HMA_Connect.map_matrix rat_of_int A')\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  invertible (HMA_Connect.map_matrix rat_of_int A')\n\ngoal (1 subgoal):\n 1. H = K", "have \"invertible (Finite_Cartesian_Product.map_matrix rat_of_int A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.map_matrix rat_of_int A')", "using inv_A"], ["proof (prove)\nusing this:\n  invertible (HMA_Connect.map_matrix rat_of_int A')\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.map_matrix rat_of_int A')", "unfolding Finite_Cartesian_Product.map_matrix_def map_matrix_def map_vector_def"], ["proof (prove)\nusing this:\n  invertible (\\<chi>i ia. rat_of_int (A' $h i $h ia))\n\ngoal (1 subgoal):\n 1. invertible (\\<chi>i j. rat_of_int (A' $h i $h j))", "by simp"], ["proof (state)\nthis:\n  invertible (Finite_Cartesian_Product.map_matrix rat_of_int A')\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  invertible (Finite_Cartesian_Product.map_matrix rat_of_int A')\n\ngoal (1 subgoal):\n 1. H = K", "have inv_P: \"invertible P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible P'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. invertible P'", "by transfer"], ["proof (state)\nthis:\n  invertible P'\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  invertible P'\n\ngoal (1 subgoal):\n 1. H = K", "have inv_Q: \"invertible Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible Q'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. invertible Q'", "by transfer"], ["proof (state)\nthis:\n  invertible Q'\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  invertible Q'\n\ngoal (1 subgoal):\n 1. H = K", "have H: \"Hermite associates res H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite associates res H'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. Hermite associates res H'", "by transfer"], ["proof (state)\nthis:\n  Hermite associates res H'\n\ngoal (1 subgoal):\n 1. H = K", "moreover"], ["proof (state)\nthis:\n  Hermite associates res H'\n\ngoal (1 subgoal):\n 1. H = K", "have K: \"Hermite associates res K'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite associates res K'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat CARD('n) CARD('n)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. Hermite associates res K'", "by transfer"], ["proof (state)\nthis:\n  Hermite associates res K'\n\ngoal (1 subgoal):\n 1. H = K", "ultimately"], ["proof (chain)\npicking this:\n  A' = P' ** H'\n  A' = Q' ** K'\n  invertible (HMA_Connect.map_matrix rat_of_int A')\n  invertible (Finite_Cartesian_Product.map_matrix rat_of_int A')\n  invertible P'\n  invertible Q'\n  Hermite associates res H'\n  Hermite associates res K'", "have \"H' = K'\""], ["proof (prove)\nusing this:\n  A' = P' ** H'\n  A' = Q' ** K'\n  invertible (HMA_Connect.map_matrix rat_of_int A')\n  invertible (Finite_Cartesian_Product.map_matrix rat_of_int A')\n  invertible P'\n  invertible Q'\n  Hermite associates res H'\n  Hermite associates res K'\n\ngoal (1 subgoal):\n 1. H' = K'", "using Hermite_unique_generalized"], ["proof (prove)\nusing this:\n  A' = P' ** H'\n  A' = Q' ** K'\n  invertible (HMA_Connect.map_matrix rat_of_int A')\n  invertible (Finite_Cartesian_Product.map_matrix rat_of_int A')\n  invertible P'\n  invertible Q'\n  Hermite associates res H'\n  Hermite associates res K'\n  \\<lbrakk>?A = ?P ** ?H; ?A = ?Q ** ?K;\n   invertible (Finite_Cartesian_Product.map_matrix rat_of_int ?A);\n   invertible ?P; invertible ?Q; Hermite ?associates ?residues ?H;\n   Hermite ?associates ?residues ?K\\<rbrakk>\n  \\<Longrightarrow> ?H = ?K\n\ngoal (1 subgoal):\n 1. H' = K'", "by blast"], ["proof (state)\nthis:\n  H' = K'\n\ngoal (1 subgoal):\n 1. H = K", "thus \"H=K\""], ["proof (prove)\nusing this:\n  H' = K'\n\ngoal (1 subgoal):\n 1. H = K", "by transfer"], ["proof (state)\nthis:\n  H = K\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Hermite_unique_generalized_JNF_with_nontriv_mod_ring:\n  fixes A::\"int mat\"\n  assumes \"A \\<in> carrier_mat CARD('n) CARD('n::nontriv mod_ring)\"\n    \"P \\<in> carrier_mat CARD('n) CARD('n)\"\n    \"H \\<in> carrier_mat CARD('n) CARD('n)\"\n    \"Q \\<in> carrier_mat CARD('n) CARD('n)\"\n    \"K \\<in> carrier_mat CARD('n) CARD('n)\"\n  assumes \"A = P * H\"\n    and \"A = Q * K\" and \"invertible_mat (map_mat rat_of_int A)\" and \"invertible_mat P\" \n    and \"invertible_mat Q\" and \"Hermite_JNF associates res H\" and \"Hermite_JNF associates res K\"\nshows \"H = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "using Hermite_unique_generalized_JNF' assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat CARD(?'n) CARD(?'n);\n   ?P \\<in> carrier_mat CARD(?'n) CARD(?'n);\n   ?H \\<in> carrier_mat CARD(?'n) CARD(?'n);\n   ?Q \\<in> carrier_mat CARD(?'n) CARD(?'n);\n   ?K \\<in> carrier_mat CARD(?'n) CARD(?'n); ?A = ?P * ?H; ?A = ?Q * ?K;\n   invertible_mat (of_int_hom.mat_hom ?A); invertible_mat ?P;\n   invertible_mat ?Q; Hermite_JNF ?associates ?res ?H;\n   Hermite_JNF ?associates ?res ?K\\<rbrakk>\n  \\<Longrightarrow> ?H = ?K\n  A \\<in> carrier_mat CARD('n) CARD('n mod_ring)\n  P \\<in> carrier_mat CARD('n) CARD('n)\n  H \\<in> carrier_mat CARD('n) CARD('n)\n  Q \\<in> carrier_mat CARD('n) CARD('n)\n  K \\<in> carrier_mat CARD('n) CARD('n)\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. H = K", "by (smt CARD_mod_ring)"], ["", "context\n  fixes p::nat\n  assumes local_typedef: \"\\<exists>(Rep :: ('b \\<Rightarrow> int)) Abs. type_definition Rep Abs {0..<p :: int}\"\n  and p: \"p>1\"\nbegin"], ["", "private"], ["", "lemma type_to_set2:\n  shows \"class.nontriv TYPE('b)\" (is ?a) and \"p=CARD('b)\" (is ?b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b) &&& p = CARD('b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. p = CARD('b)", "from local_typedef"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<int p}", "obtain Rep::\"('b \\<Rightarrow> int)\" and Abs \n    where t: \"type_definition Rep Abs {0..<p :: int}\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs {0..<int p}\n\ngoal (1 subgoal):\n 1. (\\<And>Rep Abs.\n        type_definition Rep Abs {0..<int p} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  type_definition Rep Abs {0..<int p}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. p = CARD('b)", "have \"card (UNIV :: 'b set) = card {0..<p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('b) = card {0..<p}", "using t type_definition.card"], ["proof (prove)\nusing this:\n  type_definition Rep Abs {0..<int p}\n  type_definition ?Rep ?Abs ?A \\<Longrightarrow> CARD(?'b) = card ?A\n\ngoal (1 subgoal):\n 1. CARD('b) = card {0..<p}", "by fastforce"], ["proof (state)\nthis:\n  CARD('b) = card {0..<p}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. p = CARD('b)", "also"], ["proof (state)\nthis:\n  CARD('b) = card {0..<p}\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. p = CARD('b)", "have \"... = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<p} = p", "by auto"], ["proof (state)\nthis:\n  card {0..<p} = p\n\ngoal (2 subgoals):\n 1. class.nontriv TYPE('b)\n 2. p = CARD('b)", "finally"], ["proof (chain)\npicking this:\n  CARD('b) = p", "show ?b"], ["proof (prove)\nusing this:\n  CARD('b) = p\n\ngoal (1 subgoal):\n 1. p = CARD('b)", ".."], ["proof (state)\nthis:\n  p = CARD('b)\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b)", "then"], ["proof (chain)\npicking this:\n  p = CARD('b)", "show ?a"], ["proof (prove)\nusing this:\n  p = CARD('b)\n\ngoal (1 subgoal):\n 1. class.nontriv TYPE('b)", "unfolding class.nontriv_def"], ["proof (prove)\nusing this:\n  p = CARD('b)\n\ngoal (1 subgoal):\n 1. 1 < CARD('b)", "using p"], ["proof (prove)\nusing this:\n  p = CARD('b)\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < CARD('b)", "by auto"], ["proof (state)\nthis:\n  class.nontriv TYPE('b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_unique_generalized_JNF_aux:\n  fixes A::\"int mat\"\n  assumes \"A \\<in> carrier_mat p p\"\n    \"P \\<in> carrier_mat p p\"\n    \"H \\<in> carrier_mat p p\"\n    \"Q \\<in> carrier_mat p p\"\n    \"K \\<in> carrier_mat p p\"\n  assumes \"A = P * H\"\n    and \"A = Q * K\" and \"invertible_mat (map_mat rat_of_int A)\" and \"invertible_mat P\" \n    and \"invertible_mat Q\" and \"Hermite_JNF associates res H\" and \"Hermite_JNF associates res K\"\nshows \"H = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "using Hermite_unique_generalized_JNF_with_nontriv_mod_ring[unfolded CARD_mod_ring,\n      internalize_sort \"'n::nontriv\", where ?'a='b]"], ["proof (prove)\nusing this:\n  \\<lbrakk>class.nontriv TYPE('b); ?A \\<in> carrier_mat CARD('b) CARD('b);\n   ?P \\<in> carrier_mat CARD('b) CARD('b);\n   ?H \\<in> carrier_mat CARD('b) CARD('b);\n   ?Q \\<in> carrier_mat CARD('b) CARD('b);\n   ?K \\<in> carrier_mat CARD('b) CARD('b); ?A = ?P * ?H; ?A = ?Q * ?K;\n   invertible_mat (of_int_hom.mat_hom ?A); invertible_mat ?P;\n   invertible_mat ?Q; Hermite_JNF ?associates ?res ?H;\n   Hermite_JNF ?associates ?res ?K\\<rbrakk>\n  \\<Longrightarrow> ?H = ?K\n\ngoal (1 subgoal):\n 1. H = K", "unfolding type_to_set2(2)[symmetric]"], ["proof (prove)\nusing this:\n  \\<lbrakk>class.nontriv TYPE('b); ?A \\<in> carrier_mat p p;\n   ?P \\<in> carrier_mat p p; ?H \\<in> carrier_mat p p;\n   ?Q \\<in> carrier_mat p p; ?K \\<in> carrier_mat p p; ?A = ?P * ?H;\n   ?A = ?Q * ?K; invertible_mat (of_int_hom.mat_hom ?A); invertible_mat ?P;\n   invertible_mat ?Q; Hermite_JNF ?associates ?res ?H;\n   Hermite_JNF ?associates ?res ?K\\<rbrakk>\n  \\<Longrightarrow> ?H = ?K\n\ngoal (1 subgoal):\n 1. H = K", "using type_to_set2(1) assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>class.nontriv TYPE('b); ?A \\<in> carrier_mat p p;\n   ?P \\<in> carrier_mat p p; ?H \\<in> carrier_mat p p;\n   ?Q \\<in> carrier_mat p p; ?K \\<in> carrier_mat p p; ?A = ?P * ?H;\n   ?A = ?Q * ?K; invertible_mat (of_int_hom.mat_hom ?A); invertible_mat ?P;\n   invertible_mat ?Q; Hermite_JNF ?associates ?res ?H;\n   Hermite_JNF ?associates ?res ?K\\<rbrakk>\n  \\<Longrightarrow> ?H = ?K\n  class.nontriv TYPE('b)\n  A \\<in> carrier_mat p p\n  P \\<in> carrier_mat p p\n  H \\<in> carrier_mat p p\n  Q \\<in> carrier_mat p p\n  K \\<in> carrier_mat p p\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. H = K", "by blast"], ["", "end"], ["", "lemma HNF_unique_generalized_JNF:\n  fixes A::\"int mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and P: \"P \\<in> carrier_mat n n\" and H: \"H \\<in> carrier_mat n n\"\n   and Q: \"Q \\<in> carrier_mat n n\" and K: \"K \\<in> carrier_mat n n\"\n assumes A_PH: \"A = P * H\" and A_QK: \"A = Q * K\"\n   and inv_A: \"invertible_mat (map_mat rat_of_int A)\" and inv_P: \"invertible_mat P\" and inv_Q: \"invertible_mat Q\"\n   and HNF_H: \"Hermite_JNF associates res H\" and HNF_K: \"Hermite_JNF associates res K\"\n  shows \"H = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "proof (cases \"n=0 \\<or> n=1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<or> n = 1 \\<Longrightarrow> H = K\n 2. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "case True"], ["proof (state)\nthis:\n  n = 0 \\<or> n = 1\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> n = 1 \\<Longrightarrow> H = K\n 2. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "note zero_or_one = True"], ["proof (state)\nthis:\n  n = 0 \\<or> n = 1\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> n = 1 \\<Longrightarrow> H = K\n 2. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "proof (cases \"n=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> H = K\n 2. n \\<noteq> 0 \\<Longrightarrow> H = K", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> H = K\n 2. n \\<noteq> 0 \\<Longrightarrow> H = K", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. H = K", "using assms"], ["proof (prove)\nusing this:\n  n = 0\n  A \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  H \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  K \\<in> carrier_mat n n\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. H = K", "by auto"], ["proof (state)\nthis:\n  H = K\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "let ?RAT = \"map_mat rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "hence n: \"n=1\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n = 1", "using zero_or_one"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  n = 0 \\<or> n = 1\n\ngoal (1 subgoal):\n 1. n = 1", "by auto"], ["proof (state)\nthis:\n  n = 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have CS_A: \"Complete_set_non_associates associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_set_non_associates associates", "using HNF_H"], ["proof (prove)\nusing this:\n  Hermite_JNF associates res H\n\ngoal (1 subgoal):\n 1. Complete_set_non_associates associates", "unfolding Hermite_JNF_def"], ["proof (prove)\nusing this:\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues res \\<and>\n  echelon_form_JNF H \\<and>\n  (\\<forall>i<dim_row H.\n      \\<not> is_zero_row_JNF i H \\<longrightarrow>\n      H $$ (i, LEAST n. H $$ (i, n) \\<noteq> 0) \\<in> associates) \\<and>\n  (\\<forall>i<dim_row H.\n      \\<not> is_zero_row_JNF i H \\<longrightarrow>\n      (\\<forall>j<i.\n          H $$ (j, LEAST n. H $$ (i, n) \\<noteq> 0)\n          \\<in> res (H $$ (i, LEAST n. H $$ (i, n) \\<noteq> 0))))\n\ngoal (1 subgoal):\n 1. Complete_set_non_associates associates", "by simp"], ["proof (state)\nthis:\n  Complete_set_non_associates associates\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have H: \"H \\<in> carrier_mat 1 1\" and K: \"K\\<in> carrier_mat 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<in> carrier_mat 1 1 &&& K \\<in> carrier_mat 1 1", "using False zero_or_one assms"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  n = 0 \\<or> n = 1\n  A \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  H \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  K \\<in> carrier_mat n n\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. H \\<in> carrier_mat 1 1 &&& K \\<in> carrier_mat 1 1", "by auto"], ["proof (state)\nthis:\n  H \\<in> carrier_mat 1 1\n  K \\<in> carrier_mat 1 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have det_P_dvd_1: \"Determinant.det P dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (Determinant.det P)", "using invertible_iff_is_unit_JNF inv_P P"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat ?A = (Determinant.det ?A dvd (1::?'a))\n  invertible_mat P\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. is_unit (Determinant.det P)", "by blast"], ["proof (state)\nthis:\n  is_unit (Determinant.det P)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have det_Q_dvd_1: \"Determinant.det Q dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (Determinant.det Q)", "using invertible_iff_is_unit_JNF inv_Q Q"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat ?A = (Determinant.det ?A dvd (1::?'a))\n  invertible_mat Q\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. is_unit (Determinant.det Q)", "by blast"], ["proof (state)\nthis:\n  is_unit (Determinant.det Q)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have PH_QK: \"Determinant.det P * Determinant.det H = Determinant.det Q * Determinant.det K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det P * Determinant.det H =\n    Determinant.det Q * Determinant.det K", "using Determinant.det_mult assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> Determinant.det (?A * ?B) =\n                    Determinant.det ?A * Determinant.det ?B\n  A \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  H \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  K \\<in> carrier_mat n n\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. Determinant.det P * Determinant.det H =\n    Determinant.det Q * Determinant.det K", "by metis"], ["proof (state)\nthis:\n  Determinant.det P * Determinant.det H =\n  Determinant.det Q * Determinant.det K\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "hence \"Determinant.det P * H $$ (0,0) = Determinant.det Q * K $$ (0,0)\""], ["proof (prove)\nusing this:\n  Determinant.det P * Determinant.det H =\n  Determinant.det Q * Determinant.det K\n\ngoal (1 subgoal):\n 1. Determinant.det P * H $$ (0, 0) = Determinant.det Q * K $$ (0, 0)", "by (metis H K determinant_one_element)"], ["proof (state)\nthis:\n  Determinant.det P * H $$ (0, 0) = Determinant.det Q * K $$ (0, 0)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "obtain u where uH_K: \"u * H $$(0,0) = K $$ (0,0)\" and unit_u: \"is_unit u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u * H $$ (0, 0) = K $$ (0, 0); is_unit u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, hide_lams) H K PH_QK algebraic_semidom_class.dvd_mult_unit_iff det_P_dvd_1 \n          det_Q_dvd_1 det_singleton dvdE dvd_mult_cancel_left mult.commute mult.right_neutral one_dvd)"], ["proof (state)\nthis:\n  u * H $$ (0, 0) = K $$ (0, 0)\n  is_unit u\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have H00_not_0: \"H $$ (0,0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<noteq> 0", "have \"?RAT A = ?RAT P * ?RAT H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom A = of_int_hom.mat_hom P * of_int_hom.mat_hom H", "using A_PH"], ["proof (prove)\nusing this:\n  A = P * H\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom A = of_int_hom.mat_hom P * of_int_hom.mat_hom H", "using P H n of_int_hom.mat_hom_mult"], ["proof (prove)\nusing this:\n  A = P * H\n  P \\<in> carrier_mat n n\n  H \\<in> carrier_mat 1 1\n  n = 1\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?n; ?B \\<in> carrier_mat ?n ?nc\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.mat_hom (?A * ?B) =\n                    of_int_hom.mat_hom ?A * of_int_hom.mat_hom ?B\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom A = of_int_hom.mat_hom P * of_int_hom.mat_hom H", "by blast"], ["proof (state)\nthis:\n  of_int_hom.mat_hom A = of_int_hom.mat_hom P * of_int_hom.mat_hom H\n\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<noteq> 0", "hence \"det (?RAT H) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom A = of_int_hom.mat_hom P * of_int_hom.mat_hom H\n\ngoal (1 subgoal):\n 1. Determinant.det (of_int_hom.mat_hom H) \\<noteq> 0", "by (metis A Determinant.det_mult False H P inv_A invertible_iff_is_unit_JNF \n            map_carrier_mat mult_eq_0_iff not_is_unit_0 zero_or_one)"], ["proof (state)\nthis:\n  Determinant.det (of_int_hom.mat_hom H) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  Determinant.det (of_int_hom.mat_hom H) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<noteq> 0", "using H determinant_one_element"], ["proof (prove)\nusing this:\n  Determinant.det (of_int_hom.mat_hom H) \\<noteq> 0\n  H \\<in> carrier_mat 1 1\n  ?A \\<in> carrier_mat 1 1 \\<Longrightarrow>\n  Determinant.det ?A = ?A $$ (0, 0)\n\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  H $$ (0, 0) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H $$ (0, 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "hence LEAST_H: \"(LEAST n. H $$ (0,n) \\<noteq> 0) = 0\""], ["proof (prove)\nusing this:\n  H $$ (0, 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (LEAST n. H $$ (0, n) \\<noteq> 0) = 0", "by simp"], ["proof (state)\nthis:\n  (LEAST n. H $$ (0, n) \\<noteq> 0) = 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have H00: \"H $$ (0,0) \\<in> associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<in> associates", "using HNF_H LEAST_H H H00_not_0"], ["proof (prove)\nusing this:\n  Hermite_JNF associates res H\n  (LEAST n. H $$ (0, n) \\<noteq> 0) = 0\n  H \\<in> carrier_mat 1 1\n  H $$ (0, 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<in> associates", "unfolding Hermite_JNF_def is_zero_row_JNF_def"], ["proof (prove)\nusing this:\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues res \\<and>\n  echelon_form_JNF H \\<and>\n  (\\<forall>i<dim_row H.\n      \\<not> (\\<forall>j<dim_col H. H $$ (i, j) = 0) \\<longrightarrow>\n      H $$ (i, LEAST n. H $$ (i, n) \\<noteq> 0) \\<in> associates) \\<and>\n  (\\<forall>i<dim_row H.\n      \\<not> (\\<forall>j<dim_col H. H $$ (i, j) = 0) \\<longrightarrow>\n      (\\<forall>j<i.\n          H $$ (j, LEAST n. H $$ (i, n) \\<noteq> 0)\n          \\<in> res (H $$ (i, LEAST n. H $$ (i, n) \\<noteq> 0))))\n  (LEAST n. H $$ (0, n) \\<noteq> 0) = 0\n  H \\<in> carrier_mat 1 1\n  H $$ (0, 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. H $$ (0, 0) \\<in> associates", "by auto"], ["proof (state)\nthis:\n  H $$ (0, 0) \\<in> associates\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have K00_not_0: \"K $$ (0,0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<noteq> 0", "have \"?RAT A = ?RAT Q * ?RAT K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom A = of_int_hom.mat_hom Q * of_int_hom.mat_hom K", "using A_QK"], ["proof (prove)\nusing this:\n  A = Q * K\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom A = of_int_hom.mat_hom Q * of_int_hom.mat_hom K", "using Q K n of_int_hom.mat_hom_mult"], ["proof (prove)\nusing this:\n  A = Q * K\n  Q \\<in> carrier_mat n n\n  K \\<in> carrier_mat 1 1\n  n = 1\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?n; ?B \\<in> carrier_mat ?n ?nc\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.mat_hom (?A * ?B) =\n                    of_int_hom.mat_hom ?A * of_int_hom.mat_hom ?B\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom A = of_int_hom.mat_hom Q * of_int_hom.mat_hom K", "by blast"], ["proof (state)\nthis:\n  of_int_hom.mat_hom A = of_int_hom.mat_hom Q * of_int_hom.mat_hom K\n\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<noteq> 0", "hence \"det (?RAT K) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom A = of_int_hom.mat_hom Q * of_int_hom.mat_hom K\n\ngoal (1 subgoal):\n 1. Determinant.det (of_int_hom.mat_hom K) \\<noteq> 0", "by (metis A Determinant.det_mult False Q K inv_A invertible_iff_is_unit_JNF \n            map_carrier_mat mult_eq_0_iff not_is_unit_0 zero_or_one)"], ["proof (state)\nthis:\n  Determinant.det (of_int_hom.mat_hom K) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  Determinant.det (of_int_hom.mat_hom K) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<noteq> 0", "using K determinant_one_element"], ["proof (prove)\nusing this:\n  Determinant.det (of_int_hom.mat_hom K) \\<noteq> 0\n  K \\<in> carrier_mat 1 1\n  ?A \\<in> carrier_mat 1 1 \\<Longrightarrow>\n  Determinant.det ?A = ?A $$ (0, 0)\n\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  K $$ (0, 0) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  K $$ (0, 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "hence LEAST_K: \"(LEAST n. K $$ (0,n) \\<noteq> 0) = 0\""], ["proof (prove)\nusing this:\n  K $$ (0, 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (LEAST n. K $$ (0, n) \\<noteq> 0) = 0", "by simp"], ["proof (state)\nthis:\n  (LEAST n. K $$ (0, n) \\<noteq> 0) = 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have K00: \"K $$ (0,0) \\<in> associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<in> associates", "using HNF_K LEAST_K K K00_not_0"], ["proof (prove)\nusing this:\n  Hermite_JNF associates res K\n  (LEAST n. K $$ (0, n) \\<noteq> 0) = 0\n  K \\<in> carrier_mat 1 1\n  K $$ (0, 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<in> associates", "unfolding Hermite_JNF_def is_zero_row_JNF_def"], ["proof (prove)\nusing this:\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues res \\<and>\n  echelon_form_JNF K \\<and>\n  (\\<forall>i<dim_row K.\n      \\<not> (\\<forall>j<dim_col K. K $$ (i, j) = 0) \\<longrightarrow>\n      K $$ (i, LEAST n. K $$ (i, n) \\<noteq> 0) \\<in> associates) \\<and>\n  (\\<forall>i<dim_row K.\n      \\<not> (\\<forall>j<dim_col K. K $$ (i, j) = 0) \\<longrightarrow>\n      (\\<forall>j<i.\n          K $$ (j, LEAST n. K $$ (i, n) \\<noteq> 0)\n          \\<in> res (K $$ (i, LEAST n. K $$ (i, n) \\<noteq> 0))))\n  (LEAST n. K $$ (0, n) \\<noteq> 0) = 0\n  K \\<in> carrier_mat 1 1\n  K $$ (0, 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. K $$ (0, 0) \\<in> associates", "by auto"], ["proof (state)\nthis:\n  K $$ (0, 0) \\<in> associates\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have ass_H00_K00: \"normalize (H $$ (0,0)) = normalize (K $$ (0,0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (H $$ (0, 0)) = normalize (K $$ (0, 0))", "by (metis normalize_mult_unit_left uH_K unit_u)"], ["proof (state)\nthis:\n  normalize (H $$ (0, 0)) = normalize (K $$ (0, 0))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "have H00_eq_K00: \"H $$ (0,0) = K $$ (0,0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $$ (0, 0) = K $$ (0, 0)", "using in_Ass_not_associated[OF CS_A H00 K00] ass_H00_K00"], ["proof (prove)\nusing this:\n  H $$ (0, 0) \\<noteq> K $$ (0, 0) \\<Longrightarrow>\n  normalize (H $$ (0, 0)) \\<noteq> normalize (K $$ (0, 0))\n  normalize (H $$ (0, 0)) = normalize (K $$ (0, 0))\n\ngoal (1 subgoal):\n 1. H $$ (0, 0) = K $$ (0, 0)", "by auto"], ["proof (state)\nthis:\n  H $$ (0, 0) = K $$ (0, 0)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> H = K", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "by (rule eq_matI, insert H K H00_eq_K00, auto)"], ["proof (state)\nthis:\n  H = K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H = K\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "case False"], ["proof (state)\nthis:\n  \\<not> (n = 0 \\<or> n = 1)\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "hence \"{0..<int n} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> (n = 0 \\<or> n = 1)\n\ngoal (1 subgoal):\n 1. {0..<int n} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {0..<int n} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "moreover"], ["proof (state)\nthis:\n  {0..<int n} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "have \"n>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n", "using False"], ["proof (prove)\nusing this:\n  \\<not> (n = 0 \\<or> n = 1)\n\ngoal (1 subgoal):\n 1. 1 < n", "by simp"], ["proof (state)\nthis:\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> n = 1) \\<Longrightarrow> H = K", "ultimately"], ["proof (chain)\npicking this:\n  {0..<int n} \\<noteq> {}\n  1 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  {0..<int n} \\<noteq> {}\n  1 < n\n\ngoal (1 subgoal):\n 1. H = K", "using Hermite_unique_generalized_JNF_aux[cancel_type_definition] assms"], ["proof (prove)\nusing this:\n  {0..<int n} \\<noteq> {}\n  1 < n\n  \\<lbrakk>{0..<int ?p} \\<noteq> {}; 1 < ?p; ?A \\<in> carrier_mat ?p ?p;\n   ?P \\<in> carrier_mat ?p ?p; ?H \\<in> carrier_mat ?p ?p;\n   ?Q \\<in> carrier_mat ?p ?p; ?K \\<in> carrier_mat ?p ?p; ?A = ?P * ?H;\n   ?A = ?Q * ?K; invertible_mat (of_int_hom.mat_hom ?A); invertible_mat ?P;\n   invertible_mat ?Q; Hermite_JNF ?associates ?res ?H;\n   Hermite_JNF ?associates ?res ?K\\<rbrakk>\n  \\<Longrightarrow> ?H = ?K\n  A \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  H \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  K \\<in> carrier_mat n n\n  A = P * H\n  A = Q * K\n  invertible_mat (of_int_hom.mat_hom A)\n  invertible_mat P\n  invertible_mat Q\n  Hermite_JNF associates res H\n  Hermite_JNF associates res K\n\ngoal (1 subgoal):\n 1. H = K", "by metis"], ["proof (state)\nthis:\n  H = K\n\ngoal:\nNo subgoals!", "(*Cancel local type definition*)"], ["proof (state)\nthis:\n  H = K\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}