{"file_name": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms/Matrix_Change_Row.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms", "problem_names": ["lemma change_row_carrier[simp]: \n  \"(change_row k f A \\<in> carrier_mat nr nc) = (A \\<in> carrier_mat nr nc)\" \n  \"dim_row (change_row k f A) = dim_row A\" \n  \"dim_col (change_row k f A) = dim_col A\"", "lemma change_row_index[simp]: \"A \\<in> carrier_mat nr nc \\<Longrightarrow> i < nr \\<Longrightarrow> j < nc \\<Longrightarrow>\n  change_row k f A $$ (i,j) = (if i = k then f j (A $$ (k,j)) else A $$ (i,j))\" \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> change_row k f A $$ (i,j) = (if i = k then f j (A $$ (k,j)) else A $$ (i,j))\"", "lemma change_row_code[code]: \"change_row k f (mat_impl A) = (if k < dim_row_impl A \n  then mat_impl (change_row_impl k f A) \n  else Code.abort (STR ''index out of bounds in change_row'') (\\<lambda> _. change_row k f (mat_impl A)))\"\n  (is \"?l = ?r\")"], "translations": [["", "lemma change_row_carrier[simp]: \n  \"(change_row k f A \\<in> carrier_mat nr nc) = (A \\<in> carrier_mat nr nc)\" \n  \"dim_row (change_row k f A) = dim_row A\" \n  \"dim_col (change_row k f A) = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (change_row k f A \\<in> carrier_mat nr nc) =\n    (A \\<in> carrier_mat nr nc) &&&\n    dim_row (change_row k f A) = dim_row A &&&\n    dim_col (change_row k f A) = dim_col A", "unfolding change_row_def carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (dim_row A) (dim_col A)\n      (\\<lambda>(i, j). if i = k then f j (A $$ (k, j)) else A $$ (i, j))\n     \\<in> {m. dim_row m = nr \\<and> dim_col m = nc}) =\n    (A \\<in> {m. dim_row m = nr \\<and> dim_col m = nc}) &&&\n    dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if i = k then f j (A $$ (k, j)) else A $$ (i, j))) =\n    dim_row A &&&\n    dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if i = k then f j (A $$ (k, j)) else A $$ (i, j))) =\n    dim_col A", "by auto"], ["", "lemma change_row_index[simp]: \"A \\<in> carrier_mat nr nc \\<Longrightarrow> i < nr \\<Longrightarrow> j < nc \\<Longrightarrow>\n  change_row k f A $$ (i,j) = (if i = k then f j (A $$ (k,j)) else A $$ (i,j))\" \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> change_row k f A $$ (i,j) = (if i = k then f j (A $$ (k,j)) else A $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>A \\<in> carrier_mat nr nc; i < nr; j < nc\\<rbrakk>\n     \\<Longrightarrow> change_row k f A $$ (i, j) =\n                       (if i = k then f j (A $$ (k, j))\n                        else A $$ (i, j))) &&&\n    (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n     \\<Longrightarrow> change_row k f A $$ (i, j) =\n                       (if i = k then f j (A $$ (k, j)) else A $$ (i, j)))", "unfolding change_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>A \\<in> carrier_mat nr nc; i < nr; j < nc\\<rbrakk>\n     \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                        (\\<lambda>(i, j).\n                            if i = k then f j (A $$ (k, j))\n                            else A $$ (i, j)) $$\n                       (i, j) =\n                       (if i = k then f j (A $$ (k, j))\n                        else A $$ (i, j))) &&&\n    (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n     \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                        (\\<lambda>(i, j).\n                            if i = k then f j (A $$ (k, j))\n                            else A $$ (i, j)) $$\n                       (i, j) =\n                       (if i = k then f j (A $$ (k, j)) else A $$ (i, j)))", "by auto"], ["", "lift_definition change_row_impl :: \"nat \\<Rightarrow> (nat \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> 'a mat_impl \\<Rightarrow> 'a mat_impl\" is\n  \"\\<lambda> k f (nr,nc,A). let Ak = IArray.sub A k; Arows = IArray.list_of A;\n     Ak' = IArray.IArray (map (\\<lambda> (i,c). f i c) (zip [0 ..< nc] (IArray.list_of Ak)));\n     A' = IArray.IArray (Arows [k := Ak'])\n     in (nr,nc,A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat fun prod.\n       prod\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc)\n               m} \\<Longrightarrow>\n       (case prod of\n        (nr, nc, A) \\<Rightarrow>\n          let Ak = A !! nat; Arows = IArray.list_of A;\n              Ak' = IArray (map2 fun [0..<nc] (IArray.list_of Ak));\n              A' = IArray (Arows[nat := Ak'])\n          in (nr, nc, A'))\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc) m}", "proof (auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat fun aa b ab.\n       \\<lbrakk>\\<forall>a\\<in>set (IArray.list_of b).\n                   length (IArray.list_of a) = aa;\n        ab \\<in> set ((IArray.list_of b)\n                      [nat :=\n                         IArray\n                          (map2 fun [0..<aa]\n                            (IArray.list_of\n                              (IArray.list_of b ! nat)))])\\<rbrakk>\n       \\<Longrightarrow> length (IArray.list_of ab) = aa", "case (1 k f nc b row)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (IArray.list_of b). length (IArray.list_of a) = nc\n  row\n  \\<in> set ((IArray.list_of b)\n             [k := IArray\n                    (map2 f [0..<nc]\n                      (IArray.list_of (IArray.list_of b ! k)))])\n\ngoal (1 subgoal):\n 1. \\<And>nat fun aa b ab.\n       \\<lbrakk>\\<forall>a\\<in>set (IArray.list_of b).\n                   length (IArray.list_of a) = aa;\n        ab \\<in> set ((IArray.list_of b)\n                      [nat :=\n                         IArray\n                          (map2 fun [0..<aa]\n                            (IArray.list_of\n                              (IArray.list_of b ! nat)))])\\<rbrakk>\n       \\<Longrightarrow> length (IArray.list_of ab) = aa", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (IArray.list_of row) = nc", "proof (cases b)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. b = IArray x \\<Longrightarrow> length (IArray.list_of row) = nc", "case (IArray rows)"], ["proof (state)\nthis:\n  b = IArray rows\n\ngoal (1 subgoal):\n 1. \\<And>x. b = IArray x \\<Longrightarrow> length (IArray.list_of row) = nc", "with 1"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (IArray.list_of b). length (IArray.list_of a) = nc\n  row\n  \\<in> set ((IArray.list_of b)\n             [k := IArray\n                    (map2 f [0..<nc]\n                      (IArray.list_of (IArray.list_of b ! k)))])\n  b = IArray rows", "have \"row \\<in> set rows \\<or> k < length rows \n       \\<and> row = IArray (map (\\<lambda> (i,c). f i c) (zip [0 ..< nc] (IArray.list_of (rows ! k))))\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (IArray.list_of b). length (IArray.list_of a) = nc\n  row\n  \\<in> set ((IArray.list_of b)\n             [k := IArray\n                    (map2 f [0..<nc]\n                      (IArray.list_of (IArray.list_of b ! k)))])\n  b = IArray rows\n\ngoal (1 subgoal):\n 1. row \\<in> set rows \\<or>\n    k < length rows \\<and>\n    row = IArray (map2 f [0..<nc] (IArray.list_of (rows ! k)))", "by (cases \"k < length rows\", auto simp: set_list_update dest: in_set_takeD in_set_dropD)"], ["proof (state)\nthis:\n  row \\<in> set rows \\<or>\n  k < length rows \\<and>\n  row = IArray (map2 f [0..<nc] (IArray.list_of (rows ! k)))\n\ngoal (1 subgoal):\n 1. \\<And>x. b = IArray x \\<Longrightarrow> length (IArray.list_of row) = nc", "with 1 IArray"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (IArray.list_of b). length (IArray.list_of a) = nc\n  row\n  \\<in> set ((IArray.list_of b)\n             [k := IArray\n                    (map2 f [0..<nc]\n                      (IArray.list_of (IArray.list_of b ! k)))])\n  b = IArray rows\n  row \\<in> set rows \\<or>\n  k < length rows \\<and>\n  row = IArray (map2 f [0..<nc] (IArray.list_of (rows ! k)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (IArray.list_of b). length (IArray.list_of a) = nc\n  row\n  \\<in> set ((IArray.list_of b)\n             [k := IArray\n                    (map2 f [0..<nc]\n                      (IArray.list_of (IArray.list_of b ! k)))])\n  b = IArray rows\n  row \\<in> set rows \\<or>\n  k < length rows \\<and>\n  row = IArray (map2 f [0..<nc] (IArray.list_of (rows ! k)))\n\ngoal (1 subgoal):\n 1. length (IArray.list_of row) = nc", "by (cases, auto)"], ["proof (state)\nthis:\n  length (IArray.list_of row) = nc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (IArray.list_of row) = nc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma change_row_code[code]: \"change_row k f (mat_impl A) = (if k < dim_row_impl A \n  then mat_impl (change_row_impl k f A) \n  else Code.abort (STR ''index out of bounds in change_row'') (\\<lambda> _. change_row k f (mat_impl A)))\"\n  (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. change_row k f (mat_impl A) =\n    (if k < dim_row_impl A then mat_impl (change_row_impl k f A)\n     else Code.abort STR ''index out of bounds in change_row''\n           (\\<lambda>_. change_row k f (mat_impl A)))", "proof (cases \"k < dim_row_impl A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < dim_row_impl A \\<Longrightarrow>\n    change_row k f (mat_impl A) =\n    (if k < dim_row_impl A then mat_impl (change_row_impl k f A)\n     else Code.abort STR ''index out of bounds in change_row''\n           (\\<lambda>_. change_row k f (mat_impl A)))\n 2. \\<not> k < dim_row_impl A \\<Longrightarrow>\n    change_row k f (mat_impl A) =\n    (if k < dim_row_impl A then mat_impl (change_row_impl k f A)\n     else Code.abort STR ''index out of bounds in change_row''\n           (\\<lambda>_. change_row k f (mat_impl A)))", "case True"], ["proof (state)\nthis:\n  k < dim_row_impl A\n\ngoal (2 subgoals):\n 1. k < dim_row_impl A \\<Longrightarrow>\n    change_row k f (mat_impl A) =\n    (if k < dim_row_impl A then mat_impl (change_row_impl k f A)\n     else Code.abort STR ''index out of bounds in change_row''\n           (\\<lambda>_. change_row k f (mat_impl A)))\n 2. \\<not> k < dim_row_impl A \\<Longrightarrow>\n    change_row k f (mat_impl A) =\n    (if k < dim_row_impl A then mat_impl (change_row_impl k f A)\n     else Code.abort STR ''index out of bounds in change_row''\n           (\\<lambda>_. change_row k f (mat_impl A)))", "hence id: \"?r = mat_impl (change_row_impl k f A)\""], ["proof (prove)\nusing this:\n  k < dim_row_impl A\n\ngoal (1 subgoal):\n 1. (if k < dim_row_impl A then mat_impl (change_row_impl k f A)\n     else Code.abort STR ''index out of bounds in change_row''\n           (\\<lambda>_. change_row k f (mat_impl A))) =\n    mat_impl (change_row_impl k f A)", "by simp"], ["proof (state)\nthis:\n  (if k < dim_row_impl A then mat_impl (change_row_impl k f A)\n   else Code.abort STR ''index out of bounds in change_row''\n         (\\<lambda>_. change_row k f (mat_impl A))) =\n  mat_impl (change_row_impl k f A)\n\ngoal (2 subgoals):\n 1. k < dim_row_impl A \\<Longrightarrow>\n    change_row k f (mat_impl A) =\n    (if k < dim_row_impl A then mat_impl (change_row_impl k f A)\n     else Code.abort STR ''index out of bounds in change_row''\n           (\\<lambda>_. change_row k f (mat_impl A)))\n 2. \\<not> k < dim_row_impl A \\<Longrightarrow>\n    change_row k f (mat_impl A) =\n    (if k < dim_row_impl A then mat_impl (change_row_impl k f A)\n     else Code.abort STR ''index out of bounds in change_row''\n           (\\<lambda>_. change_row k f (mat_impl A)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. change_row k f (mat_impl A) =\n    (if k < dim_row_impl A then mat_impl (change_row_impl k f A)\n     else Code.abort STR ''index out of bounds in change_row''\n           (\\<lambda>_. change_row k f (mat_impl A)))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. change_row k f (mat_impl A) = mat_impl (change_row_impl k f A)", "unfolding change_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n     (\\<lambda>(i, j).\n         if i = k then f j (mat_impl A $$ (k, j))\n         else mat_impl A $$ (i, j)) =\n    mat_impl (change_row_impl k f A)", "proof (rule eq_matI, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (mat_impl (change_row_impl k f A));\n        j < dim_col (mat_impl (change_row_impl k f A))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n                          (\\<lambda>(i, j).\n                              if i = k then f j (mat_impl A $$ (k, j))\n                              else mat_impl A $$ (i, j)) $$\n                         (i, j) =\n                         mat_impl (change_row_impl k f A) $$ (i, j)\n 2. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if i = k then f j (mat_impl A $$ (k, j))\n           else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (change_row_impl k f A))\n 3. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if i = k then f j (mat_impl A $$ (k, j))\n           else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (change_row_impl k f A))", "case (1 i j)"], ["proof (state)\nthis:\n  i < dim_row (mat_impl (change_row_impl k f A))\n  j < dim_col (mat_impl (change_row_impl k f A))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (mat_impl (change_row_impl k f A));\n        j < dim_col (mat_impl (change_row_impl k f A))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n                          (\\<lambda>(i, j).\n                              if i = k then f j (mat_impl A $$ (k, j))\n                              else mat_impl A $$ (i, j)) $$\n                         (i, j) =\n                         mat_impl (change_row_impl k f A) $$ (i, j)\n 2. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if i = k then f j (mat_impl A $$ (k, j))\n           else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (change_row_impl k f A))\n 3. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if i = k then f j (mat_impl A $$ (k, j))\n           else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (change_row_impl k f A))", "thus ?case"], ["proof (prove)\nusing this:\n  i < dim_row (mat_impl (change_row_impl k f A))\n  j < dim_col (mat_impl (change_row_impl k f A))\n\ngoal (1 subgoal):\n 1. mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n     (\\<lambda>(i, j).\n         if i = k then f j (mat_impl A $$ (k, j))\n         else mat_impl A $$ (i, j)) $$\n    (i, j) =\n    mat_impl (change_row_impl k f A) $$ (i, j)", "using True"], ["proof (prove)\nusing this:\n  i < dim_row (mat_impl (change_row_impl k f A))\n  j < dim_col (mat_impl (change_row_impl k f A))\n  k < dim_row_impl A\n\ngoal (1 subgoal):\n 1. mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n     (\\<lambda>(i, j).\n         if i = k then f j (mat_impl A $$ (k, j))\n         else mat_impl A $$ (i, j)) $$\n    (i, j) =\n    mat_impl (change_row_impl k f A) $$ (i, j)", "by (transfer, auto simp: mk_mat_def)"], ["proof (state)\nthis:\n  mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n   (\\<lambda>(i, j).\n       if i = k then f j (mat_impl A $$ (k, j))\n       else mat_impl A $$ (i, j)) $$\n  (i, j) =\n  mat_impl (change_row_impl k f A) $$ (i, j)\n\ngoal (2 subgoals):\n 1. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if i = k then f j (mat_impl A $$ (k, j))\n           else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (change_row_impl k f A))\n 2. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if i = k then f j (mat_impl A $$ (k, j))\n           else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (change_row_impl k f A))", "qed (transfer, auto)+"], ["proof (state)\nthis:\n  change_row k f (mat_impl A) =\n  (if k < dim_row_impl A then mat_impl (change_row_impl k f A)\n   else Code.abort STR ''index out of bounds in change_row''\n         (\\<lambda>_. change_row k f (mat_impl A)))\n\ngoal (1 subgoal):\n 1. \\<not> k < dim_row_impl A \\<Longrightarrow>\n    change_row k f (mat_impl A) =\n    (if k < dim_row_impl A then mat_impl (change_row_impl k f A)\n     else Code.abort STR ''index out of bounds in change_row''\n           (\\<lambda>_. change_row k f (mat_impl A)))", "qed simp"], ["", "end"]]}