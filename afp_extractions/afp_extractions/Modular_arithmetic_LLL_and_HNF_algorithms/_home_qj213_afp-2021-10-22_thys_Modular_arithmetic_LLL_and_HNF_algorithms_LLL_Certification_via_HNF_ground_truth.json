{"file_name": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms/LLL_Certification_via_HNF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms", "problem_names": ["lemma m_le_n: \"m\\<le>n\"", "lemma HNF_A_eq_HNF_PA'_exist:\n  fixes A::\"int mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and inv_A: \"invertible_mat (map_mat rat_of_int A)\" \n    and inv_P: \"invertible_mat P\" and P: \"P \\<in> carrier_mat n n\"\n    and HNF_H1: \"Hermite_JNF associates res H1\"\n    and H1: \"H1 \\<in> carrier_mat n n\"\n    and HNF_H2: \"Hermite_JNF associates res H2\"\n    and H2: \"H2 \\<in> carrier_mat n n\"\n    and sound_HNF1: \"\\<exists>P1. P1 \\<in> carrier_mat n n \\<and> invertible_mat P1 \\<and> (P * A) = P1 * H1\"\n    and sound_HNF2: \"\\<exists>P2. P2 \\<in> carrier_mat n n \\<and> invertible_mat P2 \\<and> A = P2 * H2\"\n  shows \"H1 = H2\"", "lemma certification_via_eq_HNF2_exist:\n  assumes HNF_H1: \"Hermite_JNF associates res H1\"\n    and H1: \"H1 \\<in> carrier_mat n n\"\n    and HNF_H2: \"Hermite_JNF associates res H2\"\n    and H2: \"H2 \\<in> carrier_mat n n\"\n    and sound_HNF1: \"\\<exists>P1. P1 \\<in> carrier_mat n n \\<and> invertible_mat P1 \\<and> (mat_of_rows n fs_init) = P1 * H1\"\n    and sound_HNF2: \"\\<exists>P2. P2 \\<in> carrier_mat n n \\<and> invertible_mat P2 \\<and> (mat_of_rows n gs) = P2 * H2\"\n    and gs: \"set gs \\<subseteq> carrier_vec n\" \n    and l: \"lattice_of fs_init = lattice_of gs\"\n    and mn: \"m = n\" and len_gs: \"length gs = n\" (*For the moment, only for square matrices*)\n  shows \"H1 = H2\"", "lemma certification_via_eq_HNF2:\n  assumes sound_HNF: \"is_sound_HNF HNF associates res\"\n    and P1_H1: \"(P1,H1) = HNF (mat_of_rows n fs_init)\"\n    and P2_H2: \"(P2,H2) = HNF (mat_of_rows n gs)\"    \n    and gs: \"set gs \\<subseteq> carrier_vec n\" \n    and l: \"lattice_of fs_init = lattice_of gs\"\n    and mn: \"m = n\" and len_gs: \"length gs = n\" (*For the moment, only for square matrices*)\n  shows \"H1 = H2\"", "lemma lattice_of_eq_via_HNF_paper:\n  fixes F G :: \"int mat\" and HNF :: \"int mat \\<Rightarrow> int mat\"\n  assumes sound_HNF': \"is_sound_HNF' HNF \\<A> \\<R>\" (* HNF is a sound algorithm *)  \n    and inv_F_Q: \"invertible_mat (map_mat rat_of_int F)\" (* invertible over Q *)\n    and FG: \"{F,G} \\<subseteq> carrier_mat n n\"\n  shows \"(HNF F = HNF G) \\<longleftrightarrow> (lattice_of (rows F) = lattice_of (rows G))\"", "lemma reduce_basis_external': assumes res: \"reduce_basis_external' HNF \\<alpha> fs_init = fs\" \n  shows \"reduced fs m\" \"LLL_invariant True m fs\"", "lemma RBE_HNF_algorithm_efficient:\n  assumes \"reduce_basis_external' (HNF_algorithm use_sym_mod) \\<alpha> fs_init = fs\"\n  shows \"gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\"\n    and \"LLL_invariant True m fs\"", "lemma RBE_HNF_algorithm_naive:\n  assumes \"reduce_basis_external' (HNF_algorithm_from_HA use_sym_mod) \\<alpha> fs_init = fs\"\n  shows \"gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\"\n    and \"LLL_invariant True m fs\"", "lemma external_lll_solver'_code[code]: \n  \"external_lll_solver' = Code.abort (STR ''require proper implementation of external_lll_solver'') (\\<lambda> _. external_lll_solver')\""], "translations": [["", "lemma m_le_n: \"m\\<le>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<le> n", "have \"gs.lin_indpt (set (RAT fs_init))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))", "using cof_vec_space.lin_indpt_list_def lin_dep"], ["proof (prove)\nusing this:\n  cof_vec_space.lin_indpt_list ?n ?fs =\n  (set ?fs \\<subseteq> carrier_vec ?n \\<and>\n   distinct ?fs \\<and>\n   \\<not> module.lin_dep class_ring (module_vec TYPE(?'a) ?n) (set ?fs))\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs_init)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))", "by blast"], ["proof (state)\nthis:\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n\ngoal (1 subgoal):\n 1. m \\<le> n", "moreover"], ["proof (state)\nthis:\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n\ngoal (1 subgoal):\n 1. m \\<le> n", "have \"gs.dim = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.dim = n", "by (simp add: gs.dim_is_n)"], ["proof (state)\nthis:\n  gs.dim = n\n\ngoal (1 subgoal):\n 1. m \\<le> n", "moreover"], ["proof (state)\nthis:\n  gs.dim = n\n\ngoal (1 subgoal):\n 1. m \\<le> n", "have \"card (set (RAT fs_init)) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (map of_int_hom.vec_hom fs_init)) = m", "using LLL_invD(2) LLL_inv_initial_state cof_vec_space.lin_indpt_list_def distinct_card lin_dep"], ["proof (prove)\nusing this:\n  LLL_invariant ?upw ?i ?fs \\<Longrightarrow>\n  length (map of_int_hom.vec_hom ?fs) = m\n  LLL_invariant True 0 fs_init\n  cof_vec_space.lin_indpt_list ?n ?fs =\n  (set ?fs \\<subseteq> carrier_vec ?n \\<and>\n   distinct ?fs \\<and>\n   \\<not> module.lin_dep class_ring (module_vec TYPE(?'a) ?n) (set ?fs))\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs_init)\n\ngoal (1 subgoal):\n 1. card (set (map of_int_hom.vec_hom fs_init)) = m", "by blast"], ["proof (state)\nthis:\n  card (set (map of_int_hom.vec_hom fs_init)) = m\n\ngoal (1 subgoal):\n 1. m \\<le> n", "ultimately"], ["proof (chain)\npicking this:\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n  gs.dim = n\n  card (set (map of_int_hom.vec_hom fs_init)) = m", "show ?thesis"], ["proof (prove)\nusing this:\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n  gs.dim = n\n  card (set (map of_int_hom.vec_hom fs_init)) = m\n\ngoal (1 subgoal):\n 1. m \\<le> n", "using gs.li_le_dim"], ["proof (prove)\nusing this:\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n  gs.dim = n\n  card (set (map of_int_hom.vec_hom fs_init)) = m\n  \\<lbrakk>gs.fin_dim; ?A \\<subseteq> Rn; gs.lin_indpt ?A\\<rbrakk>\n  \\<Longrightarrow> finite ?A\n  \\<lbrakk>gs.fin_dim; ?A \\<subseteq> Rn; gs.lin_indpt ?A\\<rbrakk>\n  \\<Longrightarrow> card ?A \\<le> gs.dim\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by (metis cof_vec_space.lin_indpt_list_def gs.fin_dim lin_dep)"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>This lemma is a generalization of the theorem named @{text \"HNF_A_eq_HNF_PA\"}, using\nthe new uniqueness statement of the HNF. We provide two versions, one\nassuming the existence and the other one obtained from a sound algorithm.\\<close>"], ["", "lemma HNF_A_eq_HNF_PA'_exist:\n  fixes A::\"int mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and inv_A: \"invertible_mat (map_mat rat_of_int A)\" \n    and inv_P: \"invertible_mat P\" and P: \"P \\<in> carrier_mat n n\"\n    and HNF_H1: \"Hermite_JNF associates res H1\"\n    and H1: \"H1 \\<in> carrier_mat n n\"\n    and HNF_H2: \"Hermite_JNF associates res H2\"\n    and H2: \"H2 \\<in> carrier_mat n n\"\n    and sound_HNF1: \"\\<exists>P1. P1 \\<in> carrier_mat n n \\<and> invertible_mat P1 \\<and> (P * A) = P1 * H1\"\n    and sound_HNF2: \"\\<exists>P2. P2 \\<in> carrier_mat n n \\<and> invertible_mat P2 \\<and> A = P2 * H2\"\n  shows \"H1 = H2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H1 = H2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H1 = H2", "obtain inv_P where P_inv_P: \"inverts_mat P inv_P\" and inv_P_P: \"inverts_mat inv_P P\"\n    and inv_P: \"inv_P \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>inv_P.\n        \\<lbrakk>inverts_mat P inv_P; inverts_mat inv_P P;\n         inv_P \\<in> carrier_mat n n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P inv_P obtain_inverse_matrix"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  invertible_mat P\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; invertible_mat ?A;\n   \\<And>B.\n      \\<lbrakk>inverts_mat ?A B; inverts_mat B ?A;\n       B \\<in> carrier_mat ?n ?n\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>inv_P.\n        \\<lbrakk>inverts_mat P inv_P; inverts_mat inv_P P;\n         inv_P \\<in> carrier_mat n n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inverts_mat P inv_P\n  inverts_mat inv_P P\n  inv_P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. H1 = H2", "obtain P1 where P1: \"P1 \\<in> carrier_mat n n\" and inv_P1: \"invertible_mat P1\" and P1_H1: \"P* A = P1 * H1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> carrier_mat n n; invertible_mat P1;\n         P * A = P1 * H1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sound_HNF1"], ["proof (prove)\nusing this:\n  \\<exists>P1.\n     P1 \\<in> carrier_mat n n \\<and>\n     invertible_mat P1 \\<and> P * A = P1 * H1\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> carrier_mat n n; invertible_mat P1;\n         P * A = P1 * H1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> carrier_mat n n\n  invertible_mat P1\n  P * A = P1 * H1\n\ngoal (1 subgoal):\n 1. H1 = H2", "obtain P2 where P2: \"P2 \\<in> carrier_mat n n\" and inv_P2: \"invertible_mat P2\" and P2_H2: \"A = P2 * H2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P2.\n        \\<lbrakk>P2 \\<in> carrier_mat n n; invertible_mat P2;\n         A = P2 * H2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sound_HNF2"], ["proof (prove)\nusing this:\n  \\<exists>P2.\n     P2 \\<in> carrier_mat n n \\<and> invertible_mat P2 \\<and> A = P2 * H2\n\ngoal (1 subgoal):\n 1. (\\<And>P2.\n        \\<lbrakk>P2 \\<in> carrier_mat n n; invertible_mat P2;\n         A = P2 * H2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P2 \\<in> carrier_mat n n\n  invertible_mat P2\n  A = P2 * H2\n\ngoal (1 subgoal):\n 1. H1 = H2", "have invertible_inv_P: \"invertible_mat inv_P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat inv_P", "using P_inv_P inv_P inv_P_P invertible_mat_def square_mat.simps"], ["proof (prove)\nusing this:\n  inverts_mat P inv_P\n  inv_P \\<in> carrier_mat n n\n  inverts_mat inv_P P\n  invertible_mat ?A \\<equiv>\n  square_mat ?A \\<and>\n  (\\<exists>B. inverts_mat ?A B \\<and> inverts_mat B ?A)\n  square_mat ?A = (dim_col ?A = dim_row ?A)\n\ngoal (1 subgoal):\n 1. invertible_mat inv_P", "by blast"], ["proof (state)\nthis:\n  invertible_mat inv_P\n\ngoal (1 subgoal):\n 1. H1 = H2", "have P_A_P1_H1: \"P * A = P1 * H1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * A = P1 * H1", "using P1_H1 P2_H2"], ["proof (prove)\nusing this:\n  P * A = P1 * H1\n  A = P2 * H2\n\ngoal (1 subgoal):\n 1. P * A = P1 * H1", "unfolding is_sound_HNF_def Let_def"], ["proof (prove)\nusing this:\n  P * A = P1 * H1\n  A = P2 * H2\n\ngoal (1 subgoal):\n 1. P * A = P1 * H1", "by (metis (mono_tags, lifting) case_prod_conv)"], ["proof (state)\nthis:\n  P * A = P1 * H1\n\ngoal (1 subgoal):\n 1. H1 = H2", "hence \"A = inv_P * (P1 * H1)\""], ["proof (prove)\nusing this:\n  P * A = P1 * H1\n\ngoal (1 subgoal):\n 1. A = inv_P * (P1 * H1)", "by (smt A P inv_P_P inv_P assoc_mult_mat carrier_matD(1) inverts_mat_def left_mult_one_mat)"], ["proof (state)\nthis:\n  A = inv_P * (P1 * H1)\n\ngoal (1 subgoal):\n 1. H1 = H2", "hence A_inv_P_P1_H1: \"A = (inv_P * P1) * H1\""], ["proof (prove)\nusing this:\n  A = inv_P * (P1 * H1)\n\ngoal (1 subgoal):\n 1. A = inv_P * P1 * H1", "using P P1_H1 assoc_mult_mat inv_P H1 P1"], ["proof (prove)\nusing this:\n  A = inv_P * (P1 * H1)\n  P \\<in> carrier_mat n n\n  P * A = P1 * H1\n  \\<lbrakk>?A \\<in> carrier_mat ?n\\<^sub>1 ?n\\<^sub>2;\n   ?B \\<in> carrier_mat ?n\\<^sub>2 ?n\\<^sub>3;\n   ?C \\<in> carrier_mat ?n\\<^sub>3 ?n\\<^sub>4\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B * ?C = ?A * (?B * ?C)\n  inv_P \\<in> carrier_mat n n\n  H1 \\<in> carrier_mat n n\n  P1 \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = inv_P * P1 * H1", "by auto"], ["proof (state)\nthis:\n  A = inv_P * P1 * H1\n\ngoal (1 subgoal):\n 1. H1 = H2", "have invertible_inv_P_P1: \"invertible_mat (inv_P * P1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat (inv_P * P1)", "by (rule invertible_mult_JNF[OF inv_P P1 invertible_inv_P inv_P1])"], ["proof (state)\nthis:\n  invertible_mat (inv_P * P1)\n\ngoal (1 subgoal):\n 1. H1 = H2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. H1 = H2", "proof (rule HNF_unique_generalized_JNF[OF A _ H1 P2 H2 A_inv_P_P1_H1 P2_H2 \n        inv_A invertible_inv_P_P1 inv_P2 HNF_H1 HNF_H2])"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_P * P1 \\<in> carrier_mat n n", "show \"inv_P * P1 \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_P * P1 \\<in> carrier_mat n n", "by (metis carrier_matD(1) carrier_matI index_mult_mat(2) inv_P\n          invertible_inv_P_P1 invertible_mat_def square_mat.simps)"], ["proof (state)\nthis:\n  inv_P * P1 \\<in> carrier_mat n n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H1 = H2\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary HNF_A_eq_HNF_PA':\n  fixes A::\"int mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and inv_A: \"invertible_mat (map_mat rat_of_int A)\" \n    and inv_P: \"invertible_mat P\" and P: \"P \\<in> carrier_mat n n\"\n    and sound_HNF: \"is_sound_HNF HNF associates res\"\n    and P1_H1: \"(P1,H1) = HNF (P*A)\"\n    and P2_H2: \"(P2,H2) = HNF A\"\n  shows \"H1 = H2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H1 = H2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H1 = H2", "have H1: \"H1 \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H1 \\<in> carrier_mat n n", "by (smt P1_H1 A P carrier_matD index_mult_mat is_sound_HNF_def prod.sel(2) sound_HNF split_beta)"], ["proof (state)\nthis:\n  H1 \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. H1 = H2", "have H2: \"H2 \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H2 \\<in> carrier_mat n n", "by (smt P2_H2 A carrier_matD index_mult_mat is_sound_HNF_def prod.sel(2) sound_HNF split_beta)"], ["proof (state)\nthis:\n  H2 \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. H1 = H2", "have HNF_H1: \"Hermite_JNF associates res H1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_JNF associates res H1", "by (smt P1_H1 is_sound_HNF_def prod.sel(2) sound_HNF split_beta)"], ["proof (state)\nthis:\n  Hermite_JNF associates res H1\n\ngoal (1 subgoal):\n 1. H1 = H2", "have HNF_H2: \"Hermite_JNF associates res H2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hermite_JNF associates res H2", "by (smt P2_H2 is_sound_HNF_def prod.sel(2) sound_HNF split_beta)"], ["proof (state)\nthis:\n  Hermite_JNF associates res H2\n\ngoal (1 subgoal):\n 1. H1 = H2", "have sound_HNF1: \"\\<exists>P1. P1 \\<in> carrier_mat n n \\<and> invertible_mat P1 \\<and> (P * A) = P1 * H1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * A = P1 * H1", "using sound_HNF P1_H1"], ["proof (prove)\nusing this:\n  is_sound_HNF HNF associates res\n  (P1, H1) = HNF (P * A)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * A = P1 * H1", "unfolding is_sound_HNF_def Let_def"], ["proof (prove)\nusing this:\n  \\<forall>A.\n     case HNF A of\n     (P, H) \\<Rightarrow>\n       P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n       H \\<in> carrier_mat (dim_row A) (dim_col A) \\<and>\n       invertible_mat P \\<and> A = P * H \\<and> Hermite_JNF associates res H\n  (P1, H1) = HNF (P * A)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * A = P1 * H1", "by (metis (mono_tags, lifting) P carrier_matD(1) index_mult_mat(2) old.prod.simps(2))"], ["proof (state)\nthis:\n  \\<exists>P1.\n     P1 \\<in> carrier_mat n n \\<and>\n     invertible_mat P1 \\<and> P * A = P1 * H1\n\ngoal (1 subgoal):\n 1. H1 = H2", "have sound_HNF2: \"\\<exists>P2. P2 \\<in> carrier_mat n n \\<and> invertible_mat P2 \\<and> A = P2 * H2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P2.\n       P2 \\<in> carrier_mat n n \\<and> invertible_mat P2 \\<and> A = P2 * H2", "using sound_HNF P1_H1"], ["proof (prove)\nusing this:\n  is_sound_HNF HNF associates res\n  (P1, H1) = HNF (P * A)\n\ngoal (1 subgoal):\n 1. \\<exists>P2.\n       P2 \\<in> carrier_mat n n \\<and> invertible_mat P2 \\<and> A = P2 * H2", "unfolding is_sound_HNF_def Let_def"], ["proof (prove)\nusing this:\n  \\<forall>A.\n     case HNF A of\n     (P, H) \\<Rightarrow>\n       P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n       H \\<in> carrier_mat (dim_row A) (dim_col A) \\<and>\n       invertible_mat P \\<and> A = P * H \\<and> Hermite_JNF associates res H\n  (P1, H1) = HNF (P * A)\n\ngoal (1 subgoal):\n 1. \\<exists>P2.\n       P2 \\<in> carrier_mat n n \\<and> invertible_mat P2 \\<and> A = P2 * H2", "by (metis (mono_tags, lifting) A P2_H2 carrier_matD(1) old.prod.simps(2))"], ["proof (state)\nthis:\n  \\<exists>P2.\n     P2 \\<in> carrier_mat n n \\<and> invertible_mat P2 \\<and> A = P2 * H2\n\ngoal (1 subgoal):\n 1. H1 = H2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. H1 = H2", "by (rule HNF_A_eq_HNF_PA'_exist[OF A inv_A inv_P P HNF_H1 H1 HNF_H2 H2 sound_HNF1 sound_HNF2])"], ["proof (state)\nthis:\n  H1 = H2\n\ngoal:\nNo subgoals!", "qed"], ["", "context LLL_with_assms\nbegin"], ["", "lemma certification_via_eq_HNF2_exist:\n  assumes HNF_H1: \"Hermite_JNF associates res H1\"\n    and H1: \"H1 \\<in> carrier_mat n n\"\n    and HNF_H2: \"Hermite_JNF associates res H2\"\n    and H2: \"H2 \\<in> carrier_mat n n\"\n    and sound_HNF1: \"\\<exists>P1. P1 \\<in> carrier_mat n n \\<and> invertible_mat P1 \\<and> (mat_of_rows n fs_init) = P1 * H1\"\n    and sound_HNF2: \"\\<exists>P2. P2 \\<in> carrier_mat n n \\<and> invertible_mat P2 \\<and> (mat_of_rows n gs) = P2 * H2\"\n    and gs: \"set gs \\<subseteq> carrier_vec n\" \n    and l: \"lattice_of fs_init = lattice_of gs\"\n    and mn: \"m = n\" and len_gs: \"length gs = n\" (*For the moment, only for square matrices*)\n  shows \"H1 = H2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H1 = H2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H1 = H2", "have \"\\<exists>P \\<in> carrier_mat n n. invertible_mat P \\<and> mat_of_rows n fs_init = P * mat_of_rows n gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>carrier_mat n n.\n       invertible_mat P \\<and> mat_of_rows n fs_init = P * mat_of_rows n gs", "by (rule eq_lattice_imp_mat_mult_invertible_rows[OF fs_init gs lin_dep len[unfolded mn] len_gs l])"], ["proof (state)\nthis:\n  \\<exists>P\\<in>carrier_mat n n.\n     invertible_mat P \\<and> mat_of_rows n fs_init = P * mat_of_rows n gs\n\ngoal (1 subgoal):\n 1. H1 = H2", "from this"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>carrier_mat n n.\n     invertible_mat P \\<and> mat_of_rows n fs_init = P * mat_of_rows n gs", "obtain P where P: \"P \\<in> carrier_mat n n\" and inv_P: \"invertible_mat P\"\n    and fs_P_gs: \"mat_of_rows n fs_init = P * mat_of_rows n gs\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>carrier_mat n n.\n     invertible_mat P \\<and> mat_of_rows n fs_init = P * mat_of_rows n gs\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> carrier_mat n n; invertible_mat P;\n         mat_of_rows n fs_init = P * mat_of_rows n gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n n\n  invertible_mat P\n  mat_of_rows n fs_init = P * mat_of_rows n gs\n\ngoal (1 subgoal):\n 1. H1 = H2", "obtain P1 where P1: \"P1 \\<in> carrier_mat n n\" and inv_P1: \"invertible_mat P1\" and P1_H1: \"(mat_of_rows n fs_init) = P1 * H1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> carrier_mat n n; invertible_mat P1;\n         mat_of_rows n fs_init = P1 * H1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sound_HNF1"], ["proof (prove)\nusing this:\n  \\<exists>P1.\n     P1 \\<in> carrier_mat n n \\<and>\n     invertible_mat P1 \\<and> mat_of_rows n fs_init = P1 * H1\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> carrier_mat n n; invertible_mat P1;\n         mat_of_rows n fs_init = P1 * H1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> carrier_mat n n\n  invertible_mat P1\n  mat_of_rows n fs_init = P1 * H1\n\ngoal (1 subgoal):\n 1. H1 = H2", "obtain P2 where P2: \"P2 \\<in> carrier_mat n n\" and inv_P2: \"invertible_mat P2\" and P2_H2: \"(mat_of_rows n gs) = P2 * H2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P2.\n        \\<lbrakk>P2 \\<in> carrier_mat n n; invertible_mat P2;\n         mat_of_rows n gs = P2 * H2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sound_HNF2"], ["proof (prove)\nusing this:\n  \\<exists>P2.\n     P2 \\<in> carrier_mat n n \\<and>\n     invertible_mat P2 \\<and> mat_of_rows n gs = P2 * H2\n\ngoal (1 subgoal):\n 1. (\\<And>P2.\n        \\<lbrakk>P2 \\<in> carrier_mat n n; invertible_mat P2;\n         mat_of_rows n gs = P2 * H2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P2 \\<in> carrier_mat n n\n  invertible_mat P2\n  mat_of_rows n gs = P2 * H2\n\ngoal (1 subgoal):\n 1. H1 = H2", "have P1_H1_2: \"P * mat_of_rows n gs = P1 * H1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * mat_of_rows n gs = P1 * H1", "using P1_H1 fs_P_gs"], ["proof (prove)\nusing this:\n  mat_of_rows n fs_init = P1 * H1\n  mat_of_rows n fs_init = P * mat_of_rows n gs\n\ngoal (1 subgoal):\n 1. P * mat_of_rows n gs = P1 * H1", "by auto"], ["proof (state)\nthis:\n  P * mat_of_rows n gs = P1 * H1\n\ngoal (1 subgoal):\n 1. H1 = H2", "have gs_carrier: \"mat_of_rows n gs \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n gs \\<in> carrier_mat n n", "by (simp add: len_gs carrier_matI)"], ["proof (state)\nthis:\n  mat_of_rows n gs \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. H1 = H2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. H1 = H2", "proof (rule HNF_A_eq_HNF_PA'_exist[OF gs_carrier _ inv_P P HNF_H1 H1 HNF_H2 H2 _ sound_HNF2])"], ["proof (state)\ngoal (2 subgoals):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))\n 2. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1", "from inv_P"], ["proof (chain)\npicking this:\n  invertible_mat P", "obtain P' where PP': \"inverts_mat P P'\" and P'P: \"inverts_mat P' P\""], ["proof (prove)\nusing this:\n  invertible_mat P\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>inverts_mat P P'; inverts_mat P' P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using invertible_mat_def"], ["proof (prove)\nusing this:\n  invertible_mat P\n  invertible_mat ?A \\<equiv>\n  square_mat ?A \\<and>\n  (\\<exists>B. inverts_mat ?A B \\<and> inverts_mat B ?A)\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>inverts_mat P P'; inverts_mat P' P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inverts_mat P P'\n  inverts_mat P' P\n\ngoal (2 subgoals):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))\n 2. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1", "let ?RAT = \"of_int_hom.mat_hom :: int mat \\<Rightarrow> rat mat\""], ["proof (state)\ngoal (2 subgoals):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))\n 2. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1", "have det_RAT_fs_init: \"det (?RAT (mat_of_rows n fs_init)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom (mat_of_rows n fs_init)) \\<noteq> 0", "proof (rule gs.lin_indpt_rows_imp_det_not_0)"], ["proof (state)\ngoal (3 subgoals):\n 1. of_int_hom.mat_hom (mat_of_rows n fs_init) \\<in> carrier_mat n n\n 2. gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 3. distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "show \"?RAT (mat_of_rows n fs_init) \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n fs_init) \\<in> carrier_mat n n", "using len map_carrier_mat mat_of_rows_carrier(1) mn"], ["proof (prove)\nusing this:\n  length fs_init = m\n  (map_mat ?f ?A \\<in> carrier_mat ?nr ?nc) = (?A \\<in> carrier_mat ?nr ?nc)\n  mat_of_rows ?n ?vs \\<in> carrier_mat (length ?vs) ?n\n  m = n\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n fs_init) \\<in> carrier_mat n n", "by blast"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (mat_of_rows n fs_init) \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "have rw: \"Matrix.rows (?RAT (mat_of_rows n fs_init)) = RAT fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rows (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n    map of_int_hom.vec_hom fs_init", "by (metis cof_vec_space.lin_indpt_list_def fs_init lin_dep mat_of_rows_map rows_mat_of_rows)"], ["proof (state)\nthis:\n  rows (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  map of_int_hom.vec_hom fs_init\n\ngoal (2 subgoals):\n 1. gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "thus \"gs.lin_indpt (set (Matrix.rows (?RAT (mat_of_rows n fs_init))))\""], ["proof (prove)\nusing this:\n  rows (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  map of_int_hom.vec_hom fs_init\n\ngoal (1 subgoal):\n 1. gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "by (insert lin_dep, simp add: cof_vec_space.lin_indpt_list_def)"], ["proof (state)\nthis:\n  gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (1 subgoal):\n 1. distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "show \"distinct (Matrix.rows (?RAT (mat_of_rows n fs_init)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "using rw cof_vec_space.lin_indpt_list_def lin_dep"], ["proof (prove)\nusing this:\n  rows (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  map of_int_hom.vec_hom fs_init\n  cof_vec_space.lin_indpt_list ?n ?fs =\n  (set ?fs \\<subseteq> carrier_vec ?n \\<and>\n   distinct ?fs \\<and>\n   \\<not> module.lin_dep class_ring (module_vec TYPE(?'a) ?n) (set ?fs))\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs_init)\n\ngoal (1 subgoal):\n 1. distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "by auto"], ["proof (state)\nthis:\n  distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (of_int_hom.mat_hom (mat_of_rows n fs_init)) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))\n 2. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1", "hence d: \"det (?RAT (mat_of_rows n fs_init)) dvd 1\""], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom (mat_of_rows n fs_init)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_unit (det (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "using dvd_field_iff"], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom (mat_of_rows n fs_init)) \\<noteq> 0\n  (?a dvd ?b) = (?a = (0::?'a) \\<longrightarrow> ?b = (0::?'a))\n\ngoal (1 subgoal):\n 1. is_unit (det (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "by blast"], ["proof (state)\nthis:\n  is_unit (det (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n\ngoal (2 subgoals):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))\n 2. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1", "hence inv_RAT_fs_init: \"invertible_mat (?RAT (mat_of_rows n fs_init))\""], ["proof (prove)\nusing this:\n  is_unit (det (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n fs_init))", "using invertible_iff_is_unit_JNF"], ["proof (prove)\nusing this:\n  is_unit (det (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat ?A = (det ?A dvd (1::?'a))\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n fs_init))", "by (metis mn len map_carrier_mat mat_of_rows_carrier(1))"], ["proof (state)\nthis:\n  invertible_mat (of_int_hom.mat_hom (mat_of_rows n fs_init))\n\ngoal (2 subgoals):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))\n 2. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1", "have \"invertible_mat (?RAT P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom P)", "by (metis P dvd_field_iff inv_P invertible_iff_is_unit_JNF map_carrier_mat \n          not_is_unit_0 of_int_hom.hom_0 of_int_hom.hom_det)"], ["proof (state)\nthis:\n  invertible_mat (of_int_hom.mat_hom P)\n\ngoal (2 subgoals):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))\n 2. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1", "have \"det (?RAT (mat_of_rows n fs_init)) = det (?RAT P) * det (?RAT (mat_of_rows n gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n    det (of_int_hom.mat_hom P) * det (of_int_hom.mat_hom (mat_of_rows n gs))", "by (metis Determinant.det_mult P fs_P_gs gs_carrier of_int_hom.hom_det of_int_hom.hom_mult)"], ["proof (state)\nthis:\n  det (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  det (of_int_hom.mat_hom P) * det (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (2 subgoals):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))\n 2. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1", "hence \"det (?RAT (mat_of_rows n gs)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  det (of_int_hom.mat_hom P) * det (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom (mat_of_rows n gs)) \\<noteq> 0", "using d"], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  det (of_int_hom.mat_hom P) * det (of_int_hom.mat_hom (mat_of_rows n gs))\n  is_unit (det (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom (mat_of_rows n gs)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  det (of_int_hom.mat_hom (mat_of_rows n gs)) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))\n 2. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1", "thus \"invertible_mat (?RAT (mat_of_rows n gs))\""], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom (mat_of_rows n gs)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))", "by (meson dvd_field_iff gs_carrier invertible_iff_is_unit_JNF map_carrier_mat)"], ["proof (state)\nthis:\n  invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1", "show \"\\<exists>P1. P1 \\<in> carrier_mat n n \\<and> invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1", "using P1 P1_H1_2 inv_P1"], ["proof (prove)\nusing this:\n  P1 \\<in> carrier_mat n n\n  P * mat_of_rows n gs = P1 * H1\n  invertible_mat P1\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> carrier_mat n n \\<and>\n       invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1", "by blast"], ["proof (state)\nthis:\n  \\<exists>P1.\n     P1 \\<in> carrier_mat n n \\<and>\n     invertible_mat P1 \\<and> P * mat_of_rows n gs = P1 * H1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H1 = H2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma certification_via_eq_HNF2:\n  assumes sound_HNF: \"is_sound_HNF HNF associates res\"\n    and P1_H1: \"(P1,H1) = HNF (mat_of_rows n fs_init)\"\n    and P2_H2: \"(P2,H2) = HNF (mat_of_rows n gs)\"    \n    and gs: \"set gs \\<subseteq> carrier_vec n\" \n    and l: \"lattice_of fs_init = lattice_of gs\"\n    and mn: \"m = n\" and len_gs: \"length gs = n\" (*For the moment, only for square matrices*)\n  shows \"H1 = H2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H1 = H2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H1 = H2", "have \"\\<exists>P \\<in> carrier_mat n n. invertible_mat P \\<and> mat_of_rows n fs_init = P * mat_of_rows n gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>carrier_mat n n.\n       invertible_mat P \\<and> mat_of_rows n fs_init = P * mat_of_rows n gs", "by (rule eq_lattice_imp_mat_mult_invertible_rows[OF fs_init gs lin_dep len[unfolded mn] len_gs l])"], ["proof (state)\nthis:\n  \\<exists>P\\<in>carrier_mat n n.\n     invertible_mat P \\<and> mat_of_rows n fs_init = P * mat_of_rows n gs\n\ngoal (1 subgoal):\n 1. H1 = H2", "from this"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>carrier_mat n n.\n     invertible_mat P \\<and> mat_of_rows n fs_init = P * mat_of_rows n gs", "obtain P where P: \"P \\<in> carrier_mat n n\" and inv_P: \"invertible_mat P\"\n    and fs_P_gs: \"mat_of_rows n fs_init = P * mat_of_rows n gs\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>carrier_mat n n.\n     invertible_mat P \\<and> mat_of_rows n fs_init = P * mat_of_rows n gs\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> carrier_mat n n; invertible_mat P;\n         mat_of_rows n fs_init = P * mat_of_rows n gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n n\n  invertible_mat P\n  mat_of_rows n fs_init = P * mat_of_rows n gs\n\ngoal (1 subgoal):\n 1. H1 = H2", "have P1_H1_2: \"(P1,H1) = HNF (P * mat_of_rows n gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P1, H1) = HNF (P * mat_of_rows n gs)", "using fs_P_gs P1_H1"], ["proof (prove)\nusing this:\n  mat_of_rows n fs_init = P * mat_of_rows n gs\n  (P1, H1) = HNF (mat_of_rows n fs_init)\n\ngoal (1 subgoal):\n 1. (P1, H1) = HNF (P * mat_of_rows n gs)", "by auto"], ["proof (state)\nthis:\n  (P1, H1) = HNF (P * mat_of_rows n gs)\n\ngoal (1 subgoal):\n 1. H1 = H2", "have gs_carrier: \"mat_of_rows n gs \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n gs \\<in> carrier_mat n n", "by (simp add: len_gs carrier_matI)"], ["proof (state)\nthis:\n  mat_of_rows n gs \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. H1 = H2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. H1 = H2", "proof (rule HNF_A_eq_HNF_PA'[OF gs_carrier _ inv_P P sound_HNF P1_H1_2 P2_H2])"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))", "from inv_P"], ["proof (chain)\npicking this:\n  invertible_mat P", "obtain P' where PP': \"inverts_mat P P'\" and P'P: \"inverts_mat P' P\""], ["proof (prove)\nusing this:\n  invertible_mat P\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>inverts_mat P P'; inverts_mat P' P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using invertible_mat_def"], ["proof (prove)\nusing this:\n  invertible_mat P\n  invertible_mat ?A \\<equiv>\n  square_mat ?A \\<and>\n  (\\<exists>B. inverts_mat ?A B \\<and> inverts_mat B ?A)\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>inverts_mat P P'; inverts_mat P' P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inverts_mat P P'\n  inverts_mat P' P\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))", "let ?RAT = \"of_int_hom.mat_hom :: int mat \\<Rightarrow> rat mat\""], ["proof (state)\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))", "have det_RAT_fs_init: \"det (?RAT (mat_of_rows n fs_init)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom (mat_of_rows n fs_init)) \\<noteq> 0", "proof (rule gs.lin_indpt_rows_imp_det_not_0)"], ["proof (state)\ngoal (3 subgoals):\n 1. of_int_hom.mat_hom (mat_of_rows n fs_init) \\<in> carrier_mat n n\n 2. gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 3. distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "show \"?RAT (mat_of_rows n fs_init) \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n fs_init) \\<in> carrier_mat n n", "using len map_carrier_mat mat_of_rows_carrier(1) mn"], ["proof (prove)\nusing this:\n  length fs_init = m\n  (map_mat ?f ?A \\<in> carrier_mat ?nr ?nc) = (?A \\<in> carrier_mat ?nr ?nc)\n  mat_of_rows ?n ?vs \\<in> carrier_mat (length ?vs) ?n\n  m = n\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n fs_init) \\<in> carrier_mat n n", "by blast"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (mat_of_rows n fs_init) \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "have rw: \"Matrix.rows (?RAT (mat_of_rows n fs_init)) = RAT fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rows (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n    map of_int_hom.vec_hom fs_init", "by (metis cof_vec_space.lin_indpt_list_def fs_init lin_dep mat_of_rows_map rows_mat_of_rows)"], ["proof (state)\nthis:\n  rows (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  map of_int_hom.vec_hom fs_init\n\ngoal (2 subgoals):\n 1. gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "thus \"gs.lin_indpt (set (Matrix.rows (?RAT (mat_of_rows n fs_init))))\""], ["proof (prove)\nusing this:\n  rows (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  map of_int_hom.vec_hom fs_init\n\ngoal (1 subgoal):\n 1. gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "by (insert lin_dep, simp add: cof_vec_space.lin_indpt_list_def)"], ["proof (state)\nthis:\n  gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (1 subgoal):\n 1. distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "show \"distinct (Matrix.rows (?RAT (mat_of_rows n fs_init)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "using rw cof_vec_space.lin_indpt_list_def lin_dep"], ["proof (prove)\nusing this:\n  rows (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  map of_int_hom.vec_hom fs_init\n  cof_vec_space.lin_indpt_list ?n ?fs =\n  (set ?fs \\<subseteq> carrier_vec ?n \\<and>\n   distinct ?fs \\<and>\n   \\<not> module.lin_dep class_ring (module_vec TYPE(?'a) ?n) (set ?fs))\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs_init)\n\ngoal (1 subgoal):\n 1. distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "by auto"], ["proof (state)\nthis:\n  distinct (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (of_int_hom.mat_hom (mat_of_rows n fs_init)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))", "hence d: \"det (?RAT (mat_of_rows n fs_init)) dvd 1\""], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom (mat_of_rows n fs_init)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_unit (det (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "using dvd_field_iff"], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom (mat_of_rows n fs_init)) \\<noteq> 0\n  (?a dvd ?b) = (?a = (0::?'a) \\<longrightarrow> ?b = (0::?'a))\n\ngoal (1 subgoal):\n 1. is_unit (det (of_int_hom.mat_hom (mat_of_rows n fs_init)))", "by blast"], ["proof (state)\nthis:\n  is_unit (det (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))", "hence inv_RAT_fs_init: \"invertible_mat (?RAT (mat_of_rows n fs_init))\""], ["proof (prove)\nusing this:\n  is_unit (det (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n fs_init))", "using invertible_iff_is_unit_JNF"], ["proof (prove)\nusing this:\n  is_unit (det (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat ?A = (det ?A dvd (1::?'a))\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n fs_init))", "by (metis mn len map_carrier_mat mat_of_rows_carrier(1))"], ["proof (state)\nthis:\n  invertible_mat (of_int_hom.mat_hom (mat_of_rows n fs_init))\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))", "have \"invertible_mat (?RAT P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom P)", "by (metis P dvd_field_iff inv_P invertible_iff_is_unit_JNF map_carrier_mat \n          not_is_unit_0 of_int_hom.hom_0 of_int_hom.hom_det)"], ["proof (state)\nthis:\n  invertible_mat (of_int_hom.mat_hom P)\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))", "have \"det (?RAT (mat_of_rows n fs_init)) = det (?RAT P) * det (?RAT (mat_of_rows n gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n    det (of_int_hom.mat_hom P) * det (of_int_hom.mat_hom (mat_of_rows n gs))", "by (metis Determinant.det_mult P fs_P_gs gs_carrier of_int_hom.hom_det of_int_hom.hom_mult)"], ["proof (state)\nthis:\n  det (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  det (of_int_hom.mat_hom P) * det (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))", "hence \"det (?RAT (mat_of_rows n gs)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  det (of_int_hom.mat_hom P) * det (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom (mat_of_rows n gs)) \\<noteq> 0", "using d"], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  det (of_int_hom.mat_hom P) * det (of_int_hom.mat_hom (mat_of_rows n gs))\n  is_unit (det (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom (mat_of_rows n gs)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  det (of_int_hom.mat_hom (mat_of_rows n gs)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))", "thus \"invertible_mat (?RAT (mat_of_rows n gs))\""], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom (mat_of_rows n gs)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))", "by (meson dvd_field_iff gs_carrier invertible_iff_is_unit_JNF map_carrier_mat)"], ["proof (state)\nthis:\n  invertible_mat (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H1 = H2\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lattice_of_eq_via_HNF:\n  assumes sound_HNF: \"is_sound_HNF HNF associates res\"\n    and P1_H1: \"(P1,H1) = HNF (mat_of_rows n fs_init)\"\n    and P2_H2: \"(P2,H2) = HNF (mat_of_rows n gs)\"    \n    and gs: \"set gs \\<subseteq> carrier_vec n\"     \n    and mn: \"m = n\" and len_gs: \"length gs = n\"\n  shows \"(H1 = H2) \\<longleftrightarrow> (lattice_of fs_init = lattice_of gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (H1 = H2) = (lattice_of fs_init = lattice_of gs)", "using certification_via_eq_HNF certification_via_eq_HNF2 assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_sound_HNF ?HNF ?associates ?res;\n   (?P1.0, ?H1.0) = ?HNF (mat_of_rows n fs_init);\n   (?P2.0, ?H2.0) = ?HNF (mat_of_rows n ?gs); ?H1.0 = ?H2.0;\n   set ?gs \\<subseteq> carrier_vec n; length ?gs = m\\<rbrakk>\n  \\<Longrightarrow> lattice_of ?gs = lattice_of fs_init\n  \\<lbrakk>is_sound_HNF ?HNF ?associates ?res;\n   (?P1.0, ?H1.0) = ?HNF (mat_of_rows n fs_init);\n   (?P2.0, ?H2.0) = ?HNF (mat_of_rows n ?gs); ?H1.0 = ?H2.0;\n   set ?gs \\<subseteq> carrier_vec n; length ?gs = m\\<rbrakk>\n  \\<Longrightarrow> LLL_with_assms n m ?gs \\<alpha>\n  \\<lbrakk>is_sound_HNF ?HNF ?associates ?res;\n   (?P1.0, ?H1.0) = ?HNF (mat_of_rows n fs_init);\n   (?P2.0, ?H2.0) = ?HNF (mat_of_rows n ?gs);\n   set ?gs \\<subseteq> carrier_vec n; lattice_of fs_init = lattice_of ?gs;\n   m = n; length ?gs = n\\<rbrakk>\n  \\<Longrightarrow> ?H1.0 = ?H2.0\n  is_sound_HNF HNF associates res\n  (P1, H1) = HNF (mat_of_rows n fs_init)\n  (P2, H2) = HNF (mat_of_rows n gs)\n  set gs \\<subseteq> carrier_vec n\n  m = n\n  length gs = n\n\ngoal (1 subgoal):\n 1. (H1 = H2) = (lattice_of fs_init = lattice_of gs)", "by metis"], ["", "end"], ["", "context\nbegin"], ["", "interpretation vec_module \"TYPE(int)\" n"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lattice_of_eq_via_HNF_paper:\n  fixes F G :: \"int mat\" and HNF :: \"int mat \\<Rightarrow> int mat\"\n  assumes sound_HNF': \"is_sound_HNF' HNF \\<A> \\<R>\" (* HNF is a sound algorithm *)  \n    and inv_F_Q: \"invertible_mat (map_mat rat_of_int F)\" (* invertible over Q *)\n    and FG: \"{F,G} \\<subseteq> carrier_mat n n\"\n  shows \"(HNF F = HNF G) \\<longleftrightarrow> (lattice_of (rows F) = lattice_of (rows G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HNF F = HNF G) = (lattice_of (rows F) = lattice_of (rows G))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (HNF F = HNF G) = (lattice_of (rows F) = lattice_of (rows G))", "define HNF' \n    where \"HNF' = (\\<lambda>A. let H = HNF A \n    in (SOME P. P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and> invertible_mat P \\<and> A = P * H, H))\""], ["proof (state)\nthis:\n  HNF' =\n  (\\<lambda>A.\n      let H = HNF A\n      in (SOME P.\n             P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n             invertible_mat P \\<and> A = P * H,\n          H))\n\ngoal (1 subgoal):\n 1. (HNF F = HNF G) = (lattice_of (rows F) = lattice_of (rows G))", "have sound_HNF': \"is_sound_HNF HNF' \\<A> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sound_HNF HNF' \\<A> \\<R>", "by (unfold HNF'_def, rule is_sound_HNF_conv[OF sound_HNF'])"], ["proof (state)\nthis:\n  is_sound_HNF HNF' \\<A> \\<R>\n\ngoal (1 subgoal):\n 1. (HNF F = HNF G) = (lattice_of (rows F) = lattice_of (rows G))", "have F_eq: \"F = mat_of_rows n (rows F)\" and G_eq: \"G = mat_of_rows n (rows G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = mat_of_rows n (rows F) &&& G = mat_of_rows n (rows G)", "using FG"], ["proof (prove)\nusing this:\n  {F, G} \\<subseteq> carrier_mat n n\n\ngoal (1 subgoal):\n 1. F = mat_of_rows n (rows F) &&& G = mat_of_rows n (rows G)", "by auto"], ["proof (state)\nthis:\n  F = mat_of_rows n (rows F)\n  G = mat_of_rows n (rows G)\n\ngoal (1 subgoal):\n 1. (HNF F = HNF G) = (lattice_of (rows F) = lattice_of (rows G))", "interpret L: LLL_with_assms n n \"(rows F)\" \"4/3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_with_assms n n (rows F) (4 / 3)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. 4 / 3 \\<le> 4 / 3\n 2. cof_vec_space.lin_indpt_list n (map of_int_hom.vec_hom (rows F))\n 3. length (rows F) = n", "interpret gs: cof_vec_space n \"TYPE(rat)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (3 subgoals):\n 1. 4 / 3 \\<le> 4 / 3\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))\n 3. length (rows F) = n", "thm gs.upper_triangular_imp_lin_indpt_rows"], ["proof (state)\ngoal (3 subgoals):\n 1. 4 / 3 \\<le> 4 / 3\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))\n 3. length (rows F) = n", "let ?RAT =\"map_mat rat_of_int\""], ["proof (state)\ngoal (3 subgoals):\n 1. 4 / 3 \\<le> 4 / 3\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))\n 3. length (rows F) = n", "have m_rw: \"(map (map_vec rat_of_int) (rows F)) = rows (?RAT F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (rows F) = rows (of_int_hom.mat_hom F)", "unfolding Matrix.rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (map (row F) [0..<dim_row F]) =\n    map (row (of_int_hom.mat_hom F)) [0..<dim_row (of_int_hom.mat_hom F)]", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom (rows F) = rows (of_int_hom.mat_hom F)\n\ngoal (3 subgoals):\n 1. 4 / 3 \\<le> 4 / 3\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))\n 3. length (rows F) = n", "show \"gs.lin_indpt_list (map (map_vec rat_of_int) (rows F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))", "have det_RAT_F: \"det (?RAT F) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom F) \\<noteq> 0", "by (metis inv_F_Q carrier_mat_triv invertible_iff_is_unit_JNF \n            invertible_mat_def not_is_unit_0 square_mat.simps)"], ["proof (state)\nthis:\n  det (of_int_hom.mat_hom F) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))", "have d_RAT_F: \"distinct (rows (?RAT F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (rows (of_int_hom.mat_hom F))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (rows (of_int_hom.mat_hom F)) \\<Longrightarrow> False", "assume \"\\<not> distinct (rows (?RAT F))\""], ["proof (state)\nthis:\n  \\<not> distinct (rows (of_int_hom.mat_hom F))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (rows (of_int_hom.mat_hom F)) \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> distinct (rows (of_int_hom.mat_hom F))", "obtain i j \n          where ij: \"row (?RAT F) i = row (?RAT F) j\"\n            and i: \"i<dim_row (?RAT F)\" and j: \"j<dim_row (?RAT F)\" \n            and i_not_j: \"i\\<noteq>j\""], ["proof (prove)\nusing this:\n  \\<not> distinct (rows (of_int_hom.mat_hom F))\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>row (of_int_hom.mat_hom F) i =\n                 row (of_int_hom.mat_hom F) j;\n         i < dim_row (of_int_hom.mat_hom F);\n         j < dim_row (of_int_hom.mat_hom F); i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Matrix.rows_def distinct_conv_nth"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i<length\n                      (map (row (of_int_hom.mat_hom F))\n                        [0..<dim_row (of_int_hom.mat_hom F)]).\n             \\<forall>j<length\n                         (map (row (of_int_hom.mat_hom F))\n                           [0..<dim_row (of_int_hom.mat_hom F)]).\n                i \\<noteq> j \\<longrightarrow>\n                map (row (of_int_hom.mat_hom F))\n                 [0..<dim_row (of_int_hom.mat_hom F)] !\n                i \\<noteq>\n                map (row (of_int_hom.mat_hom F))\n                 [0..<dim_row (of_int_hom.mat_hom F)] !\n                j)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>row (of_int_hom.mat_hom F) i =\n                 row (of_int_hom.mat_hom F) j;\n         i < dim_row (of_int_hom.mat_hom F);\n         j < dim_row (of_int_hom.mat_hom F); i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  row (of_int_hom.mat_hom F) i = row (of_int_hom.mat_hom F) j\n  i < dim_row (of_int_hom.mat_hom F)\n  j < dim_row (of_int_hom.mat_hom F)\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<not> distinct (rows (of_int_hom.mat_hom F)) \\<Longrightarrow> False", "have \"det (?RAT F) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom F) = 0", "using ij i j i_not_j"], ["proof (prove)\nusing this:\n  row (of_int_hom.mat_hom F) i = row (of_int_hom.mat_hom F) j\n  i < dim_row (of_int_hom.mat_hom F)\n  j < dim_row (of_int_hom.mat_hom F)\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom F) = 0", "by (metis Determinant.det_def Determinant.det_identical_rows carrier_mat_triv)"], ["proof (state)\nthis:\n  det (of_int_hom.mat_hom F) = 0\n\ngoal (1 subgoal):\n 1. \\<not> distinct (rows (of_int_hom.mat_hom F)) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom F) = 0\n\ngoal (1 subgoal):\n 1. False", "using inv_F_Q"], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom F) = 0\n  invertible_mat (of_int_hom.mat_hom F)\n\ngoal (1 subgoal):\n 1. False", "by (metis carrier_mat_triv invertible_iff_is_unit_JNF invertible_mat_def \n              not_is_unit_0 square_mat.simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (rows (of_int_hom.mat_hom F))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))", "moreover"], ["proof (state)\nthis:\n  distinct (rows (of_int_hom.mat_hom F))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))", "have \"\\<not> gs.lin_dep (set (rows (?RAT F)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt (set (rows (of_int_hom.mat_hom F)))", "using gs.det_not_0_imp_lin_indpt_rows[OF _ det_RAT_F]"], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom F \\<in> carrier_mat n n \\<Longrightarrow>\n  gs.lin_indpt (set (rows (of_int_hom.mat_hom F)))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt (set (rows (of_int_hom.mat_hom F)))", "using FG"], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom F \\<in> carrier_mat n n \\<Longrightarrow>\n  gs.lin_indpt (set (rows (of_int_hom.mat_hom F)))\n  {F, G} \\<subseteq> carrier_mat n n\n\ngoal (1 subgoal):\n 1. gs.lin_indpt (set (rows (of_int_hom.mat_hom F)))", "by auto"], ["proof (state)\nthis:\n  gs.lin_indpt (set (rows (of_int_hom.mat_hom F)))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))", "ultimately"], ["proof (chain)\npicking this:\n  distinct (rows (of_int_hom.mat_hom F))\n  gs.lin_indpt (set (rows (of_int_hom.mat_hom F)))", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (rows (of_int_hom.mat_hom F))\n  gs.lin_indpt (set (rows (of_int_hom.mat_hom F)))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))", "unfolding gs.lin_indpt_list_def m_rw"], ["proof (prove)\nusing this:\n  distinct (rows (of_int_hom.mat_hom F))\n  gs.lin_indpt (set (rows (of_int_hom.mat_hom F)))\n\ngoal (1 subgoal):\n 1. set (rows (of_int_hom.mat_hom F)) \\<subseteq> carrier_vec n \\<and>\n    distinct (rows (of_int_hom.mat_hom F)) \\<and>\n    gs.lin_indpt (set (rows (of_int_hom.mat_hom F)))", "using FG"], ["proof (prove)\nusing this:\n  distinct (rows (of_int_hom.mat_hom F))\n  gs.lin_indpt (set (rows (of_int_hom.mat_hom F)))\n  {F, G} \\<subseteq> carrier_mat n n\n\ngoal (1 subgoal):\n 1. set (rows (of_int_hom.mat_hom F)) \\<subseteq> carrier_vec n \\<and>\n    distinct (rows (of_int_hom.mat_hom F)) \\<and>\n    gs.lin_indpt (set (rows (of_int_hom.mat_hom F)))", "unfolding Matrix.rows_def"], ["proof (prove)\nusing this:\n  distinct\n   (map (row (of_int_hom.mat_hom F)) [0..<dim_row (of_int_hom.mat_hom F)])\n  gs.lin_indpt\n   (set (map (row (of_int_hom.mat_hom F))\n          [0..<dim_row (of_int_hom.mat_hom F)]))\n  {F, G} \\<subseteq> carrier_mat n n\n\ngoal (1 subgoal):\n 1. set (map (row (of_int_hom.mat_hom F))\n          [0..<dim_row (of_int_hom.mat_hom F)])\n    \\<subseteq> carrier_vec n \\<and>\n    distinct\n     (map (row (of_int_hom.mat_hom F))\n       [0..<dim_row (of_int_hom.mat_hom F)]) \\<and>\n    gs.lin_indpt\n     (set (map (row (of_int_hom.mat_hom F))\n            [0..<dim_row (of_int_hom.mat_hom F)]))", "by auto"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom (rows F))\n\ngoal (2 subgoals):\n 1. 4 / 3 \\<le> 4 / 3\n 2. length (rows F) = n", "qed (insert FG F_eq, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. (HNF F = HNF G) = (lattice_of (rows F) = lattice_of (rows G))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HNF F = HNF G) = (lattice_of (rows F) = lattice_of (rows G))", "proof (rule L.lattice_of_eq_via_HNF[OF sound_HNF'])"], ["proof (state)\ngoal (5 subgoals):\n 1. (?P1.0, HNF F) = HNF' (mat_of_rows n (rows F))\n 2. (?P2.0, HNF G) = HNF' (mat_of_rows n (rows G))\n 3. set (rows G) \\<subseteq> carrier_vec n\n 4. n = n\n 5. length (rows G) = n", "show \"(fst (HNF' F), HNF F) = HNF' (mat_of_rows n (rows F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (HNF' F), HNF F) = HNF' (mat_of_rows n (rows F))", "unfolding HNF'_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (SOME P.\n             P \\<in> carrier_mat (dim_row F) (dim_row F) \\<and>\n             invertible_mat P \\<and> F = P * HNF F,\n          HNF F),\n     HNF F) =\n    (SOME P.\n        P \\<in> carrier_mat (dim_row (mat_of_rows n (rows F)))\n                 (dim_row (mat_of_rows n (rows F))) \\<and>\n        invertible_mat P \\<and>\n        mat_of_rows n (rows F) = P * HNF (mat_of_rows n (rows F)),\n     HNF (mat_of_rows n (rows F)))", "using F_eq"], ["proof (prove)\nusing this:\n  F = mat_of_rows n (rows F)\n\ngoal (1 subgoal):\n 1. (fst (SOME P.\n             P \\<in> carrier_mat (dim_row F) (dim_row F) \\<and>\n             invertible_mat P \\<and> F = P * HNF F,\n          HNF F),\n     HNF F) =\n    (SOME P.\n        P \\<in> carrier_mat (dim_row (mat_of_rows n (rows F)))\n                 (dim_row (mat_of_rows n (rows F))) \\<and>\n        invertible_mat P \\<and>\n        mat_of_rows n (rows F) = P * HNF (mat_of_rows n (rows F)),\n     HNF (mat_of_rows n (rows F)))", "by auto"], ["proof (state)\nthis:\n  (fst (HNF' F), HNF F) = HNF' (mat_of_rows n (rows F))\n\ngoal (4 subgoals):\n 1. (?P2.0, HNF G) = HNF' (mat_of_rows n (rows G))\n 2. set (rows G) \\<subseteq> carrier_vec n\n 3. n = n\n 4. length (rows G) = n", "show \"(fst (HNF' G), HNF G) = HNF' (mat_of_rows n (rows G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (HNF' G), HNF G) = HNF' (mat_of_rows n (rows G))", "unfolding HNF'_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (SOME P.\n             P \\<in> carrier_mat (dim_row G) (dim_row G) \\<and>\n             invertible_mat P \\<and> G = P * HNF G,\n          HNF G),\n     HNF G) =\n    (SOME P.\n        P \\<in> carrier_mat (dim_row (mat_of_rows n (rows G)))\n                 (dim_row (mat_of_rows n (rows G))) \\<and>\n        invertible_mat P \\<and>\n        mat_of_rows n (rows G) = P * HNF (mat_of_rows n (rows G)),\n     HNF (mat_of_rows n (rows G)))", "using G_eq"], ["proof (prove)\nusing this:\n  G = mat_of_rows n (rows G)\n\ngoal (1 subgoal):\n 1. (fst (SOME P.\n             P \\<in> carrier_mat (dim_row G) (dim_row G) \\<and>\n             invertible_mat P \\<and> G = P * HNF G,\n          HNF G),\n     HNF G) =\n    (SOME P.\n        P \\<in> carrier_mat (dim_row (mat_of_rows n (rows G)))\n                 (dim_row (mat_of_rows n (rows G))) \\<and>\n        invertible_mat P \\<and>\n        mat_of_rows n (rows G) = P * HNF (mat_of_rows n (rows G)),\n     HNF (mat_of_rows n (rows G)))", "by auto"], ["proof (state)\nthis:\n  (fst (HNF' G), HNF G) = HNF' (mat_of_rows n (rows G))\n\ngoal (3 subgoals):\n 1. set (rows G) \\<subseteq> carrier_vec n\n 2. n = n\n 3. length (rows G) = n", "show \"length (rows G) = n \""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rows G) = n", "using FG"], ["proof (prove)\nusing this:\n  {F, G} \\<subseteq> carrier_mat n n\n\ngoal (1 subgoal):\n 1. length (rows G) = n", "by auto"], ["proof (state)\nthis:\n  length (rows G) = n\n\ngoal (2 subgoals):\n 1. set (rows G) \\<subseteq> carrier_vec n\n 2. n = n", "show \"set (rows G) \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rows G) \\<subseteq> carrier_vec n", "using FG"], ["proof (prove)\nusing this:\n  {F, G} \\<subseteq> carrier_mat n n\n\ngoal (1 subgoal):\n 1. set (rows G) \\<subseteq> carrier_vec n", "by (metis G_eq mat_of_rows_carrier(3) rows_carrier)"], ["proof (state)\nthis:\n  set (rows G) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. n = n", "qed (simp)"], ["proof (state)\nthis:\n  (HNF F = HNF G) = (lattice_of (rows F) = lattice_of (rows G))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>We define a new const similar to @{text \"external_lll_solver\"},\nbut now it only returns the reduced matrix.\\<close>"], ["", "consts external_lll_solver' :: \"integer \\<times> integer \\<Rightarrow> integer list list \\<Rightarrow> integer list list\""], ["", "hide_type (open) Finite_Cartesian_Product.vec"], ["", "text \\<open>The following definition is an adaptation of @{text \"reduce_basis_external\"}\\<close>"], ["", "definition reduce_basis_external' :: \"(int mat \\<Rightarrow> int mat) \\<Rightarrow> rat \\<Rightarrow> int vec list \\<Rightarrow> int vec list\" where\n  \"reduce_basis_external' HNF \\<alpha> fs = (case fs of Nil \\<Rightarrow> [] | Cons f _ \\<Rightarrow> (let \n    rb = reduce_basis \\<alpha>;\n    fsi = map (map integer_of_int o list_of_vec) fs;\n    n = dim_vec f;\n    m = length fs;\n    gsi = external_lll_solver' (map_prod integer_of_int integer_of_int (quotient_of \\<alpha>)) fsi;\n    gs = (map (vec_of_list o map int_of_integer) gsi) in\n    if \\<not> (length gs = m \\<and> (\\<forall> gi \\<in> set gs. dim_vec gi = n)) then\n      Code.abort (STR ''error in external LLL invocation: dimensions of reduced basis do not fit\\<newline>input to external solver: ''\n        + String.implode (show fs) + STR ''\\<newline>\\<newline>'') (\\<lambda> _. rb fs)\n     else \n      let Fs = mat_of_rows n fs;\n          Gs = mat_of_rows n gs;\n          H1 = HNF Fs;\n          H2 = HNF Gs in \n           if (H1 = H2) then rb gs \n          else Code.abort (STR ''the reduced matrix does not span the same lattice\\<newline>f,g,P1,P2,H1,H2 are as follows\\<newline>''\n            + String.implode (show Fs) + STR ''\\<newline>\\<newline>''\n            + String.implode (show Gs) + STR ''\\<newline>\\<newline>''\n            + String.implode (show H1) + STR ''\\<newline>\\<newline>''\n            + String.implode (show H2) + STR ''\\<newline>\\<newline>''\n            ) (\\<lambda> _. rb fs))\n    )\""], ["", "locale certification = LLL_with_assms +\n  fixes HNF::\"int mat \\<Rightarrow> int mat\" and associates res (*HNF operation without explicit transformation matrix*)\n  assumes sound_HNF': \"is_sound_HNF' HNF associates res\"\nbegin"], ["", "lemma reduce_basis_external': assumes res: \"reduce_basis_external' HNF \\<alpha> fs_init = fs\" \n  shows \"reduced fs m\" \"LLL_invariant True m fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m &&&\n    LLL_invariant True m fs", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "proof (cases \"LLL_Impl.reduce_basis \\<alpha> fs_init = fs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init = fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "case True"], ["proof (state)\nthis:\n  LLL_Impl.reduce_basis \\<alpha> fs_init = fs\n\ngoal (2 subgoals):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init = fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "from reduce_basis[OF this]"], ["proof (chain)\npicking this:\n  lattice_of fs = L\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = m\n  LLL_invariant True m fs", "show ?thesis"], ["proof (prove)\nusing this:\n  lattice_of fs = L\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = m\n  LLL_invariant True m fs\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "by simp"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  LLL_invariant True m fs\n\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "case False"], ["proof (state)\nthis:\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "note a = False"], ["proof (state)\nthis:\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "proof (cases fs_init)"], ["proof (state)\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "case Nil"], ["proof (state)\nthis:\n  fs_init = []\n\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "with res"], ["proof (chain)\npicking this:\n  reduce_basis_external' HNF \\<alpha> fs_init = fs\n  fs_init = []", "have \"fs = []\""], ["proof (prove)\nusing this:\n  reduce_basis_external' HNF \\<alpha> fs_init = fs\n  fs_init = []\n\ngoal (1 subgoal):\n 1. fs = []", "unfolding reduce_basis_external'_def"], ["proof (prove)\nusing this:\n  (case fs_init of [] \\<Rightarrow> []\n   | f # x \\<Rightarrow>\n       let rb = LLL_Impl.reduce_basis \\<alpha>;\n           fsi = map (map integer_of_int \\<circ> list_of_vec) fs_init;\n           n = dim_vec f; m = length fs_init;\n           gsi =\n             external_lll_solver'\n              (map_prod integer_of_int integer_of_int\n                (quotient_of \\<alpha>))\n              fsi;\n           gs = map (vec_of_list \\<circ> map int_of_integer) gsi\n       in if \\<not> (length gs = m \\<and>\n                     (\\<forall>gi\\<in>set gs. dim_vec gi = n))\n          then Code.abort\n                (STR ''error in external LLL invocation: dimensions of reduced basis do not fit\\<newline>input to external solver: '' +\n                 String.implode (show fs_init) +\n                 STR ''\\<newline>\\<newline>'')\n                (\\<lambda>_. rb fs_init)\n          else let Fs = mat_of_rows n fs_init; Gs = mat_of_rows n gs;\n                   H1 = HNF Fs; H2 = HNF Gs\n               in if H1 = H2 then rb gs\n                  else Code.abort\n                        (STR ''the reduced matrix does not span the same lattice\\<newline>f,g,P1,P2,H1,H2 are as follows\\<newline>'' +\n                         String.implode (show Fs) +\n                         STR ''\\<newline>\\<newline>'' +\n                         String.implode (show Gs) +\n                         STR ''\\<newline>\\<newline>'' +\n                         String.implode (show H1) +\n                         STR ''\\<newline>\\<newline>'' +\n                         String.implode (show H2) +\n                         STR ''\\<newline>\\<newline>'')\n                        (\\<lambda>_. rb fs_init)) =\n  fs\n  fs_init = []\n\ngoal (1 subgoal):\n 1. fs = []", "by auto"], ["proof (state)\nthis:\n  fs = []\n\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "with False Nil"], ["proof (chain)\npicking this:\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n  fs_init = []\n  fs = []", "have False"], ["proof (prove)\nusing this:\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n  fs_init = []\n  fs = []\n\ngoal (1 subgoal):\n 1. False", "by (simp add: LLL_Impl.reduce_basis_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", ".."], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  LLL_invariant True m fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "case (Cons f rest)"], ["proof (state)\nthis:\n  fs_init = f # rest\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "from Cons fs_init len"], ["proof (chain)\npicking this:\n  fs_init = f # rest\n  set fs_init \\<subseteq> carrier_vec n\n  length fs_init = m", "have dim_fs_n: \"dim_vec f = n\""], ["proof (prove)\nusing this:\n  fs_init = f # rest\n  set fs_init \\<subseteq> carrier_vec n\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. dim_vec f = n", "by auto"], ["proof (state)\nthis:\n  dim_vec f = n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "let ?ext = \"external_lll_solver' (map_prod integer_of_int integer_of_int (quotient_of \\<alpha>)) \n        (map (map integer_of_int \\<circ> list_of_vec) fs_init)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "note res = res[unfolded reduce_basis_external'_def Cons Let_def list.case Code.abort_def dim_fs_n,\n          folded Cons]"], ["proof (state)\nthis:\n  (if \\<not> (length\n               (map (vec_of_list \\<circ> map int_of_integer)\n                 (external_lll_solver'\n                   (map_prod integer_of_int integer_of_int\n                     (quotient_of \\<alpha>))\n                   (map (map integer_of_int \\<circ> list_of_vec)\n                     fs_init))) =\n              length fs_init \\<and>\n              (\\<forall>gi\\<in>set (map (vec_of_list \\<circ>\n   map int_of_integer)\n                                     (external_lll_solver'\n (map_prod integer_of_int integer_of_int (quotient_of \\<alpha>))\n (map (map integer_of_int \\<circ> list_of_vec) fs_init))).\n                  dim_vec gi = n))\n   then LLL_Impl.reduce_basis \\<alpha> fs_init\n   else if HNF (mat_of_rows n fs_init) =\n           HNF (mat_of_rows n\n                 (map (vec_of_list \\<circ> map int_of_integer)\n                   (external_lll_solver'\n                     (map_prod integer_of_int integer_of_int\n                       (quotient_of \\<alpha>))\n                     (map (map integer_of_int \\<circ> list_of_vec)\n                       fs_init))))\n        then LLL_Impl.reduce_basis \\<alpha>\n              (map (vec_of_list \\<circ> map int_of_integer)\n                (external_lll_solver'\n                  (map_prod integer_of_int integer_of_int\n                    (quotient_of \\<alpha>))\n                  (map (map integer_of_int \\<circ> list_of_vec) fs_init)))\n        else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "define gs where \"gs = map (vec_of_list o map int_of_integer) ?ext\""], ["proof (state)\nthis:\n  gs =\n  map (vec_of_list \\<circ> map int_of_integer)\n   (external_lll_solver'\n     (map_prod integer_of_int integer_of_int (quotient_of \\<alpha>))\n     (map (map integer_of_int \\<circ> list_of_vec) fs_init))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "define Fs where \"Fs = mat_of_rows n fs_init\""], ["proof (state)\nthis:\n  Fs = mat_of_rows n fs_init\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "define Gs where \"Gs = mat_of_rows n gs\""], ["proof (state)\nthis:\n  Gs = mat_of_rows n gs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "define H1 where \"H1 = HNF Fs\""], ["proof (state)\nthis:\n  H1 = HNF Fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "define H2 where \"H2 = HNF Gs\""], ["proof (state)\nthis:\n  H2 = HNF Gs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "note res = res[unfolded ext option.simps split len dim_fs_n, folded gs_def]"], ["proof (state)\nthis:\n  (if \\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))\n   then LLL_Impl.reduce_basis \\<alpha> fs_init\n   else if HNF (mat_of_rows n fs_init) = HNF (mat_of_rows n gs)\n        then LLL_Impl.reduce_basis \\<alpha> gs\n        else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "from res False"], ["proof (chain)\npicking this:\n  (if \\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))\n   then LLL_Impl.reduce_basis \\<alpha> fs_init\n   else if HNF (mat_of_rows n fs_init) = HNF (mat_of_rows n gs)\n        then LLL_Impl.reduce_basis \\<alpha> gs\n        else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs", "have not: \"(\\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))) = False\""], ["proof (prove)\nusing this:\n  (if \\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))\n   then LLL_Impl.reduce_basis \\<alpha> fs_init\n   else if HNF (mat_of_rows n fs_init) = HNF (mat_of_rows n gs)\n        then LLL_Impl.reduce_basis \\<alpha> gs\n        else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n\ngoal (1 subgoal):\n 1. (\\<not> (length gs = m \\<and>\n             (\\<forall>gi\\<in>set gs. dim_vec gi = n))) =\n    False", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  (\\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))) =\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "note res = res[unfolded this if_False]"], ["proof (state)\nthis:\n  (if HNF (mat_of_rows n fs_init) = HNF (mat_of_rows n gs)\n   then LLL_Impl.reduce_basis \\<alpha> gs\n   else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "from not"], ["proof (chain)\npicking this:\n  (\\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))) =\n  False", "have gs: \"set gs \\<subseteq> carrier_vec n\" \n        and len_gs: \"length gs = m\""], ["proof (prove)\nusing this:\n  (\\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))) =\n  False\n\ngoal (1 subgoal):\n 1. set gs \\<subseteq> carrier_vec n &&& length gs = m", "by auto"], ["proof (state)\nthis:\n  set gs \\<subseteq> carrier_vec n\n  length gs = m\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "proof (cases \"H1 = H2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. H1 = H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "case True"], ["proof (state)\nthis:\n  H1 = H2\n\ngoal (2 subgoals):\n 1. H1 = H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "hence H1_eq_H2: \"H1 = H2\""], ["proof (prove)\nusing this:\n  H1 = H2\n\ngoal (1 subgoal):\n 1. H1 = H2", "by auto"], ["proof (state)\nthis:\n  H1 = H2\n\ngoal (2 subgoals):\n 1. H1 = H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "let ?HNF = \"(\\<lambda>A. let H = HNF A in (SOME P. P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and> invertible_mat P \\<and> A = P * H, H))\""], ["proof (state)\ngoal (2 subgoals):\n 1. H1 = H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "obtain P1 where P1_H1: \"(P1,H1) = ?HNF Fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        (P1, H1) =\n        (let H = HNF Fs\n         in (SOME P.\n                P \\<in> carrier_mat (dim_row Fs) (dim_row Fs) \\<and>\n                invertible_mat P \\<and> Fs = P * H,\n             H)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis H1_def)"], ["proof (state)\nthis:\n  (P1, H1) =\n  (let H = HNF Fs\n   in (SOME P.\n          P \\<in> carrier_mat (dim_row Fs) (dim_row Fs) \\<and>\n          invertible_mat P \\<and> Fs = P * H,\n       H))\n\ngoal (2 subgoals):\n 1. H1 = H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "obtain P2 where P2_H2: \"(P2,H2) = ?HNF Gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P2.\n        (P2, H2) =\n        (let H = HNF Gs\n         in (SOME P.\n                P \\<in> carrier_mat (dim_row Gs) (dim_row Gs) \\<and>\n                invertible_mat P \\<and> Gs = P * H,\n             H)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis H2_def)"], ["proof (state)\nthis:\n  (P2, H2) =\n  (let H = HNF Gs\n   in (SOME P.\n          P \\<in> carrier_mat (dim_row Gs) (dim_row Gs) \\<and>\n          invertible_mat P \\<and> Gs = P * H,\n       H))\n\ngoal (2 subgoals):\n 1. H1 = H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "have sound_HNF: \"is_sound_HNF ?HNF associates res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sound_HNF\n     (\\<lambda>A.\n         let H = HNF A\n         in (SOME P.\n                P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n                invertible_mat P \\<and> A = P * H,\n             H))\n     associates res", "by (rule is_sound_HNF_conv[OF sound_HNF'])"], ["proof (state)\nthis:\n  is_sound_HNF\n   (\\<lambda>A.\n       let H = HNF A\n       in (SOME P.\n              P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n              invertible_mat P \\<and> A = P * H,\n           H))\n   associates res\n\ngoal (2 subgoals):\n 1. H1 = H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "have laticce_gs_fs_init: \"lattice_of gs = lattice_of fs_init\" \n          and gs_assms: \"LLL_with_assms n m gs \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs_init &&& LLL_with_assms n m gs \\<alpha>", "by (rule certification_via_eq_HNF[OF sound_HNF P1_H1[unfolded Fs_def] \n                P2_H2[unfolded Gs_def] H1_eq_H2 gs len_gs])+"], ["proof (state)\nthis:\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n\ngoal (2 subgoals):\n 1. H1 = H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "from res a True"], ["proof (chain)\npicking this:\n  (if HNF (mat_of_rows n fs_init) = HNF (mat_of_rows n gs)\n   then LLL_Impl.reduce_basis \\<alpha> gs\n   else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n  H1 = H2", "have gs_fs:  \"LLL_Impl.reduce_basis \\<alpha> gs = fs\""], ["proof (prove)\nusing this:\n  (if HNF (mat_of_rows n fs_init) = HNF (mat_of_rows n gs)\n   then LLL_Impl.reduce_basis \\<alpha> gs\n   else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n  H1 = H2\n\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> gs = fs", "by (auto split:  prod.split)"], ["proof (state)\nthis:\n  LLL_Impl.reduce_basis \\<alpha> gs = fs\n\ngoal (2 subgoals):\n 1. H1 = H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "have lattice_gs_fs: \"lattice_of gs = lattice_of fs\" \n          and \"gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\" \n          and \"gs.lin_indpt_list (map of_int_hom.vec_hom fs)\"\n          and \"length fs = length gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lattice_of gs = lattice_of fs &&&\n     gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m) &&&\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) &&& length fs = length gs", "using LLL_with_assms.reduce_basis gs_fs gs_assms laticce_gs_fs_init gs_assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> vec_module.lattice_of ?n ?fs = LLL.L ?n ?fs_init\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.reduced ?n (map of_int_hom.vec_hom ?fs)\n                     ?\\<alpha> ?m\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> cof_vec_space.lin_indpt_list ?n\n                     (map of_int_hom.vec_hom ?fs)\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> length ?fs = ?m\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> LLL.LLL_invariant ?n ?m ?fs_init ?\\<alpha> True ?m ?fs\n  LLL_Impl.reduce_basis \\<alpha> gs = fs\n  LLL_with_assms n m gs \\<alpha>\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n\ngoal (1 subgoal):\n 1. (lattice_of gs = lattice_of fs &&&\n     gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m) &&&\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) &&& length fs = length gs", "using LLL_with_assms_def len_gs"], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> vec_module.lattice_of ?n ?fs = LLL.L ?n ?fs_init\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.reduced ?n (map of_int_hom.vec_hom ?fs)\n                     ?\\<alpha> ?m\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> cof_vec_space.lin_indpt_list ?n\n                     (map of_int_hom.vec_hom ?fs)\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> length ?fs = ?m\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> LLL.LLL_invariant ?n ?m ?fs_init ?\\<alpha> True ?m ?fs\n  LLL_Impl.reduce_basis \\<alpha> gs = fs\n  LLL_with_assms n m gs \\<alpha>\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n  LLL_with_assms ?n ?m ?fs_init ?\\<alpha> \\<equiv>\n  4 / 3 \\<le> ?\\<alpha> \\<and>\n  cof_vec_space.lin_indpt_list ?n (map of_int_hom.vec_hom ?fs_init) \\<and>\n  length ?fs_init = ?m\n  length gs = m\n\ngoal (1 subgoal):\n 1. (lattice_of gs = lattice_of fs &&&\n     gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m) &&&\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) &&& length fs = length gs", "unfolding LLL.L_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> vec_module.lattice_of ?n ?fs =\n                    vec_module.lattice_of ?n ?fs_init\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.reduced ?n (map of_int_hom.vec_hom ?fs)\n                     ?\\<alpha> ?m\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> cof_vec_space.lin_indpt_list ?n\n                     (map of_int_hom.vec_hom ?fs)\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> length ?fs = ?m\n  \\<lbrakk>LLL_with_assms ?n ?m ?fs_init ?\\<alpha>;\n   LLL_Impl.reduce_basis ?\\<alpha> ?fs_init = ?fs\\<rbrakk>\n  \\<Longrightarrow> LLL.LLL_invariant ?n ?m ?fs_init ?\\<alpha> True ?m ?fs\n  LLL_Impl.reduce_basis \\<alpha> gs = fs\n  LLL_with_assms n m gs \\<alpha>\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n  LLL_with_assms ?n ?m ?fs_init ?\\<alpha> \\<equiv>\n  4 / 3 \\<le> ?\\<alpha> \\<and>\n  cof_vec_space.lin_indpt_list ?n (map of_int_hom.vec_hom ?fs_init) \\<and>\n  length ?fs_init = ?m\n  length gs = m\n\ngoal (1 subgoal):\n 1. (lattice_of gs = lattice_of fs &&&\n     gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m) &&&\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) &&& length fs = length gs", "by fast+"], ["proof (state)\nthis:\n  lattice_of gs = lattice_of fs\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = length gs\n\ngoal (2 subgoals):\n 1. H1 = H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "from this"], ["proof (chain)\npicking this:\n  lattice_of gs = lattice_of fs\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = length gs", "show ?thesis"], ["proof (prove)\nusing this:\n  lattice_of gs = lattice_of fs\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = length gs\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "using laticce_gs_fs_init gs_assms LLL_with_assms_def lattice_gs_fs"], ["proof (prove)\nusing this:\n  lattice_of gs = lattice_of fs\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = length gs\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n  LLL_with_assms ?n ?m ?fs_init ?\\<alpha> \\<equiv>\n  4 / 3 \\<le> ?\\<alpha> \\<and>\n  cof_vec_space.lin_indpt_list ?n (map of_int_hom.vec_hom ?fs_init) \\<and>\n  length ?fs_init = ?m\n  lattice_of gs = lattice_of fs\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "unfolding LLL_invariant_def L_def"], ["proof (prove)\nusing this:\n  lattice_of gs = lattice_of fs\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = length gs\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n  LLL_with_assms ?n ?m ?fs_init ?\\<alpha> \\<equiv>\n  4 / 3 \\<le> ?\\<alpha> \\<and>\n  cof_vec_space.lin_indpt_list ?n (map of_int_hom.vec_hom ?fs_init) \\<and>\n  length ?fs_init = ?m\n  lattice_of gs = lattice_of fs\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n    lattice_of fs = lattice_of fs_init \\<and>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    m \\<le> m \\<and> length fs = m \\<and> (True \\<or> \\<mu>_small fs m)", "by auto"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  LLL_invariant True m fs\n\ngoal (1 subgoal):\n 1. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "case False"], ["proof (state)\nthis:\n  H1 \\<noteq> H2\n\ngoal (1 subgoal):\n 1. H1 \\<noteq> H2 \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "then"], ["proof (chain)\npicking this:\n  H1 \\<noteq> H2", "show ?thesis"], ["proof (prove)\nusing this:\n  H1 \\<noteq> H2\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "using a Fs_def Gs_def res H1_def H2_def"], ["proof (prove)\nusing this:\n  H1 \\<noteq> H2\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n  Fs = mat_of_rows n fs_init\n  Gs = mat_of_rows n gs\n  (if HNF (mat_of_rows n fs_init) = HNF (mat_of_rows n gs)\n   then LLL_Impl.reduce_basis \\<alpha> gs\n   else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  H1 = HNF Fs\n  H2 = HNF Gs\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "by auto"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  LLL_invariant True m fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  LLL_invariant True m fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  LLL_invariant True m fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  LLL_invariant True m fs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context LLL_with_assms\nbegin"], ["", "text \\<open>We interpret the certification context using our formalized @{text \"HNF_algorithm\"}\\<close>"], ["", "interpretation efficient_cert: certification n m fs_init \\<alpha> \"HNF_algorithm use_sym_mod\" \"range ass_function_euclidean\" \"\\<lambda>c. range (res_int c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. certification n m fs_init \\<alpha> (HNF_algorithm use_sym_mod)\n     (range ass_function_euclidean) (\\<lambda>c. range (res_int c))", "by (unfold_locales, rule is_sound_HNF'_HNF_algorithm)"], ["", "(*We get the final lemma for our algorithm. It works for any matrix, but it only applies operations\nmodulo determinant for non-singular matrices.*)"], ["", "thm efficient_cert.reduce_basis_external'"], ["", "text \\<open>Same, but applying the naive HNF algorithm, moved to JNF library from the echelon form \n  and Hermite normal form AFP entries\\<close>"], ["", "interpretation cert: certification n m fs_init \\<alpha> \"HNF_algorithm_from_HA use_sym_mod\" \"range ass_function_euclidean\" \"\\<lambda>c. range (res_int c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. certification n m fs_init \\<alpha> (HNF_algorithm_from_HA use_sym_mod)\n     (range ass_function_euclidean) (\\<lambda>c. range (res_int c))", "by (unfold_locales, rule is_sound_HNF'_HNF_algorithm_from_HA)"], ["", "thm cert.reduce_basis_external'"], ["", "(*Explicit versions for paper-presentation:*)"], ["", "lemma RBE_HNF_algorithm_efficient:\n  assumes \"reduce_basis_external' (HNF_algorithm use_sym_mod) \\<alpha> fs_init = fs\"\n  shows \"gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\"\n    and \"LLL_invariant True m fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m &&&\n    LLL_invariant True m fs", "using efficient_cert.reduce_basis_external' assms"], ["proof (prove)\nusing this:\n  reduce_basis_external' (HNF_algorithm ?use_sym_mod) \\<alpha> fs_init =\n  ?fs \\<Longrightarrow>\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom ?fs) \\<alpha> m\n  reduce_basis_external' (HNF_algorithm ?use_sym_mod) \\<alpha> fs_init =\n  ?fs \\<Longrightarrow>\n  LLL_invariant True m ?fs\n  reduce_basis_external' (HNF_algorithm use_sym_mod) \\<alpha> fs_init = fs\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m &&&\n    LLL_invariant True m fs", "by blast+"], ["", "lemma RBE_HNF_algorithm_naive:\n  assumes \"reduce_basis_external' (HNF_algorithm_from_HA use_sym_mod) \\<alpha> fs_init = fs\"\n  shows \"gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\"\n    and \"LLL_invariant True m fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m &&&\n    LLL_invariant True m fs", "using cert.reduce_basis_external' assms"], ["proof (prove)\nusing this:\n  reduce_basis_external' (HNF_algorithm_from_HA ?use_sym_mod) \\<alpha>\n   fs_init =\n  ?fs \\<Longrightarrow>\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom ?fs) \\<alpha> m\n  reduce_basis_external' (HNF_algorithm_from_HA ?use_sym_mod) \\<alpha>\n   fs_init =\n  ?fs \\<Longrightarrow>\n  LLL_invariant True m ?fs\n  reduce_basis_external' (HNF_algorithm_from_HA use_sym_mod) \\<alpha>\n   fs_init =\n  fs\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m &&&\n    LLL_invariant True m fs", "by blast+"], ["", "end"], ["", "lemma external_lll_solver'_code[code]: \n  \"external_lll_solver' = Code.abort (STR ''require proper implementation of external_lll_solver'') (\\<lambda> _. external_lll_solver')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. external_lll_solver' =\n    Code.abort STR ''require proper implementation of external_lll_solver''\n     (\\<lambda>_. external_lll_solver')", "by simp"], ["", "end"]]}