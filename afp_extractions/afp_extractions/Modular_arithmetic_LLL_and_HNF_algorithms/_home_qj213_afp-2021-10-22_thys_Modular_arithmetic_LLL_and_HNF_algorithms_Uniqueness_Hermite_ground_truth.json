{"file_name": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms/Uniqueness_Hermite.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms", "problem_names": ["lemma map_matrix_rat_of_int_mult:\n  shows \"map_matrix rat_of_int (A**B) = (map_matrix rat_of_int A)**(map_matrix rat_of_int B)\"", "lemma det_map_matrix:\n  fixes A :: \"int^'n::mod_type^'n::mod_type\"\n  shows \"det (map_matrix rat_of_int A) = rat_of_int (det A)\"", "lemma inv_Z_imp_inv_Q:\n  fixes A :: \"int^'n::mod_type^'n::mod_type\"\n  assumes inv_A: \"invertible A\"\n  shows \"invertible (map_matrix rat_of_int A)\"", "lemma upper_triangular_Z_eq_Q:\n  \"upper_triangular (map_matrix rat_of_int A) = upper_triangular A\"", "lemma invertible_and_upper_diagonal_not0:\n  fixes H :: \"int^'n::mod_type^'n::mod_type\"\n  assumes inv_H: \"invertible (map_matrix rat_of_int H)\" and up_H: \"upper_triangular H\"\n  shows \"H $ i $ i \\<noteq> 0\"", "lemma diagonal_least_nonzero:\n  fixes H :: \"int^'n::mod_type^'n::mod_type\"\n  assumes H: \"Hermite associates residues H\"\n  and inv_H: \"invertible (map_matrix rat_of_int H)\" and up_H: \"upper_triangular H\"\n  shows \"(LEAST n. H $ i $ n \\<noteq> 0) = i\"", "lemma diagonal_in_associates:\n  fixes H :: \"int^'n::mod_type^'n::mod_type\"\n  assumes H: \"Hermite associates residues H\"\n  and inv_H: \"invertible (map_matrix rat_of_int H)\" and up_H: \"upper_triangular H\"\n  shows \"H $ i $ i \\<in> associates\"", "lemma above_diagonal_in_residues:\n  fixes H :: \"int^'n::mod_type^'n::mod_type\"\n  assumes H: \"Hermite associates residues H\"\n  and inv_H: \"invertible (map_matrix rat_of_int H)\" and up_H: \"upper_triangular H\"\n  and j_i: \"j<i\"\n  shows \"H $ j $ (LEAST n. H $ i $ n \\<noteq> 0) \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))\"", "lemma Hermite_unique_generalized:\n  fixes K::\"int^'n::mod_type^'n::mod_type\"\n  assumes A_PH: \"A = P ** H\" \n  and A_QK: \"A = Q ** K\"\n  and inv_A: \"invertible (map_matrix rat_of_int A)\" (*The original statement assumes \"invertible A\", \n                                                      that is, invertibility over integers, which is\n                                                      more restrictive.*)\n  and inv_P: \"invertible P\"\n  and inv_Q: \"invertible Q\"\n  and H: \"Hermite associates residues H\"\n  and K: \"Hermite associates residues K\"\n  shows \"H = K\""], "translations": [["", "lemma map_matrix_rat_of_int_mult:\n  shows \"map_matrix rat_of_int (A**B) = (map_matrix rat_of_int A)**(map_matrix rat_of_int B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_matrix rat_of_int (A ** B) =\n    map_matrix rat_of_int A ** map_matrix rat_of_int B", "unfolding map_matrix_def matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j.\n        rat_of_int\n         ((\\<chi>i j. \\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) $ i $ j)) =\n    (\\<chi>i j.\n        \\<Sum>k\\<in>UNIV.\n          (\\<chi>i j. rat_of_int (A $ i $ j)) $ i $ k *\n          (\\<chi>i j. rat_of_int (B $ i $ j)) $ k $ j)", "by auto"], ["", "lemma det_map_matrix:\n  fixes A :: \"int^'n::mod_type^'n::mod_type\"\n  shows \"det (map_matrix rat_of_int A) = rat_of_int (det A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (map_matrix rat_of_int A) = rat_of_int (det A)", "unfolding map_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (\\<chi>i j. rat_of_int (A $ i $ j)) = rat_of_int (det A)", "unfolding Determinants.det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes UNIV.\n       rat_of_int (sign p) *\n       (\\<Prod>i\\<in>UNIV. (\\<chi>i j. rat_of_int (A $ i $ j)) $ i $ p i)) =\n    rat_of_int\n     (\\<Sum>p | p permutes UNIV.\n        of_int (sign p) * (\\<Prod>i\\<in>UNIV. A $ i $ p i))", "by auto"], ["", "lemma inv_Z_imp_inv_Q:\n  fixes A :: \"int^'n::mod_type^'n::mod_type\"\n  assumes inv_A: \"invertible A\"\n  shows \"invertible (map_matrix rat_of_int A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int A)", "have \"is_unit (det A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (det A)", "using inv_A invertible_iff_is_unit"], ["proof (prove)\nusing this:\n  invertible A\n  invertible ?A = (det ?A dvd (1::?'a))\n\ngoal (1 subgoal):\n 1. is_unit (det A)", "by blast"], ["proof (state)\nthis:\n  is_unit (det A)\n\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int A)", "hence \"is_unit (det (map_matrix rat_of_int A))\""], ["proof (prove)\nusing this:\n  is_unit (det A)\n\ngoal (1 subgoal):\n 1. is_unit (det (map_matrix rat_of_int A))", "by (simp add: det_map_matrix dvd_if_abs_eq)"], ["proof (state)\nthis:\n  is_unit (det (map_matrix rat_of_int A))\n\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_unit (det (map_matrix rat_of_int A))\n\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int A)", "using invertible_iff_is_unit"], ["proof (prove)\nusing this:\n  is_unit (det (map_matrix rat_of_int A))\n  invertible ?A = (det ?A dvd (1::?'a))\n\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int A)", "by blast"], ["proof (state)\nthis:\n  invertible (map_matrix rat_of_int A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upper_triangular_Z_eq_Q:\n  \"upper_triangular (map_matrix rat_of_int A) = upper_triangular A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (map_matrix rat_of_int A) = upper_triangular A", "unfolding upper_triangular_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i j.\n        j < i \\<longrightarrow> map_matrix rat_of_int A $ i $ j = 0) =\n    (\\<forall>i j. j < i \\<longrightarrow> A $ i $ j = 0)", "by auto"], ["", "lemma invertible_and_upper_diagonal_not0:\n  fixes H :: \"int^'n::mod_type^'n::mod_type\"\n  assumes inv_H: \"invertible (map_matrix rat_of_int H)\" and up_H: \"upper_triangular H\"\n  shows \"H $ i $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> 0", "let ?RAT_H = \"(map_matrix rat_of_int H)\""], ["proof (state)\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> 0", "have up_RAT_H: \"upper_triangular ?RAT_H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (map_matrix rat_of_int H)", "using up_H"], ["proof (prove)\nusing this:\n  upper_triangular H\n\ngoal (1 subgoal):\n 1. upper_triangular (map_matrix rat_of_int H)", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  \\<forall>i j. j < i \\<longrightarrow> H $ i $ j = 0\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       j < i \\<longrightarrow> map_matrix rat_of_int H $ i $ j = 0", "by auto"], ["proof (state)\nthis:\n  upper_triangular (map_matrix rat_of_int H)\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> 0", "have \"is_unit (det ?RAT_H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (det (map_matrix rat_of_int H))", "using inv_H"], ["proof (prove)\nusing this:\n  invertible (map_matrix rat_of_int H)\n\ngoal (1 subgoal):\n 1. is_unit (det (map_matrix rat_of_int H))", "using invertible_iff_is_unit"], ["proof (prove)\nusing this:\n  invertible (map_matrix rat_of_int H)\n  invertible ?A = (det ?A dvd (1::?'a))\n\ngoal (1 subgoal):\n 1. is_unit (det (map_matrix rat_of_int H))", "by blast"], ["proof (state)\nthis:\n  is_unit (det (map_matrix rat_of_int H))\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> 0", "hence \"?RAT_H $ i $ i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  is_unit (det (map_matrix rat_of_int H))\n\ngoal (1 subgoal):\n 1. map_matrix rat_of_int H $ i $ i \\<noteq> 0", "using inv_H up_RAT_H is_unit_diagonal"], ["proof (prove)\nusing this:\n  is_unit (det (map_matrix rat_of_int H))\n  invertible (map_matrix rat_of_int H)\n  upper_triangular (map_matrix rat_of_int H)\n  \\<lbrakk>upper_triangular ?U; is_unit (det ?U)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i. is_unit (?U $ i $ i)\n\ngoal (1 subgoal):\n 1. map_matrix rat_of_int H $ i $ i \\<noteq> 0", "by (metis not_is_unit_0)"], ["proof (state)\nthis:\n  map_matrix rat_of_int H $ i $ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_matrix rat_of_int H $ i $ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  H $ i $ i \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diagonal_least_nonzero:\n  fixes H :: \"int^'n::mod_type^'n::mod_type\"\n  assumes H: \"Hermite associates residues H\"\n  and inv_H: \"invertible (map_matrix rat_of_int H)\" and up_H: \"upper_triangular H\"\n  shows \"(LEAST n. H $ i $ n \\<noteq> 0) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. H $ i $ n \\<noteq> 0) = i", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. H $ i $ i \\<noteq> 0\n 2. \\<And>y. H $ i $ y \\<noteq> 0 \\<Longrightarrow> i \\<le> y", "show \"H $ i $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> 0", "by (rule invertible_and_upper_diagonal_not0[OF inv_H up_H])"], ["proof (state)\nthis:\n  H $ i $ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>y. H $ i $ y \\<noteq> 0 \\<Longrightarrow> i \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. H $ i $ y \\<noteq> 0 \\<Longrightarrow> i \\<le> y", "assume Hiy: \"H $ i $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  H $ i $ y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>y. H $ i $ y \\<noteq> 0 \\<Longrightarrow> i \\<le> y", "show \"i \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> y", "using up_H"], ["proof (prove)\nusing this:\n  upper_triangular H\n\ngoal (1 subgoal):\n 1. i \\<le> y", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  \\<forall>i j. j < i \\<longrightarrow> H $ i $ j = 0\n\ngoal (1 subgoal):\n 1. i \\<le> y", "by (metis (poly_guards_query) Hiy not_less)"], ["proof (state)\nthis:\n  i \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diagonal_in_associates:\n  fixes H :: \"int^'n::mod_type^'n::mod_type\"\n  assumes H: \"Hermite associates residues H\"\n  and inv_H: \"invertible (map_matrix rat_of_int H)\" and up_H: \"upper_triangular H\"\n  shows \"H $ i $ i \\<in> associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "have \"H $ i $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> 0", "by (rule invertible_and_upper_diagonal_not0[OF inv_H up_H])"], ["proof (state)\nthis:\n  H $ i $ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "hence \"\\<not> is_zero_row i H\""], ["proof (prove)\nusing this:\n  H $ i $ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i H", "unfolding is_zero_row_def is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  H $ i $ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < CARD('n) \\<longrightarrow>\n               H $ i $ j = 0)", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row i H\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "using H"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n  Hermite associates residues H\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "unfolding Hermite_def"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues residues \\<and>\n  echelon_form H \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      H $ i $ (LEAST n. H $ i $ n \\<noteq> 0) \\<in> associates) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      (\\<forall>j<i.\n          H $ j $ (LEAST n. H $ i $ n \\<noteq> 0)\n          \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))))\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "unfolding diagonal_least_nonzero[OF H inv_H up_H]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues residues \\<and>\n  echelon_form H \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      H $ i $ i \\<in> associates) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      (\\<forall>j<i. H $ j $ i \\<in> residues (H $ i $ i)))\n\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "by auto"], ["proof (state)\nthis:\n  H $ i $ i \\<in> associates\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma above_diagonal_in_residues:\n  fixes H :: \"int^'n::mod_type^'n::mod_type\"\n  assumes H: \"Hermite associates residues H\"\n  and inv_H: \"invertible (map_matrix rat_of_int H)\" and up_H: \"upper_triangular H\"\n  and j_i: \"j<i\"\n  shows \"H $ j $ (LEAST n. H $ i $ n \\<noteq> 0) \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> 0)\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> 0)\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))", "have \"H $ i $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i \\<noteq> 0", "by (rule invertible_and_upper_diagonal_not0[OF inv_H up_H])"], ["proof (state)\nthis:\n  H $ i $ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> 0)\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))", "hence \"\\<not> is_zero_row i H\""], ["proof (prove)\nusing this:\n  H $ i $ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i H", "unfolding is_zero_row_def is_zero_row_upt_k_def ncols_def"], ["proof (prove)\nusing this:\n  H $ i $ i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < CARD('n) \\<longrightarrow>\n               H $ i $ j = 0)", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row i H\n\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> 0)\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> 0)\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))", "using H j_i"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n  Hermite associates residues H\n  j < i\n\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> 0)\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))", "unfolding Hermite_def"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues residues \\<and>\n  echelon_form H \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      H $ i $ (LEAST n. H $ i $ n \\<noteq> 0) \\<in> associates) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      (\\<forall>j<i.\n          H $ j $ (LEAST n. H $ i $ n \\<noteq> 0)\n          \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))))\n  j < i\n\ngoal (1 subgoal):\n 1. H $ j $ (LEAST n. H $ i $ n \\<noteq> 0)\n    \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))", "unfolding diagonal_least_nonzero[OF H inv_H up_H]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i H\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues residues \\<and>\n  echelon_form H \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      H $ i $ i \\<in> associates) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      (\\<forall>j<i. H $ j $ i \\<in> residues (H $ i $ i)))\n  j < i\n\ngoal (1 subgoal):\n 1. H $ j $ i \\<in> residues (H $ i $ i)", "by auto"], ["proof (state)\nthis:\n  H $ j $ (LEAST n. H $ i $ n \\<noteq> 0)\n  \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Hermite_unique_generalized:\n  fixes K::\"int^'n::mod_type^'n::mod_type\"\n  assumes A_PH: \"A = P ** H\" \n  and A_QK: \"A = Q ** K\"\n  and inv_A: \"invertible (map_matrix rat_of_int A)\" (*The original statement assumes \"invertible A\", \n                                                      that is, invertibility over integers, which is\n                                                      more restrictive.*)\n  and inv_P: \"invertible P\"\n  and inv_Q: \"invertible Q\"\n  and H: \"Hermite associates residues H\"\n  and K: \"Hermite associates residues K\"\n  shows \"H = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H = K", "let ?RAT = \"map_matrix rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. H = K", "have cs_residues: \"Complete_set_residues residues\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_set_residues residues", "using H"], ["proof (prove)\nusing this:\n  Hermite associates residues H\n\ngoal (1 subgoal):\n 1. Complete_set_residues residues", "unfolding Hermite_def"], ["proof (prove)\nusing this:\n  Complete_set_non_associates associates \\<and>\n  Complete_set_residues residues \\<and>\n  echelon_form H \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      H $ i $ (LEAST n. H $ i $ n \\<noteq> 0) \\<in> associates) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row i H \\<longrightarrow>\n      (\\<forall>j<i.\n          H $ j $ (LEAST n. H $ i $ n \\<noteq> 0)\n          \\<in> residues (H $ i $ (LEAST n. H $ i $ n \\<noteq> 0))))\n\ngoal (1 subgoal):\n 1. Complete_set_residues residues", "by simp"], ["proof (state)\nthis:\n  Complete_set_residues residues\n\ngoal (1 subgoal):\n 1. H = K", "have inv_H: \"invertible (?RAT H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int H)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int H)", "have \"?RAT A = ?RAT P ** ?RAT H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_matrix rat_of_int A =\n    map_matrix rat_of_int P ** map_matrix rat_of_int H", "using A_PH map_matrix_rat_of_int_mult"], ["proof (prove)\nusing this:\n  A = P ** H\n  map_matrix rat_of_int (?A ** ?B) =\n  map_matrix rat_of_int ?A ** map_matrix rat_of_int ?B\n\ngoal (1 subgoal):\n 1. map_matrix rat_of_int A =\n    map_matrix rat_of_int P ** map_matrix rat_of_int H", "by blast"], ["proof (state)\nthis:\n  map_matrix rat_of_int A =\n  map_matrix rat_of_int P ** map_matrix rat_of_int H\n\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int H)", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_matrix rat_of_int A =\n  map_matrix rat_of_int P ** map_matrix rat_of_int H\n\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int H)", "by (metis inv_A invertible_left_inverse matrix_inv(1) matrix_mul_assoc)"], ["proof (state)\nthis:\n  invertible (map_matrix rat_of_int H)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invertible (map_matrix rat_of_int H)\n\ngoal (1 subgoal):\n 1. H = K", "have inv_K: \"invertible (?RAT K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int K)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int K)", "have \"?RAT A = ?RAT Q ** ?RAT K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_matrix rat_of_int A =\n    map_matrix rat_of_int Q ** map_matrix rat_of_int K", "using A_QK map_matrix_rat_of_int_mult"], ["proof (prove)\nusing this:\n  A = Q ** K\n  map_matrix rat_of_int (?A ** ?B) =\n  map_matrix rat_of_int ?A ** map_matrix rat_of_int ?B\n\ngoal (1 subgoal):\n 1. map_matrix rat_of_int A =\n    map_matrix rat_of_int Q ** map_matrix rat_of_int K", "by blast"], ["proof (state)\nthis:\n  map_matrix rat_of_int A =\n  map_matrix rat_of_int Q ** map_matrix rat_of_int K\n\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int K)", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_matrix rat_of_int A =\n  map_matrix rat_of_int Q ** map_matrix rat_of_int K\n\ngoal (1 subgoal):\n 1. invertible (map_matrix rat_of_int K)", "by (metis inv_A invertible_left_inverse matrix_inv(1) matrix_mul_assoc)"], ["proof (state)\nthis:\n  invertible (map_matrix rat_of_int K)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invertible (map_matrix rat_of_int K)\n\ngoal (1 subgoal):\n 1. H = K", "define U where \"U = (matrix_inv P)**Q\""], ["proof (state)\nthis:\n  U = matrix_inv P ** Q\n\ngoal (1 subgoal):\n 1. H = K", "have inv_U: \"invertible U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible U", "by (metis U_def inv_P inv_Q invertible_def invertible_mult matrix_inv_left matrix_inv_right)"], ["proof (state)\nthis:\n  invertible U\n\ngoal (1 subgoal):\n 1. H = K", "have H_UK: \"H = U ** K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = U ** K", "using A_PH A_QK inv_P"], ["proof (prove)\nusing this:\n  A = P ** H\n  A = Q ** K\n  invertible P\n\ngoal (1 subgoal):\n 1. H = U ** K", "by (metis U_def matrix_inv_left matrix_mul_assoc matrix_mul_lid)"], ["proof (state)\nthis:\n  H = U ** K\n\ngoal (1 subgoal):\n 1. H = K", "have \"Determinants.det K *k U = H ** adjugate K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det K *k U = H ** adjugate K", "unfolding H_UK matrix_mul_assoc[symmetric] mult_adjugate_det matrix_mul_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. det K *k U = det K *k U", ".."], ["proof (state)\nthis:\n  det K *k U = H ** adjugate K\n\ngoal (1 subgoal):\n 1. H = K", "have upper_triangular_H: \"upper_triangular H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular H", "by (metis H Hermite_def echelon_form_imp_upper_triagular)"], ["proof (state)\nthis:\n  upper_triangular H\n\ngoal (1 subgoal):\n 1. H = K", "have upper_triangular_K: \"upper_triangular K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular K", "by (metis K Hermite_def echelon_form_imp_upper_triagular)"], ["proof (state)\nthis:\n  upper_triangular K\n\ngoal (1 subgoal):\n 1. H = K", "have upper_triangular_U: \"upper_triangular U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular U", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. upper_triangular U", "have U_H_K: \"?RAT U = (?RAT H) ** (matrix_inv (?RAT K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_matrix rat_of_int U =\n    map_matrix rat_of_int H ** matrix_inv (map_matrix rat_of_int K)", "by (metis H_UK inv_K map_matrix_rat_of_int_mult matrix_inv(2) matrix_mul_assoc matrix_mul_rid)"], ["proof (state)\nthis:\n  map_matrix rat_of_int U =\n  map_matrix rat_of_int H ** matrix_inv (map_matrix rat_of_int K)\n\ngoal (1 subgoal):\n 1. upper_triangular U", "have up_inv_RAT_K: \"upper_triangular (matrix_inv (?RAT K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (matrix_inv (map_matrix rat_of_int K))", "using upper_triangular_inverse"], ["proof (prove)\nusing this:\n  \\<lbrakk>upper_triangular ?A; invertible ?A\\<rbrakk>\n  \\<Longrightarrow> upper_triangular (matrix_inv ?A)\n\ngoal (1 subgoal):\n 1. upper_triangular (matrix_inv (map_matrix rat_of_int K))", "by (simp add: upper_triangular_inverse inv_K upper_triangular_K upper_triangular_Z_eq_Q)"], ["proof (state)\nthis:\n  upper_triangular (matrix_inv (map_matrix rat_of_int K))\n\ngoal (1 subgoal):\n 1. upper_triangular U", "have \"upper_triangular (?RAT U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (map_matrix rat_of_int U)", "unfolding U_H_K"], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular\n     (map_matrix rat_of_int H ** matrix_inv (map_matrix rat_of_int K))", "by (rule upper_triangular_mult[OF _ up_inv_RAT_K], \n          auto simp add: upper_triangular_H upper_triangular_Z_eq_Q)"], ["proof (state)\nthis:\n  upper_triangular (map_matrix rat_of_int U)\n\ngoal (1 subgoal):\n 1. upper_triangular U", "thus ?thesis"], ["proof (prove)\nusing this:\n  upper_triangular (map_matrix rat_of_int U)\n\ngoal (1 subgoal):\n 1. upper_triangular U", "using upper_triangular_Z_eq_Q"], ["proof (prove)\nusing this:\n  upper_triangular (map_matrix rat_of_int U)\n  upper_triangular (map_matrix rat_of_int ?A) = upper_triangular ?A\n\ngoal (1 subgoal):\n 1. upper_triangular U", "by auto"], ["proof (state)\nthis:\n  upper_triangular U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upper_triangular U\n\ngoal (1 subgoal):\n 1. H = K", "have unit_det_U: \"is_unit (det U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (det U)", "by (metis inv_U invertible_iff_is_unit)"], ["proof (state)\nthis:\n  is_unit (det U)\n\ngoal (1 subgoal):\n 1. H = K", "have is_unit_diagonal_U: \"(\\<forall>i. is_unit (U $ i $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. is_unit (U $ i $ i)", "by (rule is_unit_diagonal[OF upper_triangular_U unit_det_U])"], ["proof (state)\nthis:\n  \\<forall>i. is_unit (U $ i $ i)\n\ngoal (1 subgoal):\n 1. H = K", "have Uii_1: \"(\\<forall>i. (U $ i $ i) = 1)\" and Hii_Kii: \"(\\<forall>i. (H $ i $ i) = (K $ i $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. U $ i $ i = 1 &&& \\<forall>i. H $ i $ i = K $ i $ i", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. U $ i $ i = 1\n 2. \\<And>i. H $ i $ i = K $ i $ i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. U $ i $ i = 1\n 2. \\<And>i. H $ i $ i = K $ i $ i", "have Hii: \"H $ i $ i \\<in> associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i \\<in> associates", "by (rule diagonal_in_associates[OF H inv_H upper_triangular_H])"], ["proof (state)\nthis:\n  H $ i $ i \\<in> associates\n\ngoal (2 subgoals):\n 1. \\<And>i. U $ i $ i = 1\n 2. \\<And>i. H $ i $ i = K $ i $ i", "have Kii: \"K $ i $ i \\<in> associates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K $ i $ i \\<in> associates", "by (rule diagonal_in_associates[OF K inv_K upper_triangular_K])"], ["proof (state)\nthis:\n  K $ i $ i \\<in> associates\n\ngoal (2 subgoals):\n 1. \\<And>i. U $ i $ i = 1\n 2. \\<And>i. H $ i $ i = K $ i $ i", "have ass_Hii_Kii: \"normalize (H $ i $ i) = normalize (K $ i $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (H $ i $ i) = normalize (K $ i $ i)", "by (metis H_UK is_unit_diagonal_U normalize_mult_unit_left upper_triangular_K upper_triangular_U upper_triangular_mult_diagonal)"], ["proof (state)\nthis:\n  normalize (H $ i $ i) = normalize (K $ i $ i)\n\ngoal (2 subgoals):\n 1. \\<And>i. U $ i $ i = 1\n 2. \\<And>i. H $ i $ i = K $ i $ i", "show Hii_eq_Kii: \"H $ i $ i = K $ i $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i = K $ i $ i", "by (metis Hermite_def Hii K Kii ass_Hii_Kii in_Ass_not_associated)"], ["proof (state)\nthis:\n  H $ i $ i = K $ i $ i\n\ngoal (1 subgoal):\n 1. \\<And>i. U $ i $ i = 1", "have \"H $ i $ i = U $ i $ i * K $ i $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ i $ i = U $ i $ i * K $ i $ i", "by (metis H_UK upper_triangular_K upper_triangular_U upper_triangular_mult_diagonal)"], ["proof (state)\nthis:\n  H $ i $ i = U $ i $ i * K $ i $ i\n\ngoal (1 subgoal):\n 1. \\<And>i. U $ i $ i = 1", "thus \"U $ i $ i = 1\""], ["proof (prove)\nusing this:\n  H $ i $ i = U $ i $ i * K $ i $ i\n\ngoal (1 subgoal):\n 1. U $ i $ i = 1", "unfolding Hii_eq_Kii mult_cancel_right1"], ["proof (prove)\nusing this:\n  K $ i $ i = 0 \\<or> U $ i $ i = 1\n\ngoal (1 subgoal):\n 1. U $ i $ i = 1", "using inv_K invertible_and_upper_diagonal_not0 upper_triangular_K"], ["proof (prove)\nusing this:\n  K $ i $ i = 0 \\<or> U $ i $ i = 1\n  invertible (map_matrix rat_of_int K)\n  \\<lbrakk>invertible (map_matrix rat_of_int ?H);\n   upper_triangular ?H\\<rbrakk>\n  \\<Longrightarrow> ?H $ ?i $ ?i \\<noteq> 0\n  upper_triangular K\n\ngoal (1 subgoal):\n 1. U $ i $ i = 1", "by blast"], ["proof (state)\nthis:\n  U $ i $ i = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i. U $ i $ i = 1\n  \\<forall>i. H $ i $ i = K $ i $ i\n\ngoal (1 subgoal):\n 1. H = K", "have zero_above: \"\\<forall>j s. j\\<ge>1 \\<and> j < ncols A - to_nat s \\<longrightarrow> U $ s $ (s + from_nat j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j s.\n       1 \\<le> j \\<and>\n       j < ncols A - mod_type_class.to_nat s \\<longrightarrow>\n       U $ s $ (s + mod_type_class.from_nat j) = 0", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j s.\n       \\<lbrakk>1 \\<le> j; j < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat j) = 0", "fix j s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j s.\n       \\<lbrakk>1 \\<le> j; j < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat j) = 0", "assume  \"1 \\<le> j\" and \"j < ncols A - (to_nat (s::'n))\""], ["proof (state)\nthis:\n  1 \\<le> j\n  j < ncols A - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. \\<And>j s.\n       \\<lbrakk>1 \\<le> j; j < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat j) = 0", "thus \"U $ s $ (s + from_nat j) = 0\""], ["proof (prove)\nusing this:\n  1 \\<le> j\n  j < ncols A - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat j) = 0", "proof (induct j rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    y < ncols A - mod_type_class.to_nat s\\<rbrakk>\n                   \\<Longrightarrow> U $ s $\n                                     (s + mod_type_class.from_nat y) =\n                                     0;\n        1 \\<le> x; x < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat x) = 0", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    y < ncols A - mod_type_class.to_nat s\\<rbrakk>\n                   \\<Longrightarrow> U $ s $\n                                     (s + mod_type_class.from_nat y) =\n                                     0;\n        1 \\<le> x; x < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat x) = 0", "assume induct_step: \"(\\<And>y. y < p \\<Longrightarrow> 1 \\<le> y \\<Longrightarrow> y < ncols A - to_nat s \\<Longrightarrow> U $ s $ (s + from_nat y) = 0)\"\n        and p1: \"1 \\<le> p\" and p2: \"p < ncols A - to_nat s\""], ["proof (state)\nthis:\n  \\<lbrakk>?y1 < p; 1 \\<le> ?y1;\n   ?y1 < ncols A - mod_type_class.to_nat s\\<rbrakk>\n  \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat ?y1) = 0\n  1 \\<le> p\n  p < ncols A - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    y < ncols A - mod_type_class.to_nat s\\<rbrakk>\n                   \\<Longrightarrow> U $ s $\n                                     (s + mod_type_class.from_nat y) =\n                                     0;\n        1 \\<le> x; x < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat x) = 0", "have s_less: \"s < s + from_nat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s < s + mod_type_class.from_nat p", "using p1 p2"], ["proof (prove)\nusing this:\n  1 \\<le> p\n  p < ncols A - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. s < s + mod_type_class.from_nat p", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  1 \\<le> p\n  p < CARD('n) - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. s < s + mod_type_class.from_nat p", "by (metis One_nat_def add.commute add_diff_cancel_right' add_lessD1 add_to_nat_def \n          from_nat_to_nat_id less_diff_conv neq_iff not_le\n          to_nat_from_nat_id to_nat_le zero_less_Suc)"], ["proof (state)\nthis:\n  s < s + mod_type_class.from_nat p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 1 \\<le> y;\n                    y < ncols A - mod_type_class.to_nat s\\<rbrakk>\n                   \\<Longrightarrow> U $ s $\n                                     (s + mod_type_class.from_nat y) =\n                                     0;\n        1 \\<le> x; x < ncols A - mod_type_class.to_nat s\\<rbrakk>\n       \\<Longrightarrow> U $ s $ (s + mod_type_class.from_nat x) = 0", "show \"U $ s $ (s + from_nat p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "have UNIV_rw: \"UNIV = insert s (UNIV-{s})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = insert s (UNIV - {s})", "by auto"], ["proof (state)\nthis:\n  UNIV = insert s (UNIV - {s})\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "have UNIV_s_rw: \"UNIV-{s} = insert (s + from_nat p) ((UNIV-{s}) - {s + from_nat p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV - {s} =\n    insert (s + mod_type_class.from_nat p)\n     (UNIV - {s} - {s + mod_type_class.from_nat p})", "using p1 p2 s_less"], ["proof (prove)\nusing this:\n  1 \\<le> p\n  p < ncols A - mod_type_class.to_nat s\n  s < s + mod_type_class.from_nat p\n\ngoal (1 subgoal):\n 1. UNIV - {s} =\n    insert (s + mod_type_class.from_nat p)\n     (UNIV - {s} - {s + mod_type_class.from_nat p})", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  1 \\<le> p\n  p < CARD('n) - mod_type_class.to_nat s\n  s < s + mod_type_class.from_nat p\n\ngoal (1 subgoal):\n 1. UNIV - {s} =\n    insert (s + mod_type_class.from_nat p)\n     (UNIV - {s} - {s + mod_type_class.from_nat p})", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  UNIV - {s} =\n  insert (s + mod_type_class.from_nat p)\n   (UNIV - {s} - {s + mod_type_class.from_nat p})\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "have sum_rw: \"(\\<Sum>k\\<in>UNIV-{s}. U $ s $ k * K $ k $ (s + from_nat p)) \n          = U $ s $ (s + from_nat p) * K $ (s + from_nat p) $ (s + from_nat p) \n          + (\\<Sum>k\\<in>(UNIV-{s})-{s + from_nat p}. U $ s $ k * K $ k $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV - {s}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    U $ s $ (s + mod_type_class.from_nat p) *\n    K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n    (\\<Sum>k\\<in>UNIV - {s} - {s + mod_type_class.from_nat p}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "using UNIV_s_rw sum.insert"], ["proof (prove)\nusing this:\n  UNIV - {s} =\n  insert (s + mod_type_class.from_nat p)\n   (UNIV - {s} - {s + mod_type_class.from_nat p})\n  \\<lbrakk>finite ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> sum ?g (insert ?x ?A) = ?g ?x + sum ?g ?A\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV - {s}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    U $ s $ (s + mod_type_class.from_nat p) *\n    K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n    (\\<Sum>k\\<in>UNIV - {s} - {s + mod_type_class.from_nat p}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "by (metis (erased, lifting) Diff_iff finite singletonI)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV - {s}.\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n  (\\<Sum>k\\<in>UNIV - {s} - {s + mod_type_class.from_nat p}.\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "have sum_0: \"(\\<Sum>k\\<in>(UNIV-{s})-{s + from_nat p}. U $ s $ k * K $ k $ (s + from_nat p)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV - {s} - {s + mod_type_class.from_nat p}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    0", "proof (rule sum.neutral, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV - {s} -\n               {s + mod_type_class.from_nat p} \\<Longrightarrow>\n       U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV - {s} -\n               {s + mod_type_class.from_nat p} \\<Longrightarrow>\n       U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "assume x: \"x \\<in> UNIV - {s} - {s + from_nat p}\""], ["proof (state)\nthis:\n  x \\<in> UNIV - {s} - {s + mod_type_class.from_nat p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV - {s} -\n               {s + mod_type_class.from_nat p} \\<Longrightarrow>\n       U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "show \"U $ s $ x * K $ x $ (s + from_nat p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "proof (cases \"x<s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n 2. \\<not> x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "case True"], ["proof (state)\nthis:\n  x < s\n\ngoal (2 subgoals):\n 1. x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n 2. \\<not> x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  x < s\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "using upper_triangular_U"], ["proof (prove)\nusing this:\n  x < s\n  upper_triangular U\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  x < s\n  \\<forall>i j. j < i \\<longrightarrow> U $ i $ j = 0\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "by auto"], ["proof (state)\nthis:\n  U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n\ngoal (1 subgoal):\n 1. \\<not> x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "case False"], ["proof (state)\nthis:\n  \\<not> x < s\n\ngoal (1 subgoal):\n 1. \\<not> x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "hence x_g_s: \"x>s\""], ["proof (prove)\nusing this:\n  \\<not> x < s\n\ngoal (1 subgoal):\n 1. s < x", "using x"], ["proof (prove)\nusing this:\n  \\<not> x < s\n  x \\<in> UNIV - {s} - {s + mod_type_class.from_nat p}\n\ngoal (1 subgoal):\n 1. s < x", "by (metis Diff_iff neq_iff singletonI)"], ["proof (state)\nthis:\n  s < x\n\ngoal (1 subgoal):\n 1. \\<not> x < s \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "proof (cases \"x<s+from_nat p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n 2. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "case True"], ["proof (state)\nthis:\n  x < s + mod_type_class.from_nat p\n\ngoal (2 subgoals):\n 1. x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n 2. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "define a where \"a = to_nat x - to_nat s\""], ["proof (state)\nthis:\n  a = mod_type_class.to_nat x - mod_type_class.to_nat s\n\ngoal (2 subgoals):\n 1. x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n 2. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "from x_g_s"], ["proof (chain)\npicking this:\n  s < x", "have \"to_nat s < to_nat x\""], ["proof (prove)\nusing this:\n  s < x\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat s < mod_type_class.to_nat x", "by (rule to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat s < mod_type_class.to_nat x\n\ngoal (2 subgoals):\n 1. x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n 2. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "hence xa: \"x=s+(from_nat a)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat s < mod_type_class.to_nat x\n\ngoal (1 subgoal):\n 1. x = s + mod_type_class.from_nat a", "unfolding a_def add_to_nat_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat s < mod_type_class.to_nat x\n\ngoal (1 subgoal):\n 1. x =\n    mod_type_class.from_nat\n     (mod_type_class.to_nat s +\n      mod_type_class.to_nat\n       (mod_type_class.from_nat\n         (mod_type_class.to_nat x - mod_type_class.to_nat s)))", "by (simp add: less_imp_diff_less to_nat_less_card algebra_simps to_nat_from_nat_id)"], ["proof (state)\nthis:\n  x = s + mod_type_class.from_nat a\n\ngoal (2 subgoals):\n 1. x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n 2. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "have \"U $ s $ x =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ s $ x = 0", "proof (unfold xa, rule induct_step)"], ["proof (state)\ngoal (3 subgoals):\n 1. a < p\n 2. 1 \\<le> a\n 3. a < ncols A - mod_type_class.to_nat s", "show a_p: \"a<p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < p", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x - mod_type_class.to_nat s < p", "using p2"], ["proof (prove)\nusing this:\n  p < ncols A - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x - mod_type_class.to_nat s < p", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  p < CARD('n) - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x - mod_type_class.to_nat s < p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p < CARD('n) - mod_type_class.to_nat s \\<Longrightarrow>\n    mod_type_class.to_nat x - mod_type_class.to_nat s < p", "have \"x < from_nat (to_nat s + to_nat (from_nat p::'n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < mod_type_class.from_nat\n         (mod_type_class.to_nat s +\n          mod_type_class.to_nat (mod_type_class.from_nat p))", "by (metis (no_types) True add_to_nat_def)"], ["proof (state)\nthis:\n  x < mod_type_class.from_nat\n       (mod_type_class.to_nat s +\n        mod_type_class.to_nat (mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. p < CARD('n) - mod_type_class.to_nat s \\<Longrightarrow>\n    mod_type_class.to_nat x - mod_type_class.to_nat s < p", "hence \"to_nat x - to_nat s < to_nat (from_nat p::'n)\""], ["proof (prove)\nusing this:\n  x < mod_type_class.from_nat\n       (mod_type_class.to_nat s +\n        mod_type_class.to_nat (mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x - mod_type_class.to_nat s\n    < mod_type_class.to_nat (mod_type_class.from_nat p)", "by (simp add: add.commute less_diff_conv2 less_imp_le to_nat_le x_g_s)"], ["proof (state)\nthis:\n  mod_type_class.to_nat x - mod_type_class.to_nat s\n  < mod_type_class.to_nat (mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. p < CARD('n) - mod_type_class.to_nat s \\<Longrightarrow>\n    mod_type_class.to_nat x - mod_type_class.to_nat s < p", "thus \"to_nat x - to_nat s < p\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat x - mod_type_class.to_nat s\n  < mod_type_class.to_nat (mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x - mod_type_class.to_nat s < p", "by (metis (no_types) from_nat_eq_imp_eq from_nat_to_nat_id le_less_trans \n                        less_imp_le not_le to_nat_less_card)"], ["proof (state)\nthis:\n  mod_type_class.to_nat x - mod_type_class.to_nat s < p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < p\n\ngoal (2 subgoals):\n 1. 1 \\<le> a\n 2. a < ncols A - mod_type_class.to_nat s", "show \"1 \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> a", "by (auto simp add: a_def p1 p2) (metis Suc_leI to_nat_mono x_g_s zero_less_diff)"], ["proof (state)\nthis:\n  1 \\<le> a\n\ngoal (1 subgoal):\n 1. a < ncols A - mod_type_class.to_nat s", "show \"a < ncols A - to_nat s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < ncols A - mod_type_class.to_nat s", "using a_p p2"], ["proof (prove)\nusing this:\n  a < p\n  p < ncols A - mod_type_class.to_nat s\n\ngoal (1 subgoal):\n 1. a < ncols A - mod_type_class.to_nat s", "by auto"], ["proof (state)\nthis:\n  a < ncols A - mod_type_class.to_nat s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U $ s $ x = 0\n\ngoal (2 subgoals):\n 1. x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n 2. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  U $ s $ x = 0\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "by simp"], ["proof (state)\nthis:\n  U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n\ngoal (1 subgoal):\n 1. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "case False"], ["proof (state)\nthis:\n  \\<not> x < s + mod_type_class.from_nat p\n\ngoal (1 subgoal):\n 1. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "hence \"x>s+from_nat p\""], ["proof (prove)\nusing this:\n  \\<not> x < s + mod_type_class.from_nat p\n\ngoal (1 subgoal):\n 1. s + mod_type_class.from_nat p < x", "using x_g_s x"], ["proof (prove)\nusing this:\n  \\<not> x < s + mod_type_class.from_nat p\n  s < x\n  x \\<in> UNIV - {s} - {s + mod_type_class.from_nat p}\n\ngoal (1 subgoal):\n 1. s + mod_type_class.from_nat p < x", "by auto"], ["proof (state)\nthis:\n  s + mod_type_class.from_nat p < x\n\ngoal (1 subgoal):\n 1. \\<not> x < s + mod_type_class.from_nat p \\<Longrightarrow>\n    U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  s + mod_type_class.from_nat p < x\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "using upper_triangular_K"], ["proof (prove)\nusing this:\n  s + mod_type_class.from_nat p < x\n  upper_triangular K\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  s + mod_type_class.from_nat p < x\n  \\<forall>i j. j < i \\<longrightarrow> K $ i $ j = 0\n\ngoal (1 subgoal):\n 1. U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0", "by auto"], ["proof (state)\nthis:\n  U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U $ s $ x * K $ x $ (s + mod_type_class.from_nat p) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV - {s} - {s + mod_type_class.from_nat p}.\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  0\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "have \"H $ s $ (s + from_nat p) = (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p) =\n    (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "unfolding H_UK matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j. \\<Sum>k\\<in>UNIV. U $ i $ k * K $ k $ j) $ s $\n    (s + mod_type_class.from_nat p) =\n    (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "by auto"], ["proof (state)\nthis:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "also"], ["proof (state)\nthis:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "have \"... = (\\<Sum>k\\<in>insert s (UNIV-{s}). U $ s $ k * K $ k $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    (\\<Sum>k\\<in>insert s (UNIV - {s}).\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "using UNIV_rw"], ["proof (prove)\nusing this:\n  UNIV = insert s (UNIV - {s})\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    (\\<Sum>k\\<in>insert s (UNIV - {s}).\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  (\\<Sum>k\\<in>insert s (UNIV - {s}).\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>UNIV. U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  (\\<Sum>k\\<in>insert s (UNIV - {s}).\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "have \"... = U $ s $ s * K $ s $ (s + from_nat p) \n          + (\\<Sum>k\\<in>UNIV-{s}. U $ s $ k * K $ k $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>insert s (UNIV - {s}).\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n    (\\<Sum>k\\<in>UNIV - {s}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))", "by (rule sum.insert, simp_all)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert s (UNIV - {s}).\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  (\\<Sum>k\\<in>UNIV - {s}.\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert s (UNIV - {s}).\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  (\\<Sum>k\\<in>UNIV - {s}.\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "have \"... = U $ s $ s * K $ s $ (s + from_nat p) \n          + U $ s $ (s + from_nat p) * K $ (s + from_nat p) $ (s + from_nat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n    (\\<Sum>k\\<in>UNIV - {s}.\n       U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n    U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n    U $ s $ (s + mod_type_class.from_nat p) *\n    K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p)", "unfolding sum_rw sum_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n    (U $ s $ (s + mod_type_class.from_nat p) *\n     K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n     0) =\n    U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n    U $ s $ (s + mod_type_class.from_nat p) *\n    K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p)", "by simp"], ["proof (state)\nthis:\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  (\\<Sum>k\\<in>UNIV - {s}.\n     U $ s $ k * K $ k $ (s + mod_type_class.from_nat p)) =\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "finally"], ["proof (chain)\npicking this:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p)", "have H_s_sp: \"H $ s $ (s + from_nat p) \n          = U $ s $ (s + from_nat p) * K $ (s + from_nat p) $ (s + from_nat p) + K $ s $ (s + from_nat p)\""], ["proof (prove)\nusing this:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p) =\n    U $ s $ (s + mod_type_class.from_nat p) *\n    K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n    K $ s $ (s + mod_type_class.from_nat p)", "using Uii_1"], ["proof (prove)\nusing this:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ s * K $ s $ (s + mod_type_class.from_nat p) +\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p)\n  \\<forall>i. U $ i $ i = 1\n\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p) =\n    U $ s $ (s + mod_type_class.from_nat p) *\n    K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n    K $ s $ (s + mod_type_class.from_nat p)", "by auto"], ["proof (state)\nthis:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n  K $ s $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "hence cong_HK: \"cong (H $ s $ (s + from_nat p)) (K $ s $ (s + from_nat p)) (K $ (s+from_nat p) $ (s + from_nat p))\""], ["proof (prove)\nusing this:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n  K $ s $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. cong (H $ s $ (s + mod_type_class.from_nat p))\n     (K $ s $ (s + mod_type_class.from_nat p))\n     (K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p))", "unfolding cong_def"], ["proof (prove)\nusing this:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n  K $ s $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       H $ s $ (s + mod_type_class.from_nat p) -\n       K $ s $ (s + mod_type_class.from_nat p) =\n       K $ (s + mod_type_class.from_nat p) $\n       (s + mod_type_class.from_nat p) *\n       k", "by auto"], ["proof (state)\nthis:\n  cong (H $ s $ (s + mod_type_class.from_nat p))\n   (K $ s $ (s + mod_type_class.from_nat p))\n   (K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "have H_s_sp_residues: \"(H $ s $ (s + from_nat p)) \\<in> residues (K $ (s+from_nat p) $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p)\n    \\<in> residues\n           (K $ (s + mod_type_class.from_nat p) $\n            (s + mod_type_class.from_nat p))", "using above_diagonal_in_residues[OF H inv_H upper_triangular_H s_less]"], ["proof (prove)\nusing this:\n  H $ s $ (LEAST n. H $ (s + mod_type_class.from_nat p) $ n \\<noteq> 0)\n  \\<in> residues\n         (H $ (s + mod_type_class.from_nat p) $\n          (LEAST n. H $ (s + mod_type_class.from_nat p) $ n \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p)\n    \\<in> residues\n           (K $ (s + mod_type_class.from_nat p) $\n            (s + mod_type_class.from_nat p))", "unfolding diagonal_least_nonzero[OF H inv_H upper_triangular_H]"], ["proof (prove)\nusing this:\n  H $ s $ (s + mod_type_class.from_nat p)\n  \\<in> residues\n         (H $ (s + mod_type_class.from_nat p) $\n          (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p)\n    \\<in> residues\n           (K $ (s + mod_type_class.from_nat p) $\n            (s + mod_type_class.from_nat p))", "by (metis Hii_Kii)"], ["proof (state)\nthis:\n  H $ s $ (s + mod_type_class.from_nat p)\n  \\<in> residues\n         (K $ (s + mod_type_class.from_nat p) $\n          (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "have K_s_sp_residues: \"(K $ s $ (s + from_nat p)) \\<in> residues (K $ (s+from_nat p) $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K $ s $ (s + mod_type_class.from_nat p)\n    \\<in> residues\n           (K $ (s + mod_type_class.from_nat p) $\n            (s + mod_type_class.from_nat p))", "using above_diagonal_in_residues[OF K inv_K upper_triangular_K s_less]"], ["proof (prove)\nusing this:\n  K $ s $ (LEAST n. K $ (s + mod_type_class.from_nat p) $ n \\<noteq> 0)\n  \\<in> residues\n         (K $ (s + mod_type_class.from_nat p) $\n          (LEAST n. K $ (s + mod_type_class.from_nat p) $ n \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. K $ s $ (s + mod_type_class.from_nat p)\n    \\<in> residues\n           (K $ (s + mod_type_class.from_nat p) $\n            (s + mod_type_class.from_nat p))", "unfolding diagonal_least_nonzero[OF K inv_K upper_triangular_K]"], ["proof (prove)\nusing this:\n  K $ s $ (s + mod_type_class.from_nat p)\n  \\<in> residues\n         (K $ (s + mod_type_class.from_nat p) $\n          (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. K $ s $ (s + mod_type_class.from_nat p)\n    \\<in> residues\n           (K $ (s + mod_type_class.from_nat p) $\n            (s + mod_type_class.from_nat p))", "."], ["proof (state)\nthis:\n  K $ s $ (s + mod_type_class.from_nat p)\n  \\<in> residues\n         (K $ (s + mod_type_class.from_nat p) $\n          (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "have Hs_sp_Ks_sp: \"(H $ s $ (s + from_nat p)) = (K $ s $ (s + from_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p) =\n    K $ s $ (s + mod_type_class.from_nat p)", "using cong_HK in_Res_not_congruent[OF cs_residues H_s_sp_residues K_s_sp_residues]"], ["proof (prove)\nusing this:\n  cong (H $ s $ (s + mod_type_class.from_nat p))\n   (K $ s $ (s + mod_type_class.from_nat p))\n   (K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p))\n  H $ s $ (s + mod_type_class.from_nat p) \\<noteq>\n  K $ s $ (s + mod_type_class.from_nat p) \\<Longrightarrow>\n  \\<not> cong (H $ s $ (s + mod_type_class.from_nat p))\n          (K $ s $ (s + mod_type_class.from_nat p))\n          (K $ (s + mod_type_class.from_nat p) $\n           (s + mod_type_class.from_nat p))\n\ngoal (1 subgoal):\n 1. H $ s $ (s + mod_type_class.from_nat p) =\n    K $ s $ (s + mod_type_class.from_nat p)", "by fast"], ["proof (state)\nthis:\n  H $ s $ (s + mod_type_class.from_nat p) =\n  K $ s $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "have \"K $ (s + from_nat p) $ (s + from_nat p) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K $ (s + mod_type_class.from_nat p) $\n    (s + mod_type_class.from_nat p) \\<noteq>\n    0", "using inv_K invertible_and_upper_diagonal_not0 upper_triangular_K"], ["proof (prove)\nusing this:\n  invertible (map_matrix rat_of_int K)\n  \\<lbrakk>invertible (map_matrix rat_of_int ?H);\n   upper_triangular ?H\\<rbrakk>\n  \\<Longrightarrow> ?H $ ?i $ ?i \\<noteq> 0\n  upper_triangular K\n\ngoal (1 subgoal):\n 1. K $ (s + mod_type_class.from_nat p) $\n    (s + mod_type_class.from_nat p) \\<noteq>\n    0", "by blast"], ["proof (state)\nthis:\n  K $ (s + mod_type_class.from_nat p) $\n  (s + mod_type_class.from_nat p) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  K $ (s + mod_type_class.from_nat p) $\n  (s + mod_type_class.from_nat p) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "unfolding from_nat_1"], ["proof (prove)\nusing this:\n  K $ (s + mod_type_class.from_nat p) $\n  (s + mod_type_class.from_nat p) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "using H_s_sp"], ["proof (prove)\nusing this:\n  K $ (s + mod_type_class.from_nat p) $\n  (s + mod_type_class.from_nat p) \\<noteq>\n  0\n  H $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n  K $ s $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "unfolding Hs_sp_Ks_sp"], ["proof (prove)\nusing this:\n  K $ (s + mod_type_class.from_nat p) $\n  (s + mod_type_class.from_nat p) \\<noteq>\n  0\n  K $ s $ (s + mod_type_class.from_nat p) =\n  U $ s $ (s + mod_type_class.from_nat p) *\n  K $ (s + mod_type_class.from_nat p) $ (s + mod_type_class.from_nat p) +\n  K $ s $ (s + mod_type_class.from_nat p)\n\ngoal (1 subgoal):\n 1. U $ s $ (s + mod_type_class.from_nat p) = 0", "by auto"], ["proof (state)\nthis:\n  U $ s $ (s + mod_type_class.from_nat p) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U $ s $ (s + mod_type_class.from_nat p) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U $ s $ (s + mod_type_class.from_nat j) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j s.\n     1 \\<le> j \\<and>\n     j < ncols A - mod_type_class.to_nat s \\<longrightarrow>\n     U $ s $ (s + mod_type_class.from_nat j) = 0\n\ngoal (1 subgoal):\n 1. H = K", "have \"U = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U = mat 1", "proof (unfold mat_def vec_eq_iff, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia. U $ ia $ ia = 1\n 2. \\<And>i ia. i \\<noteq> ia \\<Longrightarrow> U $ i $ ia = 0", "fix ia"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia. U $ ia $ ia = 1\n 2. \\<And>i ia. i \\<noteq> ia \\<Longrightarrow> U $ i $ ia = 0", "show \"U $ ia $ ia = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ ia $ ia = 1", "using Uii_1"], ["proof (prove)\nusing this:\n  \\<forall>i. U $ i $ i = 1\n\ngoal (1 subgoal):\n 1. U $ ia $ ia = 1", "by simp"], ["proof (state)\nthis:\n  U $ ia $ ia = 1\n\ngoal (1 subgoal):\n 1. \\<And>i ia. i \\<noteq> ia \\<Longrightarrow> U $ i $ ia = 0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia. i \\<noteq> ia \\<Longrightarrow> U $ i $ ia = 0", "assume i_ia: \"i \\<noteq> ia\""], ["proof (state)\nthis:\n  i \\<noteq> ia\n\ngoal (1 subgoal):\n 1. \\<And>i ia. i \\<noteq> ia \\<Longrightarrow> U $ i $ ia = 0", "show \"U $ i $ ia = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U $ i $ ia = 0", "proof (cases \"ia<i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ia < i \\<Longrightarrow> U $ i $ ia = 0\n 2. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = 0", "case True"], ["proof (state)\nthis:\n  ia < i\n\ngoal (2 subgoals):\n 1. ia < i \\<Longrightarrow> U $ i $ ia = 0\n 2. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  ia < i\n\ngoal (1 subgoal):\n 1. U $ i $ ia = 0", "using upper_triangular_U"], ["proof (prove)\nusing this:\n  ia < i\n  upper_triangular U\n\ngoal (1 subgoal):\n 1. U $ i $ ia = 0", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  ia < i\n  \\<forall>i j. j < i \\<longrightarrow> U $ i $ j = 0\n\ngoal (1 subgoal):\n 1. U $ i $ ia = 0", "by auto"], ["proof (state)\nthis:\n  U $ i $ ia = 0\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = 0", "case False"], ["proof (state)\nthis:\n  \\<not> ia < i\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = 0", "hence i_less_ia: \"i<ia\""], ["proof (prove)\nusing this:\n  \\<not> ia < i\n\ngoal (1 subgoal):\n 1. i < ia", "using i_ia"], ["proof (prove)\nusing this:\n  \\<not> ia < i\n  i \\<noteq> ia\n\ngoal (1 subgoal):\n 1. i < ia", "by auto"], ["proof (state)\nthis:\n  i < ia\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = 0", "define a where \"a = to_nat ia - to_nat i\""], ["proof (state)\nthis:\n  a = mod_type_class.to_nat ia - mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = 0", "have ia_eq: \"ia = i + from_nat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia = i + mod_type_class.from_nat a", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    i +\n    mod_type_class.from_nat\n     (mod_type_class.to_nat ia - mod_type_class.to_nat i)", "by (metis i_less_ia a_def add_to_nat_def dual_order.strict_iff_order from_nat_to_nat_id \n            le_add_diff_inverse less_imp_diff_less to_nat_from_nat_id to_nat_less_card to_nat_mono)"], ["proof (state)\nthis:\n  ia = i + mod_type_class.from_nat a\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = 0", "have \"1 \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> a", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> mod_type_class.to_nat ia - mod_type_class.to_nat i", "by (metis diff_is_0_eq i_less_ia less_one not_less to_nat_mono)"], ["proof (state)\nthis:\n  1 \\<le> a\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = 0", "moreover"], ["proof (state)\nthis:\n  1 \\<le> a\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = 0", "have \"a < ncols A - to_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < ncols A - mod_type_class.to_nat i", "unfolding a_def ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat ia - mod_type_class.to_nat i\n    < CARD('n) - mod_type_class.to_nat i", "by (metis False diff_less_mono not_less to_nat_less_card to_nat_mono')"], ["proof (state)\nthis:\n  a < ncols A - mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> ia < i \\<Longrightarrow> U $ i $ ia = 0", "ultimately"], ["proof (chain)\npicking this:\n  1 \\<le> a\n  a < ncols A - mod_type_class.to_nat i", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> a\n  a < ncols A - mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. U $ i $ ia = 0", "using zero_above"], ["proof (prove)\nusing this:\n  1 \\<le> a\n  a < ncols A - mod_type_class.to_nat i\n  \\<forall>j s.\n     1 \\<le> j \\<and>\n     j < ncols A - mod_type_class.to_nat s \\<longrightarrow>\n     U $ s $ (s + mod_type_class.from_nat j) = 0\n\ngoal (1 subgoal):\n 1. U $ i $ ia = 0", "unfolding ia_eq"], ["proof (prove)\nusing this:\n  1 \\<le> a\n  a < ncols A - mod_type_class.to_nat i\n  \\<forall>j s.\n     1 \\<le> j \\<and>\n     j < ncols A - mod_type_class.to_nat s \\<longrightarrow>\n     U $ s $ (s + mod_type_class.from_nat j) = 0\n\ngoal (1 subgoal):\n 1. U $ i $ (i + mod_type_class.from_nat a) = 0", "by blast"], ["proof (state)\nthis:\n  U $ i $ ia = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U $ i $ ia = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U = mat 1\n\ngoal (1 subgoal):\n 1. H = K", "thus ?thesis"], ["proof (prove)\nusing this:\n  U = mat 1\n\ngoal (1 subgoal):\n 1. H = K", "using H_UK matrix_mul_lid"], ["proof (prove)\nusing this:\n  U = mat 1\n  H = U ** K\n  mat (1::?'a) ** ?A = ?A\n\ngoal (1 subgoal):\n 1. H = K", "by fast"], ["proof (state)\nthis:\n  H = K\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}