{"file_name": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms/Signed_Modulo.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms", "problem_names": ["lemma sym_mod_code[code]: \"sym_mod x y = (let m = x mod y\n   in if m + m \\<le> y then m else m - y)\"", "lemma sym_mod_zero[simp]: \"n symmod 0 = n\" \"n > 0 \\<Longrightarrow> 0 symmod n = 0\"", "lemma sym_mod_range: \"y > 0 \\<Longrightarrow> x symmod y \\<in> {- ((y - 1) div 2) .. y div 2}\"", "lemma card_sym_mod_range: \"y > 0 \\<Longrightarrow> card {- ((y - 1) div 2) .. y div 2} = y\"", "lemma sym_mod_abs: \"y > 0 \\<Longrightarrow> \\<bar>x symmod y\\<bar> < y\"\n  \"y \\<ge> 1 \\<Longrightarrow> \\<bar>x symmod y\\<bar> \\<le> y div 2\"", "lemma sym_mod_sym_mod[simp]: \"x symmod y symmod y = x symmod (y :: int)\"", "lemma sym_mod_diff_eq: \"(a symmod c - b symmod c) symmod c = (a - b) symmod c\"", "lemma sym_mod_sym_mod_cancel: \"c dvd b \\<Longrightarrow> a symmod b symmod c = a symmod c\"", "lemma sym_mod_diff_right_eq: \"(a - b symmod c) symmod c = (a - b) symmod c\"", "lemma sym_mod_mult_right_eq: \"a * (b symmod c) symmod c = a * b symmod c\"", "lemma dvd_imp_sym_mod_0 [simp]:\n  \"b symmod a = 0\" if \"a > 0\" \"a dvd b\"", "lemma sym_mod_0_imp_dvd [dest!]:\n  \"b dvd a\" if \"a symmod b = 0\"", "lemma of_int_mod_integer: \"(of_int (x mod y) :: integer) = (of_int x :: integer) mod (of_int y)\"", "lemma sym_div_code[code]: \n  \"sym_div x y = (let yy = integer_of_int y in \n     (case divmod_integer (integer_of_int x) yy\n     of (d, m) \\<Rightarrow> if m + m \\<le> yy then int_of_integer d else (int_of_integer (d + 1))))\"", "lemma sym_mod_sym_div: assumes y: \"y > 0\" shows \"x symmod y = x - sym_div x y * y\"", "lemma dvd_sym_div_mult_right [simp]:\n  \"(a symdiv b) * b = a\" if \"b > 0\" \"b dvd a\"", "lemma dvd_sym_div_mult_left [simp]:\n  \"b * (a symdiv b) = a\" if \"b > 0\" \"b dvd a\""], "translations": [["", "lemma sym_mod_code[code]: \"sym_mod x y = (let m = x mod y\n   in if m + m \\<le> y then m else m - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x symmod y = (let m = x mod y in if m + m \\<le> y then m else m - y)", "unfolding sym_mod_def poly_mod.inv_M_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x mod y + x mod y \\<le> y then x mod y else x mod y - y) =\n    (if x mod y + x mod y \\<le> y then x mod y else x mod y - y)", ".."], ["", "lemma sym_mod_zero[simp]: \"n symmod 0 = n\" \"n > 0 \\<Longrightarrow> 0 symmod n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n symmod 0 = n &&& (0 < n \\<Longrightarrow> 0 symmod n = 0)", "unfolding sym_mod_def poly_mod.inv_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n mod 0 + n mod 0 \\<le> 0 then n mod 0 else n mod 0 - 0) = n &&&\n    (0 < n \\<Longrightarrow>\n     (if 0 mod n + 0 mod n \\<le> n then 0 mod n else 0 mod n - n) = 0)", "by auto"], ["", "lemma sym_mod_range: \"y > 0 \\<Longrightarrow> x symmod y \\<in> {- ((y - 1) div 2) .. y div 2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> x symmod y \\<in> {- ((y - 1) div 2)..y div 2}", "unfolding sym_mod_def poly_mod.inv_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow>\n    (if x mod y + x mod y \\<le> y then x mod y else x mod y - y)\n    \\<in> {- ((y - 1) div 2)..y div 2}", "using pos_mod_bound[of y x]"], ["proof (prove)\nusing this:\n  0 < y \\<Longrightarrow> x mod y < y\n\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow>\n    (if x mod y + x mod y \\<le> y then x mod y else x mod y - y)\n    \\<in> {- ((y - 1) div 2)..y div 2}", "by (cases \"x mod y \\<ge> y\", auto) \n    (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign half_nonnegative_int_iff)+"], ["", "text \\<open>The range is optimal in the sense that exactly y elements can be represented.\\<close>"], ["", "lemma card_sym_mod_range: \"y > 0 \\<Longrightarrow> card {- ((y - 1) div 2) .. y div 2} = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> card {- int ((y - 1) div 2)..int (y div 2)} = y", "by simp"], ["", "lemma sym_mod_abs: \"y > 0 \\<Longrightarrow> \\<bar>x symmod y\\<bar> < y\"\n  \"y \\<ge> 1 \\<Longrightarrow> \\<bar>x symmod y\\<bar> \\<le> y div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < y \\<Longrightarrow> \\<bar>x symmod y\\<bar> < y) &&&\n    (1 \\<le> y \\<Longrightarrow> \\<bar>x symmod y\\<bar> \\<le> y div 2)", "using sym_mod_range[of y x]"], ["proof (prove)\nusing this:\n  0 < y \\<Longrightarrow> x symmod y \\<in> {- ((y - 1) div 2)..y div 2}\n\ngoal (1 subgoal):\n 1. (0 < y \\<Longrightarrow> \\<bar>x symmod y\\<bar> < y) &&&\n    (1 \\<le> y \\<Longrightarrow> \\<bar>x symmod y\\<bar> \\<le> y div 2)", "by auto"], ["", "lemma sym_mod_sym_mod[simp]: \"x symmod y symmod y = x symmod (y :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x symmod y symmod y = x symmod y", "unfolding sym_mod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.inv_M y (poly_mod.inv_M y (x mod y) mod y) =\n    poly_mod.inv_M y (x mod y)", "using poly_mod.M_def poly_mod.M_inv_M_id"], ["proof (prove)\nusing this:\n  poly_mod.M ?m ?x = ?x mod ?m\n  poly_mod.M ?m (poly_mod.inv_M ?m ?x) = poly_mod.M ?m ?x\n\ngoal (1 subgoal):\n 1. poly_mod.inv_M y (poly_mod.inv_M y (x mod y) mod y) =\n    poly_mod.inv_M y (x mod y)", "by auto"], ["", "lemma sym_mod_diff_eq: \"(a symmod c - b symmod c) symmod c = (a - b) symmod c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a symmod c - b symmod c) symmod c = (a - b) symmod c", "unfolding sym_mod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.inv_M c\n     ((poly_mod.inv_M c (a mod c) - poly_mod.inv_M c (b mod c)) mod c) =\n    poly_mod.inv_M c ((a - b) mod c)", "by (metis mod_diff_cong mod_mod_trivial poly_mod.M_def poly_mod.M_inv_M_id)"], ["", "lemma sym_mod_sym_mod_cancel: \"c dvd b \\<Longrightarrow> a symmod b symmod c = a symmod c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c dvd b \\<Longrightarrow> a symmod b symmod c = a symmod c", "using mod_mod_cancel[of c b]"], ["proof (prove)\nusing this:\n  c dvd b \\<Longrightarrow> ?a mod b mod c = ?a mod c\n\ngoal (1 subgoal):\n 1. c dvd b \\<Longrightarrow> a symmod b symmod c = a symmod c", "unfolding sym_mod_def"], ["proof (prove)\nusing this:\n  c dvd b \\<Longrightarrow> ?a mod b mod c = ?a mod c\n\ngoal (1 subgoal):\n 1. c dvd b \\<Longrightarrow>\n    poly_mod.inv_M c (poly_mod.inv_M b (a mod b) mod c) =\n    poly_mod.inv_M c (a mod c)", "by (metis poly_mod.M_def poly_mod.M_inv_M_id)"], ["", "lemma sym_mod_diff_right_eq: \"(a - b symmod c) symmod c = (a - b) symmod c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a - b symmod c) symmod c = (a - b) symmod c", "using sym_mod_diff_eq"], ["proof (prove)\nusing this:\n  (?a symmod ?c - ?b symmod ?c) symmod ?c = (?a - ?b) symmod ?c\n\ngoal (1 subgoal):\n 1. (a - b symmod c) symmod c = (a - b) symmod c", "by (metis sym_mod_sym_mod)"], ["", "lemma sym_mod_mult_right_eq: \"a * (b symmod c) symmod c = a * b symmod c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (b symmod c) symmod c = a * b symmod c", "unfolding sym_mod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.inv_M c (a * poly_mod.inv_M c (b mod c) mod c) =\n    poly_mod.inv_M c (a * b mod c)", "by (metis poly_mod.M_def poly_mod.M_inv_M_id mod_mult_right_eq)"], ["", "lemma dvd_imp_sym_mod_0 [simp]:\n  \"b symmod a = 0\" if \"a > 0\" \"a dvd b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b symmod a = 0", "unfolding sym_mod_def poly_mod.inv_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b mod a + b mod a \\<le> a then b mod a else b mod a - a) = 0", "using that"], ["proof (prove)\nusing this:\n  0 < a\n  a dvd b\n\ngoal (1 subgoal):\n 1. (if b mod a + b mod a \\<le> a then b mod a else b mod a - a) = 0", "by simp"], ["", "lemma sym_mod_0_imp_dvd [dest!]:\n  \"b dvd a\" if \"a symmod b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b dvd a", "using that"], ["proof (prove)\nusing this:\n  a symmod b = 0\n\ngoal (1 subgoal):\n 1. b dvd a", "unfolding sym_mod_def poly_mod.inv_M_def"], ["proof (prove)\nusing this:\n  (if a mod b + a mod b \\<le> b then a mod b else a mod b - b) = 0\n\ngoal (1 subgoal):\n 1. b dvd a", "by (smt (verit) Euclidean_Division.pos_mod_bound dvd_eq_mod_eq_0)"], ["", "definition sym_div :: \"int \\<Rightarrow> int \\<Rightarrow> int\" (infixl \"symdiv\" 70) where\n  \"sym_div x y = (let d = x div y; m = x mod y in \n       if m + m \\<le> y then d else d + 1)\""], ["", "lemma of_int_mod_integer: \"(of_int (x mod y) :: integer) = (of_int x :: integer) mod (of_int y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (x mod y) = of_int x mod of_int y", "using integer_of_int_eq_of_int modulo_integer.abs_eq"], ["proof (prove)\nusing this:\n  integer_of_int = of_int\n  integer_of_int ?xa mod integer_of_int ?x = integer_of_int (?xa mod ?x)\n\ngoal (1 subgoal):\n 1. of_int (x mod y) = of_int x mod of_int y", "by presburger"], ["", "lemma sym_div_code[code]: \n  \"sym_div x y = (let yy = integer_of_int y in \n     (case divmod_integer (integer_of_int x) yy\n     of (d, m) \\<Rightarrow> if m + m \\<le> yy then int_of_integer d else (int_of_integer (d + 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x symdiv y =\n    (let yy = integer_of_int y\n     in case divmod_integer (integer_of_int x) yy of\n        (d, m) \\<Rightarrow>\n          if m + m \\<le> yy then int_of_integer d\n          else int_of_integer (d + 1))", "unfolding sym_div_def Let_def divmod_integer_def split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x mod y + x mod y \\<le> y then x div y else x div y + 1) =\n    (if integer_of_int x mod integer_of_int y +\n        integer_of_int x mod integer_of_int y\n        \\<le> integer_of_int y\n     then int_of_integer (integer_of_int x div integer_of_int y)\n     else int_of_integer (integer_of_int x div integer_of_int y + 1))", "apply (rule if_cong, subst of_int_le_iff[symmetric], unfold of_int_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (of_int (x mod y) + of_int (x mod y) \\<le> of_int y) =\n    (integer_of_int x mod integer_of_int y +\n     integer_of_int x mod integer_of_int y\n     \\<le> integer_of_int y)\n 2. integer_of_int x mod integer_of_int y +\n    integer_of_int x mod integer_of_int y\n    \\<le> integer_of_int y \\<Longrightarrow>\n    x div y = int_of_integer (integer_of_int x div integer_of_int y)\n 3. \\<not> integer_of_int x mod integer_of_int y +\n           integer_of_int x mod integer_of_int y\n           \\<le> integer_of_int y \\<Longrightarrow>\n    x div y + 1 = int_of_integer (integer_of_int x div integer_of_int y + 1)", "by (subst (1 2) of_int_mod_integer, auto)"], ["", "lemma sym_mod_sym_div: assumes y: \"y > 0\" shows \"x symmod y = x - sym_div x y * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "let ?z = \"x - y * (x div y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "let ?u = \"y * (x div y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "have \"x = y * (x div y) + x mod y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y * (x div y) + x mod y", "using y"], ["proof (prove)\nusing this:\n  0 < y\n\ngoal (1 subgoal):\n 1. x = y * (x div y) + x mod y", "by simp"], ["proof (state)\nthis:\n  x = y * (x div y) + x mod y\n\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "hence id: \"x mod y = ?z\""], ["proof (prove)\nusing this:\n  x = y * (x div y) + x mod y\n\ngoal (1 subgoal):\n 1. x mod y = x - y * (x div y)", "by linarith"], ["proof (state)\nthis:\n  x mod y = x - y * (x div y)\n\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "have \"x symmod y = poly_mod.inv_M y ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x symmod y = poly_mod.inv_M y (x - y * (x div y))", "unfolding sym_mod_def id"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.inv_M y (x - y * (x div y)) =\n    poly_mod.inv_M y (x - y * (x div y))", "by auto"], ["proof (state)\nthis:\n  x symmod y = poly_mod.inv_M y (x - y * (x div y))\n\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "also"], ["proof (state)\nthis:\n  x symmod y = poly_mod.inv_M y (x - y * (x div y))\n\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "have \"\\<dots> = (if ?z + ?z \\<le> y then ?z else ?z - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mod.inv_M y (x - y * (x div y)) =\n    (if x - y * (x div y) + (x - y * (x div y)) \\<le> y\n     then x - y * (x div y) else x - y * (x div y) - y)", "unfolding poly_mod.inv_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x - y * (x div y) + (x - y * (x div y)) \\<le> y\n     then x - y * (x div y) else x - y * (x div y) - y) =\n    (if x - y * (x div y) + (x - y * (x div y)) \\<le> y\n     then x - y * (x div y) else x - y * (x div y) - y)", ".."], ["proof (state)\nthis:\n  poly_mod.inv_M y (x - y * (x div y)) =\n  (if x - y * (x div y) + (x - y * (x div y)) \\<le> y then x - y * (x div y)\n   else x - y * (x div y) - y)\n\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "also"], ["proof (state)\nthis:\n  poly_mod.inv_M y (x - y * (x div y)) =\n  (if x - y * (x div y) + (x - y * (x div y)) \\<le> y then x - y * (x div y)\n   else x - y * (x div y) - y)\n\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "have \"\\<dots> = x - (if (x mod y) + (x mod y) \\<le> y then x div y else x div y + 1) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x - y * (x div y) + (x - y * (x div y)) \\<le> y\n     then x - y * (x div y) else x - y * (x div y) - y) =\n    x - (if x mod y + x mod y \\<le> y then x div y else x div y + 1) * y", "by (simp add: algebra_simps id)"], ["proof (state)\nthis:\n  (if x - y * (x div y) + (x - y * (x div y)) \\<le> y then x - y * (x div y)\n   else x - y * (x div y) - y) =\n  x - (if x mod y + x mod y \\<le> y then x div y else x div y + 1) * y\n\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "also"], ["proof (state)\nthis:\n  (if x - y * (x div y) + (x - y * (x div y)) \\<le> y then x - y * (x div y)\n   else x - y * (x div y) - y) =\n  x - (if x mod y + x mod y \\<le> y then x div y else x div y + 1) * y\n\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "have \"(if (x mod y) + (x mod y) \\<le> y then x div y else x div y + 1) = sym_div x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x mod y + x mod y \\<le> y then x div y else x div y + 1) =\n    x symdiv y", "unfolding sym_div_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x mod y + x mod y \\<le> y then x div y else x div y + 1) =\n    (if x mod y + x mod y \\<le> y then x div y else x div y + 1)", ".."], ["proof (state)\nthis:\n  (if x mod y + x mod y \\<le> y then x div y else x div y + 1) = x symdiv y\n\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "finally"], ["proof (chain)\npicking this:\n  x symmod y = x - x symdiv y * y", "show ?thesis"], ["proof (prove)\nusing this:\n  x symmod y = x - x symdiv y * y\n\ngoal (1 subgoal):\n 1. x symmod y = x - x symdiv y * y", "."], ["proof (state)\nthis:\n  x symmod y = x - x symdiv y * y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_sym_div_mult_right [simp]:\n  \"(a symdiv b) * b = a\" if \"b > 0\" \"b dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a symdiv b * b = a", "using sym_mod_sym_div[of b a] that"], ["proof (prove)\nusing this:\n  0 < b \\<Longrightarrow> a symmod b = a - a symdiv b * b\n  0 < b\n  b dvd a\n\ngoal (1 subgoal):\n 1. a symdiv b * b = a", "by simp"], ["", "lemma dvd_sym_div_mult_left [simp]:\n  \"b * (a symdiv b) = a\" if \"b > 0\" \"b dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * (a symdiv b) = a", "using dvd_sym_div_mult_right[OF that]"], ["proof (prove)\nusing this:\n  a symdiv b * b = a\n\ngoal (1 subgoal):\n 1. b * (a symdiv b) = a", "by (simp add: ac_simps)"], ["", "end"]]}