{"file_name": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms/HNF_Mod_Det_Algorithm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms", "problem_names": ["lemma reduce_impl: \"a < nr \\<Longrightarrow> b < nr \\<Longrightarrow> 0 < nc \\<Longrightarrow> a \\<noteq> b \\<Longrightarrow> A \\<in> carrier_mat nr nc\n  \\<Longrightarrow> reduce_impl a b D A = reduce a b D A\"", "lemma reduce_abs_impl: \"a < nr \\<Longrightarrow> b < nr \\<Longrightarrow> 0 < nc \\<Longrightarrow> a \\<noteq> b \\<Longrightarrow> A \\<in> carrier_mat nr nc\n  \\<Longrightarrow> reduce_abs_impl a b D A = reduce_abs a b D A\"", "lemma reduce_impl_carrier[simp,intro]: \"A \\<in> carrier_mat m n \\<Longrightarrow> reduce_impl a b D A \\<in> carrier_mat m n\"", "lemma reduce_below_impl: \"a < nr \\<Longrightarrow> 0 < nc \\<Longrightarrow> (\\<And> b. b \\<in> set bs \\<Longrightarrow> b < nr) \\<Longrightarrow> a \\<notin> set bs \n  \\<Longrightarrow> A \\<in> carrier_mat nr nc \\<Longrightarrow> reduce_below_impl a bs D A = reduce_below a bs D A\"", "lemma reduce_abs_impl_carrier[simp,intro]: \"A \\<in> carrier_mat m n \\<Longrightarrow> reduce_abs_impl a b D A \\<in> carrier_mat m n\"", "lemma reduce_abs_below_impl: \"a < nr \\<Longrightarrow> 0 < nc \\<Longrightarrow> (\\<And> b. b \\<in> set bs \\<Longrightarrow> b < nr) \\<Longrightarrow> a \\<notin> set bs \n  \\<Longrightarrow> A \\<in> carrier_mat nr nc \\<Longrightarrow> reduce_below_abs_impl a bs D A = reduce_below_abs a bs D A\"", "lemma FindPreHNF_code: \"FindPreHNF abs_flag D A = \n  (let m = dim_row A; n = dim_col A in \n  if m < 2 \\<or> n = 0 then A else \n  let non_zero_positions = filter (\\<lambda>i. A $$ (i,0) \\<noteq> 0) [1..<dim_row A];\n         A' = (if A$$(0,0) \\<noteq> 0 then A\n              else let i = non_zero_positions ! 0 in swaprows 0 i A  \n              );\n         Reduce_impl = (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\n    in\n      if n < 2 then Reduce_impl 0 non_zero_positions D A'   \n    else \n      let         \n        (A_UL,A_UR,A_DL,A_DR) = split_block (Reduce_impl 0 non_zero_positions D (make_first_column_positive A')) 1 1; \n        sub_PreHNF = FindPreHNF abs_flag D A_DR in       \n        four_block_mat A_UL A_UR A_DL sub_PreHNF)\"  (is \"?lhs = ?rhs\")"], "translations": [["", "lemma reduce_impl: \"a < nr \\<Longrightarrow> b < nr \\<Longrightarrow> 0 < nc \\<Longrightarrow> a \\<noteq> b \\<Longrightarrow> A \\<in> carrier_mat nr nc\n  \\<Longrightarrow> reduce_impl a b D A = reduce a b D A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < nr; b < nr; 0 < nc; a \\<noteq> b;\n     A \\<in> carrier_mat nr nc\\<rbrakk>\n    \\<Longrightarrow> reduce_impl a b D A = reduce a b D A", "unfolding reduce_impl_def reduce.simps Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < nr; b < nr; 0 < nc; a \\<noteq> b;\n     A \\<in> carrier_mat nr nc\\<rbrakk>\n    \\<Longrightarrow> (if Matrix.row A a $v 0 = 0 then A\n                       else case euclid_ext2 (Matrix.row A a $v 0)\n                                  (Matrix.row A b $v 0) of\n                            (p, q, u, v, d) \\<Rightarrow>\n                              change_row a\n                               (\\<lambda>k ak.\n                                   if k = 0\n                                   then if D dvd\n     p * ak + q * Matrix.row A b $v k\n  then D else p * ak + q * Matrix.row A b $v k\n                                   else (p * ak +\n   q * Matrix.row A b $v k) gmod\n  D)\n                               (change_row b\n                                 (\\<lambda>k bk.\n                                     if k = 0\n                                     then u * Matrix.row A a $v k + v * bk\n                                     else (u * Matrix.row A a $v k +\n     v * bk) gmod\n    D)\n                                 A)) =\n                      (if A $$ (a, 0) = 0 then A\n                       else case euclid_ext2 (A $$ (a, 0)) (A $$ (b, 0)) of\n                            (p, q, u, v, d) \\<Rightarrow>\n                              Matrix.mat (dim_row A) (dim_col A)\n                               (\\<lambda>(i, k).\n                                   if i = a\n                                   then if k = 0\n  then if D dvd p * A $$ (a, k) + q * A $$ (b, k) then D\n       else p * A $$ (a, k) + q * A $$ (b, k)\n  else (p * A $$ (a, k) + q * A $$ (b, k)) gmod D\n                                   else if i = b\n  then if k = 0 then u * A $$ (a, k) + v * A $$ (b, k)\n       else (u * A $$ (a, k) + v * A $$ (b, k)) gmod D\n  else A $$ (i, k)))", "apply (intro if_cong[OF _ refl], force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < nr; b < nr; 0 < nc; a \\<noteq> b;\n     A \\<in> carrier_mat nr nc; A $$ (a, 0) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (case euclid_ext2 (Matrix.row A a $v 0)\n                             (Matrix.row A b $v 0) of\n                       (p, q, u, v, d) \\<Rightarrow>\n                         change_row a\n                          (\\<lambda>k ak.\n                              if k = 0\n                              then if D dvd p * ak + q * Matrix.row A b $v k\n                                   then D\n                                   else p * ak + q * Matrix.row A b $v k\n                              else (p * ak + q * Matrix.row A b $v k) gmod\n                                   D)\n                          (change_row b\n                            (\\<lambda>k bk.\n                                if k = 0\n                                then u * Matrix.row A a $v k + v * bk\n                                else (u * Matrix.row A a $v k + v * bk) gmod\n                                     D)\n                            A)) =\n                      (case euclid_ext2 (A $$ (a, 0)) (A $$ (b, 0)) of\n                       (p, q, u, v, d) \\<Rightarrow>\n                         Matrix.mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, k).\n                              if i = a\n                              then if k = 0\n                                   then if D dvd\n     p * A $$ (a, k) + q * A $$ (b, k)\n  then D else p * A $$ (a, k) + q * A $$ (b, k)\n                                   else (p * A $$ (a, k) +\n   q * A $$ (b, k)) gmod\n  D\n                              else if i = b\n                                   then if k = 0\n  then u * A $$ (a, k) + v * A $$ (b, k)\n  else (u * A $$ (a, k) + v * A $$ (b, k)) gmod D\n                                   else A $$ (i, k)))", "apply (intro prod.case_cong refl, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x2 q x2a u x2b v d.\n       \\<lbrakk>a < nr; b < nr; 0 < nc; a \\<noteq> b;\n        A \\<in> carrier_mat nr nc; A $$ (a, 0) \\<noteq> 0;\n        euclid_ext2 (A $$ (a, 0)) (A $$ (b, 0)) = (p, x2); x2 = (q, x2a);\n        x2a = (u, x2b); x2b = (v, d)\\<rbrakk>\n       \\<Longrightarrow> change_row a\n                          (\\<lambda>k ak.\n                              if k = 0\n                              then if D dvd p * ak + q * Matrix.row A b $v k\n                                   then D\n                                   else p * ak + q * Matrix.row A b $v k\n                              else (p * ak + q * Matrix.row A b $v k) gmod\n                                   D)\n                          (change_row b\n                            (\\<lambda>k bk.\n                                if k = 0\n                                then u * Matrix.row A a $v k + v * bk\n                                else (u * Matrix.row A a $v k + v * bk) gmod\n                                     D)\n                            A) =\n                         Matrix.mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, k).\n                              if i = a\n                              then if k = 0\n                                   then if D dvd\n     p * A $$ (a, k) + q * A $$ (b, k)\n  then D else p * A $$ (a, k) + q * A $$ (b, k)\n                                   else (p * A $$ (a, k) +\n   q * A $$ (b, k)) gmod\n  D\n                              else if i = b\n                                   then if k = 0\n  then u * A $$ (a, k) + v * A $$ (b, k)\n  else (u * A $$ (a, k) + v * A $$ (b, k)) gmod D\n                                   else A $$ (i, k))", "apply (intro eq_matI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reduce_abs_impl: \"a < nr \\<Longrightarrow> b < nr \\<Longrightarrow> 0 < nc \\<Longrightarrow> a \\<noteq> b \\<Longrightarrow> A \\<in> carrier_mat nr nc\n  \\<Longrightarrow> reduce_abs_impl a b D A = reduce_abs a b D A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < nr; b < nr; 0 < nc; a \\<noteq> b;\n     A \\<in> carrier_mat nr nc\\<rbrakk>\n    \\<Longrightarrow> reduce_abs_impl a b D A = reduce_abs a b D A", "unfolding reduce_abs_impl_def reduce_abs.simps Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < nr; b < nr; 0 < nc; a \\<noteq> b;\n     A \\<in> carrier_mat nr nc\\<rbrakk>\n    \\<Longrightarrow> (if Matrix.row A a $v 0 = 0 then A\n                       else case euclid_ext2 (Matrix.row A a $v 0)\n                                  (Matrix.row A b $v 0) of\n                            (p, q, u, v, d) \\<Rightarrow>\n                              change_row a\n                               (\\<lambda>k ak.\n                                   if D\n< \\<bar>p * ak + q * Matrix.row A b $v k\\<bar>\n                                   then if k = 0 \\<and>\n     D dvd p * ak + q * Matrix.row A b $v k\n  then D else (p * ak + q * Matrix.row A b $v k) gmod D\n                                   else p * ak + q * Matrix.row A b $v k)\n                               (change_row b\n                                 (\\<lambda>k bk.\n                                     if D\n  < \\<bar>u * Matrix.row A a $v k + v * bk\\<bar>\n                                     then (u * Matrix.row A a $v k +\n     v * bk) gmod\n    D\n                                     else u * Matrix.row A a $v k + v * bk)\n                                 A)) =\n                      (if A $$ (a, 0) = 0 then A\n                       else case euclid_ext2 (A $$ (a, 0)) (A $$ (b, 0)) of\n                            (p, q, u, v, d) \\<Rightarrow>\n                              Matrix.mat (dim_row A) (dim_col A)\n                               (\\<lambda>(i, k).\n                                   if i = a\n                                   then if D\n     < \\<bar>p * A $$ (a, k) + q * A $$ (b, k)\\<bar>\n  then if k = 0 \\<and> D dvd p * A $$ (a, k) + q * A $$ (b, k) then D\n       else (p * A $$ (a, k) + q * A $$ (b, k)) gmod D\n  else p * A $$ (a, k) + q * A $$ (b, k)\n                                   else if i = b\n  then if D < \\<bar>u * A $$ (a, k) + v * A $$ (b, k)\\<bar>\n       then (u * A $$ (a, k) + v * A $$ (b, k)) gmod D\n       else u * A $$ (a, k) + v * A $$ (b, k)\n  else A $$ (i, k)))", "apply (intro if_cong[OF _ refl], force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < nr; b < nr; 0 < nc; a \\<noteq> b;\n     A \\<in> carrier_mat nr nc; A $$ (a, 0) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (case euclid_ext2 (Matrix.row A a $v 0)\n                             (Matrix.row A b $v 0) of\n                       (p, q, u, v, d) \\<Rightarrow>\n                         change_row a\n                          (\\<lambda>k ak.\n                              if D < \\<bar>p * ak +\n     q * Matrix.row A b $v k\\<bar>\n                              then if k = 0 \\<and>\nD dvd p * ak + q * Matrix.row A b $v k\n                                   then D\n                                   else (p * ak +\n   q * Matrix.row A b $v k) gmod\n  D\n                              else p * ak + q * Matrix.row A b $v k)\n                          (change_row b\n                            (\\<lambda>k bk.\n                                if D < \\<bar>u * Matrix.row A a $v k +\n       v * bk\\<bar>\n                                then (u * Matrix.row A a $v k + v * bk) gmod\n                                     D\n                                else u * Matrix.row A a $v k + v * bk)\n                            A)) =\n                      (case euclid_ext2 (A $$ (a, 0)) (A $$ (b, 0)) of\n                       (p, q, u, v, d) \\<Rightarrow>\n                         Matrix.mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, k).\n                              if i = a\n                              then if D\n< \\<bar>p * A $$ (a, k) + q * A $$ (b, k)\\<bar>\n                                   then if k = 0 \\<and>\n     D dvd p * A $$ (a, k) + q * A $$ (b, k)\n  then D else (p * A $$ (a, k) + q * A $$ (b, k)) gmod D\n                                   else p * A $$ (a, k) + q * A $$ (b, k)\n                              else if i = b\n                                   then if D\n     < \\<bar>u * A $$ (a, k) + v * A $$ (b, k)\\<bar>\n  then (u * A $$ (a, k) + v * A $$ (b, k)) gmod D\n  else u * A $$ (a, k) + v * A $$ (b, k)\n                                   else A $$ (i, k)))", "apply (intro prod.case_cong refl, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x2 q x2a u x2b v d.\n       \\<lbrakk>a < nr; b < nr; 0 < nc; a \\<noteq> b;\n        A \\<in> carrier_mat nr nc; A $$ (a, 0) \\<noteq> 0;\n        euclid_ext2 (A $$ (a, 0)) (A $$ (b, 0)) = (p, x2); x2 = (q, x2a);\n        x2a = (u, x2b); x2b = (v, d)\\<rbrakk>\n       \\<Longrightarrow> change_row a\n                          (\\<lambda>k ak.\n                              if D < \\<bar>p * ak +\n     q * Matrix.row A b $v k\\<bar>\n                              then if k = 0 \\<and>\nD dvd p * ak + q * Matrix.row A b $v k\n                                   then D\n                                   else (p * ak +\n   q * Matrix.row A b $v k) gmod\n  D\n                              else p * ak + q * Matrix.row A b $v k)\n                          (change_row b\n                            (\\<lambda>k bk.\n                                if D < \\<bar>u * Matrix.row A a $v k +\n       v * bk\\<bar>\n                                then (u * Matrix.row A a $v k + v * bk) gmod\n                                     D\n                                else u * Matrix.row A a $v k + v * bk)\n                            A) =\n                         Matrix.mat (dim_row A) (dim_col A)\n                          (\\<lambda>(i, k).\n                              if i = a\n                              then if D\n< \\<bar>p * A $$ (a, k) + q * A $$ (b, k)\\<bar>\n                                   then if k = 0 \\<and>\n     D dvd p * A $$ (a, k) + q * A $$ (b, k)\n  then D else (p * A $$ (a, k) + q * A $$ (b, k)) gmod D\n                                   else p * A $$ (a, k) + q * A $$ (b, k)\n                              else if i = b\n                                   then if D\n     < \\<bar>u * A $$ (a, k) + v * A $$ (b, k)\\<bar>\n  then (u * A $$ (a, k) + v * A $$ (b, k)) gmod D\n  else u * A $$ (a, k) + v * A $$ (b, k)\n                                   else A $$ (i, k))", "apply (intro eq_matI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* This functions reduce the elements below the position (a,0), given a list of positions \n   of non-zero positions as input*)"], ["", "fun reduce_below :: \"nat \\<Rightarrow> nat list \\<Rightarrow> int \\<Rightarrow> int mat \\<Rightarrow> int mat\"\nwhere \"reduce_below a [] D A = A\"\n  | \"reduce_below a (x # xs) D A = reduce_below a xs D (reduce a x D A)\""], ["", "fun reduce_below_impl :: \"nat \\<Rightarrow> nat list \\<Rightarrow> int \\<Rightarrow> int mat \\<Rightarrow> int mat\"\nwhere \"reduce_below_impl a [] D A = A\"\n  | \"reduce_below_impl a (x # xs) D A = reduce_below_impl a xs D (reduce_impl a x D A)\""], ["", "lemma reduce_impl_carrier[simp,intro]: \"A \\<in> carrier_mat m n \\<Longrightarrow> reduce_impl a b D A \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat m n \\<Longrightarrow>\n    reduce_impl a b D A \\<in> carrier_mat m n", "unfolding reduce_impl_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat m n \\<Longrightarrow>\n    (if Matrix.row A a $v 0 = 0 then A\n     else case euclid_ext2 (Matrix.row A a $v 0) (Matrix.row A b $v 0) of\n          (p, q, u, v, d) \\<Rightarrow>\n            change_row a\n             (\\<lambda>k ak.\n                 if k = 0\n                 then if D dvd p * ak + q * Matrix.row A b $v k then D\n                      else p * ak + q * Matrix.row A b $v k\n                 else (p * ak + q * Matrix.row A b $v k) gmod D)\n             (change_row b\n               (\\<lambda>k bk.\n                   if k = 0 then u * Matrix.row A a $v k + v * bk\n                   else (u * Matrix.row A a $v k + v * bk) gmod D)\n               A))\n    \\<in> carrier_mat m n", "by (auto split: prod.splits)"], ["", "lemma reduce_below_impl: \"a < nr \\<Longrightarrow> 0 < nc \\<Longrightarrow> (\\<And> b. b \\<in> set bs \\<Longrightarrow> b < nr) \\<Longrightarrow> a \\<notin> set bs \n  \\<Longrightarrow> A \\<in> carrier_mat nr nc \\<Longrightarrow> reduce_below_impl a bs D A = reduce_below a bs D A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < nr; 0 < nc;\n     \\<And>b. b \\<in> set bs \\<Longrightarrow> b < nr; a \\<notin> set bs;\n     A \\<in> carrier_mat nr nc\\<rbrakk>\n    \\<Longrightarrow> reduce_below_impl a bs D A = reduce_below a bs D A", "proof (induct bs arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>a < nr; 0 < nc;\n        \\<And>b. b \\<in> set [] \\<Longrightarrow> b < nr; a \\<notin> set [];\n        A \\<in> carrier_mat nr nc\\<rbrakk>\n       \\<Longrightarrow> reduce_below_impl a [] D A = reduce_below a [] D A\n 2. \\<And>aa bs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>a < nr; 0 < nc;\n                    \\<And>b. b \\<in> set bs \\<Longrightarrow> b < nr;\n                    a \\<notin> set bs; A \\<in> carrier_mat nr nc\\<rbrakk>\n                   \\<Longrightarrow> reduce_below_impl a bs D A =\n                                     reduce_below a bs D A;\n        a < nr; 0 < nc;\n        \\<And>b. b \\<in> set (aa # bs) \\<Longrightarrow> b < nr;\n        a \\<notin> set (aa # bs); A \\<in> carrier_mat nr nc\\<rbrakk>\n       \\<Longrightarrow> reduce_below_impl a (aa # bs) D A =\n                         reduce_below a (aa # bs) D A", "case (Cons b bs A)"], ["proof (state)\nthis:\n  \\<lbrakk>a < nr; 0 < nc; \\<And>b. b \\<in> set bs \\<Longrightarrow> b < nr;\n   a \\<notin> set bs; ?A \\<in> carrier_mat nr nc\\<rbrakk>\n  \\<Longrightarrow> reduce_below_impl a bs D ?A = reduce_below a bs D ?A\n  a < nr\n  0 < nc\n  ?b \\<in> set (b # bs) \\<Longrightarrow> ?b < nr\n  a \\<notin> set (b # bs)\n  A \\<in> carrier_mat nr nc\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>a < nr; 0 < nc;\n        \\<And>b. b \\<in> set [] \\<Longrightarrow> b < nr; a \\<notin> set [];\n        A \\<in> carrier_mat nr nc\\<rbrakk>\n       \\<Longrightarrow> reduce_below_impl a [] D A = reduce_below a [] D A\n 2. \\<And>aa bs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>a < nr; 0 < nc;\n                    \\<And>b. b \\<in> set bs \\<Longrightarrow> b < nr;\n                    a \\<notin> set bs; A \\<in> carrier_mat nr nc\\<rbrakk>\n                   \\<Longrightarrow> reduce_below_impl a bs D A =\n                                     reduce_below a bs D A;\n        a < nr; 0 < nc;\n        \\<And>b. b \\<in> set (aa # bs) \\<Longrightarrow> b < nr;\n        a \\<notin> set (aa # bs); A \\<in> carrier_mat nr nc\\<rbrakk>\n       \\<Longrightarrow> reduce_below_impl a (aa # bs) D A =\n                         reduce_below a (aa # bs) D A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_below_impl a (b # bs) D A = reduce_below a (b # bs) D A", "by (simp del: reduce.simps, \n      subst reduce_impl[of _ nr _ nc], \n      (insert Cons, auto simp del: reduce.simps)[5],\n      rule Cons(1), insert Cons(2-), auto simp: Let_def split: prod.splits)"], ["proof (state)\nthis:\n  reduce_below_impl a (b # bs) D A = reduce_below a (b # bs) D A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>a < nr; 0 < nc;\n        \\<And>b. b \\<in> set [] \\<Longrightarrow> b < nr; a \\<notin> set [];\n        A \\<in> carrier_mat nr nc\\<rbrakk>\n       \\<Longrightarrow> reduce_below_impl a [] D A = reduce_below a [] D A", "qed simp"], ["", "fun reduce_below_abs :: \"nat \\<Rightarrow> nat list \\<Rightarrow> int \\<Rightarrow> int mat \\<Rightarrow> int mat\"\nwhere \"reduce_below_abs a [] D A = A\"\n  | \"reduce_below_abs a (x # xs) D A = reduce_below_abs a xs D (reduce_abs a x D A)\""], ["", "fun reduce_below_abs_impl :: \"nat \\<Rightarrow> nat list \\<Rightarrow> int \\<Rightarrow> int mat \\<Rightarrow> int mat\"\nwhere \"reduce_below_abs_impl a [] D A = A\"\n  | \"reduce_below_abs_impl a (x # xs) D A = reduce_below_abs_impl a xs D (reduce_abs_impl a x D A)\""], ["", "lemma reduce_abs_impl_carrier[simp,intro]: \"A \\<in> carrier_mat m n \\<Longrightarrow> reduce_abs_impl a b D A \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat m n \\<Longrightarrow>\n    reduce_abs_impl a b D A \\<in> carrier_mat m n", "unfolding reduce_abs_impl_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat m n \\<Longrightarrow>\n    (if Matrix.row A a $v 0 = 0 then A\n     else case euclid_ext2 (Matrix.row A a $v 0) (Matrix.row A b $v 0) of\n          (p, q, u, v, d) \\<Rightarrow>\n            change_row a\n             (\\<lambda>k ak.\n                 if D < \\<bar>p * ak + q * Matrix.row A b $v k\\<bar>\n                 then if k = 0 \\<and> D dvd p * ak + q * Matrix.row A b $v k\n                      then D else (p * ak + q * Matrix.row A b $v k) gmod D\n                 else p * ak + q * Matrix.row A b $v k)\n             (change_row b\n               (\\<lambda>k bk.\n                   if D < \\<bar>u * Matrix.row A a $v k + v * bk\\<bar>\n                   then (u * Matrix.row A a $v k + v * bk) gmod D\n                   else u * Matrix.row A a $v k + v * bk)\n               A))\n    \\<in> carrier_mat m n", "by (auto split: prod.splits)"], ["", "lemma reduce_abs_below_impl: \"a < nr \\<Longrightarrow> 0 < nc \\<Longrightarrow> (\\<And> b. b \\<in> set bs \\<Longrightarrow> b < nr) \\<Longrightarrow> a \\<notin> set bs \n  \\<Longrightarrow> A \\<in> carrier_mat nr nc \\<Longrightarrow> reduce_below_abs_impl a bs D A = reduce_below_abs a bs D A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < nr; 0 < nc;\n     \\<And>b. b \\<in> set bs \\<Longrightarrow> b < nr; a \\<notin> set bs;\n     A \\<in> carrier_mat nr nc\\<rbrakk>\n    \\<Longrightarrow> reduce_below_abs_impl a bs D A =\n                      reduce_below_abs a bs D A", "proof (induct bs arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>a < nr; 0 < nc;\n        \\<And>b. b \\<in> set [] \\<Longrightarrow> b < nr; a \\<notin> set [];\n        A \\<in> carrier_mat nr nc\\<rbrakk>\n       \\<Longrightarrow> reduce_below_abs_impl a [] D A =\n                         reduce_below_abs a [] D A\n 2. \\<And>aa bs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>a < nr; 0 < nc;\n                    \\<And>b. b \\<in> set bs \\<Longrightarrow> b < nr;\n                    a \\<notin> set bs; A \\<in> carrier_mat nr nc\\<rbrakk>\n                   \\<Longrightarrow> reduce_below_abs_impl a bs D A =\n                                     reduce_below_abs a bs D A;\n        a < nr; 0 < nc;\n        \\<And>b. b \\<in> set (aa # bs) \\<Longrightarrow> b < nr;\n        a \\<notin> set (aa # bs); A \\<in> carrier_mat nr nc\\<rbrakk>\n       \\<Longrightarrow> reduce_below_abs_impl a (aa # bs) D A =\n                         reduce_below_abs a (aa # bs) D A", "case (Cons b bs A)"], ["proof (state)\nthis:\n  \\<lbrakk>a < nr; 0 < nc; \\<And>b. b \\<in> set bs \\<Longrightarrow> b < nr;\n   a \\<notin> set bs; ?A \\<in> carrier_mat nr nc\\<rbrakk>\n  \\<Longrightarrow> reduce_below_abs_impl a bs D ?A =\n                    reduce_below_abs a bs D ?A\n  a < nr\n  0 < nc\n  ?b \\<in> set (b # bs) \\<Longrightarrow> ?b < nr\n  a \\<notin> set (b # bs)\n  A \\<in> carrier_mat nr nc\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>a < nr; 0 < nc;\n        \\<And>b. b \\<in> set [] \\<Longrightarrow> b < nr; a \\<notin> set [];\n        A \\<in> carrier_mat nr nc\\<rbrakk>\n       \\<Longrightarrow> reduce_below_abs_impl a [] D A =\n                         reduce_below_abs a [] D A\n 2. \\<And>aa bs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>a < nr; 0 < nc;\n                    \\<And>b. b \\<in> set bs \\<Longrightarrow> b < nr;\n                    a \\<notin> set bs; A \\<in> carrier_mat nr nc\\<rbrakk>\n                   \\<Longrightarrow> reduce_below_abs_impl a bs D A =\n                                     reduce_below_abs a bs D A;\n        a < nr; 0 < nc;\n        \\<And>b. b \\<in> set (aa # bs) \\<Longrightarrow> b < nr;\n        a \\<notin> set (aa # bs); A \\<in> carrier_mat nr nc\\<rbrakk>\n       \\<Longrightarrow> reduce_below_abs_impl a (aa # bs) D A =\n                         reduce_below_abs a (aa # bs) D A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_below_abs_impl a (b # bs) D A = reduce_below_abs a (b # bs) D A", "by (simp del: reduce_abs.simps, \n      subst reduce_abs_impl[of _ nr _ nc], \n      (insert Cons, auto simp del: reduce_abs.simps)[5],\n      rule Cons(1), insert Cons(2-), auto simp: Let_def split: prod.splits)"], ["proof (state)\nthis:\n  reduce_below_abs_impl a (b # bs) D A = reduce_below_abs a (b # bs) D A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>a < nr; 0 < nc;\n        \\<And>b. b \\<in> set [] \\<Longrightarrow> b < nr; a \\<notin> set [];\n        A \\<in> carrier_mat nr nc\\<rbrakk>\n       \\<Longrightarrow> reduce_below_abs_impl a [] D A =\n                         reduce_below_abs a [] D A", "qed simp"], ["", "text \\<open>This function outputs a matrix in echelon form via reductions modulo the determinant\\<close>"], ["", "function FindPreHNF :: \"bool \\<Rightarrow> int \\<Rightarrow> int mat \\<Rightarrow> int mat\"\n  where \"FindPreHNF abs_flag D A = \n  (let m = dim_row A; n = dim_col A in \n  if m < 2 \\<or> n = 0 then A else \\<comment> \\<open> No operations are carried out if m = 1 \\<close>\n  let non_zero_positions = filter (\\<lambda>i. A $$ (i,0) \\<noteq> 0) [1..<dim_row A];\n         A' = (if A$$(0,0) \\<noteq> 0 then A\n              else let i = non_zero_positions ! 0  \\<comment> \\<open> Select the first non-zero position below the first element\\<close>\n                   in swaprows 0 i A  \n              );\n        Reduce = (if abs_flag then reduce_below_abs else reduce_below)\n    in\n      if n < 2 then Reduce 0 non_zero_positions D A'  \\<comment> \\<open> If n = 1, then we have to reduce the column \\<close>   \n    else \n      let         \n        (A_UL,A_UR,A_DL,A_DR) = split_block (Reduce 0 non_zero_positions D (make_first_column_positive A')) 1 1; \n        sub_PreHNF = FindPreHNF abs_flag D A_DR in       \n        four_block_mat A_UL A_UR A_DL sub_PreHNF)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>abs_flag D A.\n           x = (abs_flag, D, A) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>abs_flag D A abs_flaga Da Aa.\n       (abs_flag, D, A) = (abs_flaga, Da, Aa) \\<Longrightarrow>\n       (let m = dim_row A; n = dim_col A\n        in if m < 2 \\<or> n = 0 then A\n           else let non_zero_positions =\n                      filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A];\n                    A' = if A $$ (0, 0) \\<noteq> 0 then A\n                         else let i = non_zero_positions ! 0\n                              in swaprows 0 i A;\n                    Reduce =\n                      if abs_flag then reduce_below_abs else reduce_below\n                in if n < 2 then Reduce 0 non_zero_positions D A'\n                   else let (A_UL, A_UR, A_DL, A_DR) =\n                              split_block\n                               (Reduce 0 non_zero_positions D\n                                 (make_first_column_positive A'))\n                               1 1\n                        in Let (FindPreHNF_sumC (abs_flag, D, A_DR))\n                            (four_block_mat A_UL A_UR A_DL)) =\n       (let m = dim_row Aa; n = dim_col Aa\n        in if m < 2 \\<or> n = 0 then Aa\n           else let non_zero_positions =\n                      filter (\\<lambda>i. Aa $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row Aa];\n                    A' = if Aa $$ (0, 0) \\<noteq> 0 then Aa\n                         else let i = non_zero_positions ! 0\n                              in swaprows 0 i Aa;\n                    Reduce =\n                      if abs_flaga then reduce_below_abs else reduce_below\n                in if n < 2 then Reduce 0 non_zero_positions Da A'\n                   else let (A_UL, A_UR, A_DL, A_DR) =\n                              split_block\n                               (Reduce 0 non_zero_positions Da\n                                 (make_first_column_positive A'))\n                               1 1\n                        in Let (FindPreHNF_sumC (abs_flaga, Da, A_DR))\n                            (four_block_mat A_UL A_UR A_DL))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All FindPreHNF_dom", "proof (relation \"Wellfounded.measure (\\<lambda>(abs_flag,D,A). dim_col A)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (Wellfounded.measure (\\<lambda>(abs_flag, D, A). dim_col A))\n 2. \\<And>abs_flag D A x xa xb xc xd xe xf y xg ya xh yb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; \\<not> (x < 2 \\<or> xa = 0);\n        xb = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A];\n        xc =\n        (if A $$ (0, 0) \\<noteq> 0 then A\n         else let i = xb ! 0 in swaprows 0 i A);\n        xd = (if abs_flag then reduce_below_abs else reduce_below);\n        \\<not> xa < 2;\n        xe = split_block (xd 0 xb D (make_first_column_positive xc)) 1 1;\n        (xf, y) = xe; (xg, ya) = y; (xh, yb) = ya\\<rbrakk>\n       \\<Longrightarrow> ((abs_flag, D, yb), abs_flag, D, A)\n                         \\<in> Wellfounded.measure\n                                (\\<lambda>(abs_flag, D, A). dim_col A)", "show \"wf (Wellfounded.measure (\\<lambda>(abs_flag,D, A). dim_col A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (Wellfounded.measure (\\<lambda>(abs_flag, D, A). dim_col A))", "by auto"], ["proof (state)\nthis:\n  wf (Wellfounded.measure (\\<lambda>(abs_flag, D, A). dim_col A))\n\ngoal (1 subgoal):\n 1. \\<And>abs_flag D A x xa xb xc xd xe xf y xg ya xh yb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; \\<not> (x < 2 \\<or> xa = 0);\n        xb = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A];\n        xc =\n        (if A $$ (0, 0) \\<noteq> 0 then A\n         else let i = xb ! 0 in swaprows 0 i A);\n        xd = (if abs_flag then reduce_below_abs else reduce_below);\n        \\<not> xa < 2;\n        xe = split_block (xd 0 xb D (make_first_column_positive xc)) 1 1;\n        (xf, y) = xe; (xg, ya) = y; (xh, yb) = ya\\<rbrakk>\n       \\<Longrightarrow> ((abs_flag, D, yb), abs_flag, D, A)\n                         \\<in> Wellfounded.measure\n                                (\\<lambda>(abs_flag, D, A). dim_col A)", "fix abs_flag D A m n nz A' R xd A'_UL y A'_UR ya A'_DL A'_DR"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>abs_flag D A x xa xb xc xd xe xf y xg ya xh yb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; \\<not> (x < 2 \\<or> xa = 0);\n        xb = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A];\n        xc =\n        (if A $$ (0, 0) \\<noteq> 0 then A\n         else let i = xb ! 0 in swaprows 0 i A);\n        xd = (if abs_flag then reduce_below_abs else reduce_below);\n        \\<not> xa < 2;\n        xe = split_block (xd 0 xb D (make_first_column_positive xc)) 1 1;\n        (xf, y) = xe; (xg, ya) = y; (xh, yb) = ya\\<rbrakk>\n       \\<Longrightarrow> ((abs_flag, D, yb), abs_flag, D, A)\n                         \\<in> Wellfounded.measure\n                                (\\<lambda>(abs_flag, D, A). dim_col A)", "assume m: \"m = dim_row A\" and n:\"n = dim_col A\"\n    and m2: \"\\<not> (m < 2 \\<or> n = 0)\" and nz_def: \"nz = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A] \"\n    and A'_def: \"A' = (if A $$ (0, 0) \\<noteq> 0 then A else let i = nz ! 0 in swaprows 0 i A)\"\n    and R_def: \"R = (if abs_flag then reduce_below_abs else reduce_below)\"\n    and n2: \"\\<not> n < 2\" and \"xd = split_block (R 0 nz D (make_first_column_positive A')) 1 1\"\n    and \"(A'_UL, y) = xd\" and \"(A'_UR, ya) = y\" and \"(A'_DL, A'_DR) = ya\""], ["proof (state)\nthis:\n  m = dim_row A\n  n = dim_col A\n  \\<not> (m < 2 \\<or> n = 0)\n  nz = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A]\n  A' =\n  (if A $$ (0, 0) \\<noteq> 0 then A else let i = nz ! 0 in swaprows 0 i A)\n  R = (if abs_flag then reduce_below_abs else reduce_below)\n  \\<not> n < 2\n  xd = split_block (R 0 nz D (make_first_column_positive A')) 1 1\n  (A'_UL, y) = xd\n  (A'_UR, ya) = y\n  (A'_DL, A'_DR) = ya\n\ngoal (1 subgoal):\n 1. \\<And>abs_flag D A x xa xb xc xd xe xf y xg ya xh yb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; \\<not> (x < 2 \\<or> xa = 0);\n        xb = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A];\n        xc =\n        (if A $$ (0, 0) \\<noteq> 0 then A\n         else let i = xb ! 0 in swaprows 0 i A);\n        xd = (if abs_flag then reduce_below_abs else reduce_below);\n        \\<not> xa < 2;\n        xe = split_block (xd 0 xb D (make_first_column_positive xc)) 1 1;\n        (xf, y) = xe; (xg, ya) = y; (xh, yb) = ya\\<rbrakk>\n       \\<Longrightarrow> ((abs_flag, D, yb), abs_flag, D, A)\n                         \\<in> Wellfounded.measure\n                                (\\<lambda>(abs_flag, D, A). dim_col A)", "hence A'_split: \"(A'_UL, A'_UR, A'_DL, A'_DR) \n        = split_block (R 0 nz D (make_first_column_positive A')) 1 1\""], ["proof (prove)\nusing this:\n  m = dim_row A\n  n = dim_col A\n  \\<not> (m < 2 \\<or> n = 0)\n  nz = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A]\n  A' =\n  (if A $$ (0, 0) \\<noteq> 0 then A else let i = nz ! 0 in swaprows 0 i A)\n  R = (if abs_flag then reduce_below_abs else reduce_below)\n  \\<not> n < 2\n  xd = split_block (R 0 nz D (make_first_column_positive A')) 1 1\n  (A'_UL, y) = xd\n  (A'_UR, ya) = y\n  (A'_DL, A'_DR) = ya\n\ngoal (1 subgoal):\n 1. (A'_UL, A'_UR, A'_DL, A'_DR) =\n    split_block (R 0 nz D (make_first_column_positive A')) 1 1", "by force"], ["proof (state)\nthis:\n  (A'_UL, A'_UR, A'_DL, A'_DR) =\n  split_block (R 0 nz D (make_first_column_positive A')) 1 1\n\ngoal (1 subgoal):\n 1. \\<And>abs_flag D A x xa xb xc xd xe xf y xg ya xh yb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; \\<not> (x < 2 \\<or> xa = 0);\n        xb = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A];\n        xc =\n        (if A $$ (0, 0) \\<noteq> 0 then A\n         else let i = xb ! 0 in swaprows 0 i A);\n        xd = (if abs_flag then reduce_below_abs else reduce_below);\n        \\<not> xa < 2;\n        xe = split_block (xd 0 xb D (make_first_column_positive xc)) 1 1;\n        (xf, y) = xe; (xg, ya) = y; (xh, yb) = ya\\<rbrakk>\n       \\<Longrightarrow> ((abs_flag, D, yb), abs_flag, D, A)\n                         \\<in> Wellfounded.measure\n                                (\\<lambda>(abs_flag, D, A). dim_col A)", "have dr_mk1: \"dim_row (make_first_column_positive A) = dim_row A\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (make_first_column_positive A) = dim_row A", "by auto"], ["proof (state)\nthis:\n  dim_row (make_first_column_positive ?A1) = dim_row ?A1\n\ngoal (1 subgoal):\n 1. \\<And>abs_flag D A x xa xb xc xd xe xf y xg ya xh yb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; \\<not> (x < 2 \\<or> xa = 0);\n        xb = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A];\n        xc =\n        (if A $$ (0, 0) \\<noteq> 0 then A\n         else let i = xb ! 0 in swaprows 0 i A);\n        xd = (if abs_flag then reduce_below_abs else reduce_below);\n        \\<not> xa < 2;\n        xe = split_block (xd 0 xb D (make_first_column_positive xc)) 1 1;\n        (xf, y) = xe; (xg, ya) = y; (xh, yb) = ya\\<rbrakk>\n       \\<Longrightarrow> ((abs_flag, D, yb), abs_flag, D, A)\n                         \\<in> Wellfounded.measure\n                                (\\<lambda>(abs_flag, D, A). dim_col A)", "have dr_mk2: \"dim_col (make_first_column_positive A) = dim_col A\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (make_first_column_positive A) = dim_col A", "by auto"], ["proof (state)\nthis:\n  dim_col (make_first_column_positive ?A1) = dim_col ?A1\n\ngoal (1 subgoal):\n 1. \\<And>abs_flag D A x xa xb xc xd xe xf y xg ya xh yb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; \\<not> (x < 2 \\<or> xa = 0);\n        xb = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A];\n        xc =\n        (if A $$ (0, 0) \\<noteq> 0 then A\n         else let i = xb ! 0 in swaprows 0 i A);\n        xd = (if abs_flag then reduce_below_abs else reduce_below);\n        \\<not> xa < 2;\n        xe = split_block (xd 0 xb D (make_first_column_positive xc)) 1 1;\n        (xf, y) = xe; (xg, ya) = y; (xh, yb) = ya\\<rbrakk>\n       \\<Longrightarrow> ((abs_flag, D, yb), abs_flag, D, A)\n                         \\<in> Wellfounded.measure\n                                (\\<lambda>(abs_flag, D, A). dim_col A)", "have r1: \"reduce_below a xs D A \\<in> carrier_mat m n\" if \"A \\<in> carrier_mat m n\" for A a xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_below a xs D A \\<in> carrier_mat m n", "using that"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. reduce_below a xs D A \\<in> carrier_mat m n", "by (induct a xs D A rule: reduce_below.induct, auto simp add: Let_def euclid_ext2_def)"], ["proof (state)\nthis:\n  ?A1 \\<in> carrier_mat m n \\<Longrightarrow>\n  reduce_below ?a1 ?xs1 D ?A1 \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. \\<And>abs_flag D A x xa xb xc xd xe xf y xg ya xh yb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; \\<not> (x < 2 \\<or> xa = 0);\n        xb = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A];\n        xc =\n        (if A $$ (0, 0) \\<noteq> 0 then A\n         else let i = xb ! 0 in swaprows 0 i A);\n        xd = (if abs_flag then reduce_below_abs else reduce_below);\n        \\<not> xa < 2;\n        xe = split_block (xd 0 xb D (make_first_column_positive xc)) 1 1;\n        (xf, y) = xe; (xg, ya) = y; (xh, yb) = ya\\<rbrakk>\n       \\<Longrightarrow> ((abs_flag, D, yb), abs_flag, D, A)\n                         \\<in> Wellfounded.measure\n                                (\\<lambda>(abs_flag, D, A). dim_col A)", "hence R: \"(reduce_below 0 nz D (make_first_column_positive A')) \\<in> carrier_mat m n\""], ["proof (prove)\nusing this:\n  ?A1 \\<in> carrier_mat m n \\<Longrightarrow>\n  reduce_below ?a1 ?xs1 D ?A1 \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. reduce_below 0 nz D (make_first_column_positive A')\n    \\<in> carrier_mat m n", "using A'_def m n"], ["proof (prove)\nusing this:\n  ?A1 \\<in> carrier_mat m n \\<Longrightarrow>\n  reduce_below ?a1 ?xs1 D ?A1 \\<in> carrier_mat m n\n  A' =\n  (if A $$ (0, 0) \\<noteq> 0 then A else let i = nz ! 0 in swaprows 0 i A)\n  m = dim_row A\n  n = dim_col A\n\ngoal (1 subgoal):\n 1. reduce_below 0 nz D (make_first_column_positive A')\n    \\<in> carrier_mat m n", "by (metis carrier_matI index_mat_swaprows(2,3) dr_mk1 dr_mk2)"], ["proof (state)\nthis:\n  reduce_below 0 nz D (make_first_column_positive A') \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. \\<And>abs_flag D A x xa xb xc xd xe xf y xg ya xh yb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; \\<not> (x < 2 \\<or> xa = 0);\n        xb = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A];\n        xc =\n        (if A $$ (0, 0) \\<noteq> 0 then A\n         else let i = xb ! 0 in swaprows 0 i A);\n        xd = (if abs_flag then reduce_below_abs else reduce_below);\n        \\<not> xa < 2;\n        xe = split_block (xd 0 xb D (make_first_column_positive xc)) 1 1;\n        (xf, y) = xe; (xg, ya) = y; (xh, yb) = ya\\<rbrakk>\n       \\<Longrightarrow> ((abs_flag, D, yb), abs_flag, D, A)\n                         \\<in> Wellfounded.measure\n                                (\\<lambda>(abs_flag, D, A). dim_col A)", "have \"reduce_below_abs a xs D A \\<in> carrier_mat m n\" if \"A \\<in> carrier_mat m n\" for A a xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_below_abs a xs D A \\<in> carrier_mat m n", "using that"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. reduce_below_abs a xs D A \\<in> carrier_mat m n", "by (induct a xs D A rule: reduce_below_abs.induct, auto simp add: Let_def euclid_ext2_def)"], ["proof (state)\nthis:\n  ?A1 \\<in> carrier_mat m n \\<Longrightarrow>\n  reduce_below_abs ?a1 ?xs1 D ?A1 \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. \\<And>abs_flag D A x xa xb xc xd xe xf y xg ya xh yb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; \\<not> (x < 2 \\<or> xa = 0);\n        xb = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A];\n        xc =\n        (if A $$ (0, 0) \\<noteq> 0 then A\n         else let i = xb ! 0 in swaprows 0 i A);\n        xd = (if abs_flag then reduce_below_abs else reduce_below);\n        \\<not> xa < 2;\n        xe = split_block (xd 0 xb D (make_first_column_positive xc)) 1 1;\n        (xf, y) = xe; (xg, ya) = y; (xh, yb) = ya\\<rbrakk>\n       \\<Longrightarrow> ((abs_flag, D, yb), abs_flag, D, A)\n                         \\<in> Wellfounded.measure\n                                (\\<lambda>(abs_flag, D, A). dim_col A)", "hence R2: \"(reduce_below_abs 0 nz D (make_first_column_positive A')) \\<in> carrier_mat m n\""], ["proof (prove)\nusing this:\n  ?A1 \\<in> carrier_mat m n \\<Longrightarrow>\n  reduce_below_abs ?a1 ?xs1 D ?A1 \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. reduce_below_abs 0 nz D (make_first_column_positive A')\n    \\<in> carrier_mat m n", "using A'_def m n"], ["proof (prove)\nusing this:\n  ?A1 \\<in> carrier_mat m n \\<Longrightarrow>\n  reduce_below_abs ?a1 ?xs1 D ?A1 \\<in> carrier_mat m n\n  A' =\n  (if A $$ (0, 0) \\<noteq> 0 then A else let i = nz ! 0 in swaprows 0 i A)\n  m = dim_row A\n  n = dim_col A\n\ngoal (1 subgoal):\n 1. reduce_below_abs 0 nz D (make_first_column_positive A')\n    \\<in> carrier_mat m n", "by (metis carrier_matI index_mat_swaprows(2,3) dr_mk1 dr_mk2)"], ["proof (state)\nthis:\n  reduce_below_abs 0 nz D (make_first_column_positive A')\n  \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. \\<And>abs_flag D A x xa xb xc xd xe xf y xg ya xh yb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; \\<not> (x < 2 \\<or> xa = 0);\n        xb = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A];\n        xc =\n        (if A $$ (0, 0) \\<noteq> 0 then A\n         else let i = xb ! 0 in swaprows 0 i A);\n        xd = (if abs_flag then reduce_below_abs else reduce_below);\n        \\<not> xa < 2;\n        xe = split_block (xd 0 xb D (make_first_column_positive xc)) 1 1;\n        (xf, y) = xe; (xg, ya) = y; (xh, yb) = ya\\<rbrakk>\n       \\<Longrightarrow> ((abs_flag, D, yb), abs_flag, D, A)\n                         \\<in> Wellfounded.measure\n                                (\\<lambda>(abs_flag, D, A). dim_col A)", "have \"A'_DR \\<in> carrier_mat (m-1) (n-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A'_DR \\<in> carrier_mat (m - 1) (n - 1)", "by (cases abs_flag; rule split_block(4)[OF A'_split[symmetric]],insert m2 n2 m n R_def R R2, auto)"], ["proof (state)\nthis:\n  A'_DR \\<in> carrier_mat (m - 1) (n - 1)\n\ngoal (1 subgoal):\n 1. \\<And>abs_flag D A x xa xb xc xd xe xf y xg ya xh yb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; \\<not> (x < 2 \\<or> xa = 0);\n        xb = filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A];\n        xc =\n        (if A $$ (0, 0) \\<noteq> 0 then A\n         else let i = xb ! 0 in swaprows 0 i A);\n        xd = (if abs_flag then reduce_below_abs else reduce_below);\n        \\<not> xa < 2;\n        xe = split_block (xd 0 xb D (make_first_column_positive xc)) 1 1;\n        (xf, y) = xe; (xg, ya) = y; (xh, yb) = ya\\<rbrakk>\n       \\<Longrightarrow> ((abs_flag, D, yb), abs_flag, D, A)\n                         \\<in> Wellfounded.measure\n                                (\\<lambda>(abs_flag, D, A). dim_col A)", "thus \"((abs_flag, D, A'_DR),abs_flag, D, A) \\<in> Wellfounded.measure (\\<lambda>(abs_flag,D, A). dim_col A)\""], ["proof (prove)\nusing this:\n  A'_DR \\<in> carrier_mat (m - 1) (n - 1)\n\ngoal (1 subgoal):\n 1. ((abs_flag, D, A'_DR), abs_flag, D, A)\n    \\<in> Wellfounded.measure (\\<lambda>(abs_flag, D, A). dim_col A)", "using n2 m2 n m"], ["proof (prove)\nusing this:\n  A'_DR \\<in> carrier_mat (m - 1) (n - 1)\n  \\<not> n < 2\n  \\<not> (m < 2 \\<or> n = 0)\n  n = dim_col A\n  m = dim_row A\n\ngoal (1 subgoal):\n 1. ((abs_flag, D, A'_DR), abs_flag, D, A)\n    \\<in> Wellfounded.measure (\\<lambda>(abs_flag, D, A). dim_col A)", "by auto"], ["proof (state)\nthis:\n  ((abs_flag, D, A'_DR), abs_flag, D, A)\n  \\<in> Wellfounded.measure (\\<lambda>(abs_flag, D, A). dim_col A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FindPreHNF_code: \"FindPreHNF abs_flag D A = \n  (let m = dim_row A; n = dim_col A in \n  if m < 2 \\<or> n = 0 then A else \n  let non_zero_positions = filter (\\<lambda>i. A $$ (i,0) \\<noteq> 0) [1..<dim_row A];\n         A' = (if A$$(0,0) \\<noteq> 0 then A\n              else let i = non_zero_positions ! 0 in swaprows 0 i A  \n              );\n         Reduce_impl = (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\n    in\n      if n < 2 then Reduce_impl 0 non_zero_positions D A'   \n    else \n      let         \n        (A_UL,A_UR,A_DL,A_DR) = split_block (Reduce_impl 0 non_zero_positions D (make_first_column_positive A')) 1 1; \n        sub_PreHNF = FindPreHNF abs_flag D A_DR in       \n        four_block_mat A_UL A_UR A_DL sub_PreHNF)\"  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. FindPreHNF abs_flag D A =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. FindPreHNF abs_flag D A =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "let ?f = \"\\<lambda>R. (if dim_row A < 2 \\<or> dim_col A = 0 then A else if dim_col A < 2\n          then R 0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A]) D\n  (if A $$ (0, 0) \\<noteq> 0 then A else swaprows 0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A] ! 0) A)\n  else case split_block (R 0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A]) D\n    (make_first_column_positive (if A $$ (0, 0) \\<noteq> 0 then A else \n      swaprows 0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A] ! 0) A))) 1 1 of\n  (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow> four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\""], ["proof (state)\ngoal (1 subgoal):\n 1. FindPreHNF abs_flag D A =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "have M_carrier: \"make_first_column_positive (if A $$ (0, 0) \\<noteq> 0 then A \n    else swaprows 0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A] ! 0) A) \n    \\<in> carrier_mat (dim_row A) (dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. make_first_column_positive\n     (if A $$ (0, 0) \\<noteq> 0 then A\n      else swaprows 0\n            (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A] !\n             0)\n            A)\n    \\<in> carrier_mat (dim_row A) (dim_col A)", "by (smt (z3) index_mat_swaprows(2) index_mat_swaprows(3) make_first_column_positive.simps mat_carrier)"], ["proof (state)\nthis:\n  make_first_column_positive\n   (if A $$ (0, 0) \\<noteq> 0 then A\n    else swaprows 0\n          (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A] ! 0)\n          A)\n  \\<in> carrier_mat (dim_row A) (dim_col A)\n\ngoal (1 subgoal):\n 1. FindPreHNF abs_flag D A =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "have *: \"0 \\<notin> set (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> set (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                     [1..<dim_row A])", "by simp"], ["proof (state)\nthis:\n  0 \\<notin> set (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                   [1..<dim_row A])\n\ngoal (1 subgoal):\n 1. FindPreHNF abs_flag D A =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "have \"?lhs = ?f (if abs_flag then reduce_below_abs else reduce_below)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FindPreHNF abs_flag D A =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "unfolding FindPreHNF.simps[of abs_flag D A] Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "by presburger"], ["proof (state)\nthis:\n  FindPreHNF abs_flag D A =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (1 subgoal):\n 1. FindPreHNF abs_flag D A =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "also"], ["proof (state)\nthis:\n  FindPreHNF abs_flag D A =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (1 subgoal):\n 1. FindPreHNF abs_flag D A =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "have \"... = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "proof (cases abs_flag)"], ["proof (state)\ngoal (2 subgoals):\n 1. abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))\n 2. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "case True"], ["proof (state)\nthis:\n  abs_flag\n\ngoal (2 subgoals):\n 1. abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))\n 2. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "have \"?f (if abs_flag then reduce_below_abs else reduce_below) = ?f reduce_below_abs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then reduce_below_abs 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     (reduce_below_abs 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "using True"], ["proof (prove)\nusing this:\n  abs_flag\n\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then reduce_below_abs 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     (reduce_below_abs 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "by presburger"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below_abs 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below_abs 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (2 subgoals):\n 1. abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))\n 2. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "also"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below_abs 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below_abs 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (2 subgoals):\n 1. abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))\n 2. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "have \"... = ?f reduce_below_abs_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then reduce_below_abs 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     (reduce_below_abs 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then reduce_below_abs_impl 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     (reduce_below_abs_impl 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "by ((intro if_cong refl prod.case_cong arg_cong[of _ _ \"\\<lambda> x. split_block x 1 1\"];\n       (subst reduce_abs_below_impl[where nr = \"dim_row A\" and nc = \"dim_col A\"])), (auto)[9])\n       (insert M_carrier *, blast+)"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below_abs 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below_abs 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below_abs_impl 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below_abs_impl 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (2 subgoals):\n 1. abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))\n 2. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "also"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below_abs 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below_abs 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below_abs_impl 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below_abs_impl 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (2 subgoals):\n 1. abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))\n 2. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "have \"... = ?f (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then reduce_below_abs_impl 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     (reduce_below_abs_impl 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs_impl\n                else reduce_below_impl)\n                0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs_impl\n                       else reduce_below_impl)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "using True"], ["proof (prove)\nusing this:\n  abs_flag\n\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then reduce_below_abs_impl 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     (reduce_below_abs_impl 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs_impl\n                else reduce_below_impl)\n                0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs_impl\n                       else reduce_below_impl)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "by presburger"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below_abs_impl 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below_abs_impl 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\n              0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs_impl\n                     else reduce_below_impl)\n                     0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (2 subgoals):\n 1. abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))\n 2. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "finally"], ["proof (chain)\npicking this:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\n              0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs_impl\n                     else reduce_below_impl)\n                     0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "show ?thesis"], ["proof (prove)\nusing this:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\n              0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs_impl\n                     else reduce_below_impl)\n                     0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "using True"], ["proof (prove)\nusing this:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\n              0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs_impl\n                     else reduce_below_impl)\n                     0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n  abs_flag\n\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "unfolding FindPreHNF.simps[of abs_flag D A] Let_def"], ["proof (prove)\nusing this:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\n              0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs_impl\n                     else reduce_below_impl)\n                     0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n  abs_flag\n\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs_impl\n                else reduce_below_impl)\n                0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs_impl\n                       else reduce_below_impl)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "by blast"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (let m = dim_row A; n = dim_col A\n   in if m < 2 \\<or> n = 0 then A\n      else let non_zero_positions =\n                 filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A];\n               A' = if A $$ (0, 0) \\<noteq> 0 then A\n                    else let i = non_zero_positions ! 0 in swaprows 0 i A;\n               Reduce_impl =\n                 if abs_flag then reduce_below_abs_impl\n                 else reduce_below_impl\n           in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n              else let (A_UL, A_UR, A_DL, A_DR) =\n                         split_block\n                          (Reduce_impl 0 non_zero_positions D\n                            (make_first_column_positive A'))\n                          1 1\n                   in Let (FindPreHNF abs_flag D A_DR)\n                       (four_block_mat A_UL A_UR A_DL))\n\ngoal (1 subgoal):\n 1. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "case False"], ["proof (state)\nthis:\n  \\<not> abs_flag\n\ngoal (1 subgoal):\n 1. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "have \"?f (if abs_flag then reduce_below_abs else reduce_below) = ?f reduce_below\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then reduce_below 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     (reduce_below 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "using False"], ["proof (prove)\nusing this:\n  \\<not> abs_flag\n\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then reduce_below 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     (reduce_below 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "by presburger"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (1 subgoal):\n 1. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "also"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (1 subgoal):\n 1. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "have \"... = ?f reduce_below_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then reduce_below 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     (reduce_below 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then reduce_below_impl 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     (reduce_below_impl 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "by ((intro if_cong refl prod.case_cong arg_cong[of _ _ \"\\<lambda> x. split_block x 1 1\"];\n       (subst reduce_below_impl[where nr = \"dim_row A\" and nc = \"dim_col A\"])), (auto)[9])\n       (insert M_carrier *, blast+)"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below_impl 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below_impl 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (1 subgoal):\n 1. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "also"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below_impl 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below_impl 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (1 subgoal):\n 1. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "have \"... = ?f (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then reduce_below_impl 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     (reduce_below_impl 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs_impl\n                else reduce_below_impl)\n                0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs_impl\n                       else reduce_below_impl)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "using False"], ["proof (prove)\nusing this:\n  \\<not> abs_flag\n\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then reduce_below_impl 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     (reduce_below_impl 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs_impl\n                else reduce_below_impl)\n                0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs_impl\n                       else reduce_below_impl)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "by presburger"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then reduce_below_impl 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   (reduce_below_impl 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\n              0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs_impl\n                     else reduce_below_impl)\n                     0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (1 subgoal):\n 1. \\<not> abs_flag \\<Longrightarrow>\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "finally"], ["proof (chain)\npicking this:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\n              0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs_impl\n                     else reduce_below_impl)\n                     0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "show ?thesis"], ["proof (prove)\nusing this:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\n              0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs_impl\n                     else reduce_below_impl)\n                     0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "using False"], ["proof (prove)\nusing this:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\n              0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs_impl\n                     else reduce_below_impl)\n                     0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n  \\<not> abs_flag\n\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "unfolding FindPreHNF.simps[of abs_flag D A] Let_def"], ["proof (prove)\nusing this:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs_impl else reduce_below_impl)\n              0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs_impl\n                     else reduce_below_impl)\n                     0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))\n  \\<not> abs_flag\n\ngoal (1 subgoal):\n 1. (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs else reduce_below) 0\n                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs else reduce_below)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL\n                  (FindPreHNF abs_flag D A_DR)) =\n    (if dim_row A < 2 \\<or> dim_col A = 0 then A\n     else if dim_col A < 2\n          then (if abs_flag then reduce_below_abs_impl\n                else reduce_below_impl)\n                0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A])\n                D (if A $$ (0, 0) \\<noteq> 0 then A\n                   else swaprows 0\n                         (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A] !\n                          0)\n                         A)\n          else case split_block\n                     ((if abs_flag then reduce_below_abs_impl\n                       else reduce_below_impl)\n                       0 (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                           [1..<dim_row A])\n                       D (make_first_column_positive\n                           (if A $$ (0, 0) \\<noteq> 0 then A\n                            else swaprows 0\n                                  (filter\n                                    (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                    [1..<dim_row A] !\n                                   0)\n                                  A)))\n                     1 1 of\n               (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n                 four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR))", "by blast"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (let m = dim_row A; n = dim_col A\n   in if m < 2 \\<or> n = 0 then A\n      else let non_zero_positions =\n                 filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A];\n               A' = if A $$ (0, 0) \\<noteq> 0 then A\n                    else let i = non_zero_positions ! 0 in swaprows 0 i A;\n               Reduce_impl =\n                 if abs_flag then reduce_below_abs_impl\n                 else reduce_below_impl\n           in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n              else let (A_UL, A_UR, A_DL, A_DR) =\n                         split_block\n                          (Reduce_impl 0 non_zero_positions D\n                            (make_first_column_positive A'))\n                          1 1\n                   in Let (FindPreHNF abs_flag D A_DR)\n                       (four_block_mat A_UL A_UR A_DL))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if dim_row A < 2 \\<or> dim_col A = 0 then A\n   else if dim_col A < 2\n        then (if abs_flag then reduce_below_abs else reduce_below) 0\n              (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0) [1..<dim_row A])\n              D (if A $$ (0, 0) \\<noteq> 0 then A\n                 else swaprows 0\n                       (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                         [1..<dim_row A] !\n                        0)\n                       A)\n        else case split_block\n                   ((if abs_flag then reduce_below_abs else reduce_below) 0\n                     (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                       [1..<dim_row A])\n                     D (make_first_column_positive\n                         (if A $$ (0, 0) \\<noteq> 0 then A\n                          else swaprows 0\n                                (filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                                  [1..<dim_row A] !\n                                 0)\n                                A)))\n                   1 1 of\n             (A_UL, A_UR, A_DL, A_DR) \\<Rightarrow>\n               four_block_mat A_UL A_UR A_DL (FindPreHNF abs_flag D A_DR)) =\n  (let m = dim_row A; n = dim_col A\n   in if m < 2 \\<or> n = 0 then A\n      else let non_zero_positions =\n                 filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A];\n               A' = if A $$ (0, 0) \\<noteq> 0 then A\n                    else let i = non_zero_positions ! 0 in swaprows 0 i A;\n               Reduce_impl =\n                 if abs_flag then reduce_below_abs_impl\n                 else reduce_below_impl\n           in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n              else let (A_UL, A_UR, A_DL, A_DR) =\n                         split_block\n                          (Reduce_impl 0 non_zero_positions D\n                            (make_first_column_positive A'))\n                          1 1\n                   in Let (FindPreHNF abs_flag D A_DR)\n                       (four_block_mat A_UL A_UR A_DL))\n\ngoal (1 subgoal):\n 1. FindPreHNF abs_flag D A =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "finally"], ["proof (chain)\npicking this:\n  FindPreHNF abs_flag D A =\n  (let m = dim_row A; n = dim_col A\n   in if m < 2 \\<or> n = 0 then A\n      else let non_zero_positions =\n                 filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A];\n               A' = if A $$ (0, 0) \\<noteq> 0 then A\n                    else let i = non_zero_positions ! 0 in swaprows 0 i A;\n               Reduce_impl =\n                 if abs_flag then reduce_below_abs_impl\n                 else reduce_below_impl\n           in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n              else let (A_UL, A_UR, A_DL, A_DR) =\n                         split_block\n                          (Reduce_impl 0 non_zero_positions D\n                            (make_first_column_positive A'))\n                          1 1\n                   in Let (FindPreHNF abs_flag D A_DR)\n                       (four_block_mat A_UL A_UR A_DL))", "show ?thesis"], ["proof (prove)\nusing this:\n  FindPreHNF abs_flag D A =\n  (let m = dim_row A; n = dim_col A\n   in if m < 2 \\<or> n = 0 then A\n      else let non_zero_positions =\n                 filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A];\n               A' = if A $$ (0, 0) \\<noteq> 0 then A\n                    else let i = non_zero_positions ! 0 in swaprows 0 i A;\n               Reduce_impl =\n                 if abs_flag then reduce_below_abs_impl\n                 else reduce_below_impl\n           in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n              else let (A_UL, A_UR, A_DL, A_DR) =\n                         split_block\n                          (Reduce_impl 0 non_zero_positions D\n                            (make_first_column_positive A'))\n                          1 1\n                   in Let (FindPreHNF abs_flag D A_DR)\n                       (four_block_mat A_UL A_UR A_DL))\n\ngoal (1 subgoal):\n 1. FindPreHNF abs_flag D A =\n    (let m = dim_row A; n = dim_col A\n     in if m < 2 \\<or> n = 0 then A\n        else let non_zero_positions =\n                   filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                    [1..<dim_row A];\n                 A' = if A $$ (0, 0) \\<noteq> 0 then A\n                      else let i = non_zero_positions ! 0 in swaprows 0 i A;\n                 Reduce_impl =\n                   if abs_flag then reduce_below_abs_impl\n                   else reduce_below_impl\n             in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n                else let (A_UL, A_UR, A_DL, A_DR) =\n                           split_block\n                            (Reduce_impl 0 non_zero_positions D\n                              (make_first_column_positive A'))\n                            1 1\n                     in Let (FindPreHNF abs_flag D A_DR)\n                         (four_block_mat A_UL A_UR A_DL))", "by blast"], ["proof (state)\nthis:\n  FindPreHNF abs_flag D A =\n  (let m = dim_row A; n = dim_col A\n   in if m < 2 \\<or> n = 0 then A\n      else let non_zero_positions =\n                 filter (\\<lambda>i. A $$ (i, 0) \\<noteq> 0)\n                  [1..<dim_row A];\n               A' = if A $$ (0, 0) \\<noteq> 0 then A\n                    else let i = non_zero_positions ! 0 in swaprows 0 i A;\n               Reduce_impl =\n                 if abs_flag then reduce_below_abs_impl\n                 else reduce_below_impl\n           in if n < 2 then Reduce_impl 0 non_zero_positions D A'\n              else let (A_UL, A_UR, A_DL, A_DR) =\n                         split_block\n                          (Reduce_impl 0 non_zero_positions D\n                            (make_first_column_positive A'))\n                          1 1\n                   in Let (FindPreHNF abs_flag D A_DR)\n                       (four_block_mat A_UL A_UR A_DL))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "declare mod_operation.FindPreHNF_code[code]"], ["", "declare mod_operation.reduce_below_impl.simps[code]"], ["", "declare mod_operation.reduce_impl_def[code]"], ["", "declare mod_operation.reduce_below_abs_impl.simps[code]"], ["", "declare mod_operation.reduce_abs_impl_def[code]"], ["", "subsubsection \\<open>From echelon form to Hermite normal form\\<close>"], ["", "text \\<open>From here on, we define functions to transform a matrix in echelon form into its Hermite\nnormal form. Essentially, we are defining the functions that are available in the AFP entry Hermite\n(which uses HOL Analysis + mod-type) in the JNF matrix representation.\\<close>"], ["", "(*Find the first nonzero element of row l (A is upper triangular)*)"], ["", "definition find_fst_non0_in_row :: \"nat \\<Rightarrow> int mat \\<Rightarrow> nat option\" where\n  \"find_fst_non0_in_row l A = (let is = [l ..< dim_col A];\n    Ais = filter (\\<lambda>j. A $$ (l, j) \\<noteq> 0) is\n    in case Ais of [] \\<Rightarrow> None | _ \\<Rightarrow> Some (Ais!0))\""], ["", "primrec Hermite_reduce_above\nwhere \"Hermite_reduce_above (A::int mat) 0 i j = A\"\n    | \"Hermite_reduce_above A (Suc n) i j = (let\n    Aij = A $$ (i,j);\n    Anj = A $$ (n,j)\n    in \n    Hermite_reduce_above (addrow (- (Anj div Aij)) n i A) n i j)\""], ["", "definition Hermite_of_row_i :: \"int mat \\<Rightarrow> nat \\<Rightarrow> int mat\" \n  where \"Hermite_of_row_i A i = (\n  case find_fst_non0_in_row i A of None \\<Rightarrow> A | Some j \\<Rightarrow> \n    let Aij = A $$(i,j) in\n    if Aij < 0 then Hermite_reduce_above (multrow i (-1) A) i i j\n    else Hermite_reduce_above A i i j)\""], ["", "primrec Hermite_of_list_of_rows \n  where\n \"Hermite_of_list_of_rows A [] = A\" | \n \"Hermite_of_list_of_rows A (a#xs) = Hermite_of_list_of_rows (Hermite_of_row_i A a) xs\""], ["", "text \\<open>We combine the previous functions to assemble the algorithm\\<close>"], ["", "definition (in mod_operation) \"Hermite_mod_det abs_flag A = \n  (let m = dim_row A; n = dim_col A; \n   D = abs(det_int A); \n   A' = A @\\<^sub>r D \\<cdot>\\<^sub>m 1\\<^sub>m n;\n   E = FindPreHNF abs_flag D A';\n   H = Hermite_of_list_of_rows E [0..<m+n]\n  in mat_of_rows n (map (Matrix.row H) [0..<m]))\""], ["", "subsubsection \\<open>Some examples of execution\\<close>"], ["", "declare mod_operation.Hermite_mod_det_def[code]"], ["", "value \"let B = mat_of_rows_list 4 ([[0,3,1,4],[7,1,0,0],[8,0,19,16],[2,0,0,3::int]]) in\n  show (mod_operation.Hermite_mod_det (mod) True B)\""], ["", "(*\nsage: import sage.matrix.matrix_integer_dense_hnf as matrix_integer_dense_hnf\nsage: A = matrix(ZZ, [[0,3,1,4],[7,1,0,0],[8,0,19,16],[2,0,0,3]])\nsage: A\n[ 0  3  1  4]\n[ 7  1  0  0]\n[ 8  0 19 16]\n[ 2  0  0  3]\nsage:  H, U = matrix_integer_dense_hnf.hnf_with_transformation(A); H\n[   1    0    0  672]\n[   0    1    0  660]\n[   0    0    1  706]\n[   0    0    0 1341]\nsage: \n*)"], ["", "value \"let B = mat_of_rows_list 7 ([\n[  1,  17, -41,  -1,   1,   0,  0],\n[  0,  -1,   2,   0,  -6,   2,   1],\n[  9,   2,   1,   1,  -2,   2,  -5],\n[ -1,  -3,  -1,   0,  -9,   0,   0],\n[  9,  -1,  -9,   0,   0,   0,   1],\n[  1,  -1,   1,   0,   1,  -8,   0],\n[  1,  -1,   0,  -2,  -1,  -1,   0::int]]) in \n  show (mod_operation.Hermite_mod_det (mod) True B)\""], ["", "(*\nsage: import sage.matrix.matrix_integer_dense_hnf as matrix_integer_dense_hnf\nsage: A = random_matrix(ZZ,7,7); A\n[  1  17 -41  -1   1   0   0]\n[  0  -1   2   0  -6   2   1]\n[  9   2   1   1  -2   2  -5]\n[ -1  -3  -1   0  -9   0   0]\n[  9  -1  -9   0   0   0   1]\n[  1  -1   1   0   1  -8   0]\n[  1  -1   0  -2  -1  -1   0]\nsage: H, U = matrix_integer_dense_hnf.hnf_with_transformation(A); H\n[     1      0      0      0      0      1 191934]\n[     0      1      0      0      0      0 435767]\n[     0      0      1      0      0      1 331950]\n[     0      0      0      1      0      0 185641]\n[     0      0      0      0      1      0  38022]\n[     0      0      0      0      0      2 477471]\n[     0      0      0      0      0      0 565304]\n*)"], ["", "end"]]}