{"file_name": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms/Storjohann_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms", "problem_names": ["lemma perform_swap_add: assumes k: \"k \\<noteq> 0\" \"k < m\" and fs: \"length fs = m\"\n  shows \"LLL_swap_row p (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k) (dmu !! k !! (k - 1)) (di !! k)) k\n    = perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k) (dmu !! k !! (k - 1)) (di !! k)\"", "lemma LLL_swap_add_eq: assumes i: \"i \\<noteq> 0\" \"i < m\" and fs: \"length fs = m\" \n  shows \"LLL_swap_add p (fs,dmu,di,mods) i = (LLL_swap_row p (LLL_add_row p (fs,dmu,di,mods) i (i - 1)) i)\"", "lemma LLL_mod_inv_to_weak: \"LLL_invariant_mod fs mfs dmu p first b i \\<Longrightarrow> LLL_invariant_mod_weak fs mfs dmu p first b\"", "lemma LLL_swap_row: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod_weak fs mfs dmu p first b\"\n  and res: \"basis_reduction_mod_swap p mfs dmu k = (mfs', dmu')\" \n  and res': \"LLL_swap_row p state k = state'\" \n  and k: \"k < m\" \"k \\<noteq> 0\" \nshows \"state_impl_inv p mfs' dmu' state'\"", "lemma LLL_add_row: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod_weak fs mfs dmu p first b\" \n  and res: \"basis_reduction_mod_add_row p mfs dmu i j = (mfs', dmu')\" \n  and res': \"LLL_add_row p state i j = state'\" \n  and i: \"i < m\"\n  and j: \"j < i\"\nshows \"state_impl_inv p mfs' dmu' state'\"", "lemma LLL_max_gso_norm_di: assumes di: \"di = IArray.of_fun (d_of dmu) (Suc m)\"\n  and m: \"m \\<noteq> 0\" \nshows \"LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu\"", "lemma LLL_max_gso_quot: assumes di: \"di = IArray.of_fun (d_of dmu) (Suc m)\"\n  and prods: \"state_iso_inv di_prods di\" \nshows \"LLL_max_gso_quot di_prods = compute_max_gso_quot dmu\"", "lemma LLL_max_gso_norm: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and m: \"m \\<noteq> 0\" \nshows \"LLL_max_gso_norm first state = compute_max_gso_norm first dmu\"", "lemma mod_of_gso_norm: \"m \\<noteq> 0 \\<Longrightarrow> mod_of_gso_norm first mn =\n  compute_mod_of_max_gso_norm first mn\"", "lemma LLL_adjust_mod: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and res: \"basis_reduction_adjust_mod p first mfs dmu = (p', mfs', dmu', g_idx)\" \n  and res': \"LLL_adjust_mod p first state = (p'', state', g_idx')\" \n  and m: \"m \\<noteq> 0\" \nshows \"state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx\"", "lemma LLL_adjust_swap_add: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod_weak fs mfs dmu p first b\"\n  and res: \"basis_reduction_adjust_swap_add_step p first mfs dmu g_idx k = (p', mfs', dmu', g_idx')\" \n  and res': \"LLL_adjust_swap_add p first state g_idx k = (p'',state', G_idx')\" \n  and k: \"k < m\" and k0: \"k \\<noteq> 0\" \nshows \"state_impl_inv p' mfs' dmu' state'\" \"p'' = p'\" \"G_idx' = g_idx'\" \n  \"i \\<le> m \\<Longrightarrow> i \\<noteq> k \\<Longrightarrow> di_of state' !! i = di_of state !! i\"", "lemma LLL_step: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod_weak fs mfs dmu p first b\"\n  and res: \"basis_reduction_mod_step p first mfs dmu g_idx k j = (p', mfs', dmu', g_idx', k', j')\" \n  and res': \"LLL_step p first state g_idx k j = ((p'',state', g_idx''), k'', j'')\" \n  and k: \"k < m\" \nshows \"state_impl_inv p' mfs' dmu' state' \\<and> k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'\"", "lemma LLL_main: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod fs mfs dmu p first b i\"\n  and res: \"basis_reduction_mod_main p first mfs dmu g_idx i k = (p', mfs', dmu')\" \n  and res': \"LLL_main p first state g_idx i k = (pi', state')\" \nshows \"state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\"", "lemma LLL_iso_main_inner: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and di_prods: \"state_iso_inv di_prods (di_of state)\" \n  and Linv: \"LLL_invariant_mod_weak fs mfs dmu p first b\"\n  and res: \"basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu')\" \n  and res': \"LLL_iso_main_inner p first state di_prods g_idx k = (pi', state')\" \n  and m: \"m > 1\" \nshows \"state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\"", "lemma LLL_iso_main: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod_weak fs mfs dmu p first b\"\n  and res: \"basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu')\" \n  and res': \"LLL_iso_main p first state g_idx k = (pi', state')\" \nshows \"state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\"", "lemma LLL_initial: assumes res: \"compute_initial_state first = (p, mfs, dmu, g_idx)\" \n  and res': \"LLL_initial first = (p', state, g_idx')\" \n  and m: \"m \\<noteq> 0\" \nshows \"state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx\"", "lemma LLL_add_rows_loop: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod fs mfs dmu p b first i\"\n  and res: \"basis_reduction_mod_add_rows_loop p mfs dmu i j = (mfs', dmu')\" \n  and res': \"LLL_add_rows_loop p state i j = state'\" \n  and j: \"j \\<le> i\" \n  and i: \"i < m\" \nshows \"state_impl_inv p mfs' dmu' state'\"", "lemma LLL_add_rows_outer_loop: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod fs mfs dmu p first b m\"\n  and res: \"basis_reduction_mod_add_rows_outer_loop p mfs dmu i = (mfs', dmu')\" \n  and res': \"LLL_add_rows_outer_loop p state i = state'\" \n  and i: \"i \\<le> m - 1\" \nshows \"state_impl_inv p mfs' dmu' state'\"", "lemma LLL_reduce_basis: \"LLL_reduce_basis = reduce_basis_mod\"", "lemma LLL_reduce_basis_iso: \"LLL_reduce_basis_iso = reduce_basis_iso\"", "lemma LLL_short_vector: assumes m: \"m \\<noteq> 0\" \n  shows \"LLL_short_vector = short_vector_mod\"", "lemma LLL_short_vector_iso: assumes m: \"m \\<noteq> 0\" \n  shows \"LLL_short_vector_iso = short_vector_iso\""], "translations": [["", "lemma perform_swap_add: assumes k: \"k \\<noteq> 0\" \"k < m\" and fs: \"length fs = m\"\n  shows \"LLL_swap_row p (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k) (dmu !! k !! (k - 1)) (di !! k)) k\n    = perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k) (dmu !! k !! (k - 1)) (di !! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "from k[folded fs]"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  k < length fs", "have drop: \"drop k fs = fs ! k # drop (Suc k) fs\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k < length fs\n\ngoal (1 subgoal):\n 1. drop k fs = fs ! k # drop (Suc k) fs", "by (simp add: Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  drop k fs = fs ! k # drop (Suc k) fs\n\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "obtain v where v: \"vec n (\\<lambda>ka. (fs ! k $ ka - c * fs ! (k - 1) $ ka) symmod p) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        vec n\n         (\\<lambda>ka. (fs ! k $ ka - c * fs ! (k - 1) $ ka) symmod p) =\n        v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  vec n (\\<lambda>ka. (fs ! k $ ka - c * fs ! (k - 1) $ ka) symmod p) = v\n\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "from k[folded fs]"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  k < length fs", "have drop1: \"drop (k - 1) (take k fs @ v # drop (Suc k) fs) = fs ! (k - 1) # v # drop (Suc k) fs\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k < length fs\n\ngoal (1 subgoal):\n 1. drop (k - 1) (take k fs @ v # drop (Suc k) fs) =\n    fs ! (k - 1) # v # drop (Suc k) fs", "by (simp add: Cons_nth_drop_Suc) \n      (smt Cons_nth_drop_Suc Suc_diff_Suc Suc_less_eq Suc_pred diff_Suc_less diff_self_eq_0 drop_take less_SucI take_Suc_Cons take_eq_Nil)"], ["proof (state)\nthis:\n  drop (k - 1) (take k fs @ v # drop (Suc k) fs) =\n  fs ! (k - 1) # v # drop (Suc k) fs\n\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "from k[folded fs]"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  k < length fs", "have drop2: \"drop (k - 1) fs = fs ! (k - 1) # fs ! k # drop (Suc k) fs\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k < length fs\n\ngoal (1 subgoal):\n 1. drop (k - 1) fs = fs ! (k - 1) # fs ! k # drop (Suc k) fs", "by (metis Cons_nth_drop_Suc One_nat_def Suc_less_eq Suc_pred less_SucI neq0_conv)"], ["proof (state)\nthis:\n  drop (k - 1) fs = fs ! (k - 1) # fs ! k # drop (Suc k) fs\n\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "have take: \"take (k - 1) (take k fs @ xs) = take (k - 1) fs\" for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (k - 1) (take k fs @ xs) = take (k - 1) fs", "using k[folded fs]"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k < length fs\n\ngoal (1 subgoal):\n 1. take (k - 1) (take k fs @ xs) = take (k - 1) fs", "by auto"], ["proof (state)\nthis:\n  take (k - 1) (take k fs @ ?xs2) = take (k - 1) fs\n\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "obtain rowk where rowk: \"IArray.of_fun\n                             (\\<lambda>jj. if jj < k - 1 then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod mods !! jj\n                else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k else dmu !! k !! jj) k = rowk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rowk.\n        IArray.of_fun\n         (\\<lambda>jj.\n             if jj < k - 1\n             then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod\n                  mods !! jj\n             else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n                  else dmu !! k !! jj)\n         k =\n        rowk \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>jj.\n       if jj < k - 1\n       then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod mods !! jj\n       else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n            else dmu !! k !! jj)\n   k =\n  rowk\n\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "obtain mukk1' where mukk1': \"(di !! Suc k * di !! (k - 1) + rowk !! (k - 1) * rowk !! (k - 1)) div di !! k = mukk1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mukk1'.\n        (di !! Suc k * di !! (k - 1) +\n         rowk !! (k - 1) * rowk !! (k - 1)) div\n        di !! k =\n        mukk1' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (di !! Suc k * di !! (k - 1) + rowk !! (k - 1) * rowk !! (k - 1)) div\n  di !! k =\n  mukk1'\n\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "have kk1: \"k - 1 < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k - 1 < k", "using k"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k < m\n\ngoal (1 subgoal):\n 1. k - 1 < k", "by auto"], ["proof (state)\nthis:\n  k - 1 < k\n\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "have mukk1'': \"(di !! Suc k * di !! (k - 1) +\n             (dmu !! k !! (k - 1) - c * di !! k) * (dmu !! k !! (k - 1) - c * di !! k)) div\n            di !! k = mukk1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (di !! Suc k * di !! (k - 1) +\n     (dmu !! k !! (k - 1) - c * di !! k) *\n     (dmu !! k !! (k - 1) - c * di !! k)) div\n    di !! k =\n    mukk1'", "unfolding mukk1'[symmetric] rowk[symmetric] IArray.of_fun_nth[OF kk1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (di !! Suc k * di !! (k - 1) +\n     (dmu !! k !! (k - 1) - c * di !! k) *\n     (dmu !! k !! (k - 1) - c * di !! k)) div\n    di !! k =\n    (di !! Suc k * di !! (k - 1) +\n     (if k - 1 < k - 1\n      then (dmu !! k !! (k - 1) - c * dmu !! (k - 1) !! (k - 1)) symmod\n           mods !! (k - 1)\n      else if k - 1 = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n           else dmu !! k !! (k - 1)) *\n     (if k - 1 < k - 1\n      then (dmu !! k !! (k - 1) - c * dmu !! (k - 1) !! (k - 1)) symmod\n           mods !! (k - 1)\n      else if k - 1 = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n           else dmu !! k !! (k - 1))) div\n    di !! k", "by auto"], ["proof (state)\nthis:\n  (di !! Suc k * di !! (k - 1) +\n   (dmu !! k !! (k - 1) - c * di !! k) *\n   (dmu !! k !! (k - 1) - c * di !! k)) div\n  di !! k =\n  mukk1'\n\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "have id: \"(k = k) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k = k) = True", "by simp"], ["proof (state)\nthis:\n  (k = k) = True\n\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "have rowk1: \"dmu !! k !! (k - 1) - c * di !! k = rowk !! (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu !! k !! (k - 1) - c * di !! k = rowk !! (k - 1)", "unfolding rowk[symmetric] IArray.of_fun_nth[OF kk1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu !! k !! (k - 1) - c * di !! k =\n    (if k - 1 < k - 1\n     then (dmu !! k !! (k - 1) - c * dmu !! (k - 1) !! (k - 1)) symmod\n          mods !! (k - 1)\n     else if k - 1 = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n          else dmu !! k !! (k - 1))", "by simp"], ["proof (state)\nthis:\n  dmu !! k !! (k - 1) - c * di !! k = rowk !! (k - 1)\n\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n       (dmu !! k !! (k - 1)) (di !! k))\n     k =\n    perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k)", "unfolding perform_swap_add_def split perform_add_row_def Let_def split LLL_swap_row_def split_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case drop (k - 1)\n           (case drop k fs of\n            fsi # end \\<Rightarrow>\n              take k fs @\n              vec n\n               (\\<lambda>ka. (fsi $ ka - c * fs ! (k - 1) $ ka) symmod p) #\n              end) of\n     fsk1 # fsk # end \\<Rightarrow>\n       take (k - 1)\n        (case drop k fs of\n         fsi # end \\<Rightarrow>\n           take k fs @\n           vec n\n            (\\<lambda>ka. (fsi $ ka - c * fs ! (k - 1) $ ka) symmod p) #\n           end) @\n       fsk # fsk1 # end,\n     IArray.of_fun\n      (\\<lambda>i.\n          if i < k - 1\n          then IArray.of_fun\n                (\\<lambda>ii.\n                    if k = ii\n                    then IArray.of_fun\n                          (\\<lambda>jj.\n                              if jj < k - 1\n                              then (dmu !! k !! jj -\n                                    c * dmu !! (k - 1) !! jj) symmod\n                                   mods !! jj\n                              else if jj = k - 1\n                                   then dmu !! k !! (k - 1) - c * di !! k\n                                   else dmu !! k !! jj)\n                          k\n                    else dmu !! ii)\n                m !!\n               i\n          else if k < i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1\n                         then (IArray.of_fun\n                                (\\<lambda>ii.\n                                    if k = ii\n                                    then IArray.of_fun\n    (\\<lambda>jj.\n        if jj < k - 1\n        then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod mods !! jj\n        else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n             else dmu !! k !! jj)\n    k\n                                    else dmu !! ii)\n                                m !!\n                               k !!\n                               (k - 1) *\n                               IArray.of_fun\n                                (\\<lambda>ii.\n                                    if k = ii\n                                    then IArray.of_fun\n    (\\<lambda>jj.\n        if jj < k - 1\n        then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod mods !! jj\n        else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n             else dmu !! k !! jj)\n    k\n                                    else dmu !! ii)\n                                m !!\n                               i !!\n                               (k - 1) +\n                               IArray.of_fun\n                                (\\<lambda>ii.\n                                    if k = ii\n                                    then IArray.of_fun\n    (\\<lambda>jj.\n        if jj < k - 1\n        then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod mods !! jj\n        else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n             else dmu !! k !! jj)\n    k\n                                    else dmu !! ii)\n                                m !!\n                               i !!\n                               k *\n                               di !! (k - 1)) div\n                              di !! k symmod\n                              (p * di !! (k - 1) *\n                               ((di !! Suc k * di !! (k - 1) +\n                                 IArray.of_fun\n                                  (\\<lambda>ii.\nif k = ii\nthen IArray.of_fun\n      (\\<lambda>jj.\n          if jj < k - 1\n          then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod mods !! jj\n          else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n               else dmu !! k !! jj)\n      k\nelse dmu !! ii)\n                                  m !!\n                                 k !!\n                                 (k - 1) *\n                                 IArray.of_fun\n                                  (\\<lambda>ii.\nif k = ii\nthen IArray.of_fun\n      (\\<lambda>jj.\n          if jj < k - 1\n          then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod mods !! jj\n          else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n               else dmu !! k !! jj)\n      k\nelse dmu !! ii)\n                                  m !!\n                                 k !!\n                                 (k - 1)) div\n                                di !! k))\n                         else if j = k\n                              then (di !! Suc k *\n                                    IArray.of_fun\n                                     (\\<lambda>ii.\n   if k = ii\n   then IArray.of_fun\n         (\\<lambda>jj.\n             if jj < k - 1\n             then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod\n                  mods !! jj\n             else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n                  else dmu !! k !! jj)\n         k\n   else dmu !! ii)\n                                     m !!\n                                    i !!\n                                    (k - 1) -\n                                    IArray.of_fun\n                                     (\\<lambda>ii.\n   if k = ii\n   then IArray.of_fun\n         (\\<lambda>jj.\n             if jj < k - 1\n             then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod\n                  mods !! jj\n             else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n                  else dmu !! k !! jj)\n         k\n   else dmu !! ii)\n                                     m !!\n                                    k !!\n                                    (k - 1) *\n                                    IArray.of_fun\n                                     (\\<lambda>ii.\n   if k = ii\n   then IArray.of_fun\n         (\\<lambda>jj.\n             if jj < k - 1\n             then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod\n                  mods !! jj\n             else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n                  else dmu !! k !! jj)\n         k\n   else dmu !! ii)\n                                     m !!\n                                    i !!\n                                    k) div\n                                   di !! k symmod\n                                   (p *\n                                    ((di !! Suc k * di !! (k - 1) +\nIArray.of_fun\n (\\<lambda>ii.\n     if k = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < k - 1\n               then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod\n                    mods !! jj\n               else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n                    else dmu !! k !! jj)\n           k\n     else dmu !! ii)\n m !!\nk !!\n(k - 1) *\nIArray.of_fun\n (\\<lambda>ii.\n     if k = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < k - 1\n               then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod\n                    mods !! jj\n               else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n                    else dmu !! k !! jj)\n           k\n     else dmu !! ii)\n m !!\nk !!\n(k - 1)) div\n                                     di !! k) *\n                                    di !! Suc k)\n                              else IArray.of_fun\n                                    (\\<lambda>ii.\n  if k = ii\n  then IArray.of_fun\n        (\\<lambda>jj.\n            if jj < k - 1\n            then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod\n                 mods !! jj\n            else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n                 else dmu !! k !! jj)\n        k\n  else dmu !! ii)\n                                    m !!\n                                   i !!\n                                   j)\n                     i\n               else if i = k\n                    then IArray.of_fun\n                          (\\<lambda>j.\n                              if j = k - 1\n                              then IArray.of_fun\n                                    (\\<lambda>ii.\n  if k = ii\n  then IArray.of_fun\n        (\\<lambda>jj.\n            if jj < k - 1\n            then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod\n                 mods !! jj\n            else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n                 else dmu !! k !! jj)\n        k\n  else dmu !! ii)\n                                    m !!\n                                   k !!\n                                   (k - 1) symmod\n                                   (p * di !! (k - 1) *\n                                    ((di !! Suc k * di !! (k - 1) +\nIArray.of_fun\n (\\<lambda>ii.\n     if k = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < k - 1\n               then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod\n                    mods !! jj\n               else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n                    else dmu !! k !! jj)\n           k\n     else dmu !! ii)\n m !!\nk !!\n(k - 1) *\nIArray.of_fun\n (\\<lambda>ii.\n     if k = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < k - 1\n               then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod\n                    mods !! jj\n               else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n                    else dmu !! k !! jj)\n           k\n     else dmu !! ii)\n m !!\nk !!\n(k - 1)) div\n                                     di !! k))\n                              else IArray.of_fun\n                                    (\\<lambda>ii.\n  if k = ii\n  then IArray.of_fun\n        (\\<lambda>jj.\n            if jj < k - 1\n            then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod\n                 mods !! jj\n            else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n                 else dmu !! k !! jj)\n        k\n  else dmu !! ii)\n                                    m !!\n                                   (k - 1) !!\n                                   j)\n                          i\n                    else IArray.of_fun\n                          ((!!)\n                            (IArray.of_fun\n                              (\\<lambda>ii.\n                                  if k = ii\n                                  then IArray.of_fun\n  (\\<lambda>jj.\n      if jj < k - 1\n      then (dmu !! k !! jj - c * dmu !! (k - 1) !! jj) symmod mods !! jj\n      else if jj = k - 1 then dmu !! k !! (k - 1) - c * di !! k\n           else dmu !! k !! jj)\n  k\n                                  else dmu !! ii)\n                              m !!\n                             k))\n                          i)\n      m,\n     IArray.of_fun\n      (\\<lambda>i.\n          if i = k\n          then (di !! Suc k * di !! (k - 1) +\n                IArray.of_fun\n                 (\\<lambda>ii.\n                     if k = ii\n                     then IArray.of_fun\n                           (\\<lambda>jj.\n                               if jj < k - 1\n                               then (dmu !! k !! jj -\n                                     c * dmu !! (k - 1) !! jj) symmod\n                                    mods !! jj\n                               else if jj = k - 1\n                                    then dmu !! k !! (k - 1) - c * di !! k\n                                    else dmu !! k !! jj)\n                           k\n                     else dmu !! ii)\n                 m !!\n                k !!\n                (k - 1) *\n                IArray.of_fun\n                 (\\<lambda>ii.\n                     if k = ii\n                     then IArray.of_fun\n                           (\\<lambda>jj.\n                               if jj < k - 1\n                               then (dmu !! k !! jj -\n                                     c * dmu !! (k - 1) !! jj) symmod\n                                    mods !! jj\n                               else if jj = k - 1\n                                    then dmu !! k !! (k - 1) - c * di !! k\n                                    else dmu !! k !! jj)\n                           k\n                     else dmu !! ii)\n                 m !!\n                k !!\n                (k - 1)) div\n               di !! k\n          else di !! i)\n      (Suc m),\n     IArray.of_fun\n      (\\<lambda>j.\n          if j = k - 1\n          then p * di !! (k - 1) *\n               ((di !! Suc k * di !! (k - 1) +\n                 IArray.of_fun\n                  (\\<lambda>ii.\n                      if k = ii\n                      then IArray.of_fun\n                            (\\<lambda>jj.\n                                if jj < k - 1\n                                then (dmu !! k !! jj -\nc * dmu !! (k - 1) !! jj) symmod\n                                     mods !! jj\n                                else if jj = k - 1\n                                     then dmu !! k !! (k - 1) - c * di !! k\n                                     else dmu !! k !! jj)\n                            k\n                      else dmu !! ii)\n                  m !!\n                 k !!\n                 (k - 1) *\n                 IArray.of_fun\n                  (\\<lambda>ii.\n                      if k = ii\n                      then IArray.of_fun\n                            (\\<lambda>jj.\n                                if jj < k - 1\n                                then (dmu !! k !! jj -\nc * dmu !! (k - 1) !! jj) symmod\n                                     mods !! jj\n                                else if jj = k - 1\n                                     then dmu !! k !! (k - 1) - c * di !! k\n                                     else dmu !! k !! jj)\n                            k\n                      else dmu !! ii)\n                  m !!\n                 k !!\n                 (k - 1)) div\n                di !! k)\n          else if j = k\n               then p *\n                    ((di !! Suc k * di !! (k - 1) +\n                      IArray.of_fun\n                       (\\<lambda>ii.\n                           if k = ii\n                           then IArray.of_fun\n                                 (\\<lambda>jj.\n                                     if jj < k - 1\n                                     then (dmu !! k !! jj -\n     c * dmu !! (k - 1) !! jj) symmod\n    mods !! jj\n                                     else if jj = k - 1\n    then dmu !! k !! (k - 1) - c * di !! k else dmu !! k !! jj)\n                                 k\n                           else dmu !! ii)\n                       m !!\n                      k !!\n                      (k - 1) *\n                      IArray.of_fun\n                       (\\<lambda>ii.\n                           if k = ii\n                           then IArray.of_fun\n                                 (\\<lambda>jj.\n                                     if jj < k - 1\n                                     then (dmu !! k !! jj -\n     c * dmu !! (k - 1) !! jj) symmod\n    mods !! jj\n                                     else if jj = k - 1\n    then dmu !! k !! (k - 1) - c * di !! k else dmu !! k !! jj)\n                                 k\n                           else dmu !! ii)\n                       m !!\n                      k !!\n                      (k - 1)) div\n                     di !! k) *\n                    di !! Suc k\n               else mods !! j)\n      (m - 1)) =\n    (case drop (k - 1) fs of\n     fsk1 # fsk # end \\<Rightarrow>\n       take (k - 1) fs @\n       vec n (\\<lambda>k. (fsk $ k - c * fsk1 $ k) symmod p) # fsk1 # end,\n     IArray.of_fun\n      (\\<lambda>i.\n          if i < k - 1 then dmu !! i\n          else if k < i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1\n                         then ((dmu !! k !! (k - 1) - c * di !! k) *\n                               dmu !! i !! (k - 1) +\n                               dmu !! i !! k * di !! (k - 1)) div\n                              di !! k symmod\n                              (p * di !! (k - 1) *\n                               ((di !! Suc k * di !! (k - 1) +\n                                 (dmu !! k !! (k - 1) - c * di !! k) *\n                                 (dmu !! k !! (k - 1) - c * di !! k)) div\n                                di !! k))\n                         else if j = k\n                              then (di !! Suc k * dmu !! i !! (k - 1) -\n                                    (dmu !! k !! (k - 1) - c * di !! k) *\n                                    dmu !! i !! k) div\n                                   di !! k symmod\n                                   (p *\n                                    ((di !! Suc k * di !! (k - 1) +\n(dmu !! k !! (k - 1) - c * di !! k) *\n(dmu !! k !! (k - 1) - c * di !! k)) div\n                                     di !! k) *\n                                    di !! Suc k)\n                              else dmu !! i !! j)\n                     i\n               else if i = k\n                    then IArray.of_fun\n                          (\\<lambda>j.\n                              if j = k - 1\n                              then (dmu !! k !! (k - 1) -\n                                    c * di !! k) symmod\n                                   (p * di !! (k - 1) *\n                                    ((di !! Suc k * di !! (k - 1) +\n(dmu !! k !! (k - 1) - c * di !! k) *\n(dmu !! k !! (k - 1) - c * di !! k)) div\n                                     di !! k))\n                              else dmu !! (k - 1) !! j)\n                          k\n                    else IArray.of_fun\n                          (\\<lambda>j.\n                              (dmu !! k !! j -\n                               c * dmu !! (k - 1) !! j) symmod\n                              mods !! j)\n                          i)\n      m,\n     IArray.of_fun\n      (\\<lambda>i.\n          if i = k\n          then (di !! Suc k * di !! (k - 1) +\n                (dmu !! k !! (k - 1) - c * di !! k) *\n                (dmu !! k !! (k - 1) - c * di !! k)) div\n               di !! k\n          else di !! i)\n      (Suc m),\n     IArray.of_fun\n      (\\<lambda>j.\n          if j = k - 1\n          then p * di !! (k - 1) *\n               ((di !! Suc k * di !! (k - 1) +\n                 (dmu !! k !! (k - 1) - c * di !! k) *\n                 (dmu !! k !! (k - 1) - c * di !! k)) div\n                di !! k)\n          else if j = k\n               then p *\n                    ((di !! Suc k * di !! (k - 1) +\n                      (dmu !! k !! (k - 1) - c * di !! k) *\n                      (dmu !! k !! (k - 1) - c * di !! k)) div\n                     di !! k) *\n                    di !! Suc k\n               else mods !! j)\n      (m - 1))", "unfolding drop list.simps v drop1 take prod.inject drop2 rowk IArray.of_fun_nth[OF \\<open>k < m\\<close>] id if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (k - 1) fs @ v # fs ! (k - 1) # drop (Suc k) fs =\n    take (k - 1) fs @ v # fs ! (k - 1) # drop (Suc k) fs \\<and>\n    IArray.of_fun\n     (\\<lambda>i.\n         if i < k - 1\n         then IArray.of_fun\n               (\\<lambda>ii. if k = ii then rowk else dmu !! ii) m !!\n              i\n         else if k < i\n              then IArray.of_fun\n                    (\\<lambda>j.\n                        if j = k - 1\n                        then (rowk !! (k - 1) *\n                              IArray.of_fun\n                               (\\<lambda>ii.\n                                   if k = ii then rowk else dmu !! ii)\n                               m !!\n                              i !!\n                              (k - 1) +\n                              IArray.of_fun\n                               (\\<lambda>ii.\n                                   if k = ii then rowk else dmu !! ii)\n                               m !!\n                              i !!\n                              k *\n                              di !! (k - 1)) div\n                             di !! k symmod\n                             (p * di !! (k - 1) *\n                              ((di !! Suc k * di !! (k - 1) +\n                                rowk !! (k - 1) * rowk !! (k - 1)) div\n                               di !! k))\n                        else if j = k\n                             then (di !! Suc k *\n                                   IArray.of_fun\n                                    (\\<lambda>ii.\n  if k = ii then rowk else dmu !! ii)\n                                    m !!\n                                   i !!\n                                   (k - 1) -\n                                   rowk !! (k - 1) *\n                                   IArray.of_fun\n                                    (\\<lambda>ii.\n  if k = ii then rowk else dmu !! ii)\n                                    m !!\n                                   i !!\n                                   k) div\n                                  di !! k symmod\n                                  (p *\n                                   ((di !! Suc k * di !! (k - 1) +\n                                     rowk !! (k - 1) * rowk !! (k - 1)) div\n                                    di !! k) *\n                                   di !! Suc k)\n                             else IArray.of_fun\n                                   (\\<lambda>ii.\n if k = ii then rowk else dmu !! ii)\n                                   m !!\n                                  i !!\n                                  j)\n                    i\n              else if i = k\n                   then IArray.of_fun\n                         (\\<lambda>j.\n                             if j = k - 1\n                             then rowk !! (k - 1) symmod\n                                  (p * di !! (k - 1) *\n                                   ((di !! Suc k * di !! (k - 1) +\n                                     rowk !! (k - 1) * rowk !! (k - 1)) div\n                                    di !! k))\n                             else IArray.of_fun\n                                   (\\<lambda>ii.\n if k = ii then rowk else dmu !! ii)\n                                   m !!\n                                  (k - 1) !!\n                                  j)\n                         i\n                   else IArray.of_fun ((!!) rowk) i)\n     m =\n    IArray.of_fun\n     (\\<lambda>i.\n         if i < k - 1 then dmu !! i\n         else if k < i\n              then IArray.of_fun\n                    (\\<lambda>j.\n                        if j = k - 1\n                        then ((dmu !! k !! (k - 1) - c * di !! k) *\n                              dmu !! i !! (k - 1) +\n                              dmu !! i !! k * di !! (k - 1)) div\n                             di !! k symmod\n                             (p * di !! (k - 1) *\n                              ((di !! Suc k * di !! (k - 1) +\n                                (dmu !! k !! (k - 1) - c * di !! k) *\n                                (dmu !! k !! (k - 1) - c * di !! k)) div\n                               di !! k))\n                        else if j = k\n                             then (di !! Suc k * dmu !! i !! (k - 1) -\n                                   (dmu !! k !! (k - 1) - c * di !! k) *\n                                   dmu !! i !! k) div\n                                  di !! k symmod\n                                  (p *\n                                   ((di !! Suc k * di !! (k - 1) +\n                                     (dmu !! k !! (k - 1) - c * di !! k) *\n                                     (dmu !! k !! (k - 1) -\nc * di !! k)) div\n                                    di !! k) *\n                                   di !! Suc k)\n                             else dmu !! i !! j)\n                    i\n              else if i = k\n                   then IArray.of_fun\n                         (\\<lambda>j.\n                             if j = k - 1\n                             then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                  (p * di !! (k - 1) *\n                                   ((di !! Suc k * di !! (k - 1) +\n                                     (dmu !! k !! (k - 1) - c * di !! k) *\n                                     (dmu !! k !! (k - 1) -\nc * di !! k)) div\n                                    di !! k))\n                             else dmu !! (k - 1) !! j)\n                         k\n                   else IArray.of_fun\n                         (\\<lambda>j.\n                             (dmu !! k !! j -\n                              c * dmu !! (k - 1) !! j) symmod\n                             mods !! j)\n                         i)\n     m \\<and>\n    IArray.of_fun\n     (\\<lambda>i.\n         if i = k\n         then (di !! Suc k * di !! (k - 1) +\n               rowk !! (k - 1) * rowk !! (k - 1)) div\n              di !! k\n         else di !! i)\n     (Suc m) =\n    IArray.of_fun\n     (\\<lambda>i.\n         if i = k\n         then (di !! Suc k * di !! (k - 1) +\n               (dmu !! k !! (k - 1) - c * di !! k) *\n               (dmu !! k !! (k - 1) - c * di !! k)) div\n              di !! k\n         else di !! i)\n     (Suc m) \\<and>\n    IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then p * di !! (k - 1) *\n              ((di !! Suc k * di !! (k - 1) +\n                rowk !! (k - 1) * rowk !! (k - 1)) div\n               di !! k)\n         else if j = k\n              then p *\n                   ((di !! Suc k * di !! (k - 1) +\n                     rowk !! (k - 1) * rowk !! (k - 1)) div\n                    di !! k) *\n                   di !! Suc k\n              else mods !! j)\n     (m - 1) =\n    IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then p * di !! (k - 1) *\n              ((di !! Suc k * di !! (k - 1) +\n                (dmu !! k !! (k - 1) - c * di !! k) *\n                (dmu !! k !! (k - 1) - c * di !! k)) div\n               di !! k)\n         else if j = k\n              then p *\n                   ((di !! Suc k * di !! (k - 1) +\n                     (dmu !! k !! (k - 1) - c * di !! k) *\n                     (dmu !! k !! (k - 1) - c * di !! k)) div\n                    di !! k) *\n                   di !! Suc k\n              else mods !! j)\n     (m - 1)", "unfolding rowk1"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (k - 1) fs @ v # fs ! (k - 1) # drop (Suc k) fs =\n    take (k - 1) fs @ v # fs ! (k - 1) # drop (Suc k) fs \\<and>\n    IArray.of_fun\n     (\\<lambda>i.\n         if i < k - 1\n         then IArray.of_fun\n               (\\<lambda>ii. if k = ii then rowk else dmu !! ii) m !!\n              i\n         else if k < i\n              then IArray.of_fun\n                    (\\<lambda>j.\n                        if j = k - 1\n                        then (rowk !! (k - 1) *\n                              IArray.of_fun\n                               (\\<lambda>ii.\n                                   if k = ii then rowk else dmu !! ii)\n                               m !!\n                              i !!\n                              (k - 1) +\n                              IArray.of_fun\n                               (\\<lambda>ii.\n                                   if k = ii then rowk else dmu !! ii)\n                               m !!\n                              i !!\n                              k *\n                              di !! (k - 1)) div\n                             di !! k symmod\n                             (p * di !! (k - 1) *\n                              ((di !! Suc k * di !! (k - 1) +\n                                rowk !! (k - 1) * rowk !! (k - 1)) div\n                               di !! k))\n                        else if j = k\n                             then (di !! Suc k *\n                                   IArray.of_fun\n                                    (\\<lambda>ii.\n  if k = ii then rowk else dmu !! ii)\n                                    m !!\n                                   i !!\n                                   (k - 1) -\n                                   rowk !! (k - 1) *\n                                   IArray.of_fun\n                                    (\\<lambda>ii.\n  if k = ii then rowk else dmu !! ii)\n                                    m !!\n                                   i !!\n                                   k) div\n                                  di !! k symmod\n                                  (p *\n                                   ((di !! Suc k * di !! (k - 1) +\n                                     rowk !! (k - 1) * rowk !! (k - 1)) div\n                                    di !! k) *\n                                   di !! Suc k)\n                             else IArray.of_fun\n                                   (\\<lambda>ii.\n if k = ii then rowk else dmu !! ii)\n                                   m !!\n                                  i !!\n                                  j)\n                    i\n              else if i = k\n                   then IArray.of_fun\n                         (\\<lambda>j.\n                             if j = k - 1\n                             then rowk !! (k - 1) symmod\n                                  (p * di !! (k - 1) *\n                                   ((di !! Suc k * di !! (k - 1) +\n                                     rowk !! (k - 1) * rowk !! (k - 1)) div\n                                    di !! k))\n                             else IArray.of_fun\n                                   (\\<lambda>ii.\n if k = ii then rowk else dmu !! ii)\n                                   m !!\n                                  (k - 1) !!\n                                  j)\n                         i\n                   else IArray.of_fun ((!!) rowk) i)\n     m =\n    IArray.of_fun\n     (\\<lambda>i.\n         if i < k - 1 then dmu !! i\n         else if k < i\n              then IArray.of_fun\n                    (\\<lambda>j.\n                        if j = k - 1\n                        then (rowk !! (k - 1) * dmu !! i !! (k - 1) +\n                              dmu !! i !! k * di !! (k - 1)) div\n                             di !! k symmod\n                             (p * di !! (k - 1) *\n                              ((di !! Suc k * di !! (k - 1) +\n                                rowk !! (k - 1) * rowk !! (k - 1)) div\n                               di !! k))\n                        else if j = k\n                             then (di !! Suc k * dmu !! i !! (k - 1) -\n                                   rowk !! (k - 1) * dmu !! i !! k) div\n                                  di !! k symmod\n                                  (p *\n                                   ((di !! Suc k * di !! (k - 1) +\n                                     rowk !! (k - 1) * rowk !! (k - 1)) div\n                                    di !! k) *\n                                   di !! Suc k)\n                             else dmu !! i !! j)\n                    i\n              else if i = k\n                   then IArray.of_fun\n                         (\\<lambda>j.\n                             if j = k - 1\n                             then rowk !! (k - 1) symmod\n                                  (p * di !! (k - 1) *\n                                   ((di !! Suc k * di !! (k - 1) +\n                                     rowk !! (k - 1) * rowk !! (k - 1)) div\n                                    di !! k))\n                             else dmu !! (k - 1) !! j)\n                         k\n                   else IArray.of_fun\n                         (\\<lambda>j.\n                             (dmu !! k !! j -\n                              c * dmu !! (k - 1) !! j) symmod\n                             mods !! j)\n                         i)\n     m \\<and>\n    IArray.of_fun\n     (\\<lambda>i.\n         if i = k\n         then (di !! Suc k * di !! (k - 1) +\n               rowk !! (k - 1) * rowk !! (k - 1)) div\n              di !! k\n         else di !! i)\n     (Suc m) =\n    IArray.of_fun\n     (\\<lambda>i.\n         if i = k\n         then (di !! Suc k * di !! (k - 1) +\n               rowk !! (k - 1) * rowk !! (k - 1)) div\n              di !! k\n         else di !! i)\n     (Suc m) \\<and>\n    IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then p * di !! (k - 1) *\n              ((di !! Suc k * di !! (k - 1) +\n                rowk !! (k - 1) * rowk !! (k - 1)) div\n               di !! k)\n         else if j = k\n              then p *\n                   ((di !! Suc k * di !! (k - 1) +\n                     rowk !! (k - 1) * rowk !! (k - 1)) div\n                    di !! k) *\n                   di !! Suc k\n              else mods !! j)\n     (m - 1) =\n    IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then p * di !! (k - 1) *\n              ((di !! Suc k * di !! (k - 1) +\n                rowk !! (k - 1) * rowk !! (k - 1)) div\n               di !! k)\n         else if j = k\n              then p *\n                   ((di !! Suc k * di !! (k - 1) +\n                     rowk !! (k - 1) * rowk !! (k - 1)) div\n                    di !! k) *\n                   di !! Suc k\n              else mods !! j)\n     (m - 1)", "proof (intro conjI refl iarray_cong, unfold rowk1[symmetric], goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       (if i < k - 1\n        then IArray.of_fun (\\<lambda>ii. if k = ii then rowk else dmu !! ii)\n              m !!\n             i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then ((dmu !! k !! (k - 1) - c * di !! k) *\n                             IArray.of_fun\n                              (\\<lambda>ii.\n                                  if k = ii then rowk else dmu !! ii)\n                              m !!\n                             i !!\n                             (k - 1) +\n                             IArray.of_fun\n                              (\\<lambda>ii.\n                                  if k = ii then rowk else dmu !! ii)\n                              m !!\n                             i !!\n                             k *\n                             di !! (k - 1)) div\n                            di !! k symmod\n                            (p * di !! (k - 1) *\n                             ((di !! Suc k * di !! (k - 1) +\n                               (dmu !! k !! (k - 1) - c * di !! k) *\n                               (dmu !! k !! (k - 1) - c * di !! k)) div\n                              di !! k))\n                       else if j = k\n                            then (di !! Suc k *\n                                  IArray.of_fun\n                                   (\\<lambda>ii.\n if k = ii then rowk else dmu !! ii)\n                                   m !!\n                                  i !!\n                                  (k - 1) -\n                                  (dmu !! k !! (k - 1) - c * di !! k) *\n                                  IArray.of_fun\n                                   (\\<lambda>ii.\n if k = ii then rowk else dmu !! ii)\n                                   m !!\n                                  i !!\n                                  k) div\n                                 di !! k symmod\n                                 (p *\n                                  ((di !! Suc k * di !! (k - 1) +\n                                    (dmu !! k !! (k - 1) - c * di !! k) *\n                                    (dmu !! k !! (k - 1) - c * di !! k)) div\n                                   di !! k) *\n                                  di !! Suc k)\n                            else IArray.of_fun\n                                  (\\<lambda>ii.\nif k = ii then rowk else dmu !! ii)\n                                  m !!\n                                 i !!\n                                 j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1\n                            then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                 (p * di !! (k - 1) *\n                                  ((di !! Suc k * di !! (k - 1) +\n                                    (dmu !! k !! (k - 1) - c * di !! k) *\n                                    (dmu !! k !! (k - 1) - c * di !! k)) div\n                                   di !! k))\n                            else IArray.of_fun\n                                  (\\<lambda>ii.\nif k = ii then rowk else dmu !! ii)\n                                  m !!\n                                 (k - 1) !!\n                                 j)\n                        i\n                  else IArray.of_fun ((!!) rowk) i) =\n       (if i < k - 1 then dmu !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then ((dmu !! k !! (k - 1) - c * di !! k) *\n                             dmu !! i !! (k - 1) +\n                             dmu !! i !! k * di !! (k - 1)) div\n                            di !! k symmod\n                            (p * di !! (k - 1) *\n                             ((di !! Suc k * di !! (k - 1) +\n                               (dmu !! k !! (k - 1) - c * di !! k) *\n                               (dmu !! k !! (k - 1) - c * di !! k)) div\n                              di !! k))\n                       else if j = k\n                            then (di !! Suc k * dmu !! i !! (k - 1) -\n                                  (dmu !! k !! (k - 1) - c * di !! k) *\n                                  dmu !! i !! k) div\n                                 di !! k symmod\n                                 (p *\n                                  ((di !! Suc k * di !! (k - 1) +\n                                    (dmu !! k !! (k - 1) - c * di !! k) *\n                                    (dmu !! k !! (k - 1) - c * di !! k)) div\n                                   di !! k) *\n                                  di !! Suc k)\n                            else dmu !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1\n                            then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                 (p * di !! (k - 1) *\n                                  ((di !! Suc k * di !! (k - 1) +\n                                    (dmu !! k !! (k - 1) - c * di !! k) *\n                                    (dmu !! k !! (k - 1) - c * di !! k)) div\n                                   di !! k))\n                            else dmu !! (k - 1) !! j)\n                        k\n                  else IArray.of_fun\n                        (\\<lambda>j.\n                            (dmu !! k !! j - c * dmu !! (k - 1) !! j) symmod\n                            mods !! j)\n                        i)", "case i: (1 i)"], ["proof (state)\nthis:\n  i < m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       (if i < k - 1\n        then IArray.of_fun (\\<lambda>ii. if k = ii then rowk else dmu !! ii)\n              m !!\n             i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then ((dmu !! k !! (k - 1) - c * di !! k) *\n                             IArray.of_fun\n                              (\\<lambda>ii.\n                                  if k = ii then rowk else dmu !! ii)\n                              m !!\n                             i !!\n                             (k - 1) +\n                             IArray.of_fun\n                              (\\<lambda>ii.\n                                  if k = ii then rowk else dmu !! ii)\n                              m !!\n                             i !!\n                             k *\n                             di !! (k - 1)) div\n                            di !! k symmod\n                            (p * di !! (k - 1) *\n                             ((di !! Suc k * di !! (k - 1) +\n                               (dmu !! k !! (k - 1) - c * di !! k) *\n                               (dmu !! k !! (k - 1) - c * di !! k)) div\n                              di !! k))\n                       else if j = k\n                            then (di !! Suc k *\n                                  IArray.of_fun\n                                   (\\<lambda>ii.\n if k = ii then rowk else dmu !! ii)\n                                   m !!\n                                  i !!\n                                  (k - 1) -\n                                  (dmu !! k !! (k - 1) - c * di !! k) *\n                                  IArray.of_fun\n                                   (\\<lambda>ii.\n if k = ii then rowk else dmu !! ii)\n                                   m !!\n                                  i !!\n                                  k) div\n                                 di !! k symmod\n                                 (p *\n                                  ((di !! Suc k * di !! (k - 1) +\n                                    (dmu !! k !! (k - 1) - c * di !! k) *\n                                    (dmu !! k !! (k - 1) - c * di !! k)) div\n                                   di !! k) *\n                                  di !! Suc k)\n                            else IArray.of_fun\n                                  (\\<lambda>ii.\nif k = ii then rowk else dmu !! ii)\n                                  m !!\n                                 i !!\n                                 j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1\n                            then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                 (p * di !! (k - 1) *\n                                  ((di !! Suc k * di !! (k - 1) +\n                                    (dmu !! k !! (k - 1) - c * di !! k) *\n                                    (dmu !! k !! (k - 1) - c * di !! k)) div\n                                   di !! k))\n                            else IArray.of_fun\n                                  (\\<lambda>ii.\nif k = ii then rowk else dmu !! ii)\n                                  m !!\n                                 (k - 1) !!\n                                 j)\n                        i\n                  else IArray.of_fun ((!!) rowk) i) =\n       (if i < k - 1 then dmu !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then ((dmu !! k !! (k - 1) - c * di !! k) *\n                             dmu !! i !! (k - 1) +\n                             dmu !! i !! k * di !! (k - 1)) div\n                            di !! k symmod\n                            (p * di !! (k - 1) *\n                             ((di !! Suc k * di !! (k - 1) +\n                               (dmu !! k !! (k - 1) - c * di !! k) *\n                               (dmu !! k !! (k - 1) - c * di !! k)) div\n                              di !! k))\n                       else if j = k\n                            then (di !! Suc k * dmu !! i !! (k - 1) -\n                                  (dmu !! k !! (k - 1) - c * di !! k) *\n                                  dmu !! i !! k) div\n                                 di !! k symmod\n                                 (p *\n                                  ((di !! Suc k * di !! (k - 1) +\n                                    (dmu !! k !! (k - 1) - c * di !! k) *\n                                    (dmu !! k !! (k - 1) - c * di !! k)) div\n                                   di !! k) *\n                                  di !! Suc k)\n                            else dmu !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1\n                            then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                 (p * di !! (k - 1) *\n                                  ((di !! Suc k * di !! (k - 1) +\n                                    (dmu !! k !! (k - 1) - c * di !! k) *\n                                    (dmu !! k !! (k - 1) - c * di !! k)) div\n                                   di !! k))\n                            else dmu !! (k - 1) !! j)\n                        k\n                  else IArray.of_fun\n                        (\\<lambda>j.\n                            (dmu !! k !! j - c * dmu !! (k - 1) !! j) symmod\n                            mods !! j)\n                        i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < k - 1\n     then IArray.of_fun (\\<lambda>ii. if k = ii then rowk else dmu !! ii)\n           m !!\n          i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then ((dmu !! k !! (k - 1) - c * di !! k) *\n                          IArray.of_fun\n                           (\\<lambda>ii. if k = ii then rowk else dmu !! ii)\n                           m !!\n                          i !!\n                          (k - 1) +\n                          IArray.of_fun\n                           (\\<lambda>ii. if k = ii then rowk else dmu !! ii)\n                           m !!\n                          i !!\n                          k *\n                          di !! (k - 1)) div\n                         di !! k symmod\n                         (p * di !! (k - 1) *\n                          ((di !! Suc k * di !! (k - 1) +\n                            (dmu !! k !! (k - 1) - c * di !! k) *\n                            (dmu !! k !! (k - 1) - c * di !! k)) div\n                           di !! k))\n                    else if j = k\n                         then (di !! Suc k *\n                               IArray.of_fun\n                                (\\<lambda>ii.\n                                    if k = ii then rowk else dmu !! ii)\n                                m !!\n                               i !!\n                               (k - 1) -\n                               (dmu !! k !! (k - 1) - c * di !! k) *\n                               IArray.of_fun\n                                (\\<lambda>ii.\n                                    if k = ii then rowk else dmu !! ii)\n                                m !!\n                               i !!\n                               k) div\n                              di !! k symmod\n                              (p *\n                               ((di !! Suc k * di !! (k - 1) +\n                                 (dmu !! k !! (k - 1) - c * di !! k) *\n                                 (dmu !! k !! (k - 1) - c * di !! k)) div\n                                di !! k) *\n                               di !! Suc k)\n                         else IArray.of_fun\n                               (\\<lambda>ii.\n                                   if k = ii then rowk else dmu !! ii)\n                               m !!\n                              i !!\n                              j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1\n                         then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                              (p * di !! (k - 1) *\n                               ((di !! Suc k * di !! (k - 1) +\n                                 (dmu !! k !! (k - 1) - c * di !! k) *\n                                 (dmu !! k !! (k - 1) - c * di !! k)) div\n                                di !! k))\n                         else IArray.of_fun\n                               (\\<lambda>ii.\n                                   if k = ii then rowk else dmu !! ii)\n                               m !!\n                              (k - 1) !!\n                              j)\n                     i\n               else IArray.of_fun ((!!) rowk) i) =\n    (if i < k - 1 then dmu !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then ((dmu !! k !! (k - 1) - c * di !! k) *\n                          dmu !! i !! (k - 1) +\n                          dmu !! i !! k * di !! (k - 1)) div\n                         di !! k symmod\n                         (p * di !! (k - 1) *\n                          ((di !! Suc k * di !! (k - 1) +\n                            (dmu !! k !! (k - 1) - c * di !! k) *\n                            (dmu !! k !! (k - 1) - c * di !! k)) div\n                           di !! k))\n                    else if j = k\n                         then (di !! Suc k * dmu !! i !! (k - 1) -\n                               (dmu !! k !! (k - 1) - c * di !! k) *\n                               dmu !! i !! k) div\n                              di !! k symmod\n                              (p *\n                               ((di !! Suc k * di !! (k - 1) +\n                                 (dmu !! k !! (k - 1) - c * di !! k) *\n                                 (dmu !! k !! (k - 1) - c * di !! k)) div\n                                di !! k) *\n                               di !! Suc k)\n                         else dmu !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1\n                         then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                              (p * di !! (k - 1) *\n                               ((di !! Suc k * di !! (k - 1) +\n                                 (dmu !! k !! (k - 1) - c * di !! k) *\n                                 (dmu !! k !! (k - 1) - c * di !! k)) div\n                                di !! k))\n                         else dmu !! (k - 1) !! j)\n                     k\n               else IArray.of_fun\n                     (\\<lambda>j.\n                         (dmu !! k !! j - c * dmu !! (k - 1) !! j) symmod\n                         mods !! j)\n                     i)", "unfolding IArray.of_fun_nth[OF i] IArray.of_fun_nth[OF \\<open>k < m\\<close>] id if_True mukk1' mukk1''\n      rowk1[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < k - 1 then if k = i then rowk else dmu !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then ((dmu !! k !! (k - 1) - c * di !! k) *\n                          (if k = i then rowk else dmu !! i) !! (k - 1) +\n                          (if k = i then rowk else dmu !! i) !! k *\n                          di !! (k - 1)) div\n                         di !! k symmod\n                         (p * di !! (k - 1) * mukk1')\n                    else if j = k\n                         then (di !! Suc k *\n                               (if k = i then rowk else dmu !! i) !!\n                               (k - 1) -\n                               (dmu !! k !! (k - 1) - c * di !! k) *\n                               (if k = i then rowk else dmu !! i) !! k) div\n                              di !! k symmod\n                              (p * mukk1' * di !! Suc k)\n                         else (if k = i then rowk else dmu !! i) !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1\n                         then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                              (p * di !! (k - 1) * mukk1')\n                         else IArray.of_fun\n                               (\\<lambda>ii.\n                                   if k = ii then rowk else dmu !! ii)\n                               m !!\n                              (k - 1) !!\n                              j)\n                     i\n               else IArray.of_fun ((!!) rowk) i) =\n    (if i < k - 1 then dmu !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then ((dmu !! k !! (k - 1) - c * di !! k) *\n                          dmu !! i !! (k - 1) +\n                          dmu !! i !! k * di !! (k - 1)) div\n                         di !! k symmod\n                         (p * di !! (k - 1) * mukk1')\n                    else if j = k\n                         then (di !! Suc k * dmu !! i !! (k - 1) -\n                               (dmu !! k !! (k - 1) - c * di !! k) *\n                               dmu !! i !! k) div\n                              di !! k symmod\n                              (p * mukk1' * di !! Suc k)\n                         else dmu !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1\n                         then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                              (p * di !! (k - 1) * mukk1')\n                         else dmu !! (k - 1) !! j)\n                     k\n               else IArray.of_fun\n                     (\\<lambda>j.\n                         (dmu !! k !! j - c * dmu !! (k - 1) !! j) symmod\n                         mods !! j)\n                     i)", "proof (intro if_cong[OF refl], force, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> i < k - 1; k < i\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 (if k = i then rowk else dmu !! i) !!\n                                 (k - 1) +\n                                 (if k = i then rowk else dmu !! i) !! k *\n                                 di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k *\n(if k = i then rowk else dmu !! i) !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) *\n(if k = i then rowk else dmu !! i) !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else (if k = i then rowk else dmu !! i) !!\n                                     j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 dmu !! i !! (k - 1) +\n                                 dmu !! i !! k * di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k * dmu !! i !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else dmu !! i !! j)\n                       i\n 2. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i = k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else IArray.of_fun\n                                 (\\<lambda>ii.\n                                     if k = ii then rowk else dmu !! ii)\n                                 m !!\n                                (k - 1) !!\n                                j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else dmu !! (k - 1) !! j)\n                       k\n 3. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun ((!!) rowk) i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           (dmu !! k !! j - c * dmu !! (k - 1) !! j) symmod\n                           mods !! j)\n                       i", "case 3"], ["proof (state)\nthis:\n  \\<not> i < k - 1\n  \\<not> k < i\n  i \\<noteq> k\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> i < k - 1; k < i\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 (if k = i then rowk else dmu !! i) !!\n                                 (k - 1) +\n                                 (if k = i then rowk else dmu !! i) !! k *\n                                 di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k *\n(if k = i then rowk else dmu !! i) !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) *\n(if k = i then rowk else dmu !! i) !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else (if k = i then rowk else dmu !! i) !!\n                                     j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 dmu !! i !! (k - 1) +\n                                 dmu !! i !! k * di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k * dmu !! i !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else dmu !! i !! j)\n                       i\n 2. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i = k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else IArray.of_fun\n                                 (\\<lambda>ii.\n                                     if k = ii then rowk else dmu !! ii)\n                                 m !!\n                                (k - 1) !!\n                                j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else dmu !! (k - 1) !! j)\n                       k\n 3. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun ((!!) rowk) i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           (dmu !! k !! j - c * dmu !! (k - 1) !! j) symmod\n                           mods !! j)\n                       i", "hence i: \"i = k - 1\""], ["proof (prove)\nusing this:\n  \\<not> i < k - 1\n  \\<not> k < i\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. i = k - 1", "by auto"], ["proof (state)\nthis:\n  i = k - 1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> i < k - 1; k < i\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 (if k = i then rowk else dmu !! i) !!\n                                 (k - 1) +\n                                 (if k = i then rowk else dmu !! i) !! k *\n                                 di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k *\n(if k = i then rowk else dmu !! i) !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) *\n(if k = i then rowk else dmu !! i) !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else (if k = i then rowk else dmu !! i) !!\n                                     j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 dmu !! i !! (k - 1) +\n                                 dmu !! i !! k * di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k * dmu !! i !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else dmu !! i !! j)\n                       i\n 2. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i = k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else IArray.of_fun\n                                 (\\<lambda>ii.\n                                     if k = ii then rowk else dmu !! ii)\n                                 m !!\n                                (k - 1) !!\n                                j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else dmu !! (k - 1) !! j)\n                       k\n 3. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun ((!!) rowk) i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           (dmu !! k !! j - c * dmu !! (k - 1) !! j) symmod\n                           mods !! j)\n                       i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun ((!!) rowk) i =\n    IArray.of_fun\n     (\\<lambda>j.\n         (dmu !! k !! j - c * dmu !! (k - 1) !! j) symmod mods !! j)\n     i", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun ((!!) rowk) (k - 1) =\n    IArray.of_fun\n     (\\<lambda>j.\n         (dmu !! k !! j - c * dmu !! (k - 1) !! j) symmod mods !! j)\n     (k - 1)", "by (intro iarray_cong[OF refl], unfold rowk[symmetric],\n          subst IArray.of_fun_nth, insert k, auto)"], ["proof (state)\nthis:\n  IArray.of_fun ((!!) rowk) i =\n  IArray.of_fun\n   (\\<lambda>j. (dmu !! k !! j - c * dmu !! (k - 1) !! j) symmod mods !! j)\n   i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> i < k - 1; k < i\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 (if k = i then rowk else dmu !! i) !!\n                                 (k - 1) +\n                                 (if k = i then rowk else dmu !! i) !! k *\n                                 di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k *\n(if k = i then rowk else dmu !! i) !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) *\n(if k = i then rowk else dmu !! i) !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else (if k = i then rowk else dmu !! i) !!\n                                     j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 dmu !! i !! (k - 1) +\n                                 dmu !! i !! k * di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k * dmu !! i !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else dmu !! i !! j)\n                       i\n 2. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i = k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else IArray.of_fun\n                                 (\\<lambda>ii.\n                                     if k = ii then rowk else dmu !! ii)\n                                 m !!\n                                (k - 1) !!\n                                j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else dmu !! (k - 1) !! j)\n                       k", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> i < k - 1; k < i\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 (if k = i then rowk else dmu !! i) !!\n                                 (k - 1) +\n                                 (if k = i then rowk else dmu !! i) !! k *\n                                 di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k *\n(if k = i then rowk else dmu !! i) !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) *\n(if k = i then rowk else dmu !! i) !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else (if k = i then rowk else dmu !! i) !!\n                                     j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 dmu !! i !! (k - 1) +\n                                 dmu !! i !! k * di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k * dmu !! i !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else dmu !! i !! j)\n                       i\n 2. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i = k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else IArray.of_fun\n                                 (\\<lambda>ii.\n                                     if k = ii then rowk else dmu !! ii)\n                                 m !!\n                                (k - 1) !!\n                                j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else dmu !! (k - 1) !! j)\n                       k", "case ki: 1"], ["proof (state)\nthis:\n  \\<not> i < k - 1\n  k < i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> i < k - 1; k < i\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 (if k = i then rowk else dmu !! i) !!\n                                 (k - 1) +\n                                 (if k = i then rowk else dmu !! i) !! k *\n                                 di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k *\n(if k = i then rowk else dmu !! i) !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) *\n(if k = i then rowk else dmu !! i) !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else (if k = i then rowk else dmu !! i) !!\n                                     j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 dmu !! i !! (k - 1) +\n                                 dmu !! i !! k * di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k * dmu !! i !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else dmu !! i !! j)\n                       i\n 2. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i = k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else IArray.of_fun\n                                 (\\<lambda>ii.\n                                     if k = ii then rowk else dmu !! ii)\n                                 m !!\n                                (k - 1) !!\n                                j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else dmu !! (k - 1) !! j)\n                       k", "(* k < i *)"], ["proof (state)\nthis:\n  \\<not> i < k - 1\n  k < i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> i < k - 1; k < i\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 (if k = i then rowk else dmu !! i) !!\n                                 (k - 1) +\n                                 (if k = i then rowk else dmu !! i) !! k *\n                                 di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k *\n(if k = i then rowk else dmu !! i) !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) *\n(if k = i then rowk else dmu !! i) !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else (if k = i then rowk else dmu !! i) !!\n                                     j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 dmu !! i !! (k - 1) +\n                                 dmu !! i !! k * di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k * dmu !! i !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else dmu !! i !! j)\n                       i\n 2. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i = k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else IArray.of_fun\n                                 (\\<lambda>ii.\n                                     if k = ii then rowk else dmu !! ii)\n                                 m !!\n                                (k - 1) !!\n                                j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else dmu !! (k - 1) !! j)\n                       k", "hence id: \"(k = i) = False\""], ["proof (prove)\nusing this:\n  \\<not> i < k - 1\n  k < i\n\ngoal (1 subgoal):\n 1. (k = i) = False", "by auto"], ["proof (state)\nthis:\n  (k = i) = False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> i < k - 1; k < i\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 (if k = i then rowk else dmu !! i) !!\n                                 (k - 1) +\n                                 (if k = i then rowk else dmu !! i) !! k *\n                                 di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k *\n(if k = i then rowk else dmu !! i) !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) *\n(if k = i then rowk else dmu !! i) !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else (if k = i then rowk else dmu !! i) !!\n                                     j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then ((dmu !! k !! (k - 1) - c * di !! k) *\n                                 dmu !! i !! (k - 1) +\n                                 dmu !! i !! k * di !! (k - 1)) div\n                                di !! k symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else if j = k\n                                then (di !! Suc k * dmu !! i !! (k - 1) -\n(dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! k) div\n                                     di !! k symmod\n                                     (p * mukk1' * di !! Suc k)\n                                else dmu !! i !! j)\n                       i\n 2. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i = k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else IArray.of_fun\n                                 (\\<lambda>ii.\n                                     if k = ii then rowk else dmu !! ii)\n                                 m !!\n                                (k - 1) !!\n                                j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else dmu !! (k - 1) !! j)\n                       k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then ((dmu !! k !! (k - 1) - c * di !! k) *\n               (if k = i then rowk else dmu !! i) !! (k - 1) +\n               (if k = i then rowk else dmu !! i) !! k * di !! (k - 1)) div\n              di !! k symmod\n              (p * di !! (k - 1) * mukk1')\n         else if j = k\n              then (di !! Suc k *\n                    (if k = i then rowk else dmu !! i) !! (k - 1) -\n                    (dmu !! k !! (k - 1) - c * di !! k) *\n                    (if k = i then rowk else dmu !! i) !! k) div\n                   di !! k symmod\n                   (p * mukk1' * di !! Suc k)\n              else (if k = i then rowk else dmu !! i) !! j)\n     i =\n    IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then ((dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! (k - 1) +\n               dmu !! i !! k * di !! (k - 1)) div\n              di !! k symmod\n              (p * di !! (k - 1) * mukk1')\n         else if j = k\n              then (di !! Suc k * dmu !! i !! (k - 1) -\n                    (dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! k) div\n                   di !! k symmod\n                   (p * mukk1' * di !! Suc k)\n              else dmu !! i !! j)\n     i", "unfolding id if_False rowk"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then ((dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! (k - 1) +\n               dmu !! i !! k * di !! (k - 1)) div\n              di !! k symmod\n              (p * di !! (k - 1) * mukk1')\n         else if j = k\n              then (di !! Suc k * dmu !! i !! (k - 1) -\n                    (dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! k) div\n                   di !! k symmod\n                   (p * mukk1' * di !! Suc k)\n              else dmu !! i !! j)\n     i =\n    IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then ((dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! (k - 1) +\n               dmu !! i !! k * di !! (k - 1)) div\n              di !! k symmod\n              (p * di !! (k - 1) * mukk1')\n         else if j = k\n              then (di !! Suc k * dmu !! i !! (k - 1) -\n                    (dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! k) div\n                   di !! k symmod\n                   (p * mukk1' * di !! Suc k)\n              else dmu !! i !! j)\n     i", "by (intro iarray_cong if_cong refl)"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>j.\n       if j = k - 1\n       then ((dmu !! k !! (k - 1) - c * di !! k) *\n             (if k = i then rowk else dmu !! i) !! (k - 1) +\n             (if k = i then rowk else dmu !! i) !! k * di !! (k - 1)) div\n            di !! k symmod\n            (p * di !! (k - 1) * mukk1')\n       else if j = k\n            then (di !! Suc k *\n                  (if k = i then rowk else dmu !! i) !! (k - 1) -\n                  (dmu !! k !! (k - 1) - c * di !! k) *\n                  (if k = i then rowk else dmu !! i) !! k) div\n                 di !! k symmod\n                 (p * mukk1' * di !! Suc k)\n            else (if k = i then rowk else dmu !! i) !! j)\n   i =\n  IArray.of_fun\n   (\\<lambda>j.\n       if j = k - 1\n       then ((dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! (k - 1) +\n             dmu !! i !! k * di !! (k - 1)) div\n            di !! k symmod\n            (p * di !! (k - 1) * mukk1')\n       else if j = k\n            then (di !! Suc k * dmu !! i !! (k - 1) -\n                  (dmu !! k !! (k - 1) - c * di !! k) * dmu !! i !! k) div\n                 di !! k symmod\n                 (p * mukk1' * di !! Suc k)\n            else dmu !! i !! j)\n   i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i = k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else IArray.of_fun\n                                 (\\<lambda>ii.\n                                     if k = ii then rowk else dmu !! ii)\n                                 m !!\n                                (k - 1) !!\n                                j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else dmu !! (k - 1) !! j)\n                       k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i = k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else IArray.of_fun\n                                 (\\<lambda>ii.\n                                     if k = ii then rowk else dmu !! ii)\n                                 m !!\n                                (k - 1) !!\n                                j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else dmu !! (k - 1) !! j)\n                       k", "case 2"], ["proof (state)\nthis:\n  \\<not> i < k - 1\n  \\<not> k < i\n  i = k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i = k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else IArray.of_fun\n                                 (\\<lambda>ii.\n                                     if k = ii then rowk else dmu !! ii)\n                                 m !!\n                                (k - 1) !!\n                                j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else dmu !! (k - 1) !! j)\n                       k", "(* k = i *)"], ["proof (state)\nthis:\n  \\<not> i < k - 1\n  \\<not> k < i\n  i = k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> i < k - 1; \\<not> k < i; i = k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else IArray.of_fun\n                                 (\\<lambda>ii.\n                                     if k = ii then rowk else dmu !! ii)\n                                 m !!\n                                (k - 1) !!\n                                j)\n                       i =\n                      IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1\n                           then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                                (p * di !! (k - 1) * mukk1')\n                           else dmu !! (k - 1) !! j)\n                       k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then (dmu !! k !! (k - 1) - c * di !! k) symmod\n              (p * di !! (k - 1) * mukk1')\n         else IArray.of_fun\n               (\\<lambda>ii. if k = ii then rowk else dmu !! ii) m !!\n              (k - 1) !!\n              j)\n     i =\n    IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then (dmu !! k !! (k - 1) - c * di !! k) symmod\n              (p * di !! (k - 1) * mukk1')\n         else dmu !! (k - 1) !! j)\n     k", "unfolding 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then (dmu !! k !! (k - 1) - c * di !! k) symmod\n              (p * di !! (k - 1) * mukk1')\n         else IArray.of_fun\n               (\\<lambda>ii. if k = ii then rowk else dmu !! ii) m !!\n              (k - 1) !!\n              j)\n     k =\n    IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then (dmu !! k !! (k - 1) - c * di !! k) symmod\n              (p * di !! (k - 1) * mukk1')\n         else dmu !! (k - 1) !! j)\n     k", "by (intro iarray_cong if_cong refl, subst IArray.of_fun_nth, insert k, auto)"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>j.\n       if j = k - 1\n       then (dmu !! k !! (k - 1) - c * di !! k) symmod\n            (p * di !! (k - 1) * mukk1')\n       else IArray.of_fun (\\<lambda>ii. if k = ii then rowk else dmu !! ii)\n             m !!\n            (k - 1) !!\n            j)\n   i =\n  IArray.of_fun\n   (\\<lambda>j.\n       if j = k - 1\n       then (dmu !! k !! (k - 1) - c * di !! k) symmod\n            (p * di !! (k - 1) * mukk1')\n       else dmu !! (k - 1) !! j)\n   k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if i < k - 1\n   then IArray.of_fun (\\<lambda>ii. if k = ii then rowk else dmu !! ii) m !!\n        i\n   else if k < i\n        then IArray.of_fun\n              (\\<lambda>j.\n                  if j = k - 1\n                  then ((dmu !! k !! (k - 1) - c * di !! k) *\n                        IArray.of_fun\n                         (\\<lambda>ii. if k = ii then rowk else dmu !! ii)\n                         m !!\n                        i !!\n                        (k - 1) +\n                        IArray.of_fun\n                         (\\<lambda>ii. if k = ii then rowk else dmu !! ii)\n                         m !!\n                        i !!\n                        k *\n                        di !! (k - 1)) div\n                       di !! k symmod\n                       (p * di !! (k - 1) *\n                        ((di !! Suc k * di !! (k - 1) +\n                          (dmu !! k !! (k - 1) - c * di !! k) *\n                          (dmu !! k !! (k - 1) - c * di !! k)) div\n                         di !! k))\n                  else if j = k\n                       then (di !! Suc k *\n                             IArray.of_fun\n                              (\\<lambda>ii.\n                                  if k = ii then rowk else dmu !! ii)\n                              m !!\n                             i !!\n                             (k - 1) -\n                             (dmu !! k !! (k - 1) - c * di !! k) *\n                             IArray.of_fun\n                              (\\<lambda>ii.\n                                  if k = ii then rowk else dmu !! ii)\n                              m !!\n                             i !!\n                             k) div\n                            di !! k symmod\n                            (p *\n                             ((di !! Suc k * di !! (k - 1) +\n                               (dmu !! k !! (k - 1) - c * di !! k) *\n                               (dmu !! k !! (k - 1) - c * di !! k)) div\n                              di !! k) *\n                             di !! Suc k)\n                       else IArray.of_fun\n                             (\\<lambda>ii.\n                                 if k = ii then rowk else dmu !! ii)\n                             m !!\n                            i !!\n                            j)\n              i\n        else if i = k\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                            (p * di !! (k - 1) *\n                             ((di !! Suc k * di !! (k - 1) +\n                               (dmu !! k !! (k - 1) - c * di !! k) *\n                               (dmu !! k !! (k - 1) - c * di !! k)) div\n                              di !! k))\n                       else IArray.of_fun\n                             (\\<lambda>ii.\n                                 if k = ii then rowk else dmu !! ii)\n                             m !!\n                            (k - 1) !!\n                            j)\n                   i\n             else IArray.of_fun ((!!) rowk) i) =\n  (if i < k - 1 then dmu !! i\n   else if k < i\n        then IArray.of_fun\n              (\\<lambda>j.\n                  if j = k - 1\n                  then ((dmu !! k !! (k - 1) - c * di !! k) *\n                        dmu !! i !! (k - 1) +\n                        dmu !! i !! k * di !! (k - 1)) div\n                       di !! k symmod\n                       (p * di !! (k - 1) *\n                        ((di !! Suc k * di !! (k - 1) +\n                          (dmu !! k !! (k - 1) - c * di !! k) *\n                          (dmu !! k !! (k - 1) - c * di !! k)) div\n                         di !! k))\n                  else if j = k\n                       then (di !! Suc k * dmu !! i !! (k - 1) -\n                             (dmu !! k !! (k - 1) - c * di !! k) *\n                             dmu !! i !! k) div\n                            di !! k symmod\n                            (p *\n                             ((di !! Suc k * di !! (k - 1) +\n                               (dmu !! k !! (k - 1) - c * di !! k) *\n                               (dmu !! k !! (k - 1) - c * di !! k)) div\n                              di !! k) *\n                             di !! Suc k)\n                       else dmu !! i !! j)\n              i\n        else if i = k\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu !! k !! (k - 1) - c * di !! k) symmod\n                            (p * di !! (k - 1) *\n                             ((di !! Suc k * di !! (k - 1) +\n                               (dmu !! k !! (k - 1) - c * di !! k) *\n                               (dmu !! k !! (k - 1) - c * di !! k)) div\n                              di !! k))\n                       else dmu !! (k - 1) !! j)\n                   k\n             else IArray.of_fun\n                   (\\<lambda>j.\n                       (dmu !! k !! j - c * dmu !! (k - 1) !! j) symmod\n                       mods !! j)\n                   i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_swap_row p\n   (perform_add_row p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n     (dmu !! k !! (k - 1)) (di !! k))\n   k =\n  perform_swap_add p (fs, dmu, di, mods) k (k - 1) c (dmu !! k)\n   (dmu !! k !! (k - 1)) (di !! k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_swap_add_eq: assumes i: \"i \\<noteq> 0\" \"i < m\" and fs: \"length fs = m\" \n  shows \"LLL_swap_add p (fs,dmu,di,mods) i = (LLL_swap_row p (LLL_add_row p (fs,dmu,di,mods) i (i - 1)) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "define c where \"c = round_num_denom (dmu !! i !! (i - 1)) (di !! i)\""], ["proof (state)\nthis:\n  c = round_num_denom (dmu !! i !! (i - 1)) (di !! i)\n\ngoal (1 subgoal):\n 1. LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "from i"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  i < m", "have si1: \"Suc (i - 1) = i\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  i < m\n\ngoal (1 subgoal):\n 1. Suc (i - 1) = i", "by auto"], ["proof (state)\nthis:\n  Suc (i - 1) = i\n\ngoal (1 subgoal):\n 1. LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "note res1 = LLL_swap_add_def[of p \"(fs,dmu,di,mods)\" i, unfolded split Let_def c_def[symmetric]]"], ["proof (state)\nthis:\n  LLL_swap_add p (fs, dmu, di, mods) i =\n  (if c = 0 then LLL_swap_row p (fs, dmu, di, mods) i\n   else perform_swap_add p (fs, dmu, di, mods) i (i - 1) c (dmu !! i)\n         (dmu !! i !! (i - 1)) (di !! i))\n\ngoal (1 subgoal):\n 1. LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "proof (cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "thus ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "using i"], ["proof (prove)\nusing this:\n  c = 0\n  i \\<noteq> 0\n  i < m\n\ngoal (1 subgoal):\n 1. LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "unfolding res1 LLL_add_row_def split id c_def Let_def"], ["proof (prove)\nusing this:\n  round_num_denom (dmu !! i !! (i - 1)) (di !! i) = 0\n  i \\<noteq> 0\n  i < m\n\ngoal (1 subgoal):\n 1. (if round_num_denom (dmu !! i !! (i - 1)) (di !! i) = 0\n     then LLL_swap_row p (fs, dmu, di, mods) i\n     else perform_swap_add p (fs, dmu, di, mods) i (i - 1)\n           (round_num_denom (dmu !! i !! (i - 1)) (di !! i)) (dmu !! i)\n           (dmu !! i !! (i - 1)) (di !! i)) =\n    LLL_swap_row p\n     (if round_num_denom (dmu !! i !! (i - 1)) (di !! Suc (i - 1)) = 0\n      then (fs, dmu, di, mods)\n      else perform_add_row p (fs, dmu, di, mods) i (i - 1)\n            (round_num_denom (dmu !! i !! (i - 1)) (di !! Suc (i - 1)))\n            (dmu !! i) (dmu !! i !! (i - 1)) (di !! Suc (i - 1)))\n     i", "by auto"], ["proof (state)\nthis:\n  LLL_swap_add p (fs, dmu, di, mods) i =\n  LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "hence c: \"(c = 0) = False\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (c = 0) = False", "by simp"], ["proof (state)\nthis:\n  (c = 0) = False\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "have add: \"LLL_add_row p (fs, dmu, di, mods) i (i - 1) = \n       perform_add_row p (fs, dmu, di, mods) i (i - 1) c (dmu !! i) (dmu !! i !! (i - 1)) (di !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_add_row p (fs, dmu, di, mods) i (i - 1) =\n    perform_add_row p (fs, dmu, di, mods) i (i - 1) c (dmu !! i)\n     (dmu !! i !! (i - 1)) (di !! i)", "unfolding LLL_add_row_def Let_def split si1 c_def[symmetric] c"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if False then (fs, dmu, di, mods)\n     else perform_add_row p (fs, dmu, di, mods) i (i - 1) c (dmu !! i)\n           (dmu !! i !! (i - 1)) (di !! i)) =\n    perform_add_row p (fs, dmu, di, mods) i (i - 1) c (dmu !! i)\n     (dmu !! i !! (i - 1)) (di !! i)", "by auto"], ["proof (state)\nthis:\n  LLL_add_row p (fs, dmu, di, mods) i (i - 1) =\n  perform_add_row p (fs, dmu, di, mods) i (i - 1) c (dmu !! i)\n   (dmu !! i !! (i - 1)) (di !! i)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_swap_add p (fs, dmu, di, mods) i =\n    LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i", "unfolding res1 c if_False add"], ["proof (prove)\ngoal (1 subgoal):\n 1. perform_swap_add p (fs, dmu, di, mods) i (i - 1) c (dmu !! i)\n     (dmu !! i !! (i - 1)) (di !! i) =\n    LLL_swap_row p\n     (perform_add_row p (fs, dmu, di, mods) i (i - 1) c (dmu !! i)\n       (dmu !! i !! (i - 1)) (di !! i))\n     i", "by (subst perform_swap_add[OF assms]) simp"], ["proof (state)\nthis:\n  LLL_swap_add p (fs, dmu, di, mods) i =\n  LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_swap_add p (fs, dmu, di, mods) i =\n  LLL_swap_row p (LLL_add_row p (fs, dmu, di, mods) i (i - 1)) i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context LLL_with_assms\nbegin"], ["", "lemma LLL_mod_inv_to_weak: \"LLL_invariant_mod fs mfs dmu p first b i \\<Longrightarrow> LLL_invariant_mod_weak fs mfs dmu p first b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant_mod fs mfs dmu p first b i \\<Longrightarrow>\n    LLL_invariant_mod_weak fs mfs dmu p first b", "unfolding LLL_invariant_mod_def LLL_invariant_mod_weak_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length fs = m \\<and>\n    length mfs = m \\<and>\n    i \\<le> m \\<and>\n    lattice_of fs = L \\<and>\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n    gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n     i \\<and>\n    map (map_vec (\\<lambda>x. x symmod p)) fs = mfs \\<and>\n    (\\<forall>i'<m.\n        \\<forall>j'<i'.\n           \\<bar>d\\<mu> fs i' j'\\<bar> < p * d fs j' * d fs (Suc j')) \\<and>\n    (\\<forall>i'<m. \\<forall>j'<m. d\\<mu> fs i' j' = dmu $$ (i', j')) \\<and>\n    1 < p \\<and>\n    g_bnd_mode first b fs \\<and> mod_invariant b p first \\<Longrightarrow>\n    length fs = m \\<and>\n    length mfs = m \\<and>\n    lattice_of fs = L \\<and>\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n    map (map_vec (\\<lambda>x. x symmod p)) fs = mfs \\<and>\n    (\\<forall>i'<m.\n        \\<forall>j'<i'.\n           \\<bar>d\\<mu> fs i' j'\\<bar> < p * d fs j' * d fs (Suc j')) \\<and>\n    (\\<forall>i'<m. \\<forall>j'<m. d\\<mu> fs i' j' = dmu $$ (i', j')) \\<and>\n    1 < p \\<and> g_bnd_mode first b fs \\<and> mod_invariant b p first", "by auto"], ["", "declare IArray.of_fun_def[simp del]"], ["", "lemma LLL_swap_row: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod_weak fs mfs dmu p first b\"\n  and res: \"basis_reduction_mod_swap p mfs dmu k = (mfs', dmu')\" \n  and res': \"LLL_swap_row p state k = state'\" \n  and k: \"k < m\" \"k \\<noteq> 0\" \nshows \"state_impl_inv p mfs' dmu' state'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "note inv = LLL_invD_modw[OF Linv]"], ["proof (state)\nthis:\n  length mfs = m\n  length fs = m\n  lattice_of fs = L\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  map (map_vec (\\<lambda>x. x symmod p)) fs = mfs\n  \\<forall>i'<m.\n     \\<forall>j'<i'.\n        \\<bar>d\\<mu> fs i' j'\\<bar> < p * d fs j' * d fs (Suc j')\n  \\<forall>i'<m. \\<forall>j'<m. d\\<mu> fs i' j' = dmu $$ (i', j')\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  ?i < m \\<Longrightarrow> mfs ! ?i \\<in> carrier_vec n\n  set mfs \\<subseteq> carrier_vec n\n  1 < p\n  g_bnd_mode first b fs\n  mod_invariant b p first\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "obtain fsi dmui di mods where state: \"state = (fsi, dmui, di, mods)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fsi dmui di mods.\n        state = (fsi, dmui, di, mods) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases state, auto)"], ["proof (state)\nthis:\n  state = (fsi, dmui, di, mods)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "obtain fsi' dmui' di' mods' where state': \"state' = (fsi', dmui', di', mods')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fsi' dmui' di' mods'.\n        state' = (fsi', dmui', di', mods') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases state', auto)"], ["proof (state)\nthis:\n  state' = (fsi', dmui', di', mods')\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "from impl[unfolded state, simplified]"], ["proof (chain)\npicking this:\n  fsi = mfs \\<and>\n  di = IArray.of_fun (d_of dmu) (Suc m) \\<and>\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n   m \\<and>\n  mods =\n  IArray.of_fun\n   (\\<lambda>j. p * IArray.list_of di ! j * IArray.list_of di ! Suc j)\n   (m - Suc 0)", "have id: \"fsi = mfs\" \n    \"di = IArray.of_fun (d_of dmu) (Suc m)\" \n    \"dmui = IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m\" \n    \"mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)\""], ["proof (prove)\nusing this:\n  fsi = mfs \\<and>\n  di = IArray.of_fun (d_of dmu) (Suc m) \\<and>\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n   m \\<and>\n  mods =\n  IArray.of_fun\n   (\\<lambda>j. p * IArray.list_of di ! j * IArray.list_of di ! Suc j)\n   (m - Suc 0)\n\ngoal (1 subgoal):\n 1. (fsi = mfs &&& di = IArray.of_fun (d_of dmu) (Suc m)) &&&\n    dmui =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n     m &&&\n    mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)", "by auto"], ["proof (state)\nthis:\n  fsi = mfs\n  di = IArray.of_fun (d_of dmu) (Suc m)\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "have kk1: \"dmui !! k !! (k - 1) = dmu $$ (k, k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dmui !! k !! (k - 1) = dmu $$ (k, k - 1)", "using k"], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dmui !! k !! (k - 1) = dmu $$ (k, k - 1)", "unfolding id \n      IArray.of_fun_nth[OF k(1)]"], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>j. dmu $$ (k, j)) k !! (k - 1) =\n    dmu $$ (k, k - 1)", "by (subst IArray.of_fun_nth, auto)"], ["proof (state)\nthis:\n  dmui !! k !! (k - 1) = dmu $$ (k, k - 1)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "have di: \"i \\<le> m \\<Longrightarrow> di !! i = d_of dmu i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> m \\<Longrightarrow> di !! i = d_of dmu i", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> m \\<Longrightarrow>\n    IArray.of_fun (d_of dmu) (Suc m) !! i = d_of dmu i", "by (subst IArray.of_fun_nth, auto)"], ["proof (state)\nthis:\n  ?i2 \\<le> m \\<Longrightarrow> di !! ?i2 = d_of dmu ?i2\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "have dS1: \"di !! Suc k = d_of dmu (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. di !! Suc k = d_of dmu (Suc k)", "using di k"], ["proof (prove)\nusing this:\n  ?i2 \\<le> m \\<Longrightarrow> di !! ?i2 = d_of dmu ?i2\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. di !! Suc k = d_of dmu (Suc k)", "by auto"], ["proof (state)\nthis:\n  di !! Suc k = d_of dmu (Suc k)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "have d1: \"di !! (k - 1) = d_of dmu (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. di !! (k - 1) = d_of dmu (k - 1)", "using di k"], ["proof (prove)\nusing this:\n  ?i2 \\<le> m \\<Longrightarrow> di !! ?i2 = d_of dmu ?i2\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. di !! (k - 1) = d_of dmu (k - 1)", "by auto"], ["proof (state)\nthis:\n  di !! (k - 1) = d_of dmu (k - 1)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "have dk: \"di !! k = d_of dmu k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. di !! k = d_of dmu k", "using di k"], ["proof (prove)\nusing this:\n  ?i2 \\<le> m \\<Longrightarrow> di !! ?i2 = d_of dmu ?i2\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. di !! k = d_of dmu k", "by auto"], ["proof (state)\nthis:\n  di !! k = d_of dmu k\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "define dk' where \"dk' = (d_of dmu (Suc k) * d_of dmu (k - 1) + dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div d_of dmu k\""], ["proof (state)\nthis:\n  dk' =\n  (d_of dmu (Suc k) * d_of dmu (k - 1) +\n   dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div\n  d_of dmu k\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "define mod1 where \"mod1 = p * d_of dmu (k - 1) * dk'\""], ["proof (state)\nthis:\n  mod1 = p * d_of dmu (k - 1) * dk'\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "define modk where \"modk = p * dk' * d_of dmu (Suc k)\""], ["proof (state)\nthis:\n  modk = p * dk' * d_of dmu (Suc k)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "define dmu'' where \"dmu'' = (mat m m\n      (\\<lambda>(i, j).\n          if j < i\n          then if i = k - 1 then dmu $$ (k, j)\n               else if i = k \\<and> j \\<noteq> k - 1 then dmu $$ (k - 1, j)\n                    else if k < i \\<and> j = k then (d_of dmu (Suc k) * dmu $$ (i, k - 1) - dmu $$ (k, k - 1) * dmu $$ (i, j)) div d_of dmu k\n                         else if k < i \\<and> j = k - 1 then (dmu $$ (k, k - 1) * dmu $$ (i, j) + dmu $$ (i, k) * d_of dmu (k - 1)) div d_of dmu k else dmu $$ (i, j)\n          else if i = j then if i = k - 1 then (d_of dmu (Suc k) * d_of dmu (k - 1) + dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div d_of dmu k else d_of dmu (Suc i)\n               else dmu $$ (i, j)))\""], ["proof (state)\nthis:\n  dmu'' =\n  mat m m\n   (\\<lambda>(i, j).\n       if j < i\n       then if i = k - 1 then dmu $$ (k, j)\n            else if i = k \\<and> j \\<noteq> k - 1 then dmu $$ (k - 1, j)\n                 else if k < i \\<and> j = k\n                      then (d_of dmu (Suc k) * dmu $$ (i, k - 1) -\n                            dmu $$ (k, k - 1) * dmu $$ (i, j)) div\n                           d_of dmu k\n                      else if k < i \\<and> j = k - 1\n                           then (dmu $$ (k, k - 1) * dmu $$ (i, j) +\n                                 dmu $$ (i, k) * d_of dmu (k - 1)) div\n                                d_of dmu k\n                           else dmu $$ (i, j)\n       else if i = j\n            then if i = k - 1\n                 then (d_of dmu (Suc k) * d_of dmu (k - 1) +\n                       dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div\n                      d_of dmu k\n                 else d_of dmu (Suc i)\n            else dmu $$ (i, j))\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "have drop: \"drop (k - 1) fsi = mfs ! (k - 1) # mfs ! k # drop (Suc k) mfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (k - 1) fsi = mfs ! (k - 1) # mfs ! k # drop (Suc k) mfs", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (k - 1) mfs = mfs ! (k - 1) # mfs ! k # drop (Suc k) mfs", "using \\<open>length mfs = m\\<close> k"], ["proof (prove)\nusing this:\n  length mfs = m\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. drop (k - 1) mfs = mfs ! (k - 1) # mfs ! k # drop (Suc k) mfs", "by (metis Cons_nth_drop_Suc One_nat_def Suc_less_eq Suc_pred less_SucI linorder_neqE_nat not_less0)"], ["proof (state)\nthis:\n  drop (k - 1) fsi = mfs ! (k - 1) # mfs ! k # drop (Suc k) mfs\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "have dk': \"dk' = d_of dmu'' k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dk' = d_of dmu'' k", "unfolding dk'_def d_of_def dmu''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if Suc k = 0 then 1 else dmu $$ (Suc k - 1, Suc k - 1)) *\n     (if k - 1 = 0 then 1 else dmu $$ (k - 1 - 1, k - 1 - 1)) +\n     dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div\n    (if k = 0 then 1 else dmu $$ (k - 1, k - 1)) =\n    (if k = 0 then 1\n     else mat m m\n           (\\<lambda>(i, j).\n               if j < i\n               then if i = k - 1 then dmu $$ (k, j)\n                    else if i = k \\<and> j \\<noteq> k - 1\n                         then dmu $$ (k - 1, j)\n                         else if k < i \\<and> j = k\n                              then ((if Suc k = 0 then 1\n                                     else dmu $$ (Suc k - 1, Suc k - 1)) *\n                                    dmu $$ (i, k - 1) -\n                                    dmu $$ (k, k - 1) * dmu $$ (i, j)) div\n                                   (if k = 0 then 1\n                                    else dmu $$ (k - 1, k - 1))\n                              else if k < i \\<and> j = k - 1\n                                   then (dmu $$ (k, k - 1) * dmu $$ (i, j) +\n   dmu $$ (i, k) *\n   (if k - 1 = 0 then 1 else dmu $$ (k - 1 - 1, k - 1 - 1))) div\n  (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                                   else dmu $$ (i, j)\n               else if i = j\n                    then if i = k - 1\n                         then ((if Suc k = 0 then 1\n                                else dmu $$ (Suc k - 1, Suc k - 1)) *\n                               (if k - 1 = 0 then 1\n                                else dmu $$ (k - 1 - 1, k - 1 - 1)) +\n                               dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div\n                              (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                         else if Suc i = 0 then 1\n                              else dmu $$ (Suc i - 1, Suc i - 1)\n                    else dmu $$ (i, j)) $$\n          (k - 1, k - 1))", "using k"], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((if Suc k = 0 then 1 else dmu $$ (Suc k - 1, Suc k - 1)) *\n     (if k - 1 = 0 then 1 else dmu $$ (k - 1 - 1, k - 1 - 1)) +\n     dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div\n    (if k = 0 then 1 else dmu $$ (k - 1, k - 1)) =\n    (if k = 0 then 1\n     else mat m m\n           (\\<lambda>(i, j).\n               if j < i\n               then if i = k - 1 then dmu $$ (k, j)\n                    else if i = k \\<and> j \\<noteq> k - 1\n                         then dmu $$ (k - 1, j)\n                         else if k < i \\<and> j = k\n                              then ((if Suc k = 0 then 1\n                                     else dmu $$ (Suc k - 1, Suc k - 1)) *\n                                    dmu $$ (i, k - 1) -\n                                    dmu $$ (k, k - 1) * dmu $$ (i, j)) div\n                                   (if k = 0 then 1\n                                    else dmu $$ (k - 1, k - 1))\n                              else if k < i \\<and> j = k - 1\n                                   then (dmu $$ (k, k - 1) * dmu $$ (i, j) +\n   dmu $$ (i, k) *\n   (if k - 1 = 0 then 1 else dmu $$ (k - 1 - 1, k - 1 - 1))) div\n  (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                                   else dmu $$ (i, j)\n               else if i = j\n                    then if i = k - 1\n                         then ((if Suc k = 0 then 1\n                                else dmu $$ (Suc k - 1, Suc k - 1)) *\n                               (if k - 1 = 0 then 1\n                                else dmu $$ (k - 1 - 1, k - 1 - 1)) +\n                               dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div\n                              (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                         else if Suc i = 0 then 1\n                              else dmu $$ (Suc i - 1, Suc i - 1)\n                    else dmu $$ (i, j)) $$\n          (k - 1, k - 1))", "by auto"], ["proof (state)\nthis:\n  dk' = d_of dmu'' k\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "have mod1: \"mod1 = p * d_of dmu'' (k - 1) * d_of dmu'' k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod1 = p * d_of dmu'' (k - 1) * d_of dmu'' k", "unfolding mod1_def dk'"], ["proof (prove)\ngoal (1 subgoal):\n 1. p * d_of dmu (k - 1) * d_of dmu'' k =\n    p * d_of dmu'' (k - 1) * d_of dmu'' k", "using k"], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p * d_of dmu (k - 1) * d_of dmu'' k =\n    p * d_of dmu'' (k - 1) * d_of dmu'' k", "by (auto simp: dmu''_def d_of_def)"], ["proof (state)\nthis:\n  mod1 = p * d_of dmu'' (k - 1) * d_of dmu'' k\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "have modk: \"modk = p * d_of dmu'' k * d_of dmu'' (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. modk = p * d_of dmu'' k * d_of dmu'' (Suc k)", "unfolding modk_def dk'"], ["proof (prove)\ngoal (1 subgoal):\n 1. p * d_of dmu'' k * d_of dmu (Suc k) =\n    p * d_of dmu'' k * d_of dmu'' (Suc k)", "using k"], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p * d_of dmu'' k * d_of dmu (Suc k) =\n    p * d_of dmu'' k * d_of dmu'' (Suc k)", "by (auto simp: dmu''_def d_of_def)"], ["proof (state)\nthis:\n  modk = p * d_of dmu'' k * d_of dmu'' (Suc k)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "note res = res[unfolded basis_reduction_mod_swap_def, folded dmu''_def, symmetric]"], ["proof (state)\nthis:\n  (mfs', dmu') =\n  (mfs[k := mfs ! (k - 1), k - 1 := mfs ! k],\n   basis_reduction_mod_swap_dmu_mod p dmu'' k)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "note res' = res'[unfolded state state' split_at_def drop list.simps split LLL_swap_row_def Let_def kk1 dS1 d1 dk, \n      folded dk'_def mod1_def modk_def, symmetric]"], ["proof (state)\nthis:\n  (fsi', dmui', di', mods') =\n  (take (k - 1) fsi @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs,\n   IArray.of_fun\n    (\\<lambda>i.\n        if i < k - 1 then dmui !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                             dmui !! i !! k * d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                  dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else dmui !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else dmui !! (k - 1) !! j)\n                        i\n                  else IArray.of_fun ((!!) (dmui !! k)) i)\n    m,\n   IArray.of_fun (\\<lambda>i. if i = k then dk' else di !! i) (Suc m),\n   IArray.of_fun\n    (\\<lambda>j.\n        if j = k - 1 then mod1 else if j = k then modk else mods !! j)\n    (m - 1))\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "from res'"], ["proof (chain)\npicking this:\n  (fsi', dmui', di', mods') =\n  (take (k - 1) fsi @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs,\n   IArray.of_fun\n    (\\<lambda>i.\n        if i < k - 1 then dmui !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                             dmui !! i !! k * d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                  dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else dmui !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else dmui !! (k - 1) !! j)\n                        i\n                  else IArray.of_fun ((!!) (dmui !! k)) i)\n    m,\n   IArray.of_fun (\\<lambda>i. if i = k then dk' else di !! i) (Suc m),\n   IArray.of_fun\n    (\\<lambda>j.\n        if j = k - 1 then mod1 else if j = k then modk else mods !! j)\n    (m - 1))", "have fsi': \"fsi' = take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs\""], ["proof (prove)\nusing this:\n  (fsi', dmui', di', mods') =\n  (take (k - 1) fsi @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs,\n   IArray.of_fun\n    (\\<lambda>i.\n        if i < k - 1 then dmui !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                             dmui !! i !! k * d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                  dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else dmui !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else dmui !! (k - 1) !! j)\n                        i\n                  else IArray.of_fun ((!!) (dmui !! k)) i)\n    m,\n   IArray.of_fun (\\<lambda>i. if i = k then dk' else di !! i) (Suc m),\n   IArray.of_fun\n    (\\<lambda>j.\n        if j = k - 1 then mod1 else if j = k then modk else mods !! j)\n    (m - 1))\n\ngoal (1 subgoal):\n 1. fsi' = take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs", "unfolding id"], ["proof (prove)\nusing this:\n  (fsi', dmui', di', mods') =\n  (take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs,\n   IArray.of_fun\n    (\\<lambda>i.\n        if i < k - 1\n        then IArray.of_fun\n              (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n             i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) *\n                             IArray.of_fun\n                              (\\<lambda>i.\n                                  IArray.of_fun (\\<lambda>j. dmu $$ (i, j))\n                                   i)\n                              m !!\n                             i !!\n                             (k - 1) +\n                             IArray.of_fun\n                              (\\<lambda>i.\n                                  IArray.of_fun (\\<lambda>j. dmu $$ (i, j))\n                                   i)\n                              m !!\n                             i !!\n                             k *\n                             d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) *\n                                  IArray.of_fun\n                                   (\\<lambda>i.\n IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n                                   m !!\n                                  i !!\n                                  (k - 1) -\n                                  dmu $$ (k, k - 1) *\n                                  IArray.of_fun\n                                   (\\<lambda>i.\n IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n                                   m !!\n                                  i !!\n                                  k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else IArray.of_fun\n                                  (\\<lambda>i.\nIArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n                                  m !!\n                                 i !!\n                                 j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else IArray.of_fun\n                                  (\\<lambda>i.\nIArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n                                  m !!\n                                 (k - 1) !!\n                                 j)\n                        i\n                  else IArray.of_fun\n                        ((!!)\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n                            m !!\n                           k))\n                        i)\n    m,\n   IArray.of_fun\n    (\\<lambda>i.\n        if i = k then dk' else IArray.of_fun (d_of dmu) (Suc m) !! i)\n    (Suc m),\n   IArray.of_fun\n    (\\<lambda>j.\n        if j = k - 1 then mod1\n        else if j = k then modk\n             else IArray.of_fun\n                   (\\<lambda>j.\n                       p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n                       IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n                   (m - 1) !!\n                  j)\n    (m - 1))\n\ngoal (1 subgoal):\n 1. fsi' = take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs", "by simp"], ["proof (state)\nthis:\n  fsi' = take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "from res'"], ["proof (chain)\npicking this:\n  (fsi', dmui', di', mods') =\n  (take (k - 1) fsi @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs,\n   IArray.of_fun\n    (\\<lambda>i.\n        if i < k - 1 then dmui !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                             dmui !! i !! k * d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                  dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else dmui !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else dmui !! (k - 1) !! j)\n                        i\n                  else IArray.of_fun ((!!) (dmui !! k)) i)\n    m,\n   IArray.of_fun (\\<lambda>i. if i = k then dk' else di !! i) (Suc m),\n   IArray.of_fun\n    (\\<lambda>j.\n        if j = k - 1 then mod1 else if j = k then modk else mods !! j)\n    (m - 1))", "have di': \"di' = IArray.of_fun (\\<lambda>ii. if ii = k then dk' else di !! ii) (Suc m)\""], ["proof (prove)\nusing this:\n  (fsi', dmui', di', mods') =\n  (take (k - 1) fsi @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs,\n   IArray.of_fun\n    (\\<lambda>i.\n        if i < k - 1 then dmui !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                             dmui !! i !! k * d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                  dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else dmui !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else dmui !! (k - 1) !! j)\n                        i\n                  else IArray.of_fun ((!!) (dmui !! k)) i)\n    m,\n   IArray.of_fun (\\<lambda>i. if i = k then dk' else di !! i) (Suc m),\n   IArray.of_fun\n    (\\<lambda>j.\n        if j = k - 1 then mod1 else if j = k then modk else mods !! j)\n    (m - 1))\n\ngoal (1 subgoal):\n 1. di' =\n    IArray.of_fun (\\<lambda>ii. if ii = k then dk' else di !! ii) (Suc m)", "by simp"], ["proof (state)\nthis:\n  di' =\n  IArray.of_fun (\\<lambda>ii. if ii = k then dk' else di !! ii) (Suc m)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "from res'"], ["proof (chain)\npicking this:\n  (fsi', dmui', di', mods') =\n  (take (k - 1) fsi @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs,\n   IArray.of_fun\n    (\\<lambda>i.\n        if i < k - 1 then dmui !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                             dmui !! i !! k * d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                  dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else dmui !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else dmui !! (k - 1) !! j)\n                        i\n                  else IArray.of_fun ((!!) (dmui !! k)) i)\n    m,\n   IArray.of_fun (\\<lambda>i. if i = k then dk' else di !! i) (Suc m),\n   IArray.of_fun\n    (\\<lambda>j.\n        if j = k - 1 then mod1 else if j = k then modk else mods !! j)\n    (m - 1))", "have dmui': \"dmui' = IArray.of_fun\n    (\\<lambda>i. if i < k - 1 then dmui !! i\n         else if k < i then IArray.of_fun\n                    (\\<lambda>j. if j = k - 1\n                         then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) + dmui !! i !! k * d_of dmu (k - 1)) \n                                 div d_of dmu k symmod mod1\n                         else if j = k\n                              then (d_of dmu (Suc k) * dmui !! i !! (k - 1) - dmu $$ (k, k - 1) * dmui !! i !! k) \n                                 div d_of dmu k symmod modk                                   \n                              else dmui !! i !! j)\n                    i\n              else if i = k then IArray.of_fun (\\<lambda>j. if j = k - 1 then dmu $$ (k, k - 1) symmod mod1 \n        else dmui !! (k - 1) !! j) i else IArray.of_fun ((!!) (dmui !! k)) i)\n    m\""], ["proof (prove)\nusing this:\n  (fsi', dmui', di', mods') =\n  (take (k - 1) fsi @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs,\n   IArray.of_fun\n    (\\<lambda>i.\n        if i < k - 1 then dmui !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                             dmui !! i !! k * d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                  dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else dmui !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else dmui !! (k - 1) !! j)\n                        i\n                  else IArray.of_fun ((!!) (dmui !! k)) i)\n    m,\n   IArray.of_fun (\\<lambda>i. if i = k then dk' else di !! i) (Suc m),\n   IArray.of_fun\n    (\\<lambda>j.\n        if j = k - 1 then mod1 else if j = k then modk else mods !! j)\n    (m - 1))\n\ngoal (1 subgoal):\n 1. dmui' =\n    IArray.of_fun\n     (\\<lambda>i.\n         if i < k - 1 then dmui !! i\n         else if k < i\n              then IArray.of_fun\n                    (\\<lambda>j.\n                        if j = k - 1\n                        then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                              dmui !! i !! k * d_of dmu (k - 1)) div\n                             d_of dmu k symmod\n                             mod1\n                        else if j = k\n                             then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                   dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                  d_of dmu k symmod\n                                  modk\n                             else dmui !! i !! j)\n                    i\n              else if i = k\n                   then IArray.of_fun\n                         (\\<lambda>j.\n                             if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                             else dmui !! (k - 1) !! j)\n                         i\n                   else IArray.of_fun ((!!) (dmui !! k)) i)\n     m", "by auto"], ["proof (state)\nthis:\n  dmui' =\n  IArray.of_fun\n   (\\<lambda>i.\n       if i < k - 1 then dmui !! i\n       else if k < i\n            then IArray.of_fun\n                  (\\<lambda>j.\n                      if j = k - 1\n                      then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                            dmui !! i !! k * d_of dmu (k - 1)) div\n                           d_of dmu k symmod\n                           mod1\n                      else if j = k\n                           then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                 dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                d_of dmu k symmod\n                                modk\n                           else dmui !! i !! j)\n                  i\n            else if i = k\n                 then IArray.of_fun\n                       (\\<lambda>j.\n                           if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                           else dmui !! (k - 1) !! j)\n                       i\n                 else IArray.of_fun ((!!) (dmui !! k)) i)\n   m\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "from res'"], ["proof (chain)\npicking this:\n  (fsi', dmui', di', mods') =\n  (take (k - 1) fsi @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs,\n   IArray.of_fun\n    (\\<lambda>i.\n        if i < k - 1 then dmui !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                             dmui !! i !! k * d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                  dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else dmui !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else dmui !! (k - 1) !! j)\n                        i\n                  else IArray.of_fun ((!!) (dmui !! k)) i)\n    m,\n   IArray.of_fun (\\<lambda>i. if i = k then dk' else di !! i) (Suc m),\n   IArray.of_fun\n    (\\<lambda>j.\n        if j = k - 1 then mod1 else if j = k then modk else mods !! j)\n    (m - 1))", "have mods': \"mods' = IArray.of_fun (\\<lambda>jj. if jj = k - 1 then mod1 else if jj = k then modk else mods !! jj) (m - 1)\""], ["proof (prove)\nusing this:\n  (fsi', dmui', di', mods') =\n  (take (k - 1) fsi @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs,\n   IArray.of_fun\n    (\\<lambda>i.\n        if i < k - 1 then dmui !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                             dmui !! i !! k * d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                  dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else dmui !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else dmui !! (k - 1) !! j)\n                        i\n                  else IArray.of_fun ((!!) (dmui !! k)) i)\n    m,\n   IArray.of_fun (\\<lambda>i. if i = k then dk' else di !! i) (Suc m),\n   IArray.of_fun\n    (\\<lambda>j.\n        if j = k - 1 then mod1 else if j = k then modk else mods !! j)\n    (m - 1))\n\ngoal (1 subgoal):\n 1. mods' =\n    IArray.of_fun\n     (\\<lambda>jj.\n         if jj = k - 1 then mod1 else if jj = k then modk else mods !! jj)\n     (m - 1)", "by auto"], ["proof (state)\nthis:\n  mods' =\n  IArray.of_fun\n   (\\<lambda>jj.\n       if jj = k - 1 then mod1 else if jj = k then modk else mods !! jj)\n   (m - 1)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "from res"], ["proof (chain)\npicking this:\n  (mfs', dmu') =\n  (mfs[k := mfs ! (k - 1), k - 1 := mfs ! k],\n   basis_reduction_mod_swap_dmu_mod p dmu'' k)", "have dmu': \"dmu' = basis_reduction_mod_swap_dmu_mod p dmu'' k\""], ["proof (prove)\nusing this:\n  (mfs', dmu') =\n  (mfs[k := mfs ! (k - 1), k - 1 := mfs ! k],\n   basis_reduction_mod_swap_dmu_mod p dmu'' k)\n\ngoal (1 subgoal):\n 1. dmu' = basis_reduction_mod_swap_dmu_mod p dmu'' k", "by auto"], ["proof (state)\nthis:\n  dmu' = basis_reduction_mod_swap_dmu_mod p dmu'' k\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "unfolding state' state_impl_inv.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. fsi' = mfs' \\<and>\n    di' = IArray.of_fun (d_of dmu') (Suc m) \\<and>\n    dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m \\<and>\n    mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "proof (intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. fsi' = mfs'\n 2. di' = IArray.of_fun (d_of dmu') (Suc m)\n 3. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m\n 4. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "from res"], ["proof (chain)\npicking this:\n  (mfs', dmu') =\n  (mfs[k := mfs ! (k - 1), k - 1 := mfs ! k],\n   basis_reduction_mod_swap_dmu_mod p dmu'' k)", "have mfs': \"mfs' = mfs[k := mfs ! (k - 1), k - 1 := mfs ! k]\""], ["proof (prove)\nusing this:\n  (mfs', dmu') =\n  (mfs[k := mfs ! (k - 1), k - 1 := mfs ! k],\n   basis_reduction_mod_swap_dmu_mod p dmu'' k)\n\ngoal (1 subgoal):\n 1. mfs' = mfs[k := mfs ! (k - 1), k - 1 := mfs ! k]", "by simp"], ["proof (state)\nthis:\n  mfs' = mfs[k := mfs ! (k - 1), k - 1 := mfs ! k]\n\ngoal (4 subgoals):\n 1. fsi' = mfs'\n 2. di' = IArray.of_fun (d_of dmu') (Suc m)\n 3. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m\n 4. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "show \"fsi' = mfs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fsi' = mfs'", "unfolding fsi' mfs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs = mfs\n    [k := mfs ! (k - 1), k - 1 := mfs ! k]", "using \\<open>length mfs = m\\<close> k"], ["proof (prove)\nusing this:\n  length mfs = m\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs = mfs\n    [k := mfs ! (k - 1), k - 1 := mfs ! k]", "proof (intro nth_equalityI, force, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>length mfs = m; k < m; k \\<noteq> 0;\n        i < length\n             (take (k - 1) mfs @\n              mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs)\\<rbrakk>\n       \\<Longrightarrow> (take (k - 1) mfs @\n                          mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs) !\n                         i =\n                         mfs[k := mfs ! (k - 1), k - 1 := mfs ! k] ! i", "case (1 j)"], ["proof (state)\nthis:\n  length mfs = m\n  k < m\n  k \\<noteq> 0\n  j < length (take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>length mfs = m; k < m; k \\<noteq> 0;\n        i < length\n             (take (k - 1) mfs @\n              mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs)\\<rbrakk>\n       \\<Longrightarrow> (take (k - 1) mfs @\n                          mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs) !\n                         i =\n                         mfs[k := mfs ! (k - 1), k - 1 := mfs ! k] ! i", "have choice: \"j = k - 1 \\<or> j = k \\<or> j < k - 1 \\<or> j > k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = k - 1 \\<or> j = k \\<or> j < k - 1 \\<or> k < j", "by linarith"], ["proof (state)\nthis:\n  j = k - 1 \\<or> j = k \\<or> j < k - 1 \\<or> k < j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>length mfs = m; k < m; k \\<noteq> 0;\n        i < length\n             (take (k - 1) mfs @\n              mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs)\\<rbrakk>\n       \\<Longrightarrow> (take (k - 1) mfs @\n                          mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs) !\n                         i =\n                         mfs[k := mfs ! (k - 1), k - 1 := mfs ! k] ! i", "have \"min (length mfs) (k - 1) = k - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (length mfs) (k - 1) = k - 1", "using 1"], ["proof (prove)\nusing this:\n  length mfs = m\n  k < m\n  k \\<noteq> 0\n  j < length (take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs)\n\ngoal (1 subgoal):\n 1. min (length mfs) (k - 1) = k - 1", "by auto"], ["proof (state)\nthis:\n  min (length mfs) (k - 1) = k - 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>length mfs = m; k < m; k \\<noteq> 0;\n        i < length\n             (take (k - 1) mfs @\n              mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs)\\<rbrakk>\n       \\<Longrightarrow> (take (k - 1) mfs @\n                          mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs) !\n                         i =\n                         mfs[k := mfs ! (k - 1), k - 1 := mfs ! k] ! i", "with 1 choice"], ["proof (chain)\npicking this:\n  length mfs = m\n  k < m\n  k \\<noteq> 0\n  j < length (take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs)\n  j = k - 1 \\<or> j = k \\<or> j < k - 1 \\<or> k < j\n  min (length mfs) (k - 1) = k - 1", "show ?case"], ["proof (prove)\nusing this:\n  length mfs = m\n  k < m\n  k \\<noteq> 0\n  j < length (take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs)\n  j = k - 1 \\<or> j = k \\<or> j < k - 1 \\<or> k < j\n  min (length mfs) (k - 1) = k - 1\n\ngoal (1 subgoal):\n 1. (take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs) ! j =\n    mfs[k := mfs ! (k - 1), k - 1 := mfs ! k] ! j", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  (take (k - 1) mfs @ mfs ! k # mfs ! (k - 1) # drop (Suc k) mfs) ! j =\n  mfs[k := mfs ! (k - 1), k - 1 := mfs ! k] ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fsi' = mfs'\n\ngoal (3 subgoals):\n 1. di' = IArray.of_fun (d_of dmu') (Suc m)\n 2. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m\n 3. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "show \"di' = IArray.of_fun (d_of dmu') (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. di' = IArray.of_fun (d_of dmu') (Suc m)", "unfolding di'"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>ii. if ii = k then dk' else di !! ii) (Suc m) =\n    IArray.of_fun (d_of dmu') (Suc m)", "proof (intro iarray_cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc m \\<Longrightarrow>\n       (if i = k then dk' else di !! i) = d_of dmu' i", "case i: (1 i)"], ["proof (state)\nthis:\n  i < Suc m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc m \\<Longrightarrow>\n       (if i = k then dk' else di !! i) = d_of dmu' i", "hence \"d_of dmu' i = d_of dmu'' i\""], ["proof (prove)\nusing this:\n  i < Suc m\n\ngoal (1 subgoal):\n 1. d_of dmu' i = d_of dmu'' i", "unfolding dmu' basis_reduction_mod_swap_dmu_mod_def d_of_def"], ["proof (prove)\nusing this:\n  i < Suc m\n\ngoal (1 subgoal):\n 1. (if i = 0 then 1\n     else mat m m\n           (\\<lambda>(i, j).\n               if j < i \\<and> (j = k \\<or> j = k - 1)\n               then dmu'' $$ (i, j) symmod\n                    (p * (if j = 0 then 1 else dmu'' $$ (j - 1, j - 1)) *\n                     (if Suc j = 0 then 1\n                      else dmu'' $$ (Suc j - 1, Suc j - 1)))\n               else dmu'' $$ (i, j)) $$\n          (i - 1, i - 1)) =\n    (if i = 0 then 1 else dmu'' $$ (i - 1, i - 1))", "by (intro if_cong, auto)"], ["proof (state)\nthis:\n  d_of dmu' i = d_of dmu'' i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc m \\<Longrightarrow>\n       (if i = k then dk' else di !! i) = d_of dmu' i", "also"], ["proof (state)\nthis:\n  d_of dmu' i = d_of dmu'' i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc m \\<Longrightarrow>\n       (if i = k then dk' else di !! i) = d_of dmu' i", "have \"\\<dots> = ((if i = k then dk' else di !! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_of dmu'' i = (if i = k then dk' else di !! i)", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow> d_of dmu'' i = (if i = k then dk' else di !! i)\n 2. i \\<noteq> k \\<Longrightarrow>\n    d_of dmu'' i = (if i = k then dk' else di !! i)", "case False"], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow> d_of dmu'' i = (if i = k then dk' else di !! i)\n 2. i \\<noteq> k \\<Longrightarrow>\n    d_of dmu'' i = (if i = k then dk' else di !! i)", "hence \"d_of dmu'' i = d_of dmu i\""], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. d_of dmu'' i = d_of dmu i", "unfolding dmu''_def d_of_def"], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. (if i = 0 then 1\n     else mat m m\n           (\\<lambda>(i, j).\n               if j < i\n               then if i = k - 1 then dmu $$ (k, j)\n                    else if i = k \\<and> j \\<noteq> k - 1\n                         then dmu $$ (k - 1, j)\n                         else if k < i \\<and> j = k\n                              then ((if Suc k = 0 then 1\n                                     else dmu $$ (Suc k - 1, Suc k - 1)) *\n                                    dmu $$ (i, k - 1) -\n                                    dmu $$ (k, k - 1) * dmu $$ (i, j)) div\n                                   (if k = 0 then 1\n                                    else dmu $$ (k - 1, k - 1))\n                              else if k < i \\<and> j = k - 1\n                                   then (dmu $$ (k, k - 1) * dmu $$ (i, j) +\n   dmu $$ (i, k) *\n   (if k - 1 = 0 then 1 else dmu $$ (k - 1 - 1, k - 1 - 1))) div\n  (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                                   else dmu $$ (i, j)\n               else if i = j\n                    then if i = k - 1\n                         then ((if Suc k = 0 then 1\n                                else dmu $$ (Suc k - 1, Suc k - 1)) *\n                               (if k - 1 = 0 then 1\n                                else dmu $$ (k - 1 - 1, k - 1 - 1)) +\n                               dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div\n                              (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                         else if Suc i = 0 then 1\n                              else dmu $$ (Suc i - 1, Suc i - 1)\n                    else dmu $$ (i, j)) $$\n          (i - 1, i - 1)) =\n    (if i = 0 then 1 else dmu $$ (i - 1, i - 1))", "using i k"], ["proof (prove)\nusing this:\n  i \\<noteq> k\n  i < Suc m\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if i = 0 then 1\n     else mat m m\n           (\\<lambda>(i, j).\n               if j < i\n               then if i = k - 1 then dmu $$ (k, j)\n                    else if i = k \\<and> j \\<noteq> k - 1\n                         then dmu $$ (k - 1, j)\n                         else if k < i \\<and> j = k\n                              then ((if Suc k = 0 then 1\n                                     else dmu $$ (Suc k - 1, Suc k - 1)) *\n                                    dmu $$ (i, k - 1) -\n                                    dmu $$ (k, k - 1) * dmu $$ (i, j)) div\n                                   (if k = 0 then 1\n                                    else dmu $$ (k - 1, k - 1))\n                              else if k < i \\<and> j = k - 1\n                                   then (dmu $$ (k, k - 1) * dmu $$ (i, j) +\n   dmu $$ (i, k) *\n   (if k - 1 = 0 then 1 else dmu $$ (k - 1 - 1, k - 1 - 1))) div\n  (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                                   else dmu $$ (i, j)\n               else if i = j\n                    then if i = k - 1\n                         then ((if Suc k = 0 then 1\n                                else dmu $$ (Suc k - 1, Suc k - 1)) *\n                               (if k - 1 = 0 then 1\n                                else dmu $$ (k - 1 - 1, k - 1 - 1)) +\n                               dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div\n                              (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                         else if Suc i = 0 then 1\n                              else dmu $$ (Suc i - 1, Suc i - 1)\n                    else dmu $$ (i, j)) $$\n          (i - 1, i - 1)) =\n    (if i = 0 then 1 else dmu $$ (i - 1, i - 1))", "by (intro if_cong refl, auto)"], ["proof (state)\nthis:\n  d_of dmu'' i = d_of dmu i\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow> d_of dmu'' i = (if i = k then dk' else di !! i)\n 2. i \\<noteq> k \\<Longrightarrow>\n    d_of dmu'' i = (if i = k then dk' else di !! i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  d_of dmu'' i = d_of dmu i\n\ngoal (1 subgoal):\n 1. d_of dmu'' i = (if i = k then dk' else di !! i)", "using False i k"], ["proof (prove)\nusing this:\n  d_of dmu'' i = d_of dmu i\n  i \\<noteq> k\n  i < Suc m\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d_of dmu'' i = (if i = k then dk' else di !! i)", "unfolding id"], ["proof (prove)\nusing this:\n  d_of dmu'' i = d_of dmu i\n  i \\<noteq> k\n  i < Suc m\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d_of dmu'' i =\n    (if i = k then dk' else IArray.of_fun (d_of dmu) (Suc m) !! i)", "by (metis iarray_of_fun_sub)"], ["proof (state)\nthis:\n  d_of dmu'' i = (if i = k then dk' else di !! i)\n\ngoal (1 subgoal):\n 1. i = k \\<Longrightarrow> d_of dmu'' i = (if i = k then dk' else di !! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = k \\<Longrightarrow> d_of dmu'' i = (if i = k then dk' else di !! i)", "case True"], ["proof (state)\nthis:\n  i = k\n\ngoal (1 subgoal):\n 1. i = k \\<Longrightarrow> d_of dmu'' i = (if i = k then dk' else di !! i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = k\n\ngoal (1 subgoal):\n 1. d_of dmu'' i = (if i = k then dk' else di !! i)", "using dk'"], ["proof (prove)\nusing this:\n  i = k\n  dk' = d_of dmu'' k\n\ngoal (1 subgoal):\n 1. d_of dmu'' i = (if i = k then dk' else di !! i)", "by auto"], ["proof (state)\nthis:\n  d_of dmu'' i = (if i = k then dk' else di !! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_of dmu'' i = (if i = k then dk' else di !! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc m \\<Longrightarrow>\n       (if i = k then dk' else di !! i) = d_of dmu' i", "finally"], ["proof (chain)\npicking this:\n  d_of dmu' i = (if i = k then dk' else di !! i)", "show ?case"], ["proof (prove)\nusing this:\n  d_of dmu' i = (if i = k then dk' else di !! i)\n\ngoal (1 subgoal):\n 1. (if i = k then dk' else di !! i) = d_of dmu' i", "by simp"], ["proof (state)\nthis:\n  (if i = k then dk' else di !! i) = d_of dmu' i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  di' = IArray.of_fun (d_of dmu') (Suc m)\n\ngoal (2 subgoals):\n 1. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m\n 2. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "have dkS1: \"d_of dmu (Suc k) = d_of dmu'' (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_of dmu (Suc k) = d_of dmu'' (Suc k)", "unfolding dmu''_def d_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc k = 0 then 1 else dmu $$ (Suc k - 1, Suc k - 1)) =\n    (if Suc k = 0 then 1\n     else mat m m\n           (\\<lambda>(i, j).\n               if j < i\n               then if i = k - 1 then dmu $$ (k, j)\n                    else if i = k \\<and> j \\<noteq> k - 1\n                         then dmu $$ (k - 1, j)\n                         else if k < i \\<and> j = k\n                              then ((if Suc k = 0 then 1\n                                     else dmu $$ (Suc k - 1, Suc k - 1)) *\n                                    dmu $$ (i, k - 1) -\n                                    dmu $$ (k, k - 1) * dmu $$ (i, j)) div\n                                   (if k = 0 then 1\n                                    else dmu $$ (k - 1, k - 1))\n                              else if k < i \\<and> j = k - 1\n                                   then (dmu $$ (k, k - 1) * dmu $$ (i, j) +\n   dmu $$ (i, k) *\n   (if k - 1 = 0 then 1 else dmu $$ (k - 1 - 1, k - 1 - 1))) div\n  (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                                   else dmu $$ (i, j)\n               else if i = j\n                    then if i = k - 1\n                         then ((if Suc k = 0 then 1\n                                else dmu $$ (Suc k - 1, Suc k - 1)) *\n                               (if k - 1 = 0 then 1\n                                else dmu $$ (k - 1 - 1, k - 1 - 1)) +\n                               dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div\n                              (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                         else if Suc i = 0 then 1\n                              else dmu $$ (Suc i - 1, Suc i - 1)\n                    else dmu $$ (i, j)) $$\n          (Suc k - 1, Suc k - 1))", "using k"], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if Suc k = 0 then 1 else dmu $$ (Suc k - 1, Suc k - 1)) =\n    (if Suc k = 0 then 1\n     else mat m m\n           (\\<lambda>(i, j).\n               if j < i\n               then if i = k - 1 then dmu $$ (k, j)\n                    else if i = k \\<and> j \\<noteq> k - 1\n                         then dmu $$ (k - 1, j)\n                         else if k < i \\<and> j = k\n                              then ((if Suc k = 0 then 1\n                                     else dmu $$ (Suc k - 1, Suc k - 1)) *\n                                    dmu $$ (i, k - 1) -\n                                    dmu $$ (k, k - 1) * dmu $$ (i, j)) div\n                                   (if k = 0 then 1\n                                    else dmu $$ (k - 1, k - 1))\n                              else if k < i \\<and> j = k - 1\n                                   then (dmu $$ (k, k - 1) * dmu $$ (i, j) +\n   dmu $$ (i, k) *\n   (if k - 1 = 0 then 1 else dmu $$ (k - 1 - 1, k - 1 - 1))) div\n  (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                                   else dmu $$ (i, j)\n               else if i = j\n                    then if i = k - 1\n                         then ((if Suc k = 0 then 1\n                                else dmu $$ (Suc k - 1, Suc k - 1)) *\n                               (if k - 1 = 0 then 1\n                                else dmu $$ (k - 1 - 1, k - 1 - 1)) +\n                               dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div\n                              (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                         else if Suc i = 0 then 1\n                              else dmu $$ (Suc i - 1, Suc i - 1)\n                    else dmu $$ (i, j)) $$\n          (Suc k - 1, Suc k - 1))", "by auto"], ["proof (state)\nthis:\n  d_of dmu (Suc k) = d_of dmu'' (Suc k)\n\ngoal (2 subgoals):\n 1. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m\n 2. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "have dk1: \"d_of dmu (k - 1) = d_of dmu'' (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_of dmu (k - 1) = d_of dmu'' (k - 1)", "unfolding dmu''_def d_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k - 1 = 0 then 1 else dmu $$ (k - 1 - 1, k - 1 - 1)) =\n    (if k - 1 = 0 then 1\n     else mat m m\n           (\\<lambda>(i, j).\n               if j < i\n               then if i = k - 1 then dmu $$ (k, j)\n                    else if i = k \\<and> j \\<noteq> k - 1\n                         then dmu $$ (k - 1, j)\n                         else if k < i \\<and> j = k\n                              then ((if Suc k = 0 then 1\n                                     else dmu $$ (Suc k - 1, Suc k - 1)) *\n                                    dmu $$ (i, k - 1) -\n                                    dmu $$ (k, k - 1) * dmu $$ (i, j)) div\n                                   (if k = 0 then 1\n                                    else dmu $$ (k - 1, k - 1))\n                              else if k < i \\<and> j = k - 1\n                                   then (dmu $$ (k, k - 1) * dmu $$ (i, j) +\n   dmu $$ (i, k) *\n   (if k - 1 = 0 then 1 else dmu $$ (k - 1 - 1, k - 1 - 1))) div\n  (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                                   else dmu $$ (i, j)\n               else if i = j\n                    then if i = k - 1\n                         then ((if Suc k = 0 then 1\n                                else dmu $$ (Suc k - 1, Suc k - 1)) *\n                               (if k - 1 = 0 then 1\n                                else dmu $$ (k - 1 - 1, k - 1 - 1)) +\n                               dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div\n                              (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                         else if Suc i = 0 then 1\n                              else dmu $$ (Suc i - 1, Suc i - 1)\n                    else dmu $$ (i, j)) $$\n          (k - 1 - 1, k - 1 - 1))", "using k"], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if k - 1 = 0 then 1 else dmu $$ (k - 1 - 1, k - 1 - 1)) =\n    (if k - 1 = 0 then 1\n     else mat m m\n           (\\<lambda>(i, j).\n               if j < i\n               then if i = k - 1 then dmu $$ (k, j)\n                    else if i = k \\<and> j \\<noteq> k - 1\n                         then dmu $$ (k - 1, j)\n                         else if k < i \\<and> j = k\n                              then ((if Suc k = 0 then 1\n                                     else dmu $$ (Suc k - 1, Suc k - 1)) *\n                                    dmu $$ (i, k - 1) -\n                                    dmu $$ (k, k - 1) * dmu $$ (i, j)) div\n                                   (if k = 0 then 1\n                                    else dmu $$ (k - 1, k - 1))\n                              else if k < i \\<and> j = k - 1\n                                   then (dmu $$ (k, k - 1) * dmu $$ (i, j) +\n   dmu $$ (i, k) *\n   (if k - 1 = 0 then 1 else dmu $$ (k - 1 - 1, k - 1 - 1))) div\n  (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                                   else dmu $$ (i, j)\n               else if i = j\n                    then if i = k - 1\n                         then ((if Suc k = 0 then 1\n                                else dmu $$ (Suc k - 1, Suc k - 1)) *\n                               (if k - 1 = 0 then 1\n                                else dmu $$ (k - 1 - 1, k - 1 - 1)) +\n                               dmu $$ (k, k - 1) * dmu $$ (k, k - 1)) div\n                              (if k = 0 then 1 else dmu $$ (k - 1, k - 1))\n                         else if Suc i = 0 then 1\n                              else dmu $$ (Suc i - 1, Suc i - 1)\n                    else dmu $$ (i, j)) $$\n          (k - 1 - 1, k - 1 - 1))", "by auto"], ["proof (state)\nthis:\n  d_of dmu (k - 1) = d_of dmu'' (k - 1)\n\ngoal (2 subgoals):\n 1. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m\n 2. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "show \"dmui' = IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m", "unfolding dmui'"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         if i < k - 1 then dmui !! i\n         else if k < i\n              then IArray.of_fun\n                    (\\<lambda>j.\n                        if j = k - 1\n                        then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                              dmui !! i !! k * d_of dmu (k - 1)) div\n                             d_of dmu k symmod\n                             mod1\n                        else if j = k\n                             then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                   dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                  d_of dmu k symmod\n                                  modk\n                             else dmui !! i !! j)\n                    i\n              else if i = k\n                   then IArray.of_fun\n                         (\\<lambda>j.\n                             if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                             else dmui !! (k - 1) !! j)\n                         i\n                   else IArray.of_fun ((!!) (dmui !! k)) i)\n     m =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m", "proof (intro iarray_cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       (if i < k - 1 then dmui !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                             dmui !! i !! k * d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                  dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else dmui !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else dmui !! (k - 1) !! j)\n                        i\n                  else IArray.of_fun ((!!) (dmui !! k)) i) =\n       IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "case i: (1 i)"], ["proof (state)\nthis:\n  i < m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       (if i < k - 1 then dmui !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                             dmui !! i !! k * d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                  dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else dmui !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else dmui !! (k - 1) !! j)\n                        i\n                  else IArray.of_fun ((!!) (dmui !! k)) i) =\n       IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "consider (1) \"i < k - 1\" | (2) \"i = k - 1\" | (3) \"i = k\" | (4) \"i > k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < k - 1 \\<Longrightarrow> thesis;\n     i = k - 1 \\<Longrightarrow> thesis; i = k \\<Longrightarrow> thesis;\n     k < i \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>i < k - 1 \\<Longrightarrow> ?thesis2;\n   i = k - 1 \\<Longrightarrow> ?thesis2; i = k \\<Longrightarrow> ?thesis2;\n   k < i \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       (if i < k - 1 then dmui !! i\n        else if k < i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1\n                       then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                             dmui !! i !! k * d_of dmu (k - 1)) div\n                            d_of dmu k symmod\n                            mod1\n                       else if j = k\n                            then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                                  dmu $$ (k, k - 1) * dmui !! i !! k) div\n                                 d_of dmu k symmod\n                                 modk\n                            else dmui !! i !! j)\n                   i\n             else if i = k\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                            else dmui !! (k - 1) !! j)\n                        i\n                  else IArray.of_fun ((!!) (dmui !! k)) i) =\n       IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < k - 1 \\<Longrightarrow> ?thesis2;\n   i = k - 1 \\<Longrightarrow> ?thesis2; i = k \\<Longrightarrow> ?thesis2;\n   k < i \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (1 subgoal):\n 1. (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "proof (cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. i < k - 1 \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 2. i = k - 1 \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 3. i = k \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 4. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "case 1"], ["proof (state)\nthis:\n  i < k - 1\n\ngoal (4 subgoals):\n 1. i < k - 1 \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 2. i = k - 1 \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 3. i = k \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 4. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "hence *: \"(i < k - 1) = True\""], ["proof (prove)\nusing this:\n  i < k - 1\n\ngoal (1 subgoal):\n 1. (i < k - 1) = True", "by simp"], ["proof (state)\nthis:\n  (i < k - 1) = True\n\ngoal (4 subgoals):\n 1. i < k - 1 \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 2. i = k - 1 \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 3. i = k \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 4. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "unfolding * if_True id IArray.of_fun_nth[OF i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "using i k 1"], ["proof (prove)\nusing this:\n  i < m\n  k < m\n  k \\<noteq> 0\n  i < k - 1\n\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "by (intro iarray_cong refl, auto simp: dmu' basis_reduction_mod_swap_dmu_mod_def, auto simp: dmu''_def)"], ["proof (state)\nthis:\n  (if i < k - 1 then dmui !! i\n   else if k < i\n        then IArray.of_fun\n              (\\<lambda>j.\n                  if j = k - 1\n                  then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                        dmui !! i !! k * d_of dmu (k - 1)) div\n                       d_of dmu k symmod\n                       mod1\n                  else if j = k\n                       then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                             dmu $$ (k, k - 1) * dmui !! i !! k) div\n                            d_of dmu k symmod\n                            modk\n                       else dmui !! i !! j)\n              i\n        else if i = k\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                       else dmui !! (k - 1) !! j)\n                   i\n             else IArray.of_fun ((!!) (dmui !! k)) i) =\n  IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n\ngoal (3 subgoals):\n 1. i = k - 1 \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 2. i = k \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 3. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. i = k - 1 \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 2. i = k \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 3. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "case 2"], ["proof (state)\nthis:\n  i = k - 1\n\ngoal (3 subgoals):\n 1. i = k - 1 \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 2. i = k \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 3. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "hence *: \"(i < k - 1) = False\" \"(k < i) = False\" \"(i = k) = False\""], ["proof (prove)\nusing this:\n  i = k - 1\n\ngoal (1 subgoal):\n 1. (i < k - 1) = False &&& (k < i) = False &&& (i = k) = False", "using k"], ["proof (prove)\nusing this:\n  i = k - 1\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (i < k - 1) = False &&& (k < i) = False &&& (i = k) = False", "by auto"], ["proof (state)\nthis:\n  (i < k - 1) = False\n  (k < i) = False\n  (i = k) = False\n\ngoal (3 subgoals):\n 1. i = k - 1 \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 2. i = k \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 3. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "unfolding * if_False id"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     ((!!)\n       (IArray.of_fun\n         (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n        k))\n     i =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "using i k 2"], ["proof (prove)\nusing this:\n  i < m\n  k < m\n  k \\<noteq> 0\n  i = k - 1\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     ((!!)\n       (IArray.of_fun\n         (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n        k))\n     i =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "unfolding IArray.of_fun_nth[OF k(1)]"], ["proof (prove)\nusing this:\n  i < m\n  k < m\n  k \\<noteq> 0\n  i = k - 1\n\ngoal (1 subgoal):\n 1. IArray.of_fun ((!!) (IArray.of_fun (\\<lambda>j. dmu $$ (k, j)) k)) i =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "by (intro iarray_cong refl, subst IArray.of_fun_nth, auto simp: dmu' basis_reduction_mod_swap_dmu_mod_def dmu''_def)"], ["proof (state)\nthis:\n  (if i < k - 1 then dmui !! i\n   else if k < i\n        then IArray.of_fun\n              (\\<lambda>j.\n                  if j = k - 1\n                  then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                        dmui !! i !! k * d_of dmu (k - 1)) div\n                       d_of dmu k symmod\n                       mod1\n                  else if j = k\n                       then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                             dmu $$ (k, k - 1) * dmui !! i !! k) div\n                            d_of dmu k symmod\n                            modk\n                       else dmui !! i !! j)\n              i\n        else if i = k\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                       else dmui !! (k - 1) !! j)\n                   i\n             else IArray.of_fun ((!!) (dmui !! k)) i) =\n  IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 2. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 2. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "case 3"], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 2. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "hence *: \"(i < k - 1) = False\" \"(k < i) = False\" \"(i = k) = True\""], ["proof (prove)\nusing this:\n  i = k\n\ngoal (1 subgoal):\n 1. (i < k - 1) = False &&& (k < i) = False &&& (i = k) = True", "using k"], ["proof (prove)\nusing this:\n  i = k\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (i < k - 1) = False &&& (k < i) = False &&& (i = k) = True", "by auto"], ["proof (state)\nthis:\n  (i < k - 1) = False\n  (k < i) = False\n  (i = k) = True\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n 2. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "unfolding * if_False if_True id IArray.of_fun_nth[OF k(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n         else IArray.of_fun\n               (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n               m !!\n              (k - 1) !!\n              j)\n     i =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "proof (intro iarray_cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < i \\<Longrightarrow>\n       (if ia = k - 1 then dmu $$ (k, k - 1) symmod mod1\n        else IArray.of_fun\n              (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n             (k - 1) !!\n             ia) =\n       dmu' $$ (i, ia)", "case j: (1 j)"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < i \\<Longrightarrow>\n       (if ia = k - 1 then dmu $$ (k, k - 1) symmod mod1\n        else IArray.of_fun\n              (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n             (k - 1) !!\n             ia) =\n       dmu' $$ (i, ia)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)", "proof (cases \"j = k - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = k - 1 \\<Longrightarrow>\n    (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)\n 2. j \\<noteq> k - 1 \\<Longrightarrow>\n    (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)", "case False"], ["proof (state)\nthis:\n  j \\<noteq> k - 1\n\ngoal (2 subgoals):\n 1. j = k - 1 \\<Longrightarrow>\n    (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)\n 2. j \\<noteq> k - 1 \\<Longrightarrow>\n    (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)", "hence *: \"(j = k - 1) = False\""], ["proof (prove)\nusing this:\n  j \\<noteq> k - 1\n\ngoal (1 subgoal):\n 1. (j = k - 1) = False", "by auto"], ["proof (state)\nthis:\n  (j = k - 1) = False\n\ngoal (2 subgoals):\n 1. j = k - 1 \\<Longrightarrow>\n    (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)\n 2. j \\<noteq> k - 1 \\<Longrightarrow>\n    (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)", "unfolding * if_False"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n     m !!\n    (k - 1) !!\n    j =\n    dmu' $$ (i, j)", "using False j k i 3"], ["proof (prove)\nusing this:\n  j \\<noteq> k - 1\n  j < i\n  k < m\n  k \\<noteq> 0\n  i < m\n  i = k\n\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n     m !!\n    (k - 1) !!\n    j =\n    dmu' $$ (i, j)", "by (subst IArray.of_fun_nth, force, subst IArray.of_fun_nth, force, auto simp: dmu' basis_reduction_mod_swap_dmu_mod_def dmu''_def)"], ["proof (state)\nthis:\n  (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n   else IArray.of_fun\n         (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n        (k - 1) !!\n        j) =\n  dmu' $$ (i, j)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)", "case True"], ["proof (state)\nthis:\n  j = k - 1\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)", "hence *: \"(j = k - 1) = True\""], ["proof (prove)\nusing this:\n  j = k - 1\n\ngoal (1 subgoal):\n 1. (j = k - 1) = True", "by auto"], ["proof (state)\nthis:\n  (j = k - 1) = True\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n          (k - 1) !!\n          j) =\n    dmu' $$ (i, j)", "unfolding * if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu $$ (k, k - 1) symmod mod1 = dmu' $$ (i, j)", "unfolding True 3"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu $$ (k, k - 1) symmod mod1 = dmu' $$ (k, k - 1)", "using k"], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dmu $$ (k, k - 1) symmod mod1 = dmu' $$ (k, k - 1)", "by (auto simp: basis_reduction_mod_swap_dmu_mod_def dmu' dk' mod1 dmu''_def)"], ["proof (state)\nthis:\n  (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n   else IArray.of_fun\n         (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n        (k - 1) !!\n        j) =\n  dmu' $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n   else IArray.of_fun\n         (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n        (k - 1) !!\n        j) =\n  dmu' $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if i < k - 1 then dmui !! i\n   else if k < i\n        then IArray.of_fun\n              (\\<lambda>j.\n                  if j = k - 1\n                  then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                        dmui !! i !! k * d_of dmu (k - 1)) div\n                       d_of dmu k symmod\n                       mod1\n                  else if j = k\n                       then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                             dmu $$ (k, k - 1) * dmui !! i !! k) div\n                            d_of dmu k symmod\n                            modk\n                       else dmui !! i !! j)\n              i\n        else if i = k\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                       else dmui !! (k - 1) !! j)\n                   i\n             else IArray.of_fun ((!!) (dmui !! k)) i) =\n  IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "case 4"], ["proof (state)\nthis:\n  k < i\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "hence *: \"(i < k - 1) = False\" \"(k < i) = True\""], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. (i < k - 1) = False &&& (k < i) = True", "using k"], ["proof (prove)\nusing this:\n  k < i\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (i < k - 1) = False &&& (k < i) = True", "by auto"], ["proof (state)\nthis:\n  (i < k - 1) = False\n  (k < i) = True\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow>\n    (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < k - 1 then dmui !! i\n     else if k < i\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = k - 1\n                    then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                          dmui !! i !! k * d_of dmu (k - 1)) div\n                         d_of dmu k symmod\n                         mod1\n                    else if j = k\n                         then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                               dmu $$ (k, k - 1) * dmui !! i !! k) div\n                              d_of dmu k symmod\n                              modk\n                         else dmui !! i !! j)\n                i\n          else if i = k\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                         else dmui !! (k - 1) !! j)\n                     i\n               else IArray.of_fun ((!!) (dmui !! k)) i) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "unfolding * if_False if_True id IArray.of_fun_nth[OF k(1)] IArray.of_fun_nth[OF \\<open>i < m\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>j.\n         if j = k - 1\n         then (dmu $$ (k, k - 1) *\n               IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! (k - 1) +\n               IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! k *\n               d_of dmu (k - 1)) div\n              d_of dmu k symmod\n              mod1\n         else if j = k\n              then (d_of dmu (Suc k) *\n                    IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! (k - 1) -\n                    dmu $$ (k, k - 1) *\n                    IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! k) div\n                   d_of dmu k symmod\n                   modk\n              else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j)\n     i =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i", "proof (intro iarray_cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < i \\<Longrightarrow>\n       (if ia = k - 1\n        then (dmu $$ (k, k - 1) *\n              IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! (k - 1) +\n              IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! k *\n              d_of dmu (k - 1)) div\n             d_of dmu k symmod\n             mod1\n        else if ia = k\n             then (d_of dmu (Suc k) *\n                   IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! (k - 1) -\n                   dmu $$ (k, k - 1) *\n                   IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! k) div\n                  d_of dmu k symmod\n                  modk\n             else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! ia) =\n       dmu' $$ (i, ia)", "case j: (1 j)"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < i \\<Longrightarrow>\n       (if ia = k - 1\n        then (dmu $$ (k, k - 1) *\n              IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! (k - 1) +\n              IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! k *\n              d_of dmu (k - 1)) div\n             d_of dmu k symmod\n             mod1\n        else if ia = k\n             then (d_of dmu (Suc k) *\n                   IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! (k - 1) -\n                   dmu $$ (k, k - 1) *\n                   IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! k) div\n                  d_of dmu k symmod\n                  modk\n             else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! ia) =\n       dmu' $$ (i, ia)", "from 4"], ["proof (chain)\npicking this:\n  k < i", "have k1: \"k - 1 < i\""], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. k - 1 < i", "by auto"], ["proof (state)\nthis:\n  k - 1 < i\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < i \\<Longrightarrow>\n       (if ia = k - 1\n        then (dmu $$ (k, k - 1) *\n              IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! (k - 1) +\n              IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! k *\n              d_of dmu (k - 1)) div\n             d_of dmu k symmod\n             mod1\n        else if ia = k\n             then (d_of dmu (Suc k) *\n                   IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! (k - 1) -\n                   dmu $$ (k, k - 1) *\n                   IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! k) div\n                  d_of dmu k symmod\n                  modk\n             else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! ia) =\n       dmu' $$ (i, ia)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j = k - 1\n     then (dmu $$ (k, k - 1) *\n           IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! (k - 1) +\n           IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! k *\n           d_of dmu (k - 1)) div\n          d_of dmu k symmod\n          mod1\n     else if j = k\n          then (d_of dmu (Suc k) *\n                IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! (k - 1) -\n                dmu $$ (k, k - 1) *\n                IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! k) div\n               d_of dmu k symmod\n               modk\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j) =\n    dmu' $$ (i, j)", "unfolding IArray.of_fun_nth[OF j] IArray.of_fun_nth[OF 4] IArray.of_fun_nth[OF k1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j = k - 1\n     then (dmu $$ (k, k - 1) * dmu $$ (i, k - 1) +\n           dmu $$ (i, k) * d_of dmu (k - 1)) div\n          d_of dmu k symmod\n          mod1\n     else if j = k\n          then (d_of dmu (Suc k) * dmu $$ (i, k - 1) -\n                dmu $$ (k, k - 1) * dmu $$ (i, k)) div\n               d_of dmu k symmod\n               modk\n          else dmu $$ (i, j)) =\n    dmu' $$ (i, j)", "unfolding mod1 modk dmu' basis_reduction_mod_swap_dmu_mod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j = k - 1\n     then (dmu $$ (k, k - 1) * dmu $$ (i, k - 1) +\n           dmu $$ (i, k) * d_of dmu (k - 1)) div\n          d_of dmu k symmod\n          (p * d_of dmu'' (k - 1) * d_of dmu'' k)\n     else if j = k\n          then (d_of dmu (Suc k) * dmu $$ (i, k - 1) -\n                dmu $$ (k, k - 1) * dmu $$ (i, k)) div\n               d_of dmu k symmod\n               (p * d_of dmu'' k * d_of dmu'' (Suc k))\n          else dmu $$ (i, j)) =\n    mat m m\n     (\\<lambda>(i, j).\n         if j < i \\<and> (j = k \\<or> j = k - 1)\n         then dmu'' $$ (i, j) symmod (p * d_of dmu'' j * d_of dmu'' (Suc j))\n         else dmu'' $$ (i, j)) $$\n    (i, j)", "using i j 4 k"], ["proof (prove)\nusing this:\n  i < m\n  j < i\n  k < i\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if j = k - 1\n     then (dmu $$ (k, k - 1) * dmu $$ (i, k - 1) +\n           dmu $$ (i, k) * d_of dmu (k - 1)) div\n          d_of dmu k symmod\n          (p * d_of dmu'' (k - 1) * d_of dmu'' k)\n     else if j = k\n          then (d_of dmu (Suc k) * dmu $$ (i, k - 1) -\n                dmu $$ (k, k - 1) * dmu $$ (i, k)) div\n               d_of dmu k symmod\n               (p * d_of dmu'' k * d_of dmu'' (Suc k))\n          else dmu $$ (i, j)) =\n    mat m m\n     (\\<lambda>(i, j).\n         if j < i \\<and> (j = k \\<or> j = k - 1)\n         then dmu'' $$ (i, j) symmod (p * d_of dmu'' j * d_of dmu'' (Suc j))\n         else dmu'' $$ (i, j)) $$\n    (i, j)", "by (auto intro!: arg_cong[of _ _ \"\\<lambda> x. x symmod _\"], auto simp: dmu''_def)"], ["proof (state)\nthis:\n  (if j = k - 1\n   then (dmu $$ (k, k - 1) *\n         IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! (k - 1) +\n         IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! k *\n         d_of dmu (k - 1)) div\n        d_of dmu k symmod\n        mod1\n   else if j = k\n        then (d_of dmu (Suc k) *\n              IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! (k - 1) -\n              dmu $$ (k, k - 1) *\n              IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! k) div\n             d_of dmu k symmod\n             modk\n        else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j) =\n  dmu' $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if i < k - 1 then dmui !! i\n   else if k < i\n        then IArray.of_fun\n              (\\<lambda>j.\n                  if j = k - 1\n                  then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                        dmui !! i !! k * d_of dmu (k - 1)) div\n                       d_of dmu k symmod\n                       mod1\n                  else if j = k\n                       then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                             dmu $$ (k, k - 1) * dmui !! i !! k) div\n                            d_of dmu k symmod\n                            modk\n                       else dmui !! i !! j)\n              i\n        else if i = k\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                       else dmui !! (k - 1) !! j)\n                   i\n             else IArray.of_fun ((!!) (dmui !! k)) i) =\n  IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if i < k - 1 then dmui !! i\n   else if k < i\n        then IArray.of_fun\n              (\\<lambda>j.\n                  if j = k - 1\n                  then (dmu $$ (k, k - 1) * dmui !! i !! (k - 1) +\n                        dmui !! i !! k * d_of dmu (k - 1)) div\n                       d_of dmu k symmod\n                       mod1\n                  else if j = k\n                       then (d_of dmu (Suc k) * dmui !! i !! (k - 1) -\n                             dmu $$ (k, k - 1) * dmui !! i !! k) div\n                            d_of dmu k symmod\n                            modk\n                       else dmui !! i !! j)\n              i\n        else if i = k\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = k - 1 then dmu $$ (k, k - 1) symmod mod1\n                       else dmui !! (k - 1) !! j)\n                   i\n             else IArray.of_fun ((!!) (dmui !! k)) i) =\n  IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dmui' =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i) m\n\ngoal (1 subgoal):\n 1. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "show \"mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "unfolding mods' di' dk' mod1 modk"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>jj.\n         if jj = k - 1 then p * d_of dmu'' (k - 1) * d_of dmu'' k\n         else if jj = k then p * d_of dmu'' k * d_of dmu'' (Suc k)\n              else mods !! jj)\n     (m - 1) =\n    IArray.of_fun\n     (\\<lambda>j.\n         p *\n         IArray.of_fun\n          (\\<lambda>ii. if ii = k then d_of dmu'' k else di !! ii)\n          (Suc m) !!\n         j *\n         IArray.of_fun\n          (\\<lambda>ii. if ii = k then d_of dmu'' k else di !! ii)\n          (Suc m) !!\n         Suc j)\n     (m - 1)", "proof (intro iarray_cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m - 1 \\<Longrightarrow>\n       (if i = k - 1 then p * d_of dmu'' (k - 1) * d_of dmu'' k\n        else if i = k then p * d_of dmu'' k * d_of dmu'' (Suc k)\n             else mods !! i) =\n       p *\n       IArray.of_fun\n        (\\<lambda>ii. if ii = k then d_of dmu'' k else di !! ii) (Suc m) !!\n       i *\n       IArray.of_fun\n        (\\<lambda>ii. if ii = k then d_of dmu'' k else di !! ii) (Suc m) !!\n       Suc i", "case (1 j)"], ["proof (state)\nthis:\n  j < m - 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m - 1 \\<Longrightarrow>\n       (if i = k - 1 then p * d_of dmu'' (k - 1) * d_of dmu'' k\n        else if i = k then p * d_of dmu'' k * d_of dmu'' (Suc k)\n             else mods !! i) =\n       p *\n       IArray.of_fun\n        (\\<lambda>ii. if ii = k then d_of dmu'' k else di !! ii) (Suc m) !!\n       i *\n       IArray.of_fun\n        (\\<lambda>ii. if ii = k then d_of dmu'' k else di !! ii) (Suc m) !!\n       Suc i", "hence j: \"j < Suc m\" \"Suc j < Suc m\""], ["proof (prove)\nusing this:\n  j < m - 1\n\ngoal (1 subgoal):\n 1. j < Suc m &&& Suc j < Suc m", "by auto"], ["proof (state)\nthis:\n  j < Suc m\n  Suc j < Suc m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m - 1 \\<Longrightarrow>\n       (if i = k - 1 then p * d_of dmu'' (k - 1) * d_of dmu'' k\n        else if i = k then p * d_of dmu'' k * d_of dmu'' (Suc k)\n             else mods !! i) =\n       p *\n       IArray.of_fun\n        (\\<lambda>ii. if ii = k then d_of dmu'' k else di !! ii) (Suc m) !!\n       i *\n       IArray.of_fun\n        (\\<lambda>ii. if ii = k then d_of dmu'' k else di !! ii) (Suc m) !!\n       Suc i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j = k - 1 then p * d_of dmu'' (k - 1) * d_of dmu'' k\n     else if j = k then p * d_of dmu'' k * d_of dmu'' (Suc k)\n          else mods !! j) =\n    p *\n    IArray.of_fun (\\<lambda>ii. if ii = k then d_of dmu'' k else di !! ii)\n     (Suc m) !!\n    j *\n    IArray.of_fun (\\<lambda>ii. if ii = k then d_of dmu'' k else di !! ii)\n     (Suc m) !!\n    Suc j", "unfolding  \n        IArray.of_fun_nth[OF 1]\n        IArray.of_fun_nth[OF j(1)]\n        IArray.of_fun_nth[OF j(2)] id(4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j = k - 1 then p * d_of dmu'' (k - 1) * d_of dmu'' k\n     else if j = k then p * d_of dmu'' k * d_of dmu'' (Suc k)\n          else p * di !! j * di !! Suc j) =\n    p * (if j = k then d_of dmu'' k else di !! j) *\n    (if Suc j = k then d_of dmu'' k else di !! Suc j)", "using k di dk1 dkS1"], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n  ?i2 \\<le> m \\<Longrightarrow> di !! ?i2 = d_of dmu ?i2\n  d_of dmu (k - 1) = d_of dmu'' (k - 1)\n  d_of dmu (Suc k) = d_of dmu'' (Suc k)\n\ngoal (1 subgoal):\n 1. (if j = k - 1 then p * d_of dmu'' (k - 1) * d_of dmu'' k\n     else if j = k then p * d_of dmu'' k * d_of dmu'' (Suc k)\n          else p * di !! j * di !! Suc j) =\n    p * (if j = k then d_of dmu'' k else di !! j) *\n    (if Suc j = k then d_of dmu'' k else di !! Suc j)", "by auto"], ["proof (state)\nthis:\n  (if j = k - 1 then p * d_of dmu'' (k - 1) * d_of dmu'' k\n   else if j = k then p * d_of dmu'' k * d_of dmu'' (Suc k)\n        else mods !! j) =\n  p *\n  IArray.of_fun (\\<lambda>ii. if ii = k then d_of dmu'' k else di !! ii)\n   (Suc m) !!\n  j *\n  IArray.of_fun (\\<lambda>ii. if ii = k then d_of dmu'' k else di !! ii)\n   (Suc m) !!\n  Suc j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_impl_inv p mfs' dmu' state'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_add_row: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod_weak fs mfs dmu p first b\" \n  and res: \"basis_reduction_mod_add_row p mfs dmu i j = (mfs', dmu')\" \n  and res': \"LLL_add_row p state i j = state'\" \n  and i: \"i < m\"\n  and j: \"j < i\"\nshows \"state_impl_inv p mfs' dmu' state'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "note inv = LLL_invD_modw[OF Linv]"], ["proof (state)\nthis:\n  length mfs = m\n  length fs = m\n  lattice_of fs = L\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  map (map_vec (\\<lambda>x. x symmod p)) fs = mfs\n  \\<forall>i'<m.\n     \\<forall>j'<i'.\n        \\<bar>d\\<mu> fs i' j'\\<bar> < p * d fs j' * d fs (Suc j')\n  \\<forall>i'<m. \\<forall>j'<m. d\\<mu> fs i' j' = dmu $$ (i', j')\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  ?i < m \\<Longrightarrow> mfs ! ?i \\<in> carrier_vec n\n  set mfs \\<subseteq> carrier_vec n\n  1 < p\n  g_bnd_mode first b fs\n  mod_invariant b p first\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "obtain fsi dmui di mods where state: \"state = (fsi, dmui, di, mods)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fsi dmui di mods.\n        state = (fsi, dmui, di, mods) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases state, auto)"], ["proof (state)\nthis:\n  state = (fsi, dmui, di, mods)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "obtain fsi' dmui' di' mods' where state': \"state' = (fsi', dmui', di', mods')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fsi' dmui' di' mods'.\n        state' = (fsi', dmui', di', mods') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases state', auto)"], ["proof (state)\nthis:\n  state' = (fsi', dmui', di', mods')\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "from impl[unfolded state, simplified]"], ["proof (chain)\npicking this:\n  fsi = mfs \\<and>\n  di = IArray.of_fun (d_of dmu) (Suc m) \\<and>\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n   m \\<and>\n  mods =\n  IArray.of_fun\n   (\\<lambda>j. p * IArray.list_of di ! j * IArray.list_of di ! Suc j)\n   (m - Suc 0)", "have id: \"fsi = mfs\" \n    \"di = IArray.of_fun (d_of dmu) (Suc m)\" \n    \"dmui = IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m\"\n    \"mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)\""], ["proof (prove)\nusing this:\n  fsi = mfs \\<and>\n  di = IArray.of_fun (d_of dmu) (Suc m) \\<and>\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n   m \\<and>\n  mods =\n  IArray.of_fun\n   (\\<lambda>j. p * IArray.list_of di ! j * IArray.list_of di ! Suc j)\n   (m - Suc 0)\n\ngoal (1 subgoal):\n 1. (fsi = mfs &&& di = IArray.of_fun (d_of dmu) (Suc m)) &&&\n    dmui =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n     m &&&\n    mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)", "by auto"], ["proof (state)\nthis:\n  fsi = mfs\n  di = IArray.of_fun (d_of dmu) (Suc m)\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "let ?c = \"round_num_denom (dmu $$ (i, j)) (d_of dmu (Suc j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "let ?c' = \"round_num_denom (dmui !! i !! j) (di !! Suc j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "obtain c where c: \"?c = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        round_num_denom (dmu $$ (i, j)) (d_of dmu (Suc j)) =\n        c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  round_num_denom (dmu $$ (i, j)) (d_of dmu (Suc j)) = c\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "have c': \"?c' = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. round_num_denom (dmui !! i !! j) (di !! Suc j) = c", "unfolding id c[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. round_num_denom\n     (IArray.of_fun\n       (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n      i !!\n      j)\n     (IArray.of_fun (d_of dmu) (Suc m) !! Suc j) =\n    round_num_denom (dmu $$ (i, j)) (d_of dmu (Suc j))", "using i j"], ["proof (prove)\nusing this:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. round_num_denom\n     (IArray.of_fun\n       (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m !!\n      i !!\n      j)\n     (IArray.of_fun (d_of dmu) (Suc m) !! Suc j) =\n    round_num_denom (dmu $$ (i, j)) (d_of dmu (Suc j))", "by (subst (1 2) IArray.of_fun_nth, (force+)[2],\n      subst IArray.of_fun_nth, force+)"], ["proof (state)\nthis:\n  round_num_denom (dmui !! i !! j) (di !! Suc j) = c\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "have drop: \"drop i fsi = mfs ! i # drop (Suc i) mfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop i fsi = mfs ! i # drop (Suc i) mfs", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop i mfs = mfs ! i # drop (Suc i) mfs", "using \\<open>length mfs = m\\<close> i"], ["proof (prove)\nusing this:\n  length mfs = m\n  i < m\n\ngoal (1 subgoal):\n 1. drop i mfs = mfs ! i # drop (Suc i) mfs", "by (metis Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  drop i fsi = mfs ! i # drop (Suc i) mfs\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "note res = res[unfolded basis_reduction_mod_add_row_def Let_def c, symmetric]"], ["proof (state)\nthis:\n  (mfs', dmu') =\n  (if c = 0 then (mfs, dmu)\n   else (mfs[i := map_vec (\\<lambda>x. x symmod p)\n                   (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j)],\n         mat m m\n          (\\<lambda>(i', j').\n              if i' = i \\<and> j' \\<le> j\n              then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n                   else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                        (p * d_of dmu j' * d_of dmu (Suc j'))\n              else dmu $$ (i', j'))))\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "note res' = res'[unfolded state state' split LLL_add_row_def Let_def c', symmetric]"], ["proof (state)\nthis:\n  (fsi', dmui', di', mods') =\n  (if c = 0 then (fsi, dmui, di, mods)\n   else perform_add_row p (fsi, dmui, di, mods) i j c (dmui !! i)\n         (dmui !! i !! j) (di !! Suc j))\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "proof (cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from res[unfolded True] res'[unfolded True]"], ["proof (chain)\npicking this:\n  (mfs', dmu') =\n  (if 0 = 0 then (mfs, dmu)\n   else (mfs[i := map_vec (\\<lambda>x. x symmod p)\n                   (mfs ! i - 0 \\<cdot>\\<^sub>v mfs ! j)],\n         mat m m\n          (\\<lambda>(i', j').\n              if i' = i \\<and> j' \\<le> j\n              then if j' = j then dmu $$ (i, j') - 0 * dmu $$ (j, j')\n                   else (dmu $$ (i, j') - 0 * dmu $$ (j, j')) symmod\n                        (p * d_of dmu j' * d_of dmu (Suc j'))\n              else dmu $$ (i', j'))))\n  (fsi', dmui', di', mods') =\n  (if 0 = 0 then (fsi, dmui, di, mods)\n   else perform_add_row p (fsi, dmui, di, mods) i j 0 (dmui !! i)\n         (dmui !! i !! j) (di !! Suc j))", "show ?thesis"], ["proof (prove)\nusing this:\n  (mfs', dmu') =\n  (if 0 = 0 then (mfs, dmu)\n   else (mfs[i := map_vec (\\<lambda>x. x symmod p)\n                   (mfs ! i - 0 \\<cdot>\\<^sub>v mfs ! j)],\n         mat m m\n          (\\<lambda>(i', j').\n              if i' = i \\<and> j' \\<le> j\n              then if j' = j then dmu $$ (i, j') - 0 * dmu $$ (j, j')\n                   else (dmu $$ (i, j') - 0 * dmu $$ (j, j')) symmod\n                        (p * d_of dmu j' * d_of dmu (Suc j'))\n              else dmu $$ (i', j'))))\n  (fsi', dmui', di', mods') =\n  (if 0 = 0 then (fsi, dmui, di, mods)\n   else perform_add_row p (fsi, dmui, di, mods) i j 0 (dmui !! i)\n         (dmui !! i !! j) (di !! Suc j))\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "unfolding state'"], ["proof (prove)\nusing this:\n  (mfs', dmu') =\n  (if 0 = 0 then (mfs, dmu)\n   else (mfs[i := map_vec (\\<lambda>x. x symmod p)\n                   (mfs ! i - 0 \\<cdot>\\<^sub>v mfs ! j)],\n         mat m m\n          (\\<lambda>(i', j').\n              if i' = i \\<and> j' \\<le> j\n              then if j' = j then dmu $$ (i, j') - 0 * dmu $$ (j, j')\n                   else (dmu $$ (i, j') - 0 * dmu $$ (j, j')) symmod\n                        (p * d_of dmu j' * d_of dmu (Suc j'))\n              else dmu $$ (i', j'))))\n  (fsi', dmui', di', mods') =\n  (if 0 = 0 then (fsi, dmui, di, mods)\n   else perform_add_row p (fsi, dmui, di, mods) i j 0 (dmui !! i)\n         (dmui !! i !! j) (di !! Suc j))\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' (fsi', dmui', di', mods')", "using id"], ["proof (prove)\nusing this:\n  (mfs', dmu') =\n  (if 0 = 0 then (mfs, dmu)\n   else (mfs[i := map_vec (\\<lambda>x. x symmod p)\n                   (mfs ! i - 0 \\<cdot>\\<^sub>v mfs ! j)],\n         mat m m\n          (\\<lambda>(i', j').\n              if i' = i \\<and> j' \\<le> j\n              then if j' = j then dmu $$ (i, j') - 0 * dmu $$ (j, j')\n                   else (dmu $$ (i, j') - 0 * dmu $$ (j, j')) symmod\n                        (p * d_of dmu j' * d_of dmu (Suc j'))\n              else dmu $$ (i', j'))))\n  (fsi', dmui', di', mods') =\n  (if 0 = 0 then (fsi, dmui, di, mods)\n   else perform_add_row p (fsi, dmui, di, mods) i j 0 (dmui !! i)\n         (dmui !! i !! j) (di !! Suc j))\n  fsi = mfs\n  di = IArray.of_fun (d_of dmu) (Suc m)\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' (fsi', dmui', di', mods')", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p mfs' dmu' state'\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "hence False: \"(c = 0) = False\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (c = 0) = False", "by simp"], ["proof (state)\nthis:\n  (c = 0) = False\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note res = res[unfolded Let_def False if_False]"], ["proof (state)\nthis:\n  (mfs', dmu') =\n  (mfs[i := map_vec (\\<lambda>x. x symmod p)\n             (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j)],\n   mat m m\n    (\\<lambda>(i', j').\n        if i' = i \\<and> j' \\<le> j\n        then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n             else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                  (p * d_of dmu j' * d_of dmu (Suc j'))\n        else dmu $$ (i', j')))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from res"], ["proof (chain)\npicking this:\n  (mfs', dmu') =\n  (mfs[i := map_vec (\\<lambda>x. x symmod p)\n             (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j)],\n   mat m m\n    (\\<lambda>(i', j').\n        if i' = i \\<and> j' \\<le> j\n        then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n             else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                  (p * d_of dmu j' * d_of dmu (Suc j'))\n        else dmu $$ (i', j')))", "have mfs': \"mfs' = mfs[i := map_vec (\\<lambda>x. x symmod p) (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j)]\""], ["proof (prove)\nusing this:\n  (mfs', dmu') =\n  (mfs[i := map_vec (\\<lambda>x. x symmod p)\n             (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j)],\n   mat m m\n    (\\<lambda>(i', j').\n        if i' = i \\<and> j' \\<le> j\n        then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n             else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                  (p * d_of dmu j' * d_of dmu (Suc j'))\n        else dmu $$ (i', j')))\n\ngoal (1 subgoal):\n 1. mfs' = mfs\n    [i := map_vec (\\<lambda>x. x symmod p)\n           (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j)]", "by auto"], ["proof (state)\nthis:\n  mfs' = mfs\n  [i := map_vec (\\<lambda>x. x symmod p)\n         (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j)]\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from res"], ["proof (chain)\npicking this:\n  (mfs', dmu') =\n  (mfs[i := map_vec (\\<lambda>x. x symmod p)\n             (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j)],\n   mat m m\n    (\\<lambda>(i', j').\n        if i' = i \\<and> j' \\<le> j\n        then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n             else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                  (p * d_of dmu j' * d_of dmu (Suc j'))\n        else dmu $$ (i', j')))", "have dmu': \"dmu' = mat m m (\\<lambda>(i', j').\n        if i' = i \\<and> j' \\<le> j\n        then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n             else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod (p * d_of dmu j' * d_of dmu (Suc j'))\n        else dmu $$ (i', j'))\""], ["proof (prove)\nusing this:\n  (mfs', dmu') =\n  (mfs[i := map_vec (\\<lambda>x. x symmod p)\n             (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j)],\n   mat m m\n    (\\<lambda>(i', j').\n        if i' = i \\<and> j' \\<le> j\n        then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n             else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                  (p * d_of dmu j' * d_of dmu (Suc j'))\n        else dmu $$ (i', j')))\n\ngoal (1 subgoal):\n 1. dmu' =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j'))", "by auto"], ["proof (state)\nthis:\n  dmu' =\n  mat m m\n   (\\<lambda>(i', j').\n       if i' = i \\<and> j' \\<le> j\n       then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n            else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                 (p * d_of dmu j' * d_of dmu (Suc j'))\n       else dmu $$ (i', j'))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note res' = res'[unfolded Let_def False if_False perform_add_row_def drop list.simps split_at_def split]"], ["proof (state)\nthis:\n  (fsi', dmui', di', mods') =\n  (take i fsi @\n   vec n (\\<lambda>k. (mfs ! i $ k - c * fsi ! j $ k) symmod p) #\n   drop (Suc i) mfs,\n   IArray.of_fun\n    (\\<lambda>ii.\n        if i = ii\n        then IArray.of_fun\n              (\\<lambda>jj.\n                  if jj < j\n                  then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                       mods !! jj\n                  else if jj = j then dmui !! i !! j - c * di !! Suc j\n                       else dmui !! i !! jj)\n              i\n        else dmui !! ii)\n    m,\n   di, mods)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from res'"], ["proof (chain)\npicking this:\n  (fsi', dmui', di', mods') =\n  (take i fsi @\n   vec n (\\<lambda>k. (mfs ! i $ k - c * fsi ! j $ k) symmod p) #\n   drop (Suc i) mfs,\n   IArray.of_fun\n    (\\<lambda>ii.\n        if i = ii\n        then IArray.of_fun\n              (\\<lambda>jj.\n                  if jj < j\n                  then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                       mods !! jj\n                  else if jj = j then dmui !! i !! j - c * di !! Suc j\n                       else dmui !! i !! jj)\n              i\n        else dmui !! ii)\n    m,\n   di, mods)", "have fsi': \"fsi' = take i fsi @ vec n (\\<lambda>k. (mfs ! i $ k - c * mfs ! j $ k) symmod p) # drop (Suc i) mfs\""], ["proof (prove)\nusing this:\n  (fsi', dmui', di', mods') =\n  (take i fsi @\n   vec n (\\<lambda>k. (mfs ! i $ k - c * fsi ! j $ k) symmod p) #\n   drop (Suc i) mfs,\n   IArray.of_fun\n    (\\<lambda>ii.\n        if i = ii\n        then IArray.of_fun\n              (\\<lambda>jj.\n                  if jj < j\n                  then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                       mods !! jj\n                  else if jj = j then dmui !! i !! j - c * di !! Suc j\n                       else dmui !! i !! jj)\n              i\n        else dmui !! ii)\n    m,\n   di, mods)\n\ngoal (1 subgoal):\n 1. fsi' =\n    take i fsi @\n    vec n (\\<lambda>k. (mfs ! i $ k - c * mfs ! j $ k) symmod p) #\n    drop (Suc i) mfs", "by (auto simp: id)"], ["proof (state)\nthis:\n  fsi' =\n  take i fsi @\n  vec n (\\<lambda>k. (mfs ! i $ k - c * mfs ! j $ k) symmod p) #\n  drop (Suc i) mfs\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from res'"], ["proof (chain)\npicking this:\n  (fsi', dmui', di', mods') =\n  (take i fsi @\n   vec n (\\<lambda>k. (mfs ! i $ k - c * fsi ! j $ k) symmod p) #\n   drop (Suc i) mfs,\n   IArray.of_fun\n    (\\<lambda>ii.\n        if i = ii\n        then IArray.of_fun\n              (\\<lambda>jj.\n                  if jj < j\n                  then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                       mods !! jj\n                  else if jj = j then dmui !! i !! j - c * di !! Suc j\n                       else dmui !! i !! jj)\n              i\n        else dmui !! ii)\n    m,\n   di, mods)", "have di': \"di' = di\" and mods': \"mods' = mods\""], ["proof (prove)\nusing this:\n  (fsi', dmui', di', mods') =\n  (take i fsi @\n   vec n (\\<lambda>k. (mfs ! i $ k - c * fsi ! j $ k) symmod p) #\n   drop (Suc i) mfs,\n   IArray.of_fun\n    (\\<lambda>ii.\n        if i = ii\n        then IArray.of_fun\n              (\\<lambda>jj.\n                  if jj < j\n                  then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                       mods !! jj\n                  else if jj = j then dmui !! i !! j - c * di !! Suc j\n                       else dmui !! i !! jj)\n              i\n        else dmui !! ii)\n    m,\n   di, mods)\n\ngoal (1 subgoal):\n 1. di' = di &&& mods' = mods", "by auto"], ["proof (state)\nthis:\n  di' = di\n  mods' = mods\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from res'"], ["proof (chain)\npicking this:\n  (fsi', dmui', di', mods') =\n  (take i fsi @\n   vec n (\\<lambda>k. (mfs ! i $ k - c * fsi ! j $ k) symmod p) #\n   drop (Suc i) mfs,\n   IArray.of_fun\n    (\\<lambda>ii.\n        if i = ii\n        then IArray.of_fun\n              (\\<lambda>jj.\n                  if jj < j\n                  then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                       mods !! jj\n                  else if jj = j then dmui !! i !! j - c * di !! Suc j\n                       else dmui !! i !! jj)\n              i\n        else dmui !! ii)\n    m,\n   di, mods)", "have dmui': \"dmui' = IArray.of_fun (\\<lambda>ii. if i = ii\n          then IArray.of_fun\n                (\\<lambda>jj. if jj < j then (dmui !! i !! jj - c * dmui !! j !! jj) symmod (mods !! jj)\n                      else if jj = j then dmui !! i !! j - c * di !! (Suc j) else dmui !! i !! jj)\n                i\n          else dmui !! ii) m\""], ["proof (prove)\nusing this:\n  (fsi', dmui', di', mods') =\n  (take i fsi @\n   vec n (\\<lambda>k. (mfs ! i $ k - c * fsi ! j $ k) symmod p) #\n   drop (Suc i) mfs,\n   IArray.of_fun\n    (\\<lambda>ii.\n        if i = ii\n        then IArray.of_fun\n              (\\<lambda>jj.\n                  if jj < j\n                  then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                       mods !! jj\n                  else if jj = j then dmui !! i !! j - c * di !! Suc j\n                       else dmui !! i !! jj)\n              i\n        else dmui !! ii)\n    m,\n   di, mods)\n\ngoal (1 subgoal):\n 1. dmui' =\n    IArray.of_fun\n     (\\<lambda>ii.\n         if i = ii\n         then IArray.of_fun\n               (\\<lambda>jj.\n                   if jj < j\n                   then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                        mods !! jj\n                   else if jj = j then dmui !! i !! j - c * di !! Suc j\n                        else dmui !! i !! jj)\n               i\n         else dmui !! ii)\n     m", "by auto"], ["proof (state)\nthis:\n  dmui' =\n  IArray.of_fun\n   (\\<lambda>ii.\n       if i = ii\n       then IArray.of_fun\n             (\\<lambda>jj.\n                 if jj < j\n                 then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                      mods !! jj\n                 else if jj = j then dmui !! i !! j - c * di !! Suc j\n                      else dmui !! i !! jj)\n             i\n       else dmui !! ii)\n   m\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "unfolding state' state_impl_inv.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. fsi' = mfs' \\<and>\n    di' = IArray.of_fun (d_of dmu') (Suc m) \\<and>\n    dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m \\<and>\n    mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "proof (intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. fsi' = mfs'\n 2. di' = IArray.of_fun (d_of dmu') (Suc m)\n 3. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m\n 4. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "from inv(11) i j"], ["proof (chain)\npicking this:\n  ?i < m \\<Longrightarrow> mfs ! ?i \\<in> carrier_vec n\n  i < m\n  j < i", "have vec: \"mfs ! i \\<in> carrier_vec n\" \"mfs ! j \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  ?i < m \\<Longrightarrow> mfs ! ?i \\<in> carrier_vec n\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. mfs ! i \\<in> carrier_vec n &&& mfs ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  mfs ! i \\<in> carrier_vec n\n  mfs ! j \\<in> carrier_vec n\n\ngoal (4 subgoals):\n 1. fsi' = mfs'\n 2. di' = IArray.of_fun (d_of dmu') (Suc m)\n 3. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m\n 4. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "hence id': \"map_vec (\\<lambda>x. x symmod p) (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j) = vec n (\\<lambda>k. (mfs ! i $ k - c * mfs ! j $ k) symmod p)\""], ["proof (prove)\nusing this:\n  mfs ! i \\<in> carrier_vec n\n  mfs ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. map_vec (\\<lambda>x. x symmod p) (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j) =\n    vec n (\\<lambda>k. (mfs ! i $ k - c * mfs ! j $ k) symmod p)", "by (intro eq_vecI, auto)"], ["proof (state)\nthis:\n  map_vec (\\<lambda>x. x symmod p) (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j) =\n  vec n (\\<lambda>k. (mfs ! i $ k - c * mfs ! j $ k) symmod p)\n\ngoal (4 subgoals):\n 1. fsi' = mfs'\n 2. di' = IArray.of_fun (d_of dmu') (Suc m)\n 3. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m\n 4. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "show \"mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "using id"], ["proof (prove)\nusing this:\n  fsi = mfs\n  di = IArray.of_fun (d_of dmu) (Suc m)\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)\n\ngoal (1 subgoal):\n 1. mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)", "unfolding mods' di'"], ["proof (prove)\nusing this:\n  fsi = mfs\n  di = IArray.of_fun (d_of dmu) (Suc m)\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)\n\ngoal (1 subgoal):\n 1. mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)", "by auto"], ["proof (state)\nthis:\n  mods' = IArray.of_fun (\\<lambda>j. p * di' !! j * di' !! Suc j) (m - 1)\n\ngoal (3 subgoals):\n 1. fsi' = mfs'\n 2. di' = IArray.of_fun (d_of dmu') (Suc m)\n 3. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m", "show \"fsi' = mfs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fsi' = mfs'", "unfolding fsi' mfs' id"], ["proof (prove)\ngoal (1 subgoal):\n 1. take i mfs @\n    vec n (\\<lambda>k. (mfs ! i $ k - c * mfs ! j $ k) symmod p) #\n    drop (Suc i) mfs =\n    mfs[i := map_vec (\\<lambda>x. x symmod p)\n              (mfs ! i - c \\<cdot>\\<^sub>v mfs ! j)]", "unfolding id'"], ["proof (prove)\ngoal (1 subgoal):\n 1. take i mfs @\n    vec n (\\<lambda>k. (mfs ! i $ k - c * mfs ! j $ k) symmod p) #\n    drop (Suc i) mfs =\n    mfs[i := vec n (\\<lambda>k. (mfs ! i $ k - c * mfs ! j $ k) symmod p)]", "using \\<open>length mfs = m\\<close> i"], ["proof (prove)\nusing this:\n  length mfs = m\n  i < m\n\ngoal (1 subgoal):\n 1. take i mfs @\n    vec n (\\<lambda>k. (mfs ! i $ k - c * mfs ! j $ k) symmod p) #\n    drop (Suc i) mfs =\n    mfs[i := vec n (\\<lambda>k. (mfs ! i $ k - c * mfs ! j $ k) symmod p)]", "by (simp add: upd_conv_take_nth_drop)"], ["proof (state)\nthis:\n  fsi' = mfs'\n\ngoal (2 subgoals):\n 1. di' = IArray.of_fun (d_of dmu') (Suc m)\n 2. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m", "show \"di' = IArray.of_fun (d_of dmu') (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. di' = IArray.of_fun (d_of dmu') (Suc m)", "unfolding dmu' di' id d_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. if i = 0 then 1 else dmu $$ (i - 1, i - 1))\n     (Suc m) =\n    IArray.of_fun\n     (\\<lambda>ia.\n         if ia = 0 then 1\n         else mat m m\n               (\\<lambda>(i', j').\n                   if i' = i \\<and> j' \\<le> j\n                   then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n                        else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                             (p *\n                              (if j' = 0 then 1\n                               else dmu $$ (j' - 1, j' - 1)) *\n                              (if Suc j' = 0 then 1\n                               else dmu $$ (Suc j' - 1, Suc j' - 1)))\n                   else dmu $$ (i', j')) $$\n              (ia - 1, ia - 1))\n     (Suc m)", "by (intro iarray_cong if_cong refl, insert i j, auto)"], ["proof (state)\nthis:\n  di' = IArray.of_fun (d_of dmu') (Suc m)\n\ngoal (1 subgoal):\n 1. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m", "show \"dmui' = IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dmui' =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m", "unfolding dmui'"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>ii.\n         if i = ii\n         then IArray.of_fun\n               (\\<lambda>jj.\n                   if jj < j\n                   then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                        mods !! jj\n                   else if jj = j then dmui !! i !! j - c * di !! Suc j\n                        else dmui !! i !! jj)\n               i\n         else dmui !! ii)\n     m =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m", "proof (intro iarray_cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < m \\<Longrightarrow>\n       (if i = ia\n        then IArray.of_fun\n              (\\<lambda>jj.\n                  if jj < j\n                  then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                       mods !! jj\n                  else if jj = j then dmui !! i !! j - c * di !! Suc j\n                       else dmui !! i !! jj)\n              i\n        else dmui !! ia) =\n       IArray.of_fun (\\<lambda>j. dmu' $$ (ia, j)) ia", "fix ii"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < m \\<Longrightarrow>\n       (if i = ia\n        then IArray.of_fun\n              (\\<lambda>jj.\n                  if jj < j\n                  then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                       mods !! jj\n                  else if jj = j then dmui !! i !! j - c * di !! Suc j\n                       else dmui !! i !! jj)\n              i\n        else dmui !! ia) =\n       IArray.of_fun (\\<lambda>j. dmu' $$ (ia, j)) ia", "assume ii: \"ii < m\""], ["proof (state)\nthis:\n  ii < m\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < m \\<Longrightarrow>\n       (if i = ia\n        then IArray.of_fun\n              (\\<lambda>jj.\n                  if jj < j\n                  then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                       mods !! jj\n                  else if jj = j then dmui !! i !! j - c * di !! Suc j\n                       else dmui !! i !! jj)\n              i\n        else dmui !! ia) =\n       IArray.of_fun (\\<lambda>j. dmu' $$ (ia, j)) ia", "show \"(if i = ii\n           then IArray.of_fun\n                 (\\<lambda>jj. if jj < j then (dmui !! i !! jj - c * dmui !! j !! jj) symmod (mods !! jj)\n                       else if jj = j then dmui !! i !! j - c * di !! (Suc j) else dmui !! i !! jj)\n                 i\n           else dmui !! ii) =\n          IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii", "proof (cases \"i = ii\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = ii \\<Longrightarrow>\n    (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii\n 2. i \\<noteq> ii \\<Longrightarrow>\n    (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii", "case False"], ["proof (state)\nthis:\n  i \\<noteq> ii\n\ngoal (2 subgoals):\n 1. i = ii \\<Longrightarrow>\n    (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii\n 2. i \\<noteq> ii \\<Longrightarrow>\n    (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii", "hence *: \"(i = ii) = False\""], ["proof (prove)\nusing this:\n  i \\<noteq> ii\n\ngoal (1 subgoal):\n 1. (i = ii) = False", "by auto"], ["proof (state)\nthis:\n  (i = ii) = False\n\ngoal (2 subgoals):\n 1. i = ii \\<Longrightarrow>\n    (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii\n 2. i \\<noteq> ii \\<Longrightarrow>\n    (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii", "unfolding * if_False id dmu'"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n     m !!\n    ii =\n    IArray.of_fun\n     (\\<lambda>ja.\n         mat m m\n          (\\<lambda>(i', j').\n              if i' = i \\<and> j' \\<le> j\n              then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n                   else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                        (p * d_of dmu j' * d_of dmu (Suc j'))\n              else dmu $$ (i', j')) $$\n         (ii, ja))\n     ii", "using False i j ii"], ["proof (prove)\nusing this:\n  i \\<noteq> ii\n  i < m\n  j < i\n  ii < m\n\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n     m !!\n    ii =\n    IArray.of_fun\n     (\\<lambda>ja.\n         mat m m\n          (\\<lambda>(i', j').\n              if i' = i \\<and> j' \\<le> j\n              then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n                   else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                        (p * d_of dmu j' * d_of dmu (Suc j'))\n              else dmu $$ (i', j')) $$\n         (ii, ja))\n     ii", "unfolding IArray.of_fun_nth[OF ii]"], ["proof (prove)\nusing this:\n  i \\<noteq> ii\n  i < m\n  j < i\n  ii < m\n\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>j. dmu $$ (ii, j)) ii =\n    IArray.of_fun\n     (\\<lambda>ja.\n         mat m m\n          (\\<lambda>(i', j').\n              if i' = i \\<and> j' \\<le> j\n              then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n                   else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                        (p * d_of dmu j' * d_of dmu (Suc j'))\n              else dmu $$ (i', j')) $$\n         (ii, ja))\n     ii", "by (intro iarray_cong refl, auto)"], ["proof (state)\nthis:\n  (if i = ii\n   then IArray.of_fun\n         (\\<lambda>jj.\n             if jj < j\n             then (dmui !! i !! jj - c * dmui !! j !! jj) symmod mods !! jj\n             else if jj = j then dmui !! i !! j - c * di !! Suc j\n                  else dmui !! i !! jj)\n         i\n   else dmui !! ii) =\n  IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii\n\ngoal (1 subgoal):\n 1. i = ii \\<Longrightarrow>\n    (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = ii \\<Longrightarrow>\n    (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii", "case True"], ["proof (state)\nthis:\n  i = ii\n\ngoal (1 subgoal):\n 1. i = ii \\<Longrightarrow>\n    (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii", "hence *: \"(i = ii) = True\""], ["proof (prove)\nusing this:\n  i = ii\n\ngoal (1 subgoal):\n 1. (i = ii) = True", "by auto"], ["proof (state)\nthis:\n  (i = ii) = True\n\ngoal (1 subgoal):\n 1. i = ii \\<Longrightarrow>\n    (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii", "from i j"], ["proof (chain)\npicking this:\n  i < m\n  j < i", "have \"j < m\""], ["proof (prove)\nusing this:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. j < m", "by simp"], ["proof (state)\nthis:\n  j < m\n\ngoal (1 subgoal):\n 1. i = ii \\<Longrightarrow>\n    (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = ii\n     then IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j\n               then (dmui !! i !! jj - c * dmui !! j !! jj) symmod\n                    mods !! jj\n               else if jj = j then dmui !! i !! j - c * di !! Suc j\n                    else dmui !! i !! jj)\n           i\n     else dmui !! ii) =\n    IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii", "unfolding * if_True dmu' id IArray.of_fun_nth[OF i] IArray.of_fun_nth[OF \\<open>j < m\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>jj.\n         if jj < j\n         then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n               c *\n               IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n              IArray.of_fun\n               (\\<lambda>j.\n                   p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n                   IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n               (m - 1) !!\n              jj\n         else if jj = j\n              then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n                   c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n              else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj)\n     i =\n    IArray.of_fun\n     (\\<lambda>ja.\n         mat m m\n          (\\<lambda>(i', j').\n              if i' = i \\<and> j' \\<le> j\n              then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n                   else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                        (p * d_of dmu j' * d_of dmu (Suc j'))\n              else dmu $$ (i', j')) $$\n         (ii, ja))\n     ii", "unfolding True[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>jj.\n         if jj < j\n         then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n               c *\n               IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n              IArray.of_fun\n               (\\<lambda>j.\n                   p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n                   IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n               (m - 1) !!\n              jj\n         else if jj = j\n              then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n                   c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n              else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj)\n     i =\n    IArray.of_fun\n     (\\<lambda>ja.\n         mat m m\n          (\\<lambda>(i', j').\n              if i' = i \\<and> j' \\<le> j\n              then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n                   else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                        (p * d_of dmu j' * d_of dmu (Suc j'))\n              else dmu $$ (i', j')) $$\n         (i, ja))\n     i", "proof (intro iarray_cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < i \\<Longrightarrow>\n       (if ia < j\n        then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! ia -\n              c *\n              IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! ia) symmod\n             IArray.of_fun\n              (\\<lambda>j.\n                  p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n                  IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n              (m - 1) !!\n             ia\n        else if ia = j\n             then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n                  c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n             else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! ia) =\n       mat m m\n        (\\<lambda>(i', j').\n            if i' = i \\<and> j' \\<le> j\n            then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n                 else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                      (p * d_of dmu j' * d_of dmu (Suc j'))\n            else dmu $$ (i', j')) $$\n       (i, ia)", "case jj: (1 jj)"], ["proof (state)\nthis:\n  jj < i\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < i \\<Longrightarrow>\n       (if ia < j\n        then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! ia -\n              c *\n              IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! ia) symmod\n             IArray.of_fun\n              (\\<lambda>j.\n                  p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n                  IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n              (m - 1) !!\n             ia\n        else if ia = j\n             then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n                  c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n             else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! ia) =\n       mat m m\n        (\\<lambda>(i', j').\n            if i' = i \\<and> j' \\<le> j\n            then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n                 else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                      (p * d_of dmu j' * d_of dmu (Suc j'))\n            else dmu $$ (i', j')) $$\n       (i, ia)", "consider (1) \"jj < j\" | (2) \"jj = j\" | (3) \"jj > j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>jj < j \\<Longrightarrow> thesis;\n     jj = j \\<Longrightarrow> thesis;\n     j < jj \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>jj < j \\<Longrightarrow> ?thesis2;\n   jj = j \\<Longrightarrow> ?thesis2;\n   j < jj \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < i \\<Longrightarrow>\n       (if ia < j\n        then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! ia -\n              c *\n              IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! ia) symmod\n             IArray.of_fun\n              (\\<lambda>j.\n                  p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n                  IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n              (m - 1) !!\n             ia\n        else if ia = j\n             then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n                  c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n             else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! ia) =\n       mat m m\n        (\\<lambda>(i', j').\n            if i' = i \\<and> j' \\<le> j\n            then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n                 else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                      (p * d_of dmu j' * d_of dmu (Suc j'))\n            else dmu $$ (i', j')) $$\n       (i, ia)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>jj < j \\<Longrightarrow> ?thesis2;\n   jj = j \\<Longrightarrow> ?thesis2;\n   j < jj \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (1 subgoal):\n 1. (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. jj < j \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)\n 2. jj = j \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)\n 3. j < jj \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "case 1"], ["proof (state)\nthis:\n  jj < j\n\ngoal (3 subgoals):\n 1. jj < j \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)\n 2. jj = j \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)\n 3. j < jj \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "thus ?thesis"], ["proof (prove)\nusing this:\n  jj < j\n\ngoal (1 subgoal):\n 1. (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "using jj i j"], ["proof (prove)\nusing this:\n  jj < j\n  jj < i\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "unfolding id(4)"], ["proof (prove)\nusing this:\n  jj < j\n  jj < i\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "by (subst (1 2 3 4 5 6) IArray.of_fun_nth, auto)"], ["proof (state)\nthis:\n  (if jj < j\n   then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n         c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n        IArray.of_fun\n         (\\<lambda>j.\n             p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n             IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n         (m - 1) !!\n        jj\n   else if jj = j\n        then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n             c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n        else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n  mat m m\n   (\\<lambda>(i', j').\n       if i' = i \\<and> j' \\<le> j\n       then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n            else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                 (p * d_of dmu j' * d_of dmu (Suc j'))\n       else dmu $$ (i', j')) $$\n  (i, jj)\n\ngoal (2 subgoals):\n 1. jj = j \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)\n 2. j < jj \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. jj = j \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)\n 2. j < jj \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "case 2"], ["proof (state)\nthis:\n  jj = j\n\ngoal (2 subgoals):\n 1. jj = j \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)\n 2. j < jj \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "thus ?thesis"], ["proof (prove)\nusing this:\n  jj = j\n\ngoal (1 subgoal):\n 1. (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "using jj i j"], ["proof (prove)\nusing this:\n  jj = j\n  jj < i\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "by (subst (5 6) IArray.of_fun_nth, auto simp: d_of_def)"], ["proof (state)\nthis:\n  (if jj < j\n   then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n         c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n        IArray.of_fun\n         (\\<lambda>j.\n             p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n             IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n         (m - 1) !!\n        jj\n   else if jj = j\n        then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n             c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n        else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n  mat m m\n   (\\<lambda>(i', j').\n       if i' = i \\<and> j' \\<le> j\n       then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n            else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                 (p * d_of dmu j' * d_of dmu (Suc j'))\n       else dmu $$ (i', j')) $$\n  (i, jj)\n\ngoal (1 subgoal):\n 1. j < jj \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j < jj \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "case 3"], ["proof (state)\nthis:\n  j < jj\n\ngoal (1 subgoal):\n 1. j < jj \\<Longrightarrow>\n    (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < jj\n\ngoal (1 subgoal):\n 1. (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "using jj i j"], ["proof (prove)\nusing this:\n  j < jj\n  jj < i\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. (if jj < j\n     then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n           c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n          IArray.of_fun\n           (\\<lambda>j.\n               p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n               IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n           (m - 1) !!\n          jj\n     else if jj = j\n          then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n               c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n          else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n    mat m m\n     (\\<lambda>(i', j').\n         if i' = i \\<and> j' \\<le> j\n         then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n              else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                   (p * d_of dmu j' * d_of dmu (Suc j'))\n         else dmu $$ (i', j')) $$\n    (i, jj)", "by (subst (7) IArray.of_fun_nth, auto simp: d_of_def)"], ["proof (state)\nthis:\n  (if jj < j\n   then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n         c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n        IArray.of_fun\n         (\\<lambda>j.\n             p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n             IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n         (m - 1) !!\n        jj\n   else if jj = j\n        then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n             c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n        else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n  mat m m\n   (\\<lambda>(i', j').\n       if i' = i \\<and> j' \\<le> j\n       then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n            else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                 (p * d_of dmu j' * d_of dmu (Suc j'))\n       else dmu $$ (i', j')) $$\n  (i, jj)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if jj < j\n   then (IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj -\n         c * IArray.of_fun (\\<lambda>ja. dmu $$ (j, ja)) j !! jj) symmod\n        IArray.of_fun\n         (\\<lambda>j.\n             p * IArray.of_fun (d_of dmu) (Suc m) !! j *\n             IArray.of_fun (d_of dmu) (Suc m) !! Suc j)\n         (m - 1) !!\n        jj\n   else if jj = j\n        then IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! j -\n             c * IArray.of_fun (d_of dmu) (Suc m) !! Suc j\n        else IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i !! jj) =\n  mat m m\n   (\\<lambda>(i', j').\n       if i' = i \\<and> j' \\<le> j\n       then if j' = j then dmu $$ (i, j') - c * dmu $$ (j, j')\n            else (dmu $$ (i, j') - c * dmu $$ (j, j')) symmod\n                 (p * d_of dmu j' * d_of dmu (Suc j'))\n       else dmu $$ (i', j')) $$\n  (i, jj)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if i = ii\n   then IArray.of_fun\n         (\\<lambda>jj.\n             if jj < j\n             then (dmui !! i !! jj - c * dmui !! j !! jj) symmod mods !! jj\n             else if jj = j then dmui !! i !! j - c * di !! Suc j\n                  else dmui !! i !! jj)\n         i\n   else dmui !! ii) =\n  IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if i = ii\n   then IArray.of_fun\n         (\\<lambda>jj.\n             if jj < j\n             then (dmui !! i !! jj - c * dmui !! j !! jj) symmod mods !! jj\n             else if jj = j then dmui !! i !! j - c * di !! Suc j\n                  else dmui !! i !! jj)\n         i\n   else dmui !! ii) =\n  IArray.of_fun (\\<lambda>j. dmu' $$ (ii, j)) ii\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dmui' =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_impl_inv p mfs' dmu' state'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_impl_inv p mfs' dmu' state'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_max_gso_norm_di: assumes di: \"di = IArray.of_fun (d_of dmu) (Suc m)\"\n  and m: \"m \\<noteq> 0\" \nshows \"LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "have di: \"j \\<le> m \\<Longrightarrow> di !! j = d_of dmu j\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> m \\<Longrightarrow> di !! j = d_of dmu j", "unfolding di"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> m \\<Longrightarrow>\n    IArray.of_fun (d_of dmu) (Suc m) !! j = d_of dmu j", "by (subst IArray.of_fun_nth, auto)"], ["proof (state)\nthis:\n  ?j2 \\<le> m \\<Longrightarrow> di !! ?j2 = d_of dmu ?j2\n\ngoal (1 subgoal):\n 1. LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "have id: \"(m = 0) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m = 0) = False", "using m"], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (m = 0) = False", "by auto"], ["proof (state)\nthis:\n  (m = 0) = False\n\ngoal (1 subgoal):\n 1. LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "proof (cases first)"], ["proof (state)\ngoal (2 subgoals):\n 1. first \\<Longrightarrow>\n    LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu\n 2. \\<not> first \\<Longrightarrow>\n    LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "case False"], ["proof (state)\nthis:\n  \\<not> first\n\ngoal (2 subgoals):\n 1. first \\<Longrightarrow>\n    LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu\n 2. \\<not> first \\<Longrightarrow>\n    LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "hence id': \"first = False\""], ["proof (prove)\nusing this:\n  \\<not> first\n\ngoal (1 subgoal):\n 1. first = False", "by auto"], ["proof (state)\nthis:\n  first = False\n\ngoal (2 subgoals):\n 1. first \\<Longrightarrow>\n    LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu\n 2. \\<not> first \\<Longrightarrow>\n    LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "unfolding LLL_max_gso_norm_di_def compute_max_gso_norm_def id id' if_False"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case max_list_rats_with_index\n           (map (\\<lambda>i. (di !! Suc i, di !! i, i)) [0..<m]) of\n     (num, denom, xa) \\<Rightarrow>\n       (rat_of_int num / rat_of_int denom, xa)) =\n    (case max_list_rats_with_index\n           (map (\\<lambda>i. (d_of dmu (Suc i), d_of dmu i, i)) [0..<m]) of\n     (num, denom, xa) \\<Rightarrow> (rat_of_int num / rat_of_int denom, xa))", "by (intro if_cong refl arg_cong[of _ _ \"\\<lambda> xs. case max_list_rats_with_index xs of (num, denom, i) \\<Rightarrow> (rat_of_int num / rat_of_int denom, i)\"], \n          unfold map_eq_conv, intro ballI, subst (1 2) di, auto)"], ["proof (state)\nthis:\n  LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu\n\ngoal (1 subgoal):\n 1. first \\<Longrightarrow>\n    LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. first \\<Longrightarrow>\n    LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "case True"], ["proof (state)\nthis:\n  first\n\ngoal (1 subgoal):\n 1. first \\<Longrightarrow>\n    LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "hence id': \"first = True\""], ["proof (prove)\nusing this:\n  first\n\ngoal (1 subgoal):\n 1. first = True", "by auto"], ["proof (state)\nthis:\n  first = True\n\ngoal (1 subgoal):\n 1. first \\<Longrightarrow>\n    LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "unfolding LLL_max_gso_norm_di_def compute_max_gso_norm_def id id' if_False if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_int (di !! 1), 0) =\n    (case max_list_rats_with_index\n           (map (\\<lambda>i. (d_of dmu (Suc i), d_of dmu i, i)) [0..<1]) of\n     (num, denom, xa) \\<Rightarrow> (rat_of_int num / rat_of_int denom, xa))", "using m di[of 1]"], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n  1 \\<le> m \\<Longrightarrow> di !! 1 = d_of dmu 1\n\ngoal (1 subgoal):\n 1. (rat_of_int (di !! 1), 0) =\n    (case max_list_rats_with_index\n           (map (\\<lambda>i. (d_of dmu (Suc i), d_of dmu i, i)) [0..<1]) of\n     (num, denom, xa) \\<Rightarrow> (rat_of_int num / rat_of_int denom, xa))", "by (simp add: d_of_def)"], ["proof (state)\nthis:\n  LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_max_gso_quot: assumes di: \"di = IArray.of_fun (d_of dmu) (Suc m)\"\n  and prods: \"state_iso_inv di_prods di\" \nshows \"LLL_max_gso_quot di_prods = compute_max_gso_quot dmu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_max_gso_quot di_prods = compute_max_gso_quot dmu", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_max_gso_quot di_prods = compute_max_gso_quot dmu", "have di: \"j \\<le> m \\<Longrightarrow> di !! j = d_of dmu j\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> m \\<Longrightarrow> di !! j = d_of dmu j", "unfolding di"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> m \\<Longrightarrow>\n    IArray.of_fun (d_of dmu) (Suc m) !! j = d_of dmu j", "by (subst IArray.of_fun_nth, auto)"], ["proof (state)\nthis:\n  ?j2 \\<le> m \\<Longrightarrow> di !! ?j2 = d_of dmu ?j2\n\ngoal (1 subgoal):\n 1. LLL_max_gso_quot di_prods = compute_max_gso_quot dmu", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_max_gso_quot di_prods = compute_max_gso_quot dmu", "unfolding LLL_max_gso_quot_def compute_max_gso_quot_def prods[unfolded state_iso_inv_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_list_rats_with_index\n     (map (\\<lambda>i.\n              case IArray.of_fun\n                    (\\<lambda>i.\n                        (di !! (i + 1) * di !! (i + 1),\n                         di !! (i + 2) * di !! i))\n                    (m - 1) !!\n                   i of\n              (l, r) \\<Rightarrow> (l, r, Suc i))\n       [0..<m - 1]) =\n    max_list_rats_with_index\n     (map (\\<lambda>i.\n              (d_of dmu (i + 1) * d_of dmu (i + 1),\n               d_of dmu (i + 2) * d_of dmu i, Suc i))\n       [0..<m - 1])", "by (intro if_cong refl arg_cong[of _ _ max_list_rats_with_index], unfold map_eq_conv Let_def, intro ballI,\n     subst IArray.of_fun_nth, force, unfold split,\n     subst (1 2 3 4) di, auto)"], ["proof (state)\nthis:\n  LLL_max_gso_quot di_prods = compute_max_gso_quot dmu\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_max_gso_norm: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and m: \"m \\<noteq> 0\" \nshows \"LLL_max_gso_norm first state = compute_max_gso_norm first dmu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_max_gso_norm first state = compute_max_gso_norm first dmu", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_max_gso_norm first state = compute_max_gso_norm first dmu", "obtain mfsi dmui di mods where state: \"state = (mfsi, dmui, di,mods)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfsi dmui di mods.\n        state = (mfsi, dmui, di, mods) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  state = (mfsi, dmui, di, mods)\n\ngoal (1 subgoal):\n 1. LLL_max_gso_norm first state = compute_max_gso_norm first dmu", "from impl[unfolded state state_impl_inv.simps]"], ["proof (chain)\npicking this:\n  mfsi = mfs \\<and>\n  di = IArray.of_fun (d_of dmu) (Suc m) \\<and>\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n   m \\<and>\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)", "have di: \"di = IArray.of_fun (d_of dmu) (Suc m)\""], ["proof (prove)\nusing this:\n  mfsi = mfs \\<and>\n  di = IArray.of_fun (d_of dmu) (Suc m) \\<and>\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n   m \\<and>\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)\n\ngoal (1 subgoal):\n 1. di = IArray.of_fun (d_of dmu) (Suc m)", "by auto"], ["proof (state)\nthis:\n  di = IArray.of_fun (d_of dmu) (Suc m)\n\ngoal (1 subgoal):\n 1. LLL_max_gso_norm first state = compute_max_gso_norm first dmu", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_max_gso_norm first state = compute_max_gso_norm first dmu", "using LLL_max_gso_norm_di[OF di m]"], ["proof (prove)\nusing this:\n  LLL_max_gso_norm_di ?first di = compute_max_gso_norm ?first dmu\n\ngoal (1 subgoal):\n 1. LLL_max_gso_norm first state = compute_max_gso_norm first dmu", "unfolding LLL_max_gso_norm_def state split"], ["proof (prove)\nusing this:\n  LLL_max_gso_norm_di ?first di = compute_max_gso_norm ?first dmu\n\ngoal (1 subgoal):\n 1. LLL_max_gso_norm_di first di = compute_max_gso_norm first dmu", "."], ["proof (state)\nthis:\n  LLL_max_gso_norm first state = compute_max_gso_norm first dmu\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_of_gso_norm: \"m \\<noteq> 0 \\<Longrightarrow> mod_of_gso_norm first mn =\n  compute_mod_of_max_gso_norm first mn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    mod_of_gso_norm first mn = compute_mod_of_max_gso_norm first mn", "unfolding mod_of_gso_norm_def compute_mod_of_max_gso_norm_def bound_number_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    log_base ^\n    log_ceiling log_base\n     (max 2\n       (root_rat_ceiling 2 (mn * rat_of_nat (if first then 4 else m + 3)) +\n        1)) =\n    log_base ^\n    log_ceiling log_base\n     (max 2\n       (root_rat_ceiling 2\n         (mn *\n          (rat_of_nat (if first \\<and> m \\<noteq> 0 then 1 else m) + 3)) +\n        1))", "by auto"], ["", "lemma LLL_adjust_mod: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and res: \"basis_reduction_adjust_mod p first mfs dmu = (p', mfs', dmu', g_idx)\" \n  and res': \"LLL_adjust_mod p first state = (p'', state', g_idx')\" \n  and m: \"m \\<noteq> 0\" \nshows \"state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "from LLL_max_gso_norm[OF impl m]"], ["proof (chain)\npicking this:\n  LLL_max_gso_norm ?first state = compute_max_gso_norm ?first dmu", "have id: \"LLL_max_gso_norm first state = compute_max_gso_norm first dmu\""], ["proof (prove)\nusing this:\n  LLL_max_gso_norm ?first state = compute_max_gso_norm ?first dmu\n\ngoal (1 subgoal):\n 1. LLL_max_gso_norm first state = compute_max_gso_norm first dmu", "by auto"], ["proof (state)\nthis:\n  LLL_max_gso_norm first state = compute_max_gso_norm first dmu\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "obtain b gi where norm: \"compute_max_gso_norm first dmu = (b, gi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b gi.\n        compute_max_gso_norm first dmu = (b, gi) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  compute_max_gso_norm first dmu = (b, gi)\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "obtain P where P: \"compute_mod_of_max_gso_norm first b = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        compute_mod_of_max_gso_norm first b = P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  compute_mod_of_max_gso_norm first b = P\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "note res = res[unfolded basis_reduction_adjust_mod.simps Let_def P norm split]"], ["proof (state)\nthis:\n  (if P < p\n   then (P, map (map_vec (\\<lambda>x. x symmod P)) mfs,\n         mat m m\n          (\\<lambda>(i, j).\n              if j < i\n              then dmu $$ (i, j) symmod\n                   (P * vec (Suc m) (d_of dmu) $ j *\n                    vec (Suc m) (d_of dmu) $ Suc j)\n              else dmu $$ (i, j)),\n         gi)\n   else (p, mfs, dmu, gi)) =\n  (p', mfs', dmu', g_idx)\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "note res' = res'[unfolded LLL_adjust_mod_def id Let_def P norm split mod_of_gso_norm[OF m]]"], ["proof (state)\nthis:\n  (if P < p then (P, perform_adjust_mod P state, gi) else (p, state, gi)) =\n  (p'', state', g_idx')\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "proof (cases \"P < p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx\n 2. \\<not> P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "case False"], ["proof (state)\nthis:\n  \\<not> P < p\n\ngoal (2 subgoals):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx\n 2. \\<not> P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> P < p\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "using res res' impl"], ["proof (prove)\nusing this:\n  \\<not> P < p\n  (if P < p\n   then (P, map (map_vec (\\<lambda>x. x symmod P)) mfs,\n         mat m m\n          (\\<lambda>(i, j).\n              if j < i\n              then dmu $$ (i, j) symmod\n                   (P * vec (Suc m) (d_of dmu) $ j *\n                    vec (Suc m) (d_of dmu) $ Suc j)\n              else dmu $$ (i, j)),\n         gi)\n   else (p, mfs, dmu, gi)) =\n  (p', mfs', dmu', g_idx)\n  (if P < p then (P, perform_adjust_mod P state, gi) else (p, state, gi)) =\n  (p'', state', g_idx')\n  state_impl_inv p mfs dmu state\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx\n\ngoal (1 subgoal):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "case True"], ["proof (state)\nthis:\n  P < p\n\ngoal (1 subgoal):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "hence id: \"(P < p) = True\""], ["proof (prove)\nusing this:\n  P < p\n\ngoal (1 subgoal):\n 1. (P < p) = True", "by auto"], ["proof (state)\nthis:\n  (P < p) = True\n\ngoal (1 subgoal):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "obtain fsi dmui di mods where state: \"state = (fsi, dmui, di, mods)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fsi dmui di mods.\n        state = (fsi, dmui, di, mods) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  state = (fsi, dmui, di, mods)\n\ngoal (1 subgoal):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "from impl[unfolded state state_impl_inv.simps]"], ["proof (chain)\npicking this:\n  fsi = mfs \\<and>\n  di = IArray.of_fun (d_of dmu) (Suc m) \\<and>\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n   m \\<and>\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)", "have impl: \"fsi = mfs\" \"di = IArray.of_fun (d_of dmu) (Suc m)\" \"dmui = IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m\""], ["proof (prove)\nusing this:\n  fsi = mfs \\<and>\n  di = IArray.of_fun (d_of dmu) (Suc m) \\<and>\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n   m \\<and>\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)\n\ngoal (1 subgoal):\n 1. fsi = mfs &&&\n    di = IArray.of_fun (d_of dmu) (Suc m) &&&\n    dmui =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n     m", "by auto"], ["proof (state)\nthis:\n  fsi = mfs\n  di = IArray.of_fun (d_of dmu) (Suc m)\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i) m\n\ngoal (1 subgoal):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "note res = res[unfolded id if_True]"], ["proof (state)\nthis:\n  (P, map (map_vec (\\<lambda>x. x symmod P)) mfs,\n   mat m m\n    (\\<lambda>(i, j).\n        if j < i\n        then dmu $$ (i, j) symmod\n             (P * vec (Suc m) (d_of dmu) $ j *\n              vec (Suc m) (d_of dmu) $ Suc j)\n        else dmu $$ (i, j)),\n   gi) =\n  (p', mfs', dmu', g_idx)\n\ngoal (1 subgoal):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "from res"], ["proof (chain)\npicking this:\n  (P, map (map_vec (\\<lambda>x. x symmod P)) mfs,\n   mat m m\n    (\\<lambda>(i, j).\n        if j < i\n        then dmu $$ (i, j) symmod\n             (P * vec (Suc m) (d_of dmu) $ j *\n              vec (Suc m) (d_of dmu) $ Suc j)\n        else dmu $$ (i, j)),\n   gi) =\n  (p', mfs', dmu', g_idx)", "have mfs': \"mfs' = map (map_vec (\\<lambda>x. x symmod P)) mfs\" \n       and p': \"p' = P\" \n       and dmu': \"dmu' = mat m m (\\<lambda>(i, j). if j < i then dmu $$ (i, j) symmod (P * vec (Suc m) (d_of dmu) $ j * vec (Suc m) (d_of dmu) $ Suc j) else dmu $$ (i, j))\" \n       and gidx: \"g_idx = gi\""], ["proof (prove)\nusing this:\n  (P, map (map_vec (\\<lambda>x. x symmod P)) mfs,\n   mat m m\n    (\\<lambda>(i, j).\n        if j < i\n        then dmu $$ (i, j) symmod\n             (P * vec (Suc m) (d_of dmu) $ j *\n              vec (Suc m) (d_of dmu) $ Suc j)\n        else dmu $$ (i, j)),\n   gi) =\n  (p', mfs', dmu', g_idx)\n\ngoal (1 subgoal):\n 1. (mfs' = map (map_vec (\\<lambda>x. x symmod P)) mfs &&& p' = P) &&&\n    dmu' =\n    mat m m\n     (\\<lambda>(i, j).\n         if j < i\n         then dmu $$ (i, j) symmod\n              (P * vec (Suc m) (d_of dmu) $ j *\n               vec (Suc m) (d_of dmu) $ Suc j)\n         else dmu $$ (i, j)) &&&\n    g_idx = gi", "by auto"], ["proof (state)\nthis:\n  mfs' = map (map_vec (\\<lambda>x. x symmod P)) mfs\n  p' = P\n  dmu' =\n  mat m m\n   (\\<lambda>(i, j).\n       if j < i\n       then dmu $$ (i, j) symmod\n            (P * vec (Suc m) (d_of dmu) $ j *\n             vec (Suc m) (d_of dmu) $ Suc j)\n       else dmu $$ (i, j))\n  g_idx = gi\n\ngoal (1 subgoal):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "let ?mods = \"IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "let ?dmu = \"IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmui !! i !! j symmod ?mods !! j) i) m\""], ["proof (state)\ngoal (1 subgoal):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "note res' = res'[unfolded id if_True state split impl(1) perform_adjust_mod_def Let_def]"], ["proof (state)\nthis:\n  (P, (map (map_vec (\\<lambda>x. x symmod P)) mfs,\n       IArray.of_fun\n        (\\<lambda>i.\n            IArray.of_fun\n             (\\<lambda>j.\n                 dmui !! i !! j symmod\n                 IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n                  (m - 1) !!\n                 j)\n             i)\n        m,\n       di, IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1)),\n   gi) =\n  (p'', state', g_idx')\n\ngoal (1 subgoal):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "from res'"], ["proof (chain)\npicking this:\n  (P, (map (map_vec (\\<lambda>x. x symmod P)) mfs,\n       IArray.of_fun\n        (\\<lambda>i.\n            IArray.of_fun\n             (\\<lambda>j.\n                 dmui !! i !! j symmod\n                 IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n                  (m - 1) !!\n                 j)\n             i)\n        m,\n       di, IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1)),\n   gi) =\n  (p'', state', g_idx')", "have p'': \"p'' = P\" and state': \"state' = (map (map_vec (\\<lambda>x. x symmod P)) mfs, ?dmu, di, ?mods)\" \n       and gidx': \"g_idx' = gi\""], ["proof (prove)\nusing this:\n  (P, (map (map_vec (\\<lambda>x. x symmod P)) mfs,\n       IArray.of_fun\n        (\\<lambda>i.\n            IArray.of_fun\n             (\\<lambda>j.\n                 dmui !! i !! j symmod\n                 IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n                  (m - 1) !!\n                 j)\n             i)\n        m,\n       di, IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1)),\n   gi) =\n  (p'', state', g_idx')\n\ngoal (1 subgoal):\n 1. p'' = P &&&\n    state' =\n    (map (map_vec (\\<lambda>x. x symmod P)) mfs,\n     IArray.of_fun\n      (\\<lambda>i.\n          IArray.of_fun\n           (\\<lambda>j.\n               dmui !! i !! j symmod\n               IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n                (m - 1) !!\n               j)\n           i)\n      m,\n     di, IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1)) &&&\n    g_idx' = gi", "by auto"], ["proof (state)\nthis:\n  p'' = P\n  state' =\n  (map (map_vec (\\<lambda>x. x symmod P)) mfs,\n   IArray.of_fun\n    (\\<lambda>i.\n        IArray.of_fun\n         (\\<lambda>j.\n             dmui !! i !! j symmod\n             IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n              (m - 1) !!\n             j)\n         i)\n    m,\n   di, IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1))\n  g_idx' = gi\n\ngoal (1 subgoal):\n 1. P < p \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx", "unfolding state' state_impl_inv.simps mfs' p'' p' gidx gidx'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (map_vec (\\<lambda>x. x symmod P)) mfs =\n     map (map_vec (\\<lambda>x. x symmod P)) mfs \\<and>\n     di = IArray.of_fun (d_of dmu') (Suc m) \\<and>\n     IArray.of_fun\n      (\\<lambda>i.\n          IArray.of_fun\n           (\\<lambda>j.\n               dmui !! i !! j symmod\n               IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n                (m - 1) !!\n               j)\n           i)\n      m =\n     IArray.of_fun\n      (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i) m \\<and>\n     IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) =\n     IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1)) \\<and>\n    P = P \\<and> gi = gi", "proof (intro conjI refl)"], ["proof (state)\ngoal (2 subgoals):\n 1. di = IArray.of_fun (d_of dmu') (Suc m)\n 2. IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>j.\n              dmui !! i !! j symmod\n              IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n               (m - 1) !!\n              j)\n          i)\n     m =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m", "show \"di = IArray.of_fun (d_of dmu') (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. di = IArray.of_fun (d_of dmu') (Suc m)", "unfolding impl"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (d_of dmu) (Suc m) = IArray.of_fun (d_of dmu') (Suc m)", "by (intro iarray_cong refl, auto simp: dmu' d_of_def)"], ["proof (state)\nthis:\n  di = IArray.of_fun (d_of dmu') (Suc m)\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>j.\n              dmui !! i !! j symmod\n              IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n               (m - 1) !!\n              j)\n          i)\n     m =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m", "show \"?dmu = IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>j.\n              dmui !! i !! j symmod\n              IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n               (m - 1) !!\n              j)\n          i)\n     m =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i)\n     m", "proof (intro iarray_cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < m; ia < i\\<rbrakk>\n       \\<Longrightarrow> dmui !! i !! ia symmod\n                         IArray.of_fun\n                          (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) !!\n                         ia =\n                         dmu' $$ (i, ia)", "case (1 i j)"], ["proof (state)\nthis:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < m; ia < i\\<rbrakk>\n       \\<Longrightarrow> dmui !! i !! ia symmod\n                         IArray.of_fun\n                          (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) !!\n                         ia =\n                         dmu' $$ (i, ia)", "hence \"j < m\" \"Suc j < Suc m\" \"j < Suc m\" \"j < m - 1\""], ["proof (prove)\nusing this:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. (j < m &&& Suc j < Suc m) &&& j < Suc m &&& j < m - 1", "by auto"], ["proof (state)\nthis:\n  j < m\n  Suc j < Suc m\n  j < Suc m\n  j < m - 1\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < m; ia < i\\<rbrakk>\n       \\<Longrightarrow> dmui !! i !! ia symmod\n                         IArray.of_fun\n                          (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) !!\n                         ia =\n                         dmu' $$ (i, ia)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmui !! i !! j symmod\n    IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) !! j =\n    dmu' $$ (i, j)", "unfolding dmu' impl IArray.of_fun_nth[OF \\<open>i < m\\<close>] IArray.of_fun_nth[OF \\<open>j < i\\<close>]\n            IArray.of_fun_nth[OF \\<open>j < m\\<close>] IArray.of_fun_nth[OF \\<open>Suc j < Suc m\\<close>]\n            IArray.of_fun_nth[OF \\<open>j < Suc m\\<close>] IArray.of_fun_nth[OF \\<open>j < m - 1\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu $$ (i, j) symmod (P * d_of dmu j * d_of dmu (Suc j)) =\n    mat m m\n     (\\<lambda>(i, j).\n         if j < i\n         then dmu $$ (i, j) symmod\n              (P * vec (Suc m) (d_of dmu) $ j *\n               vec (Suc m) (d_of dmu) $ Suc j)\n         else dmu $$ (i, j)) $$\n    (i, j)", "using 1"], ["proof (prove)\nusing this:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. dmu $$ (i, j) symmod (P * d_of dmu j * d_of dmu (Suc j)) =\n    mat m m\n     (\\<lambda>(i, j).\n         if j < i\n         then dmu $$ (i, j) symmod\n              (P * vec (Suc m) (d_of dmu) $ j *\n               vec (Suc m) (d_of dmu) $ Suc j)\n         else dmu $$ (i, j)) $$\n    (i, j)", "by auto"], ["proof (state)\nthis:\n  dmui !! i !! j symmod\n  IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) !! j =\n  dmu' $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>i.\n       IArray.of_fun\n        (\\<lambda>j.\n            dmui !! i !! j symmod\n            IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) !!\n            j)\n        i)\n   m =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu' $$ (i, j)) i) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> g_idx' = g_idx\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_adjust_swap_add: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod_weak fs mfs dmu p first b\"\n  and res: \"basis_reduction_adjust_swap_add_step p first mfs dmu g_idx k = (p', mfs', dmu', g_idx')\" \n  and res': \"LLL_adjust_swap_add p first state g_idx k = (p'',state', G_idx')\" \n  and k: \"k < m\" and k0: \"k \\<noteq> 0\" \nshows \"state_impl_inv p' mfs' dmu' state'\" \"p'' = p'\" \"G_idx' = g_idx'\" \n  \"i \\<le> m \\<Longrightarrow> i \\<noteq> k \\<Longrightarrow> di_of state' !! i = di_of state !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' &&& p'' = p') &&&\n    G_idx' = g_idx' &&&\n    (\\<lbrakk>i \\<le> m; i \\<noteq> k\\<rbrakk>\n     \\<Longrightarrow> di_of state' !! i = di_of state !! i)", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "from k"], ["proof (chain)\npicking this:\n  k < m", "have m: \"m \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k < m\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "obtain mfsi dmui di mods where state: \"state = (mfsi, dmui, di, mods)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfsi dmui di mods.\n        state = (mfsi, dmui, di, mods) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  state = (mfsi, dmui, di, mods)\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "obtain state'' where add': \"LLL_add_row p state k (k - 1) = state''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>state''.\n        LLL_add_row p state k (k - 1) = state'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LLL_add_row p state k (k - 1) = state''\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "obtain mfs'' dmu'' where add: \"basis_reduction_mod_add_row p mfs dmu k (k - 1) = (mfs'', dmu'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfs'' dmu''.\n        basis_reduction_mod_add_row p mfs dmu k (k - 1) =\n        (mfs'', dmu'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  basis_reduction_mod_add_row p mfs dmu k (k - 1) = (mfs'', dmu'')\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "obtain mfs3 dmu3 where swap: \"basis_reduction_mod_swap p mfs'' dmu'' k = (mfs3, dmu3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfs3 dmu3.\n        basis_reduction_mod_swap p mfs'' dmu'' k =\n        (mfs3, dmu3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  basis_reduction_mod_swap p mfs'' dmu'' k = (mfs3, dmu3)\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "obtain state3 where swap': \"LLL_swap_row p state'' k = state3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>state3.\n        LLL_swap_row p state'' k = state3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LLL_swap_row p state'' k = state3\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "obtain mfsi2 dmui2 di2 mods2 where state2: \"state'' = (mfsi2, dmui2, di2, mods2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfsi2 dmui2 di2 mods2.\n        state'' = (mfsi2, dmui2, di2, mods2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases state'', auto)"], ["proof (state)\nthis:\n  state'' = (mfsi2, dmui2, di2, mods2)\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "obtain mfsi3 dmui3 di3 mods3 where state3: \"state3 = (mfsi3, dmui3, di3, mods3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfsi3 dmui3 di3 mods3.\n        state3 = (mfsi3, dmui3, di3, mods3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases state3, auto)"], ["proof (state)\nthis:\n  state3 = (mfsi3, dmui3, di3, mods3)\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "have \"length mfsi = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length mfsi = m", "using impl[unfolded state state_impl_inv.simps] LLL_invD_modw[OF Linv]"], ["proof (prove)\nusing this:\n  mfsi = mfs \\<and>\n  di = IArray.of_fun (d_of dmu) (Suc m) \\<and>\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n   m \\<and>\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)\n  length mfs = m\n  length fs = m\n  lattice_of fs = L\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  map (map_vec (\\<lambda>x. x symmod p)) fs = mfs\n  \\<forall>i'<m.\n     \\<forall>j'<i'.\n        \\<bar>d\\<mu> fs i' j'\\<bar> < p * d fs j' * d fs (Suc j')\n  \\<forall>i'<m. \\<forall>j'<m. d\\<mu> fs i' j' = dmu $$ (i', j')\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  ?i < m \\<Longrightarrow> mfs ! ?i \\<in> carrier_vec n\n  set mfs \\<subseteq> carrier_vec n\n  1 < p\n  g_bnd_mode first b fs\n  mod_invariant b p first\n\ngoal (1 subgoal):\n 1. length mfsi = m", "by auto"], ["proof (state)\nthis:\n  length mfsi = m\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "note res' = res'[unfolded state LLL_adjust_swap_add_def LLL_swap_add_eq[OF k0 k this], folded state, unfolded add' swap' Let_def]"], ["proof (state)\nthis:\n  (if k - 1 = g_idx then LLL_adjust_mod p first state3\n   else (p, state3, g_idx)) =\n  (p'', state', G_idx')\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "note res = res[unfolded basis_reduction_adjust_swap_add_step_def Let_def add split swap]"], ["proof (state)\nthis:\n  (if k - 1 = g_idx then basis_reduction_adjust_mod p first mfs3 dmu3\n   else (p, mfs3, dmu3, g_idx)) =\n  (p', mfs', dmu', g_idx')\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "from LLL_add_row[OF impl Linv add add' k] k0"], ["proof (chain)\npicking this:\n  k - 1 < k \\<Longrightarrow> state_impl_inv p mfs'' dmu'' state''\n  k \\<noteq> 0", "have impl': \"state_impl_inv p mfs'' dmu'' state''\""], ["proof (prove)\nusing this:\n  k - 1 < k \\<Longrightarrow> state_impl_inv p mfs'' dmu'' state''\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs'' dmu'' state''", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p mfs'' dmu'' state''\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "from basis_reduction_mod_add_row[OF Linv add k _ k0] k0"], ["proof (chain)\npicking this:\n  k - 1 < k \\<Longrightarrow>\n  \\<exists>fs'.\n     LLL_invariant_mod_weak fs' mfs'' dmu'' p first b \\<and>\n     LLL_measure k fs' = LLL_measure k fs \\<and>\n     (\\<mu>_small_row k fs (Suc (k - 1)) \\<longrightarrow>\n      \\<mu>_small_row k fs' (k - 1)) \\<and>\n     \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') k\n            (k - 1)\\<bar>\n     \\<le> 1 / 2 \\<and>\n     (\\<forall>i' j'.\n         i' < k \\<longrightarrow>\n         j' \\<le> i' \\<longrightarrow>\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i' j' =\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i' j') \\<and>\n     (LLL_invariant_mod fs mfs dmu p first b k \\<longrightarrow>\n      LLL_invariant_mod fs' mfs'' dmu'' p first b k) \\<and>\n     (\\<forall>ii\\<le>m. d fs' ii = d fs ii)\n  k \\<noteq> 0", "obtain fs'' where Linv': \"LLL_invariant_mod_weak fs'' mfs'' dmu'' p first b\""], ["proof (prove)\nusing this:\n  k - 1 < k \\<Longrightarrow>\n  \\<exists>fs'.\n     LLL_invariant_mod_weak fs' mfs'' dmu'' p first b \\<and>\n     LLL_measure k fs' = LLL_measure k fs \\<and>\n     (\\<mu>_small_row k fs (Suc (k - 1)) \\<longrightarrow>\n      \\<mu>_small_row k fs' (k - 1)) \\<and>\n     \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') k\n            (k - 1)\\<bar>\n     \\<le> 1 / 2 \\<and>\n     (\\<forall>i' j'.\n         i' < k \\<longrightarrow>\n         j' \\<le> i' \\<longrightarrow>\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i' j' =\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i' j') \\<and>\n     (LLL_invariant_mod fs mfs dmu p first b k \\<longrightarrow>\n      LLL_invariant_mod fs' mfs'' dmu'' p first b k) \\<and>\n     (\\<forall>ii\\<le>m. d fs' ii = d fs ii)\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>fs''.\n        LLL_invariant_mod_weak fs'' mfs'' dmu'' p first b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_invariant_mod_weak fs'' mfs'' dmu'' p first b\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "from LLL_swap_row[OF impl' Linv' swap swap' k k0]"], ["proof (chain)\npicking this:\n  state_impl_inv p mfs3 dmu3 state3", "have impl3: \"state_impl_inv p mfs3 dmu3 state3\""], ["proof (prove)\nusing this:\n  state_impl_inv p mfs3 dmu3 state3\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs3 dmu3 state3", "."], ["proof (state)\nthis:\n  state_impl_inv p mfs3 dmu3 state3\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "have di2: \"di2 = di\""], ["proof (prove)\ngoal (1 subgoal):\n 1. di2 = di", "using add'[unfolded state LLL_add_row_def Let_def split perform_add_row_def state2]"], ["proof (prove)\nusing this:\n  (if round_num_denom (dmui !! k !! (k - 1)) (di !! Suc (k - 1)) = 0\n   then (mfsi, dmui, di, mods)\n   else (case split_at k mfsi of\n         (start, fsi # end) \\<Rightarrow>\n           start @\n           vec n\n            (\\<lambda>ka.\n                (fsi $ ka -\n                 round_num_denom (dmui !! k !! (k - 1))\n                  (di !! Suc (k - 1)) *\n                 mfsi ! (k - 1) $ ka) symmod\n                p) #\n           end,\n         IArray.of_fun\n          (\\<lambda>ii.\n              if k = ii\n              then IArray.of_fun\n                    (\\<lambda>jj.\n                        if jj < k - 1\n                        then (dmui !! k !! jj -\n                              round_num_denom (dmui !! k !! (k - 1))\n                               (di !! Suc (k - 1)) *\n                              dmui !! (k - 1) !! jj) symmod\n                             mods !! jj\n                        else if jj = k - 1\n                             then dmui !! k !! (k - 1) -\n                                  round_num_denom (dmui !! k !! (k - 1))\n                                   (di !! Suc (k - 1)) *\n                                  di !! Suc (k - 1)\n                             else dmui !! k !! jj)\n                    k\n              else dmui !! ii)\n          m,\n         di, mods)) =\n  (mfsi2, dmui2, di2, mods2)\n\ngoal (1 subgoal):\n 1. di2 = di", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  di2 = di\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "have di3: \"di3 = IArray.of_fun (\\<lambda>i. if i = k then (di2 !! Suc k * di2 !! (k - 1) + dmui2 !! k !! (k - 1) * dmui2 !! k !! (k - 1)) div di2 !! k else di2 !! i) (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. di3 =\n    IArray.of_fun\n     (\\<lambda>i.\n         if i = k\n         then (di2 !! Suc k * di2 !! (k - 1) +\n               dmui2 !! k !! (k - 1) * dmui2 !! k !! (k - 1)) div\n              di2 !! k\n         else di2 !! i)\n     (Suc m)", "using swap'[unfolded state2 state3]"], ["proof (prove)\nusing this:\n  LLL_swap_row p (mfsi2, dmui2, di2, mods2) k = (mfsi3, dmui3, di3, mods3)\n\ngoal (1 subgoal):\n 1. di3 =\n    IArray.of_fun\n     (\\<lambda>i.\n         if i = k\n         then (di2 !! Suc k * di2 !! (k - 1) +\n               dmui2 !! k !! (k - 1) * dmui2 !! k !! (k - 1)) div\n              di2 !! k\n         else di2 !! i)\n     (Suc m)", "unfolding LLL_swap_row_def Let_def"], ["proof (prove)\nusing this:\n  (case (mfsi2, dmui2, di2, mods2) of\n   (mfsi, dmui, di, mods) \\<Rightarrow>\n     (case split_at (k - 1) mfsi of\n      (start, fsk1 # fsk # end) \\<Rightarrow> start @ fsk # fsk1 # end,\n      IArray.of_fun\n       (\\<lambda>i.\n           if i < k - 1 then dmui !! i\n           else if k < i\n                then IArray.of_fun\n                      (\\<lambda>j.\n                          if j = k - 1\n                          then (dmui !! k !! (k - 1) *\n                                dmui !! i !! (k - 1) +\n                                dmui !! i !! k * di !! (k - 1)) div\n                               di !! k symmod\n                               (p * di !! (k - 1) *\n                                ((di !! Suc k * di !! (k - 1) +\n                                  dmui !! k !! (k - 1) *\n                                  dmui !! k !! (k - 1)) div\n                                 di !! k))\n                          else if j = k\n                               then (di !! Suc k * dmui !! i !! (k - 1) -\n                                     dmui !! k !! (k - 1) *\n                                     dmui !! i !! k) div\n                                    di !! k symmod\n                                    (p *\n                                     ((di !! Suc k * di !! (k - 1) +\n dmui !! k !! (k - 1) * dmui !! k !! (k - 1)) div\ndi !! k) *\n                                     di !! Suc k)\n                               else dmui !! i !! j)\n                      i\n                else if i = k\n                     then IArray.of_fun\n                           (\\<lambda>j.\n                               if j = k - 1\n                               then dmui !! k !! (k - 1) symmod\n                                    (p * di !! (k - 1) *\n                                     ((di !! Suc k * di !! (k - 1) +\n dmui !! k !! (k - 1) * dmui !! k !! (k - 1)) div\ndi !! k))\n                               else dmui !! (k - 1) !! j)\n                           i\n                     else IArray.of_fun ((!!) (dmui !! k)) i)\n       m,\n      IArray.of_fun\n       (\\<lambda>i.\n           if i = k\n           then (di !! Suc k * di !! (k - 1) +\n                 dmui !! k !! (k - 1) * dmui !! k !! (k - 1)) div\n                di !! k\n           else di !! i)\n       (Suc m),\n      IArray.of_fun\n       (\\<lambda>j.\n           if j = k - 1\n           then p * di !! (k - 1) *\n                ((di !! Suc k * di !! (k - 1) +\n                  dmui !! k !! (k - 1) * dmui !! k !! (k - 1)) div\n                 di !! k)\n           else if j = k\n                then p *\n                     ((di !! Suc k * di !! (k - 1) +\n                       dmui !! k !! (k - 1) * dmui !! k !! (k - 1)) div\n                      di !! k) *\n                     di !! Suc k\n                else mods !! j)\n       (m - 1))) =\n  (mfsi3, dmui3, di3, mods3)\n\ngoal (1 subgoal):\n 1. di3 =\n    IArray.of_fun\n     (\\<lambda>i.\n         if i = k\n         then (di2 !! Suc k * di2 !! (k - 1) +\n               dmui2 !! k !! (k - 1) * dmui2 !! k !! (k - 1)) div\n              di2 !! k\n         else di2 !! i)\n     (Suc m)", "by simp"], ["proof (state)\nthis:\n  di3 =\n  IArray.of_fun\n   (\\<lambda>i.\n       if i = k\n       then (di2 !! Suc k * di2 !! (k - 1) +\n             dmui2 !! k !! (k - 1) * dmui2 !! k !! (k - 1)) div\n            di2 !! k\n       else di2 !! i)\n   (Suc m)\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "have di3: \"i \\<le> m \\<Longrightarrow> i \\<noteq> k \\<Longrightarrow> di3 !! i = di !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> m; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> di3 !! i = di !! i", "unfolding di2[symmetric] di3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> m; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> IArray.of_fun\n                       (\\<lambda>i.\n                           if i = k\n                           then (di2 !! Suc k * di2 !! (k - 1) +\n                                 dmui2 !! k !! (k - 1) *\n                                 dmui2 !! k !! (k - 1)) div\n                                di2 !! k\n                           else di2 !! i)\n                       (Suc m) !!\n                      i =\n                      di2 !! i", "by (subst IArray.of_fun_nth, auto)"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> m; i \\<noteq> k\\<rbrakk>\n  \\<Longrightarrow> di3 !! i = di !! i\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "proof (cases \"k - 1 = g_idx\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k - 1 = g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)\n 2. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "case True"], ["proof (state)\nthis:\n  k - 1 = g_idx\n\ngoal (2 subgoals):\n 1. k - 1 = g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)\n 2. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "hence id: \"(k - 1 = g_idx) = True\""], ["proof (prove)\nusing this:\n  k - 1 = g_idx\n\ngoal (1 subgoal):\n 1. (k - 1 = g_idx) = True", "by simp"], ["proof (state)\nthis:\n  (k - 1 = g_idx) = True\n\ngoal (2 subgoals):\n 1. k - 1 = g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)\n 2. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "note res = res[unfolded id if_True]"], ["proof (state)\nthis:\n  basis_reduction_adjust_mod p first mfs3 dmu3 = (p', mfs', dmu', g_idx')\n\ngoal (2 subgoals):\n 1. k - 1 = g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)\n 2. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "note res' = res'[unfolded id if_True]"], ["proof (state)\nthis:\n  LLL_adjust_mod p first state3 = (p'', state', G_idx')\n\ngoal (2 subgoals):\n 1. k - 1 = g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)\n 2. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "obtain mfsi4 dmui4 di4 mods4 where state': \"state' = (mfsi4, dmui4, di4, mods4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfsi4 dmui4 di4 mods4.\n        state' = (mfsi4, dmui4, di4, mods4) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases state', auto)"], ["proof (state)\nthis:\n  state' = (mfsi4, dmui4, di4, mods4)\n\ngoal (2 subgoals):\n 1. k - 1 = g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)\n 2. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "from res'[unfolded state3 state' LLL_adjust_mod_def Let_def perform_adjust_mod_def]"], ["proof (chain)\npicking this:\n  (case LLL_max_gso_norm first (mfsi3, dmui3, di3, mods3) of\n   (b', g_idx) \\<Rightarrow>\n     if mod_of_gso_norm first b' < p\n     then (mod_of_gso_norm first b',\n           case (mfsi3, dmui3, di3, mods3) of\n           (mfsi, dmui, di, x) \\<Rightarrow>\n             (map (map_vec (\\<lambda>x. x symmod mod_of_gso_norm first b'))\n               mfsi,\n              IArray.of_fun\n               (\\<lambda>i.\n                   IArray.of_fun\n                    (\\<lambda>j.\n                        dmui !! i !! j symmod\n                        IArray.of_fun\n                         (\\<lambda>j.\n                             mod_of_gso_norm first b' * di !! j *\n                             di !! Suc j)\n                         (m - 1) !!\n                        j)\n                    i)\n               m,\n              di,\n              IArray.of_fun\n               (\\<lambda>j.\n                   mod_of_gso_norm first b' * di !! j * di !! Suc j)\n               (m - 1)),\n           g_idx)\n     else (p, (mfsi3, dmui3, di3, mods3), g_idx)) =\n  (p'', (mfsi4, dmui4, di4, mods4), G_idx')", "have di4: \"di4 = di3\""], ["proof (prove)\nusing this:\n  (case LLL_max_gso_norm first (mfsi3, dmui3, di3, mods3) of\n   (b', g_idx) \\<Rightarrow>\n     if mod_of_gso_norm first b' < p\n     then (mod_of_gso_norm first b',\n           case (mfsi3, dmui3, di3, mods3) of\n           (mfsi, dmui, di, x) \\<Rightarrow>\n             (map (map_vec (\\<lambda>x. x symmod mod_of_gso_norm first b'))\n               mfsi,\n              IArray.of_fun\n               (\\<lambda>i.\n                   IArray.of_fun\n                    (\\<lambda>j.\n                        dmui !! i !! j symmod\n                        IArray.of_fun\n                         (\\<lambda>j.\n                             mod_of_gso_norm first b' * di !! j *\n                             di !! Suc j)\n                         (m - 1) !!\n                        j)\n                    i)\n               m,\n              di,\n              IArray.of_fun\n               (\\<lambda>j.\n                   mod_of_gso_norm first b' * di !! j * di !! Suc j)\n               (m - 1)),\n           g_idx)\n     else (p, (mfsi3, dmui3, di3, mods3), g_idx)) =\n  (p'', (mfsi4, dmui4, di4, mods4), G_idx')\n\ngoal (1 subgoal):\n 1. di4 = di3", "by (auto split: if_splits prod.splits)"], ["proof (state)\nthis:\n  di4 = di3\n\ngoal (2 subgoals):\n 1. k - 1 = g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)\n 2. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "from LLL_adjust_mod[OF impl3 res res' m] di3 state state' di4 res'"], ["proof (chain)\npicking this:\n  state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> G_idx' = g_idx'\n  \\<lbrakk>i \\<le> m; i \\<noteq> k\\<rbrakk>\n  \\<Longrightarrow> di3 !! i = di !! i\n  state = (mfsi, dmui, di, mods)\n  state' = (mfsi4, dmui4, di4, mods4)\n  di4 = di3\n  LLL_adjust_mod p first state3 = (p'', state', G_idx')", "show ?thesis"], ["proof (prove)\nusing this:\n  state_impl_inv p' mfs' dmu' state' \\<and> p'' = p' \\<and> G_idx' = g_idx'\n  \\<lbrakk>i \\<le> m; i \\<noteq> k\\<rbrakk>\n  \\<Longrightarrow> di3 !! i = di !! i\n  state = (mfsi, dmui, di, mods)\n  state' = (mfsi4, dmui4, di4, mods4)\n  di4 = di3\n  LLL_adjust_mod p first state3 = (p'', state', G_idx')\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "by auto"], ["proof (state)\nthis:\n  (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n  G_idx' = g_idx' \\<and>\n  (i \\<le> m \\<longrightarrow>\n   i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)\n\ngoal (1 subgoal):\n 1. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "case False"], ["proof (state)\nthis:\n  k - 1 \\<noteq> g_idx\n\ngoal (1 subgoal):\n 1. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "hence id: \"(k - 1 = g_idx) = False\""], ["proof (prove)\nusing this:\n  k - 1 \\<noteq> g_idx\n\ngoal (1 subgoal):\n 1. (k - 1 = g_idx) = False", "by simp"], ["proof (state)\nthis:\n  (k - 1 = g_idx) = False\n\ngoal (1 subgoal):\n 1. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "note res = res[unfolded id if_False]"], ["proof (state)\nthis:\n  (p, mfs3, dmu3, g_idx) = (p', mfs', dmu', g_idx')\n\ngoal (1 subgoal):\n 1. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "note res' = res'[unfolded id if_False]"], ["proof (state)\nthis:\n  (p, state3, g_idx) = (p'', state', G_idx')\n\ngoal (1 subgoal):\n 1. k - 1 \\<noteq> g_idx \\<Longrightarrow>\n    (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "from impl3 res res' di3 state state3"], ["proof (chain)\npicking this:\n  state_impl_inv p mfs3 dmu3 state3\n  (p, mfs3, dmu3, g_idx) = (p', mfs', dmu', g_idx')\n  (p, state3, g_idx) = (p'', state', G_idx')\n  \\<lbrakk>i \\<le> m; i \\<noteq> k\\<rbrakk>\n  \\<Longrightarrow> di3 !! i = di !! i\n  state = (mfsi, dmui, di, mods)\n  state3 = (mfsi3, dmui3, di3, mods3)", "show ?thesis"], ["proof (prove)\nusing this:\n  state_impl_inv p mfs3 dmu3 state3\n  (p, mfs3, dmu3, g_idx) = (p', mfs', dmu', g_idx')\n  (p, state3, g_idx) = (p'', state', G_idx')\n  \\<lbrakk>i \\<le> m; i \\<noteq> k\\<rbrakk>\n  \\<Longrightarrow> di3 !! i = di !! i\n  state = (mfsi, dmui, di, mods)\n  state3 = (mfsi3, dmui3, di3, mods3)\n\ngoal (1 subgoal):\n 1. (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n    G_idx' = g_idx' \\<and>\n    (i \\<le> m \\<longrightarrow>\n     i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)", "by auto"], ["proof (state)\nthis:\n  (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n  G_idx' = g_idx' \\<and>\n  (i \\<le> m \\<longrightarrow>\n   i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (state_impl_inv p' mfs' dmu' state' \\<and> p'' = p') \\<and>\n  G_idx' = g_idx' \\<and>\n  (i \\<le> m \\<longrightarrow>\n   i \\<noteq> k \\<longrightarrow> di_of state' !! i = di_of state !! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_step: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod_weak fs mfs dmu p first b\"\n  and res: \"basis_reduction_mod_step p first mfs dmu g_idx k j = (p', mfs', dmu', g_idx', k', j')\" \n  and res': \"LLL_step p first state g_idx k j = ((p'',state', g_idx''), k'', j'')\" \n  and k: \"k < m\" \nshows \"state_impl_inv p' mfs' dmu' state' \\<and> k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "using res res' impl"], ["proof (prove)\nusing this:\n  k = 0\n  basis_reduction_mod_step p first mfs dmu g_idx k j =\n  (p', mfs', dmu', g_idx', k', j')\n  LLL_step p first state g_idx k j = ((p'', state', g_idx''), k'', j'')\n  state_impl_inv p mfs dmu state\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "unfolding LLL_step_def basis_reduction_mod_step_def"], ["proof (prove)\nusing this:\n  k = 0\n  (if k = 0 then (p, mfs, dmu, g_idx, Suc k, j)\n   else let di = d_of dmu k; (num, denom) = quotient_of \\<alpha>\n        in if di * di * denom\n              \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n           then (p, mfs, dmu, g_idx, Suc k, j)\n           else let (p', mfs', dmu', g_idx') =\n                      basis_reduction_adjust_swap_add_step p first mfs dmu\n                       g_idx k\n                in (p', mfs', dmu', g_idx', k - 1, j + 1)) =\n  (p', mfs', dmu', g_idx', k', j')\n  (if k = 0 then ((p, state, g_idx), Suc k, j)\n   else let i1 = k - 1; iS = Suc k; (uu_, uu_, di, uu_) = state;\n            (num, denom) = quotient_of \\<alpha>; d_i = di !! k;\n            d_i1 = di !! i1; d_Si = di !! iS\n        in if d_i * d_i * denom \\<le> num * d_i1 * d_Si\n           then ((p, state, g_idx), iS, j)\n           else (LLL_adjust_swap_add p first state g_idx k, i1, j + 1)) =\n  ((p'', state', g_idx''), k'', j'')\n  state_impl_inv p mfs dmu state\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and>\n  k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "case k0: False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "hence id: \"(k = 0) = False\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (k = 0) = False", "by simp"], ["proof (state)\nthis:\n  (k = 0) = False\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "note res = res[unfolded basis_reduction_mod_step_def id if_False]"], ["proof (state)\nthis:\n  (let di = d_of dmu k; (num, denom) = quotient_of \\<alpha>\n   in if di * di * denom \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n      then (p, mfs, dmu, g_idx, Suc k, j)\n      else let (p', mfs', dmu', g_idx') =\n                 basis_reduction_adjust_swap_add_step p first mfs dmu g_idx\n                  k\n           in (p', mfs', dmu', g_idx', k - 1, j + 1)) =\n  (p', mfs', dmu', g_idx', k', j')\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "obtain num denom where alph: \"quotient_of \\<alpha> = (num,denom)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>num denom.\n        quotient_of \\<alpha> = (num, denom) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of \\<alpha> = (num, denom)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "obtain mfsi dmui di mods where state: \"state = (mfsi, dmui, di, mods)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfsi dmui di mods.\n        state = (mfsi, dmui, di, mods) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  state = (mfsi, dmui, di, mods)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "note res' = res'[unfolded LLL_step_def id if_False Let_def state split alph, folded state]"], ["proof (state)\nthis:\n  (if di !! k * di !! k * denom \\<le> num * di !! (k - 1) * di !! Suc k\n   then ((p, state, g_idx), Suc k, j)\n   else (LLL_adjust_swap_add p first state g_idx k, k - 1, j + 1)) =\n  ((p'', state', g_idx''), k'', j'')\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "from k0"], ["proof (chain)\npicking this:\n  k \\<noteq> 0", "have kk1: \"k - 1 < k\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k - 1 < k", "by auto"], ["proof (state)\nthis:\n  k - 1 < k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "note res = res[unfolded Let_def alph split]"], ["proof (state)\nthis:\n  (if d_of dmu k * d_of dmu k * denom\n      \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n   then (p, mfs, dmu, g_idx, Suc k, j)\n   else case basis_reduction_adjust_swap_add_step p first mfs dmu g_idx k of\n        (p', mfs', dmu', g_idx') \\<Rightarrow>\n          (p', mfs', dmu', g_idx', k - 1, j + 1)) =\n  (p', mfs', dmu', g_idx', k', j')\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "obtain state'' where addi: \"LLL_swap_add p state k = state''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>state''.\n        LLL_swap_add p state k = state'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_swap_add p state k = state''\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "from impl[unfolded state state_impl_inv.simps]"], ["proof (chain)\npicking this:\n  mfsi = mfs \\<and>\n  di = IArray.of_fun (d_of dmu) (Suc m) \\<and>\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n   m \\<and>\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)", "have di: \"di = IArray.of_fun (d_of dmu) (Suc m)\""], ["proof (prove)\nusing this:\n  mfsi = mfs \\<and>\n  di = IArray.of_fun (d_of dmu) (Suc m) \\<and>\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n   m \\<and>\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)\n\ngoal (1 subgoal):\n 1. di = IArray.of_fun (d_of dmu) (Suc m)", "by auto"], ["proof (state)\nthis:\n  di = IArray.of_fun (d_of dmu) (Suc m)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "have id: \"di !! k = d_of dmu k\" \n    \"di !! (Suc k) = d_of dmu (Suc k)\" \n    \"di !! (k - 1) = d_of dmu (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. di !! k = d_of dmu k &&&\n    di !! Suc k = d_of dmu (Suc k) &&& di !! (k - 1) = d_of dmu (k - 1)", "unfolding di"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (d_of dmu) (Suc m) !! k = d_of dmu k &&&\n    IArray.of_fun (d_of dmu) (Suc m) !! Suc k = d_of dmu (Suc k) &&&\n    IArray.of_fun (d_of dmu) (Suc m) !! (k - 1) = d_of dmu (k - 1)", "using k"], ["proof (prove)\nusing this:\n  k < m\n\ngoal (1 subgoal):\n 1. IArray.of_fun (d_of dmu) (Suc m) !! k = d_of dmu k &&&\n    IArray.of_fun (d_of dmu) (Suc m) !! Suc k = d_of dmu (Suc k) &&&\n    IArray.of_fun (d_of dmu) (Suc m) !! (k - 1) = d_of dmu (k - 1)", "by (subst IArray.of_fun_nth, force, force)+"], ["proof (state)\nthis:\n  di !! k = d_of dmu k\n  di !! Suc k = d_of dmu (Suc k)\n  di !! (k - 1) = d_of dmu (k - 1)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "have \"length mfsi = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length mfsi = m", "using impl[unfolded state state_impl_inv.simps] LLL_invD_modw[OF Linv]"], ["proof (prove)\nusing this:\n  mfsi = mfs \\<and>\n  di = IArray.of_fun (d_of dmu) (Suc m) \\<and>\n  dmui =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu $$ (i, j)) i)\n   m \\<and>\n  mods = IArray.of_fun (\\<lambda>j. p * di !! j * di !! Suc j) (m - 1)\n  length mfs = m\n  length fs = m\n  lattice_of fs = L\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  map (map_vec (\\<lambda>x. x symmod p)) fs = mfs\n  \\<forall>i'<m.\n     \\<forall>j'<i'.\n        \\<bar>d\\<mu> fs i' j'\\<bar> < p * d fs j' * d fs (Suc j')\n  \\<forall>i'<m. \\<forall>j'<m. d\\<mu> fs i' j' = dmu $$ (i', j')\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  ?i < m \\<Longrightarrow> mfs ! ?i \\<in> carrier_vec n\n  set mfs \\<subseteq> carrier_vec n\n  1 < p\n  g_bnd_mode first b fs\n  mod_invariant b p first\n\ngoal (1 subgoal):\n 1. length mfsi = m", "by auto"], ["proof (state)\nthis:\n  length mfsi = m\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "note res' = res'[unfolded id]"], ["proof (state)\nthis:\n  (if d_of dmu k * d_of dmu k * denom\n      \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n   then ((p, state, g_idx), Suc k, j)\n   else (LLL_adjust_swap_add p first state g_idx k, k - 1, j + 1)) =\n  ((p'', state', g_idx''), k'', j'')\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "let ?cond = \"d_of dmu k * d_of dmu k * denom \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "proof (cases ?cond)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_of dmu k * d_of dmu k * denom\n    \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'\n 2. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "case True"], ["proof (state)\nthis:\n  d_of dmu k * d_of dmu k * denom\n  \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n\ngoal (2 subgoals):\n 1. d_of dmu k * d_of dmu k * denom\n    \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'\n 2. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "from True res res' state"], ["proof (chain)\npicking this:\n  d_of dmu k * d_of dmu k * denom\n  \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n  (if d_of dmu k * d_of dmu k * denom\n      \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n   then (p, mfs, dmu, g_idx, Suc k, j)\n   else case basis_reduction_adjust_swap_add_step p first mfs dmu g_idx k of\n        (p', mfs', dmu', g_idx') \\<Rightarrow>\n          (p', mfs', dmu', g_idx', k - 1, j + 1)) =\n  (p', mfs', dmu', g_idx', k', j')\n  (if d_of dmu k * d_of dmu k * denom\n      \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n   then ((p, state, g_idx), Suc k, j)\n   else (LLL_adjust_swap_add p first state g_idx k, k - 1, j + 1)) =\n  ((p'', state', g_idx''), k'', j'')\n  state = (mfsi, dmui, di, mods)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_of dmu k * d_of dmu k * denom\n  \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n  (if d_of dmu k * d_of dmu k * denom\n      \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n   then (p, mfs, dmu, g_idx, Suc k, j)\n   else case basis_reduction_adjust_swap_add_step p first mfs dmu g_idx k of\n        (p', mfs', dmu', g_idx') \\<Rightarrow>\n          (p', mfs', dmu', g_idx', k - 1, j + 1)) =\n  (p', mfs', dmu', g_idx', k', j')\n  (if d_of dmu k * d_of dmu k * denom\n      \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n   then ((p, state, g_idx), Suc k, j)\n   else (LLL_adjust_swap_add p first state g_idx k, k - 1, j + 1)) =\n  ((p'', state', g_idx''), k'', j'')\n  state = (mfsi, dmui, di, mods)\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "using impl"], ["proof (prove)\nusing this:\n  d_of dmu k * d_of dmu k * denom\n  \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n  (if d_of dmu k * d_of dmu k * denom\n      \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n   then (p, mfs, dmu, g_idx, Suc k, j)\n   else case basis_reduction_adjust_swap_add_step p first mfs dmu g_idx k of\n        (p', mfs', dmu', g_idx') \\<Rightarrow>\n          (p', mfs', dmu', g_idx', k - 1, j + 1)) =\n  (p', mfs', dmu', g_idx', k', j')\n  (if d_of dmu k * d_of dmu k * denom\n      \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n   then ((p, state, g_idx), Suc k, j)\n   else (LLL_adjust_swap_add p first state g_idx k, k - 1, j + 1)) =\n  ((p'', state', g_idx''), k'', j'')\n  state = (mfsi, dmui, di, mods)\n  state_impl_inv p mfs dmu state\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and>\n  k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'\n\ngoal (1 subgoal):\n 1. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "case False"], ["proof (state)\nthis:\n  \\<not> d_of dmu k * d_of dmu k * denom\n         \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n\ngoal (1 subgoal):\n 1. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "hence cond: \"?cond = False\""], ["proof (prove)\nusing this:\n  \\<not> d_of dmu k * d_of dmu k * denom\n         \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)\n\ngoal (1 subgoal):\n 1. (d_of dmu k * d_of dmu k * denom\n     \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)) =\n    False", "by simp"], ["proof (state)\nthis:\n  (d_of dmu k * d_of dmu k * denom\n   \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k)) =\n  False\n\ngoal (1 subgoal):\n 1. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "note res = res[unfolded cond if_False]"], ["proof (state)\nthis:\n  (case basis_reduction_adjust_swap_add_step p first mfs dmu g_idx k of\n   (p', mfs', dmu', g_idx') \\<Rightarrow>\n     (p', mfs', dmu', g_idx', k - 1, j + 1)) =\n  (p', mfs', dmu', g_idx', k', j')\n\ngoal (1 subgoal):\n 1. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "note res' = res'[unfolded cond if_False]"], ["proof (state)\nthis:\n  (LLL_adjust_swap_add p first state g_idx k, k - 1, j + 1) =\n  ((p'', state', g_idx''), k'', j'')\n\ngoal (1 subgoal):\n 1. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "let ?step = \"basis_reduction_adjust_swap_add_step p first mfs dmu g_idx k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "let ?step' = \"LLL_adjust_swap_add p first state g_idx k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "from res"], ["proof (chain)\npicking this:\n  (case basis_reduction_adjust_swap_add_step p first mfs dmu g_idx k of\n   (p', mfs', dmu', g_idx') \\<Rightarrow>\n     (p', mfs', dmu', g_idx', k - 1, j + 1)) =\n  (p', mfs', dmu', g_idx', k', j')", "have step: \"?step = (p', mfs', dmu', g_idx')\""], ["proof (prove)\nusing this:\n  (case basis_reduction_adjust_swap_add_step p first mfs dmu g_idx k of\n   (p', mfs', dmu', g_idx') \\<Rightarrow>\n     (p', mfs', dmu', g_idx', k - 1, j + 1)) =\n  (p', mfs', dmu', g_idx', k', j')\n\ngoal (1 subgoal):\n 1. basis_reduction_adjust_swap_add_step p first mfs dmu g_idx k =\n    (p', mfs', dmu', g_idx')", "by (cases ?step, auto)"], ["proof (state)\nthis:\n  basis_reduction_adjust_swap_add_step p first mfs dmu g_idx k =\n  (p', mfs', dmu', g_idx')\n\ngoal (1 subgoal):\n 1. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "note res = res[unfolded step split]"], ["proof (state)\nthis:\n  (p', mfs', dmu', g_idx', k - 1, j + 1) = (p', mfs', dmu', g_idx', k', j')\n\ngoal (1 subgoal):\n 1. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "from res'"], ["proof (chain)\npicking this:\n  (LLL_adjust_swap_add p first state g_idx k, k - 1, j + 1) =\n  ((p'', state', g_idx''), k'', j'')", "have step': \"?step' = (p'',state', g_idx'')\""], ["proof (prove)\nusing this:\n  (LLL_adjust_swap_add p first state g_idx k, k - 1, j + 1) =\n  ((p'', state', g_idx''), k'', j'')\n\ngoal (1 subgoal):\n 1. LLL_adjust_swap_add p first state g_idx k = (p'', state', g_idx'')", "by auto"], ["proof (state)\nthis:\n  LLL_adjust_swap_add p first state g_idx k = (p'', state', g_idx'')\n\ngoal (1 subgoal):\n 1. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "note res' = res'[unfolded step']"], ["proof (state)\nthis:\n  ((p'', state', g_idx''), k - 1, j + 1) =\n  ((p'', state', g_idx''), k'', j'')\n\ngoal (1 subgoal):\n 1. \\<not> d_of dmu k * d_of dmu k * denom\n           \\<le> num * d_of dmu (k - 1) * d_of dmu (Suc k) \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "from LLL_adjust_swap_add[OF impl Linv step step' k k0]"], ["proof (chain)\npicking this:\n  state_impl_inv p' mfs' dmu' state'\n  p'' = p'\n  g_idx'' = g_idx'\n  \\<lbrakk>?i \\<le> m; ?i \\<noteq> k\\<rbrakk>\n  \\<Longrightarrow> di_of state' !! ?i = di_of state !! ?i", "show ?thesis"], ["proof (prove)\nusing this:\n  state_impl_inv p' mfs' dmu' state'\n  p'' = p'\n  g_idx'' = g_idx'\n  \\<lbrakk>?i \\<le> m; ?i \\<noteq> k\\<rbrakk>\n  \\<Longrightarrow> di_of state' !! ?i = di_of state !! ?i\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "using res res'"], ["proof (prove)\nusing this:\n  state_impl_inv p' mfs' dmu' state'\n  p'' = p'\n  g_idx'' = g_idx'\n  \\<lbrakk>?i \\<le> m; ?i \\<noteq> k\\<rbrakk>\n  \\<Longrightarrow> di_of state' !! ?i = di_of state !! ?i\n  (p', mfs', dmu', g_idx', k - 1, j + 1) = (p', mfs', dmu', g_idx', k', j')\n  ((p'', state', g_idx''), k - 1, j + 1) =\n  ((p'', state', g_idx''), k'', j'')\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and>\n    k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and>\n  k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and>\n  k'' = k' \\<and> p'' = p' \\<and> j'' = j' \\<and> g_idx'' = g_idx'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_main: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod fs mfs dmu p first b i\"\n  and res: \"basis_reduction_mod_main p first mfs dmu g_idx i k = (p', mfs', dmu')\" \n  and res': \"LLL_main p first state g_idx i k = (pi', state')\" \nshows \"state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "using assms"], ["proof (prove)\nusing this:\n  state_impl_inv p mfs dmu state\n  LLL_invariant_mod fs mfs dmu p first b i\n  basis_reduction_mod_main p first mfs dmu g_idx i k = (p', mfs', dmu')\n  LLL_main p first state g_idx i k = (pi', state')\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "proof (induct \"LLL_measure i fs\" arbitrary: mfs dmu state fs p b k i g_idx rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fs i mfs dmu state p b k g_idx.\n       \\<lbrakk>\\<And>fsa ia mfs dmu state p b k g_idx.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fsa mfs dmu p first b ia;\n                    basis_reduction_mod_main p first mfs dmu g_idx ia k =\n                    (p', mfs', dmu');\n                    LLL_main p first state g_idx ia k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b i;\n        basis_reduction_mod_main p first mfs dmu g_idx i k =\n        (p', mfs', dmu');\n        LLL_main p first state g_idx i k = (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "case (less fs i mfs dmu state p b k g_idx)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_measure ?i2 ?fs2 < LLL_measure i fs;\n   state_impl_inv ?p2 ?mfs2 ?dmu2 ?state2;\n   LLL_invariant_mod ?fs2 ?mfs2 ?dmu2 ?p2 first ?b2 ?i2;\n   basis_reduction_mod_main ?p2 first ?mfs2 ?dmu2 ?g_idx2 ?i2 ?k2 =\n   (p', mfs', dmu');\n   LLL_main ?p2 first ?state2 ?g_idx2 ?i2 ?k2 = (pi', state')\\<rbrakk>\n  \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n  state_impl_inv p mfs dmu state\n  LLL_invariant_mod fs mfs dmu p first b i\n  basis_reduction_mod_main p first mfs dmu g_idx i k = (p', mfs', dmu')\n  LLL_main p first state g_idx i k = (pi', state')\n\ngoal (1 subgoal):\n 1. \\<And>fs i mfs dmu state p b k g_idx.\n       \\<lbrakk>\\<And>fsa ia mfs dmu state p b k g_idx.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fsa mfs dmu p first b ia;\n                    basis_reduction_mod_main p first mfs dmu g_idx ia k =\n                    (p', mfs', dmu');\n                    LLL_main p first state g_idx ia k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b i;\n        basis_reduction_mod_main p first mfs dmu g_idx i k =\n        (p', mfs', dmu');\n        LLL_main p first state g_idx i k = (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note impl = less(2)"], ["proof (state)\nthis:\n  state_impl_inv p mfs dmu state\n\ngoal (1 subgoal):\n 1. \\<And>fs i mfs dmu state p b k g_idx.\n       \\<lbrakk>\\<And>fsa ia mfs dmu state p b k g_idx.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fsa mfs dmu p first b ia;\n                    basis_reduction_mod_main p first mfs dmu g_idx ia k =\n                    (p', mfs', dmu');\n                    LLL_main p first state g_idx ia k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b i;\n        basis_reduction_mod_main p first mfs dmu g_idx i k =\n        (p', mfs', dmu');\n        LLL_main p first state g_idx i k = (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note Linv = less(3)"], ["proof (state)\nthis:\n  LLL_invariant_mod fs mfs dmu p first b i\n\ngoal (1 subgoal):\n 1. \\<And>fs i mfs dmu state p b k g_idx.\n       \\<lbrakk>\\<And>fsa ia mfs dmu state p b k g_idx.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fsa mfs dmu p first b ia;\n                    basis_reduction_mod_main p first mfs dmu g_idx ia k =\n                    (p', mfs', dmu');\n                    LLL_main p first state g_idx ia k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b i;\n        basis_reduction_mod_main p first mfs dmu g_idx i k =\n        (p', mfs', dmu');\n        LLL_main p first state g_idx i k = (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note res = less(4)"], ["proof (state)\nthis:\n  basis_reduction_mod_main p first mfs dmu g_idx i k = (p', mfs', dmu')\n\ngoal (1 subgoal):\n 1. \\<And>fs i mfs dmu state p b k g_idx.\n       \\<lbrakk>\\<And>fsa ia mfs dmu state p b k g_idx.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fsa mfs dmu p first b ia;\n                    basis_reduction_mod_main p first mfs dmu g_idx ia k =\n                    (p', mfs', dmu');\n                    LLL_main p first state g_idx ia k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b i;\n        basis_reduction_mod_main p first mfs dmu g_idx i k =\n        (p', mfs', dmu');\n        LLL_main p first state g_idx i k = (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note res' = less(5)"], ["proof (state)\nthis:\n  LLL_main p first state g_idx i k = (pi', state')\n\ngoal (1 subgoal):\n 1. \\<And>fs i mfs dmu state p b k g_idx.\n       \\<lbrakk>\\<And>fsa ia mfs dmu state p b k g_idx.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fsa mfs dmu p first b ia;\n                    basis_reduction_mod_main p first mfs dmu g_idx ia k =\n                    (p', mfs', dmu');\n                    LLL_main p first state g_idx ia k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b i;\n        basis_reduction_mod_main p first mfs dmu g_idx i k =\n        (p', mfs', dmu');\n        LLL_main p first state g_idx i k = (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note IH = less(1)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_measure ?i2 ?fs2 < LLL_measure i fs;\n   state_impl_inv ?p2 ?mfs2 ?dmu2 ?state2;\n   LLL_invariant_mod ?fs2 ?mfs2 ?dmu2 ?p2 first ?b2 ?i2;\n   basis_reduction_mod_main ?p2 first ?mfs2 ?dmu2 ?g_idx2 ?i2 ?k2 =\n   (p', mfs', dmu');\n   LLL_main ?p2 first ?state2 ?g_idx2 ?i2 ?k2 = (pi', state')\\<rbrakk>\n  \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n\ngoal (1 subgoal):\n 1. \\<And>fs i mfs dmu state p b k g_idx.\n       \\<lbrakk>\\<And>fsa ia mfs dmu state p b k g_idx.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fsa mfs dmu p first b ia;\n                    basis_reduction_mod_main p first mfs dmu g_idx ia k =\n                    (p', mfs', dmu');\n                    LLL_main p first state g_idx ia k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b i;\n        basis_reduction_mod_main p first mfs dmu g_idx i k =\n        (p', mfs', dmu');\n        LLL_main p first state g_idx i k = (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note res = res[unfolded basis_reduction_mod_main.simps[of _ _ _ _ _ _ k]]"], ["proof (state)\nthis:\n  (if i < m\n   then case basis_reduction_mod_step p first mfs dmu g_idx i k of\n        (p', mfs', dmu', g_idx', x, xb) \\<Rightarrow>\n          basis_reduction_mod_main p' first mfs' dmu' g_idx' x xb\n   else (p, mfs, dmu)) =\n  (p', mfs', dmu')\n\ngoal (1 subgoal):\n 1. \\<And>fs i mfs dmu state p b k g_idx.\n       \\<lbrakk>\\<And>fsa ia mfs dmu state p b k g_idx.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fsa mfs dmu p first b ia;\n                    basis_reduction_mod_main p first mfs dmu g_idx ia k =\n                    (p', mfs', dmu');\n                    LLL_main p first state g_idx ia k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b i;\n        basis_reduction_mod_main p first mfs dmu g_idx i k =\n        (p', mfs', dmu');\n        LLL_main p first state g_idx i k = (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note res' = res'[unfolded LLL_main.simps[of _ _ _ _ _ k]]"], ["proof (state)\nthis:\n  (if i < m\n   then case LLL_step p first state g_idx i k of\n        ((p', state', g_idx'), x, xa) \\<Rightarrow>\n          LLL_main p' first state' g_idx' x xa\n   else (p, state)) =\n  (pi', state')\n\ngoal (1 subgoal):\n 1. \\<And>fs i mfs dmu state p b k g_idx.\n       \\<lbrakk>\\<And>fsa ia mfs dmu state p b k g_idx.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fsa mfs dmu p first b ia;\n                    basis_reduction_mod_main p first mfs dmu g_idx ia k =\n                    (p', mfs', dmu');\n                    LLL_main p first state g_idx ia k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b i;\n        basis_reduction_mod_main p first mfs dmu g_idx i k =\n        (p', mfs', dmu');\n        LLL_main p first state g_idx i k = (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note Linvw = LLL_mod_inv_to_weak[OF Linv]"], ["proof (state)\nthis:\n  LLL_invariant_mod_weak fs mfs dmu p first b\n\ngoal (1 subgoal):\n 1. \\<And>fs i mfs dmu state p b k g_idx.\n       \\<lbrakk>\\<And>fsa ia mfs dmu state p b k g_idx.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fsa mfs dmu p first b ia;\n                    basis_reduction_mod_main p first mfs dmu g_idx ia k =\n                    (p', mfs', dmu');\n                    LLL_main p first state g_idx ia k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b i;\n        basis_reduction_mod_main p first mfs dmu g_idx i k =\n        (p', mfs', dmu');\n        LLL_main p first state g_idx i k = (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "proof (cases \"i < m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n 2. \\<not> i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "case False"], ["proof (state)\nthis:\n  \\<not> i < m\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n 2. \\<not> i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "using res res' impl"], ["proof (prove)\nusing this:\n  \\<not> i < m\n  (if i < m\n   then case basis_reduction_mod_step p first mfs dmu g_idx i k of\n        (p', mfs', dmu', g_idx', x, xb) \\<Rightarrow>\n          basis_reduction_mod_main p' first mfs' dmu' g_idx' x xb\n   else (p, mfs, dmu)) =\n  (p', mfs', dmu')\n  (if i < m\n   then case LLL_step p first state g_idx i k of\n        ((p', state', g_idx'), x, xa) \\<Rightarrow>\n          LLL_main p' first state' g_idx' x xa\n   else (p, state)) =\n  (pi', state')\n  state_impl_inv p mfs dmu state\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "case i: True"], ["proof (state)\nthis:\n  i < m\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "hence id: \"(i < m) = True\""], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. (i < m) = True", "by simp"], ["proof (state)\nthis:\n  (i < m) = True\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "obtain P'' state'' I'' K'' G_idx'' where step': \"LLL_step p first state g_idx i k = ((P'', state'', G_idx''), I'', K'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P'' state'' G_idx'' I'' K''.\n        LLL_step p first state g_idx i k =\n        ((P'', state'', G_idx''), I'', K'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  LLL_step p first state g_idx i k = ((P'', state'', G_idx''), I'', K'')\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "obtain p'' mfs'' dmu'' i'' k'' g_idx'' where step: \"basis_reduction_mod_step p first mfs dmu g_idx i k = (p'', mfs'', dmu'', g_idx'', i'', k'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p'' mfs'' dmu'' g_idx'' i'' k''.\n        basis_reduction_mod_step p first mfs dmu g_idx i k =\n        (p'', mfs'', dmu'', g_idx'', i'', k'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  basis_reduction_mod_step p first mfs dmu g_idx i k =\n  (p'', mfs'', dmu'', g_idx'', i'', k'')\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "from LLL_step[OF impl Linvw step step' i]"], ["proof (chain)\npicking this:\n  state_impl_inv p'' mfs'' dmu'' state'' \\<and>\n  I'' = i'' \\<and> P'' = p'' \\<and> K'' = k'' \\<and> G_idx'' = g_idx''", "have impl'': \"state_impl_inv p'' mfs'' dmu'' state''\" and ID: \"I'' = i''\" \"K'' = k''\" \"P'' = p''\" \"G_idx'' = g_idx''\""], ["proof (prove)\nusing this:\n  state_impl_inv p'' mfs'' dmu'' state'' \\<and>\n  I'' = i'' \\<and> P'' = p'' \\<and> K'' = k'' \\<and> G_idx'' = g_idx''\n\ngoal (1 subgoal):\n 1. state_impl_inv p'' mfs'' dmu'' state'' &&&\n    (I'' = i'' &&& K'' = k'') &&& P'' = p'' &&& G_idx'' = g_idx''", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p'' mfs'' dmu'' state''\n  I'' = i''\n  K'' = k''\n  P'' = p''\n  G_idx'' = g_idx''\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "from basis_reduction_mod_step[OF Linv step i]"], ["proof (chain)\npicking this:\n  \\<exists>fs' b'.\n     LLL_measure i'' fs' < LLL_measure i fs \\<and>\n     LLL_invariant_mod fs' mfs'' dmu'' p'' first b' i''", "obtain\n       fs'' b'' where \n       Linv'': \"LLL_invariant_mod fs'' mfs'' dmu'' p'' first b'' i''\" and \n       decr: \"LLL_measure i'' fs'' < LLL_measure i fs\""], ["proof (prove)\nusing this:\n  \\<exists>fs' b'.\n     LLL_measure i'' fs' < LLL_measure i fs \\<and>\n     LLL_invariant_mod fs' mfs'' dmu'' p'' first b' i''\n\ngoal (1 subgoal):\n 1. (\\<And>fs'' b''.\n        \\<lbrakk>LLL_invariant_mod fs'' mfs'' dmu'' p'' first b'' i'';\n         LLL_measure i'' fs'' < LLL_measure i fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_invariant_mod fs'' mfs'' dmu'' p'' first b'' i''\n  LLL_measure i'' fs'' < LLL_measure i fs\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note res = res[unfolded id if_True step split]"], ["proof (state)\nthis:\n  basis_reduction_mod_main p'' first mfs'' dmu'' g_idx'' i'' k'' =\n  (p', mfs', dmu')\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note res' = res'[unfolded id if_True step' split ID]"], ["proof (state)\nthis:\n  LLL_main p'' first state'' g_idx'' i'' k'' = (pi', state')\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "by (rule IH[OF decr impl'' Linv'' res res'])"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_iso_main_inner: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and di_prods: \"state_iso_inv di_prods (di_of state)\" \n  and Linv: \"LLL_invariant_mod_weak fs mfs dmu p first b\"\n  and res: \"basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu')\" \n  and res': \"LLL_iso_main_inner p first state di_prods g_idx k = (pi', state')\" \n  and m: \"m > 1\" \nshows \"state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "using assms(1-5)"], ["proof (prove)\nusing this:\n  state_impl_inv p mfs dmu state\n  state_iso_inv di_prods (di_of state)\n  LLL_invariant_mod_weak fs mfs dmu p first b\n  basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu')\n  LLL_iso_main_inner p first state di_prods g_idx k = (pi', state')\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "proof (induct \"LLL_measure (m - 1) fs\" arbitrary: mfs dmu state fs p b k di_prods g_idx rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "case (less fs mfs dmu state p b k di_prods g_idx)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_measure (m - 1) ?fs2 < LLL_measure (m - 1) fs;\n   state_impl_inv ?p2 ?mfs2 ?dmu2 ?state2;\n   state_iso_inv ?di_prods2 (di_of ?state2);\n   LLL_invariant_mod_weak ?fs2 ?mfs2 ?dmu2 ?p2 first ?b2;\n   basis_reduction_iso_main ?p2 first ?mfs2 ?dmu2 ?g_idx2 ?k2 =\n   (p', mfs', dmu');\n   LLL_iso_main_inner ?p2 first ?state2 ?di_prods2 ?g_idx2 ?k2 =\n   (pi', state')\\<rbrakk>\n  \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n  state_impl_inv p mfs dmu state\n  state_iso_inv di_prods (di_of state)\n  LLL_invariant_mod_weak fs mfs dmu p first b\n  basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu')\n  LLL_iso_main_inner p first state di_prods g_idx k = (pi', state')\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note impl = less(2)"], ["proof (state)\nthis:\n  state_impl_inv p mfs dmu state\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note di_prods  = less(3)"], ["proof (state)\nthis:\n  state_iso_inv di_prods (di_of state)\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note Linv = less(4)"], ["proof (state)\nthis:\n  LLL_invariant_mod_weak fs mfs dmu p first b\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note res = less(5)"], ["proof (state)\nthis:\n  basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu')\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note res' = less(6)"], ["proof (state)\nthis:\n  LLL_iso_main_inner p first state di_prods g_idx k = (pi', state')\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note IH = less(1)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_measure (m - 1) ?fs2 < LLL_measure (m - 1) fs;\n   state_impl_inv ?p2 ?mfs2 ?dmu2 ?state2;\n   state_iso_inv ?di_prods2 (di_of ?state2);\n   LLL_invariant_mod_weak ?fs2 ?mfs2 ?dmu2 ?p2 first ?b2;\n   basis_reduction_iso_main ?p2 first ?mfs2 ?dmu2 ?g_idx2 ?k2 =\n   (p', mfs', dmu');\n   LLL_iso_main_inner ?p2 first ?state2 ?di_prods2 ?g_idx2 ?k2 =\n   (pi', state')\\<rbrakk>\n  \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "obtain mfsi dmui di mods where state: \"state = (mfsi, dmui, di, mods)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfsi dmui di mods.\n        state = (mfsi, dmui, di, mods) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases4)"], ["proof (state)\nthis:\n  state = (mfsi, dmui, di, mods)\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "from di_prods state"], ["proof (chain)\npicking this:\n  state_iso_inv di_prods (di_of state)\n  state = (mfsi, dmui, di, mods)", "have di_prods: \"state_iso_inv di_prods di\""], ["proof (prove)\nusing this:\n  state_iso_inv di_prods (di_of state)\n  state = (mfsi, dmui, di, mods)\n\ngoal (1 subgoal):\n 1. state_iso_inv di_prods di", "by auto"], ["proof (state)\nthis:\n  state_iso_inv di_prods di\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "obtain num denom idx where quot': \"LLL_max_gso_quot di_prods = (num, denom, idx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>num denom idx.\n        LLL_max_gso_quot di_prods = (num, denom, idx) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  LLL_max_gso_quot di_prods = (num, denom, idx)\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note inv = LLL_invD_modw[OF Linv]"], ["proof (state)\nthis:\n  length mfs = m\n  length fs = m\n  lattice_of fs = L\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  map (map_vec (\\<lambda>x. x symmod p)) fs = mfs\n  \\<forall>i'<m.\n     \\<forall>j'<i'.\n        \\<bar>d\\<mu> fs i' j'\\<bar> < p * d fs j' * d fs (Suc j')\n  \\<forall>i'<m. \\<forall>j'<m. d\\<mu> fs i' j' = dmu $$ (i', j')\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  ?i < m \\<Longrightarrow> mfs ! ?i \\<in> carrier_vec n\n  set mfs \\<subseteq> carrier_vec n\n  1 < p\n  g_bnd_mode first b fs\n  mod_invariant b p first\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "obtain na da where alph: \"quotient_of \\<alpha> = (na,da)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>na da.\n        quotient_of \\<alpha> = (na, da) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of \\<alpha> = (na, da)\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "from impl[unfolded state]"], ["proof (chain)\npicking this:\n  state_impl_inv p mfs dmu (mfsi, dmui, di, mods)", "have di: \"di = IArray.of_fun (d_of dmu) (Suc m)\""], ["proof (prove)\nusing this:\n  state_impl_inv p mfs dmu (mfsi, dmui, di, mods)\n\ngoal (1 subgoal):\n 1. di = IArray.of_fun (d_of dmu) (Suc m)", "by auto"], ["proof (state)\nthis:\n  di = IArray.of_fun (d_of dmu) (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "from LLL_max_gso_quot[OF di di_prods]"], ["proof (chain)\npicking this:\n  LLL_max_gso_quot di_prods = compute_max_gso_quot dmu", "have quot: \"compute_max_gso_quot dmu = LLL_max_gso_quot di_prods\""], ["proof (prove)\nusing this:\n  LLL_max_gso_quot di_prods = compute_max_gso_quot dmu\n\ngoal (1 subgoal):\n 1. compute_max_gso_quot dmu = LLL_max_gso_quot di_prods", ".."], ["proof (state)\nthis:\n  compute_max_gso_quot dmu = LLL_max_gso_quot di_prods\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "obtain cmp where cmp: \"(na * denom < num * da) = cmp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cmp.\n        (na * denom < num * da) = cmp \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (na * denom < num * da) = cmp\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "have \"(m > 1) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 < m) = True", "using m"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. (1 < m) = True", "by auto"], ["proof (state)\nthis:\n  (1 < m) = True\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note res = res[unfolded basis_reduction_iso_main.simps[of _ _ _ _ _ k] this if_True Let_def quot quot' split alph cmp]"], ["proof (state)\nthis:\n  (if cmp\n   then case basis_reduction_adjust_swap_add_step p first mfs dmu g_idx\n              idx of\n        (p', mfs', dmu', g_idx') \\<Rightarrow>\n          basis_reduction_iso_main p' first mfs' dmu' g_idx' (k + 1)\n   else (p, mfs, dmu)) =\n  (p', mfs', dmu')\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note res' = res'[unfolded LLL_iso_main_inner.simps[of _ _ _ _ _ k] state split Let_def quot' alph cmp, folded state]"], ["proof (state)\nthis:\n  (if cmp\n   then case LLL_adjust_swap_add p first state g_idx idx of\n        (p', state', g_idx') \\<Rightarrow>\n          case state' of\n          (x, xaa, di', xba) \\<Rightarrow>\n            LLL_iso_main_inner p' first state'\n             (IArray.of_fun\n               (\\<lambda>i.\n                   if idx < i \\<or> i + 2 < idx then di_prods !! i\n                   else case di_prods !! i of\n                        (l, r) \\<Rightarrow>\n                          if i + 1 = idx then (di' !! idx * di' !! idx, r)\n                          else (l, di' !! (i + 2) * di' !! i))\n               (m - 1))\n             g_idx' (k + 1)\n   else (p, state)) =\n  (pi', state')\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note cmp = compute_max_gso_quot_alpha[OF Linv quot[unfolded quot'] alph cmp m]"], ["proof (state)\nthis:\n  cmp \\<Longrightarrow>\n  idx \\<noteq> 0 \\<and>\n  idx < m \\<and>\n  \\<not> d_of dmu idx * d_of dmu idx * da\n         \\<le> na * d_of dmu (idx - 1) * d_of dmu (Suc idx)\n  \\<not> cmp \\<Longrightarrow> LLL_invariant_mod fs mfs dmu p first b m\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state p b k di_prods g_idx.\n       \\<lbrakk>\\<And>fsa mfs dmu state p b k di_prods g_idx.\n                   \\<lbrakk>LLL_measure (m - 1) fsa\n                            < LLL_measure (m - 1) fs;\n                    state_impl_inv p mfs dmu state;\n                    state_iso_inv di_prods (di_of state);\n                    LLL_invariant_mod_weak fsa mfs dmu p first b;\n                    basis_reduction_iso_main p first mfs dmu g_idx k =\n                    (p', mfs', dmu');\n                    LLL_iso_main_inner p first state di_prods g_idx k =\n                    (pi', state')\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p' mfs' dmu'\nstate' \\<and>\n                                     pi' = p';\n        state_impl_inv p mfs dmu state;\n        state_iso_inv di_prods (di_of state);\n        LLL_invariant_mod_weak fs mfs dmu p first b;\n        basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu');\n        LLL_iso_main_inner p first state di_prods g_idx k =\n        (pi', state')\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "proof (cases cmp)"], ["proof (state)\ngoal (2 subgoals):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n 2. \\<not> cmp \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "case False"], ["proof (state)\nthis:\n  \\<not> cmp\n\ngoal (2 subgoals):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n 2. \\<not> cmp \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> cmp\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "using res res' impl"], ["proof (prove)\nusing this:\n  \\<not> cmp\n  (if cmp\n   then case basis_reduction_adjust_swap_add_step p first mfs dmu g_idx\n              idx of\n        (p', mfs', dmu', g_idx') \\<Rightarrow>\n          basis_reduction_iso_main p' first mfs' dmu' g_idx' (k + 1)\n   else (p, mfs, dmu)) =\n  (p', mfs', dmu')\n  (if cmp\n   then case LLL_adjust_swap_add p first state g_idx idx of\n        (p', state', g_idx') \\<Rightarrow>\n          case state' of\n          (x, xaa, di', xba) \\<Rightarrow>\n            LLL_iso_main_inner p' first state'\n             (IArray.of_fun\n               (\\<lambda>i.\n                   if idx < i \\<or> i + 2 < idx then di_prods !! i\n                   else case di_prods !! i of\n                        (l, r) \\<Rightarrow>\n                          if i + 1 = idx then (di' !! idx * di' !! idx, r)\n                          else (l, di' !! (i + 2) * di' !! i))\n               (m - 1))\n             g_idx' (k + 1)\n   else (p, state)) =\n  (pi', state')\n  state_impl_inv p mfs dmu state\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "case True"], ["proof (state)\nthis:\n  cmp\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "hence id: \"cmp = True\""], ["proof (prove)\nusing this:\n  cmp\n\ngoal (1 subgoal):\n 1. cmp = True", "by simp"], ["proof (state)\nthis:\n  cmp = True\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note cmp = cmp(1)[OF True]"], ["proof (state)\nthis:\n  idx \\<noteq> 0 \\<and>\n  idx < m \\<and>\n  \\<not> d_of dmu idx * d_of dmu idx * da\n         \\<le> na * d_of dmu (idx - 1) * d_of dmu (Suc idx)\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "obtain state'' P'' G_idx'' where step': \"LLL_adjust_swap_add p first state g_idx idx = (P'',state'', G_idx'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P'' state'' G_idx''.\n        LLL_adjust_swap_add p first state g_idx idx =\n        (P'', state'', G_idx'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  LLL_adjust_swap_add p first state g_idx idx = (P'', state'', G_idx'')\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "obtain mfs'' dmu'' p'' g_idx'' where step: \"basis_reduction_adjust_swap_add_step p first mfs dmu g_idx idx = (p'', mfs'', dmu'', g_idx'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p'' mfs'' dmu'' g_idx''.\n        basis_reduction_adjust_swap_add_step p first mfs dmu g_idx idx =\n        (p'', mfs'', dmu'', g_idx'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  basis_reduction_adjust_swap_add_step p first mfs dmu g_idx idx =\n  (p'', mfs'', dmu'', g_idx'')\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "obtain mfsi2 dmui2 di2 mods2 where state2: \"state'' = (mfsi2, dmui2, di2, mods2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfsi2 dmui2 di2 mods2.\n        state'' = (mfsi2, dmui2, di2, mods2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases state'', auto)"], ["proof (state)\nthis:\n  state'' = (mfsi2, dmui2, di2, mods2)\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note res = res[unfolded id if_True step split]"], ["proof (state)\nthis:\n  basis_reduction_iso_main p'' first mfs'' dmu'' g_idx'' (k + 1) =\n  (p', mfs', dmu')\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "note res' = res'[unfolded id if_True step' state2 split, folded state2]"], ["proof (state)\nthis:\n  LLL_iso_main_inner P'' first state''\n   (IArray.of_fun\n     (\\<lambda>i.\n         if idx < i \\<or> i + 2 < idx then di_prods !! i\n         else case di_prods !! i of\n              (l, r) \\<Rightarrow>\n                if i + 1 = idx then (di2 !! idx * di2 !! idx, r)\n                else (l, di2 !! (i + 2) * di2 !! i))\n     (m - 1))\n   G_idx'' (k + 1) =\n  (pi', state')\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "from cmp"], ["proof (chain)\npicking this:\n  idx \\<noteq> 0 \\<and>\n  idx < m \\<and>\n  \\<not> d_of dmu idx * d_of dmu idx * da\n         \\<le> na * d_of dmu (idx - 1) * d_of dmu (Suc idx)", "have idx0: \"idx \\<noteq> 0\" and idx: \"idx < m\" and ineq: \"\\<not> d_of dmu idx * d_of dmu idx * da \\<le> na * d_of dmu (idx - 1) * d_of dmu (Suc idx)\""], ["proof (prove)\nusing this:\n  idx \\<noteq> 0 \\<and>\n  idx < m \\<and>\n  \\<not> d_of dmu idx * d_of dmu idx * da\n         \\<le> na * d_of dmu (idx - 1) * d_of dmu (Suc idx)\n\ngoal (1 subgoal):\n 1. idx \\<noteq> 0 &&&\n    idx < m &&&\n    \\<not> d_of dmu idx * d_of dmu idx * da\n           \\<le> na * d_of dmu (idx - 1) * d_of dmu (Suc idx)", "by auto"], ["proof (state)\nthis:\n  idx \\<noteq> 0\n  idx < m\n  \\<not> d_of dmu idx * d_of dmu idx * da\n         \\<le> na * d_of dmu (idx - 1) * d_of dmu (Suc idx)\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "from basis_reduction_adjust_swap_add_step[OF Linv step alph ineq idx idx0]"], ["proof (chain)\npicking this:\n  \\<exists>fs' b'.\n     LLL_invariant_mod_weak fs' mfs'' dmu'' p'' first b' \\<and>\n     LLL_measure (idx - 1) fs' < LLL_measure idx fs \\<and>\n     LLL_measure (m - 1) fs' < LLL_measure (m - 1) fs \\<and>\n     (LLL_invariant_mod fs mfs dmu p first b idx \\<longrightarrow>\n      LLL_invariant_mod fs' mfs'' dmu'' p'' first b' (idx - 1))", "obtain fs'' b'' where Linv'': \"LLL_invariant_mod_weak fs'' mfs'' dmu'' p'' first b''\" and\n       meas: \"LLL_measure (m - 1) fs'' < LLL_measure (m - 1) fs\""], ["proof (prove)\nusing this:\n  \\<exists>fs' b'.\n     LLL_invariant_mod_weak fs' mfs'' dmu'' p'' first b' \\<and>\n     LLL_measure (idx - 1) fs' < LLL_measure idx fs \\<and>\n     LLL_measure (m - 1) fs' < LLL_measure (m - 1) fs \\<and>\n     (LLL_invariant_mod fs mfs dmu p first b idx \\<longrightarrow>\n      LLL_invariant_mod fs' mfs'' dmu'' p'' first b' (idx - 1))\n\ngoal (1 subgoal):\n 1. (\\<And>fs'' b''.\n        \\<lbrakk>LLL_invariant_mod_weak fs'' mfs'' dmu'' p'' first b'';\n         LLL_measure (m - 1) fs'' < LLL_measure (m - 1) fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_invariant_mod_weak fs'' mfs'' dmu'' p'' first b''\n  LLL_measure (m - 1) fs'' < LLL_measure (m - 1) fs\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "from LLL_adjust_swap_add[OF impl Linv step step' idx idx0]"], ["proof (chain)\npicking this:\n  state_impl_inv p'' mfs'' dmu'' state''\n  P'' = p''\n  G_idx'' = g_idx''\n  \\<lbrakk>?i \\<le> m; ?i \\<noteq> idx\\<rbrakk>\n  \\<Longrightarrow> di_of state'' !! ?i = di_of state !! ?i", "have impl'': \"state_impl_inv p'' mfs'' dmu'' state''\" and P'': \"P'' = p''\" \"G_idx'' = g_idx''\" \n      and di_prod_upd: \"\\<And> i. i \\<le> m \\<Longrightarrow> i \\<noteq> idx \\<Longrightarrow> di2 !! i = di !! i\""], ["proof (prove)\nusing this:\n  state_impl_inv p'' mfs'' dmu'' state''\n  P'' = p''\n  G_idx'' = g_idx''\n  \\<lbrakk>?i \\<le> m; ?i \\<noteq> idx\\<rbrakk>\n  \\<Longrightarrow> di_of state'' !! ?i = di_of state !! ?i\n\ngoal (1 subgoal):\n 1. state_impl_inv p'' mfs'' dmu'' state'' &&&\n    (P'' = p'' &&& G_idx'' = g_idx'') &&&\n    (\\<And>i.\n        \\<lbrakk>i \\<le> m; i \\<noteq> idx\\<rbrakk>\n        \\<Longrightarrow> di2 !! i = di !! i)", "using state state2"], ["proof (prove)\nusing this:\n  state_impl_inv p'' mfs'' dmu'' state''\n  P'' = p''\n  G_idx'' = g_idx''\n  \\<lbrakk>?i \\<le> m; ?i \\<noteq> idx\\<rbrakk>\n  \\<Longrightarrow> di_of state'' !! ?i = di_of state !! ?i\n  state = (mfsi, dmui, di, mods)\n  state'' = (mfsi2, dmui2, di2, mods2)\n\ngoal (1 subgoal):\n 1. state_impl_inv p'' mfs'' dmu'' state'' &&&\n    (P'' = p'' &&& G_idx'' = g_idx'') &&&\n    (\\<And>i.\n        \\<lbrakk>i \\<le> m; i \\<noteq> idx\\<rbrakk>\n        \\<Longrightarrow> di2 !! i = di !! i)", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p'' mfs'' dmu'' state''\n  P'' = p''\n  G_idx'' = g_idx''\n  \\<lbrakk>?i2 \\<le> m; ?i2 \\<noteq> idx\\<rbrakk>\n  \\<Longrightarrow> di2 !! ?i2 = di !! ?i2\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "have di_prods: \"state_iso_inv (IArray.of_fun\n       (\\<lambda>i. if idx < i \\<or> i + 2 < idx then di_prods !! i\n            else case di_prods !! i of (l, r) \\<Rightarrow> if i + 1 = idx then (di2 !! idx * di2 !! idx, r) else (l, di2 !! (i + 2) * di2 !! i))\n       (m - 1)) di2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_iso_inv\n     (IArray.of_fun\n       (\\<lambda>i.\n           if idx < i \\<or> i + 2 < idx then di_prods !! i\n           else case di_prods !! i of\n                (l, r) \\<Rightarrow>\n                  if i + 1 = idx then (di2 !! idx * di2 !! idx, r)\n                  else (l, di2 !! (i + 2) * di2 !! i))\n       (m - 1))\n     di2", "unfolding state_iso_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         if idx < i \\<or> i + 2 < idx then di_prods !! i\n         else case di_prods !! i of\n              (l, r) \\<Rightarrow>\n                if i + 1 = idx then (di2 !! idx * di2 !! idx, r)\n                else (l, di2 !! (i + 2) * di2 !! i))\n     (m - 1) =\n    IArray.of_fun\n     (\\<lambda>i.\n         (di2 !! (i + 1) * di2 !! (i + 1), di2 !! (i + 2) * di2 !! i))\n     (m - 1)", "by (intro iarray_cong', insert di_prod_upd, unfold di_prods[unfolded state_iso_inv_def],\n        subst (1 2) IArray.of_fun_nth, auto)"], ["proof (state)\nthis:\n  state_iso_inv\n   (IArray.of_fun\n     (\\<lambda>i.\n         if idx < i \\<or> i + 2 < idx then di_prods !! i\n         else case di_prods !! i of\n              (l, r) \\<Rightarrow>\n                if i + 1 = idx then (di2 !! idx * di2 !! idx, r)\n                else (l, di2 !! (i + 2) * di2 !! i))\n     (m - 1))\n   di2\n\ngoal (1 subgoal):\n 1. cmp \\<Longrightarrow> state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "by (rule IH[OF meas impl'' _ Linv'' res res'[unfolded step' P'']], insert di_prods state2, auto)"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_iso_main: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod_weak fs mfs dmu p first b\"\n  and res: \"basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu')\" \n  and res': \"LLL_iso_main p first state g_idx k = (pi', state')\" \nshows \"state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "proof (cases \"m > 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n 2. \\<not> 1 < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "case True"], ["proof (state)\nthis:\n  1 < m\n\ngoal (2 subgoals):\n 1. 1 < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n 2. \\<not> 1 < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "from LLL_iso_main_inner[OF impl _ Linv res _ True, unfolded state_iso_inv_def, OF refl, of pi' state'] res' True"], ["proof (chain)\npicking this:\n  LLL_iso_main_inner p first state\n   (IArray.of_fun\n     (\\<lambda>i.\n         (di_of state !! (i + 1) * di_of state !! (i + 1),\n          di_of state !! (i + 2) * di_of state !! i))\n     (m - 1))\n   g_idx k =\n  (pi', state') \\<Longrightarrow>\n  state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n  LLL_iso_main p first state g_idx k = (pi', state')\n  1 < m", "show ?thesis"], ["proof (prove)\nusing this:\n  LLL_iso_main_inner p first state\n   (IArray.of_fun\n     (\\<lambda>i.\n         (di_of state !! (i + 1) * di_of state !! (i + 1),\n          di_of state !! (i + 2) * di_of state !! i))\n     (m - 1))\n   g_idx k =\n  (pi', state') \\<Longrightarrow>\n  state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n  LLL_iso_main p first state g_idx k = (pi', state')\n  1 < m\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "unfolding LLL_iso_main_def"], ["proof (prove)\nusing this:\n  LLL_iso_main_inner p first state\n   (IArray.of_fun\n     (\\<lambda>i.\n         (di_of state !! (i + 1) * di_of state !! (i + 1),\n          di_of state !! (i + 2) * di_of state !! i))\n     (m - 1))\n   g_idx k =\n  (pi', state') \\<Longrightarrow>\n  state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n  (if 1 < m\n   then case state of\n        (x, xaa, di, xba) \\<Rightarrow>\n          let di_prods =\n                IArray.of_fun\n                 (\\<lambda>i.\n                     (di !! (i + 1) * di !! (i + 1),\n                      di !! (i + 2) * di !! i))\n                 (m - 1)\n          in LLL_iso_main_inner p first state di_prods g_idx k\n   else (p, state)) =\n  (pi', state')\n  1 < m\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "by (cases state, auto)"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n\ngoal (1 subgoal):\n 1. \\<not> 1 < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 1 < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "case False"], ["proof (state)\nthis:\n  \\<not> 1 < m\n\ngoal (1 subgoal):\n 1. \\<not> 1 < m \\<Longrightarrow>\n    state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 1 < m\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "using res res' impl"], ["proof (prove)\nusing this:\n  \\<not> 1 < m\n  basis_reduction_iso_main p first mfs dmu g_idx k = (p', mfs', dmu')\n  LLL_iso_main p first state g_idx k = (pi', state')\n  state_impl_inv p mfs dmu state\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "unfolding LLL_iso_main_def\n    basis_reduction_iso_main.simps[of _ _ _ _ _ k]"], ["proof (prove)\nusing this:\n  \\<not> 1 < m\n  (if 1 < m\n   then let (max_gso_num, max_gso_denum, indx) = compute_max_gso_quot dmu;\n            (num, denum) = quotient_of \\<alpha>\n        in if num * max_gso_denum < max_gso_num * denum\n           then case basis_reduction_adjust_swap_add_step p first mfs dmu\n                      g_idx indx of\n                (p', mfs', dmu', g_idx') \\<Rightarrow>\n                  basis_reduction_iso_main p' first mfs' dmu' g_idx' (k + 1)\n           else (p, mfs, dmu)\n   else (p, mfs, dmu)) =\n  (p', mfs', dmu')\n  (if 1 < m\n   then case state of\n        (x, xaa, di, xba) \\<Rightarrow>\n          let di_prods =\n                IArray.of_fun\n                 (\\<lambda>i.\n                     (di !! (i + 1) * di !! (i + 1),\n                      di !! (i + 2) * di !! i))\n                 (m - 1)\n          in LLL_iso_main_inner p first state di_prods g_idx k\n   else (p, state)) =\n  (pi', state')\n  state_impl_inv p mfs dmu state\n\ngoal (1 subgoal):\n 1. state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p' mfs' dmu' state' \\<and> pi' = p'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_initial: assumes res: \"compute_initial_state first = (p, mfs, dmu, g_idx)\" \n  and res': \"LLL_initial first = (p', state, g_idx')\" \n  and m: \"m \\<noteq> 0\" \nshows \"state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "obtain b gi where norm: \"compute_max_gso_norm first dmu_initial = (b,gi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b gi.\n        compute_max_gso_norm first dmu_initial = (b, gi) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  compute_max_gso_norm first dmu_initial = (b, gi)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "obtain P where P: \"compute_mod_of_max_gso_norm first b = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        compute_mod_of_max_gso_norm first b = P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  compute_mod_of_max_gso_norm first b = P\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "define di where \"di = IArray.of_fun (\\<lambda>i. if i = 0 then 1 else d\\<mu>_impl fs_init !! (i - 1) !! (i - 1)) (Suc m)\""], ["proof (state)\nthis:\n  di =\n  IArray.of_fun\n   (\\<lambda>i.\n       if i = 0 then 1 else d\\<mu>_impl fs_init !! (i - 1) !! (i - 1))\n   (Suc m)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "note res = res[unfolded compute_initial_state_def Let_def P norm split]"], ["proof (state)\nthis:\n  (P, compute_initial_mfs P, compute_initial_dmu P dmu_initial, gi) =\n  (p, mfs, dmu, g_idx)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "have di: \"di = IArray.of_fun (d_of dmu_initial) (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. di = IArray.of_fun (d_of dmu_initial) (Suc m)", "unfolding di_def dmu_initial_def Let_def d_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         if i = 0 then 1 else d\\<mu>_impl fs_init !! (i - 1) !! (i - 1))\n     (Suc m) =\n    IArray.of_fun\n     (\\<lambda>i.\n         if i = 0 then 1\n         else mat m m\n               (\\<lambda>(i, j).\n                   if j \\<le> i then d\\<mu>_impl fs_init !! i !! j\n                   else 0) $$\n              (i - 1, i - 1))\n     (Suc m)", "by (intro iarray_cong refl if_cong, auto)"], ["proof (state)\nthis:\n  di = IArray.of_fun (d_of dmu_initial) (Suc m)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "note norm' = LLL_max_gso_norm_di[OF di m, of first, unfolded norm]"], ["proof (state)\nthis:\n  LLL_max_gso_norm_di first di = (b, gi)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "note res' = res'[unfolded LLL_initial_def Let_def, folded di_def, unfolded norm' P split mod_of_gso_norm[OF m]]"], ["proof (state)\nthis:\n  (P, (compute_initial_mfs P,\n       IArray.of_fun\n        (\\<lambda>i.\n            IArray.of_fun\n             (\\<lambda>j.\n                 d\\<mu>_impl fs_init !! i !! j symmod\n                 IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n                  (m - 1) !!\n                 j)\n             i)\n        m,\n       di, IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1)),\n   gi) =\n  (p', state, g_idx')\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "from res"], ["proof (chain)\npicking this:\n  (P, compute_initial_mfs P, compute_initial_dmu P dmu_initial, gi) =\n  (p, mfs, dmu, g_idx)", "have p: \"p = P\" and mfs: \"mfs = compute_initial_mfs p\" and dmu: \"dmu = compute_initial_dmu P dmu_initial\" \n    and g_idx: \"g_idx = gi\""], ["proof (prove)\nusing this:\n  (P, compute_initial_mfs P, compute_initial_dmu P dmu_initial, gi) =\n  (p, mfs, dmu, g_idx)\n\ngoal (1 subgoal):\n 1. (p = P &&& mfs = compute_initial_mfs p) &&&\n    dmu = compute_initial_dmu P dmu_initial &&& g_idx = gi", "by auto"], ["proof (state)\nthis:\n  p = P\n  mfs = compute_initial_mfs p\n  dmu = compute_initial_dmu P dmu_initial\n  g_idx = gi\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "let ?mods = \"IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "have di': \"di = IArray.of_fun (d_of (compute_initial_dmu P dmu_initial)) (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. di = IArray.of_fun (d_of (compute_initial_dmu P dmu_initial)) (Suc m)", "unfolding di"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (d_of dmu_initial) (Suc m) =\n    IArray.of_fun (d_of (compute_initial_dmu P dmu_initial)) (Suc m)", "by (intro iarray_cong refl, auto simp: compute_initial_dmu_def d_of_def)"], ["proof (state)\nthis:\n  di = IArray.of_fun (d_of (compute_initial_dmu P dmu_initial)) (Suc m)\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "from res'"], ["proof (chain)\npicking this:\n  (P, (compute_initial_mfs P,\n       IArray.of_fun\n        (\\<lambda>i.\n            IArray.of_fun\n             (\\<lambda>j.\n                 d\\<mu>_impl fs_init !! i !! j symmod\n                 IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n                  (m - 1) !!\n                 j)\n             i)\n        m,\n       di, IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1)),\n   gi) =\n  (p', state, g_idx')", "have p': \"p' = P\" and g_idx': \"g_idx' = gi\" and state: \n    \"state = (compute_initial_mfs P, IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. d\\<mu>_impl fs_init !! i !! j symmod ?mods !! j) i) m, di, ?mods)\""], ["proof (prove)\nusing this:\n  (P, (compute_initial_mfs P,\n       IArray.of_fun\n        (\\<lambda>i.\n            IArray.of_fun\n             (\\<lambda>j.\n                 d\\<mu>_impl fs_init !! i !! j symmod\n                 IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n                  (m - 1) !!\n                 j)\n             i)\n        m,\n       di, IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1)),\n   gi) =\n  (p', state, g_idx')\n\ngoal (1 subgoal):\n 1. p' = P &&&\n    g_idx' = gi &&&\n    state =\n    (compute_initial_mfs P,\n     IArray.of_fun\n      (\\<lambda>i.\n          IArray.of_fun\n           (\\<lambda>j.\n               d\\<mu>_impl fs_init !! i !! j symmod\n               IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n                (m - 1) !!\n               j)\n           i)\n      m,\n     di, IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1))", "by auto"], ["proof (state)\nthis:\n  p' = P\n  g_idx' = gi\n  state =\n  (compute_initial_mfs P,\n   IArray.of_fun\n    (\\<lambda>i.\n        IArray.of_fun\n         (\\<lambda>j.\n             d\\<mu>_impl fs_init !! i !! j symmod\n             IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n              (m - 1) !!\n             j)\n         i)\n    m,\n   di, IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1))\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx", "unfolding mfs p state p' dmu state_impl_inv.simps g_idx' g_idx"], ["proof (prove)\ngoal (1 subgoal):\n 1. (compute_initial_mfs P = compute_initial_mfs P \\<and>\n     di =\n     IArray.of_fun (d_of (compute_initial_dmu P dmu_initial)) (Suc m) \\<and>\n     IArray.of_fun\n      (\\<lambda>i.\n          IArray.of_fun\n           (\\<lambda>j.\n               d\\<mu>_impl fs_init !! i !! j symmod\n               IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j)\n                (m - 1) !!\n               j)\n           i)\n      m =\n     IArray.of_fun\n      (\\<lambda>i.\n          IArray.of_fun\n           (\\<lambda>j. compute_initial_dmu P dmu_initial $$ (i, j)) i)\n      m \\<and>\n     IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) =\n     IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1)) \\<and>\n    P = P \\<and> gi = gi", "proof (intro conjI refl di' iarray_cong, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < m; ia < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu>_impl fs_init !! i !! ia symmod\n                         IArray.of_fun\n                          (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) !!\n                         ia =\n                         compute_initial_dmu P dmu_initial $$ (i, ia)", "case (1 i j)"], ["proof (state)\nthis:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < m; ia < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu>_impl fs_init !! i !! ia symmod\n                         IArray.of_fun\n                          (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) !!\n                         ia =\n                         compute_initial_dmu P dmu_initial $$ (i, ia)", "hence \"j < m\" \"Suc j < Suc m\" \"j < Suc m\" \"j < m - 1\""], ["proof (prove)\nusing this:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. (j < m &&& Suc j < Suc m) &&& j < Suc m &&& j < m - 1", "by auto"], ["proof (state)\nthis:\n  j < m\n  Suc j < Suc m\n  j < Suc m\n  j < m - 1\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < m; ia < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu>_impl fs_init !! i !! ia symmod\n                         IArray.of_fun\n                          (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) !!\n                         ia =\n                         compute_initial_dmu P dmu_initial $$ (i, ia)", "thus ?case"], ["proof (prove)\nusing this:\n  j < m\n  Suc j < Suc m\n  j < Suc m\n  j < m - 1\n\ngoal (1 subgoal):\n 1. d\\<mu>_impl fs_init !! i !! j symmod\n    IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) !! j =\n    compute_initial_dmu P dmu_initial $$ (i, j)", "unfolding compute_initial_dmu_def di \n        IArray.of_fun_nth[OF \\<open>j < m\\<close>]\n        IArray.of_fun_nth[OF \\<open>Suc j < Suc m\\<close>]\n        IArray.of_fun_nth[OF \\<open>j < Suc m\\<close>]\n        IArray.of_fun_nth[OF \\<open>j < m - 1\\<close>]"], ["proof (prove)\nusing this:\n  j < m\n  Suc j < Suc m\n  j < Suc m\n  j < m - 1\n\ngoal (1 subgoal):\n 1. d\\<mu>_impl fs_init !! i !! j symmod\n    (P * d_of dmu_initial j * d_of dmu_initial (Suc j)) =\n    mat m m\n     (\\<lambda>(i', j').\n         if j' < i'\n         then dmu_initial $$ (i', j') symmod\n              (P * d_of dmu_initial j' * d_of dmu_initial (Suc j'))\n         else dmu_initial $$ (i', j')) $$\n    (i, j)", "unfolding dmu_initial_def Let_def"], ["proof (prove)\nusing this:\n  j < m\n  Suc j < Suc m\n  j < Suc m\n  j < m - 1\n\ngoal (1 subgoal):\n 1. d\\<mu>_impl fs_init !! i !! j symmod\n    (P *\n     d_of\n      (mat m m\n        (\\<lambda>(i, j).\n            if j \\<le> i then d\\<mu>_impl fs_init !! i !! j else 0))\n      j *\n     d_of\n      (mat m m\n        (\\<lambda>(i, j).\n            if j \\<le> i then d\\<mu>_impl fs_init !! i !! j else 0))\n      (Suc j)) =\n    mat m m\n     (\\<lambda>(i', j').\n         if j' < i'\n         then mat m m\n               (\\<lambda>(i, j).\n                   if j \\<le> i then d\\<mu>_impl fs_init !! i !! j\n                   else 0) $$\n              (i', j') symmod\n              (P *\n               d_of\n                (mat m m\n                  (\\<lambda>(i, j).\n                      if j \\<le> i then d\\<mu>_impl fs_init !! i !! j\n                      else 0))\n                j' *\n               d_of\n                (mat m m\n                  (\\<lambda>(i, j).\n                      if j \\<le> i then d\\<mu>_impl fs_init !! i !! j\n                      else 0))\n                (Suc j'))\n         else mat m m\n               (\\<lambda>(i, j).\n                   if j \\<le> i then d\\<mu>_impl fs_init !! i !! j\n                   else 0) $$\n              (i', j')) $$\n    (i, j)", "using 1"], ["proof (prove)\nusing this:\n  j < m\n  Suc j < Suc m\n  j < Suc m\n  j < m - 1\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. d\\<mu>_impl fs_init !! i !! j symmod\n    (P *\n     d_of\n      (mat m m\n        (\\<lambda>(i, j).\n            if j \\<le> i then d\\<mu>_impl fs_init !! i !! j else 0))\n      j *\n     d_of\n      (mat m m\n        (\\<lambda>(i, j).\n            if j \\<le> i then d\\<mu>_impl fs_init !! i !! j else 0))\n      (Suc j)) =\n    mat m m\n     (\\<lambda>(i', j').\n         if j' < i'\n         then mat m m\n               (\\<lambda>(i, j).\n                   if j \\<le> i then d\\<mu>_impl fs_init !! i !! j\n                   else 0) $$\n              (i', j') symmod\n              (P *\n               d_of\n                (mat m m\n                  (\\<lambda>(i, j).\n                      if j \\<le> i then d\\<mu>_impl fs_init !! i !! j\n                      else 0))\n                j' *\n               d_of\n                (mat m m\n                  (\\<lambda>(i, j).\n                      if j \\<le> i then d\\<mu>_impl fs_init !! i !! j\n                      else 0))\n                (Suc j'))\n         else mat m m\n               (\\<lambda>(i, j).\n                   if j \\<le> i then d\\<mu>_impl fs_init !! i !! j\n                   else 0) $$\n              (i', j')) $$\n    (i, j)", "by auto"], ["proof (state)\nthis:\n  d\\<mu>_impl fs_init !! i !! j symmod\n  IArray.of_fun (\\<lambda>j. P * di !! j * di !! Suc j) (m - 1) !! j =\n  compute_initial_dmu P dmu_initial $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_impl_inv p mfs dmu state \\<and> p' = p \\<and> g_idx' = g_idx\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_add_rows_loop: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod fs mfs dmu p b first i\"\n  and res: \"basis_reduction_mod_add_rows_loop p mfs dmu i j = (mfs', dmu')\" \n  and res': \"LLL_add_rows_loop p state i j = state'\" \n  and j: \"j \\<le> i\" \n  and i: \"i < m\" \nshows \"state_impl_inv p mfs' dmu' state'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "using assms(1-5)"], ["proof (prove)\nusing this:\n  state_impl_inv p mfs dmu state\n  LLL_invariant_mod fs mfs dmu p b first i\n  basis_reduction_mod_add_rows_loop p mfs dmu i j = (mfs', dmu')\n  LLL_add_rows_loop p state i j = state'\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "proof (induct j arbitrary: fs mfs dmu state)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "case (Suc j)"], ["proof (state)\nthis:\n  \\<lbrakk>state_impl_inv p ?mfs2 ?dmu2 ?state2;\n   LLL_invariant_mod ?fs2 ?mfs2 ?dmu2 p b first i;\n   basis_reduction_mod_add_rows_loop p ?mfs2 ?dmu2 i j = (mfs', dmu');\n   LLL_add_rows_loop p ?state2 i j = state'; j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n  state_impl_inv p mfs dmu state\n  LLL_invariant_mod fs mfs dmu p b first i\n  basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) = (mfs', dmu')\n  LLL_add_rows_loop p state i (Suc j) = state'\n  Suc j \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note impl = Suc(2)"], ["proof (state)\nthis:\n  state_impl_inv p mfs dmu state\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note Linv = Suc(3)"], ["proof (state)\nthis:\n  LLL_invariant_mod fs mfs dmu p b first i\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note res = Suc(4)"], ["proof (state)\nthis:\n  basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) = (mfs', dmu')\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note res' = Suc(5)"], ["proof (state)\nthis:\n  LLL_add_rows_loop p state i (Suc j) = state'\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note IH = Suc(1)"], ["proof (state)\nthis:\n  \\<lbrakk>state_impl_inv p ?mfs2 ?dmu2 ?state2;\n   LLL_invariant_mod ?fs2 ?mfs2 ?dmu2 p b first i;\n   basis_reduction_mod_add_rows_loop p ?mfs2 ?dmu2 i j = (mfs', dmu');\n   LLL_add_rows_loop p ?state2 i j = state'; j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>state_impl_inv p ?mfs2 ?dmu2 ?state2;\n   LLL_invariant_mod ?fs2 ?mfs2 ?dmu2 p b first i;\n   basis_reduction_mod_add_rows_loop p ?mfs2 ?dmu2 i j = (mfs', dmu');\n   LLL_add_rows_loop p ?state2 i j = state'; j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n  state_impl_inv p mfs dmu state\n  LLL_invariant_mod fs mfs dmu p b first i\n  basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) = (mfs', dmu')\n  LLL_add_rows_loop p state i (Suc j) = state'\n  Suc j \\<le> i", "have j: \"j < i\" and ji: \"j \\<le> i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>state_impl_inv p ?mfs2 ?dmu2 ?state2;\n   LLL_invariant_mod ?fs2 ?mfs2 ?dmu2 p b first i;\n   basis_reduction_mod_add_rows_loop p ?mfs2 ?dmu2 i j = (mfs', dmu');\n   LLL_add_rows_loop p ?state2 i j = state'; j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n  state_impl_inv p mfs dmu state\n  LLL_invariant_mod fs mfs dmu p b first i\n  basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) = (mfs', dmu')\n  LLL_add_rows_loop p state i (Suc j) = state'\n  Suc j \\<le> i\n\ngoal (1 subgoal):\n 1. j < i &&& j \\<le> i", "by auto"], ["proof (state)\nthis:\n  j < i\n  j \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "obtain mfs1 dmu1 where add: \"basis_reduction_mod_add_row p mfs dmu i j = (mfs1, dmu1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfs1 dmu1.\n        basis_reduction_mod_add_row p mfs dmu i j =\n        (mfs1, dmu1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  basis_reduction_mod_add_row p mfs dmu i j = (mfs1, dmu1)\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note res = res[unfolded basis_reduction_mod_add_rows_loop.simps Let_def add split]"], ["proof (state)\nthis:\n  basis_reduction_mod_add_rows_loop p mfs1 dmu1 i j = (mfs', dmu')\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "obtain state1 where add': \"LLL_add_row p state i j = state1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>state1.\n        LLL_add_row p state i j = state1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_add_row p state i j = state1\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note res' = res'[unfolded LLL_add_rows_loop.simps Let_def add']"], ["proof (state)\nthis:\n  LLL_add_rows_loop p state1 i j = state'\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note Linvw = LLL_mod_inv_to_weak[OF Linv]"], ["proof (state)\nthis:\n  LLL_invariant_mod_weak fs mfs dmu p b first\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from LLL_add_row[OF impl Linvw add add' i j]"], ["proof (chain)\npicking this:\n  state_impl_inv p mfs1 dmu1 state1", "have impl1: \"state_impl_inv p mfs1 dmu1 state1\""], ["proof (prove)\nusing this:\n  state_impl_inv p mfs1 dmu1 state1\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs1 dmu1 state1", "."], ["proof (state)\nthis:\n  state_impl_inv p mfs1 dmu1 state1\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from basis_reduction_mod_add_row[OF Linvw add i j] Linv j"], ["proof (chain)\npicking this:\n  i \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>fs'.\n     LLL_invariant_mod_weak fs' mfs1 dmu1 p b first \\<and>\n     LLL_measure i fs' = LLL_measure i fs \\<and>\n     (\\<mu>_small_row i fs (Suc j) \\<longrightarrow>\n      \\<mu>_small_row i fs' j) \\<and>\n     \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n     \\<le> 1 / 2 \\<and>\n     (\\<forall>i' j'.\n         i' < i \\<longrightarrow>\n         j' \\<le> i' \\<longrightarrow>\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i' j' =\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i' j') \\<and>\n     (LLL_invariant_mod fs mfs dmu p b first i \\<longrightarrow>\n      LLL_invariant_mod fs' mfs1 dmu1 p b first i) \\<and>\n     (\\<forall>ii\\<le>m. d fs' ii = d fs ii)\n  LLL_invariant_mod fs mfs dmu p b first i\n  j < i", "obtain fs1 where Linv1: \"LLL_invariant_mod fs1 mfs1 dmu1 p b first i\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>fs'.\n     LLL_invariant_mod_weak fs' mfs1 dmu1 p b first \\<and>\n     LLL_measure i fs' = LLL_measure i fs \\<and>\n     (\\<mu>_small_row i fs (Suc j) \\<longrightarrow>\n      \\<mu>_small_row i fs' j) \\<and>\n     \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n     \\<le> 1 / 2 \\<and>\n     (\\<forall>i' j'.\n         i' < i \\<longrightarrow>\n         j' \\<le> i' \\<longrightarrow>\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i' j' =\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i' j') \\<and>\n     (LLL_invariant_mod fs mfs dmu p b first i \\<longrightarrow>\n      LLL_invariant_mod fs' mfs1 dmu1 p b first i) \\<and>\n     (\\<forall>ii\\<le>m. d fs' ii = d fs ii)\n  LLL_invariant_mod fs mfs dmu p b first i\n  j < i\n\ngoal (1 subgoal):\n 1. (\\<And>fs1.\n        LLL_invariant_mod fs1 mfs1 dmu1 p b first i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_invariant_mod fs1 mfs1 dmu1 p b first i\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>j fs mfs dmu state.\n       \\<lbrakk>\\<And>fs mfs dmu state.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p b first i;\n                    basis_reduction_mod_add_rows_loop p mfs dmu i j =\n                    (mfs', dmu');\n                    LLL_add_rows_loop p state i j = state';\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i (Suc j) =\n        (mfs', dmu');\n        LLL_add_rows_loop p state i (Suc j) = state'; Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "using IH[OF impl1 Linv1 res res' ji]"], ["proof (prove)\nusing this:\n  state_impl_inv p mfs' dmu' state'\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "."], ["proof (state)\nthis:\n  state_impl_inv p mfs' dmu' state'\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p b first i;\n        basis_reduction_mod_add_rows_loop p mfs dmu i 0 = (mfs', dmu');\n        LLL_add_rows_loop p state i 0 = state'; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "qed auto"], ["", "lemma LLL_add_rows_outer_loop: assumes impl: \"state_impl_inv p mfs dmu state\" \n  and Linv: \"LLL_invariant_mod fs mfs dmu p first b m\"\n  and res: \"basis_reduction_mod_add_rows_outer_loop p mfs dmu i = (mfs', dmu')\" \n  and res': \"LLL_add_rows_outer_loop p state i = state'\" \n  and i: \"i \\<le> m - 1\" \nshows \"state_impl_inv p mfs' dmu' state'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "using assms"], ["proof (prove)\nusing this:\n  state_impl_inv p mfs dmu state\n  LLL_invariant_mod fs mfs dmu p first b m\n  basis_reduction_mod_add_rows_outer_loop p mfs dmu i = (mfs', dmu')\n  LLL_add_rows_outer_loop p state i = state'\n  i \\<le> m - 1\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "proof (induct i arbitrary: fs mfs dmu state mfs' dmu' state')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>state_impl_inv p ?mfs2 ?dmu2 ?state2;\n   LLL_invariant_mod ?fs2 ?mfs2 ?dmu2 p first b m;\n   basis_reduction_mod_add_rows_outer_loop p ?mfs2 ?dmu2 i =\n   (?mfs'2, ?dmu'2);\n   LLL_add_rows_outer_loop p ?state2 i = ?state'2; i \\<le> m - 1\\<rbrakk>\n  \\<Longrightarrow> state_impl_inv p ?mfs'2 ?dmu'2 ?state'2\n  state_impl_inv p mfs dmu state\n  LLL_invariant_mod fs mfs dmu p first b m\n  basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) = (mfs', dmu')\n  LLL_add_rows_outer_loop p state (Suc i) = state'\n  Suc i \\<le> m - 1\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note impl = Suc(2)"], ["proof (state)\nthis:\n  state_impl_inv p mfs dmu state\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note Linv = Suc(3)"], ["proof (state)\nthis:\n  LLL_invariant_mod fs mfs dmu p first b m\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note res = Suc(4)"], ["proof (state)\nthis:\n  basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) = (mfs', dmu')\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note res' = Suc(5)"], ["proof (state)\nthis:\n  LLL_add_rows_outer_loop p state (Suc i) = state'\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note i = Suc(6)"], ["proof (state)\nthis:\n  Suc i \\<le> m - 1\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note IH = Suc(1)"], ["proof (state)\nthis:\n  \\<lbrakk>state_impl_inv p ?mfs2 ?dmu2 ?state2;\n   LLL_invariant_mod ?fs2 ?mfs2 ?dmu2 p first b m;\n   basis_reduction_mod_add_rows_outer_loop p ?mfs2 ?dmu2 i =\n   (?mfs'2, ?dmu'2);\n   LLL_add_rows_outer_loop p ?state2 i = ?state'2; i \\<le> m - 1\\<rbrakk>\n  \\<Longrightarrow> state_impl_inv p ?mfs'2 ?dmu'2 ?state'2\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from i"], ["proof (chain)\npicking this:\n  Suc i \\<le> m - 1", "have im: \"i < m\" \"i \\<le> m - 1\" \"Suc i < m\""], ["proof (prove)\nusing this:\n  Suc i \\<le> m - 1\n\ngoal (1 subgoal):\n 1. i < m &&& i \\<le> m - 1 &&& Suc i < m", "by auto"], ["proof (state)\nthis:\n  i < m\n  i \\<le> m - 1\n  Suc i < m\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "obtain mfs1 dmu1 where add: \"basis_reduction_mod_add_rows_outer_loop p mfs dmu i = (mfs1, dmu1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfs1 dmu1.\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n        (mfs1, dmu1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  basis_reduction_mod_add_rows_outer_loop p mfs dmu i = (mfs1, dmu1)\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note res = res[unfolded basis_reduction_mod_add_rows_outer_loop.simps Let_def add split]"], ["proof (state)\nthis:\n  basis_reduction_mod_add_rows_loop p mfs1 dmu1 (Suc i) (Suc i) =\n  (mfs', dmu')\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "obtain state1 where add': \"LLL_add_rows_outer_loop p state i = state1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>state1.\n        LLL_add_rows_outer_loop p state i = state1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_add_rows_outer_loop p state i = state1\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "note res' = res'[unfolded LLL_add_rows_outer_loop.simps Let_def add']"], ["proof (state)\nthis:\n  LLL_add_rows_loop p state1 (Suc i) (Suc i) = state'\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from IH[OF impl Linv add add' im(2)]"], ["proof (chain)\npicking this:\n  state_impl_inv p mfs1 dmu1 state1", "have impl1: \"state_impl_inv p mfs1 dmu1 state1\""], ["proof (prove)\nusing this:\n  state_impl_inv p mfs1 dmu1 state1\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs1 dmu1 state1", "."], ["proof (state)\nthis:\n  state_impl_inv p mfs1 dmu1 state1\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from basis_reduction_mod_add_rows_outer_loop_inv[OF Linv add[symmetric] im(1)]"], ["proof (chain)\npicking this:\n  \\<exists>fs'.\n     LLL_invariant_mod fs' mfs1 dmu1 p first b m \\<and>\n     (\\<forall>j\\<le>i. \\<mu>_small fs' j)", "obtain fs1 where Linv1: \"LLL_invariant_mod fs1 mfs1 dmu1 p first b m\""], ["proof (prove)\nusing this:\n  \\<exists>fs'.\n     LLL_invariant_mod fs' mfs1 dmu1 p first b m \\<and>\n     (\\<forall>j\\<le>i. \\<mu>_small fs' j)\n\ngoal (1 subgoal):\n 1. (\\<And>fs1.\n        LLL_invariant_mod fs1 mfs1 dmu1 p first b m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_invariant_mod fs1 mfs1 dmu1 p first b m\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from basis_reduction_mod_add_rows_loop_inv'[OF Linv1 res im(3)]"], ["proof (chain)\npicking this:\n  \\<exists>fs'.\n     LLL_invariant_mod fs' mfs' dmu' p first b m \\<and>\n     (\\<forall>i' j'.\n         i' < Suc i \\<longrightarrow>\n         j' \\<le> i' \\<longrightarrow>\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs1) i' j' =\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i' j') \\<and>\n     \\<mu>_small fs' (Suc i)", "obtain fs' where \n    Linv': \"LLL_invariant_mod fs' mfs' dmu' p first b m\""], ["proof (prove)\nusing this:\n  \\<exists>fs'.\n     LLL_invariant_mod fs' mfs' dmu' p first b m \\<and>\n     (\\<forall>i' j'.\n         i' < Suc i \\<longrightarrow>\n         j' \\<le> i' \\<longrightarrow>\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs1) i' j' =\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i' j') \\<and>\n     \\<mu>_small fs' (Suc i)\n\ngoal (1 subgoal):\n 1. (\\<And>fs'.\n        LLL_invariant_mod fs' mfs' dmu' p first b m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_invariant_mod fs' mfs' dmu' p first b m\n\ngoal (2 subgoals):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n 2. \\<And>i fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>\\<And>fs mfs dmu state mfs' dmu' state'.\n                   \\<lbrakk>state_impl_inv p mfs dmu state;\n                    LLL_invariant_mod fs mfs dmu p first b m;\n                    basis_reduction_mod_add_rows_outer_loop p mfs dmu i =\n                    (mfs', dmu');\n                    LLL_add_rows_outer_loop p state i = state';\n                    i \\<le> m - 1\\<rbrakk>\n                   \\<Longrightarrow> state_impl_inv p mfs' dmu' state';\n        state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu (Suc i) =\n        (mfs', dmu');\n        LLL_add_rows_outer_loop p state (Suc i) = state';\n        Suc i \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "from LLL_add_rows_loop[OF impl1 LLL_invariant_mod_to_weak_m_to_i(1)[OF Linv1] res res' le_refl im(3)] i"], ["proof (chain)\npicking this:\n  Suc i \\<le> m \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n  Suc i \\<le> m - 1", "show ?case"], ["proof (prove)\nusing this:\n  Suc i \\<le> m \\<Longrightarrow> state_impl_inv p mfs' dmu' state'\n  Suc i \\<le> m - 1\n\ngoal (1 subgoal):\n 1. state_impl_inv p mfs' dmu' state'", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p mfs' dmu' state'\n\ngoal (1 subgoal):\n 1. \\<And>fs mfs dmu state mfs' dmu' state'.\n       \\<lbrakk>state_impl_inv p mfs dmu state;\n        LLL_invariant_mod fs mfs dmu p first b m;\n        basis_reduction_mod_add_rows_outer_loop p mfs dmu 0 = (mfs', dmu');\n        LLL_add_rows_outer_loop p state 0 = state'; 0 \\<le> m - 1\\<rbrakk>\n       \\<Longrightarrow> state_impl_inv p mfs' dmu' state'", "qed auto"], ["", "subsection \\<open>Soundness of implementation\\<close>"], ["", "text \\<open>We just prove that the concrete implementations have the same input-output-behaviour as\n  the abstract versions of Storjohann's algorithms.\\<close>"], ["", "lemma LLL_reduce_basis: \"LLL_reduce_basis = reduce_basis_mod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_reduce_basis = reduce_basis_mod", "proof (cases \"m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod\n 2. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "case True"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod\n 2. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "from LLL_invD[OF reduce_basis_mod_inv[OF refl]] True"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom reduce_basis_mod)\n  length (map of_int_hom.vec_hom reduce_basis_mod) = m\n  set reduce_basis_mod \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> reduce_basis_mod ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom reduce_basis_mod) ?i\n  \\<in> Rn\n  length reduce_basis_mod = m\n  lattice_of reduce_basis_mod = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom reduce_basis_mod)\n   \\<alpha> m\n  m \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom reduce_basis_mod)\n   \\<alpha> m\n  True \\<or> \\<mu>_small reduce_basis_mod m\n  m = 0", "have \"reduce_basis_mod = []\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom reduce_basis_mod)\n  length (map of_int_hom.vec_hom reduce_basis_mod) = m\n  set reduce_basis_mod \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> reduce_basis_mod ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom reduce_basis_mod) ?i\n  \\<in> Rn\n  length reduce_basis_mod = m\n  lattice_of reduce_basis_mod = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom reduce_basis_mod)\n   \\<alpha> m\n  m \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom reduce_basis_mod)\n   \\<alpha> m\n  True \\<or> \\<mu>_small reduce_basis_mod m\n  m = 0\n\ngoal (1 subgoal):\n 1. reduce_basis_mod = []", "by auto"], ["proof (state)\nthis:\n  reduce_basis_mod = []\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod\n 2. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "thus ?thesis"], ["proof (prove)\nusing this:\n  reduce_basis_mod = []\n\ngoal (1 subgoal):\n 1. LLL_reduce_basis = reduce_basis_mod", "using True"], ["proof (prove)\nusing this:\n  reduce_basis_mod = []\n  m = 0\n\ngoal (1 subgoal):\n 1. LLL_reduce_basis = reduce_basis_mod", "unfolding LLL_reduce_basis_def"], ["proof (prove)\nusing this:\n  reduce_basis_mod = []\n  m = 0\n\ngoal (1 subgoal):\n 1. (if m = 0 then []\n     else let first = False; (p0, state0, g_idx0) = LLL_initial first;\n              (p, state) = LLL_main p0 first state0 g_idx0 0 0;\n              (mfs, uu_, uu_, uu_) = LLL_add_rows_outer_loop p state (m - 1)\n          in mfs) =\n    reduce_basis_mod", "by auto"], ["proof (state)\nthis:\n  LLL_reduce_basis = reduce_basis_mod\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "case False"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "hence idm: \"(m = 0) = False\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (m = 0) = False", "by auto"], ["proof (state)\nthis:\n  (m = 0) = False\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "let ?first = False"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "obtain p1 mfs1 dmu1 g_idx1 where init: \"compute_initial_state ?first = (p1, mfs1, dmu1,g_idx1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 mfs1 dmu1 g_idx1.\n        compute_initial_state False =\n        (p1, mfs1, dmu1, g_idx1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  compute_initial_state False = (p1, mfs1, dmu1, g_idx1)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "obtain p1' state1 g_idx1' where init': \"LLL_initial ?first = (p1', state1, g_idx1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1' state1 g_idx1'.\n        LLL_initial False = (p1', state1, g_idx1') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  LLL_initial False = (p1', state1, g_idx1')\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "from LLL_initial[OF init init' False]"], ["proof (chain)\npicking this:\n  state_impl_inv p1 mfs1 dmu1 state1 \\<and> p1' = p1 \\<and> g_idx1' = g_idx1", "have impl1: \"state_impl_inv p1 mfs1 dmu1 state1\" and id: \"p1' = p1\" \"g_idx1' = g_idx1\""], ["proof (prove)\nusing this:\n  state_impl_inv p1 mfs1 dmu1 state1 \\<and> p1' = p1 \\<and> g_idx1' = g_idx1\n\ngoal (1 subgoal):\n 1. state_impl_inv p1 mfs1 dmu1 state1 &&& p1' = p1 &&& g_idx1' = g_idx1", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p1 mfs1 dmu1 state1\n  p1' = p1\n  g_idx1' = g_idx1\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "from LLL_initial_invariant_mod[OF init]"], ["proof (chain)\npicking this:\n  \\<exists>fs b. LLL_invariant_mod fs mfs1 dmu1 p1 False b 0", "obtain fs1 b1 where \n    inv1: \"LLL_invariant_mod fs1 mfs1 dmu1 p1 ?first b1 0\""], ["proof (prove)\nusing this:\n  \\<exists>fs b. LLL_invariant_mod fs mfs1 dmu1 p1 False b 0\n\ngoal (1 subgoal):\n 1. (\\<And>fs1 b1.\n        LLL_invariant_mod fs1 mfs1 dmu1 p1 False b1 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_invariant_mod fs1 mfs1 dmu1 p1 False b1 0\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "obtain p2 mfs2 dmu2 where main: \"basis_reduction_mod_main p1 ?first mfs1 dmu1 g_idx1 0 0 = (p2, mfs2, dmu2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2 mfs2 dmu2.\n        basis_reduction_mod_main p1 False mfs1 dmu1 g_idx1 0 0 =\n        (p2, mfs2, dmu2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  basis_reduction_mod_main p1 False mfs1 dmu1 g_idx1 0 0 = (p2, mfs2, dmu2)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "from basis_reduction_mod_main[OF inv1 main]"], ["proof (chain)\npicking this:\n  \\<exists>fs' b'. LLL_invariant_mod fs' mfs2 dmu2 p2 False b' m", "obtain fs2 b2 where \n    inv2: \" LLL_invariant_mod fs2 mfs2 dmu2 p2 ?first b2 m\""], ["proof (prove)\nusing this:\n  \\<exists>fs' b'. LLL_invariant_mod fs' mfs2 dmu2 p2 False b' m\n\ngoal (1 subgoal):\n 1. (\\<And>fs2 b2.\n        LLL_invariant_mod fs2 mfs2 dmu2 p2 False b2 m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_invariant_mod fs2 mfs2 dmu2 p2 False b2 m\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "obtain p2' state2 where main': \"LLL_main p1 ?first state1 g_idx1 0 0 = (p2', state2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2' state2.\n        LLL_main p1 False state1 g_idx1 0 0 =\n        (p2', state2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  LLL_main p1 False state1 g_idx1 0 0 = (p2', state2)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "from LLL_main[OF impl1 inv1 main, unfolded id, OF main']"], ["proof (chain)\npicking this:\n  state_impl_inv p2 mfs2 dmu2 state2 \\<and> p2' = p2", "have impl2: \"state_impl_inv p2 mfs2 dmu2 state2\" and p2: \"p2' = p2\""], ["proof (prove)\nusing this:\n  state_impl_inv p2 mfs2 dmu2 state2 \\<and> p2' = p2\n\ngoal (1 subgoal):\n 1. state_impl_inv p2 mfs2 dmu2 state2 &&& p2' = p2", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p2 mfs2 dmu2 state2\n  p2' = p2\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "obtain mfs3 dmu3 where outer: \"basis_reduction_mod_add_rows_outer_loop p2 mfs2 dmu2 (m - 1) = (mfs3, dmu3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfs3 dmu3.\n        basis_reduction_mod_add_rows_outer_loop p2 mfs2 dmu2 (m - 1) =\n        (mfs3, dmu3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  basis_reduction_mod_add_rows_outer_loop p2 mfs2 dmu2 (m - 1) =\n  (mfs3, dmu3)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "obtain mfsi3 dmui3 di3 mods3 where outer': \"LLL_add_rows_outer_loop p2 state2 (m - 1) = (mfsi3, dmui3, di3, mods3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfsi3 dmui3 di3 mods3.\n        LLL_add_rows_outer_loop p2 state2 (m - 1) =\n        (mfsi3, dmui3, di3, mods3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases4)"], ["proof (state)\nthis:\n  LLL_add_rows_outer_loop p2 state2 (m - 1) = (mfsi3, dmui3, di3, mods3)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "from LLL_add_rows_outer_loop[OF impl2 inv2 outer outer' le_refl]"], ["proof (chain)\npicking this:\n  state_impl_inv p2 mfs3 dmu3 (mfsi3, dmui3, di3, mods3)", "have \"state_impl_inv p2 mfs3 dmu3 (mfsi3, dmui3, di3, mods3)\""], ["proof (prove)\nusing this:\n  state_impl_inv p2 mfs3 dmu3 (mfsi3, dmui3, di3, mods3)\n\ngoal (1 subgoal):\n 1. state_impl_inv p2 mfs3 dmu3 (mfsi3, dmui3, di3, mods3)", "."], ["proof (state)\nthis:\n  state_impl_inv p2 mfs3 dmu3 (mfsi3, dmui3, di3, mods3)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "hence identity: \"mfs3 = mfsi3\""], ["proof (prove)\nusing this:\n  state_impl_inv p2 mfs3 dmu3 (mfsi3, dmui3, di3, mods3)\n\ngoal (1 subgoal):\n 1. mfs3 = mfsi3", "unfolding state_impl_inv.simps"], ["proof (prove)\nusing this:\n  mfsi3 = mfs3 \\<and>\n  di3 = IArray.of_fun (d_of dmu3) (Suc m) \\<and>\n  dmui3 =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu3 $$ (i, j)) i)\n   m \\<and>\n  mods3 = IArray.of_fun (\\<lambda>j. p2 * di3 !! j * di3 !! Suc j) (m - 1)\n\ngoal (1 subgoal):\n 1. mfs3 = mfsi3", "by auto"], ["proof (state)\nthis:\n  mfs3 = mfsi3\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "note res = reduce_basis_mod_def[unfolded init main split Let_def outer]"], ["proof (state)\nthis:\n  reduce_basis_mod = mfs3\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "note res' = LLL_reduce_basis_def[unfolded init' Let_def main' id split p2 outer' idm if_False]"], ["proof (state)\nthis:\n  LLL_reduce_basis = mfsi3\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis = reduce_basis_mod", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_reduce_basis = reduce_basis_mod", "unfolding res res' identity"], ["proof (prove)\ngoal (1 subgoal):\n 1. mfsi3 = mfsi3", ".."], ["proof (state)\nthis:\n  LLL_reduce_basis = reduce_basis_mod\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_reduce_basis_iso: \"LLL_reduce_basis_iso = reduce_basis_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_reduce_basis_iso = reduce_basis_iso", "proof (cases \"m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso\n 2. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "case True"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso\n 2. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "from LLL_invD[OF reduce_basis_iso_inv[OF refl]] True"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom reduce_basis_iso)\n  length (map of_int_hom.vec_hom reduce_basis_iso) = m\n  set reduce_basis_iso \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> reduce_basis_iso ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom reduce_basis_iso) ?i\n  \\<in> Rn\n  length reduce_basis_iso = m\n  lattice_of reduce_basis_iso = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom reduce_basis_iso)\n   \\<alpha> m\n  m \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom reduce_basis_iso)\n   \\<alpha> m\n  True \\<or> \\<mu>_small reduce_basis_iso m\n  m = 0", "have \"reduce_basis_iso = []\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom reduce_basis_iso)\n  length (map of_int_hom.vec_hom reduce_basis_iso) = m\n  set reduce_basis_iso \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> reduce_basis_iso ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom reduce_basis_iso) ?i\n  \\<in> Rn\n  length reduce_basis_iso = m\n  lattice_of reduce_basis_iso = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom reduce_basis_iso)\n   \\<alpha> m\n  m \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom reduce_basis_iso)\n   \\<alpha> m\n  True \\<or> \\<mu>_small reduce_basis_iso m\n  m = 0\n\ngoal (1 subgoal):\n 1. reduce_basis_iso = []", "by auto"], ["proof (state)\nthis:\n  reduce_basis_iso = []\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso\n 2. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "thus ?thesis"], ["proof (prove)\nusing this:\n  reduce_basis_iso = []\n\ngoal (1 subgoal):\n 1. LLL_reduce_basis_iso = reduce_basis_iso", "using True"], ["proof (prove)\nusing this:\n  reduce_basis_iso = []\n  m = 0\n\ngoal (1 subgoal):\n 1. LLL_reduce_basis_iso = reduce_basis_iso", "unfolding LLL_reduce_basis_iso_def"], ["proof (prove)\nusing this:\n  reduce_basis_iso = []\n  m = 0\n\ngoal (1 subgoal):\n 1. (if m = 0 then []\n     else let first = False; (p0, state0, g_idx0) = LLL_initial first;\n              (p, state) = LLL_iso_main p0 first state0 g_idx0 0;\n              (mfs, uu_, uu_, uu_) = LLL_add_rows_outer_loop p state (m - 1)\n          in mfs) =\n    reduce_basis_iso", "by auto"], ["proof (state)\nthis:\n  LLL_reduce_basis_iso = reduce_basis_iso\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "case False"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "hence idm: \"(m = 0) = False\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (m = 0) = False", "by auto"], ["proof (state)\nthis:\n  (m = 0) = False\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "let ?first = False"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "obtain p1 mfs1 dmu1 g_idx1 where init: \"compute_initial_state ?first = (p1, mfs1, dmu1, g_idx1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 mfs1 dmu1 g_idx1.\n        compute_initial_state False =\n        (p1, mfs1, dmu1, g_idx1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  compute_initial_state False = (p1, mfs1, dmu1, g_idx1)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "obtain p1' state1 g_idx1' where init': \"LLL_initial ?first = (p1', state1, g_idx1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1' state1 g_idx1'.\n        LLL_initial False = (p1', state1, g_idx1') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  LLL_initial False = (p1', state1, g_idx1')\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "from LLL_initial[OF init init' False]"], ["proof (chain)\npicking this:\n  state_impl_inv p1 mfs1 dmu1 state1 \\<and> p1' = p1 \\<and> g_idx1' = g_idx1", "have impl1: \"state_impl_inv p1 mfs1 dmu1 state1\" and id: \"p1' = p1\" \"g_idx1' = g_idx1\""], ["proof (prove)\nusing this:\n  state_impl_inv p1 mfs1 dmu1 state1 \\<and> p1' = p1 \\<and> g_idx1' = g_idx1\n\ngoal (1 subgoal):\n 1. state_impl_inv p1 mfs1 dmu1 state1 &&& p1' = p1 &&& g_idx1' = g_idx1", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p1 mfs1 dmu1 state1\n  p1' = p1\n  g_idx1' = g_idx1\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "from LLL_initial_invariant_mod[OF init]"], ["proof (chain)\npicking this:\n  \\<exists>fs b. LLL_invariant_mod fs mfs1 dmu1 p1 False b 0", "obtain fs1 b1 where \n    inv1: \"LLL_invariant_mod_weak fs1 mfs1 dmu1 p1 ?first b1\""], ["proof (prove)\nusing this:\n  \\<exists>fs b. LLL_invariant_mod fs mfs1 dmu1 p1 False b 0\n\ngoal (1 subgoal):\n 1. (\\<And>fs1 b1.\n        LLL_invariant_mod_weak fs1 mfs1 dmu1 p1 False b1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: LLL_invariant_mod_weak_def LLL_invariant_mod_def)"], ["proof (state)\nthis:\n  LLL_invariant_mod_weak fs1 mfs1 dmu1 p1 False b1\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "obtain p2 mfs2 dmu2 where main: \"basis_reduction_iso_main p1 ?first mfs1 dmu1 g_idx1 0 = (p2, mfs2, dmu2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2 mfs2 dmu2.\n        basis_reduction_iso_main p1 False mfs1 dmu1 g_idx1 0 =\n        (p2, mfs2, dmu2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  basis_reduction_iso_main p1 False mfs1 dmu1 g_idx1 0 = (p2, mfs2, dmu2)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "from basis_reduction_iso_main[OF inv1 main]"], ["proof (chain)\npicking this:\n  \\<exists>fs' b'. LLL_invariant_mod fs' mfs2 dmu2 p2 False b' m", "obtain fs2 b2 where \n    inv2: \" LLL_invariant_mod fs2 mfs2 dmu2 p2 ?first b2 m\""], ["proof (prove)\nusing this:\n  \\<exists>fs' b'. LLL_invariant_mod fs' mfs2 dmu2 p2 False b' m\n\ngoal (1 subgoal):\n 1. (\\<And>fs2 b2.\n        LLL_invariant_mod fs2 mfs2 dmu2 p2 False b2 m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_invariant_mod fs2 mfs2 dmu2 p2 False b2 m\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "obtain p2' state2 where main': \"LLL_iso_main p1 ?first state1 g_idx1 0 = (p2', state2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2' state2.\n        LLL_iso_main p1 False state1 g_idx1 0 =\n        (p2', state2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  LLL_iso_main p1 False state1 g_idx1 0 = (p2', state2)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "from LLL_iso_main[OF impl1 inv1 main, unfolded id, OF main']"], ["proof (chain)\npicking this:\n  state_impl_inv p2 mfs2 dmu2 state2 \\<and> p2' = p2", "have impl2: \"state_impl_inv p2 mfs2 dmu2 state2\" and p2: \"p2' = p2\""], ["proof (prove)\nusing this:\n  state_impl_inv p2 mfs2 dmu2 state2 \\<and> p2' = p2\n\ngoal (1 subgoal):\n 1. state_impl_inv p2 mfs2 dmu2 state2 &&& p2' = p2", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p2 mfs2 dmu2 state2\n  p2' = p2\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "obtain mfs3 dmu3 where outer: \"basis_reduction_mod_add_rows_outer_loop p2 mfs2 dmu2 (m - 1) = (mfs3, dmu3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfs3 dmu3.\n        basis_reduction_mod_add_rows_outer_loop p2 mfs2 dmu2 (m - 1) =\n        (mfs3, dmu3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  basis_reduction_mod_add_rows_outer_loop p2 mfs2 dmu2 (m - 1) =\n  (mfs3, dmu3)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "obtain mfsi3 dmui3 di3 mods3 where outer': \"LLL_add_rows_outer_loop p2 state2 (m - 1) = (mfsi3, dmui3, di3, mods3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mfsi3 dmui3 di3 mods3.\n        LLL_add_rows_outer_loop p2 state2 (m - 1) =\n        (mfsi3, dmui3, di3, mods3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases4)"], ["proof (state)\nthis:\n  LLL_add_rows_outer_loop p2 state2 (m - 1) = (mfsi3, dmui3, di3, mods3)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "from LLL_add_rows_outer_loop[OF impl2 inv2 outer outer' le_refl]"], ["proof (chain)\npicking this:\n  state_impl_inv p2 mfs3 dmu3 (mfsi3, dmui3, di3, mods3)", "have \"state_impl_inv p2 mfs3 dmu3 (mfsi3, dmui3, di3, mods3)\""], ["proof (prove)\nusing this:\n  state_impl_inv p2 mfs3 dmu3 (mfsi3, dmui3, di3, mods3)\n\ngoal (1 subgoal):\n 1. state_impl_inv p2 mfs3 dmu3 (mfsi3, dmui3, di3, mods3)", "."], ["proof (state)\nthis:\n  state_impl_inv p2 mfs3 dmu3 (mfsi3, dmui3, di3, mods3)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "hence identity: \"mfs3 = mfsi3\""], ["proof (prove)\nusing this:\n  state_impl_inv p2 mfs3 dmu3 (mfsi3, dmui3, di3, mods3)\n\ngoal (1 subgoal):\n 1. mfs3 = mfsi3", "unfolding state_impl_inv.simps"], ["proof (prove)\nusing this:\n  mfsi3 = mfs3 \\<and>\n  di3 = IArray.of_fun (d_of dmu3) (Suc m) \\<and>\n  dmui3 =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu3 $$ (i, j)) i)\n   m \\<and>\n  mods3 = IArray.of_fun (\\<lambda>j. p2 * di3 !! j * di3 !! Suc j) (m - 1)\n\ngoal (1 subgoal):\n 1. mfs3 = mfsi3", "by auto"], ["proof (state)\nthis:\n  mfs3 = mfsi3\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "note res = reduce_basis_iso_def[unfolded init main split Let_def outer]"], ["proof (state)\nthis:\n  reduce_basis_iso = mfs3\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "note res' = LLL_reduce_basis_iso_def[unfolded init' Let_def main' id split p2 outer' idm if_False]"], ["proof (state)\nthis:\n  LLL_reduce_basis_iso = mfsi3\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> LLL_reduce_basis_iso = reduce_basis_iso", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_reduce_basis_iso = reduce_basis_iso", "unfolding res res' identity"], ["proof (prove)\ngoal (1 subgoal):\n 1. mfsi3 = mfsi3", ".."], ["proof (state)\nthis:\n  LLL_reduce_basis_iso = reduce_basis_iso\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_short_vector: assumes m: \"m \\<noteq> 0\" \n  shows \"LLL_short_vector = short_vector_mod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "let ?first = True"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "obtain p1 mfs1 dmu1 g_idx1 where init: \"compute_initial_state ?first = (p1, mfs1, dmu1,g_idx1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 mfs1 dmu1 g_idx1.\n        compute_initial_state True =\n        (p1, mfs1, dmu1, g_idx1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  compute_initial_state True = (p1, mfs1, dmu1, g_idx1)\n\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "obtain p1' state1 g_idx1' where init': \"LLL_initial ?first = (p1', state1, g_idx1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1' state1 g_idx1'.\n        LLL_initial True = (p1', state1, g_idx1') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  LLL_initial True = (p1', state1, g_idx1')\n\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "from LLL_initial[OF init init' m]"], ["proof (chain)\npicking this:\n  state_impl_inv p1 mfs1 dmu1 state1 \\<and> p1' = p1 \\<and> g_idx1' = g_idx1", "have impl1: \"state_impl_inv p1 mfs1 dmu1 state1\" and id: \"p1' = p1\" \"g_idx1' = g_idx1\""], ["proof (prove)\nusing this:\n  state_impl_inv p1 mfs1 dmu1 state1 \\<and> p1' = p1 \\<and> g_idx1' = g_idx1\n\ngoal (1 subgoal):\n 1. state_impl_inv p1 mfs1 dmu1 state1 &&& p1' = p1 &&& g_idx1' = g_idx1", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p1 mfs1 dmu1 state1\n  p1' = p1\n  g_idx1' = g_idx1\n\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "from LLL_initial_invariant_mod[OF init]"], ["proof (chain)\npicking this:\n  \\<exists>fs b. LLL_invariant_mod fs mfs1 dmu1 p1 True b 0", "obtain fs1 b1 where \n    inv1: \"LLL_invariant_mod fs1 mfs1 dmu1 p1 ?first b1 0\""], ["proof (prove)\nusing this:\n  \\<exists>fs b. LLL_invariant_mod fs mfs1 dmu1 p1 True b 0\n\ngoal (1 subgoal):\n 1. (\\<And>fs1 b1.\n        LLL_invariant_mod fs1 mfs1 dmu1 p1 True b1 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_invariant_mod fs1 mfs1 dmu1 p1 True b1 0\n\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "obtain p2 mfs2 dmu2 where main: \"basis_reduction_mod_main p1 ?first mfs1 dmu1 g_idx1 0 0 = (p2, mfs2, dmu2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2 mfs2 dmu2.\n        basis_reduction_mod_main p1 True mfs1 dmu1 g_idx1 0 0 =\n        (p2, mfs2, dmu2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  basis_reduction_mod_main p1 True mfs1 dmu1 g_idx1 0 0 = (p2, mfs2, dmu2)\n\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "from basis_reduction_mod_main[OF inv1 main]"], ["proof (chain)\npicking this:\n  \\<exists>fs' b'. LLL_invariant_mod fs' mfs2 dmu2 p2 True b' m", "obtain fs2 b2 where \n    inv2: \" LLL_invariant_mod fs2 mfs2 dmu2 p2 ?first b2 m\""], ["proof (prove)\nusing this:\n  \\<exists>fs' b'. LLL_invariant_mod fs' mfs2 dmu2 p2 True b' m\n\ngoal (1 subgoal):\n 1. (\\<And>fs2 b2.\n        LLL_invariant_mod fs2 mfs2 dmu2 p2 True b2 m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_invariant_mod fs2 mfs2 dmu2 p2 True b2 m\n\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "obtain p2' mfsi2 dmui2 di2 mods2 where main': \"LLL_main p1 ?first state1 g_idx1 0 0 = (p2', (mfsi2, dmui2, di2, mods2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2' mfsi2 dmui2 di2 mods2.\n        LLL_main p1 True state1 g_idx1 0 0 =\n        (p2', mfsi2, dmui2, di2, mods2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  LLL_main p1 True state1 g_idx1 0 0 = (p2', mfsi2, dmui2, di2, mods2)\n\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "from LLL_main[OF impl1 inv1 main, unfolded id, OF main']"], ["proof (chain)\npicking this:\n  state_impl_inv p2 mfs2 dmu2 (mfsi2, dmui2, di2, mods2) \\<and> p2' = p2", "have impl2: \"state_impl_inv p2 mfs2 dmu2 (mfsi2, dmui2, di2, mods2)\" and p2: \"p2' = p2\""], ["proof (prove)\nusing this:\n  state_impl_inv p2 mfs2 dmu2 (mfsi2, dmui2, di2, mods2) \\<and> p2' = p2\n\ngoal (1 subgoal):\n 1. state_impl_inv p2 mfs2 dmu2 (mfsi2, dmui2, di2, mods2) &&& p2' = p2", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p2 mfs2 dmu2 (mfsi2, dmui2, di2, mods2)\n  p2' = p2\n\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "hence identity: \"mfs2 = mfsi2\""], ["proof (prove)\nusing this:\n  state_impl_inv p2 mfs2 dmu2 (mfsi2, dmui2, di2, mods2)\n  p2' = p2\n\ngoal (1 subgoal):\n 1. mfs2 = mfsi2", "unfolding state_impl_inv.simps"], ["proof (prove)\nusing this:\n  mfsi2 = mfs2 \\<and>\n  di2 = IArray.of_fun (d_of dmu2) (Suc m) \\<and>\n  dmui2 =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu2 $$ (i, j)) i)\n   m \\<and>\n  mods2 = IArray.of_fun (\\<lambda>j. p2 * di2 !! j * di2 !! Suc j) (m - 1)\n  p2' = p2\n\ngoal (1 subgoal):\n 1. mfs2 = mfsi2", "by auto"], ["proof (state)\nthis:\n  mfs2 = mfsi2\n\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "note res = short_vector_mod_def[unfolded init main split Let_def]"], ["proof (state)\nthis:\n  short_vector_mod = hd mfs2\n\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "note res' = LLL_short_vector_def[unfolded init' Let_def main' id split p2]"], ["proof (state)\nthis:\n  LLL_short_vector = hd mfsi2\n\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_short_vector = short_vector_mod", "unfolding res res' identity"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd mfsi2 = hd mfsi2", ".."], ["proof (state)\nthis:\n  LLL_short_vector = short_vector_mod\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_short_vector_iso: assumes m: \"m \\<noteq> 0\" \n  shows \"LLL_short_vector_iso = short_vector_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "let ?first = True"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "obtain p1 mfs1 dmu1 g_idx1 where init: \"compute_initial_state ?first = (p1, mfs1, dmu1,g_idx1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 mfs1 dmu1 g_idx1.\n        compute_initial_state True =\n        (p1, mfs1, dmu1, g_idx1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  compute_initial_state True = (p1, mfs1, dmu1, g_idx1)\n\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "obtain p1' state1 g_idx1' where init': \"LLL_initial ?first = (p1', state1, g_idx1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1' state1 g_idx1'.\n        LLL_initial True = (p1', state1, g_idx1') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  LLL_initial True = (p1', state1, g_idx1')\n\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "from LLL_initial[OF init init' m]"], ["proof (chain)\npicking this:\n  state_impl_inv p1 mfs1 dmu1 state1 \\<and> p1' = p1 \\<and> g_idx1' = g_idx1", "have impl1: \"state_impl_inv p1 mfs1 dmu1 state1\" and id: \"p1' = p1\" \"g_idx1' = g_idx1\""], ["proof (prove)\nusing this:\n  state_impl_inv p1 mfs1 dmu1 state1 \\<and> p1' = p1 \\<and> g_idx1' = g_idx1\n\ngoal (1 subgoal):\n 1. state_impl_inv p1 mfs1 dmu1 state1 &&& p1' = p1 &&& g_idx1' = g_idx1", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p1 mfs1 dmu1 state1\n  p1' = p1\n  g_idx1' = g_idx1\n\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "from LLL_initial_invariant_mod[OF init]"], ["proof (chain)\npicking this:\n  \\<exists>fs b. LLL_invariant_mod fs mfs1 dmu1 p1 True b 0", "obtain fs1 b1 where \n    inv1: \"LLL_invariant_mod_weak fs1 mfs1 dmu1 p1 ?first b1\""], ["proof (prove)\nusing this:\n  \\<exists>fs b. LLL_invariant_mod fs mfs1 dmu1 p1 True b 0\n\ngoal (1 subgoal):\n 1. (\\<And>fs1 b1.\n        LLL_invariant_mod_weak fs1 mfs1 dmu1 p1 True b1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: LLL_invariant_mod_weak_def LLL_invariant_mod_def)"], ["proof (state)\nthis:\n  LLL_invariant_mod_weak fs1 mfs1 dmu1 p1 True b1\n\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "obtain p2 mfs2 dmu2 where main: \"basis_reduction_iso_main p1 ?first mfs1 dmu1 g_idx1 0 = (p2, mfs2, dmu2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2 mfs2 dmu2.\n        basis_reduction_iso_main p1 True mfs1 dmu1 g_idx1 0 =\n        (p2, mfs2, dmu2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  basis_reduction_iso_main p1 True mfs1 dmu1 g_idx1 0 = (p2, mfs2, dmu2)\n\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "from basis_reduction_iso_main[OF inv1 main]"], ["proof (chain)\npicking this:\n  \\<exists>fs' b'. LLL_invariant_mod fs' mfs2 dmu2 p2 True b' m", "obtain fs2 b2 where \n    inv2: \" LLL_invariant_mod fs2 mfs2 dmu2 p2 ?first b2 m\""], ["proof (prove)\nusing this:\n  \\<exists>fs' b'. LLL_invariant_mod fs' mfs2 dmu2 p2 True b' m\n\ngoal (1 subgoal):\n 1. (\\<And>fs2 b2.\n        LLL_invariant_mod fs2 mfs2 dmu2 p2 True b2 m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_invariant_mod fs2 mfs2 dmu2 p2 True b2 m\n\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "obtain p2' mfsi2 dmui2 di2 mods2 where main': \"LLL_iso_main p1 ?first state1 g_idx1 0 = (p2', (mfsi2, dmui2, di2, mods2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2' mfsi2 dmui2 di2 mods2.\n        LLL_iso_main p1 True state1 g_idx1 0 =\n        (p2', mfsi2, dmui2, di2, mods2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  LLL_iso_main p1 True state1 g_idx1 0 = (p2', mfsi2, dmui2, di2, mods2)\n\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "from LLL_iso_main[OF impl1 inv1 main, unfolded id, OF main']"], ["proof (chain)\npicking this:\n  state_impl_inv p2 mfs2 dmu2 (mfsi2, dmui2, di2, mods2) \\<and> p2' = p2", "have impl2: \"state_impl_inv p2 mfs2 dmu2 (mfsi2, dmui2, di2, mods2)\" and p2: \"p2' = p2\""], ["proof (prove)\nusing this:\n  state_impl_inv p2 mfs2 dmu2 (mfsi2, dmui2, di2, mods2) \\<and> p2' = p2\n\ngoal (1 subgoal):\n 1. state_impl_inv p2 mfs2 dmu2 (mfsi2, dmui2, di2, mods2) &&& p2' = p2", "by auto"], ["proof (state)\nthis:\n  state_impl_inv p2 mfs2 dmu2 (mfsi2, dmui2, di2, mods2)\n  p2' = p2\n\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "hence identity: \"mfs2 = mfsi2\""], ["proof (prove)\nusing this:\n  state_impl_inv p2 mfs2 dmu2 (mfsi2, dmui2, di2, mods2)\n  p2' = p2\n\ngoal (1 subgoal):\n 1. mfs2 = mfsi2", "unfolding state_impl_inv.simps"], ["proof (prove)\nusing this:\n  mfsi2 = mfs2 \\<and>\n  di2 = IArray.of_fun (d_of dmu2) (Suc m) \\<and>\n  dmui2 =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>j. dmu2 $$ (i, j)) i)\n   m \\<and>\n  mods2 = IArray.of_fun (\\<lambda>j. p2 * di2 !! j * di2 !! Suc j) (m - 1)\n  p2' = p2\n\ngoal (1 subgoal):\n 1. mfs2 = mfsi2", "by auto"], ["proof (state)\nthis:\n  mfs2 = mfsi2\n\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "note res = short_vector_iso_def[unfolded init main split Let_def]"], ["proof (state)\nthis:\n  short_vector_iso = hd mfs2\n\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "note res' = LLL_short_vector_iso_def[unfolded init' Let_def main' id split p2]"], ["proof (state)\nthis:\n  LLL_short_vector_iso = hd mfsi2\n\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_short_vector_iso = short_vector_iso", "unfolding res res' identity"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd mfsi2 = hd mfsi2", ".."], ["proof (state)\nthis:\n  LLL_short_vector_iso = short_vector_iso\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}