{"file_name": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms/Storjohann_Mod_Operation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Modular_arithmetic_LLL_and_HNF_algorithms", "problem_names": ["lemma map_vec_map_vec: \"map_vec f (map_vec g v) = map_vec (f o g) v\"", "lemma mat_hom_add: assumes A: \"A \\<in> carrier_mat nr nc\" and B: \"B \\<in> carrier_mat nr nc\"\n  shows \"mat\\<^sub>h (A + B) = mat\\<^sub>h A + mat\\<^sub>h B\"", "lemma inverse_via_det: \"I * A = 1\\<^sub>m n\" \"A * I = 1\\<^sub>m n\" \"I \\<in> carrier_mat n n\" \n  \"I = mat n n (\\<lambda> (i,j). det (replace_col A (unit_vec n j) i) / det A)\"", "lemma matrix_for_singleton_entry: assumes i: \"i < n\" and \n  j: \"j < n\" \n  and Rdef: \"R = mat n n ( \\<lambda> ij. if ij = (i,j) then c :: 'a else 0)\" \nshows \"mat n n\n   (\\<lambda>(i', j'). if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n       else 0) * A = R\"", "lemma (in gram_schmidt_fs_Rn) det_M_1: \"det (M m) = 1\"", "lemma assumes IM: \"IM = the (mat_inverse (M m))\" \n  shows inv_mu_lower_triangular: \"\\<And> k i. k < i \\<Longrightarrow> i < m \\<Longrightarrow> IM $$ (k, i) = 0\"\n  and inv_mu_diag: \"\\<And> k. k < m \\<Longrightarrow> IM $$ (k, k) = 1\"\n  and d_inv_mu_integer: \"\\<And> i j. i < m \\<Longrightarrow> j < m \\<Longrightarrow> d i * IM $$ (i,j) \\<in> \\<int>\" \n  and inv_mu_inverse: \"IM * M m = 1\\<^sub>m m\" \"M m * IM = 1\\<^sub>m m\" \"IM \\<in> carrier_mat m m\"", "lemma inv_mu_ij_mat: assumes i: \"i < m\" and ji: \"j < i\" \n  shows \n(* Effect on \\<mu> *)\n   \"map_mat of_int (inv_mu_ij_mat i j c) * M m =\n    mat m m (\\<lambda>ij. if ij = (i, j) then of_int c * d j else 0) + M m\" (* only change value of \\<mu>_ij *)\n(* Effect on A *)\n  \"A \\<in> carrier_mat m n \\<Longrightarrow> c mod p = 0 \\<Longrightarrow> map_mat (\\<lambda> x. x mod p) (inv_mu_ij_mat i j c * A) = \n    (map_mat (\\<lambda> x. x mod p) A)\" (* no change (mod p) *)\n(* The transformation-matrix is ... *)\n  \"inv_mu_ij_mat i j c \\<in> carrier_mat m m\" (* ... of dimension m*m *)\n  \"i' < j' \\<Longrightarrow> j' < m \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i',j') = 0\" (* ... lower triangular *)\n  \"k < m \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k,k) = 1\"", "lemma Gramian_determinant_of_int: assumes fs: \"set fs \\<subseteq> carrier_vec n\" \n  and j: \"j \\<le> length fs\" \nshows \"of_int (gram_schmidt.Gramian_determinant n fs j)\n  = gram_schmidt.Gramian_determinant n (map (map_vec rat_of_int) fs) j\"", "lemma multiply_invertible_mat: assumes lin: \"lin_indep fs\" \n  and len: \"length fs = m\" \n  and A: \"A \\<in> carrier_mat m m\" \n  and A_invertible: \"\\<exists> B. B \\<in> carrier_mat m m \\<and> B * A = 1\\<^sub>m m\" \n  and fs'_prod: \"fs' = Matrix.rows (A * mat_of_rows n fs)\" \nshows \"lattice_of fs' = lattice_of fs\" \n  \"lin_indep fs'\" \n  \"length fs' = m\"", "lemma change_single_element: assumes lin: \"lin_indep fs\" \n  and len: \"length fs = m\" \n  and i: \"i < m\" and ji: \"j < i\"  \n  and A: \"A = gram_schmidt_fs_int.inv_mu_ij_mat n (RAT fs)\"    \\<comment> \\<open>the transformation matrix A\\<close>\n  and fs'_prod: \"fs' = Matrix.rows (A i j c * mat_of_rows n fs)\" \\<comment> \\<open>fs' is the new basis\\<close>\n  and latt: \"lattice_of fs = L\" \nshows \"lattice_of fs' = L\"\n  \"c mod p = 0 \\<Longrightarrow> map (map_vec (\\<lambda> x. x mod p)) fs' = map (map_vec (\\<lambda> x. x mod p)) fs\" \n  \"lin_indep fs'\" \n  \"length fs' = m\" \n  \"\\<And> k. k < m \\<Longrightarrow> gso fs' k = gso fs k\" \n  \"\\<And> k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\" \n  \"i' < m \\<Longrightarrow> j' < m \\<Longrightarrow> \n    \\<mu> fs' i' j' = (if (i',j') = (i,j) then rat_of_int (c * d fs j) + \\<mu> fs i' j' else \\<mu> fs i' j')\" \n  \"i' < m \\<Longrightarrow> j' < m \\<Longrightarrow> \n    d\\<mu> fs' i' j' = (if (i',j') = (i,j) then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j' else d\\<mu> fs i' j')\"", "lemma mod_single_element: assumes lin: \"lin_indep fs\" \n  and len: \"length fs = m\" \n  and i: \"i < m\" and ji: \"j < i\"  \n  and latt: \"lattice_of fs = L\" \n  and pgtz: \"p > 0\"\nshows \"\\<exists> fs'. lattice_of fs' = L \\<and> \n  map (map_vec (\\<lambda> x. x mod p)) fs' = map (map_vec (\\<lambda> x. x mod p)) fs \\<and>\n  map (map_vec (\\<lambda> x. x symmod p)) fs' = map (map_vec (\\<lambda> x. x symmod p)) fs \\<and>\n  lin_indep fs' \\<and>\n  length fs' = m \\<and> \n  (\\<forall> k < m. gso fs' k = gso fs k) \\<and> \n  (\\<forall> k \\<le> m. d fs' k = d fs k) \\<and>\n  (\\<forall> i' < m. \\<forall> j' < m. d\\<mu> fs' i' j' = (if (i',j') = (i,j) then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j')) else d\\<mu> fs i' j'))\"", "lemma mod_finite_set: assumes lin: \"lin_indep fs\" \n  and len: \"length fs = m\" \n  and I: \"I \\<subseteq> {(i,j). i < m \\<and> j < i}\"\n  and latt: \"lattice_of fs = L\" \n  and pgtz: \"p > 0\"\nshows \"\\<exists> fs'. lattice_of fs' = L \\<and>\n  map (map_vec (\\<lambda> x. x mod p)) fs' = map (map_vec (\\<lambda> x. x mod p)) fs \\<and>\n  map (map_vec (\\<lambda> x. x symmod p)) fs' = map (map_vec (\\<lambda> x. x symmod p)) fs \\<and>\n  lin_indep fs' \\<and>\n  length fs' = m \\<and> \n  (\\<forall> k < m. gso fs' k = gso fs k) \\<and> \n  (\\<forall> k \\<le> m. d fs' k = d fs k) \\<and>\n  (\\<forall> i' < m. \\<forall> j' < m. d\\<mu> fs' i' j' = \n     (if (i',j') \\<in> I then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j')) else d\\<mu> fs i' j'))\""], "translations": [["", "lemma map_vec_map_vec: \"map_vec f (map_vec g v) = map_vec (f o g) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vec f (map_vec g v) = map_vec (f \\<circ> g) v", "by (intro eq_vecI, auto)"], ["", "context semiring_hom\nbegin"], ["", "(* TODO: move *)"], ["", "lemma mat_hom_add: assumes A: \"A \\<in> carrier_mat nr nc\" and B: \"B \\<in> carrier_mat nr nc\"\n  shows \"mat\\<^sub>h (A + B) = mat\\<^sub>h A + mat\\<^sub>h B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat\\<^sub>h (A + B) = mat\\<^sub>h A + mat\\<^sub>h B", "by (intro eq_matI, insert A B, auto simp: hom_add)"], ["", "end"], ["", "text \\<open>We now start to prove lemma 13 of Storjohann's paper.\\<close>"], ["", "context\n  fixes A I :: \"'a :: field mat\" and n :: nat\n  assumes A: \"A \\<in> carrier_mat n n\" \n  and det: \"det A \\<noteq> 0\" \n  and I: \"I = the (mat_inverse A)\" \nbegin"], ["", "lemma inverse_via_det: \"I * A = 1\\<^sub>m n\" \"A * I = 1\\<^sub>m n\" \"I \\<in> carrier_mat n n\" \n  \"I = mat n n (\\<lambda> (i,j). det (replace_col A (unit_vec n j) i) / det A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I * A = 1\\<^sub>m n &&& A * I = 1\\<^sub>m n) &&&\n    I \\<in> carrier_mat n n &&&\n    I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. I * A = 1\\<^sub>m n\n 2. A * I = 1\\<^sub>m n\n 3. I \\<in> carrier_mat n n\n 4. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "from det_non_zero_imp_unit[OF A det]"], ["proof (chain)\npicking this:\n  A \\<in> Units (ring_mat TYPE('a) n ?b)", "have Unit: \"A \\<in> Units (ring_mat TYPE('a) n n)\""], ["proof (prove)\nusing this:\n  A \\<in> Units (ring_mat TYPE('a) n ?b)\n\ngoal (1 subgoal):\n 1. A \\<in> Units (ring_mat TYPE('a) n n)", "."], ["proof (state)\nthis:\n  A \\<in> Units (ring_mat TYPE('a) n n)\n\ngoal (4 subgoals):\n 1. I * A = 1\\<^sub>m n\n 2. A * I = 1\\<^sub>m n\n 3. I \\<in> carrier_mat n n\n 4. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "from mat_inverse(1)[OF A, of n] Unit I"], ["proof (chain)\npicking this:\n  mat_inverse A = None \\<Longrightarrow>\n  A \\<notin> Units (ring_mat TYPE('a) n n)\n  A \\<in> Units (ring_mat TYPE('a) n n)\n  I = the (mat_inverse A)", "have \"mat_inverse A = Some I\""], ["proof (prove)\nusing this:\n  mat_inverse A = None \\<Longrightarrow>\n  A \\<notin> Units (ring_mat TYPE('a) n n)\n  A \\<in> Units (ring_mat TYPE('a) n n)\n  I = the (mat_inverse A)\n\ngoal (1 subgoal):\n 1. mat_inverse A = Some I", "by (cases \"mat_inverse A\", auto)"], ["proof (state)\nthis:\n  mat_inverse A = Some I\n\ngoal (4 subgoals):\n 1. I * A = 1\\<^sub>m n\n 2. A * I = 1\\<^sub>m n\n 3. I \\<in> carrier_mat n n\n 4. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "from mat_inverse(2)[OF A this]"], ["proof (chain)\npicking this:\n  A * I = 1\\<^sub>m n \\<and>\n  I * A = 1\\<^sub>m n \\<and> I \\<in> carrier_mat n n", "show left: \"I * A = 1\\<^sub>m n\" and right: \"A * I = 1\\<^sub>m n\" and I: \"I \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A * I = 1\\<^sub>m n \\<and>\n  I * A = 1\\<^sub>m n \\<and> I \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. I * A = 1\\<^sub>m n &&& A * I = 1\\<^sub>m n &&& I \\<in> carrier_mat n n", "by blast+"], ["proof (state)\nthis:\n  I * A = 1\\<^sub>m n\n  A * I = 1\\<^sub>m n\n  I \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "{"], ["proof (state)\nthis:\n  I * A = 1\\<^sub>m n\n  A * I = 1\\<^sub>m n\n  I \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "assume i: \"i < n\" and j: \"j < n\""], ["proof (state)\nthis:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "from I i j"], ["proof (chain)\npicking this:\n  I \\<in> carrier_mat n n\n  i < n\n  j < n", "have cI: \"col I j $ i = I $$ (i,j)\""], ["proof (prove)\nusing this:\n  I \\<in> carrier_mat n n\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. col I j $ i = I $$ (i, j)", "by simp"], ["proof (state)\nthis:\n  col I j $ i = I $$ (i, j)\n\ngoal (1 subgoal):\n 1. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "from j"], ["proof (chain)\npicking this:\n  j < n", "have uv: \"unit_vec n j \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. unit_vec n j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  unit_vec n j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "from j I"], ["proof (chain)\npicking this:\n  j < n\n  I \\<in> carrier_mat n n", "have col: \"col I j \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  j < n\n  I \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. col I j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  col I j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "from col_mult2[OF A I j, unfolded right] j"], ["proof (chain)\npicking this:\n  col (1\\<^sub>m n) j = A *\\<^sub>v col I j\n  j < n", "have \"A *\\<^sub>v col I j = unit_vec n j\""], ["proof (prove)\nusing this:\n  col (1\\<^sub>m n) j = A *\\<^sub>v col I j\n  j < n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v col I j = unit_vec n j", "by simp"], ["proof (state)\nthis:\n  A *\\<^sub>v col I j = unit_vec n j\n\ngoal (1 subgoal):\n 1. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "from cramer_lemma_mat[OF A col i, unfolded this cI]"], ["proof (chain)\npicking this:\n  det (replace_col A (unit_vec n j) i) = I $$ (i, j) * det A", "have \"I $$ (i,j) = det (replace_col A (unit_vec n j) i) / det A\""], ["proof (prove)\nusing this:\n  det (replace_col A (unit_vec n j) i) = I $$ (i, j) * det A\n\ngoal (1 subgoal):\n 1. I $$ (i, j) = det (replace_col A (unit_vec n j) i) / det A", "using det"], ["proof (prove)\nusing this:\n  det (replace_col A (unit_vec n j) i) = I $$ (i, j) * det A\n  det A \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. I $$ (i, j) = det (replace_col A (unit_vec n j) i) / det A", "by simp"], ["proof (state)\nthis:\n  I $$ (i, j) = det (replace_col A (unit_vec n j) i) / det A\n\ngoal (1 subgoal):\n 1. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> I $$ (?i2, ?j2) =\n                    det (replace_col A (unit_vec n ?j2) ?i2) / det A\n\ngoal (1 subgoal):\n 1. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "thus \"I = mat n n (\\<lambda> (i,j). det (replace_col A (unit_vec n j) i) / det A)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> I $$ (?i2, ?j2) =\n                    det (replace_col A (unit_vec n ?j2) ?i2) / det A\n\ngoal (1 subgoal):\n 1. I =\n    mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)", "by (intro eq_matI, use I in auto)"], ["proof (state)\nthis:\n  I =\n  mat n n (\\<lambda>(i, j). det (replace_col A (unit_vec n j) i) / det A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_for_singleton_entry: assumes i: \"i < n\" and \n  j: \"j < n\" \n  and Rdef: \"R = mat n n ( \\<lambda> ij. if ij = (i,j) then c :: 'a else 0)\" \nshows \"mat n n\n   (\\<lambda>(i', j'). if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n       else 0) * A = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "note I = inverse_via_det(3)"], ["proof (state)\nthis:\n  I \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "have R: \"R \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<in> carrier_mat n n", "unfolding Rdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n (\\<lambda>ij. if ij = (i, j) then c else (0::'a))\n    \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  R \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "have \"(R * I) * A = R * (I * A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R * I * A = R * (I * A)", "using I A R"], ["proof (prove)\nusing this:\n  I \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n  R \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. R * I * A = R * (I * A)", "by auto"], ["proof (state)\nthis:\n  R * I * A = R * (I * A)\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "also"], ["proof (state)\nthis:\n  R * I * A = R * (I * A)\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "have \"I * A = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I * A = 1\\<^sub>m n", "unfolding inverse_via_det(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n = 1\\<^sub>m n", ".."], ["proof (state)\nthis:\n  I * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "also"], ["proof (state)\nthis:\n  I * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "have \"R * \\<dots> = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R * 1\\<^sub>m n = R", "using R"], ["proof (prove)\nusing this:\n  R \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. R * 1\\<^sub>m n = R", "by simp"], ["proof (state)\nthis:\n  R * 1\\<^sub>m n = R\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "also"], ["proof (state)\nthis:\n  R * 1\\<^sub>m n = R\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "have \"R * I = mat n n (\\<lambda> (i',j'). row R i' \\<bullet> col I j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R * I = mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j')", "using I R"], ["proof (prove)\nusing this:\n  I \\<in> carrier_mat n n\n  R \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. R * I = mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j')", "unfolding times_mat_def"], ["proof (prove)\nusing this:\n  I \\<in> carrier_mat n n\n  R \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mat (dim_row R) (dim_col I)\n     (\\<lambda>(i, j). row R i \\<bullet> col I j) =\n    mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j')", "by simp"], ["proof (state)\nthis:\n  R * I = mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j')\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "also"], ["proof (state)\nthis:\n  R * I = mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j')\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "have \"\\<dots> = mat n n ( \\<lambda> (i',j'). if i' = i then c * I $$ (j, j') else 0)\" \n    (is \"mat n n ?f = mat n n ?g\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j') =\n    mat n n\n     (\\<lambda>(i', j'). if i' = i then c * I $$ (j, j') else (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j') =\n    mat n n\n     (\\<lambda>(i', j'). if i' = i then c * I $$ (j, j') else (0::'a))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j') =\n    mat n n\n     (\\<lambda>(i', j'). if i' = i then c * I $$ (j, j') else (0::'a))", "fix i' j'"], ["proof (state)\ngoal (1 subgoal):\n 1. mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j') =\n    mat n n\n     (\\<lambda>(i', j'). if i' = i then c * I $$ (j, j') else (0::'a))", "assume i': \"i' < n\" and j': \"j' < n\""], ["proof (state)\nthis:\n  i' < n\n  j' < n\n\ngoal (1 subgoal):\n 1. mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j') =\n    mat n n\n     (\\<lambda>(i', j'). if i' = i then c * I $$ (j, j') else (0::'a))", "have \"?f (i',j') = ?g (i',j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))", "proof (cases \"i' = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow>\n    (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))\n 2. i' \\<noteq> i \\<Longrightarrow>\n    (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))", "case False"], ["proof (state)\nthis:\n  i' \\<noteq> i\n\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow>\n    (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))\n 2. i' \\<noteq> i \\<Longrightarrow>\n    (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))", "hence \"row R i' = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. row R i' = 0\\<^sub>v n", "unfolding Rdef"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. row (mat n n (\\<lambda>ij. if ij = (i, j) then c else (0::'a))) i' =\n    0\\<^sub>v n", "using i'"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n  i' < n\n\ngoal (1 subgoal):\n 1. row (mat n n (\\<lambda>ij. if ij = (i, j) then c else (0::'a))) i' =\n    0\\<^sub>v n", "by (intro eq_vecI, auto simp: Matrix.row_def)"], ["proof (state)\nthis:\n  row R i' = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow>\n    (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))\n 2. i' \\<noteq> i \\<Longrightarrow>\n    (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  row R i' = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))", "using False i' j' I"], ["proof (prove)\nusing this:\n  row R i' = 0\\<^sub>v n\n  i' \\<noteq> i\n  i' < n\n  j' < n\n  I \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))", "by simp"], ["proof (state)\nthis:\n  (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n  (case (i', j') of\n   (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))\n\ngoal (1 subgoal):\n 1. i' = i \\<Longrightarrow>\n    (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i' = i \\<Longrightarrow>\n    (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))", "case True"], ["proof (state)\nthis:\n  i' = i\n\ngoal (1 subgoal):\n 1. i' = i \\<Longrightarrow>\n    (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))", "hence \"row R i' = c \\<cdot>\\<^sub>v unit_vec n j\""], ["proof (prove)\nusing this:\n  i' = i\n\ngoal (1 subgoal):\n 1. row R i' = c \\<cdot>\\<^sub>v unit_vec n j", "unfolding Rdef"], ["proof (prove)\nusing this:\n  i' = i\n\ngoal (1 subgoal):\n 1. row (mat n n (\\<lambda>ij. if ij = (i, j) then c else (0::'a))) i' =\n    c \\<cdot>\\<^sub>v unit_vec n j", "using i' j' i j"], ["proof (prove)\nusing this:\n  i' = i\n  i' < n\n  j' < n\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. row (mat n n (\\<lambda>ij. if ij = (i, j) then c else (0::'a))) i' =\n    c \\<cdot>\\<^sub>v unit_vec n j", "by (intro eq_vecI, auto simp: Matrix.row_def)"], ["proof (state)\nthis:\n  row R i' = c \\<cdot>\\<^sub>v unit_vec n j\n\ngoal (1 subgoal):\n 1. i' = i \\<Longrightarrow>\n    (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))", "with True"], ["proof (chain)\npicking this:\n  i' = i\n  row R i' = c \\<cdot>\\<^sub>v unit_vec n j", "show ?thesis"], ["proof (prove)\nusing this:\n  i' = i\n  row R i' = c \\<cdot>\\<^sub>v unit_vec n j\n\ngoal (1 subgoal):\n 1. (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))", "using i' j' I j"], ["proof (prove)\nusing this:\n  i' = i\n  row R i' = c \\<cdot>\\<^sub>v unit_vec n j\n  i' < n\n  j' < n\n  I \\<in> carrier_mat n n\n  j < n\n\ngoal (1 subgoal):\n 1. (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n    (case (i', j') of\n     (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))", "by simp"], ["proof (state)\nthis:\n  (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n  (case (i', j') of\n   (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case (i', j') of (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n  (case (i', j') of\n   (i', j') \\<Rightarrow> if i' = i then c * I $$ (j, j') else (0::'a))\n\ngoal (1 subgoal):\n 1. mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j') =\n    mat n n\n     (\\<lambda>(i', j'). if i' = i then c * I $$ (j, j') else (0::'a))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i'2 < n; ?j'2 < n\\<rbrakk>\n  \\<Longrightarrow> (case (?i'2, ?j'2) of\n                     (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n                    (case (?i'2, ?j'2) of\n                     (i', j') \\<Rightarrow>\n                       if i' = i then c * I $$ (j, j') else (0::'a))\n\ngoal (1 subgoal):\n 1. mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j') =\n    mat n n\n     (\\<lambda>(i', j'). if i' = i then c * I $$ (j, j') else (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i'2 < n; ?j'2 < n\\<rbrakk>\n  \\<Longrightarrow> (case (?i'2, ?j'2) of\n                     (i', j') \\<Rightarrow> row R i' \\<bullet> col I j') =\n                    (case (?i'2, ?j'2) of\n                     (i', j') \\<Rightarrow>\n                       if i' = i then c * I $$ (j, j') else (0::'a))\n\ngoal (1 subgoal):\n 1. mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j') =\n    mat n n\n     (\\<lambda>(i', j'). if i' = i then c * I $$ (j, j') else (0::'a))", "by auto"], ["proof (state)\nthis:\n  mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j') =\n  mat n n (\\<lambda>(i', j'). if i' = i then c * I $$ (j, j') else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat n n (\\<lambda>(i', j'). row R i' \\<bullet> col I j') =\n  mat n n (\\<lambda>(i', j'). if i' = i then c * I $$ (j, j') else (0::'a))\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "finally"], ["proof (chain)\npicking this:\n  mat n n\n   (\\<lambda>(i', j'). if i' = i then c * I $$ (j, j') else (0::'a)) *\n  A =\n  R", "show ?thesis"], ["proof (prove)\nusing this:\n  mat n n\n   (\\<lambda>(i', j'). if i' = i then c * I $$ (j, j') else (0::'a)) *\n  A =\n  R\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "unfolding inverse_via_det(4)"], ["proof (prove)\nusing this:\n  mat n n\n   (\\<lambda>(i', j').\n       if i' = i\n       then c *\n            mat n n\n             (\\<lambda>(i, j).\n                 det (replace_col A (unit_vec n j) i) / det A) $$\n            (j, j')\n       else (0::'a)) *\n  A =\n  R\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "using j"], ["proof (prove)\nusing this:\n  mat n n\n   (\\<lambda>(i', j').\n       if i' = i\n       then c *\n            mat n n\n             (\\<lambda>(i, j).\n                 det (replace_col A (unit_vec n j) i) / det A) $$\n            (j, j')\n       else (0::'a)) *\n  A =\n  R\n  j < n\n\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i', j').\n         if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n         else (0::'a)) *\n    A =\n    R", "by (auto intro!: arg_cong[of _ _ \"\\<lambda> x. x * A\"])"], ["proof (state)\nthis:\n  mat n n\n   (\\<lambda>(i', j').\n       if i' = i then c * det (replace_col A (unit_vec n j') j) / det A\n       else (0::'a)) *\n  A =\n  R\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma (in gram_schmidt_fs_Rn) det_M_1: \"det (M m) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (M (length fs)) = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (M (length fs)) = (1::'a)", "have \"det (M m) = prod_list (diag_mat (M m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (M (length fs)) = prod_list (diag_mat (M (length fs)))", "by (rule det_lower_triangular[of m], auto simp: \\<mu>.simps)"], ["proof (state)\nthis:\n  det (M (length fs)) = prod_list (diag_mat (M (length fs)))\n\ngoal (1 subgoal):\n 1. det (M (length fs)) = (1::'a)", "also"], ["proof (state)\nthis:\n  det (M (length fs)) = prod_list (diag_mat (M (length fs)))\n\ngoal (1 subgoal):\n 1. det (M (length fs)) = (1::'a)", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (diag_mat (M (length fs))) = (1::'a)", "by (rule prod_list_neutral, auto simp: diag_mat_def \\<mu>.simps)"], ["proof (state)\nthis:\n  prod_list (diag_mat (M (length fs))) = (1::'a)\n\ngoal (1 subgoal):\n 1. det (M (length fs)) = (1::'a)", "finally"], ["proof (chain)\npicking this:\n  det (M (length fs)) = (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  det (M (length fs)) = (1::'a)\n\ngoal (1 subgoal):\n 1. det (M (length fs)) = (1::'a)", "."], ["proof (state)\nthis:\n  det (M (length fs)) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "context gram_schmidt_fs_int\nbegin"], ["", "lemma assumes IM: \"IM = the (mat_inverse (M m))\" \n  shows inv_mu_lower_triangular: \"\\<And> k i. k < i \\<Longrightarrow> i < m \\<Longrightarrow> IM $$ (k, i) = 0\"\n  and inv_mu_diag: \"\\<And> k. k < m \\<Longrightarrow> IM $$ (k, k) = 1\"\n  and d_inv_mu_integer: \"\\<And> i j. i < m \\<Longrightarrow> j < m \\<Longrightarrow> d i * IM $$ (i,j) \\<in> \\<int>\" \n  and inv_mu_inverse: \"IM * M m = 1\\<^sub>m m\" \"M m * IM = 1\\<^sub>m m\" \"IM \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>k i.\n         \\<lbrakk>k < i; i < length fs\\<rbrakk>\n         \\<Longrightarrow> IM $$ (k, i) = (0::'a)) &&&\n     (\\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a))) &&&\n    (\\<And>i j.\n        \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n        \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>) &&&\n    IM * M (length fs) = 1\\<^sub>m (length fs) &&&\n    M (length fs) * IM = 1\\<^sub>m (length fs) &&&\n    IM \\<in> carrier_mat (length fs) (length fs)", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>\n 4. IM * M (length fs) = 1\\<^sub>m (length fs)\n 5. M (length fs) * IM = 1\\<^sub>m (length fs)\n 6. IM \\<in> carrier_mat (length fs) (length fs)", "note * = inverse_via_det[OF M_dim(3) _ IM, unfolded det_M_1]"], ["proof (state)\nthis:\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM * M (length fs) = 1\\<^sub>m (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  M (length fs) * IM = 1\\<^sub>m (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM \\<in> carrier_mat (length fs) (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j).\n       det (replace_col (M (length fs)) (unit_vec (length fs) j) i) /\n       (1::'a))\n\ngoal (6 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>\n 4. IM * M (length fs) = 1\\<^sub>m (length fs)\n 5. M (length fs) * IM = 1\\<^sub>m (length fs)\n 6. IM \\<in> carrier_mat (length fs) (length fs)", "from *"], ["proof (chain)\npicking this:\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM * M (length fs) = 1\\<^sub>m (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  M (length fs) * IM = 1\\<^sub>m (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM \\<in> carrier_mat (length fs) (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j).\n       det (replace_col (M (length fs)) (unit_vec (length fs) j) i) /\n       (1::'a))", "show inv: \"IM * M m = 1\\<^sub>m m\" \"M m * IM = 1\\<^sub>m m\" \n    and IM: \"IM \\<in> carrier_mat m m\""], ["proof (prove)\nusing this:\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM * M (length fs) = 1\\<^sub>m (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  M (length fs) * IM = 1\\<^sub>m (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM \\<in> carrier_mat (length fs) (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j).\n       det (replace_col (M (length fs)) (unit_vec (length fs) j) i) /\n       (1::'a))\n\ngoal (1 subgoal):\n 1. (IM * M (length fs) = 1\\<^sub>m (length fs) &&&\n     M (length fs) * IM = 1\\<^sub>m (length fs)) &&&\n    IM \\<in> carrier_mat (length fs) (length fs)", "by auto"], ["proof (state)\nthis:\n  IM * M (length fs) = 1\\<^sub>m (length fs)\n  M (length fs) * IM = 1\\<^sub>m (length fs)\n  IM \\<in> carrier_mat (length fs) (length fs)\n\ngoal (3 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "from *"], ["proof (chain)\npicking this:\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM * M (length fs) = 1\\<^sub>m (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  M (length fs) * IM = 1\\<^sub>m (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM \\<in> carrier_mat (length fs) (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j).\n       det (replace_col (M (length fs)) (unit_vec (length fs) j) i) /\n       (1::'a))", "have IM_det: \"IM = mat m m (\\<lambda>(i, j). det (replace_col (M m) ((unit_vec m) j) i))\""], ["proof (prove)\nusing this:\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM * M (length fs) = 1\\<^sub>m (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  M (length fs) * IM = 1\\<^sub>m (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM \\<in> carrier_mat (length fs) (length fs)\n  (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  IM =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j).\n       det (replace_col (M (length fs)) (unit_vec (length fs) j) i) /\n       (1::'a))\n\ngoal (1 subgoal):\n 1. IM =\n    mat (length fs) (length fs)\n     (\\<lambda>(i, j).\n         det (replace_col (M (length fs)) (unit_vec (length fs) j) i))", "by auto"], ["proof (state)\nthis:\n  IM =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j).\n       det (replace_col (M (length fs)) (unit_vec (length fs) j) i))\n\ngoal (3 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "from matrix_equality"], ["proof (chain)\npicking this:\n  mat_of_rows n fs = M (length fs) * mat_of_rows n (map gso [0..<length fs])", "have \"IM * FF = IM * ((M m) * Fs)\""], ["proof (prove)\nusing this:\n  mat_of_rows n fs = M (length fs) * mat_of_rows n (map gso [0..<length fs])\n\ngoal (1 subgoal):\n 1. IM * mat_of_rows n fs =\n    IM * (M (length fs) * mat_of_rows n (map gso [0..<length fs]))", "by simp"], ["proof (state)\nthis:\n  IM * mat_of_rows n fs =\n  IM * (M (length fs) * mat_of_rows n (map gso [0..<length fs]))\n\ngoal (3 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  IM * mat_of_rows n fs =\n  IM * (M (length fs) * mat_of_rows n (map gso [0..<length fs]))\n\ngoal (3 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"\\<dots> = (IM * M m) * Fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IM * (M (length fs) * mat_of_rows n (map gso [0..<length fs])) =\n    IM * M (length fs) * mat_of_rows n (map gso [0..<length fs])", "using M_dim(3) IM Fs_dim(3)"], ["proof (prove)\nusing this:\n  M (length fs) \\<in> carrier_mat (length fs) (length fs)\n  IM \\<in> carrier_mat (length fs) (length fs)\n  mat_of_rows n (map gso [0..<length fs]) \\<in> carrier_mat (length fs) n\n\ngoal (1 subgoal):\n 1. IM * (M (length fs) * mat_of_rows n (map gso [0..<length fs])) =\n    IM * M (length fs) * mat_of_rows n (map gso [0..<length fs])", "by (metis assoc_mult_mat)"], ["proof (state)\nthis:\n  IM * (M (length fs) * mat_of_rows n (map gso [0..<length fs])) =\n  IM * M (length fs) * mat_of_rows n (map gso [0..<length fs])\n\ngoal (3 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  IM * (M (length fs) * mat_of_rows n (map gso [0..<length fs])) =\n  IM * M (length fs) * mat_of_rows n (map gso [0..<length fs])\n\ngoal (3 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"\\<dots> = Fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IM * M (length fs) * mat_of_rows n (map gso [0..<length fs]) =\n    mat_of_rows n (map gso [0..<length fs])", "unfolding inv"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m (length fs) * mat_of_rows n (map gso [0..<length fs]) =\n    mat_of_rows n (map gso [0..<length fs])", "using Fs_dim(3)"], ["proof (prove)\nusing this:\n  mat_of_rows n (map gso [0..<length fs]) \\<in> carrier_mat (length fs) n\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m (length fs) * mat_of_rows n (map gso [0..<length fs]) =\n    mat_of_rows n (map gso [0..<length fs])", "by simp"], ["proof (state)\nthis:\n  IM * M (length fs) * mat_of_rows n (map gso [0..<length fs]) =\n  mat_of_rows n (map gso [0..<length fs])\n\ngoal (3 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  IM * mat_of_rows n fs = mat_of_rows n (map gso [0..<length fs])", "have equality: \"IM * FF = Fs\""], ["proof (prove)\nusing this:\n  IM * mat_of_rows n fs = mat_of_rows n (map gso [0..<length fs])\n\ngoal (1 subgoal):\n 1. IM * mat_of_rows n fs = mat_of_rows n (map gso [0..<length fs])", "."], ["proof (state)\nthis:\n  IM * mat_of_rows n fs = mat_of_rows n (map gso [0..<length fs])\n\ngoal (3 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "{"], ["proof (state)\nthis:\n  IM * mat_of_rows n fs = mat_of_rows n (map gso [0..<length fs])\n\ngoal (3 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "fix i k"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "assume i: \"k < i\" \"i < m\""], ["proof (state)\nthis:\n  k < i\n  i < length fs\n\ngoal (3 subgoals):\n 1. \\<And>k i.\n       \\<lbrakk>k < i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> IM $$ (k, i) = (0::'a)\n 2. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 3. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "show \"IM $$ (k, i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IM $$ (k, i) = (0::'a)", "using i M_dim"], ["proof (prove)\nusing this:\n  k < i\n  i < length fs\n  dim_row (M (length fs)) = length fs\n  dim_col (M (length fs)) = length fs\n  M (length fs) \\<in> carrier_mat (length fs) (length fs)\n\ngoal (1 subgoal):\n 1. IM $$ (k, i) = (0::'a)", "unfolding IM_det"], ["proof (prove)\nusing this:\n  k < i\n  i < length fs\n  dim_row (M (length fs)) = length fs\n  dim_col (M (length fs)) = length fs\n  M (length fs) \\<in> carrier_mat (length fs) (length fs)\n\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>(i, j).\n         det (replace_col (M (length fs)) (unit_vec (length fs) j) i)) $$\n    (k, i) =\n    (0::'a)", "by (simp, subst det_lower_triangular[of m], auto simp: replace_col_def \\<mu>.simps diag_mat_def)"], ["proof (state)\nthis:\n  IM $$ (k, i) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 2. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?k3 < ?i3; ?i3 < length fs\\<rbrakk>\n  \\<Longrightarrow> IM $$ (?k3, ?i3) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 2. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "note IM_lower_triag = this"], ["proof (state)\nthis:\n  \\<lbrakk>?k3 < ?i3; ?i3 < length fs\\<rbrakk>\n  \\<Longrightarrow> IM $$ (?k3, ?i3) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 2. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?k3 < ?i3; ?i3 < length fs\\<rbrakk>\n  \\<Longrightarrow> IM $$ (?k3, ?i3) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 2. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 2. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "assume k: \"k < m\""], ["proof (state)\nthis:\n  k < length fs\n\ngoal (2 subgoals):\n 1. \\<And>k. k < length fs \\<Longrightarrow> IM $$ (k, k) = (1::'a)\n 2. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "show \"IM $$ (k,k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IM $$ (k, k) = (1::'a)", "using k M_dim"], ["proof (prove)\nusing this:\n  k < length fs\n  dim_row (M (length fs)) = length fs\n  dim_col (M (length fs)) = length fs\n  M (length fs) \\<in> carrier_mat (length fs) (length fs)\n\ngoal (1 subgoal):\n 1. IM $$ (k, k) = (1::'a)", "unfolding IM_det"], ["proof (prove)\nusing this:\n  k < length fs\n  dim_row (M (length fs)) = length fs\n  dim_col (M (length fs)) = length fs\n  M (length fs) \\<in> carrier_mat (length fs) (length fs)\n\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>(i, j).\n         det (replace_col (M (length fs)) (unit_vec (length fs) j) i)) $$\n    (k, k) =\n    (1::'a)", "by (simp, subst det_lower_triangular[of m], auto simp: replace_col_def \\<mu>.simps diag_mat_def\n        intro!: prod_list_neutral)"], ["proof (state)\nthis:\n  IM $$ (k, k) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "}"], ["proof (state)\nthis:\n  ?k3 < length fs \\<Longrightarrow> IM $$ (?k3, ?k3) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "note IM_diag_1 = this"], ["proof (state)\nthis:\n  ?k3 < length fs \\<Longrightarrow> IM $$ (?k3, ?k3) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "{"], ["proof (state)\nthis:\n  ?k3 < length fs \\<Longrightarrow> IM $$ (?k3, ?k3) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "assume k: \"k < m\""], ["proof (state)\nthis:\n  k < length fs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "let ?f = \"\\<lambda> i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "let ?sum = \"M.sumlist (map ?f [0..<m])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "let ?sumk = \"M.sumlist (map ?f [0..<k])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have set: \"set (map ?f [0..<m]) \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n          [0..<length fs])\n    \\<subseteq> carrier_vec n", "using fs_carrier"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n          [0..<length fs])\n    \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n        [0..<length fs])\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "hence sum: \"?sum \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n        [0..<length fs])\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n    \\<in> carrier_vec n", "by simp"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "from set k"], ["proof (chain)\npicking this:\n  set (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n        [0..<length fs])\n  \\<subseteq> carrier_vec n\n  k < length fs", "have setk: \"set (map ?f [0..<k]) \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n        [0..<length fs])\n  \\<subseteq> carrier_vec n\n  k < length fs\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k])\n    \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k])\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "hence sumk: \"?sumk \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k])\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k])\n    \\<in> carrier_vec n", "by simp"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "from sum"], ["proof (chain)\npicking this:\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n  \\<in> carrier_vec n", "have dim_sum: \"dim_vec ?sum = n\""], ["proof (prove)\nusing this:\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec\n     (M.sumlist\n       (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n         [0..<length fs])) =\n    n", "by simp"], ["proof (state)\nthis:\n  dim_vec\n   (M.sumlist\n     (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n       [0..<length fs])) =\n  n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"gso k = row Fs k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso k = row (mat_of_rows n (map gso [0..<length fs])) k", "using k"], ["proof (prove)\nusing this:\n  k < length fs\n\ngoal (1 subgoal):\n 1. gso k = row (mat_of_rows n (map gso [0..<length fs])) k", "by auto"], ["proof (state)\nthis:\n  gso k = row (mat_of_rows n (map gso [0..<length fs])) k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  gso k = row (mat_of_rows n (map gso [0..<length fs])) k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"\\<dots> = row (IM * FF) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_rows n (map gso [0..<length fs])) k =\n    row (IM * mat_of_rows n fs) k", "unfolding equality"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_rows n (map gso [0..<length fs])) k =\n    row (mat_of_rows n (map gso [0..<length fs])) k", ".."], ["proof (state)\nthis:\n  row (mat_of_rows n (map gso [0..<length fs])) k =\n  row (IM * mat_of_rows n fs) k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  row (mat_of_rows n (map gso [0..<length fs])) k =\n  row (IM * mat_of_rows n fs) k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"IM * FF = mat m n (\\<lambda> (i,j). row IM i  \\<bullet> col FF j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IM * mat_of_rows n fs =\n    mat (length fs) n\n     (\\<lambda>(i, j). row IM i \\<bullet> col (mat_of_rows n fs) j)", "unfolding times_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row IM) (dim_col (mat_of_rows n fs))\n     (\\<lambda>(i, j). row IM i \\<bullet> col (mat_of_rows n fs) j) =\n    mat (length fs) n\n     (\\<lambda>(i, j). row IM i \\<bullet> col (mat_of_rows n fs) j)", "using IM FF_dim"], ["proof (prove)\nusing this:\n  IM \\<in> carrier_mat (length fs) (length fs)\n  dim_row (mat_of_rows n fs) = length fs\n  dim_col (mat_of_rows n fs) = n\n  mat_of_rows n fs \\<in> carrier_mat (length fs) n\n\ngoal (1 subgoal):\n 1. mat (dim_row IM) (dim_col (mat_of_rows n fs))\n     (\\<lambda>(i, j). row IM i \\<bullet> col (mat_of_rows n fs) j) =\n    mat (length fs) n\n     (\\<lambda>(i, j). row IM i \\<bullet> col (mat_of_rows n fs) j)", "by auto"], ["proof (state)\nthis:\n  IM * mat_of_rows n fs =\n  mat (length fs) n\n   (\\<lambda>(i, j). row IM i \\<bullet> col (mat_of_rows n fs) j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  IM * mat_of_rows n fs =\n  mat (length fs) n\n   (\\<lambda>(i, j). row IM i \\<bullet> col (mat_of_rows n fs) j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"row \\<dots> k = vec n (\\<lambda> j. row IM k \\<bullet> col FF j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat (length fs) n\n          (\\<lambda>(i, j). row IM i \\<bullet> col (mat_of_rows n fs) j))\n     k =\n    vec n (\\<lambda>j. row IM k \\<bullet> col (mat_of_rows n fs) j)", "unfolding Matrix.row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (dim_col\n          (mat (length fs) n\n            (\\<lambda>(i, j).\n                vec (dim_col IM) (\\<lambda>j. IM $$ (i, j)) \\<bullet>\n                col (mat_of_rows n fs) j)))\n     (\\<lambda>j.\n         mat (length fs) n\n          (\\<lambda>(i, j).\n              vec (dim_col IM) (\\<lambda>j. IM $$ (i, j)) \\<bullet>\n              col (mat_of_rows n fs) j) $$\n         (k, j)) =\n    vec n\n     (\\<lambda>j.\n         vec (dim_col IM) (\\<lambda>j. IM $$ (k, j)) \\<bullet>\n         col (mat_of_rows n fs) j)", "using IM FF_dim k"], ["proof (prove)\nusing this:\n  IM \\<in> carrier_mat (length fs) (length fs)\n  dim_row (mat_of_rows n fs) = length fs\n  dim_col (mat_of_rows n fs) = n\n  mat_of_rows n fs \\<in> carrier_mat (length fs) n\n  k < length fs\n\ngoal (1 subgoal):\n 1. vec (dim_col\n          (mat (length fs) n\n            (\\<lambda>(i, j).\n                vec (dim_col IM) (\\<lambda>j. IM $$ (i, j)) \\<bullet>\n                col (mat_of_rows n fs) j)))\n     (\\<lambda>j.\n         mat (length fs) n\n          (\\<lambda>(i, j).\n              vec (dim_col IM) (\\<lambda>j. IM $$ (i, j)) \\<bullet>\n              col (mat_of_rows n fs) j) $$\n         (k, j)) =\n    vec n\n     (\\<lambda>j.\n         vec (dim_col IM) (\\<lambda>j. IM $$ (k, j)) \\<bullet>\n         col (mat_of_rows n fs) j)", "by auto"], ["proof (state)\nthis:\n  row (mat (length fs) n\n        (\\<lambda>(i, j). row IM i \\<bullet> col (mat_of_rows n fs) j))\n   k =\n  vec n (\\<lambda>j. row IM k \\<bullet> col (mat_of_rows n fs) j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  row (mat (length fs) n\n        (\\<lambda>(i, j). row IM i \\<bullet> col (mat_of_rows n fs) j))\n   k =\n  vec n (\\<lambda>j. row IM k \\<bullet> col (mat_of_rows n fs) j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"\\<dots> = vec n (\\<lambda> j. \\<Sum> i < m. IM $$ (k, i) * fs ! i $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row IM k \\<bullet> col (mat_of_rows n fs) j) =\n    vec n (\\<lambda>j. \\<Sum>i<length fs. IM $$ (k, i) * fs ! i $ j)", "by (intro eq_vecI, insert IM k, auto simp: scalar_prod_def Matrix.row_def intro!: sum.cong)"], ["proof (state)\nthis:\n  vec n (\\<lambda>j. row IM k \\<bullet> col (mat_of_rows n fs) j) =\n  vec n (\\<lambda>j. \\<Sum>i<length fs. IM $$ (k, i) * fs ! i $ j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  vec n (\\<lambda>j. row IM k \\<bullet> col (mat_of_rows n fs) j) =\n  vec n (\\<lambda>j. \\<Sum>i<length fs. IM $$ (k, i) * fs ! i $ j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"\\<dots> = ?sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. \\<Sum>i<length fs. IM $$ (k, i) * fs ! i $ j) =\n    M.sumlist\n     (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])", "by (intro eq_vecI, insert IM, unfold dim_sum, subst sumlist_vec_index, \n        auto simp: o_def sum_list_sum_nth intro!: sum.cong)"], ["proof (state)\nthis:\n  vec n (\\<lambda>j. \\<Sum>i<length fs. IM $$ (k, i) * fs ! i $ j) =\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  vec n (\\<lambda>j. \\<Sum>i<length fs. IM $$ (k, i) * fs ! i $ j) =\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"[0..<m] = [0..<k] @ [k] @ [Suc k ..<m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<length fs] = [0..<k] @ [k] @ [Suc k..<length fs]", "using k"], ["proof (prove)\nusing this:\n  k < length fs\n\ngoal (1 subgoal):\n 1. [0..<length fs] = [0..<k] @ [k] @ [Suc k..<length fs]", "by (simp add: list_trisect)"], ["proof (state)\nthis:\n  [0..<length fs] = [0..<k] @ [k] @ [Suc k..<length fs]\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  [0..<length fs] = [0..<k] @ [k] @ [Suc k..<length fs]\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"M.sumlist (map ?f \\<dots>) = ?sumk + \n      (?f k + M.sumlist (map ?f [Suc k ..< m]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n       ([0..<k] @ [k] @ [Suc k..<length fs])) =\n    M.sumlist\n     (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n    (IM $$ (k, k) \\<cdot>\\<^sub>v fs ! k +\n     M.sumlist\n      (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n        [Suc k..<length fs]))", "unfolding map_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k] @\n      map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [k] @\n      map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n       [Suc k..<length fs]) =\n    M.sumlist\n     (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n    (IM $$ (k, k) \\<cdot>\\<^sub>v fs ! k +\n     M.sumlist\n      (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n        [Suc k..<length fs]))", "by (subst M.sumlist_append; (subst M.sumlist_append)?, insert k fs_carrier, auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n     ([0..<k] @ [k] @ [Suc k..<length fs])) =\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n  (IM $$ (k, k) \\<cdot>\\<^sub>v fs ! k +\n   M.sumlist\n    (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n      [Suc k..<length fs]))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n     ([0..<k] @ [k] @ [Suc k..<length fs])) =\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n  (IM $$ (k, k) \\<cdot>\\<^sub>v fs ! k +\n   M.sumlist\n    (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n      [Suc k..<length fs]))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"M.sumlist (map ?f [Suc k ..< m]) = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n       [Suc k..<length fs]) =\n    0\\<^sub>v n", "by (rule sumlist_neutral, insert IM_lower_triag, auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n     [Suc k..<length fs]) =\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i)\n     [Suc k..<length fs]) =\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"IM $$ (k,k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IM $$ (k, k) = (1::'a)", "using IM_diag_1[OF k]"], ["proof (prove)\nusing this:\n  IM $$ (k, k) = (1::'a)\n\ngoal (1 subgoal):\n 1. IM $$ (k, k) = (1::'a)", "."], ["proof (state)\nthis:\n  IM $$ (k, k) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  gso k =\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n  ((1::'a) \\<cdot>\\<^sub>v fs ! k + 0\\<^sub>v n)", "have gso: \"gso k = ?sumk + fs ! k\""], ["proof (prove)\nusing this:\n  gso k =\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n  ((1::'a) \\<cdot>\\<^sub>v fs ! k + 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. gso k =\n    M.sumlist\n     (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n    fs ! k", "using k"], ["proof (prove)\nusing this:\n  gso k =\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n  ((1::'a) \\<cdot>\\<^sub>v fs ! k + 0\\<^sub>v n)\n  k < length fs\n\ngoal (1 subgoal):\n 1. gso k =\n    M.sumlist\n     (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n    fs ! k", "by simp"], ["proof (state)\nthis:\n  gso k =\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n  fs ! k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "define b where \"b = vec k (\\<lambda> j. fs ! j \\<bullet> fs ! k)\""], ["proof (state)\nthis:\n  b = vec k (\\<lambda>j. fs ! j \\<bullet> fs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "{"], ["proof (state)\nthis:\n  b = vec k (\\<lambda>j. fs ! j \\<bullet> fs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "assume jk: \"j < k\""], ["proof (state)\nthis:\n  j < k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "with k"], ["proof (chain)\npicking this:\n  k < length fs\n  j < k", "have j: \"j < m\""], ["proof (prove)\nusing this:\n  k < length fs\n  j < k\n\ngoal (1 subgoal):\n 1. j < length fs", "by auto"], ["proof (state)\nthis:\n  j < length fs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"fs ! j \\<bullet> gso k = fs ! j \\<bullet> (?sumk + fs ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! j \\<bullet> gso k =\n    fs ! j \\<bullet>\n    (M.sumlist\n      (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n     fs ! k)", "unfolding gso"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! j \\<bullet>\n    (M.sumlist\n      (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n     fs ! k) =\n    fs ! j \\<bullet>\n    (M.sumlist\n      (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n     fs ! k)", "by simp"], ["proof (state)\nthis:\n  fs ! j \\<bullet> gso k =\n  fs ! j \\<bullet>\n  (M.sumlist\n    (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n   fs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  fs ! j \\<bullet> gso k =\n  fs ! j \\<bullet>\n  (M.sumlist\n    (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n   fs ! k)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"fs ! j \\<bullet> gso k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! j \\<bullet> gso k = (0::'a)", "using jk k"], ["proof (prove)\nusing this:\n  j < k\n  k < length fs\n\ngoal (1 subgoal):\n 1. fs ! j \\<bullet> gso k = (0::'a)", "by (simp add: fi_scalar_prod_gso gram_schmidt_fs.\\<mu>.simps)"], ["proof (state)\nthis:\n  fs ! j \\<bullet> gso k = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  fs ! j \\<bullet> gso k = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"fs ! j \\<bullet> (?sumk + fs ! k)\n         = fs ! j \\<bullet> ?sumk + fs ! j \\<bullet> fs ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! j \\<bullet>\n    (M.sumlist\n      (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n     fs ! k) =\n    fs ! j \\<bullet>\n    M.sumlist\n     (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n    fs ! j \\<bullet> fs ! k", "by (rule scalar_prod_add_distrib[OF _ sumk], insert j k, auto)"], ["proof (state)\nthis:\n  fs ! j \\<bullet>\n  (M.sumlist\n    (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n   fs ! k) =\n  fs ! j \\<bullet>\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n  fs ! j \\<bullet> fs ! k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  fs ! j \\<bullet>\n  (M.sumlist\n    (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n   fs ! k) =\n  fs ! j \\<bullet>\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n  fs ! j \\<bullet> fs ! k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have \"fs ! j \\<bullet> fs ! k = b $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! j \\<bullet> fs ! k = b $ j", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! j \\<bullet> fs ! k =\n    vec k (\\<lambda>j. fs ! j \\<bullet> fs ! k) $ j", "using jk"], ["proof (prove)\nusing this:\n  j < k\n\ngoal (1 subgoal):\n 1. fs ! j \\<bullet> fs ! k =\n    vec k (\\<lambda>j. fs ! j \\<bullet> fs ! k) $ j", "by simp"], ["proof (state)\nthis:\n  fs ! j \\<bullet> fs ! k = b $ j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  (0::'a) =\n  fs ! j \\<bullet>\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n  b $ j", "have \"b $ j = - (fs ! j \\<bullet> ?sumk)\""], ["proof (prove)\nusing this:\n  (0::'a) =\n  fs ! j \\<bullet>\n  M.sumlist\n   (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]) +\n  b $ j\n\ngoal (1 subgoal):\n 1. b $ j =\n    - (fs ! j \\<bullet>\n       M.sumlist\n        (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]))", "by linarith"], ["proof (state)\nthis:\n  b $ j =\n  - (fs ! j \\<bullet>\n     M.sumlist\n      (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "}"], ["proof (state)\nthis:\n  ?j3 < k \\<Longrightarrow>\n  b $ ?j3 =\n  - (fs ! ?j3 \\<bullet>\n     M.sumlist\n      (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "note b_index = this"], ["proof (state)\nthis:\n  ?j3 < k \\<Longrightarrow>\n  b $ ?j3 =\n  - (fs ! ?j3 \\<bullet>\n     M.sumlist\n      (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k]))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "let ?x = \"vec k (\\<lambda> i. - IM $$ (k, i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have x: \"?x \\<in> carrier_vec k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec k (\\<lambda>i. - IM $$ (k, i)) \\<in> carrier_vec k", "by auto"], ["proof (state)\nthis:\n  vec k (\\<lambda>i. - IM $$ (k, i)) \\<in> carrier_vec k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "from k"], ["proof (chain)\npicking this:\n  k < length fs", "have km: \"k \\<le> m\""], ["proof (prove)\nusing this:\n  k < length fs\n\ngoal (1 subgoal):\n 1. k \\<le> length fs", "by simp"], ["proof (state)\nthis:\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have bGx: \"b = Gramian_matrix fs k *\\<^sub>v (vec k (\\<lambda> i. - IM $$ (k, i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = Gramian_matrix fs k *\\<^sub>v vec k (\\<lambda>i. - IM $$ (k, i))", "unfolding Gramian_matrix_alt_alt_def[OF km]"], ["proof (prove)\ngoal (1 subgoal):\n 1. b =\n    mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j) *\\<^sub>v\n    vec k (\\<lambda>i. - IM $$ (k, i))", "proof (rule eq_vecI; simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       b $ i =\n       vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet>\n       vec k (\\<lambda>i. - IM $$ (k, i))\n 2. dim_vec b = k", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       b $ i =\n       vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet>\n       vec k (\\<lambda>i. - IM $$ (k, i))\n 2. dim_vec b = k", "assume i: \"i < k\""], ["proof (state)\nthis:\n  i < k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       b $ i =\n       vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet>\n       vec k (\\<lambda>i. - IM $$ (k, i))\n 2. dim_vec b = k", "have \"b $ i = - (\\<Sum>x\\<leftarrow>[0..<k]. fs ! i \\<bullet> (IM $$ (k, x) \\<cdot>\\<^sub>v fs ! x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b $ i =\n    - (\\<Sum>x\\<leftarrow>[0..<\n                           k]. fs ! i \\<bullet>\n                               (IM $$ (k, x) \\<cdot>\\<^sub>v fs ! x))", "unfolding b_index[OF i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet>\n       M.sumlist\n        (map (\\<lambda>i. IM $$ (k, i) \\<cdot>\\<^sub>v fs ! i) [0..<k])) =\n    - (\\<Sum>x\\<leftarrow>[0..<\n                           k]. fs ! i \\<bullet>\n                               (IM $$ (k, x) \\<cdot>\\<^sub>v fs ! x))", "by (subst scalar_prod_right_sum_distrib, insert setk i k, auto simp: o_def)"], ["proof (state)\nthis:\n  b $ i =\n  - (\\<Sum>x\\<leftarrow>[0..<\n                         k]. fs ! i \\<bullet>\n                             (IM $$ (k, x) \\<cdot>\\<^sub>v fs ! x))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       b $ i =\n       vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet>\n       vec k (\\<lambda>i. - IM $$ (k, i))\n 2. dim_vec b = k", "also"], ["proof (state)\nthis:\n  b $ i =\n  - (\\<Sum>x\\<leftarrow>[0..<\n                         k]. fs ! i \\<bullet>\n                             (IM $$ (k, x) \\<cdot>\\<^sub>v fs ! x))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       b $ i =\n       vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet>\n       vec k (\\<lambda>i. - IM $$ (k, i))\n 2. dim_vec b = k", "have \"\\<dots> = vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet> vec k (\\<lambda>i. - IM $$ (k, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (\\<Sum>x\\<leftarrow>[0..<\n                           k]. fs ! i \\<bullet>\n                               (IM $$ (k, x) \\<cdot>\\<^sub>v fs ! x)) =\n    vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet>\n    vec k (\\<lambda>i. - IM $$ (k, i))", "by (subst (3) scalar_prod_def, insert i k, auto simp: o_def sum_list_sum_nth simp flip: sum_negf\n          intro!: sum.cong)"], ["proof (state)\nthis:\n  - (\\<Sum>x\\<leftarrow>[0..<\n                         k]. fs ! i \\<bullet>\n                             (IM $$ (k, x) \\<cdot>\\<^sub>v fs ! x)) =\n  vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet>\n  vec k (\\<lambda>i. - IM $$ (k, i))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       b $ i =\n       vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet>\n       vec k (\\<lambda>i. - IM $$ (k, i))\n 2. dim_vec b = k", "finally"], ["proof (chain)\npicking this:\n  b $ i =\n  vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet>\n  vec k (\\<lambda>i. - IM $$ (k, i))", "show \"b $ i = vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet> vec k (\\<lambda>i. - IM $$ (k, i))\""], ["proof (prove)\nusing this:\n  b $ i =\n  vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet>\n  vec k (\\<lambda>i. - IM $$ (k, i))\n\ngoal (1 subgoal):\n 1. b $ i =\n    vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet>\n    vec k (\\<lambda>i. - IM $$ (k, i))", "."], ["proof (state)\nthis:\n  b $ i =\n  vec k (\\<lambda>j. fs ! i \\<bullet> fs ! j) \\<bullet>\n  vec k (\\<lambda>i. - IM $$ (k, i))\n\ngoal (1 subgoal):\n 1. dim_vec b = k", "qed (simp add: b_def)"], ["proof (state)\nthis:\n  b = Gramian_matrix fs k *\\<^sub>v vec k (\\<lambda>i. - IM $$ (k, i))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "have G: \"Gramian_matrix fs k \\<in> carrier_mat k k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_matrix fs k \\<in> carrier_mat k k", "unfolding Gramian_matrix_alt_alt_def[OF km]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j) \\<in> carrier_mat k k", "by simp"], ["proof (state)\nthis:\n  Gramian_matrix fs k \\<in> carrier_mat k k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "from cramer_lemma_mat[OF G x, folded bGx Gramian_determinant_def]"], ["proof (chain)\npicking this:\n  ?k < k \\<Longrightarrow>\n  det (replace_col (Gramian_matrix fs k) b ?k) =\n  vec k (\\<lambda>i. - IM $$ (k, i)) $ ?k * d k", "have \"i < k \\<Longrightarrow> \n      d k * IM $$ (k, i) = - det (replace_col (Gramian_matrix fs k) (vec k (\\<lambda> j. fs ! j \\<bullet> fs ! k)) i)\" \n      for i"], ["proof (prove)\nusing this:\n  ?k < k \\<Longrightarrow>\n  det (replace_col (Gramian_matrix fs k) b ?k) =\n  vec k (\\<lambda>i. - IM $$ (k, i)) $ ?k * d k\n\ngoal (1 subgoal):\n 1. i < k \\<Longrightarrow>\n    d k * IM $$ (k, i) =\n    - det (replace_col (Gramian_matrix fs k)\n            (vec k (\\<lambda>j. fs ! j \\<bullet> fs ! k)) i)", "unfolding b_def"], ["proof (prove)\nusing this:\n  ?k < k \\<Longrightarrow>\n  det (replace_col (Gramian_matrix fs k)\n        (vec k (\\<lambda>j. fs ! j \\<bullet> fs ! k)) ?k) =\n  vec k (\\<lambda>i. - IM $$ (k, i)) $ ?k * d k\n\ngoal (1 subgoal):\n 1. i < k \\<Longrightarrow>\n    d k * IM $$ (k, i) =\n    - det (replace_col (Gramian_matrix fs k)\n            (vec k (\\<lambda>j. fs ! j \\<bullet> fs ! k)) i)", "by simp"], ["proof (state)\nthis:\n  ?i1 < k \\<Longrightarrow>\n  d k * IM $$ (k, ?i1) =\n  - det (replace_col (Gramian_matrix fs k)\n          (vec k (\\<lambda>j. fs ! j \\<bullet> fs ! k)) ?i1)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 < length fs; ?i1 < ?k4\\<rbrakk>\n  \\<Longrightarrow> d ?k4 * IM $$ (?k4, ?i1) =\n                    - det (replace_col (Gramian_matrix fs ?k4)\n                            (vec ?k4\n                              (\\<lambda>j. fs ! j \\<bullet> fs ! ?k4))\n                            ?i1)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "note IM_lower_values = this"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 < length fs; ?i1 < ?k4\\<rbrakk>\n  \\<Longrightarrow> d ?k4 * IM $$ (?k4, ?i1) =\n                    - det (replace_col (Gramian_matrix fs ?k4)\n                            (vec ?k4\n                              (\\<lambda>j. fs ! j \\<bullet> fs ! ?k4))\n                            ?i1)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 < length fs; ?i1 < ?k4\\<rbrakk>\n  \\<Longrightarrow> d ?k4 * IM $$ (?k4, ?i1) =\n                    - det (replace_col (Gramian_matrix fs ?k4)\n                            (vec ?k4\n                              (\\<lambda>j. fs ! j \\<bullet> fs ! ?k4))\n                            ?i1)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "assume i: \"i < m\" and j: \"j < m\""], ["proof (state)\nthis:\n  i < length fs\n  j < length fs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "from i"], ["proof (chain)\npicking this:\n  i < length fs", "have im: \"i \\<le> m\""], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. i \\<le> length fs", "by auto"], ["proof (state)\nthis:\n  i \\<le> length fs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "consider (1) \"j < i\" | (2) \"j = i\" | (3) \"i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < i \\<Longrightarrow> thesis; j = i \\<Longrightarrow> thesis;\n     i < j \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>j < i \\<Longrightarrow> ?thesis1;\n   j = i \\<Longrightarrow> ?thesis1;\n   i < j \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "thus \"d i * IM $$ (i,j) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>j < i \\<Longrightarrow> ?thesis1;\n   j = i \\<Longrightarrow> ?thesis1;\n   i < j \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. d i * IM $$ (i, j) \\<in> \\<int>", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. j < i \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>\n 2. j = i \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>\n 3. i < j \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "case 1"], ["proof (state)\nthis:\n  j < i\n\ngoal (3 subgoals):\n 1. j < i \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>\n 2. j = i \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>\n 3. i < j \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d i * IM $$ (i, j) \\<in> \\<int>", "unfolding IM_lower_values[OF i 1] replace_col_def Gramian_matrix_alt_alt_def[OF im]"], ["proof (prove)\ngoal (1 subgoal):\n 1. - det (mat (dim_row\n                 (mat i i (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)))\n            (dim_col (mat i i (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)))\n            (\\<lambda>(ia, ja).\n                if ja = j\n                then vec i (\\<lambda>j. fs ! j \\<bullet> fs ! i) $ ia\n                else mat i i (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j) $$\n                     (ia, ja)))\n    \\<in> \\<int>", "by (intro Ints_minus Ints_det, insert i j, auto intro!: Ints_scalar_prod[of _ n] fs_int)"], ["proof (state)\nthis:\n  d i * IM $$ (i, j) \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>\n 2. i < j \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>\n 2. i < j \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "case 3"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>\n 2. i < j \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d i * IM $$ (i, j) \\<in> \\<int>", "unfolding IM_lower_triag[OF 3 j]"], ["proof (prove)\ngoal (1 subgoal):\n 1. d i * (0::'a) \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  d i * IM $$ (i, j) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "case 2"], ["proof (state)\nthis:\n  j = i\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow> d i * IM $$ (i, j) \\<in> \\<int>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d i * IM $$ (i, j) \\<in> \\<int>", "unfolding IM_diag_1[OF i] 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. d i * (1::'a) \\<in> \\<int>", "using i"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. d i * (1::'a) \\<in> \\<int>", "unfolding Gramian_determinant_def\n         Gramian_matrix_alt_alt_def[OF im]"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. det (mat i i (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)) * (1::'a)\n    \\<in> \\<int>", "by (intro Ints_mult Ints_det, insert i j, auto intro!: Ints_scalar_prod[of _ n] fs_int)"], ["proof (state)\nthis:\n  d i * IM $$ (i, j) \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d i * IM $$ (i, j) \\<in> \\<int>\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 < length fs; ?j3 < length fs\\<rbrakk>\n  \\<Longrightarrow> d ?i3 * IM $$ (?i3, ?j3) \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition inv_mu_ij_mat :: \"nat \\<Rightarrow> nat \\<Rightarrow> int \\<Rightarrow> int mat\" where\n \"inv_mu_ij_mat i j c = (let\n    B = mat m m (\\<lambda> ij. if ij = (i,j) then c else 0);\n    C = mat m m (\\<lambda> (i,j). the_inv (of_int :: _ \\<Rightarrow> 'a) (d i * the (mat_inverse (M m)) $$ (i,j)))\n   in B * C + 1\\<^sub>m m)\""], ["", "lemma inv_mu_ij_mat: assumes i: \"i < m\" and ji: \"j < i\" \n  shows \n(* Effect on \\<mu> *)\n   \"map_mat of_int (inv_mu_ij_mat i j c) * M m =\n    mat m m (\\<lambda>ij. if ij = (i, j) then of_int c * d j else 0) + M m\" (* only change value of \\<mu>_ij *)\n(* Effect on A *)\n  \"A \\<in> carrier_mat m n \\<Longrightarrow> c mod p = 0 \\<Longrightarrow> map_mat (\\<lambda> x. x mod p) (inv_mu_ij_mat i j c * A) = \n    (map_mat (\\<lambda> x. x mod p) A)\" (* no change (mod p) *)\n(* The transformation-matrix is ... *)\n  \"inv_mu_ij_mat i j c \\<in> carrier_mat m m\" (* ... of dimension m*m *)\n  \"i' < j' \\<Longrightarrow> j' < m \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i',j') = 0\" (* ... lower triangular *)\n  \"k < m \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k,k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n     mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n     M (length fs) &&&\n     (\\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n      \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                         (inv_mu_ij_mat i j c * A) =\n                        map_mat (\\<lambda>x. x mod p) A)) &&&\n    inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs) &&&\n    (\\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n     \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0) &&&\n    (k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1)", "(* ... with diagonal all 1 *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n     mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n     M (length fs) &&&\n     (\\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n      \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                         (inv_mu_ij_mat i j c * A) =\n                        map_mat (\\<lambda>x. x mod p) A)) &&&\n    inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs) &&&\n    (\\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n     \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0) &&&\n    (k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1)", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "obtain IM where IM: \"IM = the (mat_inverse (M m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>IM.\n        IM = the (mat_inverse (M (length fs))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  IM = the (mat_inverse (M (length fs)))\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "let ?oi = \"of_int :: _ \\<Rightarrow> 'a\""], ["proof (state)\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "let ?C = \"mat m m (\\<lambda> ij. if ij = (i,j) then ?oi c else 0)\""], ["proof (state)\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "let ?D = \"mat m m (\\<lambda> (i,j). d i * IM $$ (i,j))\""], ["proof (state)\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have oi: \"inj ?oi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj of_int", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV. of_int x = of_int y \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj of_int\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have C: \"?C \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a))\n    \\<in> carrier_mat (length fs) (length fs)", "by auto"], ["proof (state)\nthis:\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a))\n  \\<in> carrier_mat (length fs) (length fs)\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "from i ji"], ["proof (chain)\npicking this:\n  i < length fs\n  j < i", "have j: \"j < m\""], ["proof (prove)\nusing this:\n  i < length fs\n  j < i\n\ngoal (1 subgoal):\n 1. j < length fs", "by auto"], ["proof (state)\nthis:\n  j < length fs\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "from j"], ["proof (chain)\npicking this:\n  j < length fs", "have jm: \"{0..<m} = {0..<j} \\<union> {j} \\<union> {Suc j..<m}\""], ["proof (prove)\nusing this:\n  j < length fs\n\ngoal (1 subgoal):\n 1. {0..<length fs} = {0..<j} \\<union> {j} \\<union> {Suc j..<length fs}", "by auto"], ["proof (state)\nthis:\n  {0..<length fs} = {0..<j} \\<union> {j} \\<union> {Suc j..<length fs}\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "note IM_props = d_inv_mu_integer[OF IM] inv_mu_inverse[OF IM]"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length fs; ?j < length fs\\<rbrakk>\n  \\<Longrightarrow> d ?i * IM $$ (?i, ?j) \\<in> \\<int>\n  IM * M (length fs) = 1\\<^sub>m (length fs)\n  M (length fs) * IM = 1\\<^sub>m (length fs)\n  IM \\<in> carrier_mat (length fs) (length fs)\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have mat_oi: \"map_mat ?oi (inv_mu_ij_mat i j c) = ?C * ?D + 1\\<^sub>m m\" (is \"?MM = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n    mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) +\n    1\\<^sub>m (length fs)", "unfolding inv_mu_ij_mat_def Let_def IM[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom\n     (mat (length fs) (length fs)\n       (\\<lambda>ij. if ij = (i, j) then c else 0) *\n      mat (length fs) (length fs)\n       (\\<lambda>(i, j). the_inv of_int (d i * IM $$ (i, j))) +\n      1\\<^sub>m (length fs)) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n    mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) +\n    1\\<^sub>m (length fs)", "apply (subst of_int_hom.mat_hom_add, force, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom\n     (mat (length fs) (length fs)\n       (\\<lambda>ij. if ij = (i, j) then c else 0) *\n      mat (length fs) (length fs)\n       (\\<lambda>(i, j). the_inv of_int (d i * IM $$ (i, j)))) +\n    of_int_hom.mat_hom (1\\<^sub>m (length fs)) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n    mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) +\n    1\\<^sub>m (length fs)", "apply (rule arg_cong2[of _ _ _ _ \"(+)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. of_int_hom.mat_hom\n     (mat (length fs) (length fs)\n       (\\<lambda>ij. if ij = (i, j) then c else 0) *\n      mat (length fs) (length fs)\n       (\\<lambda>(i, j). the_inv of_int (d i * IM $$ (i, j)))) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n    mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))\n 2. of_int_hom.mat_hom (1\\<^sub>m (length fs)) = 1\\<^sub>m (length fs)", "apply (subst of_int_hom.mat_hom_mult, force, force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. of_int_hom.mat_hom\n     (mat (length fs) (length fs)\n       (\\<lambda>ij. if ij = (i, j) then c else 0)) *\n    of_int_hom.mat_hom\n     (mat (length fs) (length fs)\n       (\\<lambda>(i, j). the_inv of_int (d i * IM $$ (i, j)))) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n    mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))\n 2. of_int_hom.mat_hom (1\\<^sub>m (length fs)) = 1\\<^sub>m (length fs)", "apply (rule arg_cong2[of _ _ _ _ \"(*)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. of_int_hom.mat_hom\n     (mat (length fs) (length fs)\n       (\\<lambda>ij. if ij = (i, j) then c else 0)) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a))\n 2. of_int_hom.mat_hom\n     (mat (length fs) (length fs)\n       (\\<lambda>(i, j). the_inv of_int (d i * IM $$ (i, j)))) =\n    mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))\n 3. of_int_hom.mat_hom (1\\<^sub>m (length fs)) = 1\\<^sub>m (length fs)", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. of_int_hom.mat_hom\n     (mat (length fs) (length fs)\n       (\\<lambda>(i, j). the_inv of_int (d i * IM $$ (i, j)))) =\n    mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))\n 2. of_int_hom.mat_hom (1\\<^sub>m (length fs)) = 1\\<^sub>m (length fs)", "apply (rule eq_matI, (auto)[3], goal_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> of_int (the_inv of_int (d i * IM $$ (i, j))) =\n                         d i * IM $$ (i, j)\n 2. of_int_hom.mat_hom (1\\<^sub>m (length fs)) = 1\\<^sub>m (length fs)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> of_int (the_inv of_int (d i * IM $$ (i, j))) =\n                         d i * IM $$ (i, j)\n 2. of_int_hom.mat_hom (1\\<^sub>m (length fs)) = 1\\<^sub>m (length fs)", "case (1 i j)"], ["proof (state)\nthis:\n  i < length fs\n  j < length fs\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n       \\<Longrightarrow> of_int (the_inv of_int (d i * IM $$ (i, j))) =\n                         d i * IM $$ (i, j)\n 2. of_int_hom.mat_hom (1\\<^sub>m (length fs)) = 1\\<^sub>m (length fs)", "from IM_props(1)[OF 1]"], ["proof (chain)\npicking this:\n  d i * IM $$ (i, j) \\<in> \\<int>", "show ?case"], ["proof (prove)\nusing this:\n  d i * IM $$ (i, j) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. of_int (the_inv of_int (d i * IM $$ (i, j))) = d i * IM $$ (i, j)", "unfolding Ints_def"], ["proof (prove)\nusing this:\n  d i * IM $$ (i, j) \\<in> range of_int\n\ngoal (1 subgoal):\n 1. of_int (the_inv of_int (d i * IM $$ (i, j))) = d i * IM $$ (i, j)", "using the_inv_f_f[OF oi]"], ["proof (prove)\nusing this:\n  d i * IM $$ (i, j) \\<in> range of_int\n  the_inv of_int (of_int ?x) = ?x\n\ngoal (1 subgoal):\n 1. of_int (the_inv of_int (d i * IM $$ (i, j))) = d i * IM $$ (i, j)", "by auto"], ["proof (state)\nthis:\n  of_int (the_inv of_int (d i * IM $$ (i, j))) = d i * IM $$ (i, j)\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (1\\<^sub>m (length fs)) = 1\\<^sub>m (length fs)", "qed auto"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) =\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n  mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) +\n  1\\<^sub>m (length fs)\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have \"map_mat ?oi (inv_mu_ij_mat i j c) * M m = (?C * ?D) * M m + M m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n    mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) *\n    M (length fs) +\n    M (length fs)", "unfolding mat_oi"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) +\n     1\\<^sub>m (length fs)) *\n    M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n    mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) *\n    M (length fs) +\n    M (length fs)", "by (subst add_mult_distrib_mat[of _ m m], auto)"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n  mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) *\n  M (length fs) +\n  M (length fs)\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "also"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n  mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) *\n  M (length fs) +\n  M (length fs)\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have \"(?C * ?D) * M m = ?C * (?D * M m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n    mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) *\n    M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n    (mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) *\n     M (length fs))", "by (rule assoc_mult_mat, auto)"], ["proof (state)\nthis:\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n  mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) *\n  M (length fs) =\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n  (mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) *\n   M (length fs))\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "also"], ["proof (state)\nthis:\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n  mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) *\n  M (length fs) =\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n  (mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) *\n   M (length fs))\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have \"?D = mat m m (\\<lambda> (i,j). if i = j then d j else 0) * IM\" (is \"_ = ?E * _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) =\n    mat (length fs) (length fs)\n     (\\<lambda>(i, j). if i = j then d j else (0::'a)) *\n    IM", "proof (rule eq_matI, insert IM_props(4), auto simp: scalar_prod_def, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs;\n        IM \\<in> carrier_mat (length fs) (length fs)\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) =\n                         (\\<Sum>ia = 0..<length fs.\n                             (if i = ia then d ia else (0::'a)) *\n                             IM $$ (ia, j))", "case (1 i j)"], ["proof (state)\nthis:\n  i < length fs\n  j < length fs\n  IM \\<in> carrier_mat (length fs) (length fs)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs;\n        IM \\<in> carrier_mat (length fs) (length fs)\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) =\n                         (\\<Sum>ia = 0..<length fs.\n                             (if i = ia then d ia else (0::'a)) *\n                             IM $$ (ia, j))", "hence id: \"{0..<m} = {0..<i} \\<union> {i} \\<union> {Suc i ..<m}\""], ["proof (prove)\nusing this:\n  i < length fs\n  j < length fs\n  IM \\<in> carrier_mat (length fs) (length fs)\n\ngoal (1 subgoal):\n 1. {0..<length fs} = {0..<i} \\<union> {i} \\<union> {Suc i..<length fs}", "by (auto simp add: list_trisect)"], ["proof (state)\nthis:\n  {0..<length fs} = {0..<i} \\<union> {i} \\<union> {Suc i..<length fs}\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < length fs;\n        IM \\<in> carrier_mat (length fs) (length fs)\\<rbrakk>\n       \\<Longrightarrow> d i * IM $$ (i, j) =\n                         (\\<Sum>ia = 0..<length fs.\n                             (if i = ia then d ia else (0::'a)) *\n                             IM $$ (ia, j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. d i * IM $$ (i, j) =\n    (\\<Sum>i = 0..<length fs.\n        (if i = i then d i else (0::'a)) * IM $$ (i, j))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. d i * IM $$ (i, j) =\n    (\\<Sum>i\\<in>{0..<i} \\<union> {i} \\<union> {Suc i..<length fs}.\n       (if i = i then d i else (0::'a)) * IM $$ (i, j))", "by (auto simp: sum.union_disjoint)"], ["proof (state)\nthis:\n  d i * IM $$ (i, j) =\n  (\\<Sum>i = 0..<length fs. (if i = i then d i else (0::'a)) * IM $$ (i, j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j). if i = j then d j else (0::'a)) *\n  IM\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "also"], ["proof (state)\nthis:\n  mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j). if i = j then d j else (0::'a)) *\n  IM\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have \"\\<dots> * M m = ?E * (IM * M m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>(i, j). if i = j then d j else (0::'a)) *\n    IM *\n    M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>(i, j). if i = j then d j else (0::'a)) *\n    (IM * M (length fs))", "by (rule assoc_mult_mat[of _ m m], insert IM_props, auto)"], ["proof (state)\nthis:\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j). if i = j then d j else (0::'a)) *\n  IM *\n  M (length fs) =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j). if i = j then d j else (0::'a)) *\n  (IM * M (length fs))\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "also"], ["proof (state)\nthis:\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j). if i = j then d j else (0::'a)) *\n  IM *\n  M (length fs) =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j). if i = j then d j else (0::'a)) *\n  (IM * M (length fs))\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have \"IM * M m = 1\\<^sub>m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IM * M (length fs) = 1\\<^sub>m (length fs)", "by fact"], ["proof (state)\nthis:\n  IM * M (length fs) = 1\\<^sub>m (length fs)\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "also"], ["proof (state)\nthis:\n  IM * M (length fs) = 1\\<^sub>m (length fs)\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have \"?E * 1\\<^sub>m m = ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>(i, j). if i = j then d j else (0::'a)) *\n    1\\<^sub>m (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>(i, j). if i = j then d j else (0::'a))", "by simp"], ["proof (state)\nthis:\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j). if i = j then d j else (0::'a)) *\n  1\\<^sub>m (length fs) =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j). if i = j then d j else (0::'a))\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "also"], ["proof (state)\nthis:\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j). if i = j then d j else (0::'a)) *\n  1\\<^sub>m (length fs) =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j). if i = j then d j else (0::'a))\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have \"?C * ?E = mat m m (\\<lambda> ij. if ij = (i,j) then ?oi c * d j else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n    mat (length fs) (length fs)\n     (\\<lambda>(i, j). if i = j then d j else (0::'a)) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a))", "by (rule eq_matI, auto simp: scalar_prod_def, auto simp: jm sum.union_disjoint)"], ["proof (state)\nthis:\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j). if i = j then d j else (0::'a)) =\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a))\n\ngoal (5 subgoals):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)\n 2. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 3. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 4. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 5. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "finally"], ["proof (chain)\npicking this:\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n  M (length fs)", "show \"map_mat ?oi (inv_mu_ij_mat i j c) * M m = \n    mat m m (\\<lambda> ij. if ij = (i,j) then ?oi c * d j else 0) + M m\""], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n  M (length fs)\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n    M (length fs)", "."], ["proof (state)\nthis:\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) * M (length fs) =\n  mat (length fs) (length fs)\n   (\\<lambda>ij. if ij = (i, j) then of_int c * d j else (0::'a)) +\n  M (length fs)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n 3. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 4. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "show carr: \"inv_mu_ij_mat i j c \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)", "unfolding inv_mu_ij_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let B = mat (length fs) (length fs)\n              (\\<lambda>ij. if ij = (i, j) then c else 0);\n         C = mat (length fs) (length fs)\n              (\\<lambda>(i, j).\n                  the_inv of_int\n                   (d i * the (mat_inverse (M (length fs))) $$ (i, j)))\n     in B * C + 1\\<^sub>m (length fs))\n    \\<in> carrier_mat (length fs) (length fs)", "by auto"], ["proof (state)\nthis:\n  inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 3. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "{"], ["proof (state)\nthis:\n  inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 3. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "assume k: \"k < m\""], ["proof (state)\nthis:\n  k < length fs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 3. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have \"of_int (inv_mu_ij_mat i j c $$ (k,k)) = ?MM $$ (k,k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (inv_mu_ij_mat i j c $$ (k, k)) =\n    of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (k, k)", "using carr k"], ["proof (prove)\nusing this:\n  inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n  k < length fs\n\ngoal (1 subgoal):\n 1. of_int (inv_mu_ij_mat i j c $$ (k, k)) =\n    of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (k, k)", "by auto"], ["proof (state)\nthis:\n  of_int (inv_mu_ij_mat i j c $$ (k, k)) =\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (k, k)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 3. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "also"], ["proof (state)\nthis:\n  of_int (inv_mu_ij_mat i j c $$ (k, k)) =\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (k, k)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 3. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have \"\\<dots> = (?C * ?D) $$ (k,k) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (k, k) =\n    (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n    (k, k) +\n    (1::'a)", "unfolding mat_oi"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) +\n     1\\<^sub>m (length fs)) $$\n    (k, k) =\n    (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n    (k, k) +\n    (1::'a)", "using k"], ["proof (prove)\nusing this:\n  k < length fs\n\ngoal (1 subgoal):\n 1. (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) +\n     1\\<^sub>m (length fs)) $$\n    (k, k) =\n    (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n    (k, k) +\n    (1::'a)", "by simp"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (k, k) =\n  (mat (length fs) (length fs)\n    (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n   mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n  (k, k) +\n  (1::'a)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 3. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "also"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (k, k) =\n  (mat (length fs) (length fs)\n    (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n   mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n  (k, k) +\n  (1::'a)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 3. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "have \"(?C * ?D) $$ (k,k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n    (k, k) =\n    (0::'a)", "using k"], ["proof (prove)\nusing this:\n  k < length fs\n\ngoal (1 subgoal):\n 1. (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n    (k, k) =\n    (0::'a)", "by (auto simp: scalar_prod_def, auto simp: jm sum.union_disjoint \n        inv_mu_lower_triangular[OF IM ji i])"], ["proof (state)\nthis:\n  (mat (length fs) (length fs)\n    (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n   mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n  (k, k) =\n  (0::'a)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n 3. k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1", "finally"], ["proof (chain)\npicking this:\n  of_int (inv_mu_ij_mat i j c $$ (k, k)) = (0::'a) + (1::'a)", "show \"inv_mu_ij_mat i j c $$ (k,k) = 1\""], ["proof (prove)\nusing this:\n  of_int (inv_mu_ij_mat i j c $$ (k, k)) = (0::'a) + (1::'a)\n\ngoal (1 subgoal):\n 1. inv_mu_ij_mat i j c $$ (k, k) = 1", "by simp"], ["proof (state)\nthis:\n  inv_mu_ij_mat i j c $$ (k, k) = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0", "}"], ["proof (state)\nthis:\n  k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0", "{"], ["proof (state)\nthis:\n  k < length fs \\<Longrightarrow> inv_mu_ij_mat i j c $$ (k, k) = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0", "assume ij': \"i' < j'\" \"j' < m\""], ["proof (state)\nthis:\n  i' < j'\n  j' < length fs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0", "have \"of_int (inv_mu_ij_mat i j c $$ (i',j')) = ?MM $$ (i',j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (inv_mu_ij_mat i j c $$ (i', j')) =\n    of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (i', j')", "using carr ij'"], ["proof (prove)\nusing this:\n  inv_mu_ij_mat i j c \\<in> carrier_mat (length fs) (length fs)\n  i' < j'\n  j' < length fs\n\ngoal (1 subgoal):\n 1. of_int (inv_mu_ij_mat i j c $$ (i', j')) =\n    of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (i', j')", "by auto"], ["proof (state)\nthis:\n  of_int (inv_mu_ij_mat i j c $$ (i', j')) =\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (i', j')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0", "also"], ["proof (state)\nthis:\n  of_int (inv_mu_ij_mat i j c $$ (i', j')) =\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (i', j')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0", "have \"\\<dots> = (?C * ?D) $$ (i',j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (i', j') =\n    (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n    (i', j')", "unfolding mat_oi"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) +\n     1\\<^sub>m (length fs)) $$\n    (i', j') =\n    (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n    (i', j')", "using ij'"], ["proof (prove)\nusing this:\n  i' < j'\n  j' < length fs\n\ngoal (1 subgoal):\n 1. (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j)) +\n     1\\<^sub>m (length fs)) $$\n    (i', j') =\n    (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n    (i', j')", "by simp"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (i', j') =\n  (mat (length fs) (length fs)\n    (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n   mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n  (i', j')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0", "also"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (inv_mu_ij_mat i j c) $$ (i', j') =\n  (mat (length fs) (length fs)\n    (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n   mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n  (i', j')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0", "have \"(?C * ?D) $$ (i',j') = (if i' = i then ?oi c * (d j * IM $$ (j, j')) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n    (i', j') =\n    (if i' = i then of_int c * (d j * IM $$ (j, j')) else (0::'a))", "using ij' i j"], ["proof (prove)\nusing this:\n  i' < j'\n  j' < length fs\n  i < length fs\n  j < length fs\n\ngoal (1 subgoal):\n 1. (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n     mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n    (i', j') =\n    (if i' = i then of_int c * (d j * IM $$ (j, j')) else (0::'a))", "by (auto simp: scalar_prod_def, auto simp: jm sum.union_disjoint)"], ["proof (state)\nthis:\n  (mat (length fs) (length fs)\n    (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n   mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n  (i', j') =\n  (if i' = i then of_int c * (d j * IM $$ (j, j')) else (0::'a))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0", "also"], ["proof (state)\nthis:\n  (mat (length fs) (length fs)\n    (\\<lambda>ij. if ij = (i, j) then of_int c else (0::'a)) *\n   mat (length fs) (length fs) (\\<lambda>(i, j). d i * IM $$ (i, j))) $$\n  (i', j') =\n  (if i' = i then of_int c * (d j * IM $$ (j, j')) else (0::'a))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i' = i then of_int c * (d j * IM $$ (j, j')) else (0::'a)) = (0::'a)", "using inv_mu_lower_triangular[OF IM _ ij'(2), of j] ij' i ji"], ["proof (prove)\nusing this:\n  j < j' \\<Longrightarrow> IM $$ (j, j') = (0::'a)\n  i' < j'\n  j' < length fs\n  i < length fs\n  j < i\n\ngoal (1 subgoal):\n 1. (if i' = i then of_int c * (d j * IM $$ (j, j')) else (0::'a)) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (if i' = i then of_int c * (d j * IM $$ (j, j')) else (0::'a)) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A\n 2. \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n    \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0", "finally"], ["proof (chain)\npicking this:\n  of_int (inv_mu_ij_mat i j c $$ (i', j')) = (0::'a)", "show \"inv_mu_ij_mat i j c $$ (i',j') = 0\""], ["proof (prove)\nusing this:\n  of_int (inv_mu_ij_mat i j c $$ (i', j')) = (0::'a)\n\ngoal (1 subgoal):\n 1. inv_mu_ij_mat i j c $$ (i', j') = 0", "by simp"], ["proof (state)\nthis:\n  inv_mu_ij_mat i j c $$ (i', j') = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n  \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "{"], ["proof (state)\nthis:\n  \\<lbrakk>i' < j'; j' < length fs\\<rbrakk>\n  \\<Longrightarrow> inv_mu_ij_mat i j c $$ (i', j') = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "assume A: \"A \\<in> carrier_mat m n\" and c: \"c mod p = 0\""], ["proof (state)\nthis:\n  A \\<in> carrier_mat (length fs) n\n  c mod p = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "let ?mod = \"map_mat (\\<lambda> x. x mod p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "let ?C = \"mat m m (\\<lambda> ij. if ij = (i,j) then c else 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "let ?D = \"mat m m (\\<lambda> ij. if ij = (i,j) then 1 else (0 :: int))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "define B where \"B = mat m m (\\<lambda> (i,j). the_inv ?oi (d i * the (mat_inverse (M m)) $$ (i,j)))\""], ["proof (state)\nthis:\n  B =\n  mat (length fs) (length fs)\n   (\\<lambda>(i, j).\n       the_inv of_int (d i * the (mat_inverse (M (length fs))) $$ (i, j)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "have B: \"B \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat (length fs) (length fs)", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>(i, j).\n         the_inv of_int (d i * the (mat_inverse (M (length fs))) $$ (i, j)))\n    \\<in> carrier_mat (length fs) (length fs)", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat (length fs) (length fs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "define BA where \"BA = B * A\""], ["proof (state)\nthis:\n  BA = B * A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "have BA: \"BA \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BA \\<in> carrier_mat (length fs) n", "unfolding BA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. B * A \\<in> carrier_mat (length fs) n", "using A B"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat (length fs) n\n  B \\<in> carrier_mat (length fs) (length fs)\n\ngoal (1 subgoal):\n 1. B * A \\<in> carrier_mat (length fs) n", "by auto"], ["proof (state)\nthis:\n  BA \\<in> carrier_mat (length fs) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "define DBA where \"DBA = ?D * BA\""], ["proof (state)\nthis:\n  DBA =\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then 1 else 0) *\n  BA\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "have DBA: \"DBA \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBA \\<in> carrier_mat (length fs) n", "unfolding DBA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then 1 else 0) *\n    BA\n    \\<in> carrier_mat (length fs) n", "using BA"], ["proof (prove)\nusing this:\n  BA \\<in> carrier_mat (length fs) n\n\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then 1 else 0) *\n    BA\n    \\<in> carrier_mat (length fs) n", "by auto"], ["proof (state)\nthis:\n  DBA \\<in> carrier_mat (length fs) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "have \"?mod (inv_mu_ij_mat i j c * A) = \n     ?mod ((?C * B + 1\\<^sub>m m) * A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>x. x mod p) (inv_mu_ij_mat i j c * A) =\n    map_mat (\\<lambda>x. x mod p)\n     ((mat (length fs) (length fs)\n        (\\<lambda>ij. if ij = (i, j) then c else 0) *\n       B +\n       1\\<^sub>m (length fs)) *\n      A)", "unfolding inv_mu_ij_mat_def B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>x. x mod p)\n     ((let B = mat (length fs) (length fs)\n                (\\<lambda>ij. if ij = (i, j) then c else 0);\n           C = mat (length fs) (length fs)\n                (\\<lambda>(i, j).\n                    the_inv of_int\n                     (d i * the (mat_inverse (M (length fs))) $$ (i, j)))\n       in B * C + 1\\<^sub>m (length fs)) *\n      A) =\n    map_mat (\\<lambda>x. x mod p)\n     ((mat (length fs) (length fs)\n        (\\<lambda>ij. if ij = (i, j) then c else 0) *\n       mat (length fs) (length fs)\n        (\\<lambda>(i, j).\n            the_inv of_int\n             (d i * the (mat_inverse (M (length fs))) $$ (i, j))) +\n       1\\<^sub>m (length fs)) *\n      A)", "by simp"], ["proof (state)\nthis:\n  map_mat (\\<lambda>x. x mod p) (inv_mu_ij_mat i j c * A) =\n  map_mat (\\<lambda>x. x mod p)\n   ((mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then c else 0) *\n     B +\n     1\\<^sub>m (length fs)) *\n    A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "also"], ["proof (state)\nthis:\n  map_mat (\\<lambda>x. x mod p) (inv_mu_ij_mat i j c * A) =\n  map_mat (\\<lambda>x. x mod p)\n   ((mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then c else 0) *\n     B +\n     1\\<^sub>m (length fs)) *\n    A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "have \"(?C * B + 1\\<^sub>m m) * A = ?C * B * A + A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then c else 0) *\n     B +\n     1\\<^sub>m (length fs)) *\n    A =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then c else 0) *\n    B *\n    A +\n    A", "by (subst add_mult_distrib_mat, insert A B, auto)"], ["proof (state)\nthis:\n  (mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then c else 0) *\n   B +\n   1\\<^sub>m (length fs)) *\n  A =\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then c else 0) *\n  B *\n  A +\n  A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "also"], ["proof (state)\nthis:\n  (mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then c else 0) *\n   B +\n   1\\<^sub>m (length fs)) *\n  A =\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then c else 0) *\n  B *\n  A +\n  A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "have \"?C * B * A = ?C * BA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then c else 0) *\n    B *\n    A =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then c else 0) *\n    BA", "unfolding BA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then c else 0) *\n    B *\n    A =\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then c else 0) *\n    (B * A)", "by (rule assoc_mult_mat, insert A B, auto)"], ["proof (state)\nthis:\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then c else 0) *\n  B *\n  A =\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then c else 0) *\n  BA\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "also"], ["proof (state)\nthis:\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then c else 0) *\n  B *\n  A =\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then c else 0) *\n  BA\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "have \"?C = c \\<cdot>\\<^sub>m ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then c else 0) =\n    c \\<cdot>\\<^sub>m\n    mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then 1 else 0)", "by (rule eq_matI, auto)"], ["proof (state)\nthis:\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then c else 0) =\n  c \\<cdot>\\<^sub>m\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "also"], ["proof (state)\nthis:\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then c else 0) =\n  c \\<cdot>\\<^sub>m\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "have \"\\<dots> * BA = c \\<cdot>\\<^sub>m DBA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then 1 else 0) *\n    BA =\n    c \\<cdot>\\<^sub>m DBA", "using BA"], ["proof (prove)\nusing this:\n  BA \\<in> carrier_mat (length fs) n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then 1 else 0) *\n    BA =\n    c \\<cdot>\\<^sub>m DBA", "unfolding DBA_def"], ["proof (prove)\nusing this:\n  BA \\<in> carrier_mat (length fs) n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m\n    mat (length fs) (length fs)\n     (\\<lambda>ij. if ij = (i, j) then 1 else 0) *\n    BA =\n    c \\<cdot>\\<^sub>m\n    (mat (length fs) (length fs)\n      (\\<lambda>ij. if ij = (i, j) then 1 else 0) *\n     BA)", "by auto"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>m\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then 1 else 0) *\n  BA =\n  c \\<cdot>\\<^sub>m DBA\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "also"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>m\n  mat (length fs) (length fs) (\\<lambda>ij. if ij = (i, j) then 1 else 0) *\n  BA =\n  c \\<cdot>\\<^sub>m DBA\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "have \"?mod (\\<dots> + A) = ?mod A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>x. x mod p) (c \\<cdot>\\<^sub>m DBA + A) =\n    map_mat (\\<lambda>x. x mod p) A", "by (rule eq_matI, insert DBA A c, auto simp: mult.assoc)"], ["proof (state)\nthis:\n  map_mat (\\<lambda>x. x mod p) (c \\<cdot>\\<^sub>m DBA + A) =\n  map_mat (\\<lambda>x. x mod p) A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n    \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                       (inv_mu_ij_mat i j c * A) =\n                      map_mat (\\<lambda>x. x mod p) A", "finally"], ["proof (chain)\npicking this:\n  map_mat (\\<lambda>x. x mod p) (inv_mu_ij_mat i j c * A) =\n  map_mat (\\<lambda>x. x mod p) A", "show \"?mod (inv_mu_ij_mat i j c * A) = ?mod A\""], ["proof (prove)\nusing this:\n  map_mat (\\<lambda>x. x mod p) (inv_mu_ij_mat i j c * A) =\n  map_mat (\\<lambda>x. x mod p) A\n\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>x. x mod p) (inv_mu_ij_mat i j c * A) =\n    map_mat (\\<lambda>x. x mod p) A", "."], ["proof (state)\nthis:\n  map_mat (\\<lambda>x. x mod p) (inv_mu_ij_mat i j c * A) =\n  map_mat (\\<lambda>x. x mod p) A\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>A \\<in> carrier_mat (length fs) n; c mod p = 0\\<rbrakk>\n  \\<Longrightarrow> map_mat (\\<lambda>x. x mod p)\n                     (inv_mu_ij_mat i j c * A) =\n                    map_mat (\\<lambda>x. x mod p) A\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma Gramian_determinant_of_int: assumes fs: \"set fs \\<subseteq> carrier_vec n\" \n  and j: \"j \\<le> length fs\" \nshows \"of_int (gram_schmidt.Gramian_determinant n fs j)\n  = gram_schmidt.Gramian_determinant n (map (map_vec rat_of_int) fs) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (gram_schmidt.Gramian_determinant n fs j) =\n    gram_schmidt.Gramian_determinant n (map of_int_hom.vec_hom fs) j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int (gram_schmidt.Gramian_determinant n fs j) =\n    gram_schmidt.Gramian_determinant n (map of_int_hom.vec_hom fs) j", "from j"], ["proof (chain)\npicking this:\n  j \\<le> length fs", "have j: \"k < j \\<Longrightarrow> k < length fs\" for k"], ["proof (prove)\nusing this:\n  j \\<le> length fs\n\ngoal (1 subgoal):\n 1. k < j \\<Longrightarrow> k < length fs", "by auto"], ["proof (state)\nthis:\n  ?k < j \\<Longrightarrow> ?k < length fs\n\ngoal (1 subgoal):\n 1. rat_of_int (gram_schmidt.Gramian_determinant n fs j) =\n    gram_schmidt.Gramian_determinant n (map of_int_hom.vec_hom fs) j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (gram_schmidt.Gramian_determinant n fs j) =\n    gram_schmidt.Gramian_determinant n (map of_int_hom.vec_hom fs) j", "unfolding gram_schmidt.Gramian_determinant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (det (gram_schmidt.Gramian_matrix n fs j)) =\n    det (gram_schmidt.Gramian_matrix n (map of_int_hom.vec_hom fs) j)", "by (subst of_int_hom.hom_det[symmetric], rule arg_cong[of _ _ det],\n      unfold gram_schmidt.Gramian_matrix_def Let_def, subst of_int_hom.mat_hom_mult, force, force,\n      unfold map_mat_transpose[symmetric],\n      rule arg_cong2[of _ _ _ _ \"\\<lambda> x y. x * y\\<^sup>T\"], insert fs[unfolded set_conv_nth] \n      j, (fastforce intro!: eq_matI)+)"], ["proof (state)\nthis:\n  rat_of_int (gram_schmidt.Gramian_determinant n fs j) =\n  gram_schmidt.Gramian_determinant n (map of_int_hom.vec_hom fs) j\n\ngoal:\nNo subgoals!", "qed"], ["", "context LLL\nbegin"], ["", "(* this lemma might also be useful for swap/add-operation *)"], ["", "lemma multiply_invertible_mat: assumes lin: \"lin_indep fs\" \n  and len: \"length fs = m\" \n  and A: \"A \\<in> carrier_mat m m\" \n  and A_invertible: \"\\<exists> B. B \\<in> carrier_mat m m \\<and> B * A = 1\\<^sub>m m\" \n  and fs'_prod: \"fs' = Matrix.rows (A * mat_of_rows n fs)\" \nshows \"lattice_of fs' = lattice_of fs\" \n  \"lin_indep fs'\" \n  \"length fs' = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of fs' = lattice_of fs &&&\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs') &&& length fs' = m", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "let ?Mfs = \"mat_of_rows n fs\""], ["proof (state)\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "let ?Mfs' = \"mat_of_rows n fs'\""], ["proof (state)\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "from A_invertible"], ["proof (chain)\npicking this:\n  \\<exists>B. B \\<in> carrier_mat m m \\<and> B * A = 1\\<^sub>m m", "obtain B where B: \"B \\<in> carrier_mat m m\" and inv: \"B * A = 1\\<^sub>m m\""], ["proof (prove)\nusing this:\n  \\<exists>B. B \\<in> carrier_mat m m \\<and> B * A = 1\\<^sub>m m\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<in> carrier_mat m m; B * A = 1\\<^sub>m m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat m m\n  B * A = 1\\<^sub>m m\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "from lin"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)", "have fs: \"set fs \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. set fs \\<subseteq> carrier_vec n", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n\ngoal (1 subgoal):\n 1. set fs \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set fs \\<subseteq> carrier_vec n\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "with len"], ["proof (chain)\npicking this:\n  length fs = m\n  set fs \\<subseteq> carrier_vec n", "have Mfs: \"?Mfs \\<in> carrier_mat m n\""], ["proof (prove)\nusing this:\n  length fs = m\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. mat_of_rows n fs \\<in> carrier_mat m n", "by auto"], ["proof (state)\nthis:\n  mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "from A Mfs"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat m m\n  mat_of_rows n fs \\<in> carrier_mat m n", "have prod: \"A * ?Mfs \\<in> carrier_mat m n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat m m\n  mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. A * mat_of_rows n fs \\<in> carrier_mat m n", "by auto"], ["proof (state)\nthis:\n  A * mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "hence fs': \"length fs' = m\" \"set fs' \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  A * mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. length fs' = m &&& set fs' \\<subseteq> carrier_vec n", "unfolding fs'_prod"], ["proof (prove)\nusing this:\n  A * mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. length (rows (A * mat_of_rows n fs)) = m &&&\n    set (rows (A * mat_of_rows n fs)) \\<subseteq> carrier_vec n", "by (auto simp: Matrix.rows_def Matrix.row_def)"], ["proof (state)\nthis:\n  length fs' = m\n  set fs' \\<subseteq> carrier_vec n\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "have Mfs_prod': \"?Mfs' = A * ?Mfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n fs' = A * mat_of_rows n fs", "unfolding arg_cong[OF fs'_prod, of \"mat_of_rows n\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n (rows (A * mat_of_rows n fs)) = A * mat_of_rows n fs", "by (intro eq_matI, auto simp: mat_of_rows_def)"], ["proof (state)\nthis:\n  mat_of_rows n fs' = A * mat_of_rows n fs\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "have \"B * ?Mfs' = B * (A * ?Mfs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B * mat_of_rows n fs' = B * (A * mat_of_rows n fs)", "unfolding Mfs_prod'"], ["proof (prove)\ngoal (1 subgoal):\n 1. B * (A * mat_of_rows n fs) = B * (A * mat_of_rows n fs)", "by simp"], ["proof (state)\nthis:\n  B * mat_of_rows n fs' = B * (A * mat_of_rows n fs)\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "also"], ["proof (state)\nthis:\n  B * mat_of_rows n fs' = B * (A * mat_of_rows n fs)\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "have \"\\<dots> = (B * A) * ?Mfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B * (A * mat_of_rows n fs) = B * A * mat_of_rows n fs", "by (subst assoc_mult_mat[OF _ A Mfs], insert B, auto)"], ["proof (state)\nthis:\n  B * (A * mat_of_rows n fs) = B * A * mat_of_rows n fs\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "also"], ["proof (state)\nthis:\n  B * (A * mat_of_rows n fs) = B * A * mat_of_rows n fs\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "have \"B * A = 1\\<^sub>m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B * A = 1\\<^sub>m m", "by fact"], ["proof (state)\nthis:\n  B * A = 1\\<^sub>m m\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "also"], ["proof (state)\nthis:\n  B * A = 1\\<^sub>m m\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "have \"\\<dots> * ?Mfs = ?Mfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m m * mat_of_rows n fs = mat_of_rows n fs", "using Mfs"], ["proof (prove)\nusing this:\n  mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m m * mat_of_rows n fs = mat_of_rows n fs", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m m * mat_of_rows n fs = mat_of_rows n fs\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "finally"], ["proof (chain)\npicking this:\n  B * mat_of_rows n fs' = mat_of_rows n fs", "have Mfs_prod: \"?Mfs = B * ?Mfs'\""], ["proof (prove)\nusing this:\n  B * mat_of_rows n fs' = mat_of_rows n fs\n\ngoal (1 subgoal):\n 1. mat_of_rows n fs = B * mat_of_rows n fs'", ".."], ["proof (state)\nthis:\n  mat_of_rows n fs = B * mat_of_rows n fs'\n\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "interpret LLL: LLL_with_assms n m fs 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_with_assms n m fs 2", "by (unfold_locales, auto simp: len lin)"], ["proof (state)\ngoal (3 subgoals):\n 1. lattice_of fs' = lattice_of fs\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 3. length fs' = m", "from LLL.LLL_change_basis[OF fs'(2,1) B A Mfs_prod Mfs_prod']"], ["proof (chain)\npicking this:\n  lattice_of fs' = lattice_of fs\n  LLL_with_assms n m fs' 2", "show latt': \"lattice_of fs' = lattice_of fs\" and lin': \"gs.lin_indpt_list (RAT fs')\" \n    and len': \"length fs' = m\""], ["proof (prove)\nusing this:\n  lattice_of fs' = lattice_of fs\n  LLL_with_assms n m fs' 2\n\ngoal (1 subgoal):\n 1. lattice_of fs' = lattice_of fs &&&\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs') &&& length fs' = m", "by (auto simp add: LLL_with_assms_def)"], ["proof (state)\nthis:\n  lattice_of fs' = lattice_of fs\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length fs' = m\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This is the key lemma.\\<close>"], ["", "lemma change_single_element: assumes lin: \"lin_indep fs\" \n  and len: \"length fs = m\" \n  and i: \"i < m\" and ji: \"j < i\"  \n  and A: \"A = gram_schmidt_fs_int.inv_mu_ij_mat n (RAT fs)\"    \\<comment> \\<open>the transformation matrix A\\<close>\n  and fs'_prod: \"fs' = Matrix.rows (A i j c * mat_of_rows n fs)\" \\<comment> \\<open>fs' is the new basis\\<close>\n  and latt: \"lattice_of fs = L\" \nshows \"lattice_of fs' = L\"\n  \"c mod p = 0 \\<Longrightarrow> map (map_vec (\\<lambda> x. x mod p)) fs' = map (map_vec (\\<lambda> x. x mod p)) fs\" \n  \"lin_indep fs'\" \n  \"length fs' = m\" \n  \"\\<And> k. k < m \\<Longrightarrow> gso fs' k = gso fs k\" \n  \"\\<And> k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\" \n  \"i' < m \\<Longrightarrow> j' < m \\<Longrightarrow> \n    \\<mu> fs' i' j' = (if (i',j') = (i,j) then rat_of_int (c * d fs j) + \\<mu> fs i' j' else \\<mu> fs i' j')\" \n  \"i' < m \\<Longrightarrow> j' < m \\<Longrightarrow> \n    d\\<mu> fs' i' j' = (if (i',j') = (i,j) then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j' else d\\<mu> fs i' j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((lattice_of fs' = L &&&\n      (c mod p = 0 \\<Longrightarrow>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs)) &&&\n     gs.lin_indpt_list (map of_int_hom.vec_hom fs') &&& length fs' = m) &&&\n    ((\\<And>k.\n         k < m \\<Longrightarrow>\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) &&&\n     (\\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k)) &&&\n    (\\<lbrakk>i' < m; j' < m\\<rbrakk>\n     \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                        i' j' =\n                       (if (i', j') = (i, j)\n                        then rat_of_int (c * d fs j) +\n                             gram_schmidt_fs.\\<mu> n\n                              (map of_int_hom.vec_hom fs) i' j'\n                        else gram_schmidt_fs.\\<mu> n\n                              (map of_int_hom.vec_hom fs) i' j')) &&&\n    (\\<lbrakk>i' < m; j' < m\\<rbrakk>\n     \\<Longrightarrow> d\\<mu> fs' i' j' =\n                       (if (i', j') = (i, j)\n                        then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                        else d\\<mu> fs i' j'))", "proof -"], ["proof (state)\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) +\n                            gram_schmidt_fs.\\<mu> n\n                             (map of_int_hom.vec_hom fs) i' j'\n                       else gram_schmidt_fs.\\<mu> n\n                             (map of_int_hom.vec_hom fs) i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "let ?A = \"A i j c\""], ["proof (state)\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) +\n                            gram_schmidt_fs.\\<mu> n\n                             (map of_int_hom.vec_hom fs) i' j'\n                       else gram_schmidt_fs.\\<mu> n\n                             (map of_int_hom.vec_hom fs) i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "let ?Mfs = \"mat_of_rows n fs\""], ["proof (state)\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) +\n                            gram_schmidt_fs.\\<mu> n\n                             (map of_int_hom.vec_hom fs) i' j'\n                       else gram_schmidt_fs.\\<mu> n\n                             (map of_int_hom.vec_hom fs) i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "let ?Mfs' = \"mat_of_rows n fs'\""], ["proof (state)\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) +\n                            gram_schmidt_fs.\\<mu> n\n                             (map of_int_hom.vec_hom fs) i' j'\n                       else gram_schmidt_fs.\\<mu> n\n                             (map of_int_hom.vec_hom fs) i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "from lin"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)", "have fs: \"set fs \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. set fs \\<subseteq> carrier_vec n", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n\ngoal (1 subgoal):\n 1. set fs \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set fs \\<subseteq> carrier_vec n\n\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) +\n                            gram_schmidt_fs.\\<mu> n\n                             (map of_int_hom.vec_hom fs) i' j'\n                       else gram_schmidt_fs.\\<mu> n\n                             (map of_int_hom.vec_hom fs) i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "with len"], ["proof (chain)\npicking this:\n  length fs = m\n  set fs \\<subseteq> carrier_vec n", "have Mfs: \"?Mfs \\<in> carrier_mat m n\""], ["proof (prove)\nusing this:\n  length fs = m\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. mat_of_rows n fs \\<in> carrier_mat m n", "by auto"], ["proof (state)\nthis:\n  mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) +\n                            gram_schmidt_fs.\\<mu> n\n                             (map of_int_hom.vec_hom fs) i' j'\n                       else gram_schmidt_fs.\\<mu> n\n                             (map of_int_hom.vec_hom fs) i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "interpret gsi: gram_schmidt_fs_int n \"RAT fs\"\n    rewrites \"gsi.inv_mu_ij_mat = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_int n (map of_int_hom.vec_hom fs) &&&\n    gram_schmidt_fs_int.inv_mu_ij_mat n (map of_int_hom.vec_hom fs) = A", "using lin"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs_int n (map of_int_hom.vec_hom fs) &&&\n    gram_schmidt_fs_int.inv_mu_ij_mat n (map of_int_hom.vec_hom fs) = A", "unfolding A"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs_int n (map of_int_hom.vec_hom fs) &&&\n    gram_schmidt_fs_int.inv_mu_ij_mat n (map of_int_hom.vec_hom fs) =\n    gram_schmidt_fs_int.inv_mu_ij_mat n (map of_int_hom.vec_hom fs)", "by (unfold_locales, insert lin[unfolded gs.lin_indpt_list_def], auto simp: set_conv_nth)"], ["proof (state)\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k = gsi.gso k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) + gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "note A = gsi.inv_mu_ij_mat[unfolded length_map len, OF i ji, where c = c]"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (A i j c) * gsi.M m =\n  mat m m (\\<lambda>ij. if ij = (i, j) then rat_of_int c * gsi.d j else 0) +\n  gsi.M m\n  \\<lbrakk>?A \\<in> carrier_mat m n; c mod ?p = 0\\<rbrakk>\n  \\<Longrightarrow> map_mat (\\<lambda>x. x mod ?p) (A i j c * ?A) =\n                    map_mat (\\<lambda>x. x mod ?p) ?A\n  A i j c \\<in> carrier_mat m m\n  \\<lbrakk>?i' < ?j'; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> A i j c $$ (?i', ?j') = 0\n  ?k < m \\<Longrightarrow> A i j c $$ (?k, ?k) = 1\n\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k = gsi.gso k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) + gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "from A(3) Mfs"], ["proof (chain)\npicking this:\n  A i j c \\<in> carrier_mat m m\n  mat_of_rows n fs \\<in> carrier_mat m n", "have prod: \"?A * ?Mfs \\<in> carrier_mat m n\""], ["proof (prove)\nusing this:\n  A i j c \\<in> carrier_mat m m\n  mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. A i j c * mat_of_rows n fs \\<in> carrier_mat m n", "by auto"], ["proof (state)\nthis:\n  A i j c * mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k = gsi.gso k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) + gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "hence fs': \"length fs' = m\" \"set fs' \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  A i j c * mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. length fs' = m &&& set fs' \\<subseteq> carrier_vec n", "unfolding fs'_prod"], ["proof (prove)\nusing this:\n  A i j c * mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. length (rows (A i j c * mat_of_rows n fs)) = m &&&\n    set (rows (A i j c * mat_of_rows n fs)) \\<subseteq> carrier_vec n", "by (auto simp: Matrix.rows_def Matrix.row_def)"], ["proof (state)\nthis:\n  length fs' = m\n  set fs' \\<subseteq> carrier_vec n\n\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k = gsi.gso k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) + gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "have Mfs_prod': \"?Mfs' = ?A * ?Mfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n fs' = A i j c * mat_of_rows n fs", "unfolding arg_cong[OF fs'_prod, of \"mat_of_rows n\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n (rows (A i j c * mat_of_rows n fs)) =\n    A i j c * mat_of_rows n fs", "by (intro eq_matI, auto simp: mat_of_rows_def)"], ["proof (state)\nthis:\n  mat_of_rows n fs' = A i j c * mat_of_rows n fs\n\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k = gsi.gso k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) + gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "have detA: \"det ?A = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (A i j c) = 1", "by (subst det_lower_triangular[OF A(4) A(3)], insert A, auto intro!: prod_list_neutral \n      simp: diag_mat_def)"], ["proof (state)\nthis:\n  det (A i j c) = 1\n\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k = gsi.gso k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) + gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "have \"\\<exists> B. B \\<in> carrier_mat m m \\<and> B * ?A = 1\\<^sub>m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B. B \\<in> carrier_mat m m \\<and> B * A i j c = 1\\<^sub>m m", "by (intro exI[of _ \"adj_mat ?A\"], insert adj_mat[OF A(3)], auto simp: detA)"], ["proof (state)\nthis:\n  \\<exists>B. B \\<in> carrier_mat m m \\<and> B * A i j c = 1\\<^sub>m m\n\ngoal (8 subgoals):\n 1. lattice_of fs' = L\n 2. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 3. gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n 4. length fs' = m\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k = gsi.gso k\n 6. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 7. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) + gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 8. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "from multiply_invertible_mat[OF lin len A(3) this fs'_prod] latt"], ["proof (chain)\npicking this:\n  lattice_of fs' = lattice_of fs\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length fs' = m\n  lattice_of fs = L", "show latt': \"lattice_of fs' = L\" and lin': \"gs.lin_indpt_list (RAT fs')\" \n    and len': \"length fs' = m\""], ["proof (prove)\nusing this:\n  lattice_of fs' = lattice_of fs\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length fs' = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. lattice_of fs' = L &&&\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs') &&& length fs' = m", "by auto"], ["proof (state)\nthis:\n  lattice_of fs' = L\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length fs' = m\n\ngoal (5 subgoals):\n 1. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 2. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k = gsi.gso k\n 3. \\<And>k. k \\<le> m \\<Longrightarrow> d fs' k = d fs k\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * d fs j) + gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 5. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n                       else d\\<mu> fs i' j')", "interpret LLL: LLL_with_assms n m fs 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_with_assms n m fs 2", "by (unfold_locales, auto simp: len lin)"], ["proof (state)\ngoal (5 subgoals):\n 1. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 2. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k = gsi.gso k\n 3. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 5. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "interpret fs: fs_int_indpt n fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int_indpt n fs", "by (standard, auto simp: lin)"], ["proof (state)\ngoal (5 subgoals):\n 1. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 2. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k = gsi.gso k\n 3. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs')\n                       i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 5. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "interpret fs': fs_int_indpt n fs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int_indpt n fs'", "by (standard, auto simp: lin')"], ["proof (state)\ngoal (5 subgoals):\n 1. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 3. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 5. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "{"], ["proof (state)\ngoal (5 subgoals):\n 1. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 3. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 5. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "assume c: \"c mod p = 0\""], ["proof (state)\nthis:\n  c mod p = 0\n\ngoal (5 subgoals):\n 1. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 3. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 5. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have id: \"rows (map_mat f A) = map (map_vec f) (rows A)\" for f A"], ["proof (prove)\ngoal (1 subgoal):\n 1. rows (map_mat f A) = map (map_vec f) (rows A)", "unfolding rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (row (map_mat f A)) [0..<dim_row (map_mat f A)] =\n    map (map_vec f) (map (row A) [0..<dim_row A])", "by auto"], ["proof (state)\nthis:\n  rows (map_mat ?f2 ?A2) = map (map_vec ?f2) (rows ?A2)\n\ngoal (5 subgoals):\n 1. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 3. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 5. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have rows_id: \"set fs \\<subseteq> carrier_vec n \\<Longrightarrow> rows (mat_of_rows n fs) = fs\" for fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. set fs \\<subseteq> carrier_vec n \\<Longrightarrow>\n    rows (mat_of_rows n fs) = fs", "unfolding mat_of_rows_def rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set fs \\<subseteq> carrier_vec n \\<Longrightarrow>\n    map (row (mat (length fs) n (\\<lambda>(i, y). fs ! i $ y)))\n     [0..<dim_row (mat (length fs) n (\\<lambda>(i, y). fs ! i $ y))] =\n    fs", "by (force simp: Matrix.row_def set_conv_nth intro!: nth_equalityI)"], ["proof (state)\nthis:\n  set ?fs3 \\<subseteq> carrier_vec n \\<Longrightarrow>\n  rows (mat_of_rows n ?fs3) = ?fs3\n\ngoal (5 subgoals):\n 1. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 3. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 5. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "from A(2)[OF Mfs c]"], ["proof (chain)\npicking this:\n  map_mat (\\<lambda>x. x mod p) (A i j c * mat_of_rows n fs) =\n  map_mat (\\<lambda>x. x mod p) (mat_of_rows n fs)", "have \"rows (map_mat (\\<lambda>x. x mod p) ?Mfs') = rows (map_mat (\\<lambda>x. x mod p) ?Mfs)\""], ["proof (prove)\nusing this:\n  map_mat (\\<lambda>x. x mod p) (A i j c * mat_of_rows n fs) =\n  map_mat (\\<lambda>x. x mod p) (mat_of_rows n fs)\n\ngoal (1 subgoal):\n 1. rows (map_mat (\\<lambda>x. x mod p) (mat_of_rows n fs')) =\n    rows (map_mat (\\<lambda>x. x mod p) (mat_of_rows n fs))", "unfolding Mfs_prod'"], ["proof (prove)\nusing this:\n  map_mat (\\<lambda>x. x mod p) (A i j c * mat_of_rows n fs) =\n  map_mat (\\<lambda>x. x mod p) (mat_of_rows n fs)\n\ngoal (1 subgoal):\n 1. rows (map_mat (\\<lambda>x. x mod p) (A i j c * mat_of_rows n fs)) =\n    rows (map_mat (\\<lambda>x. x mod p) (mat_of_rows n fs))", "by simp"], ["proof (state)\nthis:\n  rows (map_mat (\\<lambda>x. x mod p) (mat_of_rows n fs')) =\n  rows (map_mat (\\<lambda>x. x mod p) (mat_of_rows n fs))\n\ngoal (5 subgoals):\n 1. c mod p = 0 \\<Longrightarrow>\n    map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 3. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 5. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "from this[unfolded id rows_id[OF fs] rows_id[OF fs'(2)]]"], ["proof (chain)\npicking this:\n  map (map_vec (\\<lambda>x. x mod p)) fs' =\n  map (map_vec (\\<lambda>x. x mod p)) fs", "show \"map (map_vec (\\<lambda> x. x mod p)) fs' = map (map_vec (\\<lambda> x. x mod p)) fs\""], ["proof (prove)\nusing this:\n  map (map_vec (\\<lambda>x. x mod p)) fs' =\n  map (map_vec (\\<lambda>x. x mod p)) fs\n\ngoal (1 subgoal):\n 1. map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs", "."], ["proof (state)\nthis:\n  map (map_vec (\\<lambda>x. x mod p)) fs' =\n  map (map_vec (\\<lambda>x. x mod p)) fs\n\ngoal (4 subgoals):\n 1. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 2. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 3. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "}"], ["proof (state)\nthis:\n  c mod p = 0 \\<Longrightarrow>\n  map (map_vec (\\<lambda>x. x mod p)) fs' =\n  map (map_vec (\\<lambda>x. x mod p)) fs\n\ngoal (4 subgoals):\n 1. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 2. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 3. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "{"], ["proof (state)\nthis:\n  c mod p = 0 \\<Longrightarrow>\n  map (map_vec (\\<lambda>x. x mod p)) fs' =\n  map (map_vec (\\<lambda>x. x mod p)) fs\n\ngoal (4 subgoals):\n 1. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 2. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 3. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "define B where \"B = ?A\""], ["proof (state)\nthis:\n  B = A i j c\n\ngoal (4 subgoals):\n 1. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 2. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 3. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have gs_eq: \"k < m \\<Longrightarrow> gso fs' k = gso fs k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "proof(induct rule: nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>ma<n.\n                   ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma;\n        n < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.gso n = gsi.gso n", "case (1 k)"], ["proof (state)\nthis:\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>ma<n.\n                   ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma;\n        n < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.gso n = gsi.gso n", "then"], ["proof (chain)\npicking this:\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n\ngoal (1 subgoal):\n 1. fs'.gs.gso k = gsi.gso k", "proof(cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ma<k.\n                ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma;\n     k < m; k = 0\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 2. \\<lbrakk>\\<forall>ma<k.\n                ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma;\n     k < m; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ma<k.\n                ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma;\n     k < m; k = 0\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 2. \\<lbrakk>\\<forall>ma<k.\n                ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma;\n     k < m; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "then"], ["proof (chain)\npicking this:\n  k = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. fs'.gs.gso k = gsi.gso k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"row ?Mfs' 0 = row ?Mfs 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "have 2: \"0\\<in> {0..<m}\" and 3: \"{1..<m} = {0..<m} - {0}\" \n              and 4: \"finite {0..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {0..<m} &&& {1..<m} = {0..<m} - {0} &&& finite {0..<m}", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n\ngoal (1 subgoal):\n 1. 0 \\<in> {0..<m} &&& {1..<m} = {0..<m} - {0} &&& finite {0..<m}", "by auto"], ["proof (state)\nthis:\n  0 \\<in> {0..<m}\n  {1..<m} = {0..<m} - {0}\n  finite {0..<m}\n\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "have \"row ?Mfs' 0 = vec n (\\<lambda>j. row B 0 \\<bullet> col ?Mfs j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 =\n    vec n (\\<lambda>j. row B 0 \\<bullet> col (mat_of_rows n fs) j)", "using row_mult A(3) Mfs 1 Mfs_prod'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?n; ?B \\<in> carrier_mat ?n ?nc;\n   ?i < ?nr\\<rbrakk>\n  \\<Longrightarrow> row (?A * ?B) ?i =\n                    vec ?nc (\\<lambda>j. row ?A ?i \\<bullet> col ?B j)\n  A i j c \\<in> carrier_mat m m\n  mat_of_rows n fs \\<in> carrier_mat m n\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n  mat_of_rows n fs' = A i j c * mat_of_rows n fs\n\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 =\n    vec n (\\<lambda>j. row B 0 \\<bullet> col (mat_of_rows n fs) j)", "unfolding B_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?n; ?B \\<in> carrier_mat ?n ?nc;\n   ?i < ?nr\\<rbrakk>\n  \\<Longrightarrow> row (?A * ?B) ?i =\n                    vec ?nc (\\<lambda>j. row ?A ?i \\<bullet> col ?B j)\n  A i j c \\<in> carrier_mat m m\n  mat_of_rows n fs \\<in> carrier_mat m n\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n  mat_of_rows n fs' = A i j c * mat_of_rows n fs\n\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 =\n    vec n (\\<lambda>ja. row (A i j c) 0 \\<bullet> col (mat_of_rows n fs) ja)", "by simp"], ["proof (state)\nthis:\n  row (mat_of_rows n fs') 0 =\n  vec n (\\<lambda>j. row B 0 \\<bullet> col (mat_of_rows n fs) j)\n\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "also"], ["proof (state)\nthis:\n  row (mat_of_rows n fs') 0 =\n  vec n (\\<lambda>j. row B 0 \\<bullet> col (mat_of_rows n fs) j)\n\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "have \"\\<dots> = vec n (\\<lambda>j. (\\<Sum>l\\<in>{0..<m}. B $$ (0, l) * ?Mfs $$ (l, j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B 0 \\<bullet> col (mat_of_rows n fs) j) =\n    vec n\n     (\\<lambda>j. \\<Sum>l = 0..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j))", "using Mfs A(3) len 1 B_def"], ["proof (prove)\nusing this:\n  mat_of_rows n fs \\<in> carrier_mat m n\n  A i j c \\<in> carrier_mat m m\n  length fs = m\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n  B = A i j c\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B 0 \\<bullet> col (mat_of_rows n fs) j) =\n    vec n\n     (\\<lambda>j. \\<Sum>l = 0..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j))", "unfolding scalar_prod_def"], ["proof (prove)\nusing this:\n  mat_of_rows n fs \\<in> carrier_mat m n\n  A i j c \\<in> carrier_mat m m\n  length fs = m\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n  B = A i j c\n\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>j.\n         \\<Sum>i = 0..<dim_vec (col (mat_of_rows n fs) j).\n            row B 0 $ i * col (mat_of_rows n fs) j $ i) =\n    vec n\n     (\\<lambda>j. \\<Sum>l = 0..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j))", "by auto"], ["proof (state)\nthis:\n  vec n (\\<lambda>j. row B 0 \\<bullet> col (mat_of_rows n fs) j) =\n  vec n\n   (\\<lambda>j. \\<Sum>l = 0..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j))\n\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "also"], ["proof (state)\nthis:\n  vec n (\\<lambda>j. row B 0 \\<bullet> col (mat_of_rows n fs) j) =\n  vec n\n   (\\<lambda>j. \\<Sum>l = 0..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j))\n\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "have \"\\<dots> = vec n (\\<lambda>j. B $$ (0, 0) * ?Mfs $$ (0, j) + \n              (\\<Sum>l\\<in>{1..<m}. B $$ (0, l) * ?Mfs $$ (l, j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>j.\n         \\<Sum>l = 0..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j)) =\n    vec n\n     (\\<lambda>j.\n         B $$ (0, 0) * mat_of_rows n fs $$ (0, j) +\n         (\\<Sum>l = 1..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j)))", "using Groups_Big.comm_monoid_add_class.sum.remove[OF 4 2] 3"], ["proof (prove)\nusing this:\n  sum ?g {0..<m} = ?g 0 + sum ?g ({0..<m} - {0})\n  {1..<m} = {0..<m} - {0}\n\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>j.\n         \\<Sum>l = 0..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j)) =\n    vec n\n     (\\<lambda>j.\n         B $$ (0, 0) * mat_of_rows n fs $$ (0, j) +\n         (\\<Sum>l = 1..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j)))", "by (simp add: \\<open>\\<And>g. sum g {0..<m} = g 0 + sum g ({0..<m} - {0})\\<close>)"], ["proof (state)\nthis:\n  vec n\n   (\\<lambda>j. \\<Sum>l = 0..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j)) =\n  vec n\n   (\\<lambda>j.\n       B $$ (0, 0) * mat_of_rows n fs $$ (0, j) +\n       (\\<Sum>l = 1..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j)))\n\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "also"], ["proof (state)\nthis:\n  vec n\n   (\\<lambda>j. \\<Sum>l = 0..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j)) =\n  vec n\n   (\\<lambda>j.\n       B $$ (0, 0) * mat_of_rows n fs $$ (0, j) +\n       (\\<Sum>l = 1..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j)))\n\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "have \"\\<dots> = row ?Mfs 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>j.\n         B $$ (0, 0) * mat_of_rows n fs $$ (0, j) +\n         (\\<Sum>l = 1..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j))) =\n    row (mat_of_rows n fs) 0", "using A(4-) 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i' < ?j'; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> A i j c $$ (?i', ?j') = 0\n  ?k < m \\<Longrightarrow> A i j c $$ (?k, ?k) = 1\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>j.\n         B $$ (0, 0) * mat_of_rows n fs $$ (0, j) +\n         (\\<Sum>l = 1..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j))) =\n    row (mat_of_rows n fs) 0", "unfolding B_def[symmetric]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i' < ?j'; ?j' < m\\<rbrakk> \\<Longrightarrow> B $$ (?i', ?j') = 0\n  ?k < m \\<Longrightarrow> B $$ (?k, ?k) = 1\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>j.\n         B $$ (0, 0) * mat_of_rows n fs $$ (0, j) +\n         (\\<Sum>l = 1..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j))) =\n    row (mat_of_rows n fs) 0", "by (simp add: row_def)"], ["proof (state)\nthis:\n  vec n\n   (\\<lambda>j.\n       B $$ (0, 0) * mat_of_rows n fs $$ (0, j) +\n       (\\<Sum>l = 1..<m. B $$ (0, l) * mat_of_rows n fs $$ (l, j))) =\n  row (mat_of_rows n fs) 0\n\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "finally"], ["proof (chain)\npicking this:\n  row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "show ?thesis"], ["proof (prove)\nusing this:\n  row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0\n\ngoal (1 subgoal):\n 1. row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "by (simp add: B_def Mfs_prod')"], ["proof (state)\nthis:\n  row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "then"], ["proof (chain)\npicking this:\n  row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0", "show ?thesis"], ["proof (prove)\nusing this:\n  row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0\n\ngoal (1 subgoal):\n 1. fs'.gs.gso k = gsi.gso k", "using True 1 fs'.f_carrier fs.f_carrier \n            fs'.gs.fs0_gso0 len' len gsi.fs0_gso0"], ["proof (prove)\nusing this:\n  row (mat_of_rows n fs') 0 = row (mat_of_rows n fs) 0\n  k = 0\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n  ?i < length fs' \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  0 < length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  map of_int_hom.vec_hom fs' ! 0 = fs'.gs.gso 0\n  length fs' = m\n  length fs = m\n  0 < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! 0 = gsi.gso 0\n\ngoal (1 subgoal):\n 1. fs'.gs.gso k = gsi.gso k", "by auto"], ["proof (state)\nthis:\n  fs'.gs.gso k = gsi.gso k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fs'.gs.gso k = gsi.gso k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ma<k.\n                ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma;\n     k < m; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ma<k.\n                ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma;\n     k < m; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ma<k.\n                ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma;\n     k < m; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fs'.gs.gso k = gsi.gso k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have gso0kcarr: \"gsi.gso ` {0 ..<k} \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gsi.gso ` {0..<k} \\<subseteq> local.LLL.Rn", "using 1(2) gsi.gso_carrier len"], ["proof (prove)\nusing this:\n  k < m\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gsi.gso ?i \\<in> local.LLL.Rn\n  length fs = m\n\ngoal (1 subgoal):\n 1. gsi.gso ` {0..<k} \\<subseteq> local.LLL.Rn", "by auto"], ["proof (state)\nthis:\n  gsi.gso ` {0..<k} \\<subseteq> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "hence gsospancarr: \"gs.span(gsi.gso ` {0 ..<k}) \\<subseteq> carrier_vec n \""], ["proof (prove)\nusing this:\n  gsi.gso ` {0..<k} \\<subseteq> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. gs.span (gsi.gso ` {0..<k}) \\<subseteq> local.LLL.Rn", "using span_is_subset2"], ["proof (prove)\nusing this:\n  gsi.gso ` {0..<k} \\<subseteq> local.LLL.Rn\n  ?S \\<subseteq> carrier_vec n \\<Longrightarrow>\n  local.span ?S \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. gs.span (gsi.gso ` {0..<k}) \\<subseteq> local.LLL.Rn", "by auto"], ["proof (state)\nthis:\n  gs.span (gsi.gso ` {0..<k}) \\<subseteq> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have fs'_gs_diff_span: \n            \"(RAT fs') !  k - fs'.gs.gso k \\<in> gs.span (gsi.gso ` {0 ..<k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "define gs'sum where \"gs'sum =\n              gs.M.sumlist (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v fs'.gs.gso ja) [0..<k])\""], ["proof (state)\nthis:\n  gs'sum =\n  gs.M.sumlist\n   (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v fs'.gs.gso ja)\n     [0..<k])\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "define gssum where \"gssum = \n              gs.M.sumlist (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja) [0..<k])\""], ["proof (state)\nthis:\n  gssum =\n  gs.M.sumlist\n   (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja) [0..<k])\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "have \"set (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja) [0..<k]) \n              \\<subseteq> gs.span(gsi.gso ` {0 ..<k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja)\n          [0..<k])\n    \\<subseteq> gs.span (gsi.gso ` {0..<k})", "using 1(2) gs.span_mem gso0kcarr"], ["proof (prove)\nusing this:\n  k < m\n  \\<lbrakk>?E \\<subseteq> local.LLL.Rn; ?u \\<in> ?E\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> gs.span ?E\n  gsi.gso ` {0..<k} \\<subseteq> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja)\n          [0..<k])\n    \\<subseteq> gs.span (gsi.gso ` {0..<k})", "by auto"], ["proof (state)\nthis:\n  set (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja)\n        [0..<k])\n  \\<subseteq> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "hence gssumspan: \"gssum \\<in> gs.span(gsi.gso ` {0 ..<k})\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja)\n        [0..<k])\n  \\<subseteq> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. gssum \\<in> gs.span (gsi.gso ` {0..<k})", "using atLeastLessThan_iff gso0kcarr imageE set_map set_upt \n                vec_space.sumlist_in_span"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja)\n        [0..<k])\n  \\<subseteq> gs.span (gsi.gso ` {0..<k})\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n  gsi.gso ` {0..<k} \\<subseteq> local.LLL.Rn\n  \\<lbrakk>?b \\<in> ?f ` ?A;\n   \\<And>x.\n      \\<lbrakk>?b = ?f x; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  set (map ?f ?xs) = ?f ` set ?xs\n  set [?i..<?j] = {?i..<?j}\n  \\<lbrakk>?W \\<subseteq> carrier_vec ?n;\n   \\<And>x.\n      x \\<in> set ?xs \\<Longrightarrow>\n      x \\<in> LinearCombinations.module.span class_ring\n               (module_vec TYPE(?'a) ?n) ?W\\<rbrakk>\n  \\<Longrightarrow> abelian_monoid.sumlist (module_vec TYPE(?'a) ?n) ?xs\n                    \\<in> LinearCombinations.module.span class_ring\n                           (module_vec TYPE(?'a) ?n) ?W\n\ngoal (1 subgoal):\n 1. gssum \\<in> gs.span (gsi.gso ` {0..<k})", "unfolding gssum_def"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja)\n        [0..<k])\n  \\<subseteq> gs.span (gsi.gso ` {0..<k})\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n  gsi.gso ` {0..<k} \\<subseteq> local.LLL.Rn\n  \\<lbrakk>?b \\<in> ?f ` ?A;\n   \\<And>x.\n      \\<lbrakk>?b = ?f x; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  set (map ?f ?xs) = ?f ` set ?xs\n  set [?i..<?j] = {?i..<?j}\n  \\<lbrakk>?W \\<subseteq> carrier_vec ?n;\n   \\<And>x.\n      x \\<in> set ?xs \\<Longrightarrow>\n      x \\<in> LinearCombinations.module.span class_ring\n               (module_vec TYPE(?'a) ?n) ?W\\<rbrakk>\n  \\<Longrightarrow> abelian_monoid.sumlist (module_vec TYPE(?'a) ?n) ?xs\n                    \\<in> LinearCombinations.module.span class_ring\n                           (module_vec TYPE(?'a) ?n) ?W\n\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja)\n       [0..<k])\n    \\<in> gs.span (gsi.gso ` {0..<k})", "by (smt subsetD)"], ["proof (state)\nthis:\n  gssum \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "hence gssumcarr: \"gssum \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  gssum \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. gssum \\<in> local.LLL.Rn", "using gsospancarr gssum_def"], ["proof (prove)\nusing this:\n  gssum \\<in> gs.span (gsi.gso ` {0..<k})\n  gs.span (gsi.gso ` {0..<k}) \\<subseteq> local.LLL.Rn\n  gssum =\n  gs.M.sumlist\n   (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja) [0..<k])\n\ngoal (1 subgoal):\n 1. gssum \\<in> local.LLL.Rn", "by blast"], ["proof (state)\nthis:\n  gssum \\<in> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "have sumid: \"gs'sum = gssum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs'sum = gssum", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gs'sum = gssum", "have \"map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v fs'.gs.gso ja) [0..<k] =\n                map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja) [0..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v fs'.gs.gso ja)\n     [0..<k] =\n    map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja) [0..<k]", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n\ngoal (1 subgoal):\n 1. map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v fs'.gs.gso ja)\n     [0..<k] =\n    map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja) [0..<k]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v fs'.gs.gso ja)\n   [0..<k] =\n  map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja) [0..<k]\n\ngoal (1 subgoal):\n 1. gs'sum = gssum", "thus ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v fs'.gs.gso ja)\n   [0..<k] =\n  map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja) [0..<k]\n\ngoal (1 subgoal):\n 1. gs'sum = gssum", "unfolding gs'sum_def gssum_def"], ["proof (prove)\nusing this:\n  map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v fs'.gs.gso ja)\n   [0..<k] =\n  map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja) [0..<k]\n\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v fs'.gs.gso ja)\n       [0..<k]) =\n    gs.M.sumlist\n     (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v gsi.gso ja)\n       [0..<k])", "by argo"], ["proof (state)\nthis:\n  gs'sum = gssum\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gs'sum = gssum\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "have \"(RAT fs') !  k = fs'.gs.gso k + gssum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = fs'.gs.gso k + gssum", "using fs'.gs.fs_by_gso_def len' False 1 sumid"], ["proof (prove)\nusing this:\n  ?i < length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  map of_int_hom.vec_hom fs' ! ?i =\n  fs'.gs.gso ?i +\n  gs.M.sumlist\n   (map (\\<lambda>ja. fs'.gs.\\<mu> ?i ja \\<cdot>\\<^sub>v fs'.gs.gso ja)\n     [0..<?i])\n  length fs' = m\n  k \\<noteq> 0\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n  gs'sum = gssum\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = fs'.gs.gso k + gssum", "unfolding gs'sum_def"], ["proof (prove)\nusing this:\n  ?i < length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  map of_int_hom.vec_hom fs' ! ?i =\n  fs'.gs.gso ?i +\n  gs.M.sumlist\n   (map (\\<lambda>ja. fs'.gs.\\<mu> ?i ja \\<cdot>\\<^sub>v fs'.gs.gso ja)\n     [0..<?i])\n  length fs' = m\n  k \\<noteq> 0\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n  gs.M.sumlist\n   (map (\\<lambda>ja. fs'.gs.\\<mu> k ja \\<cdot>\\<^sub>v fs'.gs.gso ja)\n     [0..<k]) =\n  gssum\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = fs'.gs.gso k + gssum", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! k = fs'.gs.gso k + gssum\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "hence \"(RAT fs') !  k - fs'.gs.gso k = gssum\""], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs' ! k = fs'.gs.gso k + gssum\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k = gssum", "using gssumcarr 1(2) len'"], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs' ! k = fs'.gs.gso k + gssum\n  gssum \\<in> local.LLL.Rn\n  k < m\n  length fs' = m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k = gssum", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k = gssum\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "thus ?thesis"], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k = gssum\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "using gssumspan"], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k = gssum\n  gssum \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "by simp"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n  \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n  \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "define v2 where \"v2 = sumlist (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..< k])\""], ["proof (state)\nthis:\n  v2 =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have v2carr: \"v2 \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v2 \\<in> carrier_vec n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v2 \\<in> carrier_vec n", "have \"set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..< k]) \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])\n    \\<subseteq> carrier_vec n", "using len 1(2) fs.f_carrier"], ["proof (prove)\nusing this:\n  length fs = m\n  k < m\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])\n    \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. v2 \\<in> carrier_vec n", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. v2 \\<in> carrier_vec n", "unfolding v2_def"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])\n    \\<in> carrier_vec n", "by simp"], ["proof (state)\nthis:\n  v2 \\<in> carrier_vec n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v2 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "define ratv2 where \"ratv2 = (map_vec rat_of_int v2)\""], ["proof (state)\nthis:\n  ratv2 = of_int_hom.vec_hom v2\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have ratv2carr: \"ratv2 \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ratv2 \\<in> local.LLL.Rn", "unfolding ratv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom v2 \\<in> local.LLL.Rn", "using v2carr"], ["proof (prove)\nusing this:\n  v2 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom v2 \\<in> local.LLL.Rn", "by simp"], ["proof (state)\nthis:\n  ratv2 \\<in> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have fs'id: \"(RAT fs') ! k = (RAT fs) ! k + ratv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "have zkm: \"[0..<m] = [0..<(Suc k)] @ [(Suc k)..<m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<m] = [0..<Suc k] @ [Suc k..<m]", "using 1(2)"], ["proof (prove)\nusing this:\n  k < m\n\ngoal (1 subgoal):\n 1. [0..<m] = [0..<Suc k] @ [Suc k..<m]", "by (metis Suc_lessI append_Nil2 upt_append upt_rec zero_less_Suc)"], ["proof (state)\nthis:\n  [0..<m] = [0..<Suc k] @ [Suc k..<m]\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "have prep: \"set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])\n    \\<subseteq> carrier_vec n", "using len fs.f_carrier"], ["proof (prove)\nusing this:\n  length fs = m\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])\n    \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "have \"fs' ! k = vec n (\\<lambda>j. row B k \\<bullet> col ?Mfs j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs' ! k = vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j)", "using 1(2) Mfs B_def A(3) fs'_prod"], ["proof (prove)\nusing this:\n  k < m\n  mat_of_rows n fs \\<in> carrier_mat m n\n  B = A i j c\n  A i j c \\<in> carrier_mat m m\n  fs' = rows (A i j c * mat_of_rows n fs)\n\ngoal (1 subgoal):\n 1. fs' ! k = vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j)", "by simp"], ["proof (state)\nthis:\n  fs' ! k = vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j)\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "also"], ["proof (state)\nthis:\n  fs' ! k = vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j)\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "have \"\\<dots> = sumlist (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "assume i: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "have \"(vec n (\\<lambda>j. row B k \\<bullet> col ?Mfs j)) $ i = row B k \\<bullet> col ?Mfs i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) $ i =\n    row B k \\<bullet> col (mat_of_rows n fs) i", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) $ i =\n    row B k \\<bullet> col (mat_of_rows n fs) i", "by auto"], ["proof (state)\nthis:\n  vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) $ i =\n  row B k \\<bullet> col (mat_of_rows n fs) i\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "also"], ["proof (state)\nthis:\n  vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) $ i =\n  row B k \\<bullet> col (mat_of_rows n fs) i\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "have \"\\<dots> = (\\<Sum>j = 0..<m. B $$ (k, j) * ?Mfs $$ (j,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row B k \\<bullet> col (mat_of_rows n fs) i =\n    (\\<Sum>j = 0..<m. B $$ (k, j) * mat_of_rows n fs $$ (j, i))", "using A(3)"], ["proof (prove)\nusing this:\n  A i j c \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. row B k \\<bullet> col (mat_of_rows n fs) i =\n    (\\<Sum>j = 0..<m. B $$ (k, j) * mat_of_rows n fs $$ (j, i))", "unfolding B_def[symmetric]"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. row B k \\<bullet> col (mat_of_rows n fs) i =\n    (\\<Sum>j = 0..<m. B $$ (k, j) * mat_of_rows n fs $$ (j, i))", "by (smt 1(2) Mfs R.finsum_cong' i atLeastLessThan_iff carrier_matD\n                      dim_col index_col index_row(1) scalar_prod_def)"], ["proof (state)\nthis:\n  row B k \\<bullet> col (mat_of_rows n fs) i =\n  (\\<Sum>j = 0..<m. B $$ (k, j) * mat_of_rows n fs $$ (j, i))\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "also"], ["proof (state)\nthis:\n  row B k \\<bullet> col (mat_of_rows n fs) i =\n  (\\<Sum>j = 0..<m. B $$ (k, j) * mat_of_rows n fs $$ (j, i))\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "have \"\\<dots> = (\\<Sum>j = 0..<m. B $$ (k, j) * (fs ! j $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. B $$ (k, j) * mat_of_rows n fs $$ (j, i)) =\n    (\\<Sum>j = 0..<m. B $$ (k, j) * fs ! j $ i)", "by (metis (no_types, lifting) R.finsum_cong' atLeastLessThan_iff i\n                      len mat_of_rows_index)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<m. B $$ (k, j) * mat_of_rows n fs $$ (j, i)) =\n  (\\<Sum>j = 0..<m. B $$ (k, j) * fs ! j $ i)\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<m. B $$ (k, j) * mat_of_rows n fs $$ (j, i)) =\n  (\\<Sum>j = 0..<m. B $$ (k, j) * fs ! j $ i)\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "have \"\\<dots> = \n                  (\\<Sum>j = 0..<m. (map (\\<lambda>ja.  B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) ! j $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. B $$ (k, j) * fs ! j $ i) =\n    (\\<Sum>j = 0..<m.\n        map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n        j $\n        i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. B $$ (k, j) * fs ! j $ i) =\n    (\\<Sum>j = 0..<m.\n        map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n        j $\n        i)", "have \"\\<forall>j<m. \\<forall>i<n. B $$ (k, j) * (fs ! j $ i) = \n                    (map (\\<lambda>ja.  B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) ! j $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<m.\n       \\<forall>i<n.\n          B $$ (k, j) * fs ! j $ i =\n          map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n          j $\n          i", "using 1(2) i A(3) len fs.f_carrier"], ["proof (prove)\nusing this:\n  k < m\n  i < n\n  A i j c \\<in> carrier_mat m m\n  length fs = m\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<forall>j<m.\n       \\<forall>i<n.\n          B $$ (k, j) * fs ! j $ i =\n          map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n          j $\n          i", "unfolding B_def[symmetric]"], ["proof (prove)\nusing this:\n  k < m\n  i < n\n  B \\<in> carrier_mat m m\n  length fs = m\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<forall>j<m.\n       \\<forall>i<n.\n          B $$ (k, j) * fs ! j $ i =\n          map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n          j $\n          i", "by auto"], ["proof (state)\nthis:\n  \\<forall>j<m.\n     \\<forall>i<n.\n        B $$ (k, j) * fs ! j $ i =\n        map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n        j $\n        i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. B $$ (k, j) * fs ! j $ i) =\n    (\\<Sum>j = 0..<m.\n        map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n        j $\n        i)", "then"], ["proof (chain)\npicking this:\n  \\<forall>j<m.\n     \\<forall>i<n.\n        B $$ (k, j) * fs ! j $ i =\n        map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n        j $\n        i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>j<m.\n     \\<forall>i<n.\n        B $$ (k, j) * fs ! j $ i =\n        map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n        j $\n        i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. B $$ (k, j) * fs ! j $ i) =\n    (\\<Sum>j = 0..<m.\n        map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n        j $\n        i)", "using i"], ["proof (prove)\nusing this:\n  \\<forall>j<m.\n     \\<forall>i<n.\n        B $$ (k, j) * fs ! j $ i =\n        map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n        j $\n        i\n  i < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m. B $$ (k, j) * fs ! j $ i) =\n    (\\<Sum>j = 0..<m.\n        map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n        j $\n        i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<m. B $$ (k, j) * fs ! j $ i) =\n  (\\<Sum>j = 0..<m.\n      map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] ! j $\n      i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<m. B $$ (k, j) * fs ! j $ i) =\n  (\\<Sum>j = 0..<m.\n      map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] ! j $\n      i)\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<m. B $$ (k, j) * fs ! j $ i) =\n  (\\<Sum>j = 0..<m.\n      map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] ! j $\n      i)\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "have \"\\<dots> = sumlist (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n        j $\n        i) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $\n    i", "using sumlist_nth i fs.f_carrier carrier_vecD len"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>set ?xs. dim_vec x = n; ?i < n\\<rbrakk>\n  \\<Longrightarrow> M.sumlist ?xs $ ?i =\n                    (\\<Sum>j = 0..<length ?xs. ?xs ! j $ ?i)\n  i < n\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> dim_vec ?v = ?n\n  length fs = m\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<m.\n        map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] !\n        j $\n        i) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $\n    i", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<m.\n      map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m] ! j $\n      i) =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $\n  i\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "finally"], ["proof (chain)\npicking this:\n  vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) $ i =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $\n  i", "have \"(vec n (\\<lambda>j. row B k \\<bullet> col ?Mfs j)) $ i =\n                  sumlist (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $ i\""], ["proof (prove)\nusing this:\n  vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) $ i =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $\n  i\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) $ i =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $\n    i", "by auto"], ["proof (state)\nthis:\n  vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) $ i =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $\n  i\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "}"], ["proof (state)\nthis:\n  ?ia3 < n \\<Longrightarrow>\n  vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) $ ?ia3 =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $\n  ?ia3\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "then"], ["proof (chain)\npicking this:\n  ?ia3 < n \\<Longrightarrow>\n  vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) $ ?ia3 =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $\n  ?ia3", "show ?thesis"], ["proof (prove)\nusing this:\n  ?ia3 < n \\<Longrightarrow>\n  vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) $ ?ia3 =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $\n  ?ia3\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "using fs.f_carrier len dim_sumlist"], ["proof (prove)\nusing this:\n  ?ia3 < n \\<Longrightarrow>\n  vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) $ ?ia3 =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) $\n  ?ia3\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  length fs = m\n  \\<forall>x\\<in>set ?xs. dim_vec x = n \\<Longrightarrow>\n  dim_vec (M.sumlist ?xs) = n\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])", "by auto"], ["proof (state)\nthis:\n  vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "also"], ["proof (state)\nthis:\n  vec n (\\<lambda>j. row B k \\<bullet> col (mat_of_rows n fs) j) =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "have \"\\<dots> = sumlist (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) \n              ([0..<(Suc k)] @ [(Suc k)..<m]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja)\n       ([0..<Suc k] @ [Suc k..<m]))", "using zkm"], ["proof (prove)\nusing this:\n  [0..<m] = [0..<Suc k] @ [Suc k..<m]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja)\n       ([0..<Suc k] @ [Suc k..<m]))", "by simp"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja)\n     ([0..<Suc k] @ [Suc k..<m]))\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m]) =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja)\n     ([0..<Suc k] @ [Suc k..<m]))\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "have \"\\<dots> = sumlist (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<(Suc k)]) +\n              sumlist (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [(Suc k)..<m])\"\n              (is \"\\<dots> = ?L2 + ?L3\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja)\n       ([0..<Suc k] @ [Suc k..<m])) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<Suc k]) +\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [Suc k..<m])", "using fs.f_carrier len dim_sumlist sumlist_append prep zkm"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  length fs = m\n  \\<forall>x\\<in>set ?xs. dim_vec x = n \\<Longrightarrow>\n  dim_vec (M.sumlist ?xs) = n\n  \\<lbrakk>set ?xs \\<subseteq> carrier_vec n;\n   set ?ys \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> M.sumlist (?xs @ ?ys) = M.sumlist ?xs + M.sumlist ?ys\n  set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])\n  \\<subseteq> carrier_vec n\n  [0..<m] = [0..<Suc k] @ [Suc k..<m]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja)\n       ([0..<Suc k] @ [Suc k..<m])) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<Suc k]) +\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [Suc k..<m])", "by auto"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja)\n     ([0..<Suc k] @ [Suc k..<m])) =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<Suc k]) +\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [Suc k..<m])\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja)\n     ([0..<Suc k] @ [Suc k..<m])) =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<Suc k]) +\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [Suc k..<m])\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "have \"?L3 = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [Suc k..<m]) =\n    0\\<^sub>v n", "using A(4) fs.f_carrier len sumlist_nth carrier_vecD sumlist_carrier \n                prep zkm"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i' < ?j'; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> A i j c $$ (?i', ?j') = 0\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  length fs = m\n  \\<lbrakk>\\<forall>x\\<in>set ?xs. dim_vec x = n; ?i < n\\<rbrakk>\n  \\<Longrightarrow> M.sumlist ?xs $ ?i =\n                    (\\<Sum>j = 0..<length ?xs. ?xs ! j $ ?i)\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> dim_vec ?v = ?n\n  set ?xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n  M.sumlist ?xs \\<in> carrier_vec n\n  set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])\n  \\<subseteq> carrier_vec n\n  [0..<m] = [0..<Suc k] @ [Suc k..<m]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [Suc k..<m]) =\n    0\\<^sub>v n", "unfolding B_def[symmetric]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i' < ?j'; ?j' < m\\<rbrakk> \\<Longrightarrow> B $$ (?i', ?j') = 0\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  length fs = m\n  \\<lbrakk>\\<forall>x\\<in>set ?xs. dim_vec x = n; ?i < n\\<rbrakk>\n  \\<Longrightarrow> M.sumlist ?xs $ ?i =\n                    (\\<Sum>j = 0..<length ?xs. ?xs ! j $ ?i)\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> dim_vec ?v = ?n\n  set ?xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n  M.sumlist ?xs \\<in> carrier_vec n\n  set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])\n  \\<subseteq> carrier_vec n\n  [0..<m] = [0..<Suc k] @ [Suc k..<m]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [Suc k..<m]) =\n    0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [Suc k..<m]) =\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [Suc k..<m]) =\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "have \"?L2 = sumlist (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n              B $$ (k, k) \\<cdot>\\<^sub>v fs ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<Suc k]) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n    B $$ (k, k) \\<cdot>\\<^sub>v fs ! k", "using prep zkm sumlist_snoc"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])\n  \\<subseteq> carrier_vec n\n  [0..<m] = [0..<Suc k] @ [Suc k..<m]\n  \\<lbrakk>set ?xs \\<subseteq> carrier_vec n;\n   ?x \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> M.sumlist (?xs @ [?x]) = M.sumlist ?xs + ?x\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<Suc k]) =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n    B $$ (k, k) \\<cdot>\\<^sub>v fs ! k", "by simp"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<Suc k]) =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n  B $$ (k, k) \\<cdot>\\<^sub>v fs ! k\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<Suc k]) =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n  B $$ (k, k) \\<cdot>\\<^sub>v fs ! k\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "have \"\\<dots> = sumlist (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) + fs ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n    B $$ (k, k) \\<cdot>\\<^sub>v fs ! k =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n    fs ! k", "using A(5) 1(2)"], ["proof (prove)\nusing this:\n  ?k < m \\<Longrightarrow> A i j c $$ (?k, ?k) = 1\n  k < m\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n    B $$ (k, k) \\<cdot>\\<^sub>v fs ! k =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n    fs ! k", "unfolding B_def[symmetric]"], ["proof (prove)\nusing this:\n  ?k < m \\<Longrightarrow> B $$ (?k, ?k) = 1\n  k < m\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n    B $$ (k, k) \\<cdot>\\<^sub>v fs ! k =\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n    fs ! k", "by simp"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n  B $$ (k, k) \\<cdot>\\<^sub>v fs ! k =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n  fs ! k\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "finally"], ["proof (chain)\npicking this:\n  fs' ! k =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n  fs ! k +\n  0\\<^sub>v n", "have \"fs' ! k = fs ! k + \n              sumlist (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])\""], ["proof (prove)\nusing this:\n  fs' ! k =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n  fs ! k +\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. fs' ! k =\n    fs ! k +\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])", "using prep zkm"], ["proof (prove)\nusing this:\n  fs' ! k =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k]) +\n  fs ! k +\n  0\\<^sub>v n\n  set (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<m])\n  \\<subseteq> carrier_vec n\n  [0..<m] = [0..<Suc k] @ [Suc k..<m]\n\ngoal (1 subgoal):\n 1. fs' ! k =\n    fs ! k +\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])", "by (simp add: M.add.m_comm)"], ["proof (state)\nthis:\n  fs' ! k =\n  fs ! k +\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "then"], ["proof (chain)\npicking this:\n  fs' ! k =\n  fs ! k +\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])", "have \"fs' !  k = fs !  k + v2\""], ["proof (prove)\nusing this:\n  fs' ! k =\n  fs ! k +\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])\n\ngoal (1 subgoal):\n 1. fs' ! k = fs ! k + v2", "unfolding v2_def"], ["proof (prove)\nusing this:\n  fs' ! k =\n  fs ! k +\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])\n\ngoal (1 subgoal):\n 1. fs' ! k =\n    fs ! k +\n    M.sumlist\n     (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])", "by simp"], ["proof (state)\nthis:\n  fs' ! k = fs ! k + v2\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "then"], ["proof (chain)\npicking this:\n  fs' ! k = fs ! k + v2", "show ?thesis"], ["proof (prove)\nusing this:\n  fs' ! k = fs ! k + v2\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "using v2carr 1(2) len len' ratv2_def"], ["proof (prove)\nusing this:\n  fs' ! k = fs ! k + v2\n  v2 \\<in> carrier_vec n\n  k < m\n  length fs = m\n  length fs' = m\n  ratv2 = of_int_hom.vec_hom v2\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2", "by force"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have ratv2span: \"ratv2 \\<in> gs.span (gsi.gso ` {0 ..<k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ratv2 \\<in> gs.span (gsi.gso ` {0..<k})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ratv2 \\<in> gs.span (gsi.gso ` {0..<k})", "have rat: \"ratv2 = gs.M.sumlist\n              (map (\\<lambda>j. of_int (B $$ (k, j)) \\<cdot>\\<^sub>v (RAT fs) ! j) [0..<k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ratv2 =\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n              map of_int_hom.vec_hom fs ! j)\n       [0..<k])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ratv2 =\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n              map of_int_hom.vec_hom fs ! j)\n       [0..<k])", "have \"set (map (\\<lambda>j. of_int (B $$ (k, j)) \\<cdot>\\<^sub>v (RAT fs) ! j) [0..<k]) \n                \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>j.\n                 rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n                 map of_int_hom.vec_hom fs ! j)\n          [0..<k])\n    \\<subseteq> local.LLL.Rn", "using fs.f_carrier 1(2) len"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  k < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>j.\n                 rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n                 map of_int_hom.vec_hom fs ! j)\n          [0..<k])\n    \\<subseteq> local.LLL.Rn", "by auto"], ["proof (state)\nthis:\n  set (map (\\<lambda>j.\n               rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n               map of_int_hom.vec_hom fs ! j)\n        [0..<k])\n  \\<subseteq> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. ratv2 =\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n              map of_int_hom.vec_hom fs ! j)\n       [0..<k])", "hence carr: \"gs.M.sumlist \n                (map (\\<lambda>j. of_int (B $$ (k, j)) \\<cdot>\\<^sub>v (RAT fs) ! j) [0..<k]) \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>j.\n               rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n               map of_int_hom.vec_hom fs ! j)\n        [0..<k])\n  \\<subseteq> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j.\n              rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n              map of_int_hom.vec_hom fs ! j)\n       [0..<k])\n    \\<in> local.LLL.Rn", "by auto"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j.\n            rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n            map of_int_hom.vec_hom fs ! j)\n     [0..<k])\n  \\<in> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. ratv2 =\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n              map of_int_hom.vec_hom fs ! j)\n       [0..<k])", "have \"set (map (\\<lambda>j. B $$ (k, j) \\<cdot>\\<^sub>v fs ! j) [0..<k]) \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>j. B $$ (k, j) \\<cdot>\\<^sub>v fs ! j) [0..<k])\n    \\<subseteq> carrier_vec n", "using fs.f_carrier 1(2) len"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  k < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>j. B $$ (k, j) \\<cdot>\\<^sub>v fs ! j) [0..<k])\n    \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (map (\\<lambda>j. B $$ (k, j) \\<cdot>\\<^sub>v fs ! j) [0..<k])\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. ratv2 =\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n              map of_int_hom.vec_hom fs ! j)\n       [0..<k])", "hence \"\\<And>i j. i < n \\<Longrightarrow> j < k \\<Longrightarrow> of_int ((B $$ (k, j) \\<cdot>\\<^sub>v fs ! j) $ i)\n                = (of_int (B $$ (k, j)) \\<cdot>\\<^sub>v (RAT fs) ! j) $ i\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>j. B $$ (k, j) \\<cdot>\\<^sub>v fs ! j) [0..<k])\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < k\\<rbrakk>\n       \\<Longrightarrow> rat_of_int\n                          ((B $$ (k, j) \\<cdot>\\<^sub>v fs ! j) $ i) =\n                         (rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n                          map of_int_hom.vec_hom fs ! j) $\n                         i", "using 1(2) len"], ["proof (prove)\nusing this:\n  set (map (\\<lambda>j. B $$ (k, j) \\<cdot>\\<^sub>v fs ! j) [0..<k])\n  \\<subseteq> carrier_vec n\n  k < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < k\\<rbrakk>\n       \\<Longrightarrow> rat_of_int\n                          ((B $$ (k, j) \\<cdot>\\<^sub>v fs ! j) $ i) =\n                         (rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n                          map of_int_hom.vec_hom fs ! j) $\n                         i", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < n; ?j1 < k\\<rbrakk>\n  \\<Longrightarrow> rat_of_int\n                     ((B $$ (k, ?j1) \\<cdot>\\<^sub>v fs ! ?j1) $ ?i1) =\n                    (rat_of_int (B $$ (k, ?j1)) \\<cdot>\\<^sub>v\n                     map of_int_hom.vec_hom fs ! ?j1) $\n                    ?i1\n\ngoal (1 subgoal):\n 1. ratv2 =\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n              map of_int_hom.vec_hom fs ! j)\n       [0..<k])", "hence \"\\<And>i. i < n \\<Longrightarrow> ratv2 $ i = gs.M.sumlist\n                (map (\\<lambda>j. (of_int (B $$ (k, j)) \\<cdot>\\<^sub>v (RAT fs) ! j)) [0..<k]) $ i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < n; ?j1 < k\\<rbrakk>\n  \\<Longrightarrow> rat_of_int\n                     ((B $$ (k, ?j1) \\<cdot>\\<^sub>v fs ! ?j1) $ ?i1) =\n                    (rat_of_int (B $$ (k, ?j1)) \\<cdot>\\<^sub>v\n                     map of_int_hom.vec_hom fs ! ?j1) $\n                    ?i1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       ratv2 $ i =\n       gs.M.sumlist\n        (map (\\<lambda>j.\n                 rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n                 map of_int_hom.vec_hom fs ! j)\n          [0..<k]) $\n       i", "using fs.f_carrier 1(2) len v2carr gs.sumlist_nth sumlist_nth \n                  ratv2_def v2_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < n; ?j1 < k\\<rbrakk>\n  \\<Longrightarrow> rat_of_int\n                     ((B $$ (k, ?j1) \\<cdot>\\<^sub>v fs ! ?j1) $ ?i1) =\n                    (rat_of_int (B $$ (k, ?j1)) \\<cdot>\\<^sub>v\n                     map of_int_hom.vec_hom fs ! ?j1) $\n                    ?i1\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  k < m\n  length fs = m\n  v2 \\<in> carrier_vec n\n  \\<lbrakk>\\<forall>x\\<in>set ?xs. dim_vec x = n; ?i < n\\<rbrakk>\n  \\<Longrightarrow> gs.M.sumlist ?xs $ ?i =\n                    (\\<Sum>j = 0..<length ?xs. ?xs ! j $ ?i)\n  \\<lbrakk>\\<forall>x\\<in>set ?xs. dim_vec x = n; ?i < n\\<rbrakk>\n  \\<Longrightarrow> M.sumlist ?xs $ ?i =\n                    (\\<Sum>j = 0..<length ?xs. ?xs ! j $ ?i)\n  ratv2 = of_int_hom.vec_hom v2\n  v2 =\n  M.sumlist\n   (map (\\<lambda>ja. B $$ (k, ja) \\<cdot>\\<^sub>v fs ! ja) [0..<k])\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       ratv2 $ i =\n       gs.M.sumlist\n        (map (\\<lambda>j.\n                 rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n                 map of_int_hom.vec_hom fs ! j)\n          [0..<k]) $\n       i", "by simp"], ["proof (state)\nthis:\n  ?i1 < n \\<Longrightarrow>\n  ratv2 $ ?i1 =\n  gs.M.sumlist\n   (map (\\<lambda>j.\n            rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n            map of_int_hom.vec_hom fs ! j)\n     [0..<k]) $\n  ?i1\n\ngoal (1 subgoal):\n 1. ratv2 =\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n              map of_int_hom.vec_hom fs ! j)\n       [0..<k])", "then"], ["proof (chain)\npicking this:\n  ?i1 < n \\<Longrightarrow>\n  ratv2 $ ?i1 =\n  gs.M.sumlist\n   (map (\\<lambda>j.\n            rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n            map of_int_hom.vec_hom fs ! j)\n     [0..<k]) $\n  ?i1", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i1 < n \\<Longrightarrow>\n  ratv2 $ ?i1 =\n  gs.M.sumlist\n   (map (\\<lambda>j.\n            rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n            map of_int_hom.vec_hom fs ! j)\n     [0..<k]) $\n  ?i1\n\ngoal (1 subgoal):\n 1. ratv2 =\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n              map of_int_hom.vec_hom fs ! j)\n       [0..<k])", "using ratv2carr carr"], ["proof (prove)\nusing this:\n  ?i1 < n \\<Longrightarrow>\n  ratv2 $ ?i1 =\n  gs.M.sumlist\n   (map (\\<lambda>j.\n            rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n            map of_int_hom.vec_hom fs ! j)\n     [0..<k]) $\n  ?i1\n  ratv2 \\<in> local.LLL.Rn\n  gs.M.sumlist\n   (map (\\<lambda>j.\n            rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n            map of_int_hom.vec_hom fs ! j)\n     [0..<k])\n  \\<in> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. ratv2 =\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n              map of_int_hom.vec_hom fs ! j)\n       [0..<k])", "by auto"], ["proof (state)\nthis:\n  ratv2 =\n  gs.M.sumlist\n   (map (\\<lambda>j.\n            rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n            map of_int_hom.vec_hom fs ! j)\n     [0..<k])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ratv2 =\n  gs.M.sumlist\n   (map (\\<lambda>j.\n            rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n            map of_int_hom.vec_hom fs ! j)\n     [0..<k])\n\ngoal (1 subgoal):\n 1. ratv2 \\<in> gs.span (gsi.gso ` {0..<k})", "have \"\\<And>i. i < k \\<Longrightarrow> (RAT fs) ! i = \n              gs.M.sumlist (map (\\<lambda> j. gsi.\\<mu> i j \\<cdot>\\<^sub>v gsi.gso j) [0 ..< Suc i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       map of_int_hom.vec_hom fs ! i =\n       gs.M.sumlist\n        (map (\\<lambda>j. gsi.\\<mu> i j \\<cdot>\\<^sub>v gsi.gso j)\n          [0..<Suc i])", "using gsi.fi_is_sum_of_mu_gso len 1(2)"], ["proof (prove)\nusing this:\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i =\n  gs.M.sumlist\n   (map (\\<lambda>j. gsi.\\<mu> ?i j \\<cdot>\\<^sub>v gsi.gso j) [0..<Suc ?i])\n  length fs = m\n  k < m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       map of_int_hom.vec_hom fs ! i =\n       gs.M.sumlist\n        (map (\\<lambda>j. gsi.\\<mu> i j \\<cdot>\\<^sub>v gsi.gso j)\n          [0..<Suc i])", "by auto"], ["proof (state)\nthis:\n  ?i1 < k \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i1 =\n  gs.M.sumlist\n   (map (\\<lambda>j. gsi.\\<mu> ?i1 j \\<cdot>\\<^sub>v gsi.gso j)\n     [0..<Suc ?i1])\n\ngoal (1 subgoal):\n 1. ratv2 \\<in> gs.span (gsi.gso ` {0..<k})", "moreover"], ["proof (state)\nthis:\n  ?i1 < k \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i1 =\n  gs.M.sumlist\n   (map (\\<lambda>j. gsi.\\<mu> ?i1 j \\<cdot>\\<^sub>v gsi.gso j)\n     [0..<Suc ?i1])\n\ngoal (1 subgoal):\n 1. ratv2 \\<in> gs.span (gsi.gso ` {0..<k})", "have \"\\<And>i. i < k \\<Longrightarrow> (\\<lambda> j. gsi.\\<mu> i j \\<cdot>\\<^sub>v gsi.gso j) ` {0 ..< Suc i}\n              \\<subseteq> gs.span (gsi.gso ` {0 ..<k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       (\\<lambda>j. gsi.\\<mu> i j \\<cdot>\\<^sub>v gsi.gso j) ` {0..<Suc i}\n       \\<subseteq> gs.span (gsi.gso ` {0..<k})", "using gs.span_mem gso0kcarr"], ["proof (prove)\nusing this:\n  \\<lbrakk>?E \\<subseteq> local.LLL.Rn; ?u \\<in> ?E\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> gs.span ?E\n  gsi.gso ` {0..<k} \\<subseteq> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       (\\<lambda>j. gsi.\\<mu> i j \\<cdot>\\<^sub>v gsi.gso j) ` {0..<Suc i}\n       \\<subseteq> gs.span (gsi.gso ` {0..<k})", "by auto"], ["proof (state)\nthis:\n  ?i1 < k \\<Longrightarrow>\n  (\\<lambda>j. gsi.\\<mu> ?i1 j \\<cdot>\\<^sub>v gsi.gso j) ` {0..<Suc ?i1}\n  \\<subseteq> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. ratv2 \\<in> gs.span (gsi.gso ` {0..<k})", "ultimately"], ["proof (chain)\npicking this:\n  ?i1 < k \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i1 =\n  gs.M.sumlist\n   (map (\\<lambda>j. gsi.\\<mu> ?i1 j \\<cdot>\\<^sub>v gsi.gso j)\n     [0..<Suc ?i1])\n  ?i1 < k \\<Longrightarrow>\n  (\\<lambda>j. gsi.\\<mu> ?i1 j \\<cdot>\\<^sub>v gsi.gso j) ` {0..<Suc ?i1}\n  \\<subseteq> gs.span (gsi.gso ` {0..<k})", "have \"\\<And>i. i < k \\<Longrightarrow> (RAT fs) ! i \\<in> gs.span (gsi.gso ` {0 ..<k})\""], ["proof (prove)\nusing this:\n  ?i1 < k \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i1 =\n  gs.M.sumlist\n   (map (\\<lambda>j. gsi.\\<mu> ?i1 j \\<cdot>\\<^sub>v gsi.gso j)\n     [0..<Suc ?i1])\n  ?i1 < k \\<Longrightarrow>\n  (\\<lambda>j. gsi.\\<mu> ?i1 j \\<cdot>\\<^sub>v gsi.gso j) ` {0..<Suc ?i1}\n  \\<subseteq> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       map of_int_hom.vec_hom fs ! i \\<in> gs.span (gsi.gso ` {0..<k})", "using gso0kcarr set_map set_upt vec_space.sumlist_in_span subsetD"], ["proof (prove)\nusing this:\n  ?i1 < k \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i1 =\n  gs.M.sumlist\n   (map (\\<lambda>j. gsi.\\<mu> ?i1 j \\<cdot>\\<^sub>v gsi.gso j)\n     [0..<Suc ?i1])\n  ?i1 < k \\<Longrightarrow>\n  (\\<lambda>j. gsi.\\<mu> ?i1 j \\<cdot>\\<^sub>v gsi.gso j) ` {0..<Suc ?i1}\n  \\<subseteq> gs.span (gsi.gso ` {0..<k})\n  gsi.gso ` {0..<k} \\<subseteq> local.LLL.Rn\n  set (map ?f ?xs) = ?f ` set ?xs\n  set [?i..<?j] = {?i..<?j}\n  \\<lbrakk>?W \\<subseteq> carrier_vec ?n;\n   \\<And>x.\n      x \\<in> set ?xs \\<Longrightarrow>\n      x \\<in> LinearCombinations.module.span class_ring\n               (module_vec TYPE(?'a) ?n) ?W\\<rbrakk>\n  \\<Longrightarrow> abelian_monoid.sumlist (module_vec TYPE(?'a) ?n) ?xs\n                    \\<in> LinearCombinations.module.span class_ring\n                           (module_vec TYPE(?'a) ?n) ?W\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> ?B\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       map of_int_hom.vec_hom fs ! i \\<in> gs.span (gsi.gso ` {0..<k})", "by smt"], ["proof (state)\nthis:\n  ?i1 < k \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i1 \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. ratv2 \\<in> gs.span (gsi.gso ` {0..<k})", "then"], ["proof (chain)\npicking this:\n  ?i1 < k \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i1 \\<in> gs.span (gsi.gso ` {0..<k})", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i1 < k \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i1 \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. ratv2 \\<in> gs.span (gsi.gso ` {0..<k})", "using rat atLeastLessThan_iff set_upt gso0kcarr imageE \n              set_map gs.smult_in_span vec_space.sumlist_in_span"], ["proof (prove)\nusing this:\n  ?i1 < k \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i1 \\<in> gs.span (gsi.gso ` {0..<k})\n  ratv2 =\n  gs.M.sumlist\n   (map (\\<lambda>j.\n            rat_of_int (B $$ (k, j)) \\<cdot>\\<^sub>v\n            map of_int_hom.vec_hom fs ! j)\n     [0..<k])\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n  set [?i..<?j] = {?i..<?j}\n  gsi.gso ` {0..<k} \\<subseteq> local.LLL.Rn\n  \\<lbrakk>?b \\<in> ?f ` ?A;\n   \\<And>x.\n      \\<lbrakk>?b = ?f x; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  set (map ?f ?xs) = ?f ` set ?xs\n  \\<lbrakk>?W \\<subseteq> local.LLL.Rn; ?x \\<in> gs.span ?W\\<rbrakk>\n  \\<Longrightarrow> ?c \\<cdot>\\<^sub>v ?x \\<in> gs.span ?W\n  \\<lbrakk>?W \\<subseteq> carrier_vec ?n;\n   \\<And>x.\n      x \\<in> set ?xs \\<Longrightarrow>\n      x \\<in> LinearCombinations.module.span class_ring\n               (module_vec TYPE(?'a) ?n) ?W\\<rbrakk>\n  \\<Longrightarrow> abelian_monoid.sumlist (module_vec TYPE(?'a) ?n) ?xs\n                    \\<in> LinearCombinations.module.span class_ring\n                           (module_vec TYPE(?'a) ?n) ?W\n\ngoal (1 subgoal):\n 1. ratv2 \\<in> gs.span (gsi.gso ` {0..<k})", "by smt"], ["proof (state)\nthis:\n  ratv2 \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ratv2 \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have fs_gs_diff_span:\n            \"(RAT fs) !  k - fs'.gs.gso k \\<in> gs.span (gsi.gso ` {0 ..<k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "from fs'_gs_diff_span"], ["proof (chain)\npicking this:\n  map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n  \\<in> gs.span (gsi.gso ` {0..<k})", "obtain v3 where sp: \"v3 \\<in> gs.span (gsi.gso ` {0 ..<k})\"\n              and eq: \"(RAT fs) ! k - fs'.gs.gso k = v3 - ratv2\""], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n  \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. (\\<And>v3.\n        \\<lbrakk>v3 \\<in> gs.span (gsi.gso ` {0..<k});\n         map of_int_hom.vec_hom fs ! k - fs'.gs.gso k = v3 - ratv2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using fs'.gs.gso_carrier len' 1(2) ratv2carr fs'id"], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs' ! k - fs'.gs.gso k\n  \\<in> gs.span (gsi.gso ` {0..<k})\n  ?i < length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  fs'.gs.gso ?i \\<in> local.LLL.Rn\n  length fs' = m\n  k < m\n  ratv2 \\<in> local.LLL.Rn\n  map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k + ratv2\n\ngoal (1 subgoal):\n 1. (\\<And>v3.\n        \\<lbrakk>v3 \\<in> gs.span (gsi.gso ` {0..<k});\n         map of_int_hom.vec_hom fs ! k - fs'.gs.gso k = v3 - ratv2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  v3 \\<in> gs.span (gsi.gso ` {0..<k})\n  map of_int_hom.vec_hom fs ! k - fs'.gs.gso k = v3 - ratv2\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "have \"v3+(-ratv2) \\<in> gs.span(gsi.gso ` {0 ..<k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v3 + - ratv2 \\<in> gs.span (gsi.gso ` {0..<k})", "by (metis sp gs.span_add1 gso0kcarr gram_schmidt.inv_in_span \n                  gso0kcarr ratv2span)"], ["proof (state)\nthis:\n  v3 + - ratv2 \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "moreover"], ["proof (state)\nthis:\n  v3 + - ratv2 \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "have \"v3+(-ratv2) = v3-ratv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v3 + - ratv2 = v3 - ratv2", "using ratv2carr"], ["proof (prove)\nusing this:\n  ratv2 \\<in> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. v3 + - ratv2 = v3 - ratv2", "by auto"], ["proof (state)\nthis:\n  v3 + - ratv2 = v3 - ratv2\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "ultimately"], ["proof (chain)\npicking this:\n  v3 + - ratv2 \\<in> gs.span (gsi.gso ` {0..<k})\n  v3 + - ratv2 = v3 - ratv2", "have \"v3 - ratv2 \\<in> gs.span (gsi.gso ` {0 ..<k})\""], ["proof (prove)\nusing this:\n  v3 + - ratv2 \\<in> gs.span (gsi.gso ` {0..<k})\n  v3 + - ratv2 = v3 - ratv2\n\ngoal (1 subgoal):\n 1. v3 - ratv2 \\<in> gs.span (gsi.gso ` {0..<k})", "by simp"], ["proof (state)\nthis:\n  v3 - ratv2 \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "then"], ["proof (chain)\npicking this:\n  v3 - ratv2 \\<in> gs.span (gsi.gso ` {0..<k})", "show ?thesis"], ["proof (prove)\nusing this:\n  v3 - ratv2 \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "using eq"], ["proof (prove)\nusing this:\n  v3 - ratv2 \\<in> gs.span (gsi.gso ` {0..<k})\n  map of_int_hom.vec_hom fs ! k - fs'.gs.gso k = v3 - ratv2\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n    \\<in> gs.span (gsi.gso ` {0..<k})", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n  \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n  \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "{"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n  \\<in> gs.span (gsi.gso ` {0..<k})\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "assume i: \"i < k\""], ["proof (state)\nthis:\n  i < k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "hence \"fs'.gs.gso k \\<bullet> fs'.gs.gso i = 0\""], ["proof (prove)\nusing this:\n  i < k\n\ngoal (1 subgoal):\n 1. fs'.gs.gso k \\<bullet> fs'.gs.gso i = 0", "using 1(2) fs'.gs.orthogonal len'"], ["proof (prove)\nusing this:\n  i < k\n  k < m\n  \\<lbrakk>?i < length (map of_int_hom.vec_hom fs');\n   ?j < length (map of_int_hom.vec_hom fs'); ?i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> fs'.gs.gso ?i \\<bullet> fs'.gs.gso ?j = 0\n  length fs' = m\n\ngoal (1 subgoal):\n 1. fs'.gs.gso k \\<bullet> fs'.gs.gso i = 0", "by auto"], ["proof (state)\nthis:\n  fs'.gs.gso k \\<bullet> fs'.gs.gso i = 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "hence \"fs'.gs.gso k \\<bullet> gsi.gso i = 0\""], ["proof (prove)\nusing this:\n  fs'.gs.gso k \\<bullet> fs'.gs.gso i = 0\n\ngoal (1 subgoal):\n 1. fs'.gs.gso k \\<bullet> gsi.gso i = 0", "using 1 i"], ["proof (prove)\nusing this:\n  fs'.gs.gso k \\<bullet> fs'.gs.gso i = 0\n  \\<forall>ma<k. ma < m \\<longrightarrow> fs'.gs.gso ma = gsi.gso ma\n  k < m\n  i < k\n\ngoal (1 subgoal):\n 1. fs'.gs.gso k \\<bullet> gsi.gso i = 0", "by simp"], ["proof (state)\nthis:\n  fs'.gs.gso k \\<bullet> gsi.gso i = 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "}"], ["proof (state)\nthis:\n  ?ia3 < k \\<Longrightarrow> fs'.gs.gso k \\<bullet> gsi.gso ?ia3 = 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "hence \"\\<And>x. x \\<in> gsi.gso ` {0..<k} \\<Longrightarrow> fs'.gs.gso k \\<bullet> x = 0\""], ["proof (prove)\nusing this:\n  ?ia3 < k \\<Longrightarrow> fs'.gs.gso k \\<bullet> gsi.gso ?ia3 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> gsi.gso ` {0..<k} \\<Longrightarrow>\n       fs'.gs.gso k \\<bullet> x = 0", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> gsi.gso ` {0..<k} \\<Longrightarrow>\n  fs'.gs.gso k \\<bullet> ?x1 = 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "then"], ["proof (chain)\npicking this:\n  ?x1 \\<in> gsi.gso ` {0..<k} \\<Longrightarrow>\n  fs'.gs.gso k \\<bullet> ?x1 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x1 \\<in> gsi.gso ` {0..<k} \\<Longrightarrow>\n  fs'.gs.gso k \\<bullet> ?x1 = 0\n\ngoal (1 subgoal):\n 1. fs'.gs.gso k = gsi.gso k", "using gsi.oc_projection_unique len len' fs_gs_diff_span 1(2)"], ["proof (prove)\nusing this:\n  ?x1 \\<in> gsi.gso ` {0..<k} \\<Longrightarrow>\n  fs'.gs.gso k \\<bullet> ?x1 = 0\n  \\<lbrakk>?i < length (map of_int_hom.vec_hom fs); ?v \\<in> local.LLL.Rn;\n   \\<And>x. x \\<in> gsi.gso ` {0..<?i} \\<Longrightarrow> ?v \\<bullet> x = 0;\n   map of_int_hom.vec_hom fs ! ?i - ?v\n   \\<in> gs.span (gsi.gso ` {0..<?i})\\<rbrakk>\n  \\<Longrightarrow> ?v = gsi.gso ?i\n  length fs = m\n  length fs' = m\n  map of_int_hom.vec_hom fs ! k - fs'.gs.gso k\n  \\<in> gs.span (gsi.gso ` {0..<k})\n  k < m\n\ngoal (1 subgoal):\n 1. fs'.gs.gso k = gsi.gso k", "by auto"], ["proof (state)\nthis:\n  fs'.gs.gso k = gsi.gso k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fs'.gs.gso k = gsi.gso k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fs'.gs.gso k = gsi.gso k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k1 < m \\<Longrightarrow> fs'.gs.gso ?k1 = gsi.gso ?k1\n\ngoal (4 subgoals):\n 1. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 2. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 3. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have \"\\<And> i' j'. i' < m \\<Longrightarrow> j' < m \\<Longrightarrow> \\<mu> fs' i' j' = \n      (map_mat of_int (A i j c) * gsi.M m) $$ (i',j')\" and\n      \"\\<And> k. k < m \\<Longrightarrow> gso fs' k = gso fs k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i' j'.\n        \\<lbrakk>i' < m; j' < m\\<rbrakk>\n        \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                          (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                          (i', j')) &&&\n    (\\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "define rB where \"rB = map_mat rat_of_int B\""], ["proof (state)\nthis:\n  rB = of_int_hom.mat_hom B\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have rBcarr: \"rB \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rB \\<in> carrier_mat m m", "using A(3)"], ["proof (prove)\nusing this:\n  A i j c \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. rB \\<in> carrier_mat m m", "unfolding rB_def B_def"], ["proof (prove)\nusing this:\n  A i j c \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (A i j c) \\<in> carrier_mat m m", "by simp"], ["proof (state)\nthis:\n  rB \\<in> carrier_mat m m\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "define rfs where \"rfs = mat_of_rows n (RAT fs)\""], ["proof (state)\nthis:\n  rfs = mat_of_rows n (map of_int_hom.vec_hom fs)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have rfscarr: \"rfs \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rfs \\<in> carrier_mat m n", "using Mfs"], ["proof (prove)\nusing this:\n  mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. rfs \\<in> carrier_mat m n", "unfolding rfs_def"], ["proof (prove)\nusing this:\n  mat_of_rows n fs \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. mat_of_rows n (map of_int_hom.vec_hom fs) \\<in> carrier_mat m n", "by simp"], ["proof (state)\nthis:\n  rfs \\<in> carrier_mat m n\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "{"], ["proof (state)\nthis:\n  rfs \\<in> carrier_mat m n\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "fix i'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "fix j'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "assume i': \"i' < m\""], ["proof (state)\nthis:\n  i' < m\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "assume j': \"j' < m\""], ["proof (state)\nthis:\n  j' < m\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have prep: \n          \"of_int_hom.vec_hom (row (B * mat_of_rows n fs) i') = row (rB * rfs) i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (row (B * mat_of_rows n fs) i') = row (rB * rfs) i'", "using len i' B_def A(3) rB_def rfs_def"], ["proof (prove)\nusing this:\n  length fs = m\n  i' < m\n  B = A i j c\n  A i j c \\<in> carrier_mat m m\n  rB = of_int_hom.mat_hom B\n  rfs = mat_of_rows n (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (row (B * mat_of_rows n fs) i') = row (rB * rfs) i'", "by (auto simp: scalar_prod_def)"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (row (B * mat_of_rows n fs) i') = row (rB * rfs) i'\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have prep2: \"row (rB * rfs) i' = vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (rB * rfs) i' = vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l)", "using len fs.f_carrier i' B_def A(3) scalar_prod_def rB_def"], ["proof (prove)\nusing this:\n  length fs = m\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  i' < m\n  B = A i j c\n  A i j c \\<in> carrier_mat m m\n  ?v \\<bullet> ?w \\<equiv> \\<Sum>i = 0..<dim_vec ?w. ?v $ i * ?w $ i\n  rB = of_int_hom.mat_hom B\n\ngoal (1 subgoal):\n 1. row (rB * rfs) i' = vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l)", "unfolding rfs_def"], ["proof (prove)\nusing this:\n  length fs = m\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  i' < m\n  B = A i j c\n  A i j c \\<in> carrier_mat m m\n  ?v \\<bullet> ?w \\<equiv> \\<Sum>i = 0..<dim_vec ?w. ?v $ i * ?w $ i\n  rB = of_int_hom.mat_hom B\n\ngoal (1 subgoal):\n 1. row (rB * mat_of_rows n (map of_int_hom.vec_hom fs)) i' =\n    vec n\n     (\\<lambda>l.\n         row rB i' \\<bullet>\n         col (mat_of_rows n (map of_int_hom.vec_hom fs)) l)", "by auto"], ["proof (state)\nthis:\n  row (rB * rfs) i' = vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have prep3: \"(vec m (\\<lambda> j1. row rfs j1 \\<bullet> gsi.gso j' / \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2)) =\n          (vec m (\\<lambda> j1. (gsi.M m) $$ (j1, j')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n    vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n    vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n    vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n    vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))", "assume x: \"x < m\" and y: \"y < m\""], ["proof (state)\nthis:\n  x < m\n  y < m\n\ngoal (1 subgoal):\n 1. vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n    vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))", "have \"(gsi.M m) $$ (x,y) = (if y < x then map of_int_hom.vec_hom fs ! x \n              \\<bullet> fs'.gs.gso y / \\<parallel>fs'.gs.gso y\\<parallel>\\<^sup>2 else if x = y then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gsi.M m $$ (x, y) =\n    (if y < x\n     then map of_int_hom.vec_hom fs ! x \\<bullet> fs'.gs.gso y /\n          \\<parallel>fs'.gs.gso y\\<parallel>\\<^sup>2\n     else if x = y then 1 else 0)", "using gsi.\\<mu>.simps x y j' len gs_eq gsi.M_index"], ["proof (prove)\nusing this:\n  gsi.\\<mu> ?i ?j =\n  (if ?j < ?i\n   then map of_int_hom.vec_hom fs ! ?i \\<bullet> gsi.gso ?j /\n        \\<parallel>gsi.gso ?j\\<parallel>\\<^sup>2\n   else if ?i = ?j then 1 else 0)\n  x < m\n  y < m\n  j' < m\n  length fs = m\n  ?k1 < m \\<Longrightarrow> fs'.gs.gso ?k1 = gsi.gso ?k1\n  \\<lbrakk>?i < length (map of_int_hom.vec_hom fs);\n   ?j < length (map of_int_hom.vec_hom fs)\\<rbrakk>\n  \\<Longrightarrow> gsi.M (length (map of_int_hom.vec_hom fs)) $$ (?i, ?j) =\n                    gsi.\\<mu> ?i ?j\n\ngoal (1 subgoal):\n 1. gsi.M m $$ (x, y) =\n    (if y < x\n     then map of_int_hom.vec_hom fs ! x \\<bullet> fs'.gs.gso y /\n          \\<parallel>fs'.gs.gso y\\<parallel>\\<^sup>2\n     else if x = y then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  gsi.M m $$ (x, y) =\n  (if y < x\n   then map of_int_hom.vec_hom fs ! x \\<bullet> fs'.gs.gso y /\n        \\<parallel>fs'.gs.gso y\\<parallel>\\<^sup>2\n   else if x = y then 1 else 0)\n\ngoal (1 subgoal):\n 1. vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n    vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))", "hence \"row rfs x \\<bullet> gsi.gso y / \\<parallel>gsi.gso y\\<parallel>\\<^sup>2 = (gsi.M m) $$ (x,y)\""], ["proof (prove)\nusing this:\n  gsi.M m $$ (x, y) =\n  (if y < x\n   then map of_int_hom.vec_hom fs ! x \\<bullet> fs'.gs.gso y /\n        \\<parallel>fs'.gs.gso y\\<parallel>\\<^sup>2\n   else if x = y then 1 else 0)\n\ngoal (1 subgoal):\n 1. row rfs x \\<bullet> gsi.gso y /\n    \\<parallel>gsi.gso y\\<parallel>\\<^sup>2 =\n    gsi.M m $$ (x, y)", "unfolding rfs_def"], ["proof (prove)\nusing this:\n  gsi.M m $$ (x, y) =\n  (if y < x\n   then map of_int_hom.vec_hom fs ! x \\<bullet> fs'.gs.gso y /\n        \\<parallel>fs'.gs.gso y\\<parallel>\\<^sup>2\n   else if x = y then 1 else 0)\n\ngoal (1 subgoal):\n 1. row (mat_of_rows n (map of_int_hom.vec_hom fs)) x \\<bullet> gsi.gso y /\n    \\<parallel>gsi.gso y\\<parallel>\\<^sup>2 =\n    gsi.M m $$ (x, y)", "by (metis carrier_matD(1) divide_eq_eq fs'.gs.\\<beta>_zero fs'.gs.gso_norm_beta \n                  gs_eq gsi.\\<mu>.simps gsi.fi_scalar_prod_gso gsi.fs_carrier len len' \n                  length_map nth_rows rfs_def rfscarr rows_mat_of_rows x y)"], ["proof (state)\nthis:\n  row rfs x \\<bullet> gsi.gso y / \\<parallel>gsi.gso y\\<parallel>\\<^sup>2 =\n  gsi.M m $$ (x, y)\n\ngoal (1 subgoal):\n 1. vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n    vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x3 < m; ?y3 < m\\<rbrakk>\n  \\<Longrightarrow> row rfs ?x3 \\<bullet> gsi.gso ?y3 /\n                    \\<parallel>gsi.gso ?y3\\<parallel>\\<^sup>2 =\n                    gsi.M m $$ (?x3, ?y3)\n\ngoal (1 subgoal):\n 1. vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n    vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x3 < m; ?y3 < m\\<rbrakk>\n  \\<Longrightarrow> row rfs ?x3 \\<bullet> gsi.gso ?y3 /\n                    \\<parallel>gsi.gso ?y3\\<parallel>\\<^sup>2 =\n                    gsi.M m $$ (?x3, ?y3)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 < m; ?y3 < m\\<rbrakk>\n  \\<Longrightarrow> row rfs ?x3 \\<bullet> gsi.gso ?y3 /\n                    \\<parallel>gsi.gso ?y3\\<parallel>\\<^sup>2 =\n                    gsi.M m $$ (?x3, ?y3)\n\ngoal (1 subgoal):\n 1. vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n    vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))", "using j'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 < m; ?y3 < m\\<rbrakk>\n  \\<Longrightarrow> row rfs ?x3 \\<bullet> gsi.gso ?y3 /\n                    \\<parallel>gsi.gso ?y3\\<parallel>\\<^sup>2 =\n                    gsi.M m $$ (?x3, ?y3)\n  j' < m\n\ngoal (1 subgoal):\n 1. vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n    vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))", "by auto"], ["proof (state)\nthis:\n  vec m\n   (\\<lambda>j1.\n       row rfs j1 \\<bullet> gsi.gso j' /\n       \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n  vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec m\n   (\\<lambda>j1.\n       row rfs j1 \\<bullet> gsi.gso j' /\n       \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n  vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have prep4: \"(1 / \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v (vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j')) =\n          (vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j' / \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n    vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j') =\n    vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  1 / \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n  vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j') =\n  vec m\n   (\\<lambda>j1.\n       row rfs j1 \\<bullet> gsi.gso j' /\n       \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"map of_int_hom.vec_hom fs' ! i' \\<bullet> fs'.gs.gso j' / \\<parallel>fs'.gs.gso j'\\<parallel>\\<^sup>2\n           = map of_int_hom.vec_hom fs' ! i' \\<bullet> gsi.gso j' / \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i' \\<bullet> fs'.gs.gso j' /\n    \\<parallel>fs'.gs.gso j'\\<parallel>\\<^sup>2 =\n    map of_int_hom.vec_hom fs' ! i' \\<bullet> gsi.gso j' /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2", "using gs_eq j'"], ["proof (prove)\nusing this:\n  ?k1 < m \\<Longrightarrow> fs'.gs.gso ?k1 = gsi.gso ?k1\n  j' < m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i' \\<bullet> fs'.gs.gso j' /\n    \\<parallel>fs'.gs.gso j'\\<parallel>\\<^sup>2 =\n    map of_int_hom.vec_hom fs' ! i' \\<bullet> gsi.gso j' /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i' \\<bullet> fs'.gs.gso j' /\n  \\<parallel>fs'.gs.gso j'\\<parallel>\\<^sup>2 =\n  map of_int_hom.vec_hom fs' ! i' \\<bullet> gsi.gso j' /\n  \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i' \\<bullet> fs'.gs.gso j' /\n  \\<parallel>fs'.gs.gso j'\\<parallel>\\<^sup>2 =\n  map of_int_hom.vec_hom fs' ! i' \\<bullet> gsi.gso j' /\n  \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"\\<dots> = row (rB * rfs) i' \\<bullet> gsi.gso j' / \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i' \\<bullet> gsi.gso j' /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n    row (rB * rfs) i' \\<bullet> gsi.gso j' /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2", "using prep i' len'"], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom (row (B * mat_of_rows n fs) i') = row (rB * rfs) i'\n  i' < m\n  length fs' = m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i' \\<bullet> gsi.gso j' /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n    row (rB * rfs) i' \\<bullet> gsi.gso j' /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2", "unfolding rB_def B_def"], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom (row (A i j c * mat_of_rows n fs) i') =\n  row (of_int_hom.mat_hom (A i j c) * rfs) i'\n  i' < m\n  length fs' = m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i' \\<bullet> gsi.gso j' /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n    row (of_int_hom.mat_hom (A i j c) * rfs) i' \\<bullet> gsi.gso j' /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2", "by (simp add: fs'_prod)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i' \\<bullet> gsi.gso j' /\n  \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n  row (rB * rfs) i' \\<bullet> gsi.gso j' /\n  \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i' \\<bullet> gsi.gso j' /\n  \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n  row (rB * rfs) i' \\<bullet> gsi.gso j' /\n  \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"\\<dots> = \n          (vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l)) \\<bullet> gsi.gso j' / \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (rB * rfs) i' \\<bullet> gsi.gso j' /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n    vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l) \\<bullet> gsi.gso j' /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2", "using prep2"], ["proof (prove)\nusing this:\n  row (rB * rfs) i' = vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l)\n\ngoal (1 subgoal):\n 1. row (rB * rfs) i' \\<bullet> gsi.gso j' /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n    vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l) \\<bullet> gsi.gso j' /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  row (rB * rfs) i' \\<bullet> gsi.gso j' /\n  \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n  vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l) \\<bullet> gsi.gso j' /\n  \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  row (rB * rfs) i' \\<bullet> gsi.gso j' /\n  \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n  vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l) \\<bullet> gsi.gso j' /\n  \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l) = \n            (vec n (\\<lambda>l. (\\<Sum>j1=0..<m. (row rB i') $ j1 * (col rfs l) $ j1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l) =\n    vec n (\\<lambda>l. \\<Sum>j1 = 0..<m. row rB i' $ j1 * col rfs l $ j1)", "using gsi.gso_carrier"], ["proof (prove)\nusing this:\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gsi.gso ?i \\<in> local.LLL.Rn\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l) =\n    vec n (\\<lambda>l. \\<Sum>j1 = 0..<m. row rB i' $ j1 * col rfs l $ j1)", "by (metis (no_types) carrier_matD(1) col_def dim_vec rfscarr scalar_prod_def)"], ["proof (state)\nthis:\n  vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l) =\n  vec n (\\<lambda>l. \\<Sum>j1 = 0..<m. row rB i' $ j1 * col rfs l $ j1)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  vec n (\\<lambda>l. row rB i' \\<bullet> col rfs l) =\n  vec n (\\<lambda>l. \\<Sum>j1 = 0..<m. row rB i' $ j1 * col rfs l $ j1)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"\\<dots> = \n            (vec n (\\<lambda>l. (\\<Sum>j1=0..<m. rB $$ (i', j1) * rfs $$ (j1, l))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n (\\<lambda>l. \\<Sum>j1 = 0..<m. row rB i' $ j1 * col rfs l $ j1) =\n    vec n (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l))", "using rBcarr rfscarr i'"], ["proof (prove)\nusing this:\n  rB \\<in> carrier_mat m m\n  rfs \\<in> carrier_mat m n\n  i' < m\n\ngoal (1 subgoal):\n 1. vec n (\\<lambda>l. \\<Sum>j1 = 0..<m. row rB i' $ j1 * col rfs l $ j1) =\n    vec n (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l))", "by auto"], ["proof (state)\nthis:\n  vec n (\\<lambda>l. \\<Sum>j1 = 0..<m. row rB i' $ j1 * col rfs l $ j1) =\n  vec n (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l))\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  vec n (\\<lambda>l. \\<Sum>j1 = 0..<m. row rB i' $ j1 * col rfs l $ j1) =\n  vec n (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l))\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"\\<dots> \\<bullet> gsi.gso j' = \n            (\\<Sum>j2=0..<n. (vec n \n            (\\<lambda>l. (\\<Sum>j1=0..<m. rB $$ (i', j1) * rfs $$ (j1, l)))) $ j2 * (gsi.gso j') $ j2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>l.\n         \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l)) \\<bullet>\n    gsi.gso j' =\n    (\\<Sum>j2 = 0..<n.\n        vec n\n         (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l)) $\n        j2 *\n        gsi.gso j' $ j2)", "using gsi.gso_carrier len j' scalar_prod_def"], ["proof (prove)\nusing this:\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gsi.gso ?i \\<in> local.LLL.Rn\n  length fs = m\n  j' < m\n  ?v \\<bullet> ?w \\<equiv> \\<Sum>i = 0..<dim_vec ?w. ?v $ i * ?w $ i\n\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>l.\n         \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l)) \\<bullet>\n    gsi.gso j' =\n    (\\<Sum>j2 = 0..<n.\n        vec n\n         (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l)) $\n        j2 *\n        gsi.gso j' $ j2)", "by (smt gs.R.finsum_cong' gsi.gso_dim length_map)"], ["proof (state)\nthis:\n  vec n\n   (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l)) \\<bullet>\n  gsi.gso j' =\n  (\\<Sum>j2 = 0..<n.\n      vec n\n       (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l)) $\n      j2 *\n      gsi.gso j' $ j2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  vec n\n   (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l)) \\<bullet>\n  gsi.gso j' =\n  (\\<Sum>j2 = 0..<n.\n      vec n\n       (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l)) $\n      j2 *\n      gsi.gso j' $ j2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"\\<dots> = (\\<Sum>j2=0..<n.\n            (\\<Sum>j1=0..<m. rB $$ (i', j1) * rfs $$ (j1, j2)) * (gsi.gso j') $ j2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j2 = 0..<n.\n        vec n\n         (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l)) $\n        j2 *\n        gsi.gso j' $ j2) =\n    (\\<Sum>j2 = 0..<n.\n        (\\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, j2)) *\n        gsi.gso j' $ j2)", "using gsi.gso_carrier len j'"], ["proof (prove)\nusing this:\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gsi.gso ?i \\<in> local.LLL.Rn\n  length fs = m\n  j' < m\n\ngoal (1 subgoal):\n 1. (\\<Sum>j2 = 0..<n.\n        vec n\n         (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l)) $\n        j2 *\n        gsi.gso j' $ j2) =\n    (\\<Sum>j2 = 0..<n.\n        (\\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, j2)) *\n        gsi.gso j' $ j2)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j2 = 0..<n.\n      vec n\n       (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l)) $\n      j2 *\n      gsi.gso j' $ j2) =\n  (\\<Sum>j2 = 0..<n.\n      (\\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, j2)) *\n      gsi.gso j' $ j2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j2 = 0..<n.\n      vec n\n       (\\<lambda>l. \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, l)) $\n      j2 *\n      gsi.gso j' $ j2) =\n  (\\<Sum>j2 = 0..<n.\n      (\\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, j2)) *\n      gsi.gso j' $ j2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"\\<dots> = (\\<Sum>j2=0..<n. (\\<Sum>j1=0..<m.\n            rB $$ (i', j1) * rfs $$ (j1, j2) * (gsi.gso j') $ j2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j2 = 0..<n.\n        (\\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, j2)) *\n        gsi.gso j' $ j2) =\n    (\\<Sum>j2 = 0..<n.\n        \\<Sum>j1 = 0..<m.\n           rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2)", "by (smt gs.R.finsum_cong' sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>j2 = 0..<n.\n      (\\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, j2)) *\n      gsi.gso j' $ j2) =\n  (\\<Sum>j2 = 0..<n.\n      \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j2 = 0..<n.\n      (\\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, j2)) *\n      gsi.gso j' $ j2) =\n  (\\<Sum>j2 = 0..<n.\n      \\<Sum>j1 = 0..<m. rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"\\<dots> = (\\<Sum>j1=0..<m. (\\<Sum>j2=0..<n.\n            rB $$ (i', j1) * rfs $$ (j1, j2) * (gsi.gso j') $ j2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j2 = 0..<n.\n        \\<Sum>j1 = 0..<m.\n           rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2) =\n    (\\<Sum>j1 = 0..<m.\n        \\<Sum>j2 = 0..<n.\n           rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2)", "using sum.swap"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>?A. sum (?g i) ?B) = (\\<Sum>j\\<in>?B. \\<Sum>i\\<in>?A. ?g i j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j2 = 0..<n.\n        \\<Sum>j1 = 0..<m.\n           rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2) =\n    (\\<Sum>j1 = 0..<m.\n        \\<Sum>j2 = 0..<n.\n           rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>j2 = 0..<n.\n      \\<Sum>j1 = 0..<m.\n         rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2) =\n  (\\<Sum>j1 = 0..<m.\n      \\<Sum>j2 = 0..<n. rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j2 = 0..<n.\n      \\<Sum>j1 = 0..<m.\n         rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2) =\n  (\\<Sum>j1 = 0..<m.\n      \\<Sum>j2 = 0..<n. rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"\\<dots> = (\\<Sum>j1=0..<m. rB $$ (i', j1) * (\\<Sum>j2=0..<n. \n            rfs $$ (j1, j2) * (gsi.gso j') $ j2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j1 = 0..<m.\n        \\<Sum>j2 = 0..<n.\n           rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2) =\n    (\\<Sum>j1 = 0..<m.\n        rB $$ (i', j1) *\n        (\\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2))", "using gs.R.finsum_cong' sum_distrib_left"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A = ?B; True;\n   \\<And>i. i \\<in> ?B \\<Longrightarrow> ?f i = ?g i\\<rbrakk>\n  \\<Longrightarrow> sum ?f ?A = sum ?g ?B\n  ?r * sum ?f ?A = (\\<Sum>n\\<in>?A. ?r * ?f n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j1 = 0..<m.\n        \\<Sum>j2 = 0..<n.\n           rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2) =\n    (\\<Sum>j1 = 0..<m.\n        rB $$ (i', j1) *\n        (\\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2))", "by (smt gs.m_assoc)"], ["proof (state)\nthis:\n  (\\<Sum>j1 = 0..<m.\n      \\<Sum>j2 = 0..<n.\n         rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2) =\n  (\\<Sum>j1 = 0..<m.\n      rB $$ (i', j1) *\n      (\\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2))\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j1 = 0..<m.\n      \\<Sum>j2 = 0..<n.\n         rB $$ (i', j1) * rfs $$ (j1, j2) * gsi.gso j' $ j2) =\n  (\\<Sum>j1 = 0..<m.\n      rB $$ (i', j1) *\n      (\\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2))\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"\\<dots> = row rB i' \\<bullet> (vec m (\\<lambda> j1. (\\<Sum>j2=0..<n.\n            rfs $$ (j1, j2) * (gsi.gso j') $ j2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j1 = 0..<m.\n        rB $$ (i', j1) *\n        (\\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2)) =\n    row rB i' \\<bullet>\n    vec m (\\<lambda>j1. \\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2)", "using rBcarr rfscarr i' scalar_prod_def"], ["proof (prove)\nusing this:\n  rB \\<in> carrier_mat m m\n  rfs \\<in> carrier_mat m n\n  i' < m\n  ?v \\<bullet> ?w \\<equiv> \\<Sum>i = 0..<dim_vec ?w. ?v $ i * ?w $ i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j1 = 0..<m.\n        rB $$ (i', j1) *\n        (\\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2)) =\n    row rB i' \\<bullet>\n    vec m (\\<lambda>j1. \\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2)", "by (smt atLeastLessThan_iff carrier_matD(1) carrier_matD(2) dim_vec \n              gs.R.finsum_cong' index_row(1) index_vec)"], ["proof (state)\nthis:\n  (\\<Sum>j1 = 0..<m.\n      rB $$ (i', j1) *\n      (\\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2)) =\n  row rB i' \\<bullet>\n  vec m (\\<lambda>j1. \\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j1 = 0..<m.\n      rB $$ (i', j1) *\n      (\\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2)) =\n  row rB i' \\<bullet>\n  vec m (\\<lambda>j1. \\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"(vec m (\\<lambda> j1. (\\<Sum>j2=0..<n. rfs $$ (j1, j2) * (gsi.gso j') $ j2)))\n            =  (vec m (\\<lambda> j1. row rfs j1 \\<bullet> gsi.gso j'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec m\n     (\\<lambda>j1. \\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2) =\n    vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j')", "using rfscarr gsi.gso_carrier len j' rfscarr"], ["proof (prove)\nusing this:\n  rfs \\<in> carrier_mat m n\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gsi.gso ?i \\<in> local.LLL.Rn\n  length fs = m\n  j' < m\n  rfs \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. vec m\n     (\\<lambda>j1. \\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2) =\n    vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j')", "by (auto simp add: scalar_prod_def)"], ["proof (state)\nthis:\n  vec m (\\<lambda>j1. \\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2) =\n  vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j')\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  vec m (\\<lambda>j1. \\<Sum>j2 = 0..<n. rfs $$ (j1, j2) * gsi.gso j' $ j2) =\n  vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j')\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"row rB i' \\<bullet> \\<dots> / \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n          row rB i' \\<bullet> vec m (\\<lambda> j1. row rfs j1 \\<bullet> gsi.gso j' / \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row rB i' \\<bullet>\n    vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j') /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n    row rB i' \\<bullet>\n    vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2)", "using prep4 scalar_prod_smult_right rBcarr carrier_matD(2) dim_vec row_def"], ["proof (prove)\nusing this:\n  1 / \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n  vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j') =\n  vec m\n   (\\<lambda>j1.\n       row rfs j1 \\<bullet> gsi.gso j' /\n       \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2)\n  dim_vec ?w = dim_vec ?v \\<Longrightarrow>\n  ?w \\<bullet> (?k \\<cdot>\\<^sub>v ?v) = ?k * (?w \\<bullet> ?v)\n  rB \\<in> carrier_mat m m\n  ?A \\<in> carrier_mat ?nr ?nc \\<Longrightarrow> dim_col ?A = ?nc\n  dim_vec (vec ?n ?f) = ?n\n  row ?A ?i = vec (dim_col ?A) (\\<lambda>j. ?A $$ (?i, j))\n\ngoal (1 subgoal):\n 1. row rB i' \\<bullet>\n    vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j') /\n    \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n    row rB i' \\<bullet>\n    vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2)", "by (smt gs.l_one times_divide_eq_left)"], ["proof (state)\nthis:\n  row rB i' \\<bullet> vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j') /\n  \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n  row rB i' \\<bullet>\n  vec m\n   (\\<lambda>j1.\n       row rfs j1 \\<bullet> gsi.gso j' /\n       \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "also"], ["proof (state)\nthis:\n  row rB i' \\<bullet> vec m (\\<lambda>j1. row rfs j1 \\<bullet> gsi.gso j') /\n  \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2 =\n  row rB i' \\<bullet>\n  vec m\n   (\\<lambda>j1.\n       row rfs j1 \\<bullet> gsi.gso j' /\n       \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "have \"\\<dots> = (rB * (gsi.M m)) $$ (i', j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row rB i' \\<bullet>\n    vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n    (rB * gsi.M m) $$ (i', j')", "using rBcarr i' j' prep3 gsi.M_def"], ["proof (prove)\nusing this:\n  rB \\<in> carrier_mat m m\n  i' < m\n  j' < m\n  vec m\n   (\\<lambda>j1.\n       row rfs j1 \\<bullet> gsi.gso j' /\n       \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n  vec m (\\<lambda>j1. gsi.M m $$ (j1, j'))\n  gsi.M ?k = mat ?k ?k (\\<lambda>(x, y). gsi.\\<mu> x y)\n\ngoal (1 subgoal):\n 1. row rB i' \\<bullet>\n    vec m\n     (\\<lambda>j1.\n         row rfs j1 \\<bullet> gsi.gso j' /\n         \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n    (rB * gsi.M m) $$ (i', j')", "by (simp add: col_def)"], ["proof (state)\nthis:\n  row rB i' \\<bullet>\n  vec m\n   (\\<lambda>j1.\n       row rfs j1 \\<bullet> gsi.gso j' /\n       \\<parallel>gsi.gso j'\\<parallel>\\<^sup>2) =\n  (rB * gsi.M m) $$ (i', j')\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "finally"], ["proof (chain)\npicking this:\n  map of_int_hom.vec_hom fs' ! i' \\<bullet> fs'.gs.gso j' /\n  \\<parallel>fs'.gs.gso j'\\<parallel>\\<^sup>2 =\n  (rB * gsi.M m) $$ (i', j')", "have \n          \"map of_int_hom.vec_hom fs' ! i' \\<bullet> fs'.gs.gso j' / \\<parallel>fs'.gs.gso j'\\<parallel>\\<^sup>2 =\n          (rB * (gsi.M m)) $$ (i', j')\""], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs' ! i' \\<bullet> fs'.gs.gso j' /\n  \\<parallel>fs'.gs.gso j'\\<parallel>\\<^sup>2 =\n  (rB * gsi.M m) $$ (i', j')\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i' \\<bullet> fs'.gs.gso j' /\n    \\<parallel>fs'.gs.gso j'\\<parallel>\\<^sup>2 =\n    (rB * gsi.M m) $$ (i', j')", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i' \\<bullet> fs'.gs.gso j' /\n  \\<parallel>fs'.gs.gso j'\\<parallel>\\<^sup>2 =\n  (rB * gsi.M m) $$ (i', j')\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i'a3 < m; ?j'a3 < m\\<rbrakk>\n  \\<Longrightarrow> map of_int_hom.vec_hom fs' ! ?i'a3 \\<bullet>\n                    fs'.gs.gso ?j'a3 /\n                    \\<parallel>fs'.gs.gso ?j'a3\\<parallel>\\<^sup>2 =\n                    (rB * gsi.M m) $$ (?i'a3, ?j'a3)\n\ngoal (2 subgoals):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')\n 2. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i'a3 < m; ?j'a3 < m\\<rbrakk>\n  \\<Longrightarrow> map of_int_hom.vec_hom fs' ! ?i'a3 \\<bullet>\n                    fs'.gs.gso ?j'a3 /\n                    \\<parallel>fs'.gs.gso ?j'a3\\<parallel>\\<^sup>2 =\n                    (rB * gsi.M m) $$ (?i'a3, ?j'a3)", "show \"\\<And> i' j'. i' < m \\<Longrightarrow> j' < m \\<Longrightarrow> \\<mu> fs' i' j' = \n        (map_mat of_int (A i j c) * gsi.M m) $$ (i',j')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i'a3 < m; ?j'a3 < m\\<rbrakk>\n  \\<Longrightarrow> map of_int_hom.vec_hom fs' ! ?i'a3 \\<bullet>\n                    fs'.gs.gso ?j'a3 /\n                    \\<parallel>fs'.gs.gso ?j'a3\\<parallel>\\<^sup>2 =\n                    (rB * gsi.M m) $$ (?i'a3, ?j'a3)\n\ngoal (1 subgoal):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')", "using B_def fs'.gs.\\<beta>_zero fs'.gs.fi_scalar_prod_gso fs'.gs.gso_norm_beta\n          len' rB_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i'a3 < m; ?j'a3 < m\\<rbrakk>\n  \\<Longrightarrow> map of_int_hom.vec_hom fs' ! ?i'a3 \\<bullet>\n                    fs'.gs.gso ?j'a3 /\n                    \\<parallel>fs'.gs.gso ?j'a3\\<parallel>\\<^sup>2 =\n                    (rB * gsi.M m) $$ (?i'a3, ?j'a3)\n  B = A i j c\n  ?i < length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  gs.\\<beta> (map of_int_hom.vec_hom fs') ?i \\<noteq> 0\n  \\<lbrakk>?i < length (map of_int_hom.vec_hom fs');\n   ?j < length (map of_int_hom.vec_hom fs')\\<rbrakk>\n  \\<Longrightarrow> map of_int_hom.vec_hom fs' ! ?i \\<bullet>\n                    fs'.gs.gso ?j =\n                    fs'.gs.\\<mu> ?i ?j *\n                    \\<parallel>fs'.gs.gso ?j\\<parallel>\\<^sup>2\n  ?j < length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  gs.\\<beta> (map of_int_hom.vec_hom fs') ?j =\n  \\<parallel>fs'.gs.gso ?j\\<parallel>\\<^sup>2\n  length fs' = m\n  rB = of_int_hom.mat_hom B\n\ngoal (1 subgoal):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                         (of_int_hom.mat_hom (A i j c) * gsi.M m) $$\n                         (i', j')", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i'1 < m; ?j'1 < m\\<rbrakk>\n  \\<Longrightarrow> fs'.gs.\\<mu> ?i'1 ?j'1 =\n                    (of_int_hom.mat_hom (A i j c) * gsi.M m) $$ (?i'1, ?j'1)\n\ngoal (1 subgoal):\n 1. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "show \"\\<And> k. k < m \\<Longrightarrow> gso fs' k = gso fs k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "using gs_eq"], ["proof (prove)\nusing this:\n  ?k1 < m \\<Longrightarrow> fs'.gs.gso ?k1 = gsi.gso ?k1\n\ngoal (1 subgoal):\n 1. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "by auto"], ["proof (state)\nthis:\n  ?k1 < m \\<Longrightarrow> fs'.gs.gso ?k1 = gsi.gso ?k1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i'1 < m; ?j'1 < m\\<rbrakk>\n  \\<Longrightarrow> fs'.gs.\\<mu> ?i'1 ?j'1 =\n                    (of_int_hom.mat_hom (A i j c) * gsi.M m) $$ (?i'1, ?j'1)\n  ?k1 < m \\<Longrightarrow> fs'.gs.gso ?k1 = gsi.gso ?k1\n\ngoal (4 subgoals):\n 1. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 2. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 3. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i'1 < m; ?j'1 < m\\<rbrakk>\n  \\<Longrightarrow> fs'.gs.\\<mu> ?i'1 ?j'1 =\n                    (of_int_hom.mat_hom (A i j c) * gsi.M m) $$ (?i'1, ?j'1)\n  ?k1 < m \\<Longrightarrow> fs'.gs.gso ?k1 = gsi.gso ?k1\n\ngoal (4 subgoals):\n 1. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 2. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 3. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "note mu_gso = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i'1 < m; ?j'1 < m\\<rbrakk>\n  \\<Longrightarrow> fs'.gs.\\<mu> ?i'1 ?j'1 =\n                    (of_int_hom.mat_hom (A i j c) * gsi.M m) $$ (?i'1, ?j'1)\n  ?k1 < m \\<Longrightarrow> fs'.gs.gso ?k1 = gsi.gso ?k1\n\ngoal (4 subgoals):\n 1. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k\n 2. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 3. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 4. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "show \"\\<And> k. k < m \\<Longrightarrow> gso fs' k = gso fs k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. k < m \\<Longrightarrow> fs'.gs.gso k = gsi.gso k", "by fact"], ["proof (state)\nthis:\n  ?k1 < m \\<Longrightarrow> fs'.gs.gso ?k1 = gsi.gso ?k1\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 3. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "{"], ["proof (state)\nthis:\n  ?k1 < m \\<Longrightarrow> fs'.gs.gso ?k1 = gsi.gso ?k1\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 3. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "fix k"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 3. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have \"k \\<le> m \\<Longrightarrow> rat_of_int (d fs' k) = rat_of_int (d fs k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> m \\<Longrightarrow>\n    rat_of_int (local.LLL.d fs' k) = rat_of_int (local.LLL.d fs k)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> m \\<Longrightarrow>\n    rat_of_int (local.LLL.d fs' 0) = rat_of_int (local.LLL.d fs 0)\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                rat_of_int (local.LLL.d fs' k) =\n                rat_of_int (local.LLL.d fs k);\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (local.LLL.d fs' (Suc k)) =\n                         rat_of_int (local.LLL.d fs (Suc k))", "case 0"], ["proof (state)\nthis:\n  0 \\<le> m\n\ngoal (2 subgoals):\n 1. 0 \\<le> m \\<Longrightarrow>\n    rat_of_int (local.LLL.d fs' 0) = rat_of_int (local.LLL.d fs 0)\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                rat_of_int (local.LLL.d fs' k) =\n                rat_of_int (local.LLL.d fs k);\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (local.LLL.d fs' (Suc k)) =\n                         rat_of_int (local.LLL.d fs (Suc k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (local.LLL.d fs' 0) = rat_of_int (local.LLL.d fs 0)", "by (simp add: d_def)"], ["proof (state)\nthis:\n  rat_of_int (local.LLL.d fs' 0) = rat_of_int (local.LLL.d fs 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                rat_of_int (local.LLL.d fs' k) =\n                rat_of_int (local.LLL.d fs k);\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (local.LLL.d fs' (Suc k)) =\n                         rat_of_int (local.LLL.d fs (Suc k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                rat_of_int (local.LLL.d fs' k) =\n                rat_of_int (local.LLL.d fs k);\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (local.LLL.d fs' (Suc k)) =\n                         rat_of_int (local.LLL.d fs (Suc k))", "case (Suc k)"], ["proof (state)\nthis:\n  k \\<le> m \\<Longrightarrow>\n  rat_of_int (local.LLL.d fs' k) = rat_of_int (local.LLL.d fs k)\n  Suc k \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                rat_of_int (local.LLL.d fs' k) =\n                rat_of_int (local.LLL.d fs k);\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (local.LLL.d fs' (Suc k)) =\n                         rat_of_int (local.LLL.d fs (Suc k))", "hence k: \"k \\<le> m\" \"k < m\""], ["proof (prove)\nusing this:\n  k \\<le> m \\<Longrightarrow>\n  rat_of_int (local.LLL.d fs' k) = rat_of_int (local.LLL.d fs k)\n  Suc k \\<le> m\n\ngoal (1 subgoal):\n 1. k \\<le> m &&& k < m", "by auto"], ["proof (state)\nthis:\n  k \\<le> m\n  k < m\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                rat_of_int (local.LLL.d fs' k) =\n                rat_of_int (local.LLL.d fs k);\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (local.LLL.d fs' (Suc k)) =\n                         rat_of_int (local.LLL.d fs (Suc k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (local.LLL.d fs' (Suc k)) =\n    rat_of_int (local.LLL.d fs (Suc k))", "by (subst (1 2) LLL_d_Suc[OF _ k(2)], auto simp: Suc(1)[OF k(1)] mu_gso(2)[OF k(2)]\n          LLL_invariant_weak_def lin lin' len len' latt latt')"], ["proof (state)\nthis:\n  rat_of_int (local.LLL.d fs' (Suc k)) = rat_of_int (local.LLL.d fs (Suc k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k1 \\<le> m \\<Longrightarrow>\n  rat_of_int (local.LLL.d fs' ?k1) = rat_of_int (local.LLL.d fs ?k1)\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 3. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "thus \"k \\<le> m \\<Longrightarrow> d fs' k = d fs k\""], ["proof (prove)\nusing this:\n  ?k1 \\<le> m \\<Longrightarrow>\n  rat_of_int (local.LLL.d fs' ?k1) = rat_of_int (local.LLL.d fs ?k1)\n\ngoal (1 subgoal):\n 1. k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k", "by simp"], ["proof (state)\nthis:\n  k \\<le> m \\<Longrightarrow> local.LLL.d fs' k = local.LLL.d fs k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "}"], ["proof (state)\nthis:\n  ?k3 \\<le> m \\<Longrightarrow> local.LLL.d fs' ?k3 = local.LLL.d fs ?k3\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "note d = this"], ["proof (state)\nthis:\n  ?k3 \\<le> m \\<Longrightarrow> local.LLL.d fs' ?k3 = local.LLL.d fs ?k3\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "{"], ["proof (state)\nthis:\n  ?k3 \\<le> m \\<Longrightarrow> local.LLL.d fs' ?k3 = local.LLL.d fs ?k3\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "assume i': \"i' < m\" and j': \"j' < m\""], ["proof (state)\nthis:\n  i' < m\n  j' < m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have \"\\<mu> fs' i' j' = (of_int_hom.mat_hom (A i j c) * gsi.M m) $$ (i',j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs'.gs.\\<mu> i' j' =\n    (of_int_hom.mat_hom (A i j c) * gsi.M m) $$ (i', j')", "by (rule mu_gso(1)[OF i' j'])"], ["proof (state)\nthis:\n  fs'.gs.\\<mu> i' j' = (of_int_hom.mat_hom (A i j c) * gsi.M m) $$ (i', j')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "also"], ["proof (state)\nthis:\n  fs'.gs.\\<mu> i' j' = (of_int_hom.mat_hom (A i j c) * gsi.M m) $$ (i', j')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have \"\\<dots> = (if (i',j') = (i,j) then of_int c * gsi.d j else 0) + gsi.M m $$ (i',j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int_hom.mat_hom (A i j c) * gsi.M m) $$ (i', j') =\n    (if (i', j') = (i, j) then rat_of_int c * gsi.d j else 0) +\n    gsi.M m $$ (i', j')", "unfolding A(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat m m\n      (\\<lambda>ij. if ij = (i, j) then rat_of_int c * gsi.d j else 0) +\n     gsi.M m) $$\n    (i', j') =\n    (if (i', j') = (i, j) then rat_of_int c * gsi.d j else 0) +\n    gsi.M m $$ (i', j')", "using i' j'"], ["proof (prove)\nusing this:\n  i' < m\n  j' < m\n\ngoal (1 subgoal):\n 1. (mat m m\n      (\\<lambda>ij. if ij = (i, j) then rat_of_int c * gsi.d j else 0) +\n     gsi.M m) $$\n    (i', j') =\n    (if (i', j') = (i, j) then rat_of_int c * gsi.d j else 0) +\n    gsi.M m $$ (i', j')", "by (auto simp: gsi.M_def)"], ["proof (state)\nthis:\n  (of_int_hom.mat_hom (A i j c) * gsi.M m) $$ (i', j') =\n  (if (i', j') = (i, j) then rat_of_int c * gsi.d j else 0) +\n  gsi.M m $$ (i', j')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "also"], ["proof (state)\nthis:\n  (of_int_hom.mat_hom (A i j c) * gsi.M m) $$ (i', j') =\n  (if (i', j') = (i, j) then rat_of_int c * gsi.d j else 0) +\n  gsi.M m $$ (i', j')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have \"gsi.M m $$ (i',j') = \\<mu> fs i' j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gsi.M m $$ (i', j') = gsi.\\<mu> i' j'", "unfolding gsi.M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat m m (\\<lambda>(x, y). gsi.\\<mu> x y) $$ (i', j') = gsi.\\<mu> i' j'", "using i' j'"], ["proof (prove)\nusing this:\n  i' < m\n  j' < m\n\ngoal (1 subgoal):\n 1. mat m m (\\<lambda>(x, y). gsi.\\<mu> x y) $$ (i', j') = gsi.\\<mu> i' j'", "by simp"], ["proof (state)\nthis:\n  gsi.M m $$ (i', j') = gsi.\\<mu> i' j'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "also"], ["proof (state)\nthis:\n  gsi.M m $$ (i', j') = gsi.\\<mu> i' j'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have \"gsi.d j = of_int (d fs j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gsi.d j = rat_of_int (local.LLL.d fs j)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gsi.d j = rat_of_int (gs.Gramian_determinant fs j)", "by (subst Gramian_determinant_of_int[OF fs], insert ji i len, auto)"], ["proof (state)\nthis:\n  gsi.d j = rat_of_int (local.LLL.d fs j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> fs'.gs.\\<mu> i' j' =\n                      (if (i', j') = (i, j)\n                       then rat_of_int (c * local.LLL.d fs j) +\n                            gsi.\\<mu> i' j'\n                       else gsi.\\<mu> i' j')\n 2. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "finally"], ["proof (chain)\npicking this:\n  fs'.gs.\\<mu> i' j' =\n  (if (i', j') = (i, j) then rat_of_int c * rat_of_int (local.LLL.d fs j)\n   else 0) +\n  gsi.\\<mu> i' j'", "show mu: \"\\<mu> fs' i' j' = (if (i',j') = (i,j) then rat_of_int (c * d fs j) + \\<mu> fs i' j' else \\<mu> fs i' j')\""], ["proof (prove)\nusing this:\n  fs'.gs.\\<mu> i' j' =\n  (if (i', j') = (i, j) then rat_of_int c * rat_of_int (local.LLL.d fs j)\n   else 0) +\n  gsi.\\<mu> i' j'\n\ngoal (1 subgoal):\n 1. fs'.gs.\\<mu> i' j' =\n    (if (i', j') = (i, j)\n     then rat_of_int (c * local.LLL.d fs j) + gsi.\\<mu> i' j'\n     else gsi.\\<mu> i' j')", "by simp"], ["proof (state)\nthis:\n  fs'.gs.\\<mu> i' j' =\n  (if (i', j') = (i, j)\n   then rat_of_int (c * local.LLL.d fs j) + gsi.\\<mu> i' j'\n   else gsi.\\<mu> i' j')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "let ?d = \"d fs (Suc j')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have d_fs: \"of_int (d\\<mu> fs i' j') = rat_of_int ?d * \\<mu> fs i' j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (local.LLL.d\\<mu> fs i' j') =\n    rat_of_int (local.LLL.d fs (Suc j')) * gsi.\\<mu> i' j'", "unfolding d\\<mu>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int\n     (int_of_rat (rat_of_int (local.LLL.d fs (Suc j')) * gsi.\\<mu> i' j')) =\n    rat_of_int (local.LLL.d fs (Suc j')) * gsi.\\<mu> i' j'", "using fs.fs_int_mu_d_Z_m_m[unfolded len, OF i' j']"], ["proof (prove)\nusing this:\n  rat_of_int (fs'.d fs (Suc i')) * gsi.\\<mu> j' i' \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int\n     (int_of_rat (rat_of_int (local.LLL.d fs (Suc j')) * gsi.\\<mu> i' j')) =\n    rat_of_int (local.LLL.d fs (Suc j')) * gsi.\\<mu> i' j'", "by (metis LLL.LLL.d_def assms(2) fs.fs_int_mu_d_Z_m_m fs_int.d_def i' \n          int_of_rat(2) j')"], ["proof (state)\nthis:\n  rat_of_int (local.LLL.d\\<mu> fs i' j') =\n  rat_of_int (local.LLL.d fs (Suc j')) * gsi.\\<mu> i' j'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have \"rat_of_int (d\\<mu> fs' i' j') = rat_of_int (d fs' (Suc j')) * \\<mu> fs' i' j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (local.LLL.d\\<mu> fs' i' j') =\n    rat_of_int (local.LLL.d fs' (Suc j')) * fs'.gs.\\<mu> i' j'", "unfolding d\\<mu>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int\n     (int_of_rat\n       (rat_of_int (local.LLL.d fs' (Suc j')) * fs'.gs.\\<mu> i' j')) =\n    rat_of_int (local.LLL.d fs' (Suc j')) * fs'.gs.\\<mu> i' j'", "using fs'.fs_int_mu_d_Z_m_m[unfolded len', OF i' j']"], ["proof (prove)\nusing this:\n  rat_of_int (fs'.d fs' (Suc i')) * fs'.gs.\\<mu> j' i' \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int\n     (int_of_rat\n       (rat_of_int (local.LLL.d fs' (Suc j')) * fs'.gs.\\<mu> i' j')) =\n    rat_of_int (local.LLL.d fs' (Suc j')) * fs'.gs.\\<mu> i' j'", "using LLL.LLL.d_def fs'(1) fs'.d\\<mu> fs'.d\\<mu>_def fs_int.d_def i' j'"], ["proof (prove)\nusing this:\n  rat_of_int (fs'.d fs' (Suc i')) * fs'.gs.\\<mu> j' i' \\<in> \\<int>\n  LLL.LLL.d ?n ?fs ?k = gram_schmidt.Gramian_determinant ?n ?fs ?k\n  length fs' = m\n  \\<lbrakk>?j < length fs'; ?ii < length fs'\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (fs'.d\\<mu> ?ii ?j) =\n                    rat_of_int (fs'.d fs' (Suc ?j)) * fs'.gs.\\<mu> ?ii ?j\n  fs'.d\\<mu> ?i ?j =\n  int_of_rat (rat_of_int (fs'.d fs' (Suc ?j)) * fs'.gs.\\<mu> ?i ?j)\n  fs_int.d ?n ?fs ?k = gram_schmidt.Gramian_determinant ?n ?fs ?k\n  i' < m\n  j' < m\n\ngoal (1 subgoal):\n 1. rat_of_int\n     (int_of_rat\n       (rat_of_int (local.LLL.d fs' (Suc j')) * fs'.gs.\\<mu> i' j')) =\n    rat_of_int (local.LLL.d fs' (Suc j')) * fs'.gs.\\<mu> i' j'", "by auto"], ["proof (state)\nthis:\n  rat_of_int (local.LLL.d\\<mu> fs' i' j') =\n  rat_of_int (local.LLL.d fs' (Suc j')) * fs'.gs.\\<mu> i' j'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "also"], ["proof (state)\nthis:\n  rat_of_int (local.LLL.d\\<mu> fs' i' j') =\n  rat_of_int (local.LLL.d fs' (Suc j')) * fs'.gs.\\<mu> i' j'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have \"d fs' (Suc j') = ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.LLL.d fs' (Suc j') = local.LLL.d fs (Suc j')", "by (rule d, insert j', auto)"], ["proof (state)\nthis:\n  local.LLL.d fs' (Suc j') = local.LLL.d fs (Suc j')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "also"], ["proof (state)\nthis:\n  local.LLL.d fs' (Suc j') = local.LLL.d fs (Suc j')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have \"rat_of_int \\<dots> * \\<mu> fs' i' j' = \n      (if (i',j') = (i,j) then rat_of_int (c * d fs j * ?d) else 0) + of_int (d\\<mu> fs i' j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (local.LLL.d fs (Suc j')) * fs'.gs.\\<mu> i' j' =\n    (if (i', j') = (i, j)\n     then rat_of_int (c * local.LLL.d fs j * local.LLL.d fs (Suc j'))\n     else 0) +\n    rat_of_int (local.LLL.d\\<mu> fs i' j')", "unfolding mu d_fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (local.LLL.d fs (Suc j')) *\n    (if (i', j') = (i, j)\n     then rat_of_int (c * local.LLL.d fs j) + gsi.\\<mu> i' j'\n     else gsi.\\<mu> i' j') =\n    (if (i', j') = (i, j)\n     then rat_of_int (c * local.LLL.d fs j * local.LLL.d fs (Suc j'))\n     else 0) +\n    rat_of_int (local.LLL.d fs (Suc j')) * gsi.\\<mu> i' j'", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  rat_of_int (local.LLL.d fs (Suc j')) * fs'.gs.\\<mu> i' j' =\n  (if (i', j') = (i, j)\n   then rat_of_int (c * local.LLL.d fs j * local.LLL.d fs (Suc j'))\n   else 0) +\n  rat_of_int (local.LLL.d\\<mu> fs i' j')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "also"], ["proof (state)\nthis:\n  rat_of_int (local.LLL.d fs (Suc j')) * fs'.gs.\\<mu> i' j' =\n  (if (i', j') = (i, j)\n   then rat_of_int (c * local.LLL.d fs j * local.LLL.d fs (Suc j'))\n   else 0) +\n  rat_of_int (local.LLL.d\\<mu> fs i' j')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have \"\\<dots> = rat_of_int ((if (i',j') = (i,j) then c * d fs j * ?d else 0) + d\\<mu> fs i' j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (i', j') = (i, j)\n     then rat_of_int (c * local.LLL.d fs j * local.LLL.d fs (Suc j'))\n     else 0) +\n    rat_of_int (local.LLL.d\\<mu> fs i' j') =\n    rat_of_int\n     ((if (i', j') = (i, j)\n       then c * local.LLL.d fs j * local.LLL.d fs (Suc j') else 0) +\n      local.LLL.d\\<mu> fs i' j')", "by simp"], ["proof (state)\nthis:\n  (if (i', j') = (i, j)\n   then rat_of_int (c * local.LLL.d fs j * local.LLL.d fs (Suc j'))\n   else 0) +\n  rat_of_int (local.LLL.d\\<mu> fs i' j') =\n  rat_of_int\n   ((if (i', j') = (i, j)\n     then c * local.LLL.d fs j * local.LLL.d fs (Suc j') else 0) +\n    local.LLL.d\\<mu> fs i' j')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "also"], ["proof (state)\nthis:\n  (if (i', j') = (i, j)\n   then rat_of_int (c * local.LLL.d fs j * local.LLL.d fs (Suc j'))\n   else 0) +\n  rat_of_int (local.LLL.d\\<mu> fs i' j') =\n  rat_of_int\n   ((if (i', j') = (i, j)\n     then c * local.LLL.d fs j * local.LLL.d fs (Suc j') else 0) +\n    local.LLL.d\\<mu> fs i' j')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "have \"\\<dots> = rat_of_int ((if (i',j') = (i,j) then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j' else d\\<mu> fs i' j'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int\n     ((if (i', j') = (i, j)\n       then c * local.LLL.d fs j * local.LLL.d fs (Suc j') else 0) +\n      local.LLL.d\\<mu> fs i' j') =\n    rat_of_int\n     (if (i', j') = (i, j)\n      then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n           local.LLL.d\\<mu> fs i' j'\n      else local.LLL.d\\<mu> fs i' j')", "by simp"], ["proof (state)\nthis:\n  rat_of_int\n   ((if (i', j') = (i, j)\n     then c * local.LLL.d fs j * local.LLL.d fs (Suc j') else 0) +\n    local.LLL.d\\<mu> fs i' j') =\n  rat_of_int\n   (if (i', j') = (i, j)\n    then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n         local.LLL.d\\<mu> fs i' j'\n    else local.LLL.d\\<mu> fs i' j')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                      (if (i', j') = (i, j)\n                       then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                            local.LLL.d\\<mu> fs i' j'\n                       else local.LLL.d\\<mu> fs i' j')", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (local.LLL.d\\<mu> fs' i' j') =\n  rat_of_int\n   (if (i', j') = (i, j)\n    then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n         local.LLL.d\\<mu> fs i' j'\n    else local.LLL.d\\<mu> fs i' j')", "show \"d\\<mu> fs' i' j' = (if (i',j') = (i,j) then c * d fs j * d fs (Suc j) + d\\<mu> fs i' j' else d\\<mu> fs i' j')\""], ["proof (prove)\nusing this:\n  rat_of_int (local.LLL.d\\<mu> fs' i' j') =\n  rat_of_int\n   (if (i', j') = (i, j)\n    then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n         local.LLL.d\\<mu> fs i' j'\n    else local.LLL.d\\<mu> fs i' j')\n\ngoal (1 subgoal):\n 1. local.LLL.d\\<mu> fs' i' j' =\n    (if (i', j') = (i, j)\n     then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n          local.LLL.d\\<mu> fs i' j'\n     else local.LLL.d\\<mu> fs i' j')", "by simp"], ["proof (state)\nthis:\n  local.LLL.d\\<mu> fs' i' j' =\n  (if (i', j') = (i, j)\n   then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n        local.LLL.d\\<mu> fs i' j'\n   else local.LLL.d\\<mu> fs i' j')\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i' < m; j' < m\\<rbrakk>\n  \\<Longrightarrow> local.LLL.d\\<mu> fs' i' j' =\n                    (if (i', j') = (i, j)\n                     then c * local.LLL.d fs j * local.LLL.d fs (Suc j) +\n                          local.LLL.d\\<mu> fs i' j'\n                     else local.LLL.d\\<mu> fs i' j')\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Eventually: Lemma 13 of Storjohann's paper.\\<close>"], ["", "lemma mod_single_element: assumes lin: \"lin_indep fs\" \n  and len: \"length fs = m\" \n  and i: \"i < m\" and ji: \"j < i\"  \n  and latt: \"lattice_of fs = L\" \n  and pgtz: \"p > 0\"\nshows \"\\<exists> fs'. lattice_of fs' = L \\<and> \n  map (map_vec (\\<lambda> x. x mod p)) fs' = map (map_vec (\\<lambda> x. x mod p)) fs \\<and>\n  map (map_vec (\\<lambda> x. x symmod p)) fs' = map (map_vec (\\<lambda> x. x symmod p)) fs \\<and>\n  lin_indep fs' \\<and>\n  length fs' = m \\<and> \n  (\\<forall> k < m. gso fs' k = gso fs k) \\<and> \n  (\\<forall> k \\<le> m. d fs' k = d fs k) \\<and>\n  (\\<forall> i' < m. \\<forall> j' < m. d\\<mu> fs' i' j' = (if (i',j') = (i,j) then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j')) else d\\<mu> fs i' j'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "have inv: \"LLL_invariant_weak fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant_weak fs", "using LLL_invariant_weak_def assms"], ["proof (prove)\nusing this:\n  LLL_invariant_weak ?fs =\n  (gs.lin_indpt_list (map of_int_hom.vec_hom ?fs) \\<and>\n   lattice_of ?fs = L \\<and> length ?fs = m)\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = m\n  i < m\n  j < i\n  lattice_of fs = L\n  0 < p\n\ngoal (1 subgoal):\n 1. LLL_invariant_weak fs", "by simp"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "let ?mult = \"d fs j * d fs (Suc j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "define M where \"M = ?mult\""], ["proof (state)\nthis:\n  M = d fs j * d fs (Suc j)\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "define pM where \"pM = p * M\""], ["proof (state)\nthis:\n  pM = p * M\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "then"], ["proof (chain)\npicking this:\n  pM = p * M", "have pMgtz: \"pM > 0\""], ["proof (prove)\nusing this:\n  pM = p * M\n\ngoal (1 subgoal):\n 1. 0 < pM", "using pgtz"], ["proof (prove)\nusing this:\n  pM = p * M\n  0 < p\n\ngoal (1 subgoal):\n 1. 0 < pM", "unfolding pM_def M_def"], ["proof (prove)\nusing this:\n  p * (d fs j * d fs (Suc j)) = p * (d fs j * d fs (Suc j))\n  0 < p\n\ngoal (1 subgoal):\n 1. 0 < p * (d fs j * d fs (Suc j))", "using LLL_d_pos[OF inv] i ji"], ["proof (prove)\nusing this:\n  p * (d fs j * d fs (Suc j)) = p * (d fs j * d fs (Suc j))\n  0 < p\n  ?k \\<le> m \\<Longrightarrow> 0 < d fs ?k\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. 0 < p * (d fs j * d fs (Suc j))", "by simp"], ["proof (state)\nthis:\n  0 < pM\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "let ?d = \"d\\<mu> fs i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "define c where \"c = - (?d symdiv pM)\""], ["proof (state)\nthis:\n  c = - (d\\<mu> fs i j symdiv pM)\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "have d_mod: \"?d symmod pM = c * pM + ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs i j symmod pM = c * pM + d\\<mu> fs i j", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs i j symmod pM =\n    - (d\\<mu> fs i j symdiv pM) * pM + d\\<mu> fs i j", "using pMgtz sym_mod_sym_div"], ["proof (prove)\nusing this:\n  0 < pM\n  0 < ?y \\<Longrightarrow> ?x symmod ?y = ?x - ?x symdiv ?y * ?y\n\ngoal (1 subgoal):\n 1. d\\<mu> fs i j symmod pM =\n    - (d\\<mu> fs i j symdiv pM) * pM + d\\<mu> fs i j", "by simp"], ["proof (state)\nthis:\n  d\\<mu> fs i j symmod pM = c * pM + d\\<mu> fs i j\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "define A where \"A = gram_schmidt_fs_int.inv_mu_ij_mat n (RAT fs)\""], ["proof (state)\nthis:\n  A = gram_schmidt_fs_int.inv_mu_ij_mat n (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "define fs' where fs': \"fs' = Matrix.rows (A i j (c * p) * mat_of_rows n fs)\""], ["proof (state)\nthis:\n  fs' = rows (A i j (c * p) * mat_of_rows n fs)\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "note main = change_single_element[OF lin len i ji A_def fs' latt]"], ["proof (state)\nthis:\n  lattice_of fs' = L\n  c * p mod ?p = 0 \\<Longrightarrow>\n  map (map_vec (\\<lambda>x. x mod ?p)) fs' =\n  map (map_vec (\\<lambda>x. x mod ?p)) fs\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length fs' = m\n  ?k < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?k =\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?k\n  ?k \\<le> m \\<Longrightarrow> d fs' ?k = d fs ?k\n  \\<lbrakk>?i' < m; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') ?i'\n                     ?j' =\n                    (if (?i', ?j') = (i, j)\n                     then rat_of_int (c * p * d fs j) +\n                          gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) ?i' ?j'\n                     else gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) ?i' ?j')\n  \\<lbrakk>?i' < m; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> d\\<mu> fs' ?i' ?j' =\n                    (if (?i', ?j') = (i, j)\n                     then c * p * d fs j * d fs (Suc j) + d\\<mu> fs ?i' ?j'\n                     else d\\<mu> fs ?i' ?j')\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "have \"map (map_vec (\\<lambda>x. x mod p)) fs' = map (map_vec (\\<lambda>x. x mod p)) fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map_vec (\\<lambda>x. x mod p)) fs' =\n    map (map_vec (\\<lambda>x. x mod p)) fs", "by (intro main, auto)"], ["proof (state)\nthis:\n  map (map_vec (\\<lambda>x. x mod p)) fs' =\n  map (map_vec (\\<lambda>x. x mod p)) fs\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "from arg_cong[OF this, of \"map (map_vec (poly_mod.inv_M p))\"]"], ["proof (chain)\npicking this:\n  map (map_vec (poly_mod.inv_M p))\n   (map (map_vec (\\<lambda>x. x mod p)) fs') =\n  map (map_vec (poly_mod.inv_M p)) (map (map_vec (\\<lambda>x. x mod p)) fs)", "have id: \"map (map_vec (\\<lambda>x. x symmod p)) fs' = map (map_vec (\\<lambda>x. x symmod p)) fs\""], ["proof (prove)\nusing this:\n  map (map_vec (poly_mod.inv_M p))\n   (map (map_vec (\\<lambda>x. x mod p)) fs') =\n  map (map_vec (poly_mod.inv_M p)) (map (map_vec (\\<lambda>x. x mod p)) fs)\n\ngoal (1 subgoal):\n 1. map (map_vec (\\<lambda>x. x symmod p)) fs' =\n    map (map_vec (\\<lambda>x. x symmod p)) fs", "unfolding map_map o_def sym_mod_def map_vec_map_vec"], ["proof (prove)\nusing this:\n  map (map_vec (\\<lambda>x. poly_mod.inv_M p (x mod p))) fs' =\n  map (map_vec (\\<lambda>x. poly_mod.inv_M p (x mod p))) fs\n\ngoal (1 subgoal):\n 1. map (map_vec (\\<lambda>x. poly_mod.inv_M p (x mod p))) fs' =\n    map (map_vec (\\<lambda>x. poly_mod.inv_M p (x mod p))) fs", "."], ["proof (state)\nthis:\n  map (map_vec (\\<lambda>x. x symmod p)) fs' =\n  map (map_vec (\\<lambda>x. x symmod p)) fs\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') = (i, j)\n               then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "proof (intro exI[of _ fs'] conjI main allI impI id)"], ["proof (state)\ngoal (4 subgoals):\n 1. c * p mod p = 0\n 2. \\<And>k. k < m \\<Longrightarrow> k < m\n 3. \\<And>k. k \\<le> m \\<Longrightarrow> k \\<le> m\n 4. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if (i', j') = (i, j)\n                          then d\\<mu> fs i j' symmod\n                               (p * d fs j' * d fs (Suc j'))\n                          else d\\<mu> fs i' j')", "fix i' j'"], ["proof (state)\ngoal (4 subgoals):\n 1. c * p mod p = 0\n 2. \\<And>k. k < m \\<Longrightarrow> k < m\n 3. \\<And>k. k \\<le> m \\<Longrightarrow> k \\<le> m\n 4. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if (i', j') = (i, j)\n                          then d\\<mu> fs i j' symmod\n                               (p * d fs j' * d fs (Suc j'))\n                          else d\\<mu> fs i' j')", "assume ij: \"i' < m\" \"j' < m\""], ["proof (state)\nthis:\n  i' < m\n  j' < m\n\ngoal (4 subgoals):\n 1. c * p mod p = 0\n 2. \\<And>k. k < m \\<Longrightarrow> k < m\n 3. \\<And>k. k \\<le> m \\<Longrightarrow> k \\<le> m\n 4. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if (i', j') = (i, j)\n                          then d\\<mu> fs i j' symmod\n                               (p * d fs j' * d fs (Suc j'))\n                          else d\\<mu> fs i' j')", "have \"d\\<mu> fs' i' j' = (if (i', j') = (i, j) then (c * p) * M + ?d else d\\<mu> fs i' j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs' i' j' =\n    (if (i', j') = (i, j) then c * p * M + d\\<mu> fs i j\n     else d\\<mu> fs i' j')", "unfolding main(8)[OF ij] M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (i', j') = (i, j)\n     then c * p * d fs j * d fs (Suc j) + d\\<mu> fs i' j'\n     else d\\<mu> fs i' j') =\n    (if (i', j') = (i, j)\n     then c * p * (d fs j * d fs (Suc j)) + d\\<mu> fs i j\n     else d\\<mu> fs i' j')", "by simp"], ["proof (state)\nthis:\n  d\\<mu> fs' i' j' =\n  (if (i', j') = (i, j) then c * p * M + d\\<mu> fs i j else d\\<mu> fs i' j')\n\ngoal (4 subgoals):\n 1. c * p mod p = 0\n 2. \\<And>k. k < m \\<Longrightarrow> k < m\n 3. \\<And>k. k \\<le> m \\<Longrightarrow> k \\<le> m\n 4. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if (i', j') = (i, j)\n                          then d\\<mu> fs i j' symmod\n                               (p * d fs j' * d fs (Suc j'))\n                          else d\\<mu> fs i' j')", "also"], ["proof (state)\nthis:\n  d\\<mu> fs' i' j' =\n  (if (i', j') = (i, j) then c * p * M + d\\<mu> fs i j else d\\<mu> fs i' j')\n\ngoal (4 subgoals):\n 1. c * p mod p = 0\n 2. \\<And>k. k < m \\<Longrightarrow> k < m\n 3. \\<And>k. k \\<le> m \\<Longrightarrow> k \\<le> m\n 4. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if (i', j') = (i, j)\n                          then d\\<mu> fs i j' symmod\n                               (p * d fs j' * d fs (Suc j'))\n                          else d\\<mu> fs i' j')", "have \"(c * p) * M + ?d = ?d symmod pM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * p * M + d\\<mu> fs i j = d\\<mu> fs i j symmod pM", "unfolding d_mod"], ["proof (prove)\ngoal (1 subgoal):\n 1. c * p * M + d\\<mu> fs i j = c * pM + d\\<mu> fs i j", "by (simp add: pM_def)"], ["proof (state)\nthis:\n  c * p * M + d\\<mu> fs i j = d\\<mu> fs i j symmod pM\n\ngoal (4 subgoals):\n 1. c * p mod p = 0\n 2. \\<And>k. k < m \\<Longrightarrow> k < m\n 3. \\<And>k. k \\<le> m \\<Longrightarrow> k \\<le> m\n 4. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if (i', j') = (i, j)\n                          then d\\<mu> fs i j' symmod\n                               (p * d fs j' * d fs (Suc j'))\n                          else d\\<mu> fs i' j')", "finally"], ["proof (chain)\npicking this:\n  d\\<mu> fs' i' j' =\n  (if (i', j') = (i, j) then d\\<mu> fs i j symmod pM else d\\<mu> fs i' j')", "show \"d\\<mu> fs' i' j' = (if (i',j') = (i,j) then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j')) else d\\<mu> fs i' j')\""], ["proof (prove)\nusing this:\n  d\\<mu> fs' i' j' =\n  (if (i', j') = (i, j) then d\\<mu> fs i j symmod pM else d\\<mu> fs i' j')\n\ngoal (1 subgoal):\n 1. d\\<mu> fs' i' j' =\n    (if (i', j') = (i, j)\n     then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n     else d\\<mu> fs i' j')", "by (auto simp: pM_def M_def ac_simps)"], ["proof (state)\nthis:\n  d\\<mu> fs' i' j' =\n  (if (i', j') = (i, j)\n   then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n   else d\\<mu> fs i' j')\n\ngoal (3 subgoals):\n 1. c * p mod p = 0\n 2. \\<And>k. k < m \\<Longrightarrow> k < m\n 3. \\<And>k. k \\<le> m \\<Longrightarrow> k \\<le> m", "qed auto"], ["proof (state)\nthis:\n  \\<exists>fs'.\n     lattice_of fs' = L \\<and>\n     map (map_vec (\\<lambda>x. x mod p)) fs' =\n     map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n     map (map_vec (\\<lambda>x. x symmod p)) fs' =\n     map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n     gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n     length fs' = m \\<and>\n     (\\<forall>k<m.\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n     (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n     (\\<forall>i'<m.\n         \\<forall>j'<m.\n            d\\<mu> fs' i' j' =\n            (if (i', j') = (i, j)\n             then d\\<mu> fs i j' symmod (p * d fs j' * d fs (Suc j'))\n             else d\\<mu> fs i' j'))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A slight generalization to perform modulo on arbitrary set of indices $I$.\\<close>"], ["", "lemma mod_finite_set: assumes lin: \"lin_indep fs\" \n  and len: \"length fs = m\" \n  and I: \"I \\<subseteq> {(i,j). i < m \\<and> j < i}\"\n  and latt: \"lattice_of fs = L\" \n  and pgtz: \"p > 0\"\nshows \"\\<exists> fs'. lattice_of fs' = L \\<and>\n  map (map_vec (\\<lambda> x. x mod p)) fs' = map (map_vec (\\<lambda> x. x mod p)) fs \\<and>\n  map (map_vec (\\<lambda> x. x symmod p)) fs' = map (map_vec (\\<lambda> x. x symmod p)) fs \\<and>\n  lin_indep fs' \\<and>\n  length fs' = m \\<and> \n  (\\<forall> k < m. gso fs' k = gso fs k) \\<and> \n  (\\<forall> k \\<le> m. d fs' k = d fs k) \\<and>\n  (\\<forall> i' < m. \\<forall> j' < m. d\\<mu> fs' i' j' = \n     (if (i',j') \\<in> I then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j')) else d\\<mu> fs i' j'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') \\<in> I\n               then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') \\<in> I\n               then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "let ?exp = \"\\<lambda> fs' I i' j'. \n    d\\<mu> fs' i' j' = (if (i',j') \\<in> I then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j')) else d\\<mu> fs i' j')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') \\<in> I\n               then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "let ?prop = \"\\<lambda> fs fs'. lattice_of fs' = L \\<and> \n    map (map_vec (\\<lambda> x. x mod p)) fs' = map (map_vec (\\<lambda> x. x mod p)) fs \\<and>\n    map (map_vec (\\<lambda> x. x symmod p)) fs' = map (map_vec (\\<lambda> x. x symmod p)) fs \\<and>\n    lin_indep fs' \\<and>\n    length fs' = m \\<and> \n    (\\<forall> k < m. gso fs' k = gso fs k) \\<and> \n    (\\<forall> k \\<le> m. d fs' k = d fs k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') \\<in> I\n               then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "have \"finite I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I", "proof (rule finite_subset[OF I], rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. {(i, j). i < m \\<and> j < i} \\<subseteq> ?B2\n 2. finite ?B2", "show \"{(i, j). i < m \\<and> j < i} \\<subseteq> {0..m} \\<times> {0..m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(i, j). i < m \\<and> j < i} \\<subseteq> {0..m} \\<times> {0..m}", "by auto"], ["proof (state)\nthis:\n  {(i, j). i < m \\<and> j < i} \\<subseteq> {0..m} \\<times> {0..m}\n\ngoal (1 subgoal):\n 1. finite ({0..m} \\<times> {0..m})", "qed auto"], ["proof (state)\nthis:\n  finite I\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') \\<in> I\n               then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "from this I"], ["proof (chain)\npicking this:\n  finite I\n  I \\<subseteq> {(i, j). i < m \\<and> j < i}", "have \"\\<exists> fs'. ?prop fs fs' \\<and> (\\<forall> i' < m. \\<forall> j' < m. ?exp fs' I i' j')\""], ["proof (prove)\nusing this:\n  finite I\n  I \\<subseteq> {(i, j). i < m \\<and> j < i}\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       (lattice_of fs' = L \\<and>\n        map (map_vec (\\<lambda>x. x mod p)) fs' =\n        map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n        map (map_vec (\\<lambda>x. x symmod p)) fs' =\n        map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n        gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n        length fs' = m \\<and>\n        (\\<forall>k<m.\n            gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n            gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n        (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') \\<in> I\n               then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "proof (induct I)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n    \\<exists>fs'.\n       (lattice_of fs' = L \\<and>\n        map (map_vec (\\<lambda>x. x mod p)) fs' =\n        map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n        map (map_vec (\\<lambda>x. x symmod p)) fs' =\n        map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n        gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n        length fs' = m \\<and>\n        (\\<forall>k<m.\n            gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n            gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n        (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') \\<in> {}\n               then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n        \\<exists>fs'.\n           (lattice_of fs' = L \\<and>\n            map (map_vec (\\<lambda>x. x mod p)) fs' =\n            map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n            map (map_vec (\\<lambda>x. x symmod p)) fs' =\n            map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n            gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n            length fs' = m \\<and>\n            (\\<forall>k<m.\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n            (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n           (\\<forall>i'<m.\n               \\<forall>j'<m.\n                  d\\<mu> fs' i' j' =\n                  (if (i', j') \\<in> F\n                   then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n                   else d\\<mu> fs i' j'));\n        insert x F \\<subseteq> {(i, j). i < m \\<and> j < i}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs'.\n                            (lattice_of fs' = L \\<and>\n                             map (map_vec (\\<lambda>x. x mod p)) fs' =\n                             map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n                             map (map_vec (\\<lambda>x. x symmod p)) fs' =\n                             map (map_vec (\\<lambda>x. x symmod p))\n                              fs \\<and>\n                             gs.lin_indpt_list\n                              (map of_int_hom.vec_hom fs') \\<and>\n                             length fs' = m \\<and>\n                             (\\<forall>k<m.\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs') k =\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs) k) \\<and>\n                             (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n                            (\\<forall>i'<m.\n                                \\<forall>j'<m.\n                                   d\\<mu> fs' i' j' =\n                                   (if (i', j') \\<in> insert x F\n                                    then d\\<mu> fs i' j' symmod\n   (p * d fs j' * d fs (Suc j'))\n                                    else d\\<mu> fs i' j'))", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> {a. case a of (i, j) \\<Rightarrow> i < m \\<and> j < i}\n\ngoal (2 subgoals):\n 1. {} \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n    \\<exists>fs'.\n       (lattice_of fs' = L \\<and>\n        map (map_vec (\\<lambda>x. x mod p)) fs' =\n        map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n        map (map_vec (\\<lambda>x. x symmod p)) fs' =\n        map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n        gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n        length fs' = m \\<and>\n        (\\<forall>k<m.\n            gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n            gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n        (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') \\<in> {}\n               then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n        \\<exists>fs'.\n           (lattice_of fs' = L \\<and>\n            map (map_vec (\\<lambda>x. x mod p)) fs' =\n            map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n            map (map_vec (\\<lambda>x. x symmod p)) fs' =\n            map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n            gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n            length fs' = m \\<and>\n            (\\<forall>k<m.\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n            (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n           (\\<forall>i'<m.\n               \\<forall>j'<m.\n                  d\\<mu> fs' i' j' =\n                  (if (i', j') \\<in> F\n                   then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n                   else d\\<mu> fs i' j'));\n        insert x F \\<subseteq> {(i, j). i < m \\<and> j < i}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs'.\n                            (lattice_of fs' = L \\<and>\n                             map (map_vec (\\<lambda>x. x mod p)) fs' =\n                             map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n                             map (map_vec (\\<lambda>x. x symmod p)) fs' =\n                             map (map_vec (\\<lambda>x. x symmod p))\n                              fs \\<and>\n                             gs.lin_indpt_list\n                              (map of_int_hom.vec_hom fs') \\<and>\n                             length fs' = m \\<and>\n                             (\\<forall>k<m.\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs') k =\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs) k) \\<and>\n                             (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n                            (\\<forall>i'<m.\n                                \\<forall>j'<m.\n                                   d\\<mu> fs' i' j' =\n                                   (if (i', j') \\<in> insert x F\n                                    then d\\<mu> fs i' j' symmod\n   (p * d fs j' * d fs (Suc j'))\n                                    else d\\<mu> fs i' j'))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       (lattice_of fs' = L \\<and>\n        map (map_vec (\\<lambda>x. x mod p)) fs' =\n        map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n        map (map_vec (\\<lambda>x. x symmod p)) fs' =\n        map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n        gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n        length fs' = m \\<and>\n        (\\<forall>k<m.\n            gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n            gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n        (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') \\<in> {}\n               then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "by (intro exI[of _ fs], insert assms, auto)"], ["proof (state)\nthis:\n  \\<exists>fs'.\n     (lattice_of fs' = L \\<and>\n      map (map_vec (\\<lambda>x. x mod p)) fs' =\n      map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n      map (map_vec (\\<lambda>x. x symmod p)) fs' =\n      map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n      gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n      length fs' = m \\<and>\n      (\\<forall>k<m.\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n      (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n     (\\<forall>i'<m.\n         \\<forall>j'<m.\n            d\\<mu> fs' i' j' =\n            (if (i', j') \\<in> {}\n             then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n             else d\\<mu> fs i' j'))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n        \\<exists>fs'.\n           (lattice_of fs' = L \\<and>\n            map (map_vec (\\<lambda>x. x mod p)) fs' =\n            map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n            map (map_vec (\\<lambda>x. x symmod p)) fs' =\n            map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n            gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n            length fs' = m \\<and>\n            (\\<forall>k<m.\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n            (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n           (\\<forall>i'<m.\n               \\<forall>j'<m.\n                  d\\<mu> fs' i' j' =\n                  (if (i', j') \\<in> F\n                   then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n                   else d\\<mu> fs i' j'));\n        insert x F \\<subseteq> {(i, j). i < m \\<and> j < i}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs'.\n                            (lattice_of fs' = L \\<and>\n                             map (map_vec (\\<lambda>x. x mod p)) fs' =\n                             map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n                             map (map_vec (\\<lambda>x. x symmod p)) fs' =\n                             map (map_vec (\\<lambda>x. x symmod p))\n                              fs \\<and>\n                             gs.lin_indpt_list\n                              (map of_int_hom.vec_hom fs') \\<and>\n                             length fs' = m \\<and>\n                             (\\<forall>k<m.\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs') k =\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs) k) \\<and>\n                             (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n                            (\\<forall>i'<m.\n                                \\<forall>j'<m.\n                                   d\\<mu> fs' i' j' =\n                                   (if (i', j') \\<in> insert x F\n                                    then d\\<mu> fs i' j' symmod\n   (p * d fs j' * d fs (Suc j'))\n                                    else d\\<mu> fs i' j'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n        \\<exists>fs'.\n           (lattice_of fs' = L \\<and>\n            map (map_vec (\\<lambda>x. x mod p)) fs' =\n            map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n            map (map_vec (\\<lambda>x. x symmod p)) fs' =\n            map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n            gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n            length fs' = m \\<and>\n            (\\<forall>k<m.\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n            (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n           (\\<forall>i'<m.\n               \\<forall>j'<m.\n                  d\\<mu> fs' i' j' =\n                  (if (i', j') \\<in> F\n                   then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n                   else d\\<mu> fs i' j'));\n        insert x F \\<subseteq> {(i, j). i < m \\<and> j < i}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs'.\n                            (lattice_of fs' = L \\<and>\n                             map (map_vec (\\<lambda>x. x mod p)) fs' =\n                             map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n                             map (map_vec (\\<lambda>x. x symmod p)) fs' =\n                             map (map_vec (\\<lambda>x. x symmod p))\n                              fs \\<and>\n                             gs.lin_indpt_list\n                              (map of_int_hom.vec_hom fs') \\<and>\n                             length fs' = m \\<and>\n                             (\\<forall>k<m.\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs') k =\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs) k) \\<and>\n                             (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n                            (\\<forall>i'<m.\n                                \\<forall>j'<m.\n                                   d\\<mu> fs' i' j' =\n                                   (if (i', j') \\<in> insert x F\n                                    then d\\<mu> fs i' j' symmod\n   (p * d fs j' * d fs (Suc j'))\n                                    else d\\<mu> fs i' j'))", "case (insert ij I)"], ["proof (state)\nthis:\n  finite I\n  ij \\<notin> I\n  I \\<subseteq> {a. case a of\n                    (i, j) \\<Rightarrow>\n                      i < m \\<and> j < i} \\<Longrightarrow>\n  \\<exists>fs'.\n     (lattice_of fs' = L \\<and>\n      map (map_vec (\\<lambda>x. x mod p)) fs' =\n      map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n      map (map_vec (\\<lambda>x. x symmod p)) fs' =\n      map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n      gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n      length fs' = m \\<and>\n      (\\<forall>k<m.\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n      (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n     (\\<forall>i'<m.\n         \\<forall>j'<m.\n            d\\<mu> fs' i' j' =\n            (if (i', j') \\<in> I\n             then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n             else d\\<mu> fs i' j'))\n  insert ij I\n  \\<subseteq> {a. case a of (i, j) \\<Rightarrow> i < m \\<and> j < i}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n        \\<exists>fs'.\n           (lattice_of fs' = L \\<and>\n            map (map_vec (\\<lambda>x. x mod p)) fs' =\n            map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n            map (map_vec (\\<lambda>x. x symmod p)) fs' =\n            map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n            gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n            length fs' = m \\<and>\n            (\\<forall>k<m.\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n            (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n           (\\<forall>i'<m.\n               \\<forall>j'<m.\n                  d\\<mu> fs' i' j' =\n                  (if (i', j') \\<in> F\n                   then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n                   else d\\<mu> fs i' j'));\n        insert x F \\<subseteq> {(i, j). i < m \\<and> j < i}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs'.\n                            (lattice_of fs' = L \\<and>\n                             map (map_vec (\\<lambda>x. x mod p)) fs' =\n                             map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n                             map (map_vec (\\<lambda>x. x symmod p)) fs' =\n                             map (map_vec (\\<lambda>x. x symmod p))\n                              fs \\<and>\n                             gs.lin_indpt_list\n                              (map of_int_hom.vec_hom fs') \\<and>\n                             length fs' = m \\<and>\n                             (\\<forall>k<m.\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs') k =\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs) k) \\<and>\n                             (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n                            (\\<forall>i'<m.\n                                \\<forall>j'<m.\n                                   d\\<mu> fs' i' j' =\n                                   (if (i', j') \\<in> insert x F\n                                    then d\\<mu> fs i' j' symmod\n   (p * d fs j' * d fs (Suc j'))\n                                    else d\\<mu> fs i' j'))", "obtain i j where ij: \"ij = (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j. ij = (i, j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  ij = (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n        \\<exists>fs'.\n           (lattice_of fs' = L \\<and>\n            map (map_vec (\\<lambda>x. x mod p)) fs' =\n            map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n            map (map_vec (\\<lambda>x. x symmod p)) fs' =\n            map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n            gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n            length fs' = m \\<and>\n            (\\<forall>k<m.\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n            (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n           (\\<forall>i'<m.\n               \\<forall>j'<m.\n                  d\\<mu> fs' i' j' =\n                  (if (i', j') \\<in> F\n                   then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n                   else d\\<mu> fs i' j'));\n        insert x F \\<subseteq> {(i, j). i < m \\<and> j < i}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs'.\n                            (lattice_of fs' = L \\<and>\n                             map (map_vec (\\<lambda>x. x mod p)) fs' =\n                             map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n                             map (map_vec (\\<lambda>x. x symmod p)) fs' =\n                             map (map_vec (\\<lambda>x. x symmod p))\n                              fs \\<and>\n                             gs.lin_indpt_list\n                              (map of_int_hom.vec_hom fs') \\<and>\n                             length fs' = m \\<and>\n                             (\\<forall>k<m.\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs') k =\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs) k) \\<and>\n                             (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n                            (\\<forall>i'<m.\n                                \\<forall>j'<m.\n                                   d\\<mu> fs' i' j' =\n                                   (if (i', j') \\<in> insert x F\n                                    then d\\<mu> fs i' j' symmod\n   (p * d fs j' * d fs (Suc j'))\n                                    else d\\<mu> fs i' j'))", "from ij insert(4)"], ["proof (chain)\npicking this:\n  ij = (i, j)\n  insert ij I\n  \\<subseteq> {a. case a of (i, j) \\<Rightarrow> i < m \\<and> j < i}", "have i: \"i < m\" \"j < i\""], ["proof (prove)\nusing this:\n  ij = (i, j)\n  insert ij I\n  \\<subseteq> {a. case a of (i, j) \\<Rightarrow> i < m \\<and> j < i}\n\ngoal (1 subgoal):\n 1. i < m &&& j < i", "by auto"], ["proof (state)\nthis:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n        \\<exists>fs'.\n           (lattice_of fs' = L \\<and>\n            map (map_vec (\\<lambda>x. x mod p)) fs' =\n            map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n            map (map_vec (\\<lambda>x. x symmod p)) fs' =\n            map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n            gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n            length fs' = m \\<and>\n            (\\<forall>k<m.\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n            (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n           (\\<forall>i'<m.\n               \\<forall>j'<m.\n                  d\\<mu> fs' i' j' =\n                  (if (i', j') \\<in> F\n                   then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n                   else d\\<mu> fs i' j'));\n        insert x F \\<subseteq> {(i, j). i < m \\<and> j < i}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs'.\n                            (lattice_of fs' = L \\<and>\n                             map (map_vec (\\<lambda>x. x mod p)) fs' =\n                             map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n                             map (map_vec (\\<lambda>x. x symmod p)) fs' =\n                             map (map_vec (\\<lambda>x. x symmod p))\n                              fs \\<and>\n                             gs.lin_indpt_list\n                              (map of_int_hom.vec_hom fs') \\<and>\n                             length fs' = m \\<and>\n                             (\\<forall>k<m.\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs') k =\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs) k) \\<and>\n                             (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n                            (\\<forall>i'<m.\n                                \\<forall>j'<m.\n                                   d\\<mu> fs' i' j' =\n                                   (if (i', j') \\<in> insert x F\n                                    then d\\<mu> fs i' j' symmod\n   (p * d fs j' * d fs (Suc j'))\n                                    else d\\<mu> fs i' j'))", "from insert(3,4)"], ["proof (chain)\npicking this:\n  I \\<subseteq> {a. case a of\n                    (i, j) \\<Rightarrow>\n                      i < m \\<and> j < i} \\<Longrightarrow>\n  \\<exists>fs'.\n     (lattice_of fs' = L \\<and>\n      map (map_vec (\\<lambda>x. x mod p)) fs' =\n      map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n      map (map_vec (\\<lambda>x. x symmod p)) fs' =\n      map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n      gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n      length fs' = m \\<and>\n      (\\<forall>k<m.\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n      (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n     (\\<forall>i'<m.\n         \\<forall>j'<m.\n            d\\<mu> fs' i' j' =\n            (if (i', j') \\<in> I\n             then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n             else d\\<mu> fs i' j'))\n  insert ij I\n  \\<subseteq> {a. case a of (i, j) \\<Rightarrow> i < m \\<and> j < i}", "obtain gs where gs: \"?prop fs gs\" \n      and exp: \"\\<And> i' j'. i' < m \\<Longrightarrow> j' < m \\<Longrightarrow> ?exp gs I i' j'\""], ["proof (prove)\nusing this:\n  I \\<subseteq> {a. case a of\n                    (i, j) \\<Rightarrow>\n                      i < m \\<and> j < i} \\<Longrightarrow>\n  \\<exists>fs'.\n     (lattice_of fs' = L \\<and>\n      map (map_vec (\\<lambda>x. x mod p)) fs' =\n      map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n      map (map_vec (\\<lambda>x. x symmod p)) fs' =\n      map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n      gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n      length fs' = m \\<and>\n      (\\<forall>k<m.\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n      (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n     (\\<forall>i'<m.\n         \\<forall>j'<m.\n            d\\<mu> fs' i' j' =\n            (if (i', j') \\<in> I\n             then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n             else d\\<mu> fs i' j'))\n  insert ij I\n  \\<subseteq> {a. case a of (i, j) \\<Rightarrow> i < m \\<and> j < i}\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>lattice_of gs = L \\<and>\n                 map (map_vec (\\<lambda>x. x mod p)) gs =\n                 map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n                 map (map_vec (\\<lambda>x. x symmod p)) gs =\n                 map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n                 gs.lin_indpt_list (map of_int_hom.vec_hom gs) \\<and>\n                 length gs = m \\<and>\n                 (\\<forall>k<m.\n                     gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs) k =\n                     gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                      k) \\<and>\n                 (\\<forall>k\\<le>m. d gs k = d fs k);\n         \\<And>i' j'.\n            \\<lbrakk>i' < m; j' < m\\<rbrakk>\n            \\<Longrightarrow> d\\<mu> gs i' j' =\n                              (if (i', j') \\<in> I\n                               then d\\<mu> fs i' j' symmod\n                                    (p * d fs j' * d fs (Suc j'))\n                               else d\\<mu> fs i' j')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lattice_of gs = L \\<and>\n  map (map_vec (\\<lambda>x. x mod p)) gs =\n  map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n  map (map_vec (\\<lambda>x. x symmod p)) gs =\n  map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n  gs.lin_indpt_list (map of_int_hom.vec_hom gs) \\<and>\n  length gs = m \\<and>\n  (\\<forall>k<m.\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs) k =\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n  (\\<forall>k\\<le>m. d gs k = d fs k)\n  \\<lbrakk>?i'1 < m; ?j'1 < m\\<rbrakk>\n  \\<Longrightarrow> d\\<mu> gs ?i'1 ?j'1 =\n                    (if (?i'1, ?j'1) \\<in> I\n                     then d\\<mu> fs ?i'1 ?j'1 symmod\n                          (p * d fs ?j'1 * d fs (Suc ?j'1))\n                     else d\\<mu> fs ?i'1 ?j'1)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n        \\<exists>fs'.\n           (lattice_of fs' = L \\<and>\n            map (map_vec (\\<lambda>x. x mod p)) fs' =\n            map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n            map (map_vec (\\<lambda>x. x symmod p)) fs' =\n            map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n            gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n            length fs' = m \\<and>\n            (\\<forall>k<m.\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n            (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n           (\\<forall>i'<m.\n               \\<forall>j'<m.\n                  d\\<mu> fs' i' j' =\n                  (if (i', j') \\<in> F\n                   then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n                   else d\\<mu> fs i' j'));\n        insert x F \\<subseteq> {(i, j). i < m \\<and> j < i}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs'.\n                            (lattice_of fs' = L \\<and>\n                             map (map_vec (\\<lambda>x. x mod p)) fs' =\n                             map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n                             map (map_vec (\\<lambda>x. x symmod p)) fs' =\n                             map (map_vec (\\<lambda>x. x symmod p))\n                              fs \\<and>\n                             gs.lin_indpt_list\n                              (map of_int_hom.vec_hom fs') \\<and>\n                             length fs' = m \\<and>\n                             (\\<forall>k<m.\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs') k =\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs) k) \\<and>\n                             (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n                            (\\<forall>i'<m.\n                                \\<forall>j'<m.\n                                   d\\<mu> fs' i' j' =\n                                   (if (i', j') \\<in> insert x F\n                                    then d\\<mu> fs i' j' symmod\n   (p * d fs j' * d fs (Suc j'))\n                                    else d\\<mu> fs i' j'))", "from gs"], ["proof (chain)\npicking this:\n  lattice_of gs = L \\<and>\n  map (map_vec (\\<lambda>x. x mod p)) gs =\n  map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n  map (map_vec (\\<lambda>x. x symmod p)) gs =\n  map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n  gs.lin_indpt_list (map of_int_hom.vec_hom gs) \\<and>\n  length gs = m \\<and>\n  (\\<forall>k<m.\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs) k =\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n  (\\<forall>k\\<le>m. d gs k = d fs k)", "have \"lin_indep gs\" \"lattice_of gs = L\" \"length gs = m\""], ["proof (prove)\nusing this:\n  lattice_of gs = L \\<and>\n  map (map_vec (\\<lambda>x. x mod p)) gs =\n  map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n  map (map_vec (\\<lambda>x. x symmod p)) gs =\n  map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n  gs.lin_indpt_list (map of_int_hom.vec_hom gs) \\<and>\n  length gs = m \\<and>\n  (\\<forall>k<m.\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs) k =\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n  (\\<forall>k\\<le>m. d gs k = d fs k)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs) &&&\n    lattice_of gs = L &&& length gs = m", "by auto"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom gs)\n  lattice_of gs = L\n  length gs = m\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n        \\<exists>fs'.\n           (lattice_of fs' = L \\<and>\n            map (map_vec (\\<lambda>x. x mod p)) fs' =\n            map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n            map (map_vec (\\<lambda>x. x symmod p)) fs' =\n            map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n            gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n            length fs' = m \\<and>\n            (\\<forall>k<m.\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n            (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n           (\\<forall>i'<m.\n               \\<forall>j'<m.\n                  d\\<mu> fs' i' j' =\n                  (if (i', j') \\<in> F\n                   then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n                   else d\\<mu> fs i' j'));\n        insert x F \\<subseteq> {(i, j). i < m \\<and> j < i}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs'.\n                            (lattice_of fs' = L \\<and>\n                             map (map_vec (\\<lambda>x. x mod p)) fs' =\n                             map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n                             map (map_vec (\\<lambda>x. x symmod p)) fs' =\n                             map (map_vec (\\<lambda>x. x symmod p))\n                              fs \\<and>\n                             gs.lin_indpt_list\n                              (map of_int_hom.vec_hom fs') \\<and>\n                             length fs' = m \\<and>\n                             (\\<forall>k<m.\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs') k =\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs) k) \\<and>\n                             (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n                            (\\<forall>i'<m.\n                                \\<forall>j'<m.\n                                   d\\<mu> fs' i' j' =\n                                   (if (i', j') \\<in> insert x F\n                                    then d\\<mu> fs i' j' symmod\n   (p * d fs j' * d fs (Suc j'))\n                                    else d\\<mu> fs i' j'))", "from mod_single_element[OF this(1,3) i this(2), of p]"], ["proof (chain)\npicking this:\n  0 < p \\<Longrightarrow>\n  \\<exists>fs'.\n     lattice_of fs' = L \\<and>\n     map (map_vec (\\<lambda>x. x mod p)) fs' =\n     map (map_vec (\\<lambda>x. x mod p)) gs \\<and>\n     map (map_vec (\\<lambda>x. x symmod p)) fs' =\n     map (map_vec (\\<lambda>x. x symmod p)) gs \\<and>\n     gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n     length fs' = m \\<and>\n     (\\<forall>k<m.\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs) k) \\<and>\n     (\\<forall>k\\<le>m. d fs' k = d gs k) \\<and>\n     (\\<forall>i'<m.\n         \\<forall>j'<m.\n            d\\<mu> fs' i' j' =\n            (if (i', j') = (i, j)\n             then d\\<mu> gs i j' symmod (p * d gs j' * d gs (Suc j'))\n             else d\\<mu> gs i' j'))", "obtain hs where hs: \"?prop gs hs\" \n      and exp': \"\\<And> i' j'. i' < m \\<Longrightarrow> j' < m \\<Longrightarrow> \n      d\\<mu> hs i' j' = (if (i', j') = (i, j) \n         then d\\<mu> gs i j' symmod (p * d gs j' * d gs (Suc j')) else d\\<mu> gs i' j')\""], ["proof (prove)\nusing this:\n  0 < p \\<Longrightarrow>\n  \\<exists>fs'.\n     lattice_of fs' = L \\<and>\n     map (map_vec (\\<lambda>x. x mod p)) fs' =\n     map (map_vec (\\<lambda>x. x mod p)) gs \\<and>\n     map (map_vec (\\<lambda>x. x symmod p)) fs' =\n     map (map_vec (\\<lambda>x. x symmod p)) gs \\<and>\n     gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n     length fs' = m \\<and>\n     (\\<forall>k<m.\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs) k) \\<and>\n     (\\<forall>k\\<le>m. d fs' k = d gs k) \\<and>\n     (\\<forall>i'<m.\n         \\<forall>j'<m.\n            d\\<mu> fs' i' j' =\n            (if (i', j') = (i, j)\n             then d\\<mu> gs i j' symmod (p * d gs j' * d gs (Suc j'))\n             else d\\<mu> gs i' j'))\n\ngoal (1 subgoal):\n 1. (\\<And>hs.\n        \\<lbrakk>lattice_of hs = L \\<and>\n                 map (map_vec (\\<lambda>x. x mod p)) hs =\n                 map (map_vec (\\<lambda>x. x mod p)) gs \\<and>\n                 map (map_vec (\\<lambda>x. x symmod p)) hs =\n                 map (map_vec (\\<lambda>x. x symmod p)) gs \\<and>\n                 gs.lin_indpt_list (map of_int_hom.vec_hom hs) \\<and>\n                 length hs = m \\<and>\n                 (\\<forall>k<m.\n                     gram_schmidt_fs.gso n (map of_int_hom.vec_hom hs) k =\n                     gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs)\n                      k) \\<and>\n                 (\\<forall>k\\<le>m. d hs k = d gs k);\n         \\<And>i' j'.\n            \\<lbrakk>i' < m; j' < m\\<rbrakk>\n            \\<Longrightarrow> d\\<mu> hs i' j' =\n                              (if (i', j') = (i, j)\n                               then d\\<mu> gs i j' symmod\n                                    (p * d gs j' * d gs (Suc j'))\n                               else d\\<mu> gs i' j')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pgtz"], ["proof (prove)\nusing this:\n  0 < p \\<Longrightarrow>\n  \\<exists>fs'.\n     lattice_of fs' = L \\<and>\n     map (map_vec (\\<lambda>x. x mod p)) fs' =\n     map (map_vec (\\<lambda>x. x mod p)) gs \\<and>\n     map (map_vec (\\<lambda>x. x symmod p)) fs' =\n     map (map_vec (\\<lambda>x. x symmod p)) gs \\<and>\n     gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n     length fs' = m \\<and>\n     (\\<forall>k<m.\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs) k) \\<and>\n     (\\<forall>k\\<le>m. d fs' k = d gs k) \\<and>\n     (\\<forall>i'<m.\n         \\<forall>j'<m.\n            d\\<mu> fs' i' j' =\n            (if (i', j') = (i, j)\n             then d\\<mu> gs i j' symmod (p * d gs j' * d gs (Suc j'))\n             else d\\<mu> gs i' j'))\n  0 < p\n\ngoal (1 subgoal):\n 1. (\\<And>hs.\n        \\<lbrakk>lattice_of hs = L \\<and>\n                 map (map_vec (\\<lambda>x. x mod p)) hs =\n                 map (map_vec (\\<lambda>x. x mod p)) gs \\<and>\n                 map (map_vec (\\<lambda>x. x symmod p)) hs =\n                 map (map_vec (\\<lambda>x. x symmod p)) gs \\<and>\n                 gs.lin_indpt_list (map of_int_hom.vec_hom hs) \\<and>\n                 length hs = m \\<and>\n                 (\\<forall>k<m.\n                     gram_schmidt_fs.gso n (map of_int_hom.vec_hom hs) k =\n                     gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs)\n                      k) \\<and>\n                 (\\<forall>k\\<le>m. d hs k = d gs k);\n         \\<And>i' j'.\n            \\<lbrakk>i' < m; j' < m\\<rbrakk>\n            \\<Longrightarrow> d\\<mu> hs i' j' =\n                              (if (i', j') = (i, j)\n                               then d\\<mu> gs i j' symmod\n                                    (p * d gs j' * d gs (Suc j'))\n                               else d\\<mu> gs i' j')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lattice_of hs = L \\<and>\n  map (map_vec (\\<lambda>x. x mod p)) hs =\n  map (map_vec (\\<lambda>x. x mod p)) gs \\<and>\n  map (map_vec (\\<lambda>x. x symmod p)) hs =\n  map (map_vec (\\<lambda>x. x symmod p)) gs \\<and>\n  gs.lin_indpt_list (map of_int_hom.vec_hom hs) \\<and>\n  length hs = m \\<and>\n  (\\<forall>k<m.\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom hs) k =\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs) k) \\<and>\n  (\\<forall>k\\<le>m. d hs k = d gs k)\n  \\<lbrakk>?i'1 < m; ?j'1 < m\\<rbrakk>\n  \\<Longrightarrow> d\\<mu> hs ?i'1 ?j'1 =\n                    (if (?i'1, ?j'1) = (i, j)\n                     then d\\<mu> gs i ?j'1 symmod\n                          (p * d gs ?j'1 * d gs (Suc ?j'1))\n                     else d\\<mu> gs ?i'1 ?j'1)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n        \\<exists>fs'.\n           (lattice_of fs' = L \\<and>\n            map (map_vec (\\<lambda>x. x mod p)) fs' =\n            map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n            map (map_vec (\\<lambda>x. x symmod p)) fs' =\n            map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n            gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n            length fs' = m \\<and>\n            (\\<forall>k<m.\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n            (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n           (\\<forall>i'<m.\n               \\<forall>j'<m.\n                  d\\<mu> fs' i' j' =\n                  (if (i', j') \\<in> F\n                   then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n                   else d\\<mu> fs i' j'));\n        insert x F \\<subseteq> {(i, j). i < m \\<and> j < i}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs'.\n                            (lattice_of fs' = L \\<and>\n                             map (map_vec (\\<lambda>x. x mod p)) fs' =\n                             map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n                             map (map_vec (\\<lambda>x. x symmod p)) fs' =\n                             map (map_vec (\\<lambda>x. x symmod p))\n                              fs \\<and>\n                             gs.lin_indpt_list\n                              (map of_int_hom.vec_hom fs') \\<and>\n                             length fs' = m \\<and>\n                             (\\<forall>k<m.\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs') k =\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs) k) \\<and>\n                             (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n                            (\\<forall>i'<m.\n                                \\<forall>j'<m.\n                                   d\\<mu> fs' i' j' =\n                                   (if (i', j') \\<in> insert x F\n                                    then d\\<mu> fs i' j' symmod\n   (p * d fs j' * d fs (Suc j'))\n                                    else d\\<mu> fs i' j'))", "from gs i"], ["proof (chain)\npicking this:\n  lattice_of gs = L \\<and>\n  map (map_vec (\\<lambda>x. x mod p)) gs =\n  map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n  map (map_vec (\\<lambda>x. x symmod p)) gs =\n  map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n  gs.lin_indpt_list (map of_int_hom.vec_hom gs) \\<and>\n  length gs = m \\<and>\n  (\\<forall>k<m.\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs) k =\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n  (\\<forall>k\\<le>m. d gs k = d fs k)\n  i < m\n  j < i", "have id: \"d gs j = d fs j\" \"d gs (Suc j) = d fs (Suc j)\""], ["proof (prove)\nusing this:\n  lattice_of gs = L \\<and>\n  map (map_vec (\\<lambda>x. x mod p)) gs =\n  map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n  map (map_vec (\\<lambda>x. x symmod p)) gs =\n  map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n  gs.lin_indpt_list (map of_int_hom.vec_hom gs) \\<and>\n  length gs = m \\<and>\n  (\\<forall>k<m.\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs) k =\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n  (\\<forall>k\\<le>m. d gs k = d fs k)\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. d gs j = d fs j &&& d gs (Suc j) = d fs (Suc j)", "by auto"], ["proof (state)\nthis:\n  d gs j = d fs j\n  d gs (Suc j) = d fs (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> {(i, j). i < m \\<and> j < i} \\<Longrightarrow>\n        \\<exists>fs'.\n           (lattice_of fs' = L \\<and>\n            map (map_vec (\\<lambda>x. x mod p)) fs' =\n            map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n            map (map_vec (\\<lambda>x. x symmod p)) fs' =\n            map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n            gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n            length fs' = m \\<and>\n            (\\<forall>k<m.\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n                gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n            (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n           (\\<forall>i'<m.\n               \\<forall>j'<m.\n                  d\\<mu> fs' i' j' =\n                  (if (i', j') \\<in> F\n                   then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n                   else d\\<mu> fs i' j'));\n        insert x F \\<subseteq> {(i, j). i < m \\<and> j < i}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs'.\n                            (lattice_of fs' = L \\<and>\n                             map (map_vec (\\<lambda>x. x mod p)) fs' =\n                             map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n                             map (map_vec (\\<lambda>x. x symmod p)) fs' =\n                             map (map_vec (\\<lambda>x. x symmod p))\n                              fs \\<and>\n                             gs.lin_indpt_list\n                              (map of_int_hom.vec_hom fs') \\<and>\n                             length fs' = m \\<and>\n                             (\\<forall>k<m.\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs') k =\n                                 gram_schmidt_fs.gso n\n                                  (map of_int_hom.vec_hom fs) k) \\<and>\n                             (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n                            (\\<forall>i'<m.\n                                \\<forall>j'<m.\n                                   d\\<mu> fs' i' j' =\n                                   (if (i', j') \\<in> insert x F\n                                    then d\\<mu> fs i' j' symmod\n   (p * d fs j' * d fs (Suc j'))\n                                    else d\\<mu> fs i' j'))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       (lattice_of fs' = L \\<and>\n        map (map_vec (\\<lambda>x. x mod p)) fs' =\n        map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n        map (map_vec (\\<lambda>x. x symmod p)) fs' =\n        map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n        gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n        length fs' = m \\<and>\n        (\\<forall>k<m.\n            gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n            gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n        (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') \\<in> insert ij I\n               then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "proof (intro exI[of _ hs], rule conjI; (intro allI impI)?)"], ["proof (state)\ngoal (2 subgoals):\n 1. lattice_of hs = L \\<and>\n    map (map_vec (\\<lambda>x. x mod p)) hs =\n    map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n    map (map_vec (\\<lambda>x. x symmod p)) hs =\n    map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n    gs.lin_indpt_list (map of_int_hom.vec_hom hs) \\<and>\n    length hs = m \\<and>\n    (\\<forall>k<m.\n        gram_schmidt_fs.gso n (map of_int_hom.vec_hom hs) k =\n        gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n    (\\<forall>k\\<le>m. d hs k = d fs k)\n 2. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> hs i' j' =\n                         (if (i', j') \\<in> insert ij I\n                          then d\\<mu> fs i' j' symmod\n                               (p * d fs j' * d fs (Suc j'))\n                          else d\\<mu> fs i' j')", "show \"?prop fs hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of hs = L \\<and>\n    map (map_vec (\\<lambda>x. x mod p)) hs =\n    map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n    map (map_vec (\\<lambda>x. x symmod p)) hs =\n    map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n    gs.lin_indpt_list (map of_int_hom.vec_hom hs) \\<and>\n    length hs = m \\<and>\n    (\\<forall>k<m.\n        gram_schmidt_fs.gso n (map of_int_hom.vec_hom hs) k =\n        gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n    (\\<forall>k\\<le>m. d hs k = d fs k)", "using gs hs"], ["proof (prove)\nusing this:\n  lattice_of gs = L \\<and>\n  map (map_vec (\\<lambda>x. x mod p)) gs =\n  map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n  map (map_vec (\\<lambda>x. x symmod p)) gs =\n  map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n  gs.lin_indpt_list (map of_int_hom.vec_hom gs) \\<and>\n  length gs = m \\<and>\n  (\\<forall>k<m.\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs) k =\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n  (\\<forall>k\\<le>m. d gs k = d fs k)\n  lattice_of hs = L \\<and>\n  map (map_vec (\\<lambda>x. x mod p)) hs =\n  map (map_vec (\\<lambda>x. x mod p)) gs \\<and>\n  map (map_vec (\\<lambda>x. x symmod p)) hs =\n  map (map_vec (\\<lambda>x. x symmod p)) gs \\<and>\n  gs.lin_indpt_list (map of_int_hom.vec_hom hs) \\<and>\n  length hs = m \\<and>\n  (\\<forall>k<m.\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom hs) k =\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom gs) k) \\<and>\n  (\\<forall>k\\<le>m. d hs k = d gs k)\n\ngoal (1 subgoal):\n 1. lattice_of hs = L \\<and>\n    map (map_vec (\\<lambda>x. x mod p)) hs =\n    map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n    map (map_vec (\\<lambda>x. x symmod p)) hs =\n    map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n    gs.lin_indpt_list (map of_int_hom.vec_hom hs) \\<and>\n    length hs = m \\<and>\n    (\\<forall>k<m.\n        gram_schmidt_fs.gso n (map of_int_hom.vec_hom hs) k =\n        gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n    (\\<forall>k\\<le>m. d hs k = d fs k)", "by auto"], ["proof (state)\nthis:\n  lattice_of hs = L \\<and>\n  map (map_vec (\\<lambda>x. x mod p)) hs =\n  map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n  map (map_vec (\\<lambda>x. x symmod p)) hs =\n  map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n  gs.lin_indpt_list (map of_int_hom.vec_hom hs) \\<and>\n  length hs = m \\<and>\n  (\\<forall>k<m.\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom hs) k =\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n  (\\<forall>k\\<le>m. d hs k = d fs k)\n\ngoal (1 subgoal):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> hs i' j' =\n                         (if (i', j') \\<in> insert ij I\n                          then d\\<mu> fs i' j' symmod\n                               (p * d fs j' * d fs (Suc j'))\n                          else d\\<mu> fs i' j')", "fix i' j'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> hs i' j' =\n                         (if (i', j') \\<in> insert ij I\n                          then d\\<mu> fs i' j' symmod\n                               (p * d fs j' * d fs (Suc j'))\n                          else d\\<mu> fs i' j')", "assume *: \"i' < m\" \"j' < m\""], ["proof (state)\nthis:\n  i' < m\n  j' < m\n\ngoal (1 subgoal):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> hs i' j' =\n                         (if (i', j') \\<in> insert ij I\n                          then d\\<mu> fs i' j' symmod\n                               (p * d fs j' * d fs (Suc j'))\n                          else d\\<mu> fs i' j')", "show \"?exp hs (insert ij I) i' j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> hs i' j' =\n    (if (i', j') \\<in> insert ij I\n     then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n     else d\\<mu> fs i' j')", "unfolding exp'[OF *] ij"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (i', j') = (i, j)\n     then d\\<mu> gs i j' symmod (p * d gs j' * d gs (Suc j'))\n     else d\\<mu> gs i' j') =\n    (if (i', j') \\<in> insert (i, j) I\n     then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n     else d\\<mu> fs i' j')", "using exp * i"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i'1 < m; ?j'1 < m\\<rbrakk>\n  \\<Longrightarrow> d\\<mu> gs ?i'1 ?j'1 =\n                    (if (?i'1, ?j'1) \\<in> I\n                     then d\\<mu> fs ?i'1 ?j'1 symmod\n                          (p * d fs ?j'1 * d fs (Suc ?j'1))\n                     else d\\<mu> fs ?i'1 ?j'1)\n  i' < m\n  j' < m\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. (if (i', j') = (i, j)\n     then d\\<mu> gs i j' symmod (p * d gs j' * d gs (Suc j'))\n     else d\\<mu> gs i' j') =\n    (if (i', j') \\<in> insert (i, j) I\n     then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n     else d\\<mu> fs i' j')", "by (auto simp: id)"], ["proof (state)\nthis:\n  d\\<mu> hs i' j' =\n  (if (i', j') \\<in> insert ij I\n   then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n   else d\\<mu> fs i' j')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>fs'.\n     (lattice_of fs' = L \\<and>\n      map (map_vec (\\<lambda>x. x mod p)) fs' =\n      map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n      map (map_vec (\\<lambda>x. x symmod p)) fs' =\n      map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n      gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n      length fs' = m \\<and>\n      (\\<forall>k<m.\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n      (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n     (\\<forall>i'<m.\n         \\<forall>j'<m.\n            d\\<mu> fs' i' j' =\n            (if (i', j') \\<in> insert ij I\n             then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n             else d\\<mu> fs i' j'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>fs'.\n     (lattice_of fs' = L \\<and>\n      map (map_vec (\\<lambda>x. x mod p)) fs' =\n      map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n      map (map_vec (\\<lambda>x. x symmod p)) fs' =\n      map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n      gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n      length fs' = m \\<and>\n      (\\<forall>k<m.\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n      (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n     (\\<forall>i'<m.\n         \\<forall>j'<m.\n            d\\<mu> fs' i' j' =\n            (if (i', j') \\<in> I\n             then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n             else d\\<mu> fs i' j'))\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') \\<in> I\n               then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>fs'.\n     (lattice_of fs' = L \\<and>\n      map (map_vec (\\<lambda>x. x mod p)) fs' =\n      map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n      map (map_vec (\\<lambda>x. x symmod p)) fs' =\n      map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n      gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n      length fs' = m \\<and>\n      (\\<forall>k<m.\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n          gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n      (\\<forall>k\\<le>m. d fs' k = d fs k)) \\<and>\n     (\\<forall>i'<m.\n         \\<forall>j'<m.\n            d\\<mu> fs' i' j' =\n            (if (i', j') \\<in> I\n             then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n             else d\\<mu> fs i' j'))\n\ngoal (1 subgoal):\n 1. \\<exists>fs'.\n       lattice_of fs' = L \\<and>\n       map (map_vec (\\<lambda>x. x mod p)) fs' =\n       map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n       map (map_vec (\\<lambda>x. x symmod p)) fs' =\n       map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n       gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n       length fs' = m \\<and>\n       (\\<forall>k<m.\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n       (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n       (\\<forall>i'<m.\n           \\<forall>j'<m.\n              d\\<mu> fs' i' j' =\n              (if (i', j') \\<in> I\n               then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n               else d\\<mu> fs i' j'))", "by auto"], ["proof (state)\nthis:\n  \\<exists>fs'.\n     lattice_of fs' = L \\<and>\n     map (map_vec (\\<lambda>x. x mod p)) fs' =\n     map (map_vec (\\<lambda>x. x mod p)) fs \\<and>\n     map (map_vec (\\<lambda>x. x symmod p)) fs' =\n     map (map_vec (\\<lambda>x. x symmod p)) fs \\<and>\n     gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n     length fs' = m \\<and>\n     (\\<forall>k<m.\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k) \\<and>\n     (\\<forall>k\\<le>m. d fs' k = d fs k) \\<and>\n     (\\<forall>i'<m.\n         \\<forall>j'<m.\n            d\\<mu> fs' i' j' =\n            (if (i', j') \\<in> I\n             then d\\<mu> fs i' j' symmod (p * d fs j' * d fs (Suc j'))\n             else d\\<mu> fs i' j'))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}