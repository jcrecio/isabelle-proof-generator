{"file_name": "/home/qj213/afp-2021-10-22/thys/Statecharts/Update.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Statecharts", "problem_names": ["lemma Update_EmptySet: \n \"(% d. d) \\<in> { L | L. Update L}\"", "lemma Update_select:\n   \"Update (Rep_update U)\"", "lemma DataSpace_DataSpace_Update [simp]:\n   \"Data.DataSpace (Rep_update U DP) = Data.DataSpace DP\"", "lemma Update_DefaultUpdate [simp]:\n   \"Update (\\<lambda> D. D)\"", "lemma update_DefaultUpdate [simp]:\n   \"(\\<lambda> D. D) \\<in> update\"", "lemma DataSpace_UpdateApply [simp]:\n   \"Data.DataSpace (U !!! D) = Data.DataSpace D\"", "lemma PUpdate_EmptySet:\n \"(% d. Data2PData d) \\<in> { L | L. PUpdate L}\"", "lemma PUpdate_select:\n   \"PUpdate (Rep_pupdate U)\"", "lemma DataSpace_PDataSpace_PUpdate [simp]:\n   \"PDataSpace (Rep_pupdate U DP) = Data.DataSpace DP\"", "lemma  PUpdate_Data2PData [simp]: \n   \"PUpdate Data2PData\"", "lemma pupdate_Data2PData  [simp]:\n   \"Data2PData \\<in> pupdate\"", "lemma PUpdate_DefaultPUpdate [simp]:\n   \"PUpdate (\\<lambda> D. DefaultPData (Data.DataSpace D))\"", "lemma pupdate_DefaultPUpdate [simp]:\n   \"(\\<lambda> D. DefaultPData (Data.DataSpace D)) \\<in> pupdate\"", "lemma DefaultPUpdate_None [simp]:\n    \"(DefaultPUpdate !! D) = DefaultPData (DataSpace D)\"", "lemma FoldSet_imp_finite:\n  \"FoldSet h z A x \\<Longrightarrow> finite A\"", "lemma finite_imp_FoldSet:\n  \"finite A \\<Longrightarrow> \\<exists> x. FoldSet h z A x\"", "lemma finite_SequentialRacing:\n   \"finite US \\<Longrightarrow> (SOME u. u \\<in> SequentialRacing US) \\<in> SequentialRacing US\""], "translations": [["", "lemma Update_EmptySet: \n \"(% d. d) \\<in> { L | L. Update L}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>d. d) \\<in> {L |L. Update L}", "by (unfold Update_def, auto)"], ["", "definition\n  \"update = { L | (L::(('d data) => ('d data))). Update L}\""], ["", "typedef 'd update = \"update :: ('d data => 'd data) set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> update", "unfolding update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {L |L. Update L}", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ?x \\<in> {L |L. Update L}", "apply (rule Update_EmptySet)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n UpdateApply :: \"['d update, 'd data] => 'd data\" (\"(_ !!!/ _)\" [10,11]10) where\n \"UpdateApply U D == Rep_update U D\""], ["", "definition\n  DefaultUpdate :: \"('d update)\" where\n \"DefaultUpdate ==  Abs_update (\\<lambda> D. D)\""], ["", "subsubsection \\<open>Basic lemmas\\<close>"], ["", "lemma Update_select:\n   \"Update (Rep_update U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Update (Rep_update U)", "apply (cut_tac x=U in Rep_update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_update U \\<in> update \\<Longrightarrow> Update (Rep_update U)", "apply (unfold update_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_update U \\<in> {L |L. Update L} \\<Longrightarrow>\n    Update (Rep_update U)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma DataSpace_DataSpace_Update [simp]:\n   \"Data.DataSpace (Rep_update U DP) = Data.DataSpace DP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data.DataSpace (Rep_update U DP) = Data.DataSpace DP", "apply (cut_tac U=U in Update_select)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Update (Rep_update U) \\<Longrightarrow>\n    Data.DataSpace (Rep_update U DP) = Data.DataSpace DP", "apply (unfold Update_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d.\n       Data.DataSpace d = Data.DataSpace (Rep_update U d) \\<Longrightarrow>\n    Data.DataSpace (Rep_update U DP) = Data.DataSpace DP", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>\\<open>DefaultUpdate\\<close>\\<close>"], ["", "lemma Update_DefaultUpdate [simp]:\n   \"Update (\\<lambda> D. D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Update (\\<lambda>D. D)", "by (unfold Update_def, auto)"], ["", "lemma update_DefaultUpdate [simp]:\n   \"(\\<lambda> D. D) \\<in> update\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>D. D) \\<in> update", "by (unfold update_def, auto)"], ["", "lemma DataSpace_UpdateApply [simp]:\n   \"Data.DataSpace (U !!! D) = Data.DataSpace D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data.DataSpace (U !!! D) = Data.DataSpace D", "by (unfold UpdateApply_def, auto)"], ["", "subsection \\<open>Partial update-functions\\<close>"], ["", "definition\n  PUpdate :: \"(('d data) => ('d pdata)) => bool\" where\n  \"PUpdate U = (\\<forall> d. Data.DataSpace d = PDataSpace (U d))\""], ["", "lemma PUpdate_EmptySet:\n \"(% d. Data2PData d) \\<in> { L | L. PUpdate L}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data2PData \\<in> {L |L. PUpdate L}", "by (unfold PUpdate_def, auto)"], ["", "definition \"pupdate = { L | (L::(('d data) => ('d pdata))). PUpdate L}\""], ["", "typedef 'd pupdate = \"pupdate :: ('d data => 'd pdata) set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> pupdate", "unfolding pupdate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {L |L. PUpdate L}", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ?x \\<in> {L |L. PUpdate L}", "apply (rule PUpdate_EmptySet)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n PUpdateApply :: \"['d pupdate, 'd data] => 'd pdata\" (\"(_ !!/ _)\" [10,11]10) where\n \"PUpdateApply U D = Rep_pupdate U D\""], ["", "definition\n  DefaultPUpdate :: \"('d pupdate)\" where\n \"DefaultPUpdate = Abs_pupdate (\\<lambda> D. DefaultPData (Data.DataSpace D))\""], ["", "subsubsection \\<open>Basic lemmas\\<close>"], ["", "lemma PUpdate_select:\n   \"PUpdate (Rep_pupdate U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PUpdate (Rep_pupdate U)", "apply (cut_tac x=U in Rep_pupdate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_pupdate U \\<in> pupdate \\<Longrightarrow> PUpdate (Rep_pupdate U)", "apply (unfold pupdate_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_pupdate U \\<in> {L |L. PUpdate L} \\<Longrightarrow>\n    PUpdate (Rep_pupdate U)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma DataSpace_PDataSpace_PUpdate [simp]:\n   \"PDataSpace (Rep_pupdate U DP) = Data.DataSpace DP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDataSpace (Rep_pupdate U DP) = Data.DataSpace DP", "apply (cut_tac U=U in PUpdate_select)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PUpdate (Rep_pupdate U) \\<Longrightarrow>\n    PDataSpace (Rep_pupdate U DP) = Data.DataSpace DP", "apply (unfold PUpdate_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d.\n       Data.DataSpace d = PDataSpace (Rep_pupdate U d) \\<Longrightarrow>\n    PDataSpace (Rep_pupdate U DP) = Data.DataSpace DP", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>\\<open>Data2PData\\<close>\\<close>"], ["", "lemma  PUpdate_Data2PData [simp]: \n   \"PUpdate Data2PData\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PUpdate Data2PData", "by (unfold PUpdate_def, auto)"], ["", "lemma pupdate_Data2PData  [simp]:\n   \"Data2PData \\<in> pupdate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data2PData \\<in> pupdate", "by (unfold pupdate_def, auto)"], ["", "subsubsection \\<open>\\<open>PUpdate\\<close>\\<close>"], ["", "lemma PUpdate_DefaultPUpdate [simp]:\n   \"PUpdate (\\<lambda> D. DefaultPData (Data.DataSpace D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PUpdate (\\<lambda>D. DefaultPData (Data.DataSpace D))", "apply (unfold PUpdate_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d.\n       Data.DataSpace d = PDataSpace (DefaultPData (Data.DataSpace d))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pupdate_DefaultPUpdate [simp]:\n   \"(\\<lambda> D. DefaultPData (Data.DataSpace D)) \\<in> pupdate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>D. DefaultPData (Data.DataSpace D)) \\<in> pupdate", "apply (unfold pupdate_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>D. DefaultPData (Data.DataSpace D)) \\<in> {L |L. PUpdate L}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma DefaultPUpdate_None [simp]:\n    \"(DefaultPUpdate !! D) = DefaultPData (DataSpace D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (DefaultPUpdate !! D) = DefaultPData (Data.DataSpace D)", "apply (unfold DefaultPUpdate_def PUpdateApply_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_pupdate (Abs_pupdate (\\<lambda>D. DefaultPData (Data.DataSpace D)))\n     D =\n    DefaultPData (Data.DataSpace D)", "apply (subst Abs_pupdate_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>D. DefaultPData (Data.DataSpace D)) \\<in> pupdate\n 2. DefaultPData (Data.DataSpace D) = DefaultPData (Data.DataSpace D)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>\\<open>SequentialRacing\\<close>\\<close>"], ["", "definition\n UpdateOverride :: \"['d pupdate, 'd update] => \n                     'd update\" (\"(_ [U+]/ _)\" [10,11]10) where\n \"UpdateOverride U P = Abs_update (\\<lambda> DA . (U !! DA) [D+] (P !!! DA))\""], ["", "(* -------------------------------------------------------------- *)\n(* We use our own FoldSet operator simular to the definition      *)\n(* of Isabelle 2002. Note, it is different to the definition      *)\n(* in Isabelle 2009. Basically we express \"f (g x)\" by \"h x\"      *)\n(* -------------------------------------------------------------- *)"], ["", "inductive\n  FoldSet :: \"('b => 'a => 'a) => 'a => 'b set => 'a => bool\"\n  for h ::  \"'b => 'a => 'a\"\n  and z :: 'a\nwhere\n  emptyI [intro]: \"FoldSet h z {} z\"\n| insertI [intro]:\n     \"\\<lbrakk> x \\<notin> A; FoldSet h z A y \\<rbrakk>\n      \\<Longrightarrow> FoldSet h z (insert x A) (h x y)\""], ["", "definition\nSequentialRacing :: \"('d pupdate set) => ('d update set)\" where\n \"SequentialRacing U = \n     {u. FoldSet UpdateOverride DefaultUpdate U u}\""], ["", "lemma FoldSet_imp_finite:\n  \"FoldSet h z A x \\<Longrightarrow> finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FoldSet h z A x \\<Longrightarrow> finite A", "by (induct set: FoldSet) auto"], ["", "lemma finite_imp_FoldSet:\n  \"finite A \\<Longrightarrow> \\<exists> x. FoldSet h z A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> \\<exists>x. FoldSet h z A x", "by (induct set: finite) auto"], ["", "lemma finite_SequentialRacing:\n   \"finite US \\<Longrightarrow> (SOME u. u \\<in> SequentialRacing US) \\<in> SequentialRacing US\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite US \\<Longrightarrow>\n    (SOME u. u \\<in> SequentialRacing US) \\<in> SequentialRacing US", "apply (unfold SequentialRacing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite US \\<Longrightarrow>\n    (SOME u. u \\<in> Collect (FoldSet UpdateOverride DefaultUpdate US))\n    \\<in> Collect (FoldSet UpdateOverride DefaultUpdate US)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite US \\<Longrightarrow>\n    FoldSet UpdateOverride DefaultUpdate US\n     (Eps (FoldSet UpdateOverride DefaultUpdate US))", "apply (drule_tac h=UpdateOverride and z=DefaultUpdate in finite_imp_FoldSet)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. FoldSet UpdateOverride DefaultUpdate US x \\<Longrightarrow>\n    FoldSet UpdateOverride DefaultUpdate US\n     (Eps (FoldSet UpdateOverride DefaultUpdate US))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       FoldSet UpdateOverride DefaultUpdate US x \\<Longrightarrow>\n       FoldSet UpdateOverride DefaultUpdate US\n        (Eps (FoldSet UpdateOverride DefaultUpdate US))", "apply (rule someI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       FoldSet UpdateOverride DefaultUpdate US x \\<Longrightarrow>\n       FoldSet UpdateOverride DefaultUpdate US (?x4 x)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}