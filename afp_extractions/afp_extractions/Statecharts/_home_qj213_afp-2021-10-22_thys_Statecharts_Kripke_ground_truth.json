{"file_name": "/home/qj213/afp-2021-10-22/thys/Statecharts/Kripke.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Statecharts", "problem_names": ["lemma Kripke_EmptySet:\n \"({@x. True}, {@x. True},{(@x. True, @x. True)}, Map.empty(@x. True \\<mapsto> {@x. True})) \\<in> \n   {(S,S0,R,L) | S S0 R L. Kripke S S0 R L}\""], "translations": [["", "lemma Kripke_EmptySet:\n \"({@x. True}, {@x. True},{(@x. True, @x. True)}, Map.empty(@x. True \\<mapsto> {@x. True})) \\<in> \n   {(S,S0,R,L) | S S0 R L. Kripke S S0 R L}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({SOME x. True}, {SOME x. True}, {(SOME x. True, SOME x. True)},\n     [SOME x. True \\<mapsto> {SOME x. True}])\n    \\<in> {(S, S0, R, L) |S S0 R L. Kripke S S0 R L}", "by (unfold Kripke_def Domain_unfold, auto)"], ["", "definition\n  \"kripke =\n    {(S,S0,T,L) |\n        (S::('s set))\n        (S0::('s set))\n        (T::(('s * 's) set))\n        (L::('s \\<rightharpoonup> ('a  set))).\n                      Kripke S S0 T L}\""], ["", "typedef ('s,'a) kripke =\n    \"kripke :: ('s set * 's set * ('s * 's) set * ('s \\<rightharpoonup> 'a set)) set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> kripke", "unfolding kripke_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {(S, S0, T, L) |S S0 T L. Kripke S S0 T L}", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ?x \\<in> {(S, S0, T, L) |S S0 T L. Kripke S S0 T L}", "apply (rule Kripke_EmptySet)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  Statuses :: \"('s,'a) kripke => 's set\" where\n  \"Statuses = fst o Rep_kripke\""], ["", "definition\n   InitStatuses :: \"('s,'a) kripke  => 's set\" where\n  \"InitStatuses == fst o snd o Rep_kripke\""], ["", "definition\n   StepRel :: \"('s,'a) kripke => ('s * 's) set\" where\n  \"StepRel == fst o snd o snd o Rep_kripke\""], ["", "definition\n   LabelFun :: \"('s,'a) kripke => ('s \\<rightharpoonup> 'a set)\" where\n  \"LabelFun == snd o snd o snd o Rep_kripke\""], ["", "definition\n   Paths :: \"[('s,'a) kripke, 's] =>\n             (nat => 's) set\" where\n  \"Paths M S == { p . S = p (0::nat) \\<and> (\\<forall>i. (p i, p (i+1)) \\<in> (StepRel M))}\""], ["", "datatype ('s,'a) ctl =  Atom \"'a\"\n                          | AND \"('s,'a) ctl\" \"('s,'a) ctl\"\n                          | OR  \"('s,'a) ctl\" \"('s,'a) ctl\"\n                          | IMPLIES \"('s,'a) ctl\" \"('s,'a) ctl\"\n                          | CAX \"('s,'a) ctl\"\n                          | AF  \"('s,'a) ctl\"\n                          | AG  \"('s,'a) ctl\"\n                          | AU  \"('s,'a) ctl\" \"('s,'a) ctl\"\n                          | AR  \"('s,'a) ctl\" \"('s,'a) ctl\""], ["", "primrec\n   eval_ctl :: \"[('s,'a) kripke, 's, ('s,'a) ctl] => bool\"  (\"_,_ |=c= _\" [92,91,90]90) \n   where\n     \"(M,S |=c= (Atom P))        = (P \\<in> the ((LabelFun M) S))\"\n   | \"(M,S |=c= (AND F1 F2))     = ((M,S |=c= F1) \\<and> (M,S |=c= F2))\"\n   | \"(M,S |=c= (OR F1 F2))      = ((M,S |=c= F1) \\<or> (M,S |=c= F2))\"\n   | \"(M,S |=c= (IMPLIES F1 F2)) = ((M,S |=c= F1) \\<longrightarrow> (M,S |=c= F2))\"\n   | \"(M,S |=c= (CAX F))         = (\\<forall> T. (S,T) \\<in> (StepRel M) \\<longrightarrow> (M,T |=c= F))\"\n   | \"(M,S |=c= (AF F))          = (\\<forall> P \\<in> Paths M S. \\<exists> i. (M,(P i) |=c= F))\"\n   | \"(M,S |=c= (AG F))          = (\\<forall> P \\<in> Paths M S. \\<forall> i. (M,(P i) |=c= F))\"\n   | \"(M,S |=c= (AU F G))        = (\\<forall> P \\<in> Paths M S.\n                                     \\<exists> i. (M,(P i) |=c= G) \\<and> \n                                       (\\<forall> j. j < i \\<longrightarrow> (M,(P j) |=c= F)))\"\n   | \"(M,S |=c= (AR F G))        = (\\<forall> P \\<in> Paths M S.\n                                     \\<forall> i. (M,(P i) |=c= G) \\<or> \n                                       (\\<exists> j. j < i \\<and> (M,(P j) |=c= F)))\""], ["", "end"]]}