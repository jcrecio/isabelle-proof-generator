{"file_name": "/home/qj213/afp-2021-10-22/thys/Stream_Fusion_Code/Stream_Fusion_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stream_Fusion_Code", "problem_names": ["lemma map_option_mono [partial_function_mono]: (* To be moved to HOL *)\n  \"mono_option f \\<Longrightarrow> mono_option (\\<lambda>x. map_option g (f x))\"", "lemma terminatesI [intro?]:\n  \"(\\<And>s. s \\<in> terminates_on g) \\<Longrightarrow> terminates g\"", "lemma terminatesD:\n  \"terminates g \\<Longrightarrow> s \\<in> terminates_on g\"", "lemma terminates_on_stop:\n  \"terminates_on (\\<lambda>_. Done) = UNIV\"", "lemma wf_terminates:\n  assumes \"wf R\"\n  and skip: \"\\<And>s s'. g s = Skip s' \\<Longrightarrow> (s',s) \\<in> R\"\n  and yield: \"\\<And>s s' a. g s = Yield a s' \\<Longrightarrow> (s',s) \\<in> R\"\n  shows \"terminates g\"", "lemma terminates_on_conv_dom_terminates_within:\n  \"terminates_on g = dom terminates_within\"", "lemma terminates_wfE:\n  assumes \"terminates g\"\n  obtains R \n  where \"wf R\"\n    \"\\<And>s s'. (g s = Skip s') \\<Longrightarrow> (s',s) \\<in> R\"\n    \"\\<And>s a s'. (g s = Yield a s') \\<Longrightarrow> (s',s) \\<in> R\"", "lemma unstream_simps [simp]:\n  \"generator g s = Done \\<Longrightarrow> unstream s = []\"\n  \"generator g s = Skip s' \\<Longrightarrow> unstream s = unstream s'\"\n  \"generator g s = Yield x s' \\<Longrightarrow> unstream s = x # unstream s'\"", "lemma force_simps [simp]:\n  \"generator g s = Done \\<Longrightarrow> force s = None\"\n  \"generator g s = Skip s' \\<Longrightarrow> force s = force s'\"\n  \"generator g s = Yield x s' \\<Longrightarrow> force s = Some (x, s')\"", "lemma unstream_force_None [simp]: \"force s = None \\<Longrightarrow> unstream s = []\"", "lemma unstream_force_Some [simp]: \"force s = Some (x, s') \\<Longrightarrow> unstream s = x # unstream s'\"", "lemma terminates_stream_raw: \"terminates stream_raw\"", "lemma unstream_stream: \"unstream stream xs = xs\"", "lemma terminates_replicate_raw: \"terminates (replicate_raw a)\"", "lemma unstream_replicate_prod [stream_fusion]: \"unstream (replicate_prod x) n = replicate n x\"", "lemma terminates_upt_raw: \"terminates (upt_raw n)\"", "lemma unstream_upt_prod [stream_fusion]: \"unstream (upt_prod n) m = upt m n\"", "lemma terminates_upto_raw: \"terminates (upto_raw n)\"", "lemma unstream_upto_prod [stream_fusion]: \"unstream (upto_prod n) m = upto m n\"", "lemma generator_Nil_prod: \"generator Nil_prod = (\\<lambda>_. Done)\"", "lemma unstream_Nil_prod [stream_fusion]: \"unstream Nil_prod () = []\"", "lemma nth_cons_code [code]:\n  \"nth_cons s n =\n  (case generator g s of Done => undefined n\n    | Skip s' => nth_cons s' n\n    | Yield x s' => (case n of 0 => x | Suc n' => nth_cons s' n'))\"", "lemma length_cons_code [code]:\n  \"length_cons s =\n    (case generator g s of\n      Done \\<Rightarrow> 0\n    | Skip s' \\<Rightarrow> length_cons s'\n    | Yield a s' \\<Rightarrow> 1 + length_cons s')\"", "lemma gen_length_cons_code [code]:\n  \"gen_length_cons n s = (case generator g s of\n     Done \\<Rightarrow> n | Skip s' \\<Rightarrow> gen_length_cons n s' | Yield a s' \\<Rightarrow> gen_length_cons (Suc n) s')\"", "lemma unstream_gen_length [stream_fusion]: \"gen_length_cons 0 s = length (unstream g s)\"", "lemma unstream_gen_length2 [stream_fusion]: \"gen_length_cons n s = List.gen_length n (unstream g s)\"", "lemma foldr_cons_code [code]:\n  \"foldr_cons s =\n    (case generator g s of\n      Done \\<Rightarrow> z\n    | Skip s' \\<Rightarrow> foldr_cons s'\n    | Yield a s' \\<Rightarrow> f a (foldr_cons s'))\"", "lemma foldl_cons_code [code]:\n  \"foldl_cons z s =\n    (case generator g s of\n      Done \\<Rightarrow> z\n    | Skip s' \\<Rightarrow> foldl_cons z s'\n    | Yield a s' \\<Rightarrow> foldl_cons (f z a) s')\"", "lemma fold_cons_code [code]:\n  \"fold_cons z s =\n    (case generator g s of\n      Done \\<Rightarrow> z\n    | Skip s' \\<Rightarrow> fold_cons z s'\n    | Yield a s' \\<Rightarrow> fold_cons (f a z) s')\"", "lemma null_cons_code [code]:\n  \"null_cons g s = (case generator g s of Done \\<Rightarrow> True | Skip s' \\<Rightarrow> null_cons g s' | Yield _ _ \\<Rightarrow> False)\"", "lemma hd_cons_code [code]:\n  \"hd_cons s =\n    (case generator g s of\n      Done \\<Rightarrow> undefined\n    | Skip s' \\<Rightarrow> hd_cons s'\n    | Yield a s' \\<Rightarrow> a)\"", "lemma last_cons_code [code]:\n  \"last_cons x s =\n  (case generator g s of Done \\<Rightarrow> the x\n             | Skip s' \\<Rightarrow> last_cons x s'\n             | Yield a s' \\<Rightarrow> last_cons (Some a) s')\"", "lemma unstream_last_cons [stream_fusion]: \"last_cons None s = last (unstream g s)\"", "lemma sum_list_cons_code [code]:\n  \"sum_list_cons s =\n    (case generator g s of\n      Done \\<Rightarrow> 0\n    | Skip s' \\<Rightarrow> sum_list_cons s'\n    | Yield a s' \\<Rightarrow> a + sum_list_cons s')\"", "lemma list_all2_cons_code [code]:\n  \"list_all2_cons sg sh = \n  (case generator g sg of\n     Done \\<Rightarrow> null_cons h sh\n   | Skip sg' \\<Rightarrow> list_all2_cons sg' sh\n   | Yield a sg' \\<Rightarrow> list_all2_cons1 a sg' sh)\"", "lemma list_all2_cons1_code [code]:\n  \"list_all2_cons1 x sg' sh = \n  (case generator h sh of\n     Done \\<Rightarrow> False\n   | Skip sh' \\<Rightarrow> list_all2_cons1 x sg' sh'\n   | Yield y sh' \\<Rightarrow> P x y \\<and> list_all2_cons sg' sh')\"", "lemma list_all_cons_code [code]:\n  \"list_all_cons s \\<longleftrightarrow>\n  (case generator g s of\n    Done \\<Rightarrow> True | Skip s' \\<Rightarrow> list_all_cons s' | Yield x s' \\<Rightarrow> P x \\<and> list_all_cons s')\"", "lemma lexord_fusion_code:\n  \"lexord_fusion g1 g2 s1 s2 \\<longleftrightarrow>\n  (case generator g1 s1 of\n     Done \\<Rightarrow> \\<not> null_cons g2 s2\n   | Skip s1' \\<Rightarrow> lexord_fusion g1 g2 s1' s2\n   | Yield x s1' \\<Rightarrow> \n     (case force g2 s2 of\n        None \\<Rightarrow> False\n      | Some (y, s2') \\<Rightarrow> x < y \\<or> \\<not> y < x \\<and> lexord_fusion g1 g2 s1' s2'))\"", "lemma lexord_eq_fusion_code:\n  \"lexord_eq_fusion g1 g2 s1 s2 \\<longleftrightarrow>\n  (case generator g1 s1 of\n     Done \\<Rightarrow> True\n   | Skip s1' \\<Rightarrow> lexord_eq_fusion g1 g2 s1' s2\n   | Yield x s1' \\<Rightarrow>\n     (case force g2 s2 of\n        None \\<Rightarrow> False\n      | Some (y, s2') \\<Rightarrow> x < y \\<or> \\<not> y < x \\<and> lexord_eq_fusion g1 g2 s1' s2'))\"", "lemmas [code] =\n  lexord_fusion_code ord.lexord_fusion_code\n  lexord_eq_fusion_code ord.lexord_eq_fusion_code", "lemmas [stream_fusion] =\n  lexord_fusion_def ord.lexord_fusion_def\n  lexord_eq_fusion_def ord.lexord_eq_fusion_def", "lemma terminates_map_raw: \n  assumes \"terminates g\"\n  shows \"terminates (map_raw f g)\"", "lemma unstream_map_trans [stream_fusion]: \"unstream (map_trans f g) s = map f (unstream g s)\"", "lemma terminates_drop_raw:\n  assumes \"terminates g\"\n  shows \"terminates (drop_raw g)\"", "lemma unstream_drop_trans [stream_fusion]: \"unstream (drop_trans g) (n, s) = drop n (unstream g s)\"", "lemma terminates_dropWhile_raw:\n  assumes \"terminates g\"\n  shows \"terminates (dropWhile_raw P g)\"", "lemma unstream_dropWhile_trans_False:\n  \"unstream (dropWhile_trans P g) (False, s) = unstream g s\"", "lemma unstream_dropWhile_trans [stream_fusion]:\n  \"unstream (dropWhile_trans P g) (True, s) = dropWhile P (unstream g s)\"", "lemma terminates_take_raw:\n  assumes \"terminates g\"\n  shows \"terminates (take_raw g)\"", "lemma unstream_take_trans [stream_fusion]: \"unstream (take_trans g) (n, s) = take n (unstream g s)\"", "lemma terminates_takeWhile_raw: \n  assumes \"terminates g\"\n  shows \"terminates (takeWhile_raw P g)\"", "lemma unstream_takeWhile_trans [stream_fusion]:\n  \"unstream (takeWhile_trans P g) s = takeWhile P (unstream g s)\"", "lemma terminates_on_append_raw_Inr: \n  assumes \"terminates h\"\n  shows \"Inr sh \\<in> terminates_on (append_raw g h sh_start)\"", "lemma terminates_append_raw:\n  assumes \"terminates g\" \"terminates h\"\n  shows \"terminates (append_raw g h sh_start)\"", "lemma unstream_append_trans_Inr: \"unstream (append_trans g h sh) (Inr sh') = unstream h sh'\"", "lemma unstream_append_trans [stream_fusion]:\n  \"unstream (append_trans g h sh) (Inl sg) = append (unstream g sg) (unstream h sh)\"", "lemma terminates_filter_raw:\n  assumes \"terminates g\"\n  shows \"terminates (filter_raw P g)\"", "lemma unstream_filter_trans [stream_fusion]: \"unstream (filter_trans P g) s = filter P (unstream g s)\"", "lemma terminates_zip_raw: \n  assumes \"terminates g\" \"terminates h\"\n  shows \"terminates (zip_raw g h)\"", "lemma unstream_zip_trans [stream_fusion]:\n  \"unstream (zip_trans g h) (sg, sh, None) = zip (unstream g sg) (unstream h sh)\"", "lemma terminates_tl_raw: \n  assumes \"terminates g\"\n  shows \"terminates (tl_raw g)\"", "lemma unstream_tl_trans_True: \"unstream (tl_trans g) (True, s) = unstream g s\"", "lemma unstream_tl_trans [stream_fusion]: \"unstream (tl_trans g) (False, s) = tl (unstream g s)\"", "lemma terminates_butlast_raw:\n  assumes \"terminates g\"\n  shows \"terminates (butlast_raw g)\"", "lemma unstream_butlast_trans_Some:\n  \"unstream (butlast_trans g) (Some b,s) = butlast (b # (unstream g s))\"", "lemma unstream_butlast_trans [stream_fusion]:\n  \"unstream (butlast_trans g) (None, s) = butlast (unstream g s)\"", "lemma terminates_concat_raw: \n  assumes \"terminates g\"\n  shows \"terminates (concat_raw g)\"", "lemma unstream_concat_trans_gen: \"unstream (concat_trans g) (xs, s) = xs @ (concat (unstream g s))\"", "lemma unstream_concat_trans [stream_fusion]:\n  \"unstream (concat_trans g) ([], s) = concat (unstream g s)\"", "lemma terminates_splice_raw: \n  assumes g: \"terminates g\" and h: \"terminates h\"\n  shows \"terminates (splice_raw g h)\"", "lemma unstream_splice_trans_Right_only: \"unstream (splice_trans g h) (Right_only sh) = unstream h sh\"", "lemma unstream_splice_trans_Left_only: \"unstream (splice_trans g h) (Left_only sg) = unstream g sg\"", "lemma unstream_splice_trans [stream_fusion]:\n  \"unstream (splice_trans g h) (Left sg sh) = splice (unstream g sg) (unstream h sh)\"", "lemma terminates_list_update_raw:\n  assumes \"terminates g\"\n  shows \"terminates (list_update_raw g b)\"", "lemma unstream_lift_update_trans_None: \"unstream (list_update_trans g b) (0, s) = unstream g s\"", "lemma unstream_list_update_trans [stream_fusion]:\n  \"unstream (list_update_trans g b) (Suc n, s) = list_update (unstream g s) n b\"", "lemma terminates_removeAll_raw:\n  assumes \"terminates g\"\n  shows \"terminates (removeAll_raw b g)\"", "lemma unstream_removeAll_trans [stream_fusion]:\n  \"unstream (removeAll_trans b g) s = removeAll b (unstream g s)\"", "lemma terminates_remove1_raw: \n  assumes \"terminates g\"\n  shows \"terminates (remove1_raw b g)\"", "lemma unstream_remove1_trans_False: \"unstream (remove1_trans b g) (False, s) = unstream g s\"", "lemma unstream_remove1_trans [stream_fusion]:\n  \"unstream (remove1_trans b g) (True, s) = remove1 b (unstream g s)\"", "lemma terminates_Cons_raw: \n  assumes \"terminates g\"\n  shows \"terminates (Cons_raw x g)\"", "lemma unstream_Cons_trans_False: \"unstream (Cons_trans x g) (False, s) = unstream g s\"", "lemma unstream_Cons_trans: \"unstream (Cons_trans x g) (True, s) = x # unstream g s\"", "lemma terminates_on_maps_raw_Some: \n  assumes \"(s, None) \\<in> terminates_on (maps_raw f g)\"\n  shows \"(s, Some (g'', s'')) \\<in> terminates_on (maps_raw f g)\"", "lemma terminates_maps_raw: \n  assumes \"terminates g\"\n  shows \"terminates (maps_raw f g)\"", "lemma unstream_maps_trans_Some:\n  \"unstream (maps_trans f g) (s, Some (g'', s'')) = unstream g'' s'' @ unstream (maps_trans f g) (s, None)\"", "lemma unstream_maps_trans:\n  \"unstream (maps_trans f g) (s, None) = List.maps (case_prod unstream \\<circ> f) (unstream g s)\"", "lemma terminates_fix_gen_raw:\n  assumes \"\\<And>x. terminates (g x)\"\n  shows \"terminates (fix_gen_raw g)\"", "lemma unstream_fix_gen: \"unstream (fix_gen g) (a, s) = unstream (g a) s\"", "lemma terminates_flatten_raw: \n  assumes \"terminates g''\" \"terminates g\"\n  shows \"terminates flatten_raw\"", "lemma unstream_flatten_Some:\n  \"unstream (flatten f g'' g) (s, Some s') = unstream g'' s' @ unstream (flatten f g'' g) (s, None)\"", "lemma unstream_flatten_fix_gen [stream_fusion]:\n  \"unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (s, None) =\n   List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g s)\"", "lemma unstream_flatten [stream_fusion]:\n  \"unstream (flatten f g'' g) (s, None) = List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g s)\""], "translations": [["", "lemma map_option_mono [partial_function_mono]: (* To be moved to HOL *)\n  \"mono_option f \\<Longrightarrow> mono_option (\\<lambda>x. map_option g (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option.le_fun option_ord f \\<Longrightarrow>\n    monotone option.le_fun option_ord (\\<lambda>x. map_option g (f x))", "apply (rule monotoneI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>monotone option.le_fun option_ord f;\n        option.le_fun x y\\<rbrakk>\n       \\<Longrightarrow> option_ord (map_option g (f x))\n                          (map_option g (f y))", "apply (drule (1) monotoneD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>option.le_fun x y; option_ord (f x) (f y)\\<rbrakk>\n       \\<Longrightarrow> option_ord (map_option g (f x))\n                          (map_option g (f y))", "apply (auto simp add: flat_ord_def split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>The type of generators for finite lists\\<close>"], ["", "datatype ('a, 's) step = Done | is_Skip: Skip 's | is_Yield: Yield 'a 's"], ["", "type_synonym ('a, 's) raw_generator = \"'s \\<Rightarrow> ('a,'s) step\""], ["", "text \\<open>\n  Raw generators may not end in @{const Done}, but may lead to infinitely many @{const Yield}s \n  in a row. Such generators cannot be converted to finite lists, because it corresponds to an\n  infinite list. Therefore, we introduce the type of generators that always end in @{const Done}\n  after finitely many steps.\n\\<close>"], ["", "inductive_set terminates_on :: \"('a, 's) raw_generator \\<Rightarrow> 's set\"\n  for g :: \"('a, 's) raw_generator\"\nwhere\n  stop: \"g s = Done \\<Longrightarrow> s \\<in> terminates_on g\"\n| pause: \"\\<lbrakk> g s = Skip s'; s' \\<in> terminates_on g \\<rbrakk> \\<Longrightarrow> s \\<in> terminates_on g\"\n| unfold: \"\\<lbrakk> g s = Yield a s'; s' \\<in> terminates_on g \\<rbrakk> \\<Longrightarrow> s \\<in> terminates_on g\""], ["", "definition terminates :: \"('a, 's) raw_generator \\<Rightarrow> bool\"\nwhere \"terminates g \\<longleftrightarrow> (terminates_on g = UNIV)\""], ["", "lemma terminatesI [intro?]:\n  \"(\\<And>s. s \\<in> terminates_on g) \\<Longrightarrow> terminates g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. s \\<in> terminates_on g) \\<Longrightarrow> terminates g", "by (auto simp add: terminates_def)"], ["", "lemma terminatesD:\n  \"terminates g \\<Longrightarrow> s \\<in> terminates_on g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates g \\<Longrightarrow> s \\<in> terminates_on g", "by (auto simp add: terminates_def)"], ["", "lemma terminates_on_stop:\n  \"terminates_on (\\<lambda>_. Done) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates_on (\\<lambda>_. Done) = UNIV", "by (auto intro: terminates_on.stop)"], ["", "lemma wf_terminates:\n  assumes \"wf R\"\n  and skip: \"\\<And>s s'. g s = Skip s' \\<Longrightarrow> (s',s) \\<in> R\"\n  and yield: \"\\<And>s s' a. g s = Yield a s' \\<Longrightarrow> (s',s) \\<in> R\"\n  shows \"terminates g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates g", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on g", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on g", "from \\<open>wf R\\<close>"], ["proof (chain)\npicking this:\n  wf R", "show \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  wf R\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "proof (induction rule: wf_induct [rule_format, consumes 1, case_names wf])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> R \\<Longrightarrow>\n           y \\<in> terminates_on g) \\<Longrightarrow>\n       x \\<in> terminates_on g", "case (wf s)"], ["proof (state)\nthis:\n  (?y, s) \\<in> R \\<Longrightarrow> ?y \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> R \\<Longrightarrow>\n           y \\<in> terminates_on g) \\<Longrightarrow>\n       x \\<in> terminates_on g", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "proof (cases \"g s\")"], ["proof (state)\ngoal (3 subgoals):\n 1. g s = Done \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x2. g s = Skip x2 \\<Longrightarrow> s \\<in> terminates_on g\n 3. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "case (Skip s')"], ["proof (state)\nthis:\n  g s = Skip s'\n\ngoal (3 subgoals):\n 1. g s = Done \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x2. g s = Skip x2 \\<Longrightarrow> s \\<in> terminates_on g\n 3. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "hence \"(s', s) \\<in> R\""], ["proof (prove)\nusing this:\n  g s = Skip s'\n\ngoal (1 subgoal):\n 1. (s', s) \\<in> R", "by (rule skip)"], ["proof (state)\nthis:\n  (s', s) \\<in> R\n\ngoal (3 subgoals):\n 1. g s = Done \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x2. g s = Skip x2 \\<Longrightarrow> s \\<in> terminates_on g\n 3. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "hence \"s' \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  (s', s) \\<in> R\n\ngoal (1 subgoal):\n 1. s' \\<in> terminates_on g", "by (rule wf.IH)"], ["proof (state)\nthis:\n  s' \\<in> terminates_on g\n\ngoal (3 subgoals):\n 1. g s = Done \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x2. g s = Skip x2 \\<Longrightarrow> s \\<in> terminates_on g\n 3. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "with Skip"], ["proof (chain)\npicking this:\n  g s = Skip s'\n  s' \\<in> terminates_on g", "show ?thesis"], ["proof (prove)\nusing this:\n  g s = Skip s'\n  s' \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (rule terminates_on.pause)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (2 subgoals):\n 1. g s = Done \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. g s = Done \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "case (Yield a s')"], ["proof (state)\nthis:\n  g s = Yield a s'\n\ngoal (2 subgoals):\n 1. g s = Done \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "hence \"(s', s) \\<in> R\""], ["proof (prove)\nusing this:\n  g s = Yield a s'\n\ngoal (1 subgoal):\n 1. (s', s) \\<in> R", "by (rule yield)"], ["proof (state)\nthis:\n  (s', s) \\<in> R\n\ngoal (2 subgoals):\n 1. g s = Done \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "hence \"s' \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  (s', s) \\<in> R\n\ngoal (1 subgoal):\n 1. s' \\<in> terminates_on g", "by (rule wf.IH)"], ["proof (state)\nthis:\n  s' \\<in> terminates_on g\n\ngoal (2 subgoals):\n 1. g s = Done \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "with Yield"], ["proof (chain)\npicking this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g", "show ?thesis"], ["proof (prove)\nusing this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (rule terminates_on.unfold)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. g s = Done \\<Longrightarrow> s \\<in> terminates_on g", "qed (rule terminates_on.stop)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal:\nNo subgoals!", "qed"], ["", "context fixes g :: \"('a, 's) raw_generator\" begin"], ["", "partial_function (option) terminates_within :: \"'s \\<Rightarrow> nat option\" where\n  \"terminates_within s = (case g s of\n     Done \\<Rightarrow> Some 0\n  | Skip s' \\<Rightarrow> map_option (\\<lambda>n. n + 1) (terminates_within s')\n  | Yield a s' \\<Rightarrow> map_option (\\<lambda>n. n + 1) (terminates_within s'))\""], ["", "lemma terminates_on_conv_dom_terminates_within:\n  \"terminates_on g = dom terminates_within\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates_on g = dom local.terminates_within", "proof (rule set_eqI iffI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> terminates_on g \\<Longrightarrow>\n       x \\<in> dom local.terminates_within\n 2. \\<And>x.\n       x \\<in> dom local.terminates_within \\<Longrightarrow>\n       x \\<in> terminates_on g", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> terminates_on g \\<Longrightarrow>\n       x \\<in> dom local.terminates_within\n 2. \\<And>x.\n       x \\<in> dom local.terminates_within \\<Longrightarrow>\n       x \\<in> terminates_on g", "assume \"s \\<in> terminates_on g\""], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> terminates_on g \\<Longrightarrow>\n       x \\<in> dom local.terminates_within\n 2. \\<And>x.\n       x \\<in> dom local.terminates_within \\<Longrightarrow>\n       x \\<in> terminates_on g", "hence \"\\<exists>n. terminates_within s = Some n\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<exists>n. local.terminates_within s = Some n", "by induction (subst terminates_within.simps, simp add: split_beta)+"], ["proof (state)\nthis:\n  \\<exists>n. local.terminates_within s = Some n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> terminates_on g \\<Longrightarrow>\n       x \\<in> dom local.terminates_within\n 2. \\<And>x.\n       x \\<in> dom local.terminates_within \\<Longrightarrow>\n       x \\<in> terminates_on g", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. local.terminates_within s = Some n", "show \"s \\<in> dom terminates_within\""], ["proof (prove)\nusing this:\n  \\<exists>n. local.terminates_within s = Some n\n\ngoal (1 subgoal):\n 1. s \\<in> dom local.terminates_within", "by blast"], ["proof (state)\nthis:\n  s \\<in> dom local.terminates_within\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dom local.terminates_within \\<Longrightarrow>\n       x \\<in> terminates_on g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dom local.terminates_within \\<Longrightarrow>\n       x \\<in> terminates_on g", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dom local.terminates_within \\<Longrightarrow>\n       x \\<in> terminates_on g", "assume \"s \\<in> dom terminates_within\""], ["proof (state)\nthis:\n  s \\<in> dom local.terminates_within\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dom local.terminates_within \\<Longrightarrow>\n       x \\<in> terminates_on g", "then"], ["proof (chain)\npicking this:\n  s \\<in> dom local.terminates_within", "obtain n where \"terminates_within s = Some n\""], ["proof (prove)\nusing this:\n  s \\<in> dom local.terminates_within\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        local.terminates_within s = Some n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  local.terminates_within s = Some n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dom local.terminates_within \\<Longrightarrow>\n       x \\<in> terminates_on g", "then"], ["proof (chain)\npicking this:\n  local.terminates_within s = Some n", "show \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  local.terminates_within s = Some n\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "proof (induction rule: terminates_within.raw_induct[rotated 1, consumes 1])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>terminates_within s sa.\n       \\<lbrakk>\\<And>x y.\n                   terminates_within x = Some y \\<Longrightarrow>\n                   x \\<in> terminates_on g;\n        (case g s of Done \\<Rightarrow> Some 0\n         | Skip s' \\<Rightarrow>\n             map_option (\\<lambda>n. n + 1) (terminates_within s')\n         | Yield a s' \\<Rightarrow>\n             map_option (\\<lambda>n. n + 1) (terminates_within s')) =\n        Some sa\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on g", "case (1 terminates_within s s')"], ["proof (state)\nthis:\n  terminates_within ?x = Some ?y \\<Longrightarrow> ?x \\<in> terminates_on g\n  (case g s of Done \\<Rightarrow> Some 0\n   | Skip s' \\<Rightarrow>\n       map_option (\\<lambda>n. n + 1) (terminates_within s')\n   | Yield a s' \\<Rightarrow>\n       map_option (\\<lambda>n. n + 1) (terminates_within s')) =\n  Some s'\n\ngoal (1 subgoal):\n 1. \\<And>terminates_within s sa.\n       \\<lbrakk>\\<And>x y.\n                   terminates_within x = Some y \\<Longrightarrow>\n                   x \\<in> terminates_on g;\n        (case g s of Done \\<Rightarrow> Some 0\n         | Skip s' \\<Rightarrow>\n             map_option (\\<lambda>n. n + 1) (terminates_within s')\n         | Yield a s' \\<Rightarrow>\n             map_option (\\<lambda>n. n + 1) (terminates_within s')) =\n        Some sa\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on g", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "proof(cases \"g s\")"], ["proof (state)\ngoal (3 subgoals):\n 1. g s = Done \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x2. g s = Skip x2 \\<Longrightarrow> s \\<in> terminates_on g\n 3. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "case Done"], ["proof (state)\nthis:\n  g s = Done\n\ngoal (3 subgoals):\n 1. g s = Done \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x2. g s = Skip x2 \\<Longrightarrow> s \\<in> terminates_on g\n 3. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "thus ?thesis"], ["proof (prove)\nusing this:\n  g s = Done\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_on.stop)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (2 subgoals):\n 1. \\<And>x2. g s = Skip x2 \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2. g s = Skip x2 \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "case (Skip s')"], ["proof (state)\nthis:\n  g s = Skip s'\n\ngoal (2 subgoals):\n 1. \\<And>x2. g s = Skip x2 \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "hence \"s' \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  g s = Skip s'\n\ngoal (1 subgoal):\n 1. s' \\<in> terminates_on g", "using 1"], ["proof (prove)\nusing this:\n  g s = Skip s'\n  terminates_within ?x = Some ?y \\<Longrightarrow> ?x \\<in> terminates_on g\n  (case g s of Done \\<Rightarrow> Some 0\n   | Skip s' \\<Rightarrow>\n       map_option (\\<lambda>n. n + 1) (terminates_within s')\n   | Yield a s' \\<Rightarrow>\n       map_option (\\<lambda>n. n + 1) (terminates_within s')) =\n  Some s'__\n\ngoal (1 subgoal):\n 1. s' \\<in> terminates_on g", "by(auto)"], ["proof (state)\nthis:\n  s' \\<in> terminates_on g\n\ngoal (2 subgoals):\n 1. \\<And>x2. g s = Skip x2 \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "thus ?thesis"], ["proof (prove)\nusing this:\n  s' \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "using \\<open>g s = Skip s'\\<close>"], ["proof (prove)\nusing this:\n  s' \\<in> terminates_on g\n  g s = Skip s'\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_on.pause)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "case (Yield a s')"], ["proof (state)\nthis:\n  g s = Yield a s'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "hence \"s' \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  g s = Yield a s'\n\ngoal (1 subgoal):\n 1. s' \\<in> terminates_on g", "using 1"], ["proof (prove)\nusing this:\n  g s = Yield a s'\n  terminates_within ?x = Some ?y \\<Longrightarrow> ?x \\<in> terminates_on g\n  (case g s of Done \\<Rightarrow> Some 0\n   | Skip s' \\<Rightarrow>\n       map_option (\\<lambda>n. n + 1) (terminates_within s')\n   | Yield a s' \\<Rightarrow>\n       map_option (\\<lambda>n. n + 1) (terminates_within s')) =\n  Some s'__\n\ngoal (1 subgoal):\n 1. s' \\<in> terminates_on g", "by(auto)"], ["proof (state)\nthis:\n  s' \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       g s = Yield x31 x32 \\<Longrightarrow> s \\<in> terminates_on g", "thus ?thesis"], ["proof (prove)\nusing this:\n  s' \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "using \\<open>g s = Yield a s'\\<close>"], ["proof (prove)\nusing this:\n  s' \\<in> terminates_on g\n  g s = Yield a s'\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (auto intro: terminates_on.unfold)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma terminates_wfE:\n  assumes \"terminates g\"\n  obtains R \n  where \"wf R\"\n    \"\\<And>s s'. (g s = Skip s') \\<Longrightarrow> (s',s) \\<in> R\"\n    \"\\<And>s a s'. (g s = Yield a s') \\<Longrightarrow> (s',s) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?R = \"measure (\\<lambda>s. the (terminates_within g s)) :: ('a \\<times> 'a) set\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"wf ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure (\\<lambda>s. the (terminates_within g s)))", "by simp"], ["proof (state)\nthis:\n  wf (measure (\\<lambda>s. the (terminates_within g s)))\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  wf (measure (\\<lambda>s. the (terminates_within g s)))\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  wf (measure (\\<lambda>s. the (terminates_within g s)))\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix s s'"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"g s = Skip s'\""], ["proof (state)\nthis:\n  g s = Skip s'\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  g s = Skip s'\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s' \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s' \\<in> terminates_on g", "by (rule terminatesD)"], ["proof (state)\nthis:\n  s' \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  s' \\<in> terminates_on g", "obtain n where \"terminates_within g s' = Some n\""], ["proof (prove)\nusing this:\n  s' \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        terminates_within g s' = Some n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding terminates_on_conv_dom_terminates_within"], ["proof (prove)\nusing this:\n  s' \\<in> dom (terminates_within g)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        terminates_within g s' = Some n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto)"], ["proof (state)\nthis:\n  terminates_within g s' = Some n\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  g s = Skip s'\n  terminates_within g s' = Some n", "have \"the (terminates_within g s') < the (terminates_within g s)\""], ["proof (prove)\nusing this:\n  g s = Skip s'\n  terminates_within g s' = Some n\n\ngoal (1 subgoal):\n 1. the (terminates_within g s') < the (terminates_within g s)", "by (simp add: terminates_within.simps)"], ["proof (state)\nthis:\n  the (terminates_within g s') < the (terminates_within g s)\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"(s',s) \\<in> ?R\""], ["proof (prove)\nusing this:\n  the (terminates_within g s') < the (terminates_within g s)\n\ngoal (1 subgoal):\n 1. (s', s) \\<in> measure (\\<lambda>s. the (terminates_within g s))", "by (auto)"], ["proof (state)\nthis:\n  (s', s) \\<in> measure (\\<lambda>s. the (terminates_within g s))\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  g ?s2 = Skip ?s'2 \\<Longrightarrow>\n  (?s'2, ?s2) \\<in> measure (\\<lambda>s. the (terminates_within g s))\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  g ?s2 = Skip ?s'2 \\<Longrightarrow>\n  (?s'2, ?s2) \\<in> measure (\\<lambda>s. the (terminates_within g s))\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  g ?s2 = Skip ?s'2 \\<Longrightarrow>\n  (?s'2, ?s2) \\<in> measure (\\<lambda>s. the (terminates_within g s))\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix s s' a"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume 2: \"g s = Yield a s'\""], ["proof (state)\nthis:\n  g s = Yield a s'\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  g s = Yield a s'\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s' \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s' \\<in> terminates_on g", "by (rule terminatesD)"], ["proof (state)\nthis:\n  s' \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  s' \\<in> terminates_on g", "obtain n where \"terminates_within g s' = Some n\""], ["proof (prove)\nusing this:\n  s' \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        terminates_within g s' = Some n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding terminates_on_conv_dom_terminates_within"], ["proof (prove)\nusing this:\n  s' \\<in> dom (terminates_within g)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        terminates_within g s' = Some n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto)"], ["proof (state)\nthis:\n  terminates_within g s' = Some n\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  g s = Yield a s'\n  terminates_within g s' = Some n", "have \"(s',s) \\<in> ?R\""], ["proof (prove)\nusing this:\n  g s = Yield a s'\n  terminates_within g s' = Some n\n\ngoal (1 subgoal):\n 1. (s', s) \\<in> measure (\\<lambda>s. the (terminates_within g s))", "by simp (subst terminates_within.simps, simp add: split_beta)"], ["proof (state)\nthis:\n  (s', s) \\<in> measure (\\<lambda>s. the (terminates_within g s))\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  g ?s2 = Yield ?a2 ?s'2 \\<Longrightarrow>\n  (?s'2, ?s2) \\<in> measure (\\<lambda>s. the (terminates_within g s))\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s s'. g s = Skip s' \\<Longrightarrow> (s', s) \\<in> R;\n         \\<And>s a s'.\n            g s = Yield a s' \\<Longrightarrow> (s', s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  wf (measure (\\<lambda>s. the (terminates_within g s)))\n  g ?s2 = Skip ?s'2 \\<Longrightarrow>\n  (?s'2, ?s2) \\<in> measure (\\<lambda>s. the (terminates_within g s))\n  g ?s2 = Yield ?a2 ?s'2 \\<Longrightarrow>\n  (?s'2, ?s2) \\<in> measure (\\<lambda>s. the (terminates_within g s))", "show thesis"], ["proof (prove)\nusing this:\n  wf (measure (\\<lambda>s. the (terminates_within g s)))\n  g ?s2 = Skip ?s'2 \\<Longrightarrow>\n  (?s'2, ?s2) \\<in> measure (\\<lambda>s. the (terminates_within g s))\n  g ?s2 = Yield ?a2 ?s'2 \\<Longrightarrow>\n  (?s'2, ?s2) \\<in> measure (\\<lambda>s. the (terminates_within g s))\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "typedef ('a,'s) generator = \"{g :: ('a,'s) raw_generator. terminates g}\"\n  morphisms generator Generator"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {g. terminates g}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {g. terminates g}", "show \"(\\<lambda>_. Done) \\<in> ?generator\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. Done) \\<in> {g. terminates g}", "by (simp add: terminates_on_stop terminates_def)"], ["proof (state)\nthis:\n  (\\<lambda>_. Done) \\<in> {g. terminates g}\n\ngoal:\nNo subgoals!", "qed"], ["", "setup_lifting type_definition_generator"], ["", "subsection \\<open>Conversion to @{typ \"'a list\"}\\<close>"], ["", "context fixes g :: \"('a, 's) generator\" begin"], ["", "function unstream :: \"'s \\<Rightarrow> 'a list\"\nwhere\n  \"unstream s = (case generator g s of\n     Done \\<Rightarrow> []\n   | Skip s' \\<Rightarrow> unstream s'\n   | Yield x s' \\<Rightarrow> x # unstream s')\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>s. x = s \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>s sa.\n       s = sa \\<Longrightarrow>\n       (case generator g s of Done \\<Rightarrow> []\n        | Skip x0 \\<Rightarrow> unstream_sumC x0\n        | Yield x s' \\<Rightarrow> x # unstream_sumC s') =\n       (case generator g sa of Done \\<Rightarrow> []\n        | Skip x0 \\<Rightarrow> unstream_sumC x0\n        | Yield x s' \\<Rightarrow> x # unstream_sumC s')", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.unstream_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All local.unstream_dom", "have \"terminates (generator g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (generator g)", "using generator[of g]"], ["proof (prove)\nusing this:\n  generator g \\<in> {g. terminates g}\n\ngoal (1 subgoal):\n 1. terminates (generator g)", "by simp"], ["proof (state)\nthis:\n  terminates (generator g)\n\ngoal (1 subgoal):\n 1. All local.unstream_dom", "thus ?thesis"], ["proof (prove)\nusing this:\n  terminates (generator g)\n\ngoal (1 subgoal):\n 1. All local.unstream_dom", "by(rule terminates_wfE)(erule \"termination\")"], ["proof (state)\nthis:\n  All local.unstream_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_simps [simp]:\n  \"generator g s = Done \\<Longrightarrow> unstream s = []\"\n  \"generator g s = Skip s' \\<Longrightarrow> unstream s = unstream s'\"\n  \"generator g s = Yield x s' \\<Longrightarrow> unstream s = x # unstream s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (generator g s = Done \\<Longrightarrow> local.unstream s = []) &&&\n    (generator g s = Skip s' \\<Longrightarrow>\n     local.unstream s = local.unstream s') &&&\n    (generator g s = Yield x s' \\<Longrightarrow>\n     local.unstream s = x # local.unstream s')", "by(simp_all)"], ["", "declare unstream.simps[simp del]"], ["", "function force :: \"'s \\<Rightarrow> ('a \\<times> 's) option\"\nwhere\n  \"force s = (case generator g s of Done \\<Rightarrow> None \n     | Skip s' \\<Rightarrow> force s'\n     | Yield x s' \\<Rightarrow> Some (x, s'))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>s. x = s \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>s sa.\n       s = sa \\<Longrightarrow>\n       (case generator g s of Done \\<Rightarrow> None\n        | Skip x0 \\<Rightarrow> force_sumC x0\n        | Yield x s' \\<Rightarrow> Some (x, s')) =\n       (case generator g sa of Done \\<Rightarrow> None\n        | Skip x0 \\<Rightarrow> force_sumC x0\n        | Yield x s' \\<Rightarrow> Some (x, s'))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.force_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All local.force_dom", "have \"terminates (generator g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (generator g)", "using generator[of g]"], ["proof (prove)\nusing this:\n  generator g \\<in> {g. terminates g}\n\ngoal (1 subgoal):\n 1. terminates (generator g)", "by simp"], ["proof (state)\nthis:\n  terminates (generator g)\n\ngoal (1 subgoal):\n 1. All local.force_dom", "thus ?thesis"], ["proof (prove)\nusing this:\n  terminates (generator g)\n\ngoal (1 subgoal):\n 1. All local.force_dom", "by(rule terminates_wfE)(rule \"termination\")"], ["proof (state)\nthis:\n  All local.force_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma force_simps [simp]:\n  \"generator g s = Done \\<Longrightarrow> force s = None\"\n  \"generator g s = Skip s' \\<Longrightarrow> force s = force s'\"\n  \"generator g s = Yield x s' \\<Longrightarrow> force s = Some (x, s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (generator g s = Done \\<Longrightarrow> local.force s = None) &&&\n    (generator g s = Skip s' \\<Longrightarrow>\n     local.force s = local.force s') &&&\n    (generator g s = Yield x s' \\<Longrightarrow>\n     local.force s = Some (x, s'))", "by(simp_all)"], ["", "declare force.simps[simp del]"], ["", "lemma unstream_force_None [simp]: \"force s = None \\<Longrightarrow> unstream s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.force s = None \\<Longrightarrow> local.unstream s = []", "proof(induction s rule: force.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>generator g s = Skip x2;\n                    local.force x2 = None\\<rbrakk>\n                   \\<Longrightarrow> local.unstream x2 = [];\n        local.force s = None\\<rbrakk>\n       \\<Longrightarrow> local.unstream s = []", "case (1 s)"], ["proof (state)\nthis:\n  \\<lbrakk>generator g s = Skip ?x2.0; local.force ?x2.0 = None\\<rbrakk>\n  \\<Longrightarrow> local.unstream ?x2.0 = []\n  local.force s = None\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>generator g s = Skip x2;\n                    local.force x2 = None\\<rbrakk>\n                   \\<Longrightarrow> local.unstream x2 = [];\n        local.force s = None\\<rbrakk>\n       \\<Longrightarrow> local.unstream s = []", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>generator g s = Skip ?x2.0; local.force ?x2.0 = None\\<rbrakk>\n  \\<Longrightarrow> local.unstream ?x2.0 = []\n  local.force s = None\n\ngoal (1 subgoal):\n 1. local.unstream s = []", "by(cases \"generator g s\") simp_all"], ["proof (state)\nthis:\n  local.unstream s = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_force_Some [simp]: \"force s = Some (x, s') \\<Longrightarrow> unstream s = x # unstream s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.force s = Some (x, s') \\<Longrightarrow>\n    local.unstream s = x # local.unstream s'", "proof(induction s rule: force.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>generator g s = Skip x2;\n                    local.force x2 = Some (x, s')\\<rbrakk>\n                   \\<Longrightarrow> local.unstream x2 =\n                                     x # local.unstream s';\n        local.force s = Some (x, s')\\<rbrakk>\n       \\<Longrightarrow> local.unstream s = x # local.unstream s'", "case (1 s)"], ["proof (state)\nthis:\n  \\<lbrakk>generator g s = Skip ?x2.0;\n   local.force ?x2.0 = Some (x, s')\\<rbrakk>\n  \\<Longrightarrow> local.unstream ?x2.0 = x # local.unstream s'\n  local.force s = Some (x, s')\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>generator g s = Skip x2;\n                    local.force x2 = Some (x, s')\\<rbrakk>\n                   \\<Longrightarrow> local.unstream x2 =\n                                     x # local.unstream s';\n        local.force s = Some (x, s')\\<rbrakk>\n       \\<Longrightarrow> local.unstream s = x # local.unstream s'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>generator g s = Skip ?x2.0;\n   local.force ?x2.0 = Some (x, s')\\<rbrakk>\n  \\<Longrightarrow> local.unstream ?x2.0 = x # local.unstream s'\n  local.force s = Some (x, s')\n\ngoal (1 subgoal):\n 1. local.unstream s = x # local.unstream s'", "by(cases \"generator g s\") simp_all"], ["proof (state)\nthis:\n  local.unstream s = x # local.unstream s'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "setup \\<open>Context.theory_map (Stream_Fusion.add_unstream @{const_name unstream})\\<close>"], ["", "subsection \\<open>Producers\\<close>"], ["", "subsubsection \\<open>Conversion to streams\\<close>"], ["", "fun stream_raw :: \"'a list \\<Rightarrow> ('a, 'a list) step\"\nwhere\n  \"stream_raw [] = Done\"\n| \"stream_raw (x # xs) = Yield x xs\""], ["", "lemma terminates_stream_raw: \"terminates stream_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates stream_raw", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on stream_raw", "fix s :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on stream_raw", "show \"s \\<in> terminates_on stream_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> terminates_on stream_raw", "by(induction s)(auto intro: terminates_on.intros)"], ["proof (state)\nthis:\n  s \\<in> terminates_on stream_raw\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition stream :: \"('a, 'a list) generator\" is \"stream_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates stream_raw", "by(rule terminates_stream_raw)"], ["", "lemma unstream_stream: \"unstream stream xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream stream xs = xs", "by(induction xs)(auto simp add: stream.rep_eq)"], ["", "subsubsection \\<open>@{const replicate}\\<close>"], ["", "fun replicate_raw :: \"'a \\<Rightarrow> ('a, nat) raw_generator\"\nwhere\n  \"replicate_raw a 0 = Done\"\n| \"replicate_raw a (Suc n) = Yield a n\""], ["", "lemma terminates_replicate_raw: \"terminates (replicate_raw a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (replicate_raw a)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (replicate_raw a)", "fix s :: \"nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (replicate_raw a)", "show \"s \\<in> terminates_on (replicate_raw a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (replicate_raw a)", "by(induction s)(auto intro: terminates_on.intros)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (replicate_raw a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition replicate_prod :: \"'a \\<Rightarrow> ('a, nat) generator\" is \"replicate_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. terminates (replicate_raw a)", "by(rule terminates_replicate_raw)"], ["", "lemma unstream_replicate_prod [stream_fusion]: \"unstream (replicate_prod x) n = replicate n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (replicate_prod x) n = replicate n x", "by(induction n)(simp_all add: replicate_prod.rep_eq)"], ["", "subsubsection \\<open>@{const upt}\\<close>"], ["", "definition upt_raw :: \"nat \\<Rightarrow> (nat, nat) raw_generator\"\nwhere \"upt_raw n m = (if m \\<ge> n then Done else Yield m (Suc m))\""], ["", "lemma terminates_upt_raw: \"terminates (upt_raw n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (upt_raw n)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (upt_raw n)", "fix s :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (upt_raw n)", "show \"s \\<in> terminates_on (upt_raw n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (upt_raw n)", "by(induction \"n-s\" arbitrary: s rule: nat.induct)(auto 4 3 simp add: upt_raw_def intro: terminates_on.intros)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (upt_raw n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition upt_prod :: \"nat \\<Rightarrow> (nat, nat) generator\" is \"upt_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat. terminates (upt_raw nat)", "by(rule terminates_upt_raw)"], ["", "lemma unstream_upt_prod [stream_fusion]: \"unstream (upt_prod n) m = upt m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (upt_prod n) m = [m..<n]", "by(induction \"n-m\" arbitrary: n m)(simp_all add: upt_prod.rep_eq upt_conv_Cons upt_raw_def unstream.simps)"], ["", "subsubsection \\<open>@{const upto}\\<close>"], ["", "definition upto_raw :: \"int \\<Rightarrow> (int, int) raw_generator\"\nwhere \"upto_raw n m = (if m \\<le> n then Yield m (m + 1) else Done)\""], ["", "lemma terminates_upto_raw: \"terminates (upto_raw n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (upto_raw n)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (upto_raw n)", "fix s :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (upto_raw n)", "show \"s \\<in> terminates_on (upto_raw n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (upto_raw n)", "by(induction \"nat(n-s+1)\" arbitrary: s)(auto 4 3 simp add: upto_raw_def intro: terminates_on.intros)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (upto_raw n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition upto_prod :: \"int \\<Rightarrow> (int, int) generator\" is \"upto_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int. terminates (upto_raw int)", "by (rule terminates_upto_raw)"], ["", "lemma unstream_upto_prod [stream_fusion]: \"unstream (upto_prod n) m = upto m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (upto_prod n) m = [m..n]", "by(induction \"nat (n - m + 1)\" arbitrary: m)(simp_all add: upto_prod.rep_eq upto.simps upto_raw_def)"], ["", "subsubsection \\<open>@{term \"[]\"}\\<close>"], ["", "lift_definition Nil_prod :: \"('a, unit) generator\" is \"\\<lambda>_. Done\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (\\<lambda>_. Done)", "by(auto simp add: terminates_def intro: terminates_on.intros)"], ["", "lemma generator_Nil_prod: \"generator Nil_prod = (\\<lambda>_. Done)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generator Nil_prod = (\\<lambda>_. Done)", "by(fact Nil_prod.rep_eq)"], ["", "lemma unstream_Nil_prod [stream_fusion]: \"unstream Nil_prod () = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream Nil_prod () = []", "by(simp add: generator_Nil_prod)"], ["", "subsection \\<open>Consumers\\<close>"], ["", "subsubsection \\<open>@{const nth}\\<close>"], ["", "context fixes g :: \"('a, 's) generator\" begin"], ["", "definition nth_cons :: \"'s \\<Rightarrow> nat \\<Rightarrow> 'a\" \nwhere [stream_fusion]: \"nth_cons s n = unstream g s ! n\""], ["", "lemma nth_cons_code [code]:\n  \"nth_cons s n =\n  (case generator g s of Done => undefined n\n    | Skip s' => nth_cons s' n\n    | Yield x s' => (case n of 0 => x | Suc n' => nth_cons s' n'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.nth_cons s n =\n    (case generator g s of Done \\<Rightarrow> undefined n\n     | Skip s' \\<Rightarrow> local.nth_cons s' n\n     | Yield x s' \\<Rightarrow>\n         case n of 0 \\<Rightarrow> x\n         | Suc n' \\<Rightarrow> local.nth_cons s' n')", "by(cases \"generator g s\")(simp_all add: nth_cons_def nth_def split: nat.split)"], ["", "end"], ["", "subsubsection \\<open>@{term length}\\<close>"], ["", "context fixes g :: \"('a, 's) generator\" begin"], ["", "definition length_cons :: \"'s \\<Rightarrow> nat\"\nwhere \"length_cons s = length (unstream g s)\""], ["", "lemma length_cons_code [code]:\n  \"length_cons s =\n    (case generator g s of\n      Done \\<Rightarrow> 0\n    | Skip s' \\<Rightarrow> length_cons s'\n    | Yield a s' \\<Rightarrow> 1 + length_cons s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.length_cons s =\n    (case generator g s of Done \\<Rightarrow> 0\n     | Skip x \\<Rightarrow> local.length_cons x\n     | Yield a s' \\<Rightarrow> 1 + local.length_cons s')", "by(cases \"generator g s\")(simp_all add: length_cons_def)"], ["", "definition gen_length_cons :: \"nat \\<Rightarrow> 's \\<Rightarrow> nat\"\nwhere \"gen_length_cons n s = n + length (unstream g s)\""], ["", "lemma gen_length_cons_code [code]:\n  \"gen_length_cons n s = (case generator g s of\n     Done \\<Rightarrow> n | Skip s' \\<Rightarrow> gen_length_cons n s' | Yield a s' \\<Rightarrow> gen_length_cons (Suc n) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.gen_length_cons n s =\n    (case generator g s of Done \\<Rightarrow> n\n     | Skip s' \\<Rightarrow> local.gen_length_cons n s'\n     | Yield a s' \\<Rightarrow> local.gen_length_cons (Suc n) s')", "by(simp add: gen_length_cons_def split: step.split)"], ["", "lemma unstream_gen_length [stream_fusion]: \"gen_length_cons 0 s = length (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.gen_length_cons 0 s = length (unstream g s)", "by(simp add: gen_length_cons_def)"], ["", "lemma unstream_gen_length2 [stream_fusion]: \"gen_length_cons n s = List.gen_length n (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.gen_length_cons n s = List.gen_length n (unstream g s)", "by(simp add: List.gen_length_def gen_length_cons_def)"], ["", "end"], ["", "subsubsection \\<open>@{const foldr}\\<close>"], ["", "context \n  fixes g :: \"('a, 's) generator\"\n  and f :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'b\"\n  and z :: \"'b\"\nbegin"], ["", "definition foldr_cons :: \"'s \\<Rightarrow> 'b\"\nwhere [stream_fusion]: \"foldr_cons s = foldr f (unstream g s) z\""], ["", "lemma foldr_cons_code [code]:\n  \"foldr_cons s =\n    (case generator g s of\n      Done \\<Rightarrow> z\n    | Skip s' \\<Rightarrow> foldr_cons s'\n    | Yield a s' \\<Rightarrow> f a (foldr_cons s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.foldr_cons s =\n    (case generator g s of Done \\<Rightarrow> z\n     | Skip x \\<Rightarrow> local.foldr_cons x\n     | Yield a s' \\<Rightarrow> f a (local.foldr_cons s'))", "by(cases \"generator g s\")(simp_all add: foldr_cons_def)"], ["", "end"], ["", "subsubsection \\<open>@{const foldl}\\<close>"], ["", "context\n  fixes g :: \"('b, 's) generator\"\n  and f :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'a\"\nbegin"], ["", "definition foldl_cons :: \"'a \\<Rightarrow> 's \\<Rightarrow> 'a\"\nwhere [stream_fusion]: \"foldl_cons z s = foldl f z (unstream g s)\""], ["", "lemma foldl_cons_code [code]:\n  \"foldl_cons z s =\n    (case generator g s of\n      Done \\<Rightarrow> z\n    | Skip s' \\<Rightarrow> foldl_cons z s'\n    | Yield a s' \\<Rightarrow> foldl_cons (f z a) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.foldl_cons z s =\n    (case generator g s of Done \\<Rightarrow> z\n     | Skip s' \\<Rightarrow> local.foldl_cons z s'\n     | Yield a s' \\<Rightarrow> local.foldl_cons (f z a) s')", "by (cases \"generator g s\")(simp_all add: foldl_cons_def)"], ["", "end"], ["", "subsubsection \\<open>@{const fold}\\<close>"], ["", "context\n  fixes g :: \"('a, 's) generator\"\n  and f :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'b\"\nbegin"], ["", "definition fold_cons :: \"'b \\<Rightarrow> 's \\<Rightarrow> 'b\"\nwhere [stream_fusion]: \"fold_cons z s = fold f (unstream g s) z\""], ["", "lemma fold_cons_code [code]:\n  \"fold_cons z s =\n    (case generator g s of\n      Done \\<Rightarrow> z\n    | Skip s' \\<Rightarrow> fold_cons z s'\n    | Yield a s' \\<Rightarrow> fold_cons (f a z) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fold_cons z s =\n    (case generator g s of Done \\<Rightarrow> z\n     | Skip s' \\<Rightarrow> local.fold_cons z s'\n     | Yield a s' \\<Rightarrow> local.fold_cons (f a z) s')", "by (cases \"generator g s\")(simp_all add: fold_cons_def)"], ["", "end"], ["", "subsubsection \\<open>@{const List.null}\\<close>"], ["", "definition null_cons :: \"('a, 's) generator \\<Rightarrow> 's \\<Rightarrow> bool\"\nwhere [stream_fusion]: \"null_cons g s = List.null (unstream g s)\""], ["", "lemma null_cons_code [code]:\n  \"null_cons g s = (case generator g s of Done \\<Rightarrow> True | Skip s' \\<Rightarrow> null_cons g s' | Yield _ _ \\<Rightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null_cons g s =\n    (case generator g s of Done \\<Rightarrow> True\n     | Skip s' \\<Rightarrow> null_cons g s'\n     | Yield x xa \\<Rightarrow> False)", "by(cases \"generator g s\")(simp_all add: null_cons_def null_def)"], ["", "subsubsection \\<open>@{const hd}\\<close>"], ["", "context fixes g :: \"('a, 's) generator\" begin"], ["", "definition hd_cons :: \"'s \\<Rightarrow> 'a\"\nwhere [stream_fusion]: \"hd_cons s = hd (unstream g s)\""], ["", "lemma hd_cons_code [code]:\n  \"hd_cons s =\n    (case generator g s of\n      Done \\<Rightarrow> undefined\n    | Skip s' \\<Rightarrow> hd_cons s'\n    | Yield a s' \\<Rightarrow> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.hd_cons s =\n    (case generator g s of Skip x \\<Rightarrow> local.hd_cons x\n     | Yield a s' \\<Rightarrow> a)", "by (cases \"generator g s\")(simp_all add: hd_cons_def hd_def)"], ["", "end"], ["", "subsubsection \\<open>@{const last}\\<close>"], ["", "context fixes g :: \"('a, 's) generator\" begin"], ["", "definition last_cons :: \"'a option \\<Rightarrow> 's \\<Rightarrow> 'a\"\nwhere \"last_cons x s = (if unstream g s = [] then the x else last (unstream g s))\""], ["", "lemma last_cons_code [code]:\n  \"last_cons x s =\n  (case generator g s of Done \\<Rightarrow> the x\n             | Skip s' \\<Rightarrow> last_cons x s'\n             | Yield a s' \\<Rightarrow> last_cons (Some a) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.last_cons x s =\n    (case generator g s of Done \\<Rightarrow> the x\n     | Skip s' \\<Rightarrow> local.last_cons x s'\n     | Yield a s' \\<Rightarrow> local.last_cons (Some a) s')", "by (cases \"generator g s\")(simp_all add: last_cons_def)"], ["", "lemma unstream_last_cons [stream_fusion]: \"last_cons None s = last (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.last_cons None s = last (unstream g s)", "by (simp add: last_cons_def last_def option.the_def)"], ["", "end"], ["", "subsubsection \\<open>@{const sum_list}\\<close>"], ["", "context fixes g :: \"('a :: monoid_add, 's) generator\" begin"], ["", "definition sum_list_cons :: \"'s \\<Rightarrow> 'a\"\nwhere [stream_fusion]: \"sum_list_cons s = sum_list (unstream g s)\""], ["", "lemma sum_list_cons_code [code]:\n  \"sum_list_cons s =\n    (case generator g s of\n      Done \\<Rightarrow> 0\n    | Skip s' \\<Rightarrow> sum_list_cons s'\n    | Yield a s' \\<Rightarrow> a + sum_list_cons s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sum_list_cons s =\n    (case generator g s of Done \\<Rightarrow> 0::'a\n     | Skip x \\<Rightarrow> local.sum_list_cons x\n     | Yield a s' \\<Rightarrow> a + local.sum_list_cons s')", "by (cases \"generator g s\")(simp_all add: sum_list_cons_def)"], ["", "end"], ["", "subsubsection \\<open>@{const list_all2}\\<close>"], ["", "context\n  fixes g :: \"('a, 's1) generator\"\n  and h :: \"('b, 's2) generator\"\n  and P :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\"\nbegin"], ["", "definition list_all2_cons :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\nwhere [stream_fusion]: \"list_all2_cons sg sh = list_all2 P (unstream g sg) (unstream h sh)\""], ["", "definition list_all2_cons1 :: \"'a \\<Rightarrow> 's1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\nwhere \"list_all2_cons1 x sg' sh = list_all2 P (x # unstream g sg') (unstream h sh)\""], ["", "lemma list_all2_cons_code [code]:\n  \"list_all2_cons sg sh = \n  (case generator g sg of\n     Done \\<Rightarrow> null_cons h sh\n   | Skip sg' \\<Rightarrow> list_all2_cons sg' sh\n   | Yield a sg' \\<Rightarrow> list_all2_cons1 a sg' sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.list_all2_cons sg sh =\n    (case generator g sg of Done \\<Rightarrow> null_cons h sh\n     | Skip sg' \\<Rightarrow> local.list_all2_cons sg' sh\n     | Yield a sg' \\<Rightarrow> local.list_all2_cons1 a sg' sh)", "by(simp split: step.split add: list_all2_cons_def null_cons_def List.null_def list_all2_cons1_def)"], ["", "lemma list_all2_cons1_code [code]:\n  \"list_all2_cons1 x sg' sh = \n  (case generator h sh of\n     Done \\<Rightarrow> False\n   | Skip sh' \\<Rightarrow> list_all2_cons1 x sg' sh'\n   | Yield y sh' \\<Rightarrow> P x y \\<and> list_all2_cons sg' sh')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.list_all2_cons1 x sg' sh =\n    (case generator h sh of Done \\<Rightarrow> False\n     | Skip sh' \\<Rightarrow> local.list_all2_cons1 x sg' sh'\n     | Yield y sh' \\<Rightarrow> P x y \\<and> local.list_all2_cons sg' sh')", "by(simp split: step.split add: list_all2_cons_def null_cons_def List.null_def list_all2_cons1_def)"], ["", "end"], ["", "subsubsection \\<open>@{const list_all}\\<close>"], ["", "context\n  fixes g :: \"('a, 's) generator\"\n  and P :: \"'a \\<Rightarrow> bool\"\nbegin"], ["", "definition list_all_cons :: \"'s \\<Rightarrow> bool\"\nwhere [stream_fusion]: \"list_all_cons s = list_all P (unstream g s)\""], ["", "lemma list_all_cons_code [code]:\n  \"list_all_cons s \\<longleftrightarrow>\n  (case generator g s of\n    Done \\<Rightarrow> True | Skip s' \\<Rightarrow> list_all_cons s' | Yield x s' \\<Rightarrow> P x \\<and> list_all_cons s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.list_all_cons s =\n    (case generator g s of Done \\<Rightarrow> True\n     | Skip x \\<Rightarrow> local.list_all_cons x\n     | Yield x s' \\<Rightarrow> P x \\<and> local.list_all_cons s')", "by(simp add: list_all_cons_def split: step.split)"], ["", "end"], ["", "subsubsection \\<open>@{const ord.lexordp}\\<close>"], ["", "context ord begin"], ["", "definition lexord_fusion :: \"('a, 's1) generator \\<Rightarrow> ('a, 's2) generator \\<Rightarrow> 's1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\nwhere [code del]: \"lexord_fusion g1 g2 s1 s2 = ord_class.lexordp (unstream g1 s1) (unstream g2 s2)\""], ["", "definition lexord_eq_fusion :: \"('a, 's1) generator \\<Rightarrow> ('a, 's2) generator \\<Rightarrow> 's1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\nwhere [code del]: \"lexord_eq_fusion g1 g2 s1 s2 = lexordp_eq (unstream g1 s1) (unstream g2 s2)\""], ["", "lemma lexord_fusion_code:\n  \"lexord_fusion g1 g2 s1 s2 \\<longleftrightarrow>\n  (case generator g1 s1 of\n     Done \\<Rightarrow> \\<not> null_cons g2 s2\n   | Skip s1' \\<Rightarrow> lexord_fusion g1 g2 s1' s2\n   | Yield x s1' \\<Rightarrow> \n     (case force g2 s2 of\n        None \\<Rightarrow> False\n      | Some (y, s2') \\<Rightarrow> x < y \\<or> \\<not> y < x \\<and> lexord_fusion g1 g2 s1' s2'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lexord_fusion g1 g2 s1 s2 =\n    (case generator g1 s1 of Done \\<Rightarrow> \\<not> null_cons g2 s2\n     | Skip s1' \\<Rightarrow> lexord_fusion g1 g2 s1' s2\n     | Yield x s1' \\<Rightarrow>\n         case force g2 s2 of None \\<Rightarrow> False\n         | Some (y, s2') \\<Rightarrow>\n             x < y \\<or> \\<not> y < x \\<and> lexord_fusion g1 g2 s1' s2')", "unfolding lexord_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_class.lexordp (unstream g1 s1) (unstream g2 s2) =\n    (case generator g1 s1 of Done \\<Rightarrow> \\<not> null_cons g2 s2\n     | Skip s1' \\<Rightarrow>\n         ord_class.lexordp (unstream g1 s1') (unstream g2 s2)\n     | Yield x s1' \\<Rightarrow>\n         case force g2 s2 of None \\<Rightarrow> False\n         | Some (y, s2') \\<Rightarrow>\n             x < y \\<or>\n             \\<not> y < x \\<and>\n             ord_class.lexordp (unstream g1 s1') (unstream g2 s2'))", "by(cases \"generator g1 s1\" \"force g2 s2\" rule: step.exhaust[case_product option.exhaust])(auto simp add: null_cons_def null_def)"], ["", "lemma lexord_eq_fusion_code:\n  \"lexord_eq_fusion g1 g2 s1 s2 \\<longleftrightarrow>\n  (case generator g1 s1 of\n     Done \\<Rightarrow> True\n   | Skip s1' \\<Rightarrow> lexord_eq_fusion g1 g2 s1' s2\n   | Yield x s1' \\<Rightarrow>\n     (case force g2 s2 of\n        None \\<Rightarrow> False\n      | Some (y, s2') \\<Rightarrow> x < y \\<or> \\<not> y < x \\<and> lexord_eq_fusion g1 g2 s1' s2'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lexord_eq_fusion g1 g2 s1 s2 =\n    (case generator g1 s1 of Done \\<Rightarrow> True\n     | Skip s1' \\<Rightarrow> lexord_eq_fusion g1 g2 s1' s2\n     | Yield x s1' \\<Rightarrow>\n         case force g2 s2 of None \\<Rightarrow> False\n         | Some (y, s2') \\<Rightarrow>\n             x < y \\<or> \\<not> y < x \\<and> lexord_eq_fusion g1 g2 s1' s2')", "unfolding lexord_eq_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lexordp_eq (unstream g1 s1) (unstream g2 s2) =\n    (case generator g1 s1 of Done \\<Rightarrow> True\n     | Skip s1' \\<Rightarrow> lexordp_eq (unstream g1 s1') (unstream g2 s2)\n     | Yield x s1' \\<Rightarrow>\n         case force g2 s2 of None \\<Rightarrow> False\n         | Some (y, s2') \\<Rightarrow>\n             x < y \\<or>\n             \\<not> y < x \\<and>\n             lexordp_eq (unstream g1 s1') (unstream g2 s2'))", "by(cases \"generator g1 s1\" \"force g2 s2\" rule: step.exhaust[case_product option.exhaust]) auto"], ["", "end"], ["", "lemmas [code] =\n  lexord_fusion_code ord.lexord_fusion_code\n  lexord_eq_fusion_code ord.lexord_eq_fusion_code"], ["", "lemmas [stream_fusion] =\n  lexord_fusion_def ord.lexord_fusion_def\n  lexord_eq_fusion_def ord.lexord_eq_fusion_def"], ["", "subsection \\<open>Transformers\\<close>"], ["", "subsubsection \\<open>@{const map}\\<close>"], ["", "definition map_raw :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a, 's) raw_generator \\<Rightarrow> ('b, 's) raw_generator\"\nwhere\n  \"map_raw f g s = (case g s of\n     Done \\<Rightarrow> Done\n   | Skip s' \\<Rightarrow> Skip s'\n   | Yield a s' \\<Rightarrow> Yield (f a) s')\""], ["", "lemma terminates_map_raw: \n  assumes \"terminates g\"\n  shows \"terminates (map_raw f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (map_raw f g)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (map_raw f g)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (map_raw f g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (map_raw f g)", "then"], ["proof (chain)\npicking this:\n  s \\<in> terminates_on g", "show \"s \\<in> terminates_on (map_raw f g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (map_raw f g)", "by (induction s)(auto intro: terminates_on.intros simp add: map_raw_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (map_raw f g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition map_trans :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a, 's) generator \\<Rightarrow> ('b, 's) generator\" is \"map_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       terminates fun2 \\<Longrightarrow> terminates (map_raw fun1 fun2)", "by (rule terminates_map_raw)"], ["", "lemma unstream_map_trans [stream_fusion]: \"unstream (map_trans f g) s = map f (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (map_trans f g) s = map f (unstream g s)", "proof (induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (map_trans f g) x2 = map f (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (map_trans f g) x32 = map f (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (map_trans f g) s = map f (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (map_trans f g) ?x2.0 = map f (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (map_trans f g) ?x32.0 = map f (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (map_trans f g) x2 = map f (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (map_trans f g) x32 = map f (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (map_trans f g) s = map f (unstream g s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (map_trans f g) s = map f (unstream g s)", "using \"1.IH\""], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (map_trans f g) ?x2.0 = map f (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (map_trans f g) ?x32.0 = map f (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (map_trans f g) s = map f (unstream g s)", "by (cases \"generator g s\")(simp_all add: map_trans.rep_eq map_raw_def)"], ["proof (state)\nthis:\n  unstream (map_trans f g) s = map f (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const drop}\\<close>"], ["", "fun drop_raw :: \"('a, 's) raw_generator \\<Rightarrow> ('a, (nat \\<times> 's)) raw_generator\"\nwhere\n  \"drop_raw g (n, s) = (case g s of\n     Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (n, s')\n   | Yield a s' \\<Rightarrow> (case n of 0 \\<Rightarrow> Yield a (0, s') | Suc n \\<Rightarrow> Skip (n, s')))\""], ["", "lemma terminates_drop_raw:\n  assumes \"terminates g\"\n  shows \"terminates (drop_raw g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (drop_raw g)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (drop_raw g)", "fix st :: \"nat \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (drop_raw g)", "obtain n s where \"st = (n, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n s. st = (n, s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases st)"], ["proof (state)\nthis:\n  st = (n, s)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (drop_raw g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (drop_raw g)", "thus \"st \\<in> terminates_on (drop_raw g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. st \\<in> terminates_on (drop_raw g)", "unfolding \\<open>st = (n, s)\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (n, s) \\<in> terminates_on (drop_raw g)", "apply(induction arbitrary: n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s n.\n       g s = Done \\<Longrightarrow> (n, s) \\<in> terminates_on (drop_raw g)\n 2. \\<And>s s' n.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (drop_raw g)\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (drop_raw g)\n 3. \\<And>s a s' n.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (drop_raw g)\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (drop_raw g)", "apply(case_tac [!] n)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s n.\n       \\<lbrakk>g s = Done; n = 0\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (drop_raw g)\n 2. \\<And>s n nat.\n       \\<lbrakk>g s = Done; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (drop_raw g)\n 3. \\<And>s s' n.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (drop_raw g); n = 0\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (drop_raw g)\n 4. \\<And>s s' n nat.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (drop_raw g);\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (drop_raw g)\n 5. \\<And>s a s' n.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (drop_raw g); n = 0\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (drop_raw g)\n 6. \\<And>s a s' n nat.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (drop_raw g);\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (drop_raw g)", "apply(auto intro: terminates_on.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  st \\<in> terminates_on (drop_raw g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition drop_trans :: \"('a, 's) generator \\<Rightarrow> ('a, nat \\<times> 's) generator\" is \"drop_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. terminates fun \\<Longrightarrow> terminates (drop_raw fun)", "by (rule terminates_drop_raw)"], ["", "lemma unstream_drop_trans [stream_fusion]: \"unstream (drop_trans g) (n, s) = drop n (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (drop_trans g) (n, s) = drop n (unstream g s)", "proof (induction s arbitrary: n taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s n.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (drop_trans g) (n, x2) = drop n (unstream g x2);\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (drop_trans g) (n, x32) =\n           drop n (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (drop_trans g) (n, s) =\n                         drop n (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (drop_trans g) (?n, ?x2.0) = drop ?n (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (drop_trans g) (?n, ?x32.0) = drop ?n (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s n.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (drop_trans g) (n, x2) = drop n (unstream g x2);\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (drop_trans g) (n, x32) =\n           drop n (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (drop_trans g) (n, s) =\n                         drop n (unstream g s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (drop_trans g) (n, s) = drop n (unstream g s)", "using \"1.IH\"(1)[of _ n] \"1.IH\"(2)[of _ _ n] \"1.IH\"(2)[of _ _ \"n - 1\"]"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (drop_trans g) (n, ?x2.0) = drop n (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (drop_trans g) (n, ?x32.0) = drop n (unstream g ?x32.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (drop_trans g) (n - 1, ?x32.0) = drop (n - 1) (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (drop_trans g) (n, s) = drop n (unstream g s)", "by(cases \"generator g s\" \"n\" rule: step.exhaust[case_product nat.exhaust])\n      (simp_all add: drop_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (drop_trans g) (n, s) = drop n (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const dropWhile}\\<close>"], ["", "fun dropWhile_raw :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a, 's) raw_generator \\<Rightarrow> ('a, bool \\<times> 's) raw_generator\"\n  \\<comment> \\<open>Boolean flag indicates whether we are still in dropping phase\\<close>\nwhere\n  \"dropWhile_raw P g (True, s) = (case g s of\n     Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (True, s')\n   | Yield a s' \\<Rightarrow> (if P a then Skip (True, s') else Yield a (False, s')))\"\n| \"dropWhile_raw P g (False, s) = (case g s of\n     Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (False, s') | Yield a s' \\<Rightarrow> Yield a (False, s'))\""], ["", "lemma terminates_dropWhile_raw:\n  assumes \"terminates g\"\n  shows \"terminates (dropWhile_raw P g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (dropWhile_raw P g)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (dropWhile_raw P g)", "fix st :: \"bool \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (dropWhile_raw P g)", "obtain b s where \"st = (b, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b s. st = (b, s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases st)"], ["proof (state)\nthis:\n  st = (b, s)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (dropWhile_raw P g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (dropWhile_raw P g)", "then"], ["proof (chain)\npicking this:\n  s \\<in> terminates_on g", "show \"st \\<in> terminates_on (dropWhile_raw P g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. st \\<in> terminates_on (dropWhile_raw P g)", "unfolding \\<open>st = (b, s)\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (b, s) \\<in> terminates_on (dropWhile_raw P g)", "proof (induction s arbitrary: b)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s b.\n       g s = Done \\<Longrightarrow>\n       (b, s) \\<in> terminates_on (dropWhile_raw P g)\n 2. \\<And>s s' b.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)\n 3. \\<And>s a s' b.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)", "case (stop s b)"], ["proof (state)\nthis:\n  g s = Done\n\ngoal (3 subgoals):\n 1. \\<And>s b.\n       g s = Done \\<Longrightarrow>\n       (b, s) \\<in> terminates_on (dropWhile_raw P g)\n 2. \\<And>s s' b.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)\n 3. \\<And>s a s' b.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)", "then"], ["proof (chain)\npicking this:\n  g s = Done", "show ?case"], ["proof (prove)\nusing this:\n  g s = Done\n\ngoal (1 subgoal):\n 1. (b, s) \\<in> terminates_on (dropWhile_raw P g)", "by (cases b)(simp_all add: terminates_on.stop)"], ["proof (state)\nthis:\n  (b, s) \\<in> terminates_on (dropWhile_raw P g)\n\ngoal (2 subgoals):\n 1. \\<And>s s' b.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)\n 2. \\<And>s a s' b.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s' b.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)\n 2. \\<And>s a s' b.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)", "case (pause s s' b)"], ["proof (state)\nthis:\n  g s = Skip s'\n  s' \\<in> terminates_on g\n  (?b, s') \\<in> terminates_on (dropWhile_raw P g)\n\ngoal (2 subgoals):\n 1. \\<And>s s' b.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)\n 2. \\<And>s a s' b.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)", "then"], ["proof (chain)\npicking this:\n  g s = Skip s'\n  s' \\<in> terminates_on g\n  (?b, s') \\<in> terminates_on (dropWhile_raw P g)", "show ?case"], ["proof (prove)\nusing this:\n  g s = Skip s'\n  s' \\<in> terminates_on g\n  (?b, s') \\<in> terminates_on (dropWhile_raw P g)\n\ngoal (1 subgoal):\n 1. (b, s) \\<in> terminates_on (dropWhile_raw P g)", "by (cases b)(simp_all add: terminates_on.pause)"], ["proof (state)\nthis:\n  (b, s) \\<in> terminates_on (dropWhile_raw P g)\n\ngoal (1 subgoal):\n 1. \\<And>s a s' b.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a s' b.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)", "case (unfold s a s' b)"], ["proof (state)\nthis:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  (?b, s') \\<in> terminates_on (dropWhile_raw P g)\n\ngoal (1 subgoal):\n 1. \\<And>s a s' b.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>b. (b, s') \\<in> terminates_on (dropWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> (b, s) \\<in> terminates_on (dropWhile_raw P g)", "then"], ["proof (chain)\npicking this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  (?b, s') \\<in> terminates_on (dropWhile_raw P g)", "show ?case"], ["proof (prove)\nusing this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  (?b, s') \\<in> terminates_on (dropWhile_raw P g)\n\ngoal (1 subgoal):\n 1. (b, s) \\<in> terminates_on (dropWhile_raw P g)", "by(cases b)(cases \"P a\", auto intro: terminates_on.pause terminates_on.unfold)"], ["proof (state)\nthis:\n  (b, s) \\<in> terminates_on (dropWhile_raw P g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  st \\<in> terminates_on (dropWhile_raw P g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition dropWhile_trans :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a, 's) generator \\<Rightarrow> ('a, bool \\<times> 's) generator\"\nis \"dropWhile_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       terminates fun2 \\<Longrightarrow>\n       terminates (dropWhile_raw fun1 fun2)", "by (rule terminates_dropWhile_raw)"], ["", "lemma unstream_dropWhile_trans_False:\n  \"unstream (dropWhile_trans P g) (False, s) = unstream g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (dropWhile_trans P g) (False, s) = unstream g s", "proof (induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (dropWhile_trans P g) (False, x2) =\n                   unstream g x2;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (dropWhile_trans P g) (False, x32) =\n           unstream g x32\\<rbrakk>\n       \\<Longrightarrow> unstream (dropWhile_trans P g) (False, s) =\n                         unstream g s", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (False, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (False, ?x32.0) = unstream g ?x32.0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (dropWhile_trans P g) (False, x2) =\n                   unstream g x2;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (dropWhile_trans P g) (False, x32) =\n           unstream g x32\\<rbrakk>\n       \\<Longrightarrow> unstream (dropWhile_trans P g) (False, s) =\n                         unstream g s", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (False, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (False, ?x32.0) = unstream g ?x32.0", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (False, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (False, ?x32.0) = unstream g ?x32.0\n\ngoal (1 subgoal):\n 1. unstream (dropWhile_trans P g) (False, s) = unstream g s", "by (cases \"generator g s\")(simp_all add: dropWhile_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (dropWhile_trans P g) (False, s) = unstream g s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_dropWhile_trans [stream_fusion]:\n  \"unstream (dropWhile_trans P g) (True, s) = dropWhile P (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (dropWhile_trans P g) (True, s) = dropWhile P (unstream g s)", "proof (induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (dropWhile_trans P g) (True, x2) =\n                   dropWhile P (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (dropWhile_trans P g) (True, x32) =\n           dropWhile P (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (dropWhile_trans P g) (True, s) =\n                         dropWhile P (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (True, ?x2.0) =\n  dropWhile P (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (True, ?x32.0) =\n  dropWhile P (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (dropWhile_trans P g) (True, x2) =\n                   dropWhile P (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (dropWhile_trans P g) (True, x32) =\n           dropWhile P (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (dropWhile_trans P g) (True, s) =\n                         dropWhile P (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (True, ?x2.0) =\n  dropWhile P (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (True, ?x32.0) =\n  dropWhile P (unstream g ?x32.0)", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (True, ?x2.0) =\n  dropWhile P (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (True, ?x32.0) =\n  dropWhile P (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (dropWhile_trans P g) (True, s) = dropWhile P (unstream g s)", "proof(cases \"generator g s\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (dropWhile_trans P g) (True, x2) =\n                dropWhile P (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (dropWhile_trans P g) (True, x32) =\n        dropWhile P (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (dropWhile_trans P g) (True, s) =\n                      dropWhile P (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (dropWhile_trans P g) (True, x2) =\n                   dropWhile P (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (dropWhile_trans P g) (True, x32) =\n           dropWhile P (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (dropWhile_trans P g) (True, s) =\n                         dropWhile P (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (dropWhile_trans P g) (True, x2) =\n                   dropWhile P (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (dropWhile_trans P g) (True, x32) =\n           dropWhile P (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (dropWhile_trans P g) (True, s) =\n                         dropWhile P (unstream g s)", "case (Yield a s')"], ["proof (state)\nthis:\n  generator g s = Yield a s'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (dropWhile_trans P g) (True, x2) =\n                dropWhile P (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (dropWhile_trans P g) (True, x32) =\n        dropWhile P (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (dropWhile_trans P g) (True, s) =\n                      dropWhile P (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (dropWhile_trans P g) (True, x2) =\n                   dropWhile P (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (dropWhile_trans P g) (True, x32) =\n           dropWhile P (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (dropWhile_trans P g) (True, s) =\n                         dropWhile P (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (dropWhile_trans P g) (True, x2) =\n                   dropWhile P (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (dropWhile_trans P g) (True, x32) =\n           dropWhile P (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (dropWhile_trans P g) (True, s) =\n                         dropWhile P (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Yield a s'", "show ?thesis"], ["proof (prove)\nusing this:\n  generator g s = Yield a s'\n\ngoal (1 subgoal):\n 1. unstream (dropWhile_trans P g) (True, s) = dropWhile P (unstream g s)", "using \"1.IH\"(2) unstream_dropWhile_trans_False"], ["proof (prove)\nusing this:\n  generator g s = Yield a s'\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (dropWhile_trans P g) (True, ?x32.0) =\n  dropWhile P (unstream g ?x32.0)\n  unstream (dropWhile_trans ?P ?g) (False, ?s) = unstream ?g ?s\n\ngoal (1 subgoal):\n 1. unstream (dropWhile_trans P g) (True, s) = dropWhile P (unstream g s)", "by (cases \"P a\")(simp_all add: dropWhile_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (dropWhile_trans P g) (True, s) = dropWhile P (unstream g s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (dropWhile_trans P g) (True, x2) =\n                dropWhile P (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (dropWhile_trans P g) (True, x32) =\n        dropWhile P (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (dropWhile_trans P g) (True, s) =\n                      dropWhile P (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (dropWhile_trans P g) (True, x2) =\n                   dropWhile P (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (dropWhile_trans P g) (True, x32) =\n           dropWhile P (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (dropWhile_trans P g) (True, s) =\n                         dropWhile P (unstream g s)", "qed(simp_all add: dropWhile_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (dropWhile_trans P g) (True, s) = dropWhile P (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const take}\\<close>"], ["", "fun take_raw :: \"('a, 's) raw_generator \\<Rightarrow> ('a, (nat \\<times> 's)) raw_generator\"\nwhere\n  \"take_raw g (0, s) = Done\"\n| \"take_raw g (Suc n, s) = (case g s of \n     Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (Suc n, s') | Yield a s' \\<Rightarrow> Yield a (n, s'))\""], ["", "lemma terminates_take_raw:\n  assumes \"terminates g\"\n  shows \"terminates (take_raw g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (take_raw g)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (take_raw g)", "fix st :: \"nat \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (take_raw g)", "obtain n s where \"st = (n, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n s. st = (n, s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases st)"], ["proof (state)\nthis:\n  st = (n, s)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (take_raw g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (take_raw g)", "thus \"st \\<in> terminates_on (take_raw g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. st \\<in> terminates_on (take_raw g)", "unfolding \\<open>st = (n, s)\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (n, s) \\<in> terminates_on (take_raw g)", "apply(induction s arbitrary: n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s n.\n       g s = Done \\<Longrightarrow> (n, s) \\<in> terminates_on (take_raw g)\n 2. \\<And>s s' n.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (take_raw g)\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (take_raw g)\n 3. \\<And>s a s' n.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (take_raw g)\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (take_raw g)", "apply(case_tac [!] n)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s n.\n       \\<lbrakk>g s = Done; n = 0\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (take_raw g)\n 2. \\<And>s n nat.\n       \\<lbrakk>g s = Done; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (take_raw g)\n 3. \\<And>s s' n.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (take_raw g); n = 0\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (take_raw g)\n 4. \\<And>s s' n nat.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (take_raw g);\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (take_raw g)\n 5. \\<And>s a s' n.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (take_raw g); n = 0\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (take_raw g)\n 6. \\<And>s a s' n nat.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (take_raw g);\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (take_raw g)", "apply(auto intro: terminates_on.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  st \\<in> terminates_on (take_raw g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition take_trans :: \"('a, 's) generator \\<Rightarrow> ('a, nat \\<times> 's) generator\" is \"take_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. terminates fun \\<Longrightarrow> terminates (take_raw fun)", "by (rule terminates_take_raw)"], ["", "lemma unstream_take_trans [stream_fusion]: \"unstream (take_trans g) (n, s) = take n (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (take_trans g) (n, s) = take n (unstream g s)", "proof (induction s arbitrary: n taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s n.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (take_trans g) (n, x2) = take n (unstream g x2);\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (take_trans g) (n, x32) =\n           take n (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (take_trans g) (n, s) =\n                         take n (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (take_trans g) (?n, ?x2.0) = take ?n (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (take_trans g) (?n, ?x32.0) = take ?n (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s n.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (take_trans g) (n, x2) = take n (unstream g x2);\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (take_trans g) (n, x32) =\n           take n (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (take_trans g) (n, s) =\n                         take n (unstream g s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (take_trans g) (n, s) = take n (unstream g s)", "using \"1.IH\"(1)[of _ n] \"1.IH\"(2)"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (take_trans g) (n, ?x2.0) = take n (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (take_trans g) (?n, ?x32.0) = take ?n (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (take_trans g) (n, s) = take n (unstream g s)", "by(cases \"generator g s\" n rule: step.exhaust[case_product nat.exhaust])\n      (simp_all add: take_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (take_trans g) (n, s) = take n (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const takeWhile}\\<close>"], ["", "definition takeWhile_raw :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a, 's) raw_generator \\<Rightarrow> ('a, 's) raw_generator\"\nwhere\n  \"takeWhile_raw P g s = (case g s of\n     Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip s' | Yield a s' \\<Rightarrow> if P a then Yield a s' else Done)\""], ["", "lemma terminates_takeWhile_raw: \n  assumes \"terminates g\"\n  shows \"terminates (takeWhile_raw P g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (takeWhile_raw P g)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (takeWhile_raw P g)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (takeWhile_raw P g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (takeWhile_raw P g)", "thus \"s \\<in> terminates_on (takeWhile_raw P g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (takeWhile_raw P g)", "proof (induction s rule: terminates_on.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       g s = Done \\<Longrightarrow>\n       s \\<in> terminates_on (takeWhile_raw P g)\n 2. \\<And>s s'.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (takeWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (takeWhile_raw P g)\n 3. \\<And>s a s'.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (takeWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (takeWhile_raw P g)", "case (unfold s a s')"], ["proof (state)\nthis:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  s' \\<in> terminates_on (takeWhile_raw P g)\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       g s = Done \\<Longrightarrow>\n       s \\<in> terminates_on (takeWhile_raw P g)\n 2. \\<And>s s'.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (takeWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (takeWhile_raw P g)\n 3. \\<And>s a s'.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (takeWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (takeWhile_raw P g)", "then"], ["proof (chain)\npicking this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  s' \\<in> terminates_on (takeWhile_raw P g)", "show ?case"], ["proof (prove)\nusing this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  s' \\<in> terminates_on (takeWhile_raw P g)\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (takeWhile_raw P g)", "by(cases \"P a\")(auto simp add: takeWhile_raw_def intro: terminates_on.intros)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (takeWhile_raw P g)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       g s = Done \\<Longrightarrow>\n       s \\<in> terminates_on (takeWhile_raw P g)\n 2. \\<And>s s'.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (takeWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (takeWhile_raw P g)", "qed(auto intro: terminates_on.intros simp add: takeWhile_raw_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (takeWhile_raw P g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition takeWhile_trans :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a, 's) generator \\<Rightarrow> ('a, 's) generator\"\nis \"takeWhile_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       terminates fun2 \\<Longrightarrow>\n       terminates (takeWhile_raw fun1 fun2)", "by (rule terminates_takeWhile_raw)"], ["", "lemma unstream_takeWhile_trans [stream_fusion]:\n  \"unstream (takeWhile_trans P g) s = takeWhile P (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (takeWhile_trans P g) s = takeWhile P (unstream g s)", "proof (induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (takeWhile_trans P g) x2 =\n                   takeWhile P (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (takeWhile_trans P g) x32 =\n           takeWhile P (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (takeWhile_trans P g) s =\n                         takeWhile P (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (takeWhile_trans P g) ?x2.0 = takeWhile P (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (takeWhile_trans P g) ?x32.0 = takeWhile P (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (takeWhile_trans P g) x2 =\n                   takeWhile P (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (takeWhile_trans P g) x32 =\n           takeWhile P (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (takeWhile_trans P g) s =\n                         takeWhile P (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (takeWhile_trans P g) ?x2.0 = takeWhile P (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (takeWhile_trans P g) ?x32.0 = takeWhile P (unstream g ?x32.0)", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (takeWhile_trans P g) ?x2.0 = takeWhile P (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (takeWhile_trans P g) ?x32.0 = takeWhile P (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (takeWhile_trans P g) s = takeWhile P (unstream g s)", "by(cases \"generator g s\")(simp_all add: takeWhile_trans.rep_eq takeWhile_raw_def)"], ["proof (state)\nthis:\n  unstream (takeWhile_trans P g) s = takeWhile P (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>@{const append}\\<close>"], ["", "fun append_raw :: \"('a, 'sg) raw_generator \\<Rightarrow> ('a, 'sh) raw_generator \\<Rightarrow> 'sh \\<Rightarrow> ('a, 'sg + 'sh) raw_generator\"\nwhere\n  \"append_raw g h sh_start (Inl sg) = (case g sg of\n     Done \\<Rightarrow> Skip (Inr sh_start) | Skip sg' \\<Rightarrow> Skip (Inl sg') | Yield a sg' \\<Rightarrow> Yield a (Inl sg'))\"\n| \"append_raw g h sh_start (Inr sh) = (case h sh of\n     Done \\<Rightarrow> Done | Skip sh' \\<Rightarrow> Skip (Inr sh') | Yield a sh' \\<Rightarrow> Yield a (Inr sh'))\""], ["", "lemma terminates_on_append_raw_Inr: \n  assumes \"terminates h\"\n  shows \"Inr sh \\<in> terminates_on (append_raw g h sh_start)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inr sh \\<in> terminates_on (append_raw g h sh_start)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Inr sh \\<in> terminates_on (append_raw g h sh_start)", "from assms"], ["proof (chain)\npicking this:\n  terminates h", "have \"sh \\<in> terminates_on h\""], ["proof (prove)\nusing this:\n  terminates h\n\ngoal (1 subgoal):\n 1. sh \\<in> terminates_on h", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  sh \\<in> terminates_on h\n\ngoal (1 subgoal):\n 1. Inr sh \\<in> terminates_on (append_raw g h sh_start)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sh \\<in> terminates_on h\n\ngoal (1 subgoal):\n 1. Inr sh \\<in> terminates_on (append_raw g h sh_start)", "by(induction sh)(auto intro: terminates_on.intros)"], ["proof (state)\nthis:\n  Inr sh \\<in> terminates_on (append_raw g h sh_start)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma terminates_append_raw:\n  assumes \"terminates g\" \"terminates h\"\n  shows \"terminates (append_raw g h sh_start)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (append_raw g h sh_start)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (append_raw g h sh_start)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (append_raw g h sh_start)", "show \"s \\<in> terminates_on (append_raw g h sh_start)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (append_raw g h sh_start)", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       s \\<in> terminates_on (append_raw g h sh_start)\n 2. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       s \\<in> terminates_on (append_raw g h sh_start)", "case (Inl sg)"], ["proof (state)\nthis:\n  s = Inl sg\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       s \\<in> terminates_on (append_raw g h sh_start)\n 2. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       s \\<in> terminates_on (append_raw g h sh_start)", "from \\<open>terminates g\\<close>"], ["proof (chain)\npicking this:\n  terminates g", "have \"sg \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. sg \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  sg \\<in> terminates_on g\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       s \\<in> terminates_on (append_raw g h sh_start)\n 2. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       s \\<in> terminates_on (append_raw g h sh_start)", "thus \"s \\<in> terminates_on (append_raw g h sh_start)\""], ["proof (prove)\nusing this:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (append_raw g h sh_start)", "unfolding Inl"], ["proof (prove)\nusing this:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. Inl sg \\<in> terminates_on (append_raw g h sh_start)", "by induction(auto intro: terminates_on.intros terminates_on_append_raw_Inr[OF \\<open>terminates h\\<close>])"], ["proof (state)\nthis:\n  s \\<in> terminates_on (append_raw g h sh_start)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       s \\<in> terminates_on (append_raw g h sh_start)", "qed(simp add: terminates_on_append_raw_Inr[OF \\<open>terminates h\\<close>])"], ["proof (state)\nthis:\n  s \\<in> terminates_on (append_raw g h sh_start)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition append_trans :: \"('a, 'sg) generator \\<Rightarrow> ('a, 'sh) generator \\<Rightarrow> 'sh \\<Rightarrow> ('a, 'sg + 'sh) generator\"\nis \"append_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh.\n       \\<lbrakk>terminates fun1; terminates fun2\\<rbrakk>\n       \\<Longrightarrow> terminates (append_raw fun1 fun2 sh)", "by (rule terminates_append_raw)"], ["", "lemma unstream_append_trans_Inr: \"unstream (append_trans g h sh) (Inr sh') = unstream h sh'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (append_trans g h sh) (Inr sh') = unstream h sh'", "proof (induction sh' taking: h rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator h s = Skip x2 \\<Longrightarrow>\n                   unstream (append_trans g h sh) (Inr x2) = unstream h x2;\n        \\<And>x31 x32.\n           generator h s = Yield x31 x32 \\<Longrightarrow>\n           unstream (append_trans g h sh) (Inr x32) =\n           unstream h x32\\<rbrakk>\n       \\<Longrightarrow> unstream (append_trans g h sh) (Inr s) =\n                         unstream h s", "case (1 sh')"], ["proof (state)\nthis:\n  generator h sh' = Skip ?x2.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inr ?x2.0) = unstream h ?x2.0\n  generator h sh' = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inr ?x32.0) = unstream h ?x32.0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator h s = Skip x2 \\<Longrightarrow>\n                   unstream (append_trans g h sh) (Inr x2) = unstream h x2;\n        \\<And>x31 x32.\n           generator h s = Yield x31 x32 \\<Longrightarrow>\n           unstream (append_trans g h sh) (Inr x32) =\n           unstream h x32\\<rbrakk>\n       \\<Longrightarrow> unstream (append_trans g h sh) (Inr s) =\n                         unstream h s", "then"], ["proof (chain)\npicking this:\n  generator h sh' = Skip ?x2.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inr ?x2.0) = unstream h ?x2.0\n  generator h sh' = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inr ?x32.0) = unstream h ?x32.0", "show ?case"], ["proof (prove)\nusing this:\n  generator h sh' = Skip ?x2.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inr ?x2.0) = unstream h ?x2.0\n  generator h sh' = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inr ?x32.0) = unstream h ?x32.0\n\ngoal (1 subgoal):\n 1. unstream (append_trans g h sh) (Inr sh') = unstream h sh'", "by (cases \"generator h sh'\")(simp_all add: append_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (append_trans g h sh) (Inr sh') = unstream h sh'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_append_trans [stream_fusion]:\n  \"unstream (append_trans g h sh) (Inl sg) = append (unstream g sg) (unstream h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (append_trans g h sh) (Inl sg) = unstream g sg @ unstream h sh", "proof(induction sg taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (append_trans g h sh) (Inl x2) =\n                   unstream g x2 @ unstream h sh;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (append_trans g h sh) (Inl x32) =\n           unstream g x32 @ unstream h sh\\<rbrakk>\n       \\<Longrightarrow> unstream (append_trans g h sh) (Inl s) =\n                         unstream g s @ unstream h sh", "case (1 sg)"], ["proof (state)\nthis:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inl ?x2.0) =\n  unstream g ?x2.0 @ unstream h sh\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inl ?x32.0) =\n  unstream g ?x32.0 @ unstream h sh\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (append_trans g h sh) (Inl x2) =\n                   unstream g x2 @ unstream h sh;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (append_trans g h sh) (Inl x32) =\n           unstream g x32 @ unstream h sh\\<rbrakk>\n       \\<Longrightarrow> unstream (append_trans g h sh) (Inl s) =\n                         unstream g s @ unstream h sh", "then"], ["proof (chain)\npicking this:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inl ?x2.0) =\n  unstream g ?x2.0 @ unstream h sh\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inl ?x32.0) =\n  unstream g ?x32.0 @ unstream h sh", "show ?case"], ["proof (prove)\nusing this:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inl ?x2.0) =\n  unstream g ?x2.0 @ unstream h sh\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inl ?x32.0) =\n  unstream g ?x32.0 @ unstream h sh\n\ngoal (1 subgoal):\n 1. unstream (append_trans g h sh) (Inl sg) = unstream g sg @ unstream h sh", "using unstream_append_trans_Inr"], ["proof (prove)\nusing this:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inl ?x2.0) =\n  unstream g ?x2.0 @ unstream h sh\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (append_trans g h sh) (Inl ?x32.0) =\n  unstream g ?x32.0 @ unstream h sh\n  unstream (append_trans ?g ?h ?sh) (Inr ?sh') = unstream ?h ?sh'\n\ngoal (1 subgoal):\n 1. unstream (append_trans g h sh) (Inl sg) = unstream g sg @ unstream h sh", "by (cases \"generator g sg\")(simp_all add: append_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (append_trans g h sh) (Inl sg) = unstream g sg @ unstream h sh\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>@{const filter}\\<close>"], ["", "definition filter_raw :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a, 's) raw_generator \\<Rightarrow> ('a, 's) raw_generator\"\nwhere \n  \"filter_raw P g s = (case g s of\n     Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip s' | Yield a s' \\<Rightarrow> if P a then Yield a s' else Skip s')\""], ["", "lemma terminates_filter_raw:\n  assumes \"terminates g\"\n  shows \"terminates (filter_raw P g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (filter_raw P g)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (filter_raw P g)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (filter_raw P g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (filter_raw P g)", "thus \"s \\<in> terminates_on (filter_raw P g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (filter_raw P g)", "proof(induction s)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       g s = Done \\<Longrightarrow> s \\<in> terminates_on (filter_raw P g)\n 2. \\<And>s s'.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (filter_raw P g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (filter_raw P g)\n 3. \\<And>s a s'.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (filter_raw P g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (filter_raw P g)", "case (unfold s a s')"], ["proof (state)\nthis:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  s' \\<in> terminates_on (filter_raw P g)\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       g s = Done \\<Longrightarrow> s \\<in> terminates_on (filter_raw P g)\n 2. \\<And>s s'.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (filter_raw P g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (filter_raw P g)\n 3. \\<And>s a s'.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (filter_raw P g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (filter_raw P g)", "thus ?case"], ["proof (prove)\nusing this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  s' \\<in> terminates_on (filter_raw P g)\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (filter_raw P g)", "by(cases \"P a\")(auto intro: terminates_on.intros simp add: filter_raw_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (filter_raw P g)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       g s = Done \\<Longrightarrow> s \\<in> terminates_on (filter_raw P g)\n 2. \\<And>s s'.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (filter_raw P g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (filter_raw P g)", "qed(auto intro: terminates_on.intros simp add: filter_raw_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (filter_raw P g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition filter_trans :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a,'s) generator \\<Rightarrow> ('a,'s) generator\"\nis \"filter_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       terminates fun2 \\<Longrightarrow> terminates (filter_raw fun1 fun2)", "by (rule terminates_filter_raw)"], ["", "lemma unstream_filter_trans [stream_fusion]: \"unstream (filter_trans P g) s = filter P (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (filter_trans P g) s = filter P (unstream g s)", "proof (induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (filter_trans P g) x2 =\n                   filter P (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (filter_trans P g) x32 =\n           filter P (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (filter_trans P g) s =\n                         filter P (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (filter_trans P g) ?x2.0 = filter P (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (filter_trans P g) ?x32.0 = filter P (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (filter_trans P g) x2 =\n                   filter P (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (filter_trans P g) x32 =\n           filter P (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (filter_trans P g) s =\n                         filter P (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (filter_trans P g) ?x2.0 = filter P (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (filter_trans P g) ?x32.0 = filter P (unstream g ?x32.0)", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (filter_trans P g) ?x2.0 = filter P (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (filter_trans P g) ?x32.0 = filter P (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (filter_trans P g) s = filter P (unstream g s)", "by(cases \"generator g s\")(simp_all add: filter_trans.rep_eq filter_raw_def)"], ["proof (state)\nthis:\n  unstream (filter_trans P g) s = filter P (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>@{const zip}\\<close>"], ["", "fun zip_raw :: \"('a, 'sg) raw_generator \\<Rightarrow> ('b, 'sh) raw_generator \\<Rightarrow> ('a \\<times> 'b, 'sg \\<times> 'sh \\<times> 'a option) raw_generator\"\n  \\<comment> \\<open>We search first the left list for the next element and cache it in the @{typ \"'a option\"}\n        part of the state once we found one\\<close>\nwhere\n  \"zip_raw g h (sg, sh, None) = (case g sg of\n      Done \\<Rightarrow> Done | Skip sg' \\<Rightarrow> Skip (sg', sh, None) | Yield a sg' \\<Rightarrow> Skip (sg', sh, Some a))\"\n| \"zip_raw g h (sg, sh, Some a) = (case h sh of\n      Done \\<Rightarrow> Done | Skip sh' \\<Rightarrow> Skip (sg, sh', Some a) | Yield b sh' \\<Rightarrow> Yield (a, b) (sg, sh', None))\""], ["", "lemma terminates_zip_raw: \n  assumes \"terminates g\" \"terminates h\"\n  shows \"terminates (zip_raw g h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (zip_raw g h)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (zip_raw g h)", "fix s :: \"'a \\<times> 'c \\<times> 'b option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (zip_raw g h)", "obtain sg sh m where \"s = (sg, sh, m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sg sh m.\n        s = (sg, sh, m) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s)"], ["proof (state)\nthis:\n  s = (sg, sh, m)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (zip_raw g h)", "show \"s \\<in> terminates_on (zip_raw g h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (zip_raw g h)", "proof(cases m)"], ["proof (state)\ngoal (2 subgoals):\n 1. m = None \\<Longrightarrow> s \\<in> terminates_on (zip_raw g h)\n 2. \\<And>a.\n       m = Some a \\<Longrightarrow> s \\<in> terminates_on (zip_raw g h)", "case None"], ["proof (state)\nthis:\n  m = None\n\ngoal (2 subgoals):\n 1. m = None \\<Longrightarrow> s \\<in> terminates_on (zip_raw g h)\n 2. \\<And>a.\n       m = Some a \\<Longrightarrow> s \\<in> terminates_on (zip_raw g h)", "from \\<open>terminates g\\<close>"], ["proof (chain)\npicking this:\n  terminates g", "have \"sg \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. sg \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  sg \\<in> terminates_on g\n\ngoal (2 subgoals):\n 1. m = None \\<Longrightarrow> s \\<in> terminates_on (zip_raw g h)\n 2. \\<And>a.\n       m = Some a \\<Longrightarrow> s \\<in> terminates_on (zip_raw g h)", "then"], ["proof (chain)\npicking this:\n  sg \\<in> terminates_on g", "show ?thesis"], ["proof (prove)\nusing this:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (zip_raw g h)", "unfolding \\<open>s = (sg, sh, m)\\<close> None"], ["proof (prove)\nusing this:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (sg, sh, None) \\<in> terminates_on (zip_raw g h)", "proof (induction sg arbitrary: sh)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s sh.\n       g s = Done \\<Longrightarrow>\n       (s, sh, None) \\<in> terminates_on (zip_raw g h)\n 2. \\<And>s s' sh.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>sh. (s', sh, None) \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (s, sh, None) \\<in> terminates_on (zip_raw g h)\n 3. \\<And>s a s' sh.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>sh. (s', sh, None) \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (s, sh, None) \\<in> terminates_on (zip_raw g h)", "case (unfold sg a sg')"], ["proof (state)\nthis:\n  g sg = Yield a sg'\n  sg' \\<in> terminates_on g\n  (sg', ?sh, None) \\<in> terminates_on (zip_raw g h)\n\ngoal (3 subgoals):\n 1. \\<And>s sh.\n       g s = Done \\<Longrightarrow>\n       (s, sh, None) \\<in> terminates_on (zip_raw g h)\n 2. \\<And>s s' sh.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>sh. (s', sh, None) \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (s, sh, None) \\<in> terminates_on (zip_raw g h)\n 3. \\<And>s a s' sh.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>sh. (s', sh, None) \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (s, sh, None) \\<in> terminates_on (zip_raw g h)", "from \\<open>terminates h\\<close>"], ["proof (chain)\npicking this:\n  terminates h", "have \"sh \\<in> terminates_on h\""], ["proof (prove)\nusing this:\n  terminates h\n\ngoal (1 subgoal):\n 1. sh \\<in> terminates_on h", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  sh \\<in> terminates_on h\n\ngoal (3 subgoals):\n 1. \\<And>s sh.\n       g s = Done \\<Longrightarrow>\n       (s, sh, None) \\<in> terminates_on (zip_raw g h)\n 2. \\<And>s s' sh.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>sh. (s', sh, None) \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (s, sh, None) \\<in> terminates_on (zip_raw g h)\n 3. \\<And>s a s' sh.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>sh. (s', sh, None) \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (s, sh, None) \\<in> terminates_on (zip_raw g h)", "hence \"(sg', sh, Some a) \\<in> terminates_on (zip_raw g h)\""], ["proof (prove)\nusing this:\n  sh \\<in> terminates_on h\n\ngoal (1 subgoal):\n 1. (sg', sh, Some a) \\<in> terminates_on (zip_raw g h)", "by induction(auto intro: terminates_on.intros unfold.IH)"], ["proof (state)\nthis:\n  (sg', sh, Some a) \\<in> terminates_on (zip_raw g h)\n\ngoal (3 subgoals):\n 1. \\<And>s sh.\n       g s = Done \\<Longrightarrow>\n       (s, sh, None) \\<in> terminates_on (zip_raw g h)\n 2. \\<And>s s' sh.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>sh. (s', sh, None) \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (s, sh, None) \\<in> terminates_on (zip_raw g h)\n 3. \\<And>s a s' sh.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>sh. (s', sh, None) \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (s, sh, None) \\<in> terminates_on (zip_raw g h)", "thus ?case"], ["proof (prove)\nusing this:\n  (sg', sh, Some a) \\<in> terminates_on (zip_raw g h)\n\ngoal (1 subgoal):\n 1. (sg, sh, None) \\<in> terminates_on (zip_raw g h)", "using unfold.hyps"], ["proof (prove)\nusing this:\n  (sg', sh, Some a) \\<in> terminates_on (zip_raw g h)\n  g sg = Yield a sg'\n  sg' \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (sg, sh, None) \\<in> terminates_on (zip_raw g h)", "by(auto intro: terminates_on.pause)"], ["proof (state)\nthis:\n  (sg, sh, None) \\<in> terminates_on (zip_raw g h)\n\ngoal (2 subgoals):\n 1. \\<And>s sh.\n       g s = Done \\<Longrightarrow>\n       (s, sh, None) \\<in> terminates_on (zip_raw g h)\n 2. \\<And>s s' sh.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>sh. (s', sh, None) \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (s, sh, None) \\<in> terminates_on (zip_raw g h)", "qed(simp_all add: terminates_on.stop terminates_on.pause)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (zip_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m = Some a \\<Longrightarrow> s \\<in> terminates_on (zip_raw g h)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       m = Some a \\<Longrightarrow> s \\<in> terminates_on (zip_raw g h)", "case (Some a')"], ["proof (state)\nthis:\n  m = Some a'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m = Some a \\<Longrightarrow> s \\<in> terminates_on (zip_raw g h)", "from \\<open>terminates h\\<close>"], ["proof (chain)\npicking this:\n  terminates h", "have \"sh \\<in> terminates_on h\""], ["proof (prove)\nusing this:\n  terminates h\n\ngoal (1 subgoal):\n 1. sh \\<in> terminates_on h", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  sh \\<in> terminates_on h\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m = Some a \\<Longrightarrow> s \\<in> terminates_on (zip_raw g h)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sh \\<in> terminates_on h\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (zip_raw g h)", "unfolding \\<open>s = (sg, sh, m)\\<close> Some"], ["proof (prove)\nusing this:\n  sh \\<in> terminates_on h\n\ngoal (1 subgoal):\n 1. (sg, sh, Some a') \\<in> terminates_on (zip_raw g h)", "proof (induction sh arbitrary: sg a')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s sg a'.\n       h s = Done \\<Longrightarrow>\n       (sg, s, Some a') \\<in> terminates_on (zip_raw g h)\n 2. \\<And>s s' sg a'.\n       \\<lbrakk>h s = Skip s'; s' \\<in> terminates_on h;\n        \\<And>sg a'.\n           (sg, s', Some a') \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (sg, s, Some a') \\<in> terminates_on (zip_raw g h)\n 3. \\<And>s a s' sg a'.\n       \\<lbrakk>h s = Yield a s'; s' \\<in> terminates_on h;\n        \\<And>sg a'.\n           (sg, s', Some a') \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (sg, s, Some a') \\<in> terminates_on (zip_raw g h)", "case (unfold sh b sh')"], ["proof (state)\nthis:\n  h sh = Yield b sh'\n  sh' \\<in> terminates_on h\n  (?sg, sh', Some ?a') \\<in> terminates_on (zip_raw g h)\n\ngoal (3 subgoals):\n 1. \\<And>s sg a'.\n       h s = Done \\<Longrightarrow>\n       (sg, s, Some a') \\<in> terminates_on (zip_raw g h)\n 2. \\<And>s s' sg a'.\n       \\<lbrakk>h s = Skip s'; s' \\<in> terminates_on h;\n        \\<And>sg a'.\n           (sg, s', Some a') \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (sg, s, Some a') \\<in> terminates_on (zip_raw g h)\n 3. \\<And>s a s' sg a'.\n       \\<lbrakk>h s = Yield a s'; s' \\<in> terminates_on h;\n        \\<And>sg a'.\n           (sg, s', Some a') \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (sg, s, Some a') \\<in> terminates_on (zip_raw g h)", "from \\<open>terminates g\\<close>"], ["proof (chain)\npicking this:\n  terminates g", "have \"sg \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. sg \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  sg \\<in> terminates_on g\n\ngoal (3 subgoals):\n 1. \\<And>s sg a'.\n       h s = Done \\<Longrightarrow>\n       (sg, s, Some a') \\<in> terminates_on (zip_raw g h)\n 2. \\<And>s s' sg a'.\n       \\<lbrakk>h s = Skip s'; s' \\<in> terminates_on h;\n        \\<And>sg a'.\n           (sg, s', Some a') \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (sg, s, Some a') \\<in> terminates_on (zip_raw g h)\n 3. \\<And>s a s' sg a'.\n       \\<lbrakk>h s = Yield a s'; s' \\<in> terminates_on h;\n        \\<And>sg a'.\n           (sg, s', Some a') \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (sg, s, Some a') \\<in> terminates_on (zip_raw g h)", "hence \"(sg, sh', None) \\<in> terminates_on (zip_raw g h)\""], ["proof (prove)\nusing this:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (sg, sh', None) \\<in> terminates_on (zip_raw g h)", "by induction(auto intro: terminates_on.intros unfold.IH)"], ["proof (state)\nthis:\n  (sg, sh', None) \\<in> terminates_on (zip_raw g h)\n\ngoal (3 subgoals):\n 1. \\<And>s sg a'.\n       h s = Done \\<Longrightarrow>\n       (sg, s, Some a') \\<in> terminates_on (zip_raw g h)\n 2. \\<And>s s' sg a'.\n       \\<lbrakk>h s = Skip s'; s' \\<in> terminates_on h;\n        \\<And>sg a'.\n           (sg, s', Some a') \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (sg, s, Some a') \\<in> terminates_on (zip_raw g h)\n 3. \\<And>s a s' sg a'.\n       \\<lbrakk>h s = Yield a s'; s' \\<in> terminates_on h;\n        \\<And>sg a'.\n           (sg, s', Some a') \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (sg, s, Some a') \\<in> terminates_on (zip_raw g h)", "thus ?case"], ["proof (prove)\nusing this:\n  (sg, sh', None) \\<in> terminates_on (zip_raw g h)\n\ngoal (1 subgoal):\n 1. (sg, sh, Some a') \\<in> terminates_on (zip_raw g h)", "using unfold.hyps"], ["proof (prove)\nusing this:\n  (sg, sh', None) \\<in> terminates_on (zip_raw g h)\n  h sh = Yield b sh'\n  sh' \\<in> terminates_on h\n\ngoal (1 subgoal):\n 1. (sg, sh, Some a') \\<in> terminates_on (zip_raw g h)", "by(auto intro: terminates_on.unfold)"], ["proof (state)\nthis:\n  (sg, sh, Some a') \\<in> terminates_on (zip_raw g h)\n\ngoal (2 subgoals):\n 1. \\<And>s sg a'.\n       h s = Done \\<Longrightarrow>\n       (sg, s, Some a') \\<in> terminates_on (zip_raw g h)\n 2. \\<And>s s' sg a'.\n       \\<lbrakk>h s = Skip s'; s' \\<in> terminates_on h;\n        \\<And>sg a'.\n           (sg, s', Some a') \\<in> terminates_on (zip_raw g h)\\<rbrakk>\n       \\<Longrightarrow> (sg, s, Some a') \\<in> terminates_on (zip_raw g h)", "qed(simp_all add: terminates_on.stop terminates_on.pause)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (zip_raw g h)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<in> terminates_on (zip_raw g h)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition zip_trans :: \"('a, 'sg) generator \\<Rightarrow> ('b, 'sh) generator \\<Rightarrow> ('a \\<times> 'b,'sg \\<times> 'sh \\<times> 'a option) generator\"\nis \"zip_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>terminates fun1; terminates fun2\\<rbrakk>\n       \\<Longrightarrow> terminates (zip_raw fun1 fun2)", "by (rule terminates_zip_raw)"], ["", "lemma unstream_zip_trans [stream_fusion]:\n  \"unstream (zip_trans g h) (sg, sh, None) = zip (unstream g sg) (unstream h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (zip_trans g h) (sg, sh, None) =\n    zip (unstream g sg) (unstream h sh)", "proof (induction sg arbitrary: sh taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s sh.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (x2, sh, None) =\n                   zip (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (x32, sh, None) =\n           zip (unstream g x32) (unstream h sh)\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (s, sh, None) =\n                         zip (unstream g s) (unstream h sh)", "case (1 sg)"], ["proof (state)\nthis:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (?x2.0, ?sh, None) =\n  zip (unstream g ?x2.0) (unstream h ?sh)\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (?x32.0, ?sh, None) =\n  zip (unstream g ?x32.0) (unstream h ?sh)\n\ngoal (1 subgoal):\n 1. \\<And>s sh.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (x2, sh, None) =\n                   zip (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (x32, sh, None) =\n           zip (unstream g x32) (unstream h sh)\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (s, sh, None) =\n                         zip (unstream g s) (unstream h sh)", "then"], ["proof (chain)\npicking this:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (?x2.0, ?sh, None) =\n  zip (unstream g ?x2.0) (unstream h ?sh)\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (?x32.0, ?sh, None) =\n  zip (unstream g ?x32.0) (unstream h ?sh)", "show ?case"], ["proof (prove)\nusing this:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (?x2.0, ?sh, None) =\n  zip (unstream g ?x2.0) (unstream h ?sh)\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (?x32.0, ?sh, None) =\n  zip (unstream g ?x32.0) (unstream h ?sh)\n\ngoal (1 subgoal):\n 1. unstream (zip_trans g h) (sg, sh, None) =\n    zip (unstream g sg) (unstream h sh)", "proof (cases \"generator g sg\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2 sh.\n                generator g sg = Skip x2 \\<Longrightarrow>\n                unstream (zip_trans g h) (x2, sh, None) =\n                zip (unstream g x2) (unstream h sh);\n     \\<And>x31 x32 sh.\n        generator g sg = Yield x31 x32 \\<Longrightarrow>\n        unstream (zip_trans g h) (x32, sh, None) =\n        zip (unstream g x32) (unstream h sh);\n     generator g sg = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                      zip (unstream g sg) (unstream h sh)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (x2, sh, None) =\n                   zip (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (x32, sh, None) =\n           zip (unstream g x32) (unstream h sh);\n        generator g sg = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                         zip (unstream g sg) (unstream h sh)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (x2, sh, None) =\n                   zip (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (x32, sh, None) =\n           zip (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                         zip (unstream g sg) (unstream h sh)", "case (Yield a sg')"], ["proof (state)\nthis:\n  generator g sg = Yield a sg'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2 sh.\n                generator g sg = Skip x2 \\<Longrightarrow>\n                unstream (zip_trans g h) (x2, sh, None) =\n                zip (unstream g x2) (unstream h sh);\n     \\<And>x31 x32 sh.\n        generator g sg = Yield x31 x32 \\<Longrightarrow>\n        unstream (zip_trans g h) (x32, sh, None) =\n        zip (unstream g x32) (unstream h sh);\n     generator g sg = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                      zip (unstream g sg) (unstream h sh)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (x2, sh, None) =\n                   zip (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (x32, sh, None) =\n           zip (unstream g x32) (unstream h sh);\n        generator g sg = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                         zip (unstream g sg) (unstream h sh)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (x2, sh, None) =\n                   zip (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (x32, sh, None) =\n           zip (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                         zip (unstream g sg) (unstream h sh)", "note IH = \"1.IH\"(2)[OF Yield]"], ["proof (state)\nthis:\n  unstream (zip_trans g h) (sg', ?sh, None) =\n  zip (unstream g sg') (unstream h ?sh)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2 sh.\n                generator g sg = Skip x2 \\<Longrightarrow>\n                unstream (zip_trans g h) (x2, sh, None) =\n                zip (unstream g x2) (unstream h sh);\n     \\<And>x31 x32 sh.\n        generator g sg = Yield x31 x32 \\<Longrightarrow>\n        unstream (zip_trans g h) (x32, sh, None) =\n        zip (unstream g x32) (unstream h sh);\n     generator g sg = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                      zip (unstream g sg) (unstream h sh)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (x2, sh, None) =\n                   zip (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (x32, sh, None) =\n           zip (unstream g x32) (unstream h sh);\n        generator g sg = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                         zip (unstream g sg) (unstream h sh)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (x2, sh, None) =\n                   zip (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (x32, sh, None) =\n           zip (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                         zip (unstream g sg) (unstream h sh)", "have \"unstream (zip_trans g h) (sg', sh, Some a) = zip (a # (unstream g sg')) (unstream h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (zip_trans g h) (sg', sh, Some a) =\n    zip (a # unstream g sg') (unstream h sh)", "proof(induction sh taking: h rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator h s = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (sg', x2, Some a) =\n                   zip (a # unstream g sg') (unstream h x2);\n        \\<And>x31 x32.\n           generator h s = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (sg', x32, Some a) =\n           zip (a # unstream g sg') (unstream h x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (sg', s, Some a) =\n                         zip (a # unstream g sg') (unstream h s)", "case (1 sh)"], ["proof (state)\nthis:\n  generator h sh = Skip ?x2.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (sg', ?x2.0, Some a) =\n  zip (a # unstream g sg') (unstream h ?x2.0)\n  generator h sh = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (sg', ?x32.0, Some a) =\n  zip (a # unstream g sg') (unstream h ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator h s = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (sg', x2, Some a) =\n                   zip (a # unstream g sg') (unstream h x2);\n        \\<And>x31 x32.\n           generator h s = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (sg', x32, Some a) =\n           zip (a # unstream g sg') (unstream h x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (sg', s, Some a) =\n                         zip (a # unstream g sg') (unstream h s)", "then"], ["proof (chain)\npicking this:\n  generator h sh = Skip ?x2.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (sg', ?x2.0, Some a) =\n  zip (a # unstream g sg') (unstream h ?x2.0)\n  generator h sh = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (sg', ?x32.0, Some a) =\n  zip (a # unstream g sg') (unstream h ?x32.0)", "show ?case"], ["proof (prove)\nusing this:\n  generator h sh = Skip ?x2.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (sg', ?x2.0, Some a) =\n  zip (a # unstream g sg') (unstream h ?x2.0)\n  generator h sh = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (sg', ?x32.0, Some a) =\n  zip (a # unstream g sg') (unstream h ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (zip_trans g h) (sg', sh, Some a) =\n    zip (a # unstream g sg') (unstream h sh)", "using IH"], ["proof (prove)\nusing this:\n  generator h sh = Skip ?x2.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (sg', ?x2.0, Some a) =\n  zip (a # unstream g sg') (unstream h ?x2.0)\n  generator h sh = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (zip_trans g h) (sg', ?x32.0, Some a) =\n  zip (a # unstream g sg') (unstream h ?x32.0)\n  unstream (zip_trans g h) (sg', ?sh, None) =\n  zip (unstream g sg') (unstream h ?sh)\n\ngoal (1 subgoal):\n 1. unstream (zip_trans g h) (sg', sh, Some a) =\n    zip (a # unstream g sg') (unstream h sh)", "by(cases \"generator h sh\")(simp_all add: zip_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (zip_trans g h) (sg', sh, Some a) =\n  zip (a # unstream g sg') (unstream h sh)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unstream (zip_trans g h) (sg', sh, Some a) =\n  zip (a # unstream g sg') (unstream h sh)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2 sh.\n                generator g sg = Skip x2 \\<Longrightarrow>\n                unstream (zip_trans g h) (x2, sh, None) =\n                zip (unstream g x2) (unstream h sh);\n     \\<And>x31 x32 sh.\n        generator g sg = Yield x31 x32 \\<Longrightarrow>\n        unstream (zip_trans g h) (x32, sh, None) =\n        zip (unstream g x32) (unstream h sh);\n     generator g sg = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                      zip (unstream g sg) (unstream h sh)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (x2, sh, None) =\n                   zip (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (x32, sh, None) =\n           zip (unstream g x32) (unstream h sh);\n        generator g sg = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                         zip (unstream g sg) (unstream h sh)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (x2, sh, None) =\n                   zip (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (x32, sh, None) =\n           zip (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                         zip (unstream g sg) (unstream h sh)", "then"], ["proof (chain)\npicking this:\n  unstream (zip_trans g h) (sg', sh, Some a) =\n  zip (a # unstream g sg') (unstream h sh)", "show ?thesis"], ["proof (prove)\nusing this:\n  unstream (zip_trans g h) (sg', sh, Some a) =\n  zip (a # unstream g sg') (unstream h sh)\n\ngoal (1 subgoal):\n 1. unstream (zip_trans g h) (sg, sh, None) =\n    zip (unstream g sg) (unstream h sh)", "using Yield"], ["proof (prove)\nusing this:\n  unstream (zip_trans g h) (sg', sh, Some a) =\n  zip (a # unstream g sg') (unstream h sh)\n  generator g sg = Yield a sg'\n\ngoal (1 subgoal):\n 1. unstream (zip_trans g h) (sg, sh, None) =\n    zip (unstream g sg) (unstream h sh)", "by (simp add: zip_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (zip_trans g h) (sg, sh, None) =\n  zip (unstream g sg) (unstream h sh)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x2 sh.\n                generator g sg = Skip x2 \\<Longrightarrow>\n                unstream (zip_trans g h) (x2, sh, None) =\n                zip (unstream g x2) (unstream h sh);\n     \\<And>x31 x32 sh.\n        generator g sg = Yield x31 x32 \\<Longrightarrow>\n        unstream (zip_trans g h) (x32, sh, None) =\n        zip (unstream g x32) (unstream h sh);\n     generator g sg = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                      zip (unstream g sg) (unstream h sh)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (zip_trans g h) (x2, sh, None) =\n                   zip (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (zip_trans g h) (x32, sh, None) =\n           zip (unstream g x32) (unstream h sh);\n        generator g sg = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (zip_trans g h) (sg, sh, None) =\n                         zip (unstream g sg) (unstream h sh)", "qed(simp_all add: zip_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (zip_trans g h) (sg, sh, None) =\n  zip (unstream g sg) (unstream h sh)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const tl}\\<close>"], ["", "fun tl_raw :: \"('a, 'sg) raw_generator \\<Rightarrow> ('a, bool \\<times> 'sg) raw_generator\"\n  \\<comment> \\<open>The Boolean flag stores whether we have already skipped the first element\\<close>\nwhere\n  \"tl_raw g (False, sg) = (case g sg of\n      Done \\<Rightarrow> Done | Skip sg' \\<Rightarrow> Skip (False, sg') | Yield a sg' \\<Rightarrow> Skip (True,sg'))\"\n| \"tl_raw g (True, sg) = (case g sg of\n      Done \\<Rightarrow> Done | Skip sg' \\<Rightarrow> Skip (True, sg') | Yield a sg' \\<Rightarrow> Yield a (True, sg'))\""], ["", "lemma terminates_tl_raw: \n  assumes \"terminates g\"\n  shows \"terminates (tl_raw g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (tl_raw g)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (tl_raw g)", "fix s :: \"bool \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (tl_raw g)", "obtain b sg where \"s = (b, sg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b sg. s = (b, sg) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s)"], ["proof (state)\nthis:\n  s = (b, sg)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (tl_raw g)", "{"], ["proof (state)\nthis:\n  s = (b, sg)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (tl_raw g)", "fix sg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (tl_raw g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"sg \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. sg \\<in> terminates_on g", "by(simp add: terminates_def)"], ["proof (state)\nthis:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (tl_raw g)", "hence \"(True, sg) \\<in> terminates_on (tl_raw g)\""], ["proof (prove)\nusing this:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (True, sg) \\<in> terminates_on (tl_raw g)", "by(induction sg)(auto intro: terminates_on.intros)"], ["proof (state)\nthis:\n  (True, sg) \\<in> terminates_on (tl_raw g)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (tl_raw g)", "}"], ["proof (state)\nthis:\n  (True, ?sga2) \\<in> terminates_on (tl_raw g)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (tl_raw g)", "moreover"], ["proof (state)\nthis:\n  (True, ?sga2) \\<in> terminates_on (tl_raw g)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (tl_raw g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"sg \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. sg \\<in> terminates_on g", "by(simp add: terminates_def)"], ["proof (state)\nthis:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (tl_raw g)", "hence \"(False, sg) \\<in> terminates_on (tl_raw g)\""], ["proof (prove)\nusing this:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (False, sg) \\<in> terminates_on (tl_raw g)", "by(induction sg)(auto intro: terminates_on.intros calculation)"], ["proof (state)\nthis:\n  (False, sg) \\<in> terminates_on (tl_raw g)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (tl_raw g)", "ultimately"], ["proof (chain)\npicking this:\n  (True, ?sga2) \\<in> terminates_on (tl_raw g)\n  (False, sg) \\<in> terminates_on (tl_raw g)", "show \"s \\<in> terminates_on (tl_raw g)\""], ["proof (prove)\nusing this:\n  (True, ?sga2) \\<in> terminates_on (tl_raw g)\n  (False, sg) \\<in> terminates_on (tl_raw g)\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (tl_raw g)", "using \\<open>s = (b, sg)\\<close>"], ["proof (prove)\nusing this:\n  (True, ?sga2) \\<in> terminates_on (tl_raw g)\n  (False, sg) \\<in> terminates_on (tl_raw g)\n  s = (b, sg)\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (tl_raw g)", "by(cases b) simp_all"], ["proof (state)\nthis:\n  s \\<in> terminates_on (tl_raw g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition tl_trans :: \"('a, 'sg) generator \\<Rightarrow> ('a, bool \\<times> 'sg) generator\"\nis \"tl_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. terminates fun \\<Longrightarrow> terminates (tl_raw fun)", "by(rule terminates_tl_raw)"], ["", "lemma unstream_tl_trans_True: \"unstream (tl_trans g) (True, s) = unstream g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (tl_trans g) (True, s) = unstream g s", "proof(induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (tl_trans g) (True, x2) = unstream g x2;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (tl_trans g) (True, x32) = unstream g x32\\<rbrakk>\n       \\<Longrightarrow> unstream (tl_trans g) (True, s) = unstream g s", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (tl_trans g) (True, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (tl_trans g) (True, ?x32.0) = unstream g ?x32.0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (tl_trans g) (True, x2) = unstream g x2;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (tl_trans g) (True, x32) = unstream g x32\\<rbrakk>\n       \\<Longrightarrow> unstream (tl_trans g) (True, s) = unstream g s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (tl_trans g) (True, s) = unstream g s", "using \"1.IH\""], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (tl_trans g) (True, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (tl_trans g) (True, ?x32.0) = unstream g ?x32.0\n\ngoal (1 subgoal):\n 1. unstream (tl_trans g) (True, s) = unstream g s", "by (cases \"generator g s\")(simp_all add: tl_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (tl_trans g) (True, s) = unstream g s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_tl_trans [stream_fusion]: \"unstream (tl_trans g) (False, s) = tl (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (tl_trans g) (False, s) = tl (unstream g s)", "proof (induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (tl_trans g) (False, x2) = tl (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (tl_trans g) (False, x32) = tl (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (tl_trans g) (False, s) =\n                         tl (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (tl_trans g) (False, ?x2.0) = tl (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (tl_trans g) (False, ?x32.0) = tl (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (tl_trans g) (False, x2) = tl (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (tl_trans g) (False, x32) = tl (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (tl_trans g) (False, s) =\n                         tl (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (tl_trans g) (False, ?x2.0) = tl (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (tl_trans g) (False, ?x32.0) = tl (unstream g ?x32.0)", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (tl_trans g) (False, ?x2.0) = tl (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (tl_trans g) (False, ?x32.0) = tl (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (tl_trans g) (False, s) = tl (unstream g s)", "using unstream_tl_trans_True"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (tl_trans g) (False, ?x2.0) = tl (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (tl_trans g) (False, ?x32.0) = tl (unstream g ?x32.0)\n  unstream (tl_trans ?g) (True, ?s) = unstream ?g ?s\n\ngoal (1 subgoal):\n 1. unstream (tl_trans g) (False, s) = tl (unstream g s)", "by (cases \"generator g s\")(simp_all add: tl_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (tl_trans g) (False, s) = tl (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const butlast}\\<close>"], ["", "fun butlast_raw :: \"('a, 's) raw_generator \\<Rightarrow> ('a, 'a option \\<times> 's) raw_generator\"\n  \\<comment> \\<open>The @{typ \"'a option\"} caches the previous element we have seen\\<close>\nwhere\n  \"butlast_raw g (None,s) = (case g s of\n     Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (None, s') | Yield a s' \\<Rightarrow> Skip (Some a, s'))\"\n| \"butlast_raw g (Some b, s) = (case g s of\n     Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (Some b, s') | Yield a s' \\<Rightarrow> Yield b (Some a, s'))\""], ["", "lemma terminates_butlast_raw:\n  assumes \"terminates g\"\n  shows \"terminates (butlast_raw g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (butlast_raw g)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (butlast_raw g)", "fix st :: \"'b option \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (butlast_raw g)", "obtain ma s where \"st = (ma,s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ma s. st = (ma, s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases st)"], ["proof (state)\nthis:\n  st = (ma, s)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (butlast_raw g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (butlast_raw g)", "then"], ["proof (chain)\npicking this:\n  s \\<in> terminates_on g", "show \"st \\<in> terminates_on (butlast_raw g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. st \\<in> terminates_on (butlast_raw g)", "unfolding \\<open>st = (ma, s)\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (ma, s) \\<in> terminates_on (butlast_raw g)", "apply(induction s arbitrary: ma)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s ma.\n       g s = Done \\<Longrightarrow>\n       (ma, s) \\<in> terminates_on (butlast_raw g)\n 2. \\<And>s s' ma.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>ma. (ma, s') \\<in> terminates_on (butlast_raw g)\\<rbrakk>\n       \\<Longrightarrow> (ma, s) \\<in> terminates_on (butlast_raw g)\n 3. \\<And>s a s' ma.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>ma. (ma, s') \\<in> terminates_on (butlast_raw g)\\<rbrakk>\n       \\<Longrightarrow> (ma, s) \\<in> terminates_on (butlast_raw g)", "apply(case_tac [!] ma)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s ma.\n       \\<lbrakk>g s = Done; ma = None\\<rbrakk>\n       \\<Longrightarrow> (ma, s) \\<in> terminates_on (butlast_raw g)\n 2. \\<And>s ma a.\n       \\<lbrakk>g s = Done; ma = Some a\\<rbrakk>\n       \\<Longrightarrow> (ma, s) \\<in> terminates_on (butlast_raw g)\n 3. \\<And>s s' ma.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>ma. (ma, s') \\<in> terminates_on (butlast_raw g);\n        ma = None\\<rbrakk>\n       \\<Longrightarrow> (ma, s) \\<in> terminates_on (butlast_raw g)\n 4. \\<And>s s' ma a.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>ma. (ma, s') \\<in> terminates_on (butlast_raw g);\n        ma = Some a\\<rbrakk>\n       \\<Longrightarrow> (ma, s) \\<in> terminates_on (butlast_raw g)\n 5. \\<And>s a s' ma.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>ma. (ma, s') \\<in> terminates_on (butlast_raw g);\n        ma = None\\<rbrakk>\n       \\<Longrightarrow> (ma, s) \\<in> terminates_on (butlast_raw g)\n 6. \\<And>s a s' ma aa.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>ma. (ma, s') \\<in> terminates_on (butlast_raw g);\n        ma = Some aa\\<rbrakk>\n       \\<Longrightarrow> (ma, s) \\<in> terminates_on (butlast_raw g)", "apply(auto intro: terminates_on.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  st \\<in> terminates_on (butlast_raw g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition butlast_trans :: \"('a,'s) generator \\<Rightarrow> ('a, 'a option \\<times> 's) generator\"\nis \"butlast_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. terminates fun \\<Longrightarrow> terminates (butlast_raw fun)", "by (rule terminates_butlast_raw)"], ["", "lemma unstream_butlast_trans_Some:\n  \"unstream (butlast_trans g) (Some b,s) = butlast (b # (unstream g s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (butlast_trans g) (Some b, s) = butlast (b # unstream g s)", "proof (induction s arbitrary: b taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s b.\n       \\<lbrakk>\\<And>x2 b.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (butlast_trans g) (Some b, x2) =\n                   butlast (b # unstream g x2);\n        \\<And>x31 x32 b.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (butlast_trans g) (Some b, x32) =\n           butlast (b # unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (butlast_trans g) (Some b, s) =\n                         butlast (b # unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (Some ?b, ?x2.0) =\n  butlast (?b # unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (Some ?b, ?x32.0) =\n  butlast (?b # unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s b.\n       \\<lbrakk>\\<And>x2 b.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (butlast_trans g) (Some b, x2) =\n                   butlast (b # unstream g x2);\n        \\<And>x31 x32 b.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (butlast_trans g) (Some b, x32) =\n           butlast (b # unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (butlast_trans g) (Some b, s) =\n                         butlast (b # unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (Some ?b, ?x2.0) =\n  butlast (?b # unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (Some ?b, ?x32.0) =\n  butlast (?b # unstream g ?x32.0)", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (Some ?b, ?x2.0) =\n  butlast (?b # unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (Some ?b, ?x32.0) =\n  butlast (?b # unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (butlast_trans g) (Some b, s) = butlast (b # unstream g s)", "by (cases \"generator g s\")(simp_all add: butlast_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (butlast_trans g) (Some b, s) = butlast (b # unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_butlast_trans [stream_fusion]:\n  \"unstream (butlast_trans g) (None, s) = butlast (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (butlast_trans g) (None, s) = butlast (unstream g s)", "proof (induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (butlast_trans g) (None, x2) =\n                   butlast (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (butlast_trans g) (None, x32) =\n           butlast (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (butlast_trans g) (None, s) =\n                         butlast (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (None, ?x2.0) = butlast (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (None, ?x32.0) = butlast (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (butlast_trans g) (None, x2) =\n                   butlast (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (butlast_trans g) (None, x32) =\n           butlast (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (butlast_trans g) (None, s) =\n                         butlast (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (None, ?x2.0) = butlast (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (None, ?x32.0) = butlast (unstream g ?x32.0)", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (None, ?x2.0) = butlast (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (None, ?x32.0) = butlast (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (butlast_trans g) (None, s) = butlast (unstream g s)", "using 1 unstream_butlast_trans_Some[of g]"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (None, ?x2.0) = butlast (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (None, ?x32.0) = butlast (unstream g ?x32.0)\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (None, ?x2.0) = butlast (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (butlast_trans g) (None, ?x32.0) = butlast (unstream g ?x32.0)\n  unstream (butlast_trans g) (Some ?b, ?s) = butlast (?b # unstream g ?s)\n\ngoal (1 subgoal):\n 1. unstream (butlast_trans g) (None, s) = butlast (unstream g s)", "by (cases \"generator g s\")(simp_all add: butlast_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (butlast_trans g) (None, s) = butlast (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const concat}\\<close>"], ["", "text \\<open>\n  We only do the easy version here where\n  the generator has type @{typ \"('a list,'s) generator\"}, not @{typ \"(('a, 'si) generator, 's) generator\"}\n\\<close>"], ["", "fun concat_raw :: \"('a list, 's) raw_generator \\<Rightarrow> ('a, 'a list \\<times> 's) raw_generator\"\nwhere\n  \"concat_raw g ([], s) = (case g s of\n     Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip ([], s') | Yield xs s' \\<Rightarrow> Skip (xs, s'))\"\n| \"concat_raw g (x # xs, s) = Yield x (xs, s)\""], ["", "lemma terminates_concat_raw: \n  assumes \"terminates g\"\n  shows \"terminates (concat_raw g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (concat_raw g)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (concat_raw g)", "fix st :: \"'b list \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (concat_raw g)", "obtain xs s where \"st = (xs, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs s. st = (xs, s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases st)"], ["proof (state)\nthis:\n  st = (xs, s)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (concat_raw g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (concat_raw g)", "then"], ["proof (chain)\npicking this:\n  s \\<in> terminates_on g", "show \"st \\<in> terminates_on (concat_raw g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. st \\<in> terminates_on (concat_raw g)", "unfolding \\<open>st = (xs, s)\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (xs, s) \\<in> terminates_on (concat_raw g)", "proof (induction s arbitrary: xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s xs.\n       g s = Done \\<Longrightarrow>\n       (xs, s) \\<in> terminates_on (concat_raw g)\n 2. \\<And>s s' xs.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)\n 3. \\<And>s a s' xs.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)", "case (stop s xs)"], ["proof (state)\nthis:\n  g s = Done\n\ngoal (3 subgoals):\n 1. \\<And>s xs.\n       g s = Done \\<Longrightarrow>\n       (xs, s) \\<in> terminates_on (concat_raw g)\n 2. \\<And>s s' xs.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)\n 3. \\<And>s a s' xs.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)", "then"], ["proof (chain)\npicking this:\n  g s = Done", "show ?case"], ["proof (prove)\nusing this:\n  g s = Done\n\ngoal (1 subgoal):\n 1. (xs, s) \\<in> terminates_on (concat_raw g)", "by (induction xs)(auto intro: terminates_on.stop terminates_on.unfold)"], ["proof (state)\nthis:\n  (xs, s) \\<in> terminates_on (concat_raw g)\n\ngoal (2 subgoals):\n 1. \\<And>s s' xs.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)\n 2. \\<And>s a s' xs.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s' xs.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)\n 2. \\<And>s a s' xs.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)", "case (pause s s' xs)"], ["proof (state)\nthis:\n  g s = Skip s'\n  s' \\<in> terminates_on g\n  (?xs, s') \\<in> terminates_on (concat_raw g)\n\ngoal (2 subgoals):\n 1. \\<And>s s' xs.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)\n 2. \\<And>s a s' xs.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)", "then"], ["proof (chain)\npicking this:\n  g s = Skip s'\n  s' \\<in> terminates_on g\n  (?xs, s') \\<in> terminates_on (concat_raw g)", "show ?case"], ["proof (prove)\nusing this:\n  g s = Skip s'\n  s' \\<in> terminates_on g\n  (?xs, s') \\<in> terminates_on (concat_raw g)\n\ngoal (1 subgoal):\n 1. (xs, s) \\<in> terminates_on (concat_raw g)", "by (induction xs)(auto intro: terminates_on.pause terminates_on.unfold)"], ["proof (state)\nthis:\n  (xs, s) \\<in> terminates_on (concat_raw g)\n\ngoal (1 subgoal):\n 1. \\<And>s a s' xs.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a s' xs.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)", "case (unfold s a s' xs)"], ["proof (state)\nthis:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  (?xs, s') \\<in> terminates_on (concat_raw g)\n\ngoal (1 subgoal):\n 1. \\<And>s a s' xs.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>xs. (xs, s') \\<in> terminates_on (concat_raw g)\\<rbrakk>\n       \\<Longrightarrow> (xs, s) \\<in> terminates_on (concat_raw g)", "then"], ["proof (chain)\npicking this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  (?xs, s') \\<in> terminates_on (concat_raw g)", "show ?case"], ["proof (prove)\nusing this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  (?xs, s') \\<in> terminates_on (concat_raw g)\n\ngoal (1 subgoal):\n 1. (xs, s) \\<in> terminates_on (concat_raw g)", "by (induction xs)(auto intro: terminates_on.pause terminates_on.unfold)"], ["proof (state)\nthis:\n  (xs, s) \\<in> terminates_on (concat_raw g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  st \\<in> terminates_on (concat_raw g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition concat_trans :: \"('a list, 's) generator \\<Rightarrow> ('a, 'a list \\<times> 's) generator\"\nis \"concat_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. terminates fun \\<Longrightarrow> terminates (concat_raw fun)", "by (rule terminates_concat_raw)"], ["", "lemma unstream_concat_trans_gen: \"unstream (concat_trans g) (xs, s) = xs @ (concat (unstream g s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (concat_trans g) (xs, s) = xs @ concat (unstream g s)", "proof (induction s arbitrary: xs taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s xs.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (concat_trans g) (?xs, ?x2.0) = ?xs @ concat (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (concat_trans g) (?xs, ?x32.0) = ?xs @ concat (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s xs.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (concat_trans g) (?xs, ?x2.0) = ?xs @ concat (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (concat_trans g) (?xs, ?x32.0) = ?xs @ concat (unstream g ?x32.0)", "show \"unstream (concat_trans g) (xs, s) = xs @ (concat (unstream g s))\""], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (concat_trans g) (?xs, ?x2.0) = ?xs @ concat (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (concat_trans g) (?xs, ?x32.0) = ?xs @ concat (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (concat_trans g) (xs, s) = xs @ concat (unstream g s)", "proof (cases \"generator g s\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2 xs.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (concat_trans g) (xs, x2) =\n                xs @ concat (unstream g x2);\n     \\<And>x31 x32 xs.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (concat_trans g) (xs, x32) = xs @ concat (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                      xs @ concat (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)", "case Done"], ["proof (state)\nthis:\n  generator g s = Done\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2 xs.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (concat_trans g) (xs, x2) =\n                xs @ concat (unstream g x2);\n     \\<And>x31 x32 xs.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (concat_trans g) (xs, x32) = xs @ concat (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                      xs @ concat (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Done", "show ?thesis"], ["proof (prove)\nusing this:\n  generator g s = Done\n\ngoal (1 subgoal):\n 1. unstream (concat_trans g) (xs, s) = xs @ concat (unstream g s)", "by (induction xs)(simp_all add: concat_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (concat_trans g) (xs, s) = xs @ concat (unstream g s)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)\n 2. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)\n 2. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)", "case (Skip s')"], ["proof (state)\nthis:\n  generator g s = Skip s'\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)\n 2. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip s'", "show ?thesis"], ["proof (prove)\nusing this:\n  generator g s = Skip s'\n\ngoal (1 subgoal):\n 1. unstream (concat_trans g) (xs, s) = xs @ concat (unstream g s)", "using \"1.IH\"(1)[of s' Nil]"], ["proof (prove)\nusing this:\n  generator g s = Skip s'\n  generator g s = Skip s' \\<Longrightarrow>\n  unstream (concat_trans g) ([], s') = [] @ concat (unstream g s')\n\ngoal (1 subgoal):\n 1. unstream (concat_trans g) (xs, s) = xs @ concat (unstream g s)", "by (induction xs)(simp_all add: concat_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (concat_trans g) (xs, s) = xs @ concat (unstream g s)\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)", "case (Yield a s')"], ["proof (state)\nthis:\n  generator g s = Yield a s'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 xs.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (concat_trans g) (xs, x2) =\n                   xs @ concat (unstream g x2);\n        \\<And>x31 x32 xs.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (concat_trans g) (xs, x32) =\n           xs @ concat (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (concat_trans g) (xs, s) =\n                         xs @ concat (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Yield a s'", "show ?thesis"], ["proof (prove)\nusing this:\n  generator g s = Yield a s'\n\ngoal (1 subgoal):\n 1. unstream (concat_trans g) (xs, s) = xs @ concat (unstream g s)", "using \"1.IH\"(2)[of a s' a]"], ["proof (prove)\nusing this:\n  generator g s = Yield a s'\n  generator g s = Yield a s' \\<Longrightarrow>\n  unstream (concat_trans g) (a, s') = a @ concat (unstream g s')\n\ngoal (1 subgoal):\n 1. unstream (concat_trans g) (xs, s) = xs @ concat (unstream g s)", "by (induction xs)(simp_all add: concat_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (concat_trans g) (xs, s) = xs @ concat (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unstream (concat_trans g) (xs, s) = xs @ concat (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_concat_trans [stream_fusion]:\n  \"unstream (concat_trans g) ([], s) = concat (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (concat_trans g) ([], s) = concat (unstream g s)", "by(simp only: unstream_concat_trans_gen append_Nil)"], ["", "subsubsection \\<open>@{const splice}\\<close>"], ["", "datatype ('a, 'b) splice_state = Left 'a 'b | Right 'a 'b | Left_only 'a | Right_only 'b"], ["", "fun splice_raw :: \"('a, 'sg) raw_generator \\<Rightarrow> ('a, 'sh) raw_generator \\<Rightarrow> ('a, ('sg, 'sh) splice_state) raw_generator\"\nwhere\n  \"splice_raw g h (Left_only sg) = (case g sg of\n     Done \\<Rightarrow> Done | Skip sg' \\<Rightarrow> Skip (Left_only sg') | Yield a sg' \\<Rightarrow> Yield a (Left_only sg'))\"\n| \"splice_raw g h (Left sg sh) = (case g sg of\n     Done \\<Rightarrow> Skip (Right_only sh) | Skip sg' \\<Rightarrow> Skip (Left sg' sh) | Yield a sg' \\<Rightarrow> Yield a (Right sg' sh))\"\n| \"splice_raw g h (Right_only sh) = (case h sh of\n     Done \\<Rightarrow> Done | Skip sh' \\<Rightarrow> Skip (Right_only sh') | Yield a sh' \\<Rightarrow> Yield a (Right_only sh'))\"\n| \"splice_raw g h (Right sg sh) = (case h sh of\n     Done \\<Rightarrow> Skip (Left_only sg) | Skip sh' \\<Rightarrow> Skip (Right sg sh') | Yield a sh' \\<Rightarrow> Yield a (Left sg sh'))\""], ["", "lemma terminates_splice_raw: \n  assumes g: \"terminates g\" and h: \"terminates h\"\n  shows \"terminates (splice_raw g h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (splice_raw g h)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "fix sg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "from g"], ["proof (chain)\npicking this:\n  terminates g", "have \"sg \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. sg \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "hence \"Left_only sg \\<in> terminates_on (splice_raw g h)\""], ["proof (prove)\nusing this:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. Left_only sg \\<in> terminates_on (splice_raw g h)", "by induction(auto intro: terminates_on.intros)"], ["proof (state)\nthis:\n  Left_only sg \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "}"], ["proof (state)\nthis:\n  Left_only ?sg2 \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "moreover"], ["proof (state)\nthis:\n  Left_only ?sg2 \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "{"], ["proof (state)\nthis:\n  Left_only ?sg2 \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "fix sh"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "from h"], ["proof (chain)\npicking this:\n  terminates h", "have \"sh \\<in> terminates_on h\""], ["proof (prove)\nusing this:\n  terminates h\n\ngoal (1 subgoal):\n 1. sh \\<in> terminates_on h", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  sh \\<in> terminates_on h\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "hence \"Right_only sh \\<in> terminates_on (splice_raw g h)\""], ["proof (prove)\nusing this:\n  sh \\<in> terminates_on h\n\ngoal (1 subgoal):\n 1. Right_only sh \\<in> terminates_on (splice_raw g h)", "by induction(auto intro: terminates_on.intros)"], ["proof (state)\nthis:\n  Right_only sh \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "}"], ["proof (state)\nthis:\n  Right_only ?sh2 \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "moreover"], ["proof (state)\nthis:\n  Right_only ?sh2 \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "{"], ["proof (state)\nthis:\n  Right_only ?sh2 \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "fix sg sh"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "from g"], ["proof (chain)\npicking this:\n  terminates g", "have \"sg \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. sg \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "hence \"Left sg sh \\<in> terminates_on (splice_raw g h)\""], ["proof (prove)\nusing this:\n  sg \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. splice_state.Left sg sh \\<in> terminates_on (splice_raw g h)", "proof (induction sg arbitrary: sh)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s sh.\n       g s = Done \\<Longrightarrow>\n       splice_state.Left s sh \\<in> terminates_on (splice_raw g h)\n 2. \\<And>s s' sh.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>sh.\n           splice_state.Left s' sh\n           \\<in> terminates_on (splice_raw g h)\\<rbrakk>\n       \\<Longrightarrow> splice_state.Left s sh\n                         \\<in> terminates_on (splice_raw g h)\n 3. \\<And>s a s' sh.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>sh.\n           splice_state.Left s' sh\n           \\<in> terminates_on (splice_raw g h)\\<rbrakk>\n       \\<Longrightarrow> splice_state.Left s sh\n                         \\<in> terminates_on (splice_raw g h)", "case (unfold sg a sg')"], ["proof (state)\nthis:\n  g sg = Yield a sg'\n  sg' \\<in> terminates_on g\n  splice_state.Left sg' ?sh \\<in> terminates_on (splice_raw g h)\n\ngoal (3 subgoals):\n 1. \\<And>s sh.\n       g s = Done \\<Longrightarrow>\n       splice_state.Left s sh \\<in> terminates_on (splice_raw g h)\n 2. \\<And>s s' sh.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>sh.\n           splice_state.Left s' sh\n           \\<in> terminates_on (splice_raw g h)\\<rbrakk>\n       \\<Longrightarrow> splice_state.Left s sh\n                         \\<in> terminates_on (splice_raw g h)\n 3. \\<And>s a s' sh.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>sh.\n           splice_state.Left s' sh\n           \\<in> terminates_on (splice_raw g h)\\<rbrakk>\n       \\<Longrightarrow> splice_state.Left s sh\n                         \\<in> terminates_on (splice_raw g h)", "from h"], ["proof (chain)\npicking this:\n  terminates h", "have \"sh \\<in> terminates_on h\""], ["proof (prove)\nusing this:\n  terminates h\n\ngoal (1 subgoal):\n 1. sh \\<in> terminates_on h", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  sh \\<in> terminates_on h\n\ngoal (3 subgoals):\n 1. \\<And>s sh.\n       g s = Done \\<Longrightarrow>\n       splice_state.Left s sh \\<in> terminates_on (splice_raw g h)\n 2. \\<And>s s' sh.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>sh.\n           splice_state.Left s' sh\n           \\<in> terminates_on (splice_raw g h)\\<rbrakk>\n       \\<Longrightarrow> splice_state.Left s sh\n                         \\<in> terminates_on (splice_raw g h)\n 3. \\<And>s a s' sh.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>sh.\n           splice_state.Left s' sh\n           \\<in> terminates_on (splice_raw g h)\\<rbrakk>\n       \\<Longrightarrow> splice_state.Left s sh\n                         \\<in> terminates_on (splice_raw g h)", "hence \"Right sg' sh \\<in> terminates_on (splice_raw g h)\""], ["proof (prove)\nusing this:\n  sh \\<in> terminates_on h\n\ngoal (1 subgoal):\n 1. splice_state.Right sg' sh \\<in> terminates_on (splice_raw g h)", "by induction(auto intro: terminates_on.intros unfold.IH calculation)"], ["proof (state)\nthis:\n  splice_state.Right sg' sh \\<in> terminates_on (splice_raw g h)\n\ngoal (3 subgoals):\n 1. \\<And>s sh.\n       g s = Done \\<Longrightarrow>\n       splice_state.Left s sh \\<in> terminates_on (splice_raw g h)\n 2. \\<And>s s' sh.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>sh.\n           splice_state.Left s' sh\n           \\<in> terminates_on (splice_raw g h)\\<rbrakk>\n       \\<Longrightarrow> splice_state.Left s sh\n                         \\<in> terminates_on (splice_raw g h)\n 3. \\<And>s a s' sh.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>sh.\n           splice_state.Left s' sh\n           \\<in> terminates_on (splice_raw g h)\\<rbrakk>\n       \\<Longrightarrow> splice_state.Left s sh\n                         \\<in> terminates_on (splice_raw g h)", "thus ?case"], ["proof (prove)\nusing this:\n  splice_state.Right sg' sh \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. splice_state.Left sg sh \\<in> terminates_on (splice_raw g h)", "using unfold.hyps"], ["proof (prove)\nusing this:\n  splice_state.Right sg' sh \\<in> terminates_on (splice_raw g h)\n  g sg = Yield a sg'\n  sg' \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. splice_state.Left sg sh \\<in> terminates_on (splice_raw g h)", "by (auto intro: terminates_on.unfold)"], ["proof (state)\nthis:\n  splice_state.Left sg sh \\<in> terminates_on (splice_raw g h)\n\ngoal (2 subgoals):\n 1. \\<And>s sh.\n       g s = Done \\<Longrightarrow>\n       splice_state.Left s sh \\<in> terminates_on (splice_raw g h)\n 2. \\<And>s s' sh.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>sh.\n           splice_state.Left s' sh\n           \\<in> terminates_on (splice_raw g h)\\<rbrakk>\n       \\<Longrightarrow> splice_state.Left s sh\n                         \\<in> terminates_on (splice_raw g h)", "qed(auto intro: terminates_on.intros calculation)"], ["proof (state)\nthis:\n  splice_state.Left sg sh \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "}"], ["proof (state)\nthis:\n  splice_state.Left ?sg2 ?sh2 \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "moreover"], ["proof (state)\nthis:\n  splice_state.Left ?sg2 ?sh2 \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "{"], ["proof (state)\nthis:\n  splice_state.Left ?sg2 ?sh2 \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "fix sg sh"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "from h"], ["proof (chain)\npicking this:\n  terminates h", "have \"sh \\<in> terminates_on h\""], ["proof (prove)\nusing this:\n  terminates h\n\ngoal (1 subgoal):\n 1. sh \\<in> terminates_on h", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  sh \\<in> terminates_on h\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "hence \"Right sg sh \\<in> terminates_on (splice_raw g h)\""], ["proof (prove)\nusing this:\n  sh \\<in> terminates_on h\n\ngoal (1 subgoal):\n 1. splice_state.Right sg sh \\<in> terminates_on (splice_raw g h)", "by(induction sh arbitrary: sg)(auto intro: terminates_on.intros calculation)"], ["proof (state)\nthis:\n  splice_state.Right sg sh \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "}"], ["proof (state)\nthis:\n  splice_state.Right ?sg2 ?sh2 \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (splice_raw g h)", "ultimately"], ["proof (chain)\npicking this:\n  Left_only ?sg2 \\<in> terminates_on (splice_raw g h)\n  Right_only ?sh2 \\<in> terminates_on (splice_raw g h)\n  splice_state.Left ?sg2 ?sh2 \\<in> terminates_on (splice_raw g h)\n  splice_state.Right ?sg2 ?sh2 \\<in> terminates_on (splice_raw g h)", "show \"s \\<in> terminates_on (splice_raw g h)\""], ["proof (prove)\nusing this:\n  Left_only ?sg2 \\<in> terminates_on (splice_raw g h)\n  Right_only ?sh2 \\<in> terminates_on (splice_raw g h)\n  splice_state.Left ?sg2 ?sh2 \\<in> terminates_on (splice_raw g h)\n  splice_state.Right ?sg2 ?sh2 \\<in> terminates_on (splice_raw g h)\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (splice_raw g h)", "by(cases s)(simp_all)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (splice_raw g h)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition splice_trans :: \"('a, 'sg) generator \\<Rightarrow> ('a, 'sh) generator \\<Rightarrow> ('a, ('sg, 'sh) splice_state) generator\"\nis \"splice_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>terminates fun1; terminates fun2\\<rbrakk>\n       \\<Longrightarrow> terminates (splice_raw fun1 fun2)", "by (rule terminates_splice_raw)"], ["", "lemma unstream_splice_trans_Right_only: \"unstream (splice_trans g h) (Right_only sh) = unstream h sh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (splice_trans g h) (Right_only sh) = unstream h sh", "proof (induction sh taking: h rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator h s = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (Right_only x2) =\n                   unstream h x2;\n        \\<And>x31 x32.\n           generator h s = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (Right_only x32) =\n           unstream h x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h) (Right_only s) =\n                         unstream h s", "case (1 sh)"], ["proof (state)\nthis:\n  generator h sh = Skip ?x2.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (Right_only ?x2.0) = unstream h ?x2.0\n  generator h sh = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (Right_only ?x32.0) = unstream h ?x32.0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator h s = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (Right_only x2) =\n                   unstream h x2;\n        \\<And>x31 x32.\n           generator h s = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (Right_only x32) =\n           unstream h x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h) (Right_only s) =\n                         unstream h s", "then"], ["proof (chain)\npicking this:\n  generator h sh = Skip ?x2.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (Right_only ?x2.0) = unstream h ?x2.0\n  generator h sh = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (Right_only ?x32.0) = unstream h ?x32.0", "show ?case"], ["proof (prove)\nusing this:\n  generator h sh = Skip ?x2.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (Right_only ?x2.0) = unstream h ?x2.0\n  generator h sh = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (Right_only ?x32.0) = unstream h ?x32.0\n\ngoal (1 subgoal):\n 1. unstream (splice_trans g h) (Right_only sh) = unstream h sh", "by (cases \"generator h sh\")(simp_all add: splice_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (splice_trans g h) (Right_only sh) = unstream h sh\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_splice_trans_Left_only: \"unstream (splice_trans g h) (Left_only sg) = unstream g sg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (splice_trans g h) (Left_only sg) = unstream g sg", "proof (induction sg taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (Left_only x2) =\n                   unstream g x2;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (Left_only x32) =\n           unstream g x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h) (Left_only s) =\n                         unstream g s", "case (1 sg)"], ["proof (state)\nthis:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (Left_only ?x2.0) = unstream g ?x2.0\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (Left_only ?x32.0) = unstream g ?x32.0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (Left_only x2) =\n                   unstream g x2;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (Left_only x32) =\n           unstream g x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h) (Left_only s) =\n                         unstream g s", "then"], ["proof (chain)\npicking this:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (Left_only ?x2.0) = unstream g ?x2.0\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (Left_only ?x32.0) = unstream g ?x32.0", "show ?case"], ["proof (prove)\nusing this:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (Left_only ?x2.0) = unstream g ?x2.0\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (Left_only ?x32.0) = unstream g ?x32.0\n\ngoal (1 subgoal):\n 1. unstream (splice_trans g h) (Left_only sg) = unstream g sg", "by (cases \"generator g sg\")(simp_all add: splice_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (splice_trans g h) (Left_only sg) = unstream g sg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_splice_trans [stream_fusion]:\n  \"unstream (splice_trans g h) (Left sg sh) = splice (unstream g sg) (unstream h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (splice_trans g h) (splice_state.Left sg sh) =\n    splice (unstream g sg) (unstream h sh)", "proof (induction sg arbitrary: sh taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s sh.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh)\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left s sh) =\n                         splice (unstream g s) (unstream h sh)", "case (1 sg sh)"], ["proof (state)\nthis:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (splice_state.Left ?x2.0 ?sh) =\n  splice (unstream g ?x2.0) (unstream h ?sh)\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (splice_state.Left ?x32.0 ?sh) =\n  splice (unstream g ?x32.0) (unstream h ?sh)\n\ngoal (1 subgoal):\n 1. \\<And>s sh.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh)\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left s sh) =\n                         splice (unstream g s) (unstream h sh)", "then"], ["proof (chain)\npicking this:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (splice_state.Left ?x2.0 ?sh) =\n  splice (unstream g ?x2.0) (unstream h ?sh)\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (splice_state.Left ?x32.0 ?sh) =\n  splice (unstream g ?x32.0) (unstream h ?sh)", "show ?case"], ["proof (prove)\nusing this:\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (splice_state.Left ?x2.0 ?sh) =\n  splice (unstream g ?x2.0) (unstream h ?sh)\n  generator g sg = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (splice_state.Left ?x32.0 ?sh) =\n  splice (unstream g ?x32.0) (unstream h ?sh)\n\ngoal (1 subgoal):\n 1. unstream (splice_trans g h) (splice_state.Left sg sh) =\n    splice (unstream g sg) (unstream h sh)", "proof (cases \"generator g sg\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2 sh.\n                generator g sg = Skip x2 \\<Longrightarrow>\n                unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                splice (unstream g x2) (unstream h sh);\n     \\<And>x31 x32 sh.\n        generator g sg = Yield x31 x32 \\<Longrightarrow>\n        unstream (splice_trans g h) (splice_state.Left x32 sh) =\n        splice (unstream g x32) (unstream h sh);\n     generator g sg = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (splice_trans g h)\n                       (splice_state.Left sg sh) =\n                      splice (unstream g sg) (unstream h sh)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)", "case Done"], ["proof (state)\nthis:\n  generator g sg = Done\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2 sh.\n                generator g sg = Skip x2 \\<Longrightarrow>\n                unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                splice (unstream g x2) (unstream h sh);\n     \\<And>x31 x32 sh.\n        generator g sg = Yield x31 x32 \\<Longrightarrow>\n        unstream (splice_trans g h) (splice_state.Left x32 sh) =\n        splice (unstream g x32) (unstream h sh);\n     generator g sg = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (splice_trans g h)\n                       (splice_state.Left sg sh) =\n                      splice (unstream g sg) (unstream h sh)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)", "with unstream_splice_trans_Right_only[of g h]"], ["proof (chain)\npicking this:\n  unstream (splice_trans g h) (Right_only ?sh) = unstream h ?sh\n  generator g sg = Done", "show ?thesis"], ["proof (prove)\nusing this:\n  unstream (splice_trans g h) (Right_only ?sh) = unstream h ?sh\n  generator g sg = Done\n\ngoal (1 subgoal):\n 1. unstream (splice_trans g h) (splice_state.Left sg sh) =\n    splice (unstream g sg) (unstream h sh)", "by (simp add: splice_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (splice_trans g h) (splice_state.Left sg sh) =\n  splice (unstream g sg) (unstream h sh)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)\n 2. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)\n 2. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)", "case (Skip sg')"], ["proof (state)\nthis:\n  generator g sg = Skip sg'\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)\n 2. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)", "then"], ["proof (chain)\npicking this:\n  generator g sg = Skip sg'", "show ?thesis"], ["proof (prove)\nusing this:\n  generator g sg = Skip sg'\n\ngoal (1 subgoal):\n 1. unstream (splice_trans g h) (splice_state.Left sg sh) =\n    splice (unstream g sg) (unstream h sh)", "using \"1.IH\"(1)"], ["proof (prove)\nusing this:\n  generator g sg = Skip sg'\n  generator g sg = Skip ?x2.0 \\<Longrightarrow>\n  unstream (splice_trans g h) (splice_state.Left ?x2.0 ?sh) =\n  splice (unstream g ?x2.0) (unstream h ?sh)\n\ngoal (1 subgoal):\n 1. unstream (splice_trans g h) (splice_state.Left sg sh) =\n    splice (unstream g sg) (unstream h sh)", "by (simp add: splice_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (splice_trans g h) (splice_state.Left sg sh) =\n  splice (unstream g sg) (unstream h sh)\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)", "case (Yield a sg')"], ["proof (state)\nthis:\n  generator g sg = Yield a sg'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)", "note IH = \"1.IH\"(2)[OF Yield]"], ["proof (state)\nthis:\n  unstream (splice_trans g h) (splice_state.Left sg' ?sh) =\n  splice (unstream g sg') (unstream h ?sh)\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)", "have \"a # (unstream (splice_trans g h) (Right sg' sh)) = splice (unstream g sg) (unstream h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n    splice (unstream g sg) (unstream h sh)", "proof (induction sh taking: h rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator h s = Skip x2 \\<Longrightarrow>\n                   a #\n                   unstream (splice_trans g h) (splice_state.Right sg' x2) =\n                   splice (unstream g sg) (unstream h x2);\n        \\<And>x31 x32.\n           generator h s = Yield x31 x32 \\<Longrightarrow>\n           a # unstream (splice_trans g h) (splice_state.Right sg' x32) =\n           splice (unstream g sg) (unstream h x32)\\<rbrakk>\n       \\<Longrightarrow> a #\n                         unstream (splice_trans g h)\n                          (splice_state.Right sg' s) =\n                         splice (unstream g sg) (unstream h s)", "case (1 sh)"], ["proof (state)\nthis:\n  generator h sh = Skip ?x2.0 \\<Longrightarrow>\n  a # unstream (splice_trans g h) (splice_state.Right sg' ?x2.0) =\n  splice (unstream g sg) (unstream h ?x2.0)\n  generator h sh = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  a # unstream (splice_trans g h) (splice_state.Right sg' ?x32.0) =\n  splice (unstream g sg) (unstream h ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator h s = Skip x2 \\<Longrightarrow>\n                   a #\n                   unstream (splice_trans g h) (splice_state.Right sg' x2) =\n                   splice (unstream g sg) (unstream h x2);\n        \\<And>x31 x32.\n           generator h s = Yield x31 x32 \\<Longrightarrow>\n           a # unstream (splice_trans g h) (splice_state.Right sg' x32) =\n           splice (unstream g sg) (unstream h x32)\\<rbrakk>\n       \\<Longrightarrow> a #\n                         unstream (splice_trans g h)\n                          (splice_state.Right sg' s) =\n                         splice (unstream g sg) (unstream h s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n    splice (unstream g sg) (unstream h sh)", "proof (cases \"generator h sh\")"], ["proof (state)\ngoal (3 subgoals):\n 1. generator h sh = Done \\<Longrightarrow>\n    a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n    splice (unstream g sg) (unstream h sh)\n 2. \\<And>x2.\n       generator h sh = Skip x2 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)\n 3. \\<And>x31 x32.\n       generator h sh = Yield x31 x32 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)", "case Done"], ["proof (state)\nthis:\n  generator h sh = Done\n\ngoal (3 subgoals):\n 1. generator h sh = Done \\<Longrightarrow>\n    a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n    splice (unstream g sg) (unstream h sh)\n 2. \\<And>x2.\n       generator h sh = Skip x2 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)\n 3. \\<And>x31 x32.\n       generator h sh = Yield x31 x32 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)", "with unstream_splice_trans_Left_only[of g h sg']"], ["proof (chain)\npicking this:\n  unstream (splice_trans g h) (Left_only sg') = unstream g sg'\n  generator h sh = Done", "show ?thesis"], ["proof (prove)\nusing this:\n  unstream (splice_trans g h) (Left_only sg') = unstream g sg'\n  generator h sh = Done\n\ngoal (1 subgoal):\n 1. a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n    splice (unstream g sg) (unstream h sh)", "using Yield"], ["proof (prove)\nusing this:\n  unstream (splice_trans g h) (Left_only sg') = unstream g sg'\n  generator h sh = Done\n  generator g sg = Yield a sg'\n\ngoal (1 subgoal):\n 1. a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n    splice (unstream g sg) (unstream h sh)", "by (simp add: splice_trans.rep_eq)"], ["proof (state)\nthis:\n  a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n  splice (unstream g sg) (unstream h sh)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       generator h sh = Skip x2 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)\n 2. \\<And>x31 x32.\n       generator h sh = Yield x31 x32 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       generator h sh = Skip x2 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)\n 2. \\<And>x31 x32.\n       generator h sh = Yield x31 x32 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)", "case (Skip sh')"], ["proof (state)\nthis:\n  generator h sh = Skip sh'\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       generator h sh = Skip x2 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)\n 2. \\<And>x31 x32.\n       generator h sh = Yield x31 x32 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)", "then"], ["proof (chain)\npicking this:\n  generator h sh = Skip sh'", "show ?thesis"], ["proof (prove)\nusing this:\n  generator h sh = Skip sh'\n\ngoal (1 subgoal):\n 1. a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n    splice (unstream g sg) (unstream h sh)", "using Yield \"1.IH\"(1) \"1.prems\""], ["proof (prove)\nusing this:\n  generator h sh = Skip sh'\n  generator g sg = Yield a sg'\n  generator h sh = Skip ?x2.0 \\<Longrightarrow>\n  a # unstream (splice_trans g h) (splice_state.Right sg' ?x2.0) =\n  splice (unstream g sg) (unstream h ?x2.0)\n\ngoal (1 subgoal):\n 1. a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n    splice (unstream g sg) (unstream h sh)", "by(simp add: splice_trans.rep_eq)"], ["proof (state)\nthis:\n  a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n  splice (unstream g sg) (unstream h sh)\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       generator h sh = Yield x31 x32 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       generator h sh = Yield x31 x32 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)", "case (Yield b sh')"], ["proof (state)\nthis:\n  generator h sh = Yield b sh'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       generator h sh = Yield x31 x32 \\<Longrightarrow>\n       a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n       splice (unstream g sg) (unstream h sh)", "then"], ["proof (chain)\npicking this:\n  generator h sh = Yield b sh'", "show ?thesis"], ["proof (prove)\nusing this:\n  generator h sh = Yield b sh'\n\ngoal (1 subgoal):\n 1. a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n    splice (unstream g sg) (unstream h sh)", "using IH \\<open>generator g sg = Yield a sg'\\<close>"], ["proof (prove)\nusing this:\n  generator h sh = Yield b sh'\n  unstream (splice_trans g h) (splice_state.Left sg' ?sh) =\n  splice (unstream g sg') (unstream h ?sh)\n  generator g sg = Yield a sg'\n\ngoal (1 subgoal):\n 1. a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n    splice (unstream g sg) (unstream h sh)", "by (simp add: splice_trans.rep_eq)"], ["proof (state)\nthis:\n  a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n  splice (unstream g sg) (unstream h sh)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n  splice (unstream g sg) (unstream h sh)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n  splice (unstream g sg) (unstream h sh)\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 sh.\n                   generator g sg = Skip x2 \\<Longrightarrow>\n                   unstream (splice_trans g h) (splice_state.Left x2 sh) =\n                   splice (unstream g x2) (unstream h sh);\n        \\<And>x31 x32 sh.\n           generator g sg = Yield x31 x32 \\<Longrightarrow>\n           unstream (splice_trans g h) (splice_state.Left x32 sh) =\n           splice (unstream g x32) (unstream h sh);\n        generator g sg = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (splice_trans g h)\n                          (splice_state.Left sg sh) =\n                         splice (unstream g sg) (unstream h sh)", "then"], ["proof (chain)\npicking this:\n  a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n  splice (unstream g sg) (unstream h sh)", "show ?thesis"], ["proof (prove)\nusing this:\n  a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n  splice (unstream g sg) (unstream h sh)\n\ngoal (1 subgoal):\n 1. unstream (splice_trans g h) (splice_state.Left sg sh) =\n    splice (unstream g sg) (unstream h sh)", "using Yield"], ["proof (prove)\nusing this:\n  a # unstream (splice_trans g h) (splice_state.Right sg' sh) =\n  splice (unstream g sg) (unstream h sh)\n  generator g sg = Yield a sg'\n\ngoal (1 subgoal):\n 1. unstream (splice_trans g h) (splice_state.Left sg sh) =\n    splice (unstream g sg) (unstream h sh)", "by (simp add: splice_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (splice_trans g h) (splice_state.Left sg sh) =\n  splice (unstream g sg) (unstream h sh)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unstream (splice_trans g h) (splice_state.Left sg sh) =\n  splice (unstream g sg) (unstream h sh)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const list_update}\\<close>"], ["", "fun list_update_raw :: \"('a,'s) raw_generator \\<Rightarrow> 'a \\<Rightarrow> ('a, nat \\<times> 's) raw_generator\"\nwhere\n  \"list_update_raw g b (n, s) = (case g s of\n     Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (n, s') \n   | Yield a s' \\<Rightarrow> if n = 0 then Yield a (0,s')\n                   else if n = 1 then Yield b (0, s')\n                   else Yield a (n - 1, s'))\""], ["", "lemma terminates_list_update_raw:\n  assumes \"terminates g\"\n  shows \"terminates (list_update_raw g b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (list_update_raw g b)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (list_update_raw g b)", "fix st :: \"nat \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (list_update_raw g b)", "obtain n s where \"st = (n, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n s. st = (n, s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases st)"], ["proof (state)\nthis:\n  st = (n, s)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (list_update_raw g b)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (list_update_raw g b)", "then"], ["proof (chain)\npicking this:\n  s \\<in> terminates_on g", "show \"st \\<in> terminates_on (list_update_raw g b)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. st \\<in> terminates_on (list_update_raw g b)", "unfolding \\<open>st = (n, s)\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (n, s) \\<in> terminates_on (list_update_raw g b)", "proof (induction s arbitrary: n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s n.\n       g s = Done \\<Longrightarrow>\n       (n, s) \\<in> terminates_on (list_update_raw g b)\n 2. \\<And>s s' n.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (list_update_raw g b)\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (list_update_raw g b)\n 3. \\<And>s a s' n.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (list_update_raw g b)\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (list_update_raw g b)", "case (unfold s a s' n)"], ["proof (state)\nthis:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  (?n, s') \\<in> terminates_on (list_update_raw g b)\n\ngoal (3 subgoals):\n 1. \\<And>s n.\n       g s = Done \\<Longrightarrow>\n       (n, s) \\<in> terminates_on (list_update_raw g b)\n 2. \\<And>s s' n.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (list_update_raw g b)\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (list_update_raw g b)\n 3. \\<And>s a s' n.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (list_update_raw g b)\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (list_update_raw g b)", "then"], ["proof (chain)\npicking this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  (?n, s') \\<in> terminates_on (list_update_raw g b)", "show \"(n, s) \\<in> terminates_on (list_update_raw g b)\""], ["proof (prove)\nusing this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  (?n, s') \\<in> terminates_on (list_update_raw g b)\n\ngoal (1 subgoal):\n 1. (n, s) \\<in> terminates_on (list_update_raw g b)", "by(cases \"n = 0 \\<or> n = 1\")(auto intro: terminates_on.unfold)"], ["proof (state)\nthis:\n  (n, s) \\<in> terminates_on (list_update_raw g b)\n\ngoal (2 subgoals):\n 1. \\<And>s n.\n       g s = Done \\<Longrightarrow>\n       (n, s) \\<in> terminates_on (list_update_raw g b)\n 2. \\<And>s s' n.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>n. (n, s') \\<in> terminates_on (list_update_raw g b)\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> terminates_on (list_update_raw g b)", "qed(simp_all add: terminates_on.stop terminates_on.pause)"], ["proof (state)\nthis:\n  st \\<in> terminates_on (list_update_raw g b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition list_update_trans :: \"('a,'s) generator \\<Rightarrow> 'a \\<Rightarrow> ('a, nat \\<times> 's)  generator\"\nis \"list_update_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun a.\n       terminates fun \\<Longrightarrow> terminates (list_update_raw fun a)", "by (rule terminates_list_update_raw)"], ["", "lemma unstream_lift_update_trans_None: \"unstream (list_update_trans g b) (0, s) = unstream g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (list_update_trans g b) (0, s) = unstream g s", "proof(induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (0, x2) = unstream g x2;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (0, x32) =\n           unstream g x32\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (0, s) =\n                         unstream g s", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (0, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (0, ?x32.0) = unstream g ?x32.0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (0, x2) = unstream g x2;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (0, x32) =\n           unstream g x32\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (0, s) =\n                         unstream g s", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (0, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (0, ?x32.0) = unstream g ?x32.0", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (0, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (0, ?x32.0) = unstream g ?x32.0\n\ngoal (1 subgoal):\n 1. unstream (list_update_trans g b) (0, s) = unstream g s", "by (cases \"generator g s\")(simp_all add: list_update_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (list_update_trans g b) (0, s) = unstream g s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_list_update_trans [stream_fusion]:\n  \"unstream (list_update_trans g b) (Suc n, s) = list_update (unstream g s) n b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (list_update_trans g b) (Suc n, s) = (unstream g s)[n := b]", "proof(induction s arbitrary: n taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s n.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b]\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (Suc ?n, ?x2.0) = (unstream g ?x2.0)\n  [?n := b]\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (Suc ?n, ?x32.0) = (unstream g ?x32.0)\n  [?n := b]\n\ngoal (1 subgoal):\n 1. \\<And>s n.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b]\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (Suc ?n, ?x2.0) = (unstream g ?x2.0)\n  [?n := b]\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (Suc ?n, ?x32.0) = (unstream g ?x32.0)\n  [?n := b]", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (Suc ?n, ?x2.0) = (unstream g ?x2.0)\n  [?n := b]\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (Suc ?n, ?x32.0) = (unstream g ?x32.0)\n  [?n := b]\n\ngoal (1 subgoal):\n 1. unstream (list_update_trans g b) (Suc n, s) = (unstream g s)[n := b]", "proof (cases \"generator g s\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2 n.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (list_update_trans g b) (Suc n, x2) =\n                (unstream g x2)[n := b];\n     \\<And>x31 x32 n.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n        [n := b];\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                      (unstream g s)[n := b]\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]", "case Done"], ["proof (state)\nthis:\n  generator g s = Done\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2 n.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (list_update_trans g b) (Suc n, x2) =\n                (unstream g x2)[n := b];\n     \\<And>x31 x32 n.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n        [n := b];\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                      (unstream g s)[n := b]\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]", "then"], ["proof (chain)\npicking this:\n  generator g s = Done", "show ?thesis"], ["proof (prove)\nusing this:\n  generator g s = Done\n\ngoal (1 subgoal):\n 1. unstream (list_update_trans g b) (Suc n, s) = (unstream g s)[n := b]", "by (simp add: list_update_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (list_update_trans g b) (Suc n, s) = (unstream g s)[n := b]\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]\n 2. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]\n 2. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]", "case (Skip s')"], ["proof (state)\nthis:\n  generator g s = Skip s'\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]\n 2. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip s'", "show ?thesis"], ["proof (prove)\nusing this:\n  generator g s = Skip s'\n\ngoal (1 subgoal):\n 1. unstream (list_update_trans g b) (Suc n, s) = (unstream g s)[n := b]", "using \"1.IH\"(1)"], ["proof (prove)\nusing this:\n  generator g s = Skip s'\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (Suc ?n, ?x2.0) = (unstream g ?x2.0)\n  [?n := b]\n\ngoal (1 subgoal):\n 1. unstream (list_update_trans g b) (Suc n, s) = (unstream g s)[n := b]", "by (simp add: list_update_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (list_update_trans g b) (Suc n, s) = (unstream g s)[n := b]\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]", "case (Yield a s')"], ["proof (state)\nthis:\n  generator g s = Yield a s'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2 n.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (list_update_trans g b) (Suc n, x2) =\n                   (unstream g x2)[n := b];\n        \\<And>x31 x32 n.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (list_update_trans g b) (Suc n, x32) = (unstream g x32)\n           [n := b];\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (list_update_trans g b) (Suc n, s) =\n                         (unstream g s)[n := b]", "then"], ["proof (chain)\npicking this:\n  generator g s = Yield a s'", "show ?thesis"], ["proof (prove)\nusing this:\n  generator g s = Yield a s'\n\ngoal (1 subgoal):\n 1. unstream (list_update_trans g b) (Suc n, s) = (unstream g s)[n := b]", "using unstream_lift_update_trans_None[of g b s'] \"1.IH\"(2)"], ["proof (prove)\nusing this:\n  generator g s = Yield a s'\n  unstream (list_update_trans g b) (0, s') = unstream g s'\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (list_update_trans g b) (Suc ?n, ?x32.0) = (unstream g ?x32.0)\n  [?n := b]\n\ngoal (1 subgoal):\n 1. unstream (list_update_trans g b) (Suc n, s) = (unstream g s)[n := b]", "by (cases n)(simp_all add: list_update_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (list_update_trans g b) (Suc n, s) = (unstream g s)[n := b]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unstream (list_update_trans g b) (Suc n, s) = (unstream g s)[n := b]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const removeAll}\\<close>"], ["", "definition removeAll_raw :: \"'a \\<Rightarrow> ('a, 's) raw_generator \\<Rightarrow> ('a, 's) raw_generator\"\nwhere\n \"removeAll_raw b g s = (case g s of\n    Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip s' | Yield a s' \\<Rightarrow> if a = b then Skip s' else Yield a s')\""], ["", "lemma terminates_removeAll_raw:\n  assumes \"terminates g\"\n  shows \"terminates (removeAll_raw b g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (removeAll_raw b g)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (removeAll_raw b g)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (removeAll_raw b g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (removeAll_raw b g)", "then"], ["proof (chain)\npicking this:\n  s \\<in> terminates_on g", "show \"s \\<in> terminates_on (removeAll_raw b g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (removeAll_raw b g)", "proof(induction s)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       g s = Done \\<Longrightarrow>\n       s \\<in> terminates_on (removeAll_raw b g)\n 2. \\<And>s s'.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (removeAll_raw b g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (removeAll_raw b g)\n 3. \\<And>s a s'.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (removeAll_raw b g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (removeAll_raw b g)", "case (unfold s a s')"], ["proof (state)\nthis:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  s' \\<in> terminates_on (removeAll_raw b g)\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       g s = Done \\<Longrightarrow>\n       s \\<in> terminates_on (removeAll_raw b g)\n 2. \\<And>s s'.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (removeAll_raw b g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (removeAll_raw b g)\n 3. \\<And>s a s'.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (removeAll_raw b g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (removeAll_raw b g)", "then"], ["proof (chain)\npicking this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  s' \\<in> terminates_on (removeAll_raw b g)", "show ?case"], ["proof (prove)\nusing this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  s' \\<in> terminates_on (removeAll_raw b g)\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (removeAll_raw b g)", "by(cases \"a = b\")(auto intro: terminates_on.intros simp add: removeAll_raw_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (removeAll_raw b g)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       g s = Done \\<Longrightarrow>\n       s \\<in> terminates_on (removeAll_raw b g)\n 2. \\<And>s s'.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        s' \\<in> terminates_on (removeAll_raw b g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on (removeAll_raw b g)", "qed(auto intro: terminates_on.intros simp add: removeAll_raw_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (removeAll_raw b g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition removeAll_trans :: \"'a \\<Rightarrow> ('a, 's) generator \\<Rightarrow> ('a, 's) generator\"\nis \"removeAll_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fun.\n       terminates fun \\<Longrightarrow> terminates (removeAll_raw a fun)", "by (rule terminates_removeAll_raw)"], ["", "lemma unstream_removeAll_trans [stream_fusion]:\n  \"unstream (removeAll_trans b g) s = removeAll b (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (removeAll_trans b g) s = removeAll b (unstream g s)", "proof (induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (removeAll_trans b g) x2 =\n                   removeAll b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (removeAll_trans b g) x32 =\n           removeAll b (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (removeAll_trans b g) s =\n                         removeAll b (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (removeAll_trans b g) ?x2.0 = removeAll b (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (removeAll_trans b g) ?x32.0 = removeAll b (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (removeAll_trans b g) x2 =\n                   removeAll b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (removeAll_trans b g) x32 =\n           removeAll b (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (removeAll_trans b g) s =\n                         removeAll b (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (removeAll_trans b g) ?x2.0 = removeAll b (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (removeAll_trans b g) ?x32.0 = removeAll b (unstream g ?x32.0)", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (removeAll_trans b g) ?x2.0 = removeAll b (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (removeAll_trans b g) ?x32.0 = removeAll b (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (removeAll_trans b g) s = removeAll b (unstream g s)", "proof(cases \"generator g s\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (removeAll_trans b g) x2 =\n                removeAll b (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (removeAll_trans b g) x32 = removeAll b (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (removeAll_trans b g) s =\n                      removeAll b (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (removeAll_trans b g) x2 =\n                   removeAll b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (removeAll_trans b g) x32 =\n           removeAll b (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (removeAll_trans b g) s =\n                         removeAll b (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (removeAll_trans b g) x2 =\n                   removeAll b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (removeAll_trans b g) x32 =\n           removeAll b (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (removeAll_trans b g) s =\n                         removeAll b (unstream g s)", "case (Yield a s')"], ["proof (state)\nthis:\n  generator g s = Yield a s'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (removeAll_trans b g) x2 =\n                removeAll b (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (removeAll_trans b g) x32 = removeAll b (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (removeAll_trans b g) s =\n                      removeAll b (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (removeAll_trans b g) x2 =\n                   removeAll b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (removeAll_trans b g) x32 =\n           removeAll b (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (removeAll_trans b g) s =\n                         removeAll b (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (removeAll_trans b g) x2 =\n                   removeAll b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (removeAll_trans b g) x32 =\n           removeAll b (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (removeAll_trans b g) s =\n                         removeAll b (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Yield a s'", "show ?thesis"], ["proof (prove)\nusing this:\n  generator g s = Yield a s'\n\ngoal (1 subgoal):\n 1. unstream (removeAll_trans b g) s = removeAll b (unstream g s)", "using \"1.IH\"(2)"], ["proof (prove)\nusing this:\n  generator g s = Yield a s'\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (removeAll_trans b g) ?x32.0 = removeAll b (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (removeAll_trans b g) s = removeAll b (unstream g s)", "by(cases \"a = b\")(simp_all add: removeAll_trans.rep_eq removeAll_raw_def)"], ["proof (state)\nthis:\n  unstream (removeAll_trans b g) s = removeAll b (unstream g s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (removeAll_trans b g) x2 =\n                removeAll b (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (removeAll_trans b g) x32 = removeAll b (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (removeAll_trans b g) s =\n                      removeAll b (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (removeAll_trans b g) x2 =\n                   removeAll b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (removeAll_trans b g) x32 =\n           removeAll b (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (removeAll_trans b g) s =\n                         removeAll b (unstream g s)", "qed(auto simp add: removeAll_trans.rep_eq removeAll_raw_def)"], ["proof (state)\nthis:\n  unstream (removeAll_trans b g) s = removeAll b (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const remove1}\\<close>"], ["", "fun remove1_raw :: \"'a \\<Rightarrow> ('a, 's) raw_generator \\<Rightarrow> ('a, bool \\<times> 's) raw_generator\"\nwhere\n  \"remove1_raw x g (b, s) = (case g s of\n     Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (b, s') \n   | Yield y s' \\<Rightarrow> if b \\<and> x = y then Skip (False, s') else Yield y (b, s'))\""], ["", "lemma terminates_remove1_raw: \n  assumes \"terminates g\"\n  shows \"terminates (remove1_raw b g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (remove1_raw b g)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (remove1_raw b g)", "fix st :: \"bool \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (remove1_raw b g)", "obtain c s where \"st = (c, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c s. st = (c, s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases st)"], ["proof (state)\nthis:\n  st = (c, s)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (remove1_raw b g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (remove1_raw b g)", "then"], ["proof (chain)\npicking this:\n  s \\<in> terminates_on g", "show \"st \\<in> terminates_on (remove1_raw b g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. st \\<in> terminates_on (remove1_raw b g)", "unfolding \\<open>st = (c, s)\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (c, s) \\<in> terminates_on (remove1_raw b g)", "proof (induction s arbitrary: c)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s c.\n       g s = Done \\<Longrightarrow>\n       (c, s) \\<in> terminates_on (remove1_raw b g)\n 2. \\<And>s s' c.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)\n 3. \\<And>s a s' c.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)", "case (stop s)"], ["proof (state)\nthis:\n  g s = Done\n\ngoal (3 subgoals):\n 1. \\<And>s c.\n       g s = Done \\<Longrightarrow>\n       (c, s) \\<in> terminates_on (remove1_raw b g)\n 2. \\<And>s s' c.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)\n 3. \\<And>s a s' c.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)", "then"], ["proof (chain)\npicking this:\n  g s = Done", "show ?case"], ["proof (prove)\nusing this:\n  g s = Done\n\ngoal (1 subgoal):\n 1. (c, s) \\<in> terminates_on (remove1_raw b g)", "by (cases c)(simp_all add: terminates_on.stop)"], ["proof (state)\nthis:\n  (c, s) \\<in> terminates_on (remove1_raw b g)\n\ngoal (2 subgoals):\n 1. \\<And>s s' c.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)\n 2. \\<And>s a s' c.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s' c.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)\n 2. \\<And>s a s' c.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)", "case (pause s s')"], ["proof (state)\nthis:\n  g s = Skip s'\n  s' \\<in> terminates_on g\n  (?c, s') \\<in> terminates_on (remove1_raw b g)\n\ngoal (2 subgoals):\n 1. \\<And>s s' c.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)\n 2. \\<And>s a s' c.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)", "then"], ["proof (chain)\npicking this:\n  g s = Skip s'\n  s' \\<in> terminates_on g\n  (?c, s') \\<in> terminates_on (remove1_raw b g)", "show ?case"], ["proof (prove)\nusing this:\n  g s = Skip s'\n  s' \\<in> terminates_on g\n  (?c, s') \\<in> terminates_on (remove1_raw b g)\n\ngoal (1 subgoal):\n 1. (c, s) \\<in> terminates_on (remove1_raw b g)", "by (cases c)(simp_all add: terminates_on.pause)"], ["proof (state)\nthis:\n  (c, s) \\<in> terminates_on (remove1_raw b g)\n\ngoal (1 subgoal):\n 1. \\<And>s a s' c.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a s' c.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)", "case (unfold s a s')"], ["proof (state)\nthis:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  (?c, s') \\<in> terminates_on (remove1_raw b g)\n\ngoal (1 subgoal):\n 1. \\<And>s a s' c.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>c. (c, s') \\<in> terminates_on (remove1_raw b g)\\<rbrakk>\n       \\<Longrightarrow> (c, s) \\<in> terminates_on (remove1_raw b g)", "then"], ["proof (chain)\npicking this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  (?c, s') \\<in> terminates_on (remove1_raw b g)", "show ?case"], ["proof (prove)\nusing this:\n  g s = Yield a s'\n  s' \\<in> terminates_on g\n  (?c, s') \\<in> terminates_on (remove1_raw b g)\n\ngoal (1 subgoal):\n 1. (c, s) \\<in> terminates_on (remove1_raw b g)", "by(cases c)(cases \"a = b\", auto intro: terminates_on.intros)"], ["proof (state)\nthis:\n  (c, s) \\<in> terminates_on (remove1_raw b g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  st \\<in> terminates_on (remove1_raw b g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition remove1_trans :: \"'a \\<Rightarrow> ('a, 's) generator \\<Rightarrow> ('a, bool \\<times> 's) generator \"\nis \"remove1_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fun.\n       terminates fun \\<Longrightarrow> terminates (remove1_raw a fun)", "by (rule terminates_remove1_raw)"], ["", "lemma unstream_remove1_trans_False: \"unstream (remove1_trans b g) (False, s) = unstream g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (remove1_trans b g) (False, s) = unstream g s", "proof (induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (remove1_trans b g) (False, x2) = unstream g x2;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (remove1_trans b g) (False, x32) =\n           unstream g x32\\<rbrakk>\n       \\<Longrightarrow> unstream (remove1_trans b g) (False, s) =\n                         unstream g s", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (False, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (False, ?x32.0) = unstream g ?x32.0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (remove1_trans b g) (False, x2) = unstream g x2;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (remove1_trans b g) (False, x32) =\n           unstream g x32\\<rbrakk>\n       \\<Longrightarrow> unstream (remove1_trans b g) (False, s) =\n                         unstream g s", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (False, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (False, ?x32.0) = unstream g ?x32.0", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (False, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (False, ?x32.0) = unstream g ?x32.0\n\ngoal (1 subgoal):\n 1. unstream (remove1_trans b g) (False, s) = unstream g s", "by (cases \"generator g s\")(simp_all add: remove1_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (remove1_trans b g) (False, s) = unstream g s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_remove1_trans [stream_fusion]:\n  \"unstream (remove1_trans b g) (True, s) = remove1 b (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (remove1_trans b g) (True, s) = remove1 b (unstream g s)", "proof(induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (remove1_trans b g) (True, x2) =\n                   remove1 b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (remove1_trans b g) (True, x32) =\n           remove1 b (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (remove1_trans b g) (True, s) =\n                         remove1 b (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (True, ?x2.0) = remove1 b (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (True, ?x32.0) =\n  remove1 b (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (remove1_trans b g) (True, x2) =\n                   remove1 b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (remove1_trans b g) (True, x32) =\n           remove1 b (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (remove1_trans b g) (True, s) =\n                         remove1 b (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (True, ?x2.0) = remove1 b (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (True, ?x32.0) =\n  remove1 b (unstream g ?x32.0)", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (True, ?x2.0) = remove1 b (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (True, ?x32.0) =\n  remove1 b (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (remove1_trans b g) (True, s) = remove1 b (unstream g s)", "proof (cases \"generator g s\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (remove1_trans b g) (True, x2) =\n                remove1 b (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (remove1_trans b g) (True, x32) =\n        remove1 b (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (remove1_trans b g) (True, s) =\n                      remove1 b (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (remove1_trans b g) (True, x2) =\n                   remove1 b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (remove1_trans b g) (True, x32) =\n           remove1 b (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (remove1_trans b g) (True, s) =\n                         remove1 b (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (remove1_trans b g) (True, x2) =\n                   remove1 b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (remove1_trans b g) (True, x32) =\n           remove1 b (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (remove1_trans b g) (True, s) =\n                         remove1 b (unstream g s)", "case (Yield a s')"], ["proof (state)\nthis:\n  generator g s = Yield a s'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (remove1_trans b g) (True, x2) =\n                remove1 b (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (remove1_trans b g) (True, x32) =\n        remove1 b (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (remove1_trans b g) (True, s) =\n                      remove1 b (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (remove1_trans b g) (True, x2) =\n                   remove1 b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (remove1_trans b g) (True, x32) =\n           remove1 b (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (remove1_trans b g) (True, s) =\n                         remove1 b (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (remove1_trans b g) (True, x2) =\n                   remove1 b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (remove1_trans b g) (True, x32) =\n           remove1 b (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (remove1_trans b g) (True, s) =\n                         remove1 b (unstream g s)", "then"], ["proof (chain)\npicking this:\n  generator g s = Yield a s'", "show ?thesis"], ["proof (prove)\nusing this:\n  generator g s = Yield a s'\n\ngoal (1 subgoal):\n 1. unstream (remove1_trans b g) (True, s) = remove1 b (unstream g s)", "using Yield \"1.IH\"(2) unstream_remove1_trans_False[of b g]"], ["proof (prove)\nusing this:\n  generator g s = Yield a s'\n  generator g s = Yield a s'\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (remove1_trans b g) (True, ?x32.0) =\n  remove1 b (unstream g ?x32.0)\n  unstream (remove1_trans b g) (False, ?s) = unstream g ?s\n\ngoal (1 subgoal):\n 1. unstream (remove1_trans b g) (True, s) = remove1 b (unstream g s)", "by (cases \"a = b\")(simp_all add: remove1_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (remove1_trans b g) (True, s) = remove1 b (unstream g s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (remove1_trans b g) (True, x2) =\n                remove1 b (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (remove1_trans b g) (True, x32) =\n        remove1 b (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (remove1_trans b g) (True, s) =\n                      remove1 b (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (remove1_trans b g) (True, x2) =\n                   remove1 b (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (remove1_trans b g) (True, x32) =\n           remove1 b (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (remove1_trans b g) (True, s) =\n                         remove1 b (unstream g s)", "qed(simp_all add: remove1_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (remove1_trans b g) (True, s) = remove1 b (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{term \"(#)\"}\\<close>"], ["", "fun Cons_raw :: \"'a \\<Rightarrow> ('a, 's) raw_generator \\<Rightarrow> ('a, bool \\<times> 's) raw_generator\"\nwhere\n  \"Cons_raw x g (b, s) = (if b then Yield x (False, s) else case g s of\n    Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (False, s') | Yield y s' \\<Rightarrow> Yield y (False, s'))\""], ["", "lemma terminates_Cons_raw: \n  assumes \"terminates g\"\n  shows \"terminates (Cons_raw x g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (Cons_raw x g)", "proof (rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (Cons_raw x g)", "fix st :: \"bool \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (Cons_raw x g)", "obtain b s where \"st = (b, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b s. st = (b, s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases st)"], ["proof (state)\nthis:\n  st = (b, s)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (Cons_raw x g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (Cons_raw x g)", "hence \"(False, s) \\<in> terminates_on (Cons_raw x g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (False, s) \\<in> terminates_on (Cons_raw x g)", "by(induction s arbitrary: b)(auto intro: terminates_on.intros)"], ["proof (state)\nthis:\n  (False, s) \\<in> terminates_on (Cons_raw x g)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (Cons_raw x g)", "then"], ["proof (chain)\npicking this:\n  (False, s) \\<in> terminates_on (Cons_raw x g)", "show \"st \\<in> terminates_on (Cons_raw x g)\""], ["proof (prove)\nusing this:\n  (False, s) \\<in> terminates_on (Cons_raw x g)\n\ngoal (1 subgoal):\n 1. st \\<in> terminates_on (Cons_raw x g)", "unfolding \\<open>st = (b, s)\\<close>"], ["proof (prove)\nusing this:\n  (False, s) \\<in> terminates_on (Cons_raw x g)\n\ngoal (1 subgoal):\n 1. (b, s) \\<in> terminates_on (Cons_raw x g)", "by(cases b)(auto intro: terminates_on.intros)"], ["proof (state)\nthis:\n  st \\<in> terminates_on (Cons_raw x g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition Cons_trans :: \"'a \\<Rightarrow> ('a, 's) generator \\<Rightarrow> ('a, bool \\<times> 's) generator\"\nis Cons_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fun.\n       terminates fun \\<Longrightarrow> terminates (Cons_raw a fun)", "by(rule terminates_Cons_raw)"], ["", "lemma unstream_Cons_trans_False: \"unstream (Cons_trans x g) (False, s) = unstream g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (Cons_trans x g) (False, s) = unstream g s", "proof(induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (Cons_trans x g) (False, x2) = unstream g x2;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (Cons_trans x g) (False, x32) = unstream g x32\\<rbrakk>\n       \\<Longrightarrow> unstream (Cons_trans x g) (False, s) = unstream g s", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (Cons_trans x g) (False, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (Cons_trans x g) (False, ?x32.0) = unstream g ?x32.0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (Cons_trans x g) (False, x2) = unstream g x2;\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (Cons_trans x g) (False, x32) = unstream g x32\\<rbrakk>\n       \\<Longrightarrow> unstream (Cons_trans x g) (False, s) = unstream g s", "then"], ["proof (chain)\npicking this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (Cons_trans x g) (False, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (Cons_trans x g) (False, ?x32.0) = unstream g ?x32.0", "show ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (Cons_trans x g) (False, ?x2.0) = unstream g ?x2.0\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (Cons_trans x g) (False, ?x32.0) = unstream g ?x32.0\n\ngoal (1 subgoal):\n 1. unstream (Cons_trans x g) (False, s) = unstream g s", "by(cases \"generator g s\")(auto simp add: Cons_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (Cons_trans x g) (False, s) = unstream g s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We do not declare @{const Cons_trans} as a transformer.\n  Otherwise, literal lists would be transformed into streams which adds a significant overhead\n  to the stream state.\n\\<close>"], ["", "lemma unstream_Cons_trans: \"unstream (Cons_trans x g) (True, s) = x # unstream g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (Cons_trans x g) (True, s) = x # unstream g s", "using unstream_Cons_trans_False[of x g s]"], ["proof (prove)\nusing this:\n  unstream (Cons_trans x g) (False, s) = unstream g s\n\ngoal (1 subgoal):\n 1. unstream (Cons_trans x g) (True, s) = x # unstream g s", "by(simp add: Cons_trans.rep_eq)"], ["", "subsubsection \\<open>@{const List.maps}\\<close>"], ["", "text \\<open>Stream version based on Coutts \\cite{Coutts2010PhD}.\\<close>"], ["", "text \\<open>\n  We restrict the function for generating the inner lists to terminating\n  generators because the code generator does not directly supported nesting abstract\n  datatypes in other types.\n\\<close>"], ["", "fun maps_raw\n  :: \"('a \\<Rightarrow> ('b, 'sg) generator \\<times> 'sg) \\<Rightarrow> ('a, 's) raw_generator\n  \\<Rightarrow> ('b, 's \\<times> (('b, 'sg) generator \\<times> 'sg) option) raw_generator\"\nwhere\n  \"maps_raw f g (s, None) = (case g s of\n    Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (s', None) | Yield x s' \\<Rightarrow> Skip (s', Some (f x)))\"\n| \"maps_raw f g (s, Some (g'', s'')) = (case generator g'' s'' of\n    Done \\<Rightarrow> Skip (s, None) | Skip s' \\<Rightarrow> Skip (s, Some (g'', s')) | Yield x s' \\<Rightarrow> Yield x (s, Some (g'', s')))\""], ["", "lemma terminates_on_maps_raw_Some: \n  assumes \"(s, None) \\<in> terminates_on (maps_raw f g)\"\n  shows \"(s, Some (g'', s'')) \\<in> terminates_on (maps_raw f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, Some (g'', s'')) \\<in> terminates_on (maps_raw f g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (s, Some (g'', s'')) \\<in> terminates_on (maps_raw f g)", "from generator[of g'']"], ["proof (chain)\npicking this:\n  generator g'' \\<in> {g. terminates g}", "have \"s'' \\<in> terminates_on (generator g'')\""], ["proof (prove)\nusing this:\n  generator g'' \\<in> {g. terminates g}\n\ngoal (1 subgoal):\n 1. s'' \\<in> terminates_on (generator g'')", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s'' \\<in> terminates_on (generator g'')\n\ngoal (1 subgoal):\n 1. (s, Some (g'', s'')) \\<in> terminates_on (maps_raw f g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  s'' \\<in> terminates_on (generator g'')\n\ngoal (1 subgoal):\n 1. (s, Some (g'', s'')) \\<in> terminates_on (maps_raw f g)", "by(induction)(auto intro: terminates_on.intros assms)"], ["proof (state)\nthis:\n  (s, Some (g'', s'')) \\<in> terminates_on (maps_raw f g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma terminates_maps_raw: \n  assumes \"terminates g\"\n  shows \"terminates (maps_raw f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (maps_raw f g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (maps_raw f g)", "fix st :: \"'a \\<times> (('c, 'd) generator \\<times> 'd) option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (maps_raw f g)", "obtain s mgs where \"st = (s, mgs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s mgs. st = (s, mgs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases st)"], ["proof (state)\nthis:\n  st = (s, mgs)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (maps_raw f g)", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (maps_raw f g)", "then"], ["proof (chain)\npicking this:\n  s \\<in> terminates_on g", "show \"st \\<in> terminates_on (maps_raw f g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. st \\<in> terminates_on (maps_raw f g)", "unfolding \\<open>st = (s, mgs)\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (s, mgs) \\<in> terminates_on (maps_raw f g)", "apply(induction arbitrary: mgs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s mgs.\n       g s = Done \\<Longrightarrow>\n       (s, mgs) \\<in> terminates_on (maps_raw f g)\n 2. \\<And>s s' mgs.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>mgs. (s', mgs) \\<in> terminates_on (maps_raw f g)\\<rbrakk>\n       \\<Longrightarrow> (s, mgs) \\<in> terminates_on (maps_raw f g)\n 3. \\<And>s a s' mgs.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>mgs. (s', mgs) \\<in> terminates_on (maps_raw f g)\\<rbrakk>\n       \\<Longrightarrow> (s, mgs) \\<in> terminates_on (maps_raw f g)", "apply(case_tac [!] mgs)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s mgs.\n       \\<lbrakk>g s = Done; mgs = None\\<rbrakk>\n       \\<Longrightarrow> (s, mgs) \\<in> terminates_on (maps_raw f g)\n 2. \\<And>s mgs a.\n       \\<lbrakk>g s = Done; mgs = Some a\\<rbrakk>\n       \\<Longrightarrow> (s, mgs) \\<in> terminates_on (maps_raw f g)\n 3. \\<And>s s' mgs.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>mgs. (s', mgs) \\<in> terminates_on (maps_raw f g);\n        mgs = None\\<rbrakk>\n       \\<Longrightarrow> (s, mgs) \\<in> terminates_on (maps_raw f g)\n 4. \\<And>s s' mgs a.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>mgs. (s', mgs) \\<in> terminates_on (maps_raw f g);\n        mgs = Some a\\<rbrakk>\n       \\<Longrightarrow> (s, mgs) \\<in> terminates_on (maps_raw f g)\n 5. \\<And>s a s' mgs.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>mgs. (s', mgs) \\<in> terminates_on (maps_raw f g);\n        mgs = None\\<rbrakk>\n       \\<Longrightarrow> (s, mgs) \\<in> terminates_on (maps_raw f g)\n 6. \\<And>s a s' mgs aa.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>mgs. (s', mgs) \\<in> terminates_on (maps_raw f g);\n        mgs = Some aa\\<rbrakk>\n       \\<Longrightarrow> (s, mgs) \\<in> terminates_on (maps_raw f g)", "apply(auto intro: terminates_on.intros intro!: terminates_on_maps_raw_Some)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  st \\<in> terminates_on (maps_raw f g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition maps_trans :: \"('a \\<Rightarrow> ('b, 'sg) generator \\<times> 'sg) \\<Rightarrow> ('a, 's) generator\n  \\<Rightarrow> ('b, 's \\<times> (('b, 'sg) generator \\<times> 'sg) option) generator\"\nis \"maps_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       terminates fun2 \\<Longrightarrow> terminates (maps_raw fun1 fun2)", "by(rule terminates_maps_raw)"], ["", "lemma unstream_maps_trans_Some:\n  \"unstream (maps_trans f g) (s, Some (g'', s'')) = unstream g'' s'' @ unstream (maps_trans f g) (s, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (maps_trans f g) (s, Some (g'', s'')) =\n    unstream g'' s'' @ unstream (maps_trans f g) (s, None)", "proof(induction s'' taking: g'' rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>\\<And>x2.\n                   generator g'' sa = Skip x2 \\<Longrightarrow>\n                   unstream (maps_trans f g) (s, Some (g'', x2)) =\n                   unstream g'' x2 @ unstream (maps_trans f g) (s, None);\n        \\<And>x31 x32.\n           generator g'' sa = Yield x31 x32 \\<Longrightarrow>\n           unstream (maps_trans f g) (s, Some (g'', x32)) =\n           unstream g'' x32 @ unstream (maps_trans f g) (s, None)\\<rbrakk>\n       \\<Longrightarrow> unstream (maps_trans f g) (s, Some (g'', sa)) =\n                         unstream g'' sa @\n                         unstream (maps_trans f g) (s, None)", "case (1 s'')"], ["proof (state)\nthis:\n  generator g'' s'' = Skip ?x2.0 \\<Longrightarrow>\n  unstream (maps_trans f g) (s, Some (g'', ?x2.0)) =\n  unstream g'' ?x2.0 @ unstream (maps_trans f g) (s, None)\n  generator g'' s'' = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (maps_trans f g) (s, Some (g'', ?x32.0)) =\n  unstream g'' ?x32.0 @ unstream (maps_trans f g) (s, None)\n\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>\\<And>x2.\n                   generator g'' sa = Skip x2 \\<Longrightarrow>\n                   unstream (maps_trans f g) (s, Some (g'', x2)) =\n                   unstream g'' x2 @ unstream (maps_trans f g) (s, None);\n        \\<And>x31 x32.\n           generator g'' sa = Yield x31 x32 \\<Longrightarrow>\n           unstream (maps_trans f g) (s, Some (g'', x32)) =\n           unstream g'' x32 @ unstream (maps_trans f g) (s, None)\\<rbrakk>\n       \\<Longrightarrow> unstream (maps_trans f g) (s, Some (g'', sa)) =\n                         unstream g'' sa @\n                         unstream (maps_trans f g) (s, None)", "then"], ["proof (chain)\npicking this:\n  generator g'' s'' = Skip ?x2.0 \\<Longrightarrow>\n  unstream (maps_trans f g) (s, Some (g'', ?x2.0)) =\n  unstream g'' ?x2.0 @ unstream (maps_trans f g) (s, None)\n  generator g'' s'' = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (maps_trans f g) (s, Some (g'', ?x32.0)) =\n  unstream g'' ?x32.0 @ unstream (maps_trans f g) (s, None)", "show ?case"], ["proof (prove)\nusing this:\n  generator g'' s'' = Skip ?x2.0 \\<Longrightarrow>\n  unstream (maps_trans f g) (s, Some (g'', ?x2.0)) =\n  unstream g'' ?x2.0 @ unstream (maps_trans f g) (s, None)\n  generator g'' s'' = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (maps_trans f g) (s, Some (g'', ?x32.0)) =\n  unstream g'' ?x32.0 @ unstream (maps_trans f g) (s, None)\n\ngoal (1 subgoal):\n 1. unstream (maps_trans f g) (s, Some (g'', s'')) =\n    unstream g'' s'' @ unstream (maps_trans f g) (s, None)", "by(cases \"generator g'' s''\")(simp_all add: maps_trans.rep_eq)"], ["proof (state)\nthis:\n  unstream (maps_trans f g) (s, Some (g'', s'')) =\n  unstream g'' s'' @ unstream (maps_trans f g) (s, None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unstream_maps_trans:\n  \"unstream (maps_trans f g) (s, None) = List.maps (case_prod unstream \\<circ> f) (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (maps_trans f g) (s, None) =\n    List.maps ((\\<lambda>(x, y). unstream x y) \\<circ> f) (unstream g s)", "proof(induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (maps_trans f g) (x2, None) =\n                   List.maps\n                    ((\\<lambda>a.\n                         case a of\n                         (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                     f)\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (maps_trans f g) (x32, None) =\n           List.maps\n            ((\\<lambda>a.\n                 case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n             f)\n            (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (maps_trans f g) (s, None) =\n                         List.maps\n                          ((\\<lambda>a.\n                               case a of\n                               (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                           f)\n                          (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (maps_trans f g) (?x2.0, None) =\n  List.maps\n   ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ> f)\n   (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (maps_trans f g) (?x32.0, None) =\n  List.maps\n   ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ> f)\n   (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (maps_trans f g) (x2, None) =\n                   List.maps\n                    ((\\<lambda>a.\n                         case a of\n                         (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                     f)\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (maps_trans f g) (x32, None) =\n           List.maps\n            ((\\<lambda>a.\n                 case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n             f)\n            (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (maps_trans f g) (s, None) =\n                         List.maps\n                          ((\\<lambda>a.\n                               case a of\n                               (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                           f)\n                          (unstream g s)", "thus ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (maps_trans f g) (?x2.0, None) =\n  List.maps\n   ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ> f)\n   (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (maps_trans f g) (?x32.0, None) =\n  List.maps\n   ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ> f)\n   (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (maps_trans f g) (s, None) =\n    List.maps\n     ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ> f)\n     (unstream g s)", "proof(cases \"generator g s\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (maps_trans f g) (x2, None) =\n                List.maps\n                 ((\\<lambda>a.\n                      case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                  f)\n                 (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (maps_trans f g) (x32, None) =\n        List.maps\n         ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n          f)\n         (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (maps_trans f g) (s, None) =\n                      List.maps\n                       ((\\<lambda>a.\n                            case a of\n                            (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                        f)\n                       (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (maps_trans f g) (x2, None) =\n                   List.maps\n                    ((\\<lambda>a.\n                         case a of\n                         (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                     f)\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (maps_trans f g) (x32, None) =\n           List.maps\n            ((\\<lambda>a.\n                 case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n             f)\n            (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (maps_trans f g) (s, None) =\n                         List.maps\n                          ((\\<lambda>a.\n                               case a of\n                               (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                           f)\n                          (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (maps_trans f g) (x2, None) =\n                   List.maps\n                    ((\\<lambda>a.\n                         case a of\n                         (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                     f)\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (maps_trans f g) (x32, None) =\n           List.maps\n            ((\\<lambda>a.\n                 case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n             f)\n            (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (maps_trans f g) (s, None) =\n                         List.maps\n                          ((\\<lambda>a.\n                               case a of\n                               (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                           f)\n                          (unstream g s)", "case (Yield x s')"], ["proof (state)\nthis:\n  generator g s = Yield x s'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (maps_trans f g) (x2, None) =\n                List.maps\n                 ((\\<lambda>a.\n                      case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                  f)\n                 (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (maps_trans f g) (x32, None) =\n        List.maps\n         ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n          f)\n         (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (maps_trans f g) (s, None) =\n                      List.maps\n                       ((\\<lambda>a.\n                            case a of\n                            (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                        f)\n                       (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (maps_trans f g) (x2, None) =\n                   List.maps\n                    ((\\<lambda>a.\n                         case a of\n                         (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                     f)\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (maps_trans f g) (x32, None) =\n           List.maps\n            ((\\<lambda>a.\n                 case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n             f)\n            (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (maps_trans f g) (s, None) =\n                         List.maps\n                          ((\\<lambda>a.\n                               case a of\n                               (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                           f)\n                          (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (maps_trans f g) (x2, None) =\n                   List.maps\n                    ((\\<lambda>a.\n                         case a of\n                         (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                     f)\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (maps_trans f g) (x32, None) =\n           List.maps\n            ((\\<lambda>a.\n                 case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n             f)\n            (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (maps_trans f g) (s, None) =\n                         List.maps\n                          ((\\<lambda>a.\n                               case a of\n                               (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                           f)\n                          (unstream g s)", "with \"1.IH\"(2)[OF this]"], ["proof (chain)\npicking this:\n  unstream (maps_trans f g) (s', None) =\n  List.maps\n   ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ> f)\n   (unstream g s')\n  generator g s = Yield x s'", "show ?thesis"], ["proof (prove)\nusing this:\n  unstream (maps_trans f g) (s', None) =\n  List.maps\n   ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ> f)\n   (unstream g s')\n  generator g s = Yield x s'\n\ngoal (1 subgoal):\n 1. unstream (maps_trans f g) (s, None) =\n    List.maps\n     ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ> f)\n     (unstream g s)", "using unstream_maps_trans_Some[of f g _ \"fst (f x)\" \"snd (f x)\"]"], ["proof (prove)\nusing this:\n  unstream (maps_trans f g) (s', None) =\n  List.maps\n   ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ> f)\n   (unstream g s')\n  generator g s = Yield x s'\n  unstream (maps_trans f g) (?s, Some (fst (f x), snd (f x))) =\n  unstream (fst (f x)) (snd (f x)) @ unstream (maps_trans f g) (?s, None)\n\ngoal (1 subgoal):\n 1. unstream (maps_trans f g) (s, None) =\n    List.maps\n     ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ> f)\n     (unstream g s)", "by(simp add: maps_trans.rep_eq maps_simps split_def)"], ["proof (state)\nthis:\n  unstream (maps_trans f g) (s, None) =\n  List.maps\n   ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ> f)\n   (unstream g s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (maps_trans f g) (x2, None) =\n                List.maps\n                 ((\\<lambda>a.\n                      case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                  f)\n                 (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (maps_trans f g) (x32, None) =\n        List.maps\n         ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n          f)\n         (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (maps_trans f g) (s, None) =\n                      List.maps\n                       ((\\<lambda>a.\n                            case a of\n                            (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                        f)\n                       (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (maps_trans f g) (x2, None) =\n                   List.maps\n                    ((\\<lambda>a.\n                         case a of\n                         (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                     f)\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (maps_trans f g) (x32, None) =\n           List.maps\n            ((\\<lambda>a.\n                 case a of (a, b) \\<Rightarrow> unstream a b) \\<circ>\n             f)\n            (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (maps_trans f g) (s, None) =\n                         List.maps\n                          ((\\<lambda>a.\n                               case a of\n                               (a, b) \\<Rightarrow> unstream a b) \\<circ>\n                           f)\n                          (unstream g s)", "qed(simp_all add: maps_trans.rep_eq maps_simps)"], ["proof (state)\nthis:\n  unstream (maps_trans f g) (s, None) =\n  List.maps\n   ((\\<lambda>a. case a of (a, b) \\<Rightarrow> unstream a b) \\<circ> f)\n   (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The rule @{thm [source] unstream_map_trans} is too complicated for fusion because of @{term split},\n  which does not arise naturally from stream fusion rules. Moreover, according to Farmer et al.\n  \\cite{FarmerHoenerGill2014PEPM}, this fusion is too general for further optimisations because the\n  generators of the inner list are generated by the outer generator and therefore compilers may\n  think that is was not known statically. \n\n  Instead, they propose a weaker version using \\<open>flatten\\<close> below.\n  (More precisely, Coutts already mentions this approach in his PhD thesis \\cite{Coutts2010PhD},\n  but dismisses it because it requires a stronger rewriting engine than GHC has. But Isabelle's\n  simplifier language is sufficiently powerful.\n\\<close>"], ["", "fun fix_step :: \"'a \\<Rightarrow> ('b, 's) step \\<Rightarrow> ('b, 'a \\<times> 's) step\"\nwhere\n  \"fix_step a Done = Done\"\n| \"fix_step a (Skip s) = Skip (a, s)\"\n| \"fix_step a (Yield x s) = Yield x (a, s)\""], ["", "fun fix_gen_raw :: \"('a \\<Rightarrow> ('b, 's) raw_generator) \\<Rightarrow> ('b, 'a \\<times> 's) raw_generator\"\nwhere \"fix_gen_raw g (a, s) = fix_step a (g a s)\""], ["", "lemma terminates_fix_gen_raw:\n  assumes \"\\<And>x. terminates (g x)\"\n  shows \"terminates (fix_gen_raw g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (fix_gen_raw g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (fix_gen_raw g)", "fix st :: \"'a \\<times> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (fix_gen_raw g)", "obtain a s where \"st = (a, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a s. st = (a, s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases st)"], ["proof (state)\nthis:\n  st = (a, s)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (fix_gen_raw g)", "from assms[of a]"], ["proof (chain)\npicking this:\n  terminates (g a)", "have \"s \\<in> terminates_on (g a)\""], ["proof (prove)\nusing this:\n  terminates (g a)\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on (g a)", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on (g a)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (fix_gen_raw g)", "then"], ["proof (chain)\npicking this:\n  s \\<in> terminates_on (g a)", "show \"st \\<in> terminates_on (fix_gen_raw g)\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on (g a)\n\ngoal (1 subgoal):\n 1. st \\<in> terminates_on (fix_gen_raw g)", "unfolding \\<open>st = (a, s)\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> terminates_on (g a)\n\ngoal (1 subgoal):\n 1. (a, s) \\<in> terminates_on (fix_gen_raw g)", "by(induction)(auto intro: terminates_on.intros)"], ["proof (state)\nthis:\n  st \\<in> terminates_on (fix_gen_raw g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition fix_gen :: \"('a \\<Rightarrow> ('b, 's) generator) \\<Rightarrow> ('b, 'a \\<times> 's) generator\"\nis \"fix_gen_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       (\\<And>x. terminates (fun x)) \\<Longrightarrow>\n       terminates (fix_gen_raw fun)", "by(rule terminates_fix_gen_raw)"], ["", "lemma unstream_fix_gen: \"unstream (fix_gen g) (a, s) = unstream (g a) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (fix_gen g) (a, s) = unstream (g a) s", "proof(induction s taking: \"g a\" rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator (g a) s = Skip x2 \\<Longrightarrow>\n                   unstream (fix_gen g) (a, x2) = unstream (g a) x2;\n        \\<And>x31 x32.\n           generator (g a) s = Yield x31 x32 \\<Longrightarrow>\n           unstream (fix_gen g) (a, x32) = unstream (g a) x32\\<rbrakk>\n       \\<Longrightarrow> unstream (fix_gen g) (a, s) = unstream (g a) s", "case (1 s)"], ["proof (state)\nthis:\n  generator (g a) s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (fix_gen g) (a, ?x2.0) = unstream (g a) ?x2.0\n  generator (g a) s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (fix_gen g) (a, ?x32.0) = unstream (g a) ?x32.0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator (g a) s = Skip x2 \\<Longrightarrow>\n                   unstream (fix_gen g) (a, x2) = unstream (g a) x2;\n        \\<And>x31 x32.\n           generator (g a) s = Yield x31 x32 \\<Longrightarrow>\n           unstream (fix_gen g) (a, x32) = unstream (g a) x32\\<rbrakk>\n       \\<Longrightarrow> unstream (fix_gen g) (a, s) = unstream (g a) s", "thus ?case"], ["proof (prove)\nusing this:\n  generator (g a) s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (fix_gen g) (a, ?x2.0) = unstream (g a) ?x2.0\n  generator (g a) s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (fix_gen g) (a, ?x32.0) = unstream (g a) ?x32.0\n\ngoal (1 subgoal):\n 1. unstream (fix_gen g) (a, s) = unstream (g a) s", "by(cases \"generator (g a) s\")(simp_all add: fix_gen.rep_eq)"], ["proof (state)\nthis:\n  unstream (fix_gen g) (a, s) = unstream (g a) s\n\ngoal:\nNo subgoals!", "qed"], ["", "context \n  fixes f :: \"('a \\<Rightarrow> 's')\"\n  and g'' :: \"('b, 's') raw_generator\"\n  and g :: \"('a, 's) raw_generator\"\nbegin"], ["", "fun flatten_raw :: \"('b, 's \\<times> 's' option) raw_generator\"\nwhere\n  \"flatten_raw (s, None) = (case g s of\n     Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (s', None) | Yield x s' \\<Rightarrow> Skip (s', Some (f x)))\"\n| \"flatten_raw (s, Some s'') = (case g'' s'' of\n     Done \\<Rightarrow> Skip (s, None) | Skip s' \\<Rightarrow> Skip (s, Some s') | Yield x s' \\<Rightarrow> Yield x (s, Some s'))\""], ["", "lemma terminates_flatten_raw: \n  assumes \"terminates g''\" \"terminates g\"\n  shows \"terminates flatten_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates local.flatten_raw", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on local.flatten_raw", "fix st :: \"'s \\<times> 's' option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on local.flatten_raw", "obtain s ms where \"st = (s, ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s ms. st = (s, ms) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases st)"], ["proof (state)\nthis:\n  st = (s, ms)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on local.flatten_raw", "{"], ["proof (state)\nthis:\n  st = (s, ms)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on local.flatten_raw", "fix s s''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on local.flatten_raw", "assume s: \"(s, None) \\<in> terminates_on flatten_raw\""], ["proof (state)\nthis:\n  (s, None) \\<in> terminates_on local.flatten_raw\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on local.flatten_raw", "from \\<open>terminates g''\\<close>"], ["proof (chain)\npicking this:\n  terminates g''", "have \"s'' \\<in> terminates_on g''\""], ["proof (prove)\nusing this:\n  terminates g''\n\ngoal (1 subgoal):\n 1. s'' \\<in> terminates_on g''", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s'' \\<in> terminates_on g''\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on local.flatten_raw", "hence \"(s, Some s'') \\<in> terminates_on flatten_raw\""], ["proof (prove)\nusing this:\n  s'' \\<in> terminates_on g''\n\ngoal (1 subgoal):\n 1. (s, Some s'') \\<in> terminates_on local.flatten_raw", "by(induction)(auto intro: terminates_on.intros s)"], ["proof (state)\nthis:\n  (s, Some s'') \\<in> terminates_on local.flatten_raw\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on local.flatten_raw", "}"], ["proof (state)\nthis:\n  (?sa2, None) \\<in> terminates_on local.flatten_raw \\<Longrightarrow>\n  (?sa2, Some ?s''2) \\<in> terminates_on local.flatten_raw\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on local.flatten_raw", "note Some = this"], ["proof (state)\nthis:\n  (?sa2, None) \\<in> terminates_on local.flatten_raw \\<Longrightarrow>\n  (?sa2, Some ?s''2) \\<in> terminates_on local.flatten_raw\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on local.flatten_raw", "from \\<open>terminates g\\<close>"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by (simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on local.flatten_raw", "then"], ["proof (chain)\npicking this:\n  s \\<in> terminates_on g", "show \"st \\<in> terminates_on flatten_raw\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. st \\<in> terminates_on local.flatten_raw", "unfolding \\<open>st = (s, ms)\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. (s, ms) \\<in> terminates_on local.flatten_raw", "apply(induction arbitrary: ms)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s ms.\n       g s = Done \\<Longrightarrow>\n       (s, ms) \\<in> terminates_on local.flatten_raw\n 2. \\<And>s s' ms.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>ms. (s', ms) \\<in> terminates_on local.flatten_raw\\<rbrakk>\n       \\<Longrightarrow> (s, ms) \\<in> terminates_on local.flatten_raw\n 3. \\<And>s a s' ms.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>ms. (s', ms) \\<in> terminates_on local.flatten_raw\\<rbrakk>\n       \\<Longrightarrow> (s, ms) \\<in> terminates_on local.flatten_raw", "apply(case_tac [!] ms)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s ms.\n       \\<lbrakk>g s = Done; ms = None\\<rbrakk>\n       \\<Longrightarrow> (s, ms) \\<in> terminates_on local.flatten_raw\n 2. \\<And>s ms a.\n       \\<lbrakk>g s = Done; ms = Some a\\<rbrakk>\n       \\<Longrightarrow> (s, ms) \\<in> terminates_on local.flatten_raw\n 3. \\<And>s s' ms.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>ms. (s', ms) \\<in> terminates_on local.flatten_raw;\n        ms = None\\<rbrakk>\n       \\<Longrightarrow> (s, ms) \\<in> terminates_on local.flatten_raw\n 4. \\<And>s s' ms a.\n       \\<lbrakk>g s = Skip s'; s' \\<in> terminates_on g;\n        \\<And>ms. (s', ms) \\<in> terminates_on local.flatten_raw;\n        ms = Some a\\<rbrakk>\n       \\<Longrightarrow> (s, ms) \\<in> terminates_on local.flatten_raw\n 5. \\<And>s a s' ms.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>ms. (s', ms) \\<in> terminates_on local.flatten_raw;\n        ms = None\\<rbrakk>\n       \\<Longrightarrow> (s, ms) \\<in> terminates_on local.flatten_raw\n 6. \\<And>s a s' ms aa.\n       \\<lbrakk>g s = Yield a s'; s' \\<in> terminates_on g;\n        \\<And>ms. (s', ms) \\<in> terminates_on local.flatten_raw;\n        ms = Some aa\\<rbrakk>\n       \\<Longrightarrow> (s, ms) \\<in> terminates_on local.flatten_raw", "apply(auto intro: terminates_on.intros intro!: Some)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  st \\<in> terminates_on local.flatten_raw\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lift_definition flatten :: \"('a \\<Rightarrow> 's') \\<Rightarrow> ('b, 's') generator \\<Rightarrow> ('a, 's) generator \\<Rightarrow> ('b, 's \\<times> 's' option) generator\"\nis \"flatten_raw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3.\n       \\<lbrakk>terminates fun2; terminates fun3\\<rbrakk>\n       \\<Longrightarrow> terminates (flatten_raw fun1 fun2 fun3)", "by(fact terminates_flatten_raw)"], ["", "lemma unstream_flatten_Some:\n  \"unstream (flatten f g'' g) (s, Some s') = unstream g'' s' @ unstream (flatten f g'' g) (s, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (flatten f g'' g) (s, Some s') =\n    unstream g'' s' @ unstream (flatten f g'' g) (s, None)", "proof(induction s' taking: g'' rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>\\<And>x2.\n                   generator g'' sa = Skip x2 \\<Longrightarrow>\n                   unstream (flatten f g'' g) (s, Some x2) =\n                   unstream g'' x2 @ unstream (flatten f g'' g) (s, None);\n        \\<And>x31 x32.\n           generator g'' sa = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten f g'' g) (s, Some x32) =\n           unstream g'' x32 @ unstream (flatten f g'' g) (s, None)\\<rbrakk>\n       \\<Longrightarrow> unstream (flatten f g'' g) (s, Some sa) =\n                         unstream g'' sa @\n                         unstream (flatten f g'' g) (s, None)", "case (1 s')"], ["proof (state)\nthis:\n  generator g'' s' = Skip ?x2.0 \\<Longrightarrow>\n  unstream (flatten f g'' g) (s, Some ?x2.0) =\n  unstream g'' ?x2.0 @ unstream (flatten f g'' g) (s, None)\n  generator g'' s' = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (flatten f g'' g) (s, Some ?x32.0) =\n  unstream g'' ?x32.0 @ unstream (flatten f g'' g) (s, None)\n\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>\\<And>x2.\n                   generator g'' sa = Skip x2 \\<Longrightarrow>\n                   unstream (flatten f g'' g) (s, Some x2) =\n                   unstream g'' x2 @ unstream (flatten f g'' g) (s, None);\n        \\<And>x31 x32.\n           generator g'' sa = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten f g'' g) (s, Some x32) =\n           unstream g'' x32 @ unstream (flatten f g'' g) (s, None)\\<rbrakk>\n       \\<Longrightarrow> unstream (flatten f g'' g) (s, Some sa) =\n                         unstream g'' sa @\n                         unstream (flatten f g'' g) (s, None)", "thus ?case"], ["proof (prove)\nusing this:\n  generator g'' s' = Skip ?x2.0 \\<Longrightarrow>\n  unstream (flatten f g'' g) (s, Some ?x2.0) =\n  unstream g'' ?x2.0 @ unstream (flatten f g'' g) (s, None)\n  generator g'' s' = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (flatten f g'' g) (s, Some ?x32.0) =\n  unstream g'' ?x32.0 @ unstream (flatten f g'' g) (s, None)\n\ngoal (1 subgoal):\n 1. unstream (flatten f g'' g) (s, Some s') =\n    unstream g'' s' @ unstream (flatten f g'' g) (s, None)", "by(cases \"generator g'' s'\")(simp_all add: flatten.rep_eq)"], ["proof (state)\nthis:\n  unstream (flatten f g'' g) (s, Some s') =\n  unstream g'' s' @ unstream (flatten f g'' g) (s, None)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>HO rewrite equations can express the variable capture in the generator unlike GHC rules\\<close>"], ["", "lemma unstream_flatten_fix_gen [stream_fusion]:\n  \"unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (s, None) =\n   List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (s, None) =\n    List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g s)", "proof(induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                    (x2, None) =\n                   List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n            (x32, None) =\n           List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n            (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream\n                          (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                          (s, None) =\n                         List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                          (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (?x2.0, None) =\n  List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (?x32.0, None) =\n  List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                    (x2, None) =\n                   List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n            (x32, None) =\n           List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n            (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream\n                          (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                          (s, None) =\n                         List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                          (unstream g s)", "thus ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (?x2.0, None) =\n  List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (?x32.0, None) =\n  List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (s, None) =\n    List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g s)", "proof(cases \"generator g s\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                 (x2, None) =\n                List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                 (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n         (x32, None) =\n        List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream\n                       (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                       (s, None) =\n                      List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                       (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                    (x2, None) =\n                   List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n            (x32, None) =\n           List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n            (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream\n                          (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                          (s, None) =\n                         List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                          (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                    (x2, None) =\n                   List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n            (x32, None) =\n           List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n            (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream\n                          (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                          (s, None) =\n                         List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                          (unstream g s)", "case (Yield x s')"], ["proof (state)\nthis:\n  generator g s = Yield x s'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                 (x2, None) =\n                List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                 (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n         (x32, None) =\n        List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream\n                       (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                       (s, None) =\n                      List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                       (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                    (x2, None) =\n                   List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n            (x32, None) =\n           List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n            (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream\n                          (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                          (s, None) =\n                         List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                          (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                    (x2, None) =\n                   List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n            (x32, None) =\n           List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n            (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream\n                          (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                          (s, None) =\n                         List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                          (unstream g s)", "with \"1.IH\"(2)[OF this] unstream_flatten_Some[of \"\\<lambda>s. (s, f s)\" \"fix_gen g''\" g]"], ["proof (chain)\npicking this:\n  unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (s', None) =\n  List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g s')\n  unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (?s, Some ?s') =\n  unstream (fix_gen g'') ?s' @\n  unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (?s, None)\n  generator g s = Yield x s'", "show ?thesis"], ["proof (prove)\nusing this:\n  unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (s', None) =\n  List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g s')\n  unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (?s, Some ?s') =\n  unstream (fix_gen g'') ?s' @\n  unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (?s, None)\n  generator g s = Yield x s'\n\ngoal (1 subgoal):\n 1. unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (s, None) =\n    List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g s)", "by(subst (1 3) unstream.simps)(simp add: flatten.rep_eq maps_simps unstream_fix_gen)"], ["proof (state)\nthis:\n  unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (s, None) =\n  List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                 (x2, None) =\n                List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                 (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n         (x32, None) =\n        List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream\n                       (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                       (s, None) =\n                      List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                       (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                    (x2, None) =\n                   List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n            (x32, None) =\n           List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n            (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream\n                          (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g)\n                          (s, None) =\n                         List.maps (\\<lambda>s'. unstream (g'' s') (f s'))\n                          (unstream g s)", "qed(simp_all add: flatten.rep_eq maps_simps)"], ["proof (state)\nthis:\n  unstream (flatten (\\<lambda>s. (s, f s)) (fix_gen g'') g) (s, None) =\n  List.maps (\\<lambda>s'. unstream (g'' s') (f s')) (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Separate fusion rule when the inner generator does not depend on the elements of the outer stream.\n\\<close>"], ["", "lemma unstream_flatten [stream_fusion]:\n  \"unstream (flatten f g'' g) (s, None) = List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (flatten f g'' g) (s, None) =\n    List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g s)", "proof(induction s taking: g rule: unstream.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten f g'' g) (x2, None) =\n                   List.maps (\\<lambda>s'. unstream g'' (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten f g'' g) (x32, None) =\n           List.maps (\\<lambda>s'. unstream g'' (f s'))\n            (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (flatten f g'' g) (s, None) =\n                         List.maps (\\<lambda>s'. unstream g'' (f s'))\n                          (unstream g s)", "case (1 s)"], ["proof (state)\nthis:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (flatten f g'' g) (?x2.0, None) =\n  List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (flatten f g'' g) (?x32.0, None) =\n  List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten f g'' g) (x2, None) =\n                   List.maps (\\<lambda>s'. unstream g'' (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten f g'' g) (x32, None) =\n           List.maps (\\<lambda>s'. unstream g'' (f s'))\n            (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> unstream (flatten f g'' g) (s, None) =\n                         List.maps (\\<lambda>s'. unstream g'' (f s'))\n                          (unstream g s)", "thus ?case"], ["proof (prove)\nusing this:\n  generator g s = Skip ?x2.0 \\<Longrightarrow>\n  unstream (flatten f g'' g) (?x2.0, None) =\n  List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g ?x2.0)\n  generator g s = Yield ?x31.0 ?x32.0 \\<Longrightarrow>\n  unstream (flatten f g'' g) (?x32.0, None) =\n  List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g ?x32.0)\n\ngoal (1 subgoal):\n 1. unstream (flatten f g'' g) (s, None) =\n    List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g s)", "proof(cases \"generator g s\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (flatten f g'' g) (x2, None) =\n                List.maps (\\<lambda>s'. unstream g'' (f s'))\n                 (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (flatten f g'' g) (x32, None) =\n        List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (flatten f g'' g) (s, None) =\n                      List.maps (\\<lambda>s'. unstream g'' (f s'))\n                       (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten f g'' g) (x2, None) =\n                   List.maps (\\<lambda>s'. unstream g'' (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten f g'' g) (x32, None) =\n           List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (flatten f g'' g) (s, None) =\n                         List.maps (\\<lambda>s'. unstream g'' (f s'))\n                          (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten f g'' g) (x2, None) =\n                   List.maps (\\<lambda>s'. unstream g'' (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten f g'' g) (x32, None) =\n           List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (flatten f g'' g) (s, None) =\n                         List.maps (\\<lambda>s'. unstream g'' (f s'))\n                          (unstream g s)", "case (Yield x s')"], ["proof (state)\nthis:\n  generator g s = Yield x s'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (flatten f g'' g) (x2, None) =\n                List.maps (\\<lambda>s'. unstream g'' (f s'))\n                 (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (flatten f g'' g) (x32, None) =\n        List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (flatten f g'' g) (s, None) =\n                      List.maps (\\<lambda>s'. unstream g'' (f s'))\n                       (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten f g'' g) (x2, None) =\n                   List.maps (\\<lambda>s'. unstream g'' (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten f g'' g) (x32, None) =\n           List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (flatten f g'' g) (s, None) =\n                         List.maps (\\<lambda>s'. unstream g'' (f s'))\n                          (unstream g s)\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten f g'' g) (x2, None) =\n                   List.maps (\\<lambda>s'. unstream g'' (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten f g'' g) (x32, None) =\n           List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g x32);\n        generator g s = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> unstream (flatten f g'' g) (s, None) =\n                         List.maps (\\<lambda>s'. unstream g'' (f s'))\n                          (unstream g s)", "with \"1.IH\"(2)[OF this]"], ["proof (chain)\npicking this:\n  unstream (flatten f g'' g) (s', None) =\n  List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g s')\n  generator g s = Yield x s'", "show ?thesis"], ["proof (prove)\nusing this:\n  unstream (flatten f g'' g) (s', None) =\n  List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g s')\n  generator g s = Yield x s'\n\ngoal (1 subgoal):\n 1. unstream (flatten f g'' g) (s, None) =\n    List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g s)", "using unstream_flatten_Some[of f g'' g s' \"f x\"]"], ["proof (prove)\nusing this:\n  unstream (flatten f g'' g) (s', None) =\n  List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g s')\n  generator g s = Yield x s'\n  unstream (flatten f g'' g) (s', Some (f x)) =\n  unstream g'' (f x) @ unstream (flatten f g'' g) (s', None)\n\ngoal (1 subgoal):\n 1. unstream (flatten f g'' g) (s, None) =\n    List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g s)", "by(simp add: flatten.rep_eq maps_simps o_def)"], ["proof (state)\nthis:\n  unstream (flatten f g'' g) (s, None) =\n  List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x2.\n                generator g s = Skip x2 \\<Longrightarrow>\n                unstream (flatten f g'' g) (x2, None) =\n                List.maps (\\<lambda>s'. unstream g'' (f s'))\n                 (unstream g x2);\n     \\<And>x31 x32.\n        generator g s = Yield x31 x32 \\<Longrightarrow>\n        unstream (flatten f g'' g) (x32, None) =\n        List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g x32);\n     generator g s = Done\\<rbrakk>\n    \\<Longrightarrow> unstream (flatten f g'' g) (s, None) =\n                      List.maps (\\<lambda>s'. unstream g'' (f s'))\n                       (unstream g s)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   unstream (flatten f g'' g) (x2, None) =\n                   List.maps (\\<lambda>s'. unstream g'' (f s'))\n                    (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           unstream (flatten f g'' g) (x32, None) =\n           List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g x32);\n        generator g s = Skip x2\\<rbrakk>\n       \\<Longrightarrow> unstream (flatten f g'' g) (s, None) =\n                         List.maps (\\<lambda>s'. unstream g'' (f s'))\n                          (unstream g s)", "qed(simp_all add: maps_simps flatten.rep_eq)"], ["proof (state)\nthis:\n  unstream (flatten f g'' g) (s, None) =\n  List.maps (\\<lambda>s'. unstream g'' (f s')) (unstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}