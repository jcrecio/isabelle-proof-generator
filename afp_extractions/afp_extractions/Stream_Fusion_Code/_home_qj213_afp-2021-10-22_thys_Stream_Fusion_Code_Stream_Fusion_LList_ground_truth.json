{"file_name": "/home/qj213/afp-2021-10-22/thys/Stream_Fusion_Code/Stream_Fusion_LList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stream_Fusion_Code", "problem_names": ["lemma productiveI [intro?]:\n  \"(\\<And>s. s \\<in> productive_on g) \\<Longrightarrow> productive g\"", "lemma productive_onI [dest?]: \"productive g \\<Longrightarrow> s \\<in> productive_on g\"", "lemma lunstream_simps:\n  \"g s = Done \\<Longrightarrow> lunstream s = LNil\"\n  \"g s = Skip s' \\<Longrightarrow> lunstream s = lunstream s'\"\n  \"g s = Yield x s' \\<Longrightarrow> lunstream s = LCons x (lunstream s')\"", "lemma lunstream_sels:\n  shows lnull_lunstream: \"lnull (lunstream s) \\<longleftrightarrow> \n  (case g s of Done \\<Rightarrow> True | Skip s' \\<Rightarrow> lnull (lunstream s') | Yield _ _ \\<Rightarrow> False)\"\n  and lhd_lunstream: \"lhd (lunstream s) =\n  (case g s of Skip s' \\<Rightarrow> lhd (lunstream s') | Yield x _ \\<Rightarrow> x)\"\n  and ltl_lunstream: \"ltl (lunstream s) =\n  (case g s of Done \\<Rightarrow> LNil | Skip s' \\<Rightarrow> ltl (lunstream s') | Yield _ s' \\<Rightarrow> lunstream s')\"", "lemma lunstream'_simps:\n  \"lgenerator g s = Done \\<Longrightarrow> lunstream' g s = LNil\"\n  \"lgenerator g s = Skip s' \\<Longrightarrow> lunstream' g s = lunstream' g s'\"\n  \"lgenerator g s = Yield x s' \\<Longrightarrow> lunstream' g s = LCons x (lunstream' g s')\"", "lemma lunstream'_sels:\n  shows lnull_lunstream': \"lnull (lunstream' g s) \\<longleftrightarrow> \n  (case lgenerator g s of Done \\<Rightarrow> True | Skip s' \\<Rightarrow> lnull (lunstream' g s') | Yield _ _ \\<Rightarrow> False)\"\n  and lhd_lunstream': \"lhd (lunstream' g s) =\n  (case lgenerator g s of Skip s' \\<Rightarrow> lhd (lunstream' g s') | Yield x _ \\<Rightarrow> x)\"\n  and ltl_lunstream': \"ltl (lunstream' g s) =\n  (case lgenerator g s of Done \\<Rightarrow> LNil | Skip s' \\<Rightarrow> ltl (lunstream' g s') | Yield _ s' \\<Rightarrow> lunstream' g s')\"", "lemma case_lstream_conv_case_llist:\n  \"(case lstream xs of Done \\<Rightarrow> done | Skip xs' \\<Rightarrow> skip xs' | Yield x xs' \\<Rightarrow> yield x xs') =\n   (case xs of LNil \\<Rightarrow> done | LCons x xs' \\<Rightarrow> yield x xs')\"", "lemma mcont2mcont_lunstream[THEN llist.mcont2mcont, simp, cont_intro]:\n  shows mcont_lunstream: \"mcont lSup lprefix lSup lprefix (lunstream lstream)\"", "lemma lunstream_lstream: \"lunstream lstream xs = xs\"", "lemma lunstream'_lstream: \"lunstream' lstream' xs = xs\"", "lemma lunstream_iterates_raw: \"lunstream (iterates_raw f) x = iterates f x\"", "lemma lunstream'_iterates_prod [stream_fusion]: \"lunstream' (iterates_prod f) x = iterates f x\"", "lemma lunstream_unfold_llist_raw:\n  \"lunstream (unfold_llist_raw stop head tail) s = unfold_llist stop head tail s\"", "lemma lunstream'_unfold_llist_prod [stream_fusion]:\n  \"lunstream' (unfold_llist_prod stop head tail) s = unfold_llist stop head tail s\"", "lemma lunstream_inf_llist_raw: \"lunstream (inf_llist_raw f) n = ldropn n (inf_llist f)\"", "lemma inf_llist_prod_fusion [stream_fusion]:\n  \"lunstream' (inf_llist_prod f) 0 = inf_llist f\"", "lemma lhd_cons_code[code]:\n  \"lhd_cons s = (case g s of Done \\<Rightarrow> undefined | Skip s' \\<Rightarrow> lhd_cons s' | Yield x _ \\<Rightarrow> x)\"", "lemma lhd_cons_fusion2 [stream_fusion]:\n  \"lhd_cons (lgenerator g) s = lhd (lunstream' g s)\"", "lemma gen_llength_cons_code [code]:\n  \"gen_llength_cons n s = (case g s of\n    Done \\<Rightarrow> n | Skip s' \\<Rightarrow> gen_llength_cons n s' | Yield _ s' \\<Rightarrow> gen_llength_cons (eSuc n) s')\"", "lemma gen_llength_cons_fusion [stream_fusion]:\n  \"gen_llength_cons 0 s = llength (lunstream g s)\"", "lemma gen_llength_cons'_code [code]:\n  \"gen_llength_cons' n s = (case lgenerator g s of\n    Done \\<Rightarrow> n | Skip s' \\<Rightarrow> gen_llength_cons' n s' | Yield _ s' \\<Rightarrow> gen_llength_cons' (eSuc n) s')\"", "lemma gen_llength_cons'_fusion [stream_fusion]:\n  \"gen_llength_cons' 0 s = llength (lunstream' g s)\"", "lemma lnull_cons_code [code]:\n  \"lnull_cons s \\<longleftrightarrow> (case g s of\n    Done \\<Rightarrow> True | Skip s' \\<Rightarrow> lnull_cons s' | Yield _ _ \\<Rightarrow> False)\"", "lemma lnull_cons'_code [code]:\n  \"lnull_cons' s \\<longleftrightarrow> (case lgenerator g s of\n    Done \\<Rightarrow> True | Skip s' \\<Rightarrow> lnull_cons' s' | Yield _ _ \\<Rightarrow> False)\"", "lemma lnull_cons'_fusion [stream_fusion]:\n  \"lnull_cons' s \\<longleftrightarrow> lnull (lunstream' g s)\"", "lemma llist_all2_cons_code [code]:\n  \"llist_all2_cons sg sh = \n  (case g sg of\n     Done \\<Rightarrow> lnull_cons h sh\n   | Skip sg' \\<Rightarrow> llist_all2_cons sg' sh\n   | Yield a sg' \\<Rightarrow> llist_all2_cons1 a sg' sh)\"", "lemma llist_all2_cons1_code [code]:\n  \"llist_all2_cons1 x sg' sh = \n  (case h sh of\n     Done \\<Rightarrow> False\n   | Skip sh' \\<Rightarrow> llist_all2_cons1 x sg' sh'\n   | Yield y sh' \\<Rightarrow> P x y \\<and> llist_all2_cons sg' sh')\"", "lemma llist_all2_cons_fusion2 [stream_fusion]:\n  \"llist_all2_cons (lgenerator g) (lgenerator h) P sg sh \\<longleftrightarrow> llist_all2 P (lunstream' g sg) (lunstream' h sh)\"", "lemma llist_all2_cons_fusion3 [stream_fusion]:\n  \"llist_all2_cons g (lgenerator h) P sg sh \\<longleftrightarrow> llist_all2 P (lunstream g sg) (lunstream' h sh)\"", "lemma llist_all2_cons_fusion4 [stream_fusion]:\n  \"llist_all2_cons (lgenerator g) h P sg sh \\<longleftrightarrow> llist_all2 P (lunstream' g sg) (lunstream h sh)\"", "lemma lnth_cons_code [code]:\n  \"lnth_cons n s = (case g s of\n    Done \\<Rightarrow> undefined n\n  | Skip s' \\<Rightarrow> lnth_cons n s'\n  | Yield x s' \\<Rightarrow> (if n = 0 then x else lnth_cons (n - 1) s'))\"", "lemma lnth_cons_fusion2 [stream_fusion]:\n  \"lnth_cons (lgenerator g) n s = lnth (lunstream' g s) n\"", "lemma lprefix_cons_code [code]:\n  \"lprefix_cons sg sh \\<longleftrightarrow> (case g sg of\n     Done \\<Rightarrow> True | Skip sg' \\<Rightarrow> lprefix_cons sg' sh | Yield x sg' \\<Rightarrow> lprefix_cons1 x sg' sh)\"", "lemma lprefix_cons1_code [code]:\n  \"lprefix_cons1 x sg' sh \\<longleftrightarrow> (case h sh of\n     Done \\<Rightarrow> False | Skip sh' \\<Rightarrow> lprefix_cons1 x sg' sh'\n   | Yield y sh' \\<Rightarrow> x = y \\<and> lprefix_cons sg' sh')\"", "lemma lprefix_cons_fusion2 [stream_fusion]:\n  \"lprefix_cons (lgenerator g) (lgenerator h) sg sh \\<longleftrightarrow> lprefix (lunstream' g sg) (lunstream' h sh)\"", "lemma lprefix_cons_fusion3 [stream_fusion]:\n  \"lprefix_cons g (lgenerator h) sg sh \\<longleftrightarrow> lprefix (lunstream g sg) (lunstream' h sh)\"", "lemma lprefix_cons_fusion4 [stream_fusion]:\n  \"lprefix_cons (lgenerator g) h sg sh \\<longleftrightarrow> lprefix (lunstream' g sg) (lunstream h sh)\"", "lemma lunstream_lmap_trans [stream_fusion]: fixes f g s\n  defines [simp]: \"g' \\<equiv> lmap_trans f g\"\n  shows \"lunstream g' s = lmap f (lunstream g s)\" (is \"?lhs = ?rhs\")", "lemma lunstream'_lmap_trans' [stream_fusion]:\n  \"lunstream' (lmap_trans' f g) s = lmap f (lunstream' g s)\"", "lemma ltake_trans_fusion [stream_fusion]:\n  fixes g' g\n  defines [simp]: \"g' \\<equiv> ltake_trans g\"\n  shows \"lunstream g' (n, s) = ltake n (lunstream g s)\" (is \"?lhs = ?rhs\")", "lemma ltake_trans'_fusion [stream_fusion]:\n  \"lunstream' (ltake_trans' g) (n, s) = ltake n (lunstream' g s)\"", "lemma ldropn_trans_fusion [stream_fusion]:\n  fixes g defines [simp]: \"g' \\<equiv> ldropn_trans g\"\n  shows \"lunstream g' (n, s) = ldropn n (lunstream g s)\" (is \"?lhs = ?rhs\")", "lemma ldropn_trans'_fusion [stream_fusion]:\n  \"lunstream' (ldropn_trans' g) (n, s) = ldropn n (lunstream' g s)\"", "lemma ldrop_trans_fusion [stream_fusion]:\n  fixes g g' defines [simp]: \"g' \\<equiv> ldrop_trans g\"\n  shows \"lunstream g' (n, s) = ldrop n (lunstream g s)\" (is \"?lhs = ?rhs\")", "lemma ldrop_trans_fusion2 [stream_fusion]:\n  \"lunstream (ldrop_trans (lgenerator g)) (n, s) = ldrop n (lunstream' g s)\"", "lemma ltakeWhile_trans_fusion [stream_fusion]:\n  fixes P g g' defines [simp]: \"g' \\<equiv> ltakeWhile_trans P g\"\n  shows \"lunstream g' s = ltakeWhile P (lunstream g s)\" (is \"?lhs = ?rhs\")", "lemma ltakeWhile_trans'_fusion [stream_fusion]:\n  \"lunstream' (ltakeWhile_trans' P g) s = ltakeWhile P (lunstream' g s)\"", "lemma ldropWhile_trans_fusion [stream_fusion]:\n  fixes P g g' defines [simp]: \"g' \\<equiv> ldropWhile_trans P g\"\n  shows \"lunstream g' (True, s) = ldropWhile P (lunstream g s)\" (is \"?lhs = ?rhs\")", "lemma ldropWhile_trans_fusion2 [stream_fusion]:\n  \"lunstream (ldropWhile_trans P (lgenerator g)) (True, s) = ldropWhile P (lunstream' g s)\"", "lemma lzip_trans_fusion [stream_fusion]:\n  fixes g h gh defines [simp]: \"gh \\<equiv> lzip_trans g h\"\n  shows \"lunstream gh (sg, sh, None) = lzip (lunstream g sg) (lunstream h sh)\"\n  (is \"?lhs = ?rhs\")", "lemma lzip_trans_fusion2 [stream_fusion]:\n  \"lunstream (lzip_trans (lgenerator g) h) (sg, sh, None) = lzip (lunstream' g sg) (lunstream h sh)\"", "lemma lzip_trans_fusion3 [stream_fusion]:\n  \"lunstream (lzip_trans g (lgenerator h)) (sg, sh, None) = lzip (lunstream g sg) (lunstream' h sh)\"", "lemma lzip_trans'_fusion [stream_fusion]:\n  \"lunstream' (lzip_trans' g h) (sg, sh, None) = lzip (lunstream' g sg) (lunstream' h sh)\"", "lemma lunstream_append_raw:\n  fixes g h sh gh defines [simp]: \"gh \\<equiv> append_raw g h sh\"\n  assumes \"productive g\"\n  shows \"lunstream gh (Inl sg) = lappend (lunstream g sg) (lunstream h sh)\"", "lemma lappend_trans_fusion [stream_fusion]:\n  \"lunstream (lappend_trans g h sh) (Inl sg) = lappend (lunstream' g sg) (lunstream h sh)\"", "lemma lappend_trans'_fusion [stream_fusion]:\n  \"lunstream' (lappend_trans' g h sh) (Inl sg) = lappend (lunstream' g sg) (lunstream' h sh)\"", "lemma lunstream_lfilter_trans [stream_fusion]:\n  fixes P g g' defines [simp]: \"g' \\<equiv> lfilter_trans P g\"\n  shows \"lunstream g' s = lfilter P (lunstream g s)\" (is \"?lhs = ?rhs\")", "lemma lunstream_lfilter_trans2 [stream_fusion]:\n  \"lunstream (lfilter_trans P (lgenerator g)) s = lfilter P (lunstream' g s)\"", "lemma lunstream_llist_of_trans [stream_fusion]:\n  \"lunstream' (llist_of_trans g) s = llist_of (unstream g s)\""], "translations": [["", "lemma productiveI [intro?]:\n  \"(\\<And>s. s \\<in> productive_on g) \\<Longrightarrow> productive g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. s \\<in> productive_on g) \\<Longrightarrow> productive g", "by(auto simp add: productive_def)"], ["", "lemma productive_onI [dest?]: \"productive g \\<Longrightarrow> s \\<in> productive_on g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. productive g \\<Longrightarrow> s \\<in> productive_on g", "by(simp add: productive_def)"], ["", "text \\<open>A type of generators that eventually will yield something else than a skip.\\<close>"], ["", "typedef ('a, 's) lgenerator' = \"{g :: ('a, 's) lgenerator. productive g}\"\n  morphisms lgenerator Abs_lgenerator'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {g. productive g}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {g. productive g}", "show \"(\\<lambda>_. Done) \\<in> ?lgenerator'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. Done) \\<in> {g. productive g}", "by(auto intro: productive_on.intros productiveI)"], ["proof (state)\nthis:\n  (\\<lambda>_. Done) \\<in> {g. productive g}\n\ngoal:\nNo subgoals!", "qed"], ["", "setup_lifting type_definition_lgenerator'"], ["", "subsection \\<open>Conversions to @{typ \"'a llist\"}\\<close>"], ["", "subsubsection \\<open>Infinitely many consecutive @{term Skip}s\\<close>"], ["", "context fixes g :: \"('a, 's) lgenerator\"\n  notes [[function_internals]]\nbegin"], ["", "partial_function (llist) lunstream :: \"'s \\<Rightarrow> 'a llist\"\nwhere\n  \"lunstream s = (case g s of \n     Done \\<Rightarrow> LNil | Skip s' \\<Rightarrow> lunstream s' | Yield x s' \\<Rightarrow> LCons x (lunstream s'))\""], ["", "declare lunstream.simps[code]"], ["", "lemma lunstream_simps:\n  \"g s = Done \\<Longrightarrow> lunstream s = LNil\"\n  \"g s = Skip s' \\<Longrightarrow> lunstream s = lunstream s'\"\n  \"g s = Yield x s' \\<Longrightarrow> lunstream s = LCons x (lunstream s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g s = Done \\<Longrightarrow> local.lunstream s = LNil) &&&\n    (g s = Skip s' \\<Longrightarrow>\n     local.lunstream s = local.lunstream s') &&&\n    (g s = Yield x s' \\<Longrightarrow>\n     local.lunstream s = LCons x (local.lunstream s'))", "by(simp_all add: lunstream.simps)"], ["", "lemma lunstream_sels:\n  shows lnull_lunstream: \"lnull (lunstream s) \\<longleftrightarrow> \n  (case g s of Done \\<Rightarrow> True | Skip s' \\<Rightarrow> lnull (lunstream s') | Yield _ _ \\<Rightarrow> False)\"\n  and lhd_lunstream: \"lhd (lunstream s) =\n  (case g s of Skip s' \\<Rightarrow> lhd (lunstream s') | Yield x _ \\<Rightarrow> x)\"\n  and ltl_lunstream: \"ltl (lunstream s) =\n  (case g s of Done \\<Rightarrow> LNil | Skip s' \\<Rightarrow> ltl (lunstream s') | Yield _ s' \\<Rightarrow> lunstream s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (local.lunstream s) =\n    (case g s of Done \\<Rightarrow> True\n     | Skip s' \\<Rightarrow> lnull (local.lunstream s')\n     | Yield x xa \\<Rightarrow> False) &&&\n    lhd (local.lunstream s) =\n    (case g s of Skip s' \\<Rightarrow> lhd (local.lunstream s')\n     | Yield x xa \\<Rightarrow> x) &&&\n    ltl (local.lunstream s) =\n    (case g s of Done \\<Rightarrow> LNil\n     | Skip s' \\<Rightarrow> ltl (local.lunstream s')\n     | Yield x xa \\<Rightarrow> local.lunstream xa)", "by(simp_all add: lhd_def lunstream_simps split: step.split)"], ["", "end"], ["", "subsubsection \\<open>Finitely many consecutive @{term Skip}s\\<close>"], ["", "lift_definition lunstream' :: \"('a, 's) lgenerator' \\<Rightarrow> 's \\<Rightarrow> 'a llist\"\nis lunstream"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lunstream'_simps:\n  \"lgenerator g s = Done \\<Longrightarrow> lunstream' g s = LNil\"\n  \"lgenerator g s = Skip s' \\<Longrightarrow> lunstream' g s = lunstream' g s'\"\n  \"lgenerator g s = Yield x s' \\<Longrightarrow> lunstream' g s = LCons x (lunstream' g s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lgenerator g s = Done \\<Longrightarrow> lunstream' g s = LNil) &&&\n    (lgenerator g s = Skip s' \\<Longrightarrow>\n     lunstream' g s = lunstream' g s') &&&\n    (lgenerator g s = Yield x s' \\<Longrightarrow>\n     lunstream' g s = LCons x (lunstream' g s'))", "by(transfer, simp add: lunstream_simps)+"], ["", "lemma lunstream'_sels:\n  shows lnull_lunstream': \"lnull (lunstream' g s) \\<longleftrightarrow> \n  (case lgenerator g s of Done \\<Rightarrow> True | Skip s' \\<Rightarrow> lnull (lunstream' g s') | Yield _ _ \\<Rightarrow> False)\"\n  and lhd_lunstream': \"lhd (lunstream' g s) =\n  (case lgenerator g s of Skip s' \\<Rightarrow> lhd (lunstream' g s') | Yield x _ \\<Rightarrow> x)\"\n  and ltl_lunstream': \"ltl (lunstream' g s) =\n  (case lgenerator g s of Done \\<Rightarrow> LNil | Skip s' \\<Rightarrow> ltl (lunstream' g s') | Yield _ s' \\<Rightarrow> lunstream' g s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lunstream' g s) =\n    (case lgenerator g s of Done \\<Rightarrow> True\n     | Skip s' \\<Rightarrow> lnull (lunstream' g s')\n     | Yield x xa \\<Rightarrow> False) &&&\n    lhd (lunstream' g s) =\n    (case lgenerator g s of Skip s' \\<Rightarrow> lhd (lunstream' g s')\n     | Yield x xa \\<Rightarrow> x) &&&\n    ltl (lunstream' g s) =\n    (case lgenerator g s of Done \\<Rightarrow> LNil\n     | Skip s' \\<Rightarrow> ltl (lunstream' g s')\n     | Yield x s' \\<Rightarrow> lunstream' g s')", "by(transfer, simp add: lunstream_sels)+"], ["", "setup \\<open>Context.theory_map (fold\n  Stream_Fusion.add_unstream [@{const_name lunstream}, @{const_name lunstream'}])\\<close>"], ["", "subsection \\<open>Producers\\<close>"], ["", "subsubsection \\<open>Conversion to streams\\<close>"], ["", "fun lstream :: \"('a, 'a llist) lgenerator\"\nwhere\n  \"lstream LNil = Done\"\n| \"lstream (LCons x xs) = Yield x xs\""], ["", "lemma case_lstream_conv_case_llist:\n  \"(case lstream xs of Done \\<Rightarrow> done | Skip xs' \\<Rightarrow> skip xs' | Yield x xs' \\<Rightarrow> yield x xs') =\n   (case xs of LNil \\<Rightarrow> done | LCons x xs' \\<Rightarrow> yield x xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case lstream xs of Done \\<Rightarrow> done\n     | Skip xs' \\<Rightarrow> skip xs'\n     | Yield x xs' \\<Rightarrow> yield x xs') =\n    (case xs of LNil \\<Rightarrow> done\n     | LCons x xs' \\<Rightarrow> yield x xs')", "by(simp split: llist.split)"], ["", "lemma mcont2mcont_lunstream[THEN llist.mcont2mcont, simp, cont_intro]:\n  shows mcont_lunstream: \"mcont lSup lprefix lSup lprefix (lunstream lstream)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup lprefix lSup lprefix (lunstream lstream)", "by(rule llist.fixp_preserves_mcont1[OF lunstream.mono lunstream_def])(simp add: case_lstream_conv_case_llist)"], ["", "lemma lunstream_lstream: \"lunstream lstream xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream lstream xs = xs", "by(induction xs)(simp_all add: lunstream_simps)"], ["", "lift_definition lstream' :: \"('a, 'a llist) lgenerator'\"\nis lstream"], ["proof (prove)\ngoal (1 subgoal):\n 1. productive lstream", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> productive_on lstream", "fix s :: \"'a llist\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> productive_on lstream", "show \"s \\<in> productive_on lstream\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> productive_on lstream", "by(cases s)(auto intro: productive_on.intros)"], ["proof (state)\nthis:\n  s \\<in> productive_on lstream\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lunstream'_lstream: \"lunstream' lstream' xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream' lstream' xs = xs", "by(transfer)(rule lunstream_lstream)"], ["", "subsubsection \\<open>@{const iterates}\\<close>"], ["", "definition iterates_raw :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> ('a, 'a) lgenerator\"\nwhere \"iterates_raw f s = Yield s (f s)\""], ["", "lemma lunstream_iterates_raw: \"lunstream (iterates_raw f) x = iterates f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream (iterates_raw f) x = iterates f x", "by(coinduction arbitrary: x)(auto simp add: iterates_raw_def lunstream_sels)"], ["", "lift_definition iterates_prod :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> ('a, 'a) lgenerator'\" is iterates_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. productive (iterates_raw fun)", "by(auto 4 3 intro: productiveI productive_on.intros simp add: iterates_raw_def)"], ["", "lemma lunstream'_iterates_prod [stream_fusion]: \"lunstream' (iterates_prod f) x = iterates f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream' (iterates_prod f) x = iterates f x", "by transfer(rule lunstream_iterates_raw)"], ["", "subsubsection \\<open>@{const unfold_llist}\\<close>"], ["", "definition unfold_llist_raw :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> ('b, 'a) lgenerator\"\nwhere\n  \"unfold_llist_raw stop head tail s = (if stop s then Done else Yield (head s) (tail s))\""], ["", "lemma lunstream_unfold_llist_raw:\n  \"lunstream (unfold_llist_raw stop head tail) s = unfold_llist stop head tail s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream (unfold_llist_raw stop head tail) s =\n    unfold_llist stop head tail s", "by(coinduction arbitrary: s)(auto simp add: lunstream_sels unfold_llist_raw_def)"], ["", "lift_definition unfold_llist_prod :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> ('b, 'a) lgenerator'\"\nis unfold_llist_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3. productive (unfold_llist_raw fun1 fun2 fun3)", "proof(rule productiveI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 s.\n       s \\<in> productive_on (unfold_llist_raw fun1 fun2 fun3)", "fix stop and head :: \"'a \\<Rightarrow> 'b\" and tail s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 s.\n       s \\<in> productive_on (unfold_llist_raw fun1 fun2 fun3)", "show \"s \\<in> productive_on (unfold_llist_raw stop head tail)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> productive_on (unfold_llist_raw stop head tail)", "by(cases \"stop s\")(auto intro: productive_on.intros simp add: unfold_llist_raw_def)"], ["proof (state)\nthis:\n  s \\<in> productive_on (unfold_llist_raw stop head tail)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lunstream'_unfold_llist_prod [stream_fusion]:\n  \"lunstream' (unfold_llist_prod stop head tail) s = unfold_llist stop head tail s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream' (unfold_llist_prod stop head tail) s =\n    unfold_llist stop head tail s", "by transfer(rule lunstream_unfold_llist_raw)"], ["", "subsubsection \\<open>@{const inf_llist}\\<close>"], ["", "definition inf_llist_raw :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> ('a, nat) lgenerator\"\nwhere \"inf_llist_raw f n = Yield (f n) (Suc n)\""], ["", "lemma lunstream_inf_llist_raw: \"lunstream (inf_llist_raw f) n = ldropn n (inf_llist f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream (inf_llist_raw f) n = ldropn n (inf_llist f)", "by(coinduction arbitrary: n)(auto simp add: lunstream_sels inf_llist_raw_def)"], ["", "lift_definition inf_llist_prod :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> ('a, nat) lgenerator'\" is inf_llist_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. productive (inf_llist_raw fun)", "by(auto 4 3 intro: productiveI productive_on.intros simp add: inf_llist_raw_def)"], ["", "lemma inf_llist_prod_fusion [stream_fusion]:\n  \"lunstream' (inf_llist_prod f) 0 = inf_llist f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream' (inf_llist_prod f) 0 = inf_llist f", "by transfer(simp add: lunstream_inf_llist_raw)"], ["", "subsection \\<open>Consumers\\<close>"], ["", "subsubsection \\<open>@{const lhd}\\<close>"], ["", "context fixes g :: \"('a, 's) lgenerator\" begin"], ["", "definition lhd_cons :: \"'s \\<Rightarrow> 'a\"\nwhere [stream_fusion]: \"lhd_cons s = lhd (lunstream g s)\""], ["", "lemma lhd_cons_code[code]:\n  \"lhd_cons s = (case g s of Done \\<Rightarrow> undefined | Skip s' \\<Rightarrow> lhd_cons s' | Yield x _ \\<Rightarrow> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lhd_cons s =\n    (case g s of Skip x \\<Rightarrow> local.lhd_cons x\n     | Yield x xa \\<Rightarrow> x)", "by(simp add: lhd_cons_def lunstream_simps lhd_def split: step.split)"], ["", "end"], ["", "lemma lhd_cons_fusion2 [stream_fusion]:\n  \"lhd_cons (lgenerator g) s = lhd (lunstream' g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd_cons (lgenerator g) s = lhd (lunstream' g s)", "by transfer(rule lhd_cons_def)"], ["", "subsubsection \\<open>@{const llength}\\<close>"], ["", "context fixes g :: \"('a, 's) lgenerator\" begin"], ["", "definition gen_llength_cons :: \"enat \\<Rightarrow> 's \\<Rightarrow> enat\"\nwhere \"gen_llength_cons n s = n + llength (lunstream g s)\""], ["", "lemma gen_llength_cons_code [code]:\n  \"gen_llength_cons n s = (case g s of\n    Done \\<Rightarrow> n | Skip s' \\<Rightarrow> gen_llength_cons n s' | Yield _ s' \\<Rightarrow> gen_llength_cons (eSuc n) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.gen_llength_cons n s =\n    (case g s of Done \\<Rightarrow> n\n     | Skip s' \\<Rightarrow> local.gen_llength_cons n s'\n     | Yield x s' \\<Rightarrow> local.gen_llength_cons (eSuc n) s')", "by(simp add: gen_llength_cons_def lunstream_simps iadd_Suc_right iadd_Suc split: step.split)"], ["", "lemma gen_llength_cons_fusion [stream_fusion]:\n  \"gen_llength_cons 0 s = llength (lunstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.gen_llength_cons 0 s = llength (lunstream g s)", "by(simp add: gen_llength_cons_def)"], ["", "end"], ["", "context fixes g :: \"('a, 's) lgenerator'\" begin"], ["", "definition gen_llength_cons' :: \"enat \\<Rightarrow> 's \\<Rightarrow> enat\"\nwhere \"gen_llength_cons' = gen_llength_cons (lgenerator g)\""], ["", "lemma gen_llength_cons'_code [code]:\n  \"gen_llength_cons' n s = (case lgenerator g s of\n    Done \\<Rightarrow> n | Skip s' \\<Rightarrow> gen_llength_cons' n s' | Yield _ s' \\<Rightarrow> gen_llength_cons' (eSuc n) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.gen_llength_cons' n s =\n    (case lgenerator g s of Done \\<Rightarrow> n\n     | Skip s' \\<Rightarrow> local.gen_llength_cons' n s'\n     | Yield x s' \\<Rightarrow> local.gen_llength_cons' (eSuc n) s')", "by(simp add: gen_llength_cons'_def cong: step.case_cong)(rule gen_llength_cons_code)"], ["", "lemma gen_llength_cons'_fusion [stream_fusion]:\n  \"gen_llength_cons' 0 s = llength (lunstream' g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.gen_llength_cons' 0 s = llength (lunstream' g s)", "by(simp add: gen_llength_cons'_def gen_llength_cons_fusion lunstream'.rep_eq)"], ["", "end"], ["", "subsubsection \\<open>@{const lnull}\\<close>"], ["", "context fixes g :: \"('a, 's) lgenerator\" begin"], ["", "definition lnull_cons :: \"'s \\<Rightarrow> bool\"\nwhere [stream_fusion]: \"lnull_cons s \\<longleftrightarrow> lnull (lunstream g s)\""], ["", "lemma lnull_cons_code [code]:\n  \"lnull_cons s \\<longleftrightarrow> (case g s of\n    Done \\<Rightarrow> True | Skip s' \\<Rightarrow> lnull_cons s' | Yield _ _ \\<Rightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lnull_cons s =\n    (case g s of Done \\<Rightarrow> True\n     | Skip x \\<Rightarrow> local.lnull_cons x\n     | Yield x xa \\<Rightarrow> False)", "by(simp add: lnull_cons_def lunstream_simps split: step.split)"], ["", "end"], ["", "context fixes g :: \"('a, 's) lgenerator'\" begin"], ["", "definition lnull_cons' :: \"'s \\<Rightarrow> bool\"\nwhere \"lnull_cons' = lnull_cons (lgenerator g)\""], ["", "lemma lnull_cons'_code [code]:\n  \"lnull_cons' s \\<longleftrightarrow> (case lgenerator g s of\n    Done \\<Rightarrow> True | Skip s' \\<Rightarrow> lnull_cons' s' | Yield _ _ \\<Rightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lnull_cons' s =\n    (case lgenerator g s of Done \\<Rightarrow> True\n     | Skip x \\<Rightarrow> local.lnull_cons' x\n     | Yield x xa \\<Rightarrow> False)", "by(simp add: lnull_cons'_def cong: step.case_cong)(rule lnull_cons_code)"], ["", "lemma lnull_cons'_fusion [stream_fusion]:\n  \"lnull_cons' s \\<longleftrightarrow> lnull (lunstream' g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lnull_cons' s = lnull (lunstream' g s)", "by(simp add: lnull_cons'_def lnull_cons_def lunstream'.rep_eq)"], ["", "end"], ["", "subsubsection \\<open>@{const llist_all2}\\<close>"], ["", "context\n  fixes g :: \"('a, 'sg) lgenerator\"\n  and h :: \"('b, 'sh) lgenerator\"\n  and P :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\"\nbegin"], ["", "definition llist_all2_cons :: \"'sg \\<Rightarrow> 'sh \\<Rightarrow> bool\"\nwhere [stream_fusion]: \"llist_all2_cons sg sh \\<longleftrightarrow> llist_all2 P (lunstream g sg) (lunstream h sh)\""], ["", "definition llist_all2_cons1 :: \"'a \\<Rightarrow> 'sg \\<Rightarrow> 'sh \\<Rightarrow> bool\"\nwhere \"llist_all2_cons1 x sg' sh = llist_all2 P (LCons x (lunstream g sg')) (lunstream h sh)\""], ["", "lemma llist_all2_cons_code [code]:\n  \"llist_all2_cons sg sh = \n  (case g sg of\n     Done \\<Rightarrow> lnull_cons h sh\n   | Skip sg' \\<Rightarrow> llist_all2_cons sg' sh\n   | Yield a sg' \\<Rightarrow> llist_all2_cons1 a sg' sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.llist_all2_cons sg sh =\n    (case g sg of Done \\<Rightarrow> lnull_cons h sh\n     | Skip sg' \\<Rightarrow> local.llist_all2_cons sg' sh\n     | Yield a sg' \\<Rightarrow> local.llist_all2_cons1 a sg' sh)", "by(simp split: step.split add: llist_all2_cons_def lnull_cons_def llist_all2_cons1_def lunstream_simps lnull_def)"], ["", "lemma llist_all2_cons1_code [code]:\n  \"llist_all2_cons1 x sg' sh = \n  (case h sh of\n     Done \\<Rightarrow> False\n   | Skip sh' \\<Rightarrow> llist_all2_cons1 x sg' sh'\n   | Yield y sh' \\<Rightarrow> P x y \\<and> llist_all2_cons sg' sh')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.llist_all2_cons1 x sg' sh =\n    (case h sh of Done \\<Rightarrow> False\n     | Skip sh' \\<Rightarrow> local.llist_all2_cons1 x sg' sh'\n     | Yield y sh' \\<Rightarrow> P x y \\<and> local.llist_all2_cons sg' sh')", "by(simp split: step.split add: llist_all2_cons_def lnull_cons_def lnull_def llist_all2_cons1_def lunstream_simps)"], ["", "end"], ["", "lemma llist_all2_cons_fusion2 [stream_fusion]:\n  \"llist_all2_cons (lgenerator g) (lgenerator h) P sg sh \\<longleftrightarrow> llist_all2 P (lunstream' g sg) (lunstream' h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2_cons (lgenerator g) (lgenerator h) P sg sh =\n    llist_all2 P (lunstream' g sg) (lunstream' h sh)", "by transfer(rule llist_all2_cons_def)"], ["", "lemma llist_all2_cons_fusion3 [stream_fusion]:\n  \"llist_all2_cons g (lgenerator h) P sg sh \\<longleftrightarrow> llist_all2 P (lunstream g sg) (lunstream' h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2_cons g (lgenerator h) P sg sh =\n    llist_all2 P (lunstream g sg) (lunstream' h sh)", "by transfer(rule llist_all2_cons_def)"], ["", "lemma llist_all2_cons_fusion4 [stream_fusion]:\n  \"llist_all2_cons (lgenerator g) h P sg sh \\<longleftrightarrow> llist_all2 P (lunstream' g sg) (lunstream h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2_cons (lgenerator g) h P sg sh =\n    llist_all2 P (lunstream' g sg) (lunstream h sh)", "by transfer(rule llist_all2_cons_def)"], ["", "subsubsection \\<open>@{const lnth}\\<close>"], ["", "context fixes g :: \"('a, 's) lgenerator\" begin"], ["", "definition lnth_cons :: \"nat \\<Rightarrow> 's \\<Rightarrow> 'a\"\nwhere [stream_fusion]: \"lnth_cons n s = lnth (lunstream g s) n\""], ["", "lemma lnth_cons_code [code]:\n  \"lnth_cons n s = (case g s of\n    Done \\<Rightarrow> undefined n\n  | Skip s' \\<Rightarrow> lnth_cons n s'\n  | Yield x s' \\<Rightarrow> (if n = 0 then x else lnth_cons (n - 1) s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lnth_cons n s =\n    (case g s of Done \\<Rightarrow> undefined n\n     | Skip s' \\<Rightarrow> local.lnth_cons n s'\n     | Yield x s' \\<Rightarrow>\n         if n = 0 then x else local.lnth_cons (n - 1) s')", "by(cases n)(simp_all add: lnth_cons_def lunstream_simps lnth_LNil split: step.split)"], ["", "end"], ["", "lemma lnth_cons_fusion2 [stream_fusion]:\n  \"lnth_cons (lgenerator g) n s = lnth (lunstream' g s) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth_cons (lgenerator g) n s = lnth (lunstream' g s) n", "by transfer(rule lnth_cons_def)"], ["", "subsubsection \\<open>@{const lprefix}\\<close>"], ["", "context\n  fixes g :: \"('a, 'sg) lgenerator\"\n  and h :: \"('a, 'sh) lgenerator\"\nbegin"], ["", "definition lprefix_cons :: \"'sg \\<Rightarrow> 'sh \\<Rightarrow> bool\"\nwhere [stream_fusion]: \"lprefix_cons sg sh \\<longleftrightarrow> lprefix (lunstream g sg) (lunstream h sh)\""], ["", "definition lprefix_cons1 :: \"'a \\<Rightarrow> 'sg \\<Rightarrow> 'sh \\<Rightarrow> bool\"\nwhere \"lprefix_cons1 x sg' sh \\<longleftrightarrow> lprefix (LCons x (lunstream g sg')) (lunstream h sh)\""], ["", "lemma lprefix_cons_code [code]:\n  \"lprefix_cons sg sh \\<longleftrightarrow> (case g sg of\n     Done \\<Rightarrow> True | Skip sg' \\<Rightarrow> lprefix_cons sg' sh | Yield x sg' \\<Rightarrow> lprefix_cons1 x sg' sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lprefix_cons sg sh =\n    (case g sg of Done \\<Rightarrow> True\n     | Skip sg' \\<Rightarrow> local.lprefix_cons sg' sh\n     | Yield x sg' \\<Rightarrow> local.lprefix_cons1 x sg' sh)", "by(simp add: lprefix_cons_def lprefix_cons1_def lunstream_simps split: step.split)"], ["", "lemma lprefix_cons1_code [code]:\n  \"lprefix_cons1 x sg' sh \\<longleftrightarrow> (case h sh of\n     Done \\<Rightarrow> False | Skip sh' \\<Rightarrow> lprefix_cons1 x sg' sh'\n   | Yield y sh' \\<Rightarrow> x = y \\<and> lprefix_cons sg' sh')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lprefix_cons1 x sg' sh =\n    (case h sh of Done \\<Rightarrow> False\n     | Skip sh' \\<Rightarrow> local.lprefix_cons1 x sg' sh'\n     | Yield y sh' \\<Rightarrow> x = y \\<and> local.lprefix_cons sg' sh')", "by(simp add: lprefix_cons_def lprefix_cons1_def lunstream_simps split: step.split)"], ["", "end"], ["", "lemma lprefix_cons_fusion2 [stream_fusion]:\n  \"lprefix_cons (lgenerator g) (lgenerator h) sg sh \\<longleftrightarrow> lprefix (lunstream' g sg) (lunstream' h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix_cons (lgenerator g) (lgenerator h) sg sh =\n    lprefix (lunstream' g sg) (lunstream' h sh)", "by transfer(rule lprefix_cons_def)"], ["", "lemma lprefix_cons_fusion3 [stream_fusion]:\n  \"lprefix_cons g (lgenerator h) sg sh \\<longleftrightarrow> lprefix (lunstream g sg) (lunstream' h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix_cons g (lgenerator h) sg sh =\n    lprefix (lunstream g sg) (lunstream' h sh)", "by transfer(rule lprefix_cons_def)"], ["", "lemma lprefix_cons_fusion4 [stream_fusion]:\n  \"lprefix_cons (lgenerator g) h sg sh \\<longleftrightarrow> lprefix (lunstream' g sg) (lunstream h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix_cons (lgenerator g) h sg sh =\n    lprefix (lunstream' g sg) (lunstream h sh)", "by transfer(rule lprefix_cons_def)"], ["", "subsection \\<open>Transformers\\<close>"], ["", "subsubsection \\<open>@{const lmap}\\<close>"], ["", "definition lmap_trans :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a, 's) lgenerator \\<Rightarrow> ('b, 's) lgenerator\"\nwhere \"lmap_trans = map_raw\""], ["", "lemma lunstream_lmap_trans [stream_fusion]: fixes f g s\n  defines [simp]: \"g' \\<equiv> lmap_trans f g\"\n  shows \"lunstream g' s = lmap f (lunstream g s)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream g' s = lmap f (lunstream g s)", "proof(rule lprefix_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. lprefix (lunstream g' s) (lmap f (lunstream g s))\n 2. lprefix (lmap f (lunstream g s)) (lunstream g' s)", "show \"lprefix ?lhs ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lunstream g' s) (lmap f (lunstream g s))", "proof(induction g' arbitrary: s rule: lunstream.fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x. lprefix (lunstreama x) (lmap f (lunstream g x)))\n 2. \\<And>s. lprefix LNil (lmap f (lunstream g s))\n 3. \\<And>s sa.\n       \\<lbrakk>\\<And>sa. lprefix (s sa) (lmap f (lunstream g sa));\n        llist.le_fun s (lunstream g')\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case g' sa of Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lmap f (lunstream g sa))", "case (3 lunstream_g')"], ["proof (state)\nthis:\n  lprefix (lunstream_g' ?s) (lmap f (lunstream g ?s))\n  llist.le_fun lunstream_g' (lunstream g')\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x. lprefix (lunstreama x) (lmap f (lunstream g x)))\n 2. \\<And>s. lprefix LNil (lmap f (lunstream g s))\n 3. \\<And>s sa.\n       \\<lbrakk>\\<And>sa. lprefix (s sa) (lmap f (lunstream g sa));\n        llist.le_fun s (lunstream g')\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case g' sa of Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lmap f (lunstream g sa))", "then"], ["proof (chain)\npicking this:\n  lprefix (lunstream_g' ?s) (lmap f (lunstream g ?s))\n  llist.le_fun lunstream_g' (lunstream g')", "show ?case"], ["proof (prove)\nusing this:\n  lprefix (lunstream_g' ?s) (lmap f (lunstream g ?s))\n  llist.le_fun lunstream_g' (lunstream g')\n\ngoal (1 subgoal):\n 1. lprefix\n     (case g' s of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream_g' s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream_g' s'))\n     (lmap f (lunstream g s))", "by(cases \"g s\")(simp_all add: lmap_trans_def map_raw_def lunstream_simps)"], ["proof (state)\nthis:\n  lprefix\n   (case g' s of Done \\<Rightarrow> LNil\n    | Skip s' \\<Rightarrow> lunstream_g' s'\n    | Yield x s' \\<Rightarrow> LCons x (lunstream_g' s'))\n   (lmap f (lunstream g s))\n\ngoal (2 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x. lprefix (lunstreama x) (lmap f (lunstream g x)))\n 2. \\<And>s. lprefix LNil (lmap f (lunstream g s))", "qed simp_all"], ["proof (state)\nthis:\n  lprefix (lunstream g' s) (lmap f (lunstream g s))\n\ngoal (1 subgoal):\n 1. lprefix (lmap f (lunstream g s)) (lunstream g' s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lprefix (lmap f (lunstream g s)) (lunstream g' s)", "note [cont_intro] = ccpo.admissible_leI[OF llist_ccpo]"], ["proof (state)\nthis:\n  \\<lbrakk>mcont ?luba ?orda lSup lprefix ?f;\n   mcont ?luba ?orda lSup lprefix ?g\\<rbrakk>\n  \\<Longrightarrow> ccpo.admissible ?luba ?orda\n                     (\\<lambda>x. lprefix (?f x) (?g x))\n\ngoal (1 subgoal):\n 1. lprefix (lmap f (lunstream g s)) (lunstream g' s)", "show \"lprefix ?rhs ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lmap f (lunstream g s)) (lunstream g' s)", "proof(induction g arbitrary: s rule: lunstream.fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x. lprefix (lmap f (lunstreama x)) (lunstream g' x))\n 2. \\<And>s. lprefix (lmap f LNil) (lunstream g' s)\n 3. \\<And>s sa.\n       \\<lbrakk>\\<And>sa. lprefix (lmap f (s sa)) (lunstream g' sa);\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lmap f\n                            (case g sa of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s')))\n                          (lunstream g' sa)", "case (3 lunstream_g)"], ["proof (state)\nthis:\n  lprefix (lmap f (lunstream_g ?s)) (lunstream g' ?s)\n  llist.le_fun lunstream_g (lunstream g)\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x. lprefix (lmap f (lunstreama x)) (lunstream g' x))\n 2. \\<And>s. lprefix (lmap f LNil) (lunstream g' s)\n 3. \\<And>s sa.\n       \\<lbrakk>\\<And>sa. lprefix (lmap f (s sa)) (lunstream g' sa);\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lmap f\n                            (case g sa of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s')))\n                          (lunstream g' sa)", "thus ?case"], ["proof (prove)\nusing this:\n  lprefix (lmap f (lunstream_g ?s)) (lunstream g' ?s)\n  llist.le_fun lunstream_g (lunstream g)\n\ngoal (1 subgoal):\n 1. lprefix\n     (lmap f\n       (case g s of Done \\<Rightarrow> LNil\n        | Skip s' \\<Rightarrow> lunstream_g s'\n        | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n     (lunstream g' s)", "by(cases \"g s\")(simp_all add: lmap_trans_def map_raw_def lunstream_simps)"], ["proof (state)\nthis:\n  lprefix\n   (lmap f\n     (case g s of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream_g s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n   (lunstream g' s)\n\ngoal (2 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x. lprefix (lmap f (lunstreama x)) (lunstream g' x))\n 2. \\<And>s. lprefix (lmap f LNil) (lunstream g' s)", "qed simp_all"], ["proof (state)\nthis:\n  lprefix (lmap f (lunstream g s)) (lunstream g' s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition lmap_trans' :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a, 's) lgenerator' \\<Rightarrow> ('b, 's) lgenerator'\"\nis lmap_trans"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       productive fun2 \\<Longrightarrow> productive (lmap_trans fun1 fun2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       productive fun2 \\<Longrightarrow>\n       s \\<in> productive_on (lmap_trans fun1 fun2)", "fix f :: \"'a \\<Rightarrow> 'b\" and g :: \"('a, 's) lgenerator\" and s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       productive fun2 \\<Longrightarrow>\n       s \\<in> productive_on (lmap_trans fun1 fun2)", "assume \"productive g\""], ["proof (state)\nthis:\n  productive g\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       productive fun2 \\<Longrightarrow>\n       s \\<in> productive_on (lmap_trans fun1 fun2)", "hence \"s \\<in> productive_on g\""], ["proof (prove)\nusing this:\n  productive g\n\ngoal (1 subgoal):\n 1. s \\<in> productive_on g", ".."], ["proof (state)\nthis:\n  s \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       productive fun2 \\<Longrightarrow>\n       s \\<in> productive_on (lmap_trans fun1 fun2)", "thus \"s \\<in> productive_on (lmap_trans f g)\""], ["proof (prove)\nusing this:\n  s \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. s \\<in> productive_on (lmap_trans f g)", "by induction(auto simp add: lmap_trans_def map_raw_def intro: productive_on.intros)"], ["proof (state)\nthis:\n  s \\<in> productive_on (lmap_trans f g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lunstream'_lmap_trans' [stream_fusion]:\n  \"lunstream' (lmap_trans' f g) s = lmap f (lunstream' g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream' (lmap_trans' f g) s = lmap f (lunstream' g s)", "by transfer(rule lunstream_lmap_trans)"], ["", "subsubsection \\<open>@{const ltake}\\<close>"], ["", "fun ltake_trans :: \"('a, 's) lgenerator \\<Rightarrow> ('a, (enat \\<times> 's)) lgenerator\"\nwhere\n  \"ltake_trans g (n, s) =\n  (if n = 0 then Done else case g s of \n    Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (n, s') | Yield a s' \\<Rightarrow> Yield a (epred n, s'))\""], ["", "lemma ltake_trans_fusion [stream_fusion]:\n  fixes g' g\n  defines [simp]: \"g' \\<equiv> ltake_trans g\"\n  shows \"lunstream g' (n, s) = ltake n (lunstream g s)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream g' (n, s) = ltake n (lunstream g s)", "proof(rule lprefix_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. lprefix (lunstream g' (n, s)) (ltake n (lunstream g s))\n 2. lprefix (ltake n (lunstream g s)) (lunstream g' (n, s))", "show \"lprefix ?lhs ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lunstream g' (n, s)) (ltake n (lunstream g s))", "proof(induction g' arbitrary: n s rule: lunstream.fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (lunstreama (x, xa)) (ltake x (lunstream g xa)))\n 2. \\<And>n s. lprefix LNil (ltake n (lunstream g s))\n 3. \\<And>s n sa.\n       \\<lbrakk>\\<And>n sa. lprefix (s (n, sa)) (ltake n (lunstream g sa));\n        llist.le_fun s (lunstream g')\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case g' (n, sa) of Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (ltake n (lunstream g sa))", "case (3 lunstream_g')"], ["proof (state)\nthis:\n  lprefix (lunstream_g' (?n, ?s)) (ltake ?n (lunstream g ?s))\n  llist.le_fun lunstream_g' (lunstream g')\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (lunstreama (x, xa)) (ltake x (lunstream g xa)))\n 2. \\<And>n s. lprefix LNil (ltake n (lunstream g s))\n 3. \\<And>s n sa.\n       \\<lbrakk>\\<And>n sa. lprefix (s (n, sa)) (ltake n (lunstream g sa));\n        llist.le_fun s (lunstream g')\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case g' (n, sa) of Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (ltake n (lunstream g sa))", "thus ?case"], ["proof (prove)\nusing this:\n  lprefix (lunstream_g' (?n, ?s)) (ltake ?n (lunstream g ?s))\n  llist.le_fun lunstream_g' (lunstream g')\n\ngoal (1 subgoal):\n 1. lprefix\n     (case g' (n, s) of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream_g' s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream_g' s'))\n     (ltake n (lunstream g s))", "by(cases \"g s\")(auto simp add: lunstream_simps neq_zero_conv_eSuc)"], ["proof (state)\nthis:\n  lprefix\n   (case g' (n, s) of Done \\<Rightarrow> LNil\n    | Skip s' \\<Rightarrow> lunstream_g' s'\n    | Yield x s' \\<Rightarrow> LCons x (lunstream_g' s'))\n   (ltake n (lunstream g s))\n\ngoal (2 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (lunstreama (x, xa)) (ltake x (lunstream g xa)))\n 2. \\<And>n s. lprefix LNil (ltake n (lunstream g s))", "qed simp_all"], ["proof (state)\nthis:\n  lprefix (lunstream g' (n, s)) (ltake n (lunstream g s))\n\ngoal (1 subgoal):\n 1. lprefix (ltake n (lunstream g s)) (lunstream g' (n, s))", "show \"lprefix ?rhs ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (ltake n (lunstream g s)) (lunstream g' (n, s))", "proof(induction g arbitrary: s n rule: lunstream.fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (ltake xa (lunstreama x)) (lunstream g' (xa, x)))\n 2. \\<And>s n. lprefix (ltake n LNil) (lunstream g' (n, s))\n 3. \\<And>s sa n.\n       \\<lbrakk>\\<And>sa n. lprefix (ltake n (s sa)) (lunstream g' (n, sa));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (ltake n\n                            (case g sa of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s')))\n                          (lunstream g' (n, sa))", "case (3 lunstream_g)"], ["proof (state)\nthis:\n  lprefix (ltake ?n (lunstream_g ?s)) (lunstream g' (?n, ?s))\n  llist.le_fun lunstream_g (lunstream g)\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (ltake xa (lunstreama x)) (lunstream g' (xa, x)))\n 2. \\<And>s n. lprefix (ltake n LNil) (lunstream g' (n, s))\n 3. \\<And>s sa n.\n       \\<lbrakk>\\<And>sa n. lprefix (ltake n (s sa)) (lunstream g' (n, sa));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (ltake n\n                            (case g sa of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s')))\n                          (lunstream g' (n, sa))", "thus ?case"], ["proof (prove)\nusing this:\n  lprefix (ltake ?n (lunstream_g ?s)) (lunstream g' (?n, ?s))\n  llist.le_fun lunstream_g (lunstream g)\n\ngoal (1 subgoal):\n 1. lprefix\n     (ltake n\n       (case g s of Done \\<Rightarrow> LNil\n        | Skip s' \\<Rightarrow> lunstream_g s'\n        | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n     (lunstream g' (n, s))", "by(cases \"g s\" n rule: step.exhaust[case_product enat_coexhaust])(auto simp add: lunstream_simps)"], ["proof (state)\nthis:\n  lprefix\n   (ltake n\n     (case g s of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream_g s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n   (lunstream g' (n, s))\n\ngoal (2 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (ltake xa (lunstreama x)) (lunstream g' (xa, x)))\n 2. \\<And>s n. lprefix (ltake n LNil) (lunstream g' (n, s))", "qed simp_all"], ["proof (state)\nthis:\n  lprefix (ltake n (lunstream g s)) (lunstream g' (n, s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition ltake_trans' :: \"('a, 's) lgenerator' \\<Rightarrow> ('a, (enat \\<times> 's)) lgenerator'\"\nis \"ltake_trans\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. productive fun \\<Longrightarrow> productive (ltake_trans fun)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun s.\n       productive fun \\<Longrightarrow>\n       s \\<in> productive_on (ltake_trans fun)", "fix g :: \"('a, 's) lgenerator\" and s :: \"enat \\<times> 's\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun s.\n       productive fun \\<Longrightarrow>\n       s \\<in> productive_on (ltake_trans fun)", "obtain n sg where s: \"s = (n, sg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n sg. s = (n, sg) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s)"], ["proof (state)\nthis:\n  s = (n, sg)\n\ngoal (1 subgoal):\n 1. \\<And>fun s.\n       productive fun \\<Longrightarrow>\n       s \\<in> productive_on (ltake_trans fun)", "assume \"productive g\""], ["proof (state)\nthis:\n  productive g\n\ngoal (1 subgoal):\n 1. \\<And>fun s.\n       productive fun \\<Longrightarrow>\n       s \\<in> productive_on (ltake_trans fun)", "hence \"sg \\<in> productive_on g\""], ["proof (prove)\nusing this:\n  productive g\n\ngoal (1 subgoal):\n 1. sg \\<in> productive_on g", ".."], ["proof (state)\nthis:\n  sg \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. \\<And>fun s.\n       productive fun \\<Longrightarrow>\n       s \\<in> productive_on (ltake_trans fun)", "then"], ["proof (chain)\npicking this:\n  sg \\<in> productive_on g", "show \"s \\<in> productive_on (ltake_trans g)\""], ["proof (prove)\nusing this:\n  sg \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. s \\<in> productive_on (ltake_trans g)", "unfolding \\<open>s = (n, sg)\\<close>"], ["proof (prove)\nusing this:\n  sg \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. (n, sg) \\<in> productive_on (ltake_trans g)", "apply(induction arbitrary: n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s n.\n       g s = Done \\<Longrightarrow>\n       (n, s) \\<in> productive_on (ltake_trans g)\n 2. \\<And>s s' n.\n       \\<lbrakk>g s = Skip s'; s' \\<in> productive_on g;\n        \\<And>n. (n, s') \\<in> productive_on (ltake_trans g)\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> productive_on (ltake_trans g)\n 3. \\<And>s x s' n.\n       g s = Yield x s' \\<Longrightarrow>\n       (n, s) \\<in> productive_on (ltake_trans g)", "apply(case_tac [!] n rule: enat_coexhaust)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s n.\n       \\<lbrakk>g s = Done; n = 0\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> productive_on (ltake_trans g)\n 2. \\<And>s n n'.\n       \\<lbrakk>g s = Done; n = eSuc n'\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> productive_on (ltake_trans g)\n 3. \\<And>s s' n.\n       \\<lbrakk>g s = Skip s'; s' \\<in> productive_on g;\n        \\<And>n. (n, s') \\<in> productive_on (ltake_trans g); n = 0\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> productive_on (ltake_trans g)\n 4. \\<And>s s' n n'.\n       \\<lbrakk>g s = Skip s'; s' \\<in> productive_on g;\n        \\<And>n. (n, s') \\<in> productive_on (ltake_trans g);\n        n = eSuc n'\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> productive_on (ltake_trans g)\n 5. \\<And>s x s' n.\n       \\<lbrakk>g s = Yield x s'; n = 0\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> productive_on (ltake_trans g)\n 6. \\<And>s x s' n n'.\n       \\<lbrakk>g s = Yield x s'; n = eSuc n'\\<rbrakk>\n       \\<Longrightarrow> (n, s) \\<in> productive_on (ltake_trans g)", "apply(auto intro: productive_on.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  s \\<in> productive_on (ltake_trans g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltake_trans'_fusion [stream_fusion]:\n  \"lunstream' (ltake_trans' g) (n, s) = ltake n (lunstream' g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream' (ltake_trans' g) (n, s) = ltake n (lunstream' g s)", "by transfer(rule ltake_trans_fusion)"], ["", "subsubsection \\<open>@{const ldropn}\\<close>"], ["", "abbreviation (input) ldropn_trans :: \"('b, 'a) lgenerator \\<Rightarrow> ('b, nat \\<times> 'a) lgenerator\"\nwhere \"ldropn_trans \\<equiv> drop_raw\""], ["", "lemma ldropn_trans_fusion [stream_fusion]:\n  fixes g defines [simp]: \"g' \\<equiv> ldropn_trans g\"\n  shows \"lunstream g' (n, s) = ldropn n (lunstream g s)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream g' (n, s) = ldropn n (lunstream g s)", "proof(rule lprefix_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. lprefix (lunstream g' (n, s)) (ldropn n (lunstream g s))\n 2. lprefix (ldropn n (lunstream g s)) (lunstream g' (n, s))", "show \"lprefix ?lhs ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lunstream g' (n, s)) (ldropn n (lunstream g s))", "proof(induction g' arbitrary: n s rule: lunstream.fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (lunstreama (x, xa)) (ldropn x (lunstream g xa)))\n 2. \\<And>n s. lprefix LNil (ldropn n (lunstream g s))\n 3. \\<And>s n sa.\n       \\<lbrakk>\\<And>n sa. lprefix (s (n, sa)) (ldropn n (lunstream g sa));\n        llist.le_fun s (lunstream g')\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case g' (n, sa) of Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (ldropn n (lunstream g sa))", "case (3 lunstream_g')"], ["proof (state)\nthis:\n  lprefix (lunstream_g' (?n, ?s)) (ldropn ?n (lunstream g ?s))\n  llist.le_fun lunstream_g' (lunstream g')\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (lunstreama (x, xa)) (ldropn x (lunstream g xa)))\n 2. \\<And>n s. lprefix LNil (ldropn n (lunstream g s))\n 3. \\<And>s n sa.\n       \\<lbrakk>\\<And>n sa. lprefix (s (n, sa)) (ldropn n (lunstream g sa));\n        llist.le_fun s (lunstream g')\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case g' (n, sa) of Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (ldropn n (lunstream g sa))", "thus ?case"], ["proof (prove)\nusing this:\n  lprefix (lunstream_g' (?n, ?s)) (ldropn ?n (lunstream g ?s))\n  llist.le_fun lunstream_g' (lunstream g')\n\ngoal (1 subgoal):\n 1. lprefix\n     (case g' (n, s) of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream_g' s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream_g' s'))\n     (ldropn n (lunstream g s))", "by(cases \"g s\" n rule: step.exhaust[case_product nat.exhaust])\n        (auto simp add: lunstream_simps elim: meta_allE[where x=0])"], ["proof (state)\nthis:\n  lprefix\n   (case g' (n, s) of Done \\<Rightarrow> LNil\n    | Skip s' \\<Rightarrow> lunstream_g' s'\n    | Yield x s' \\<Rightarrow> LCons x (lunstream_g' s'))\n   (ldropn n (lunstream g s))\n\ngoal (2 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (lunstreama (x, xa)) (ldropn x (lunstream g xa)))\n 2. \\<And>n s. lprefix LNil (ldropn n (lunstream g s))", "qed simp_all"], ["proof (state)\nthis:\n  lprefix (lunstream g' (n, s)) (ldropn n (lunstream g s))\n\ngoal (1 subgoal):\n 1. lprefix (ldropn n (lunstream g s)) (lunstream g' (n, s))", "note [cont_intro] = ccpo.admissible_leI[OF llist_ccpo]"], ["proof (state)\nthis:\n  \\<lbrakk>mcont ?luba ?orda lSup lprefix ?f;\n   mcont ?luba ?orda lSup lprefix ?g\\<rbrakk>\n  \\<Longrightarrow> ccpo.admissible ?luba ?orda\n                     (\\<lambda>x. lprefix (?f x) (?g x))\n\ngoal (1 subgoal):\n 1. lprefix (ldropn n (lunstream g s)) (lunstream g' (n, s))", "show \"lprefix ?rhs ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (ldropn n (lunstream g s)) (lunstream g' (n, s))", "proof(induction g arbitrary: n s rule: lunstream.fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (ldropn x (lunstreama xa)) (lunstream g' (x, xa)))\n 2. \\<And>n s. lprefix (ldropn n LNil) (lunstream g' (n, s))\n 3. \\<And>s n sa.\n       \\<lbrakk>\\<And>n sa.\n                   lprefix (ldropn n (s sa)) (lunstream g' (n, sa));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (ldropn n\n                            (case g sa of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s')))\n                          (lunstream g' (n, sa))", "case (3 lunstream_g)"], ["proof (state)\nthis:\n  lprefix (ldropn ?n (lunstream_g ?s)) (lunstream g' (?n, ?s))\n  llist.le_fun lunstream_g (lunstream g)\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (ldropn x (lunstreama xa)) (lunstream g' (x, xa)))\n 2. \\<And>n s. lprefix (ldropn n LNil) (lunstream g' (n, s))\n 3. \\<And>s n sa.\n       \\<lbrakk>\\<And>n sa.\n                   lprefix (ldropn n (s sa)) (lunstream g' (n, sa));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (ldropn n\n                            (case g sa of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s')))\n                          (lunstream g' (n, sa))", "thus ?case"], ["proof (prove)\nusing this:\n  lprefix (ldropn ?n (lunstream_g ?s)) (lunstream g' (?n, ?s))\n  llist.le_fun lunstream_g (lunstream g)\n\ngoal (1 subgoal):\n 1. lprefix\n     (ldropn n\n       (case g s of Done \\<Rightarrow> LNil\n        | Skip s' \\<Rightarrow> lunstream_g s'\n        | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n     (lunstream g' (n, s))", "by(cases n)(auto split: step.split simp add: lunstream_simps elim: meta_allE[where x=0])"], ["proof (state)\nthis:\n  lprefix\n   (ldropn n\n     (case g s of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream_g s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n   (lunstream g' (n, s))\n\ngoal (2 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (ldropn x (lunstreama xa)) (lunstream g' (x, xa)))\n 2. \\<And>n s. lprefix (ldropn n LNil) (lunstream g' (n, s))", "qed simp_all"], ["proof (state)\nthis:\n  lprefix (ldropn n (lunstream g s)) (lunstream g' (n, s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition ldropn_trans' :: \"('a, 's) lgenerator' \\<Rightarrow> ('a, nat \\<times> 's) lgenerator'\"\nis ldropn_trans"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. productive fun \\<Longrightarrow> productive (drop_raw fun)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun s.\n       productive fun \\<Longrightarrow> s \\<in> productive_on (drop_raw fun)", "fix g :: \"('a, 's) lgenerator\" and ns :: \"nat \\<times> 's\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun s.\n       productive fun \\<Longrightarrow> s \\<in> productive_on (drop_raw fun)", "obtain n s where ns: \"ns = (n, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n s. ns = (n, s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ns)"], ["proof (state)\nthis:\n  ns = (n, s)\n\ngoal (1 subgoal):\n 1. \\<And>fun s.\n       productive fun \\<Longrightarrow> s \\<in> productive_on (drop_raw fun)", "assume g: \"productive g\""], ["proof (state)\nthis:\n  productive g\n\ngoal (1 subgoal):\n 1. \\<And>fun s.\n       productive fun \\<Longrightarrow> s \\<in> productive_on (drop_raw fun)", "show \"ns \\<in> productive_on (ldropn_trans g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns \\<in> productive_on (drop_raw g)", "unfolding ns"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n, s) \\<in> productive_on (drop_raw g)", "proof(induction n arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. (0, s) \\<in> productive_on (drop_raw g)\n 2. \\<And>n s.\n       (\\<And>s. (n, s) \\<in> productive_on (drop_raw g)) \\<Longrightarrow>\n       (Suc n, s) \\<in> productive_on (drop_raw g)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. (0, s) \\<in> productive_on (drop_raw g)\n 2. \\<And>n s.\n       (\\<And>s. (n, s) \\<in> productive_on (drop_raw g)) \\<Longrightarrow>\n       (Suc n, s) \\<in> productive_on (drop_raw g)", "from g"], ["proof (chain)\npicking this:\n  productive g", "have \"s \\<in> productive_on g\""], ["proof (prove)\nusing this:\n  productive g\n\ngoal (1 subgoal):\n 1. s \\<in> productive_on g", ".."], ["proof (state)\nthis:\n  s \\<in> productive_on g\n\ngoal (2 subgoals):\n 1. \\<And>s. (0, s) \\<in> productive_on (drop_raw g)\n 2. \\<And>n s.\n       (\\<And>s. (n, s) \\<in> productive_on (drop_raw g)) \\<Longrightarrow>\n       (Suc n, s) \\<in> productive_on (drop_raw g)", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. (0, s) \\<in> productive_on (drop_raw g)", "by induction(auto intro: productive_on.intros)"], ["proof (state)\nthis:\n  (0, s) \\<in> productive_on (drop_raw g)\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s. (n, s) \\<in> productive_on (drop_raw g)) \\<Longrightarrow>\n       (Suc n, s) \\<in> productive_on (drop_raw g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s. (n, s) \\<in> productive_on (drop_raw g)) \\<Longrightarrow>\n       (Suc n, s) \\<in> productive_on (drop_raw g)", "case (Suc n)"], ["proof (state)\nthis:\n  (n, ?s) \\<in> productive_on (drop_raw g)\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s. (n, s) \\<in> productive_on (drop_raw g)) \\<Longrightarrow>\n       (Suc n, s) \\<in> productive_on (drop_raw g)", "from g"], ["proof (chain)\npicking this:\n  productive g", "have \"s \\<in> productive_on g\""], ["proof (prove)\nusing this:\n  productive g\n\ngoal (1 subgoal):\n 1. s \\<in> productive_on g", ".."], ["proof (state)\nthis:\n  s \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s. (n, s) \\<in> productive_on (drop_raw g)) \\<Longrightarrow>\n       (Suc n, s) \\<in> productive_on (drop_raw g)", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. (Suc n, s) \\<in> productive_on (drop_raw g)", "by induction(auto intro: productive_on.intros Suc.IH)"], ["proof (state)\nthis:\n  (Suc n, s) \\<in> productive_on (drop_raw g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ns \\<in> productive_on (drop_raw g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldropn_trans'_fusion [stream_fusion]:\n  \"lunstream' (ldropn_trans' g) (n, s) = ldropn n (lunstream' g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream' (ldropn_trans' g) (n, s) = ldropn n (lunstream' g s)", "by transfer(rule ldropn_trans_fusion)"], ["", "subsubsection \\<open>@{const ldrop}\\<close>"], ["", "fun ldrop_trans :: \"('a, 's) lgenerator \\<Rightarrow> ('a, enat \\<times> 's) lgenerator\"\nwhere\n  \"ldrop_trans g (n, s) = (case g s of \n    Done \\<Rightarrow> Done | Skip s' \\<Rightarrow> Skip (n, s')\n  | Yield x s' \\<Rightarrow> (if n = 0 then Yield x (n, s') else Skip (epred n, s')))\""], ["", "lemma ldrop_trans_fusion [stream_fusion]:\n  fixes g g' defines [simp]: \"g' \\<equiv> ldrop_trans g\"\n  shows \"lunstream g' (n, s) = ldrop n (lunstream g s)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream g' (n, s) = ldrop n (lunstream g s)", "proof(rule lprefix_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. lprefix (lunstream g' (n, s)) (ldrop n (lunstream g s))\n 2. lprefix (ldrop n (lunstream g s)) (lunstream g' (n, s))", "show \"lprefix ?lhs ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lunstream g' (n, s)) (ldrop n (lunstream g s))", "by(induction g' arbitrary: n s rule: lunstream.fixp_induct)\n      (auto simp add: lunstream_simps neq_zero_conv_eSuc elim: meta_allE[where x=0] split: step.split)"], ["proof (state)\nthis:\n  lprefix (lunstream g' (n, s)) (ldrop n (lunstream g s))\n\ngoal (1 subgoal):\n 1. lprefix (ldrop n (lunstream g s)) (lunstream g' (n, s))", "show \"lprefix ?rhs ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (ldrop n (lunstream g s)) (lunstream g' (n, s))", "proof(induction g arbitrary: n s rule: lunstream.fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (ldrop x (lunstreama xa)) (lunstream g' (x, xa)))\n 2. \\<And>n s. lprefix (ldrop n LNil) (lunstream g' (n, s))\n 3. \\<And>s n sa.\n       \\<lbrakk>\\<And>n sa. lprefix (ldrop n (s sa)) (lunstream g' (n, sa));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (ldrop n\n                            (case g sa of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s')))\n                          (lunstream g' (n, sa))", "case (3 lunstream_g)"], ["proof (state)\nthis:\n  lprefix (ldrop ?n (lunstream_g ?s)) (lunstream g' (?n, ?s))\n  llist.le_fun lunstream_g (lunstream g)\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (ldrop x (lunstreama xa)) (lunstream g' (x, xa)))\n 2. \\<And>n s. lprefix (ldrop n LNil) (lunstream g' (n, s))\n 3. \\<And>s n sa.\n       \\<lbrakk>\\<And>n sa. lprefix (ldrop n (s sa)) (lunstream g' (n, sa));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (ldrop n\n                            (case g sa of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s')))\n                          (lunstream g' (n, sa))", "thus ?case"], ["proof (prove)\nusing this:\n  lprefix (ldrop ?n (lunstream_g ?s)) (lunstream g' (?n, ?s))\n  llist.le_fun lunstream_g (lunstream g)\n\ngoal (1 subgoal):\n 1. lprefix\n     (ldrop n\n       (case g s of Done \\<Rightarrow> LNil\n        | Skip s' \\<Rightarrow> lunstream_g s'\n        | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n     (lunstream g' (n, s))", "by(cases n rule: enat_coexhaust)(auto simp add: lunstream_simps split: step.split elim: meta_allE[where x=0])"], ["proof (state)\nthis:\n  lprefix\n   (ldrop n\n     (case g s of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream_g s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n   (lunstream g' (n, s))\n\ngoal (2 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa.\n            lprefix (ldrop x (lunstreama xa)) (lunstream g' (x, xa)))\n 2. \\<And>n s. lprefix (ldrop n LNil) (lunstream g' (n, s))", "qed simp_all"], ["proof (state)\nthis:\n  lprefix (ldrop n (lunstream g s)) (lunstream g' (n, s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldrop_trans_fusion2 [stream_fusion]:\n  \"lunstream (ldrop_trans (lgenerator g)) (n, s) = ldrop n (lunstream' g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream (ldrop_trans (lgenerator g)) (n, s) = ldrop n (lunstream' g s)", "by transfer (rule ldrop_trans_fusion)"], ["", "subsubsection \\<open>@{const ltakeWhile}\\<close>"], ["", "abbreviation (input) ltakeWhile_trans :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a, 's) lgenerator \\<Rightarrow> ('a, 's) lgenerator\"\nwhere \"ltakeWhile_trans \\<equiv> takeWhile_raw\""], ["", "lemma ltakeWhile_trans_fusion [stream_fusion]:\n  fixes P g g' defines [simp]: \"g' \\<equiv> ltakeWhile_trans P g\"\n  shows \"lunstream g' s = ltakeWhile P (lunstream g s)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream g' s = ltakeWhile P (lunstream g s)", "proof(rule lprefix_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. lprefix (lunstream g' s) (ltakeWhile P (lunstream g s))\n 2. lprefix (ltakeWhile P (lunstream g s)) (lunstream g' s)", "show \"lprefix ?lhs ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lunstream g' s) (ltakeWhile P (lunstream g s))", "by(induction g' arbitrary: s rule: lunstream.fixp_induct)(auto simp add: lunstream_simps takeWhile_raw_def split: step.split)"], ["proof (state)\nthis:\n  lprefix (lunstream g' s) (ltakeWhile P (lunstream g s))\n\ngoal (1 subgoal):\n 1. lprefix (ltakeWhile P (lunstream g s)) (lunstream g' s)", "show \"lprefix ?rhs ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (ltakeWhile P (lunstream g s)) (lunstream g' s)", "by(induction g arbitrary: s rule: lunstream.fixp_induct)(auto split: step.split simp add: lunstream_simps takeWhile_raw_def)"], ["proof (state)\nthis:\n  lprefix (ltakeWhile P (lunstream g s)) (lunstream g' s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition ltakeWhile_trans' :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a, 's) lgenerator' \\<Rightarrow> ('a, 's) lgenerator'\"\nis ltakeWhile_trans"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       productive fun2 \\<Longrightarrow>\n       productive (takeWhile_raw fun1 fun2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       productive fun2 \\<Longrightarrow>\n       s \\<in> productive_on (takeWhile_raw fun1 fun2)", "fix P and g :: \"('a, 's) lgenerator\" and s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       productive fun2 \\<Longrightarrow>\n       s \\<in> productive_on (takeWhile_raw fun1 fun2)", "assume \"productive g\""], ["proof (state)\nthis:\n  productive g\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       productive fun2 \\<Longrightarrow>\n       s \\<in> productive_on (takeWhile_raw fun1 fun2)", "hence \"s \\<in> productive_on g\""], ["proof (prove)\nusing this:\n  productive g\n\ngoal (1 subgoal):\n 1. s \\<in> productive_on g", ".."], ["proof (state)\nthis:\n  s \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       productive fun2 \\<Longrightarrow>\n       s \\<in> productive_on (takeWhile_raw fun1 fun2)", "thus \"s \\<in> productive_on (ltakeWhile_trans P g)\""], ["proof (prove)\nusing this:\n  s \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. s \\<in> productive_on (takeWhile_raw P g)", "apply(induction)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       g s = Done \\<Longrightarrow>\n       s \\<in> productive_on (takeWhile_raw P g)\n 2. \\<And>s s'.\n       \\<lbrakk>g s = Skip s'; s' \\<in> productive_on g;\n        s' \\<in> productive_on (takeWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (takeWhile_raw P g)\n 3. \\<And>s x s'.\n       g s = Yield x s' \\<Longrightarrow>\n       s \\<in> productive_on (takeWhile_raw P g)", "apply(case_tac [3] \"P x\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       g s = Done \\<Longrightarrow>\n       s \\<in> productive_on (takeWhile_raw P g)\n 2. \\<And>s s'.\n       \\<lbrakk>g s = Skip s'; s' \\<in> productive_on g;\n        s' \\<in> productive_on (takeWhile_raw P g)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (takeWhile_raw P g)\n 3. \\<And>s x s'.\n       \\<lbrakk>g s = Yield x s'; P x\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (takeWhile_raw P g)\n 4. \\<And>s x s'.\n       \\<lbrakk>g s = Yield x s'; \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (takeWhile_raw P g)", "apply(auto intro: productive_on.intros simp add: takeWhile_raw_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  s \\<in> productive_on (takeWhile_raw P g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltakeWhile_trans'_fusion [stream_fusion]:\n  \"lunstream' (ltakeWhile_trans' P g) s = ltakeWhile P (lunstream' g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream' (ltakeWhile_trans' P g) s = ltakeWhile P (lunstream' g s)", "by transfer(rule ltakeWhile_trans_fusion)"], ["", "subsubsection \\<open>@{const ldropWhile}\\<close>"], ["", "abbreviation (input) ldropWhile_trans :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) lgenerator \\<Rightarrow> ('a, bool \\<times> 'b) lgenerator\"\nwhere \"ldropWhile_trans \\<equiv> dropWhile_raw\""], ["", "lemma ldropWhile_trans_fusion [stream_fusion]:\n  fixes P g g' defines [simp]: \"g' \\<equiv> ldropWhile_trans P g\"\n  shows \"lunstream g' (True, s) = ldropWhile P (lunstream g s)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream g' (True, s) = ldropWhile P (lunstream g s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lunstream g' (True, s) = ldropWhile P (lunstream g s)", "have \"lprefix ?lhs ?rhs\" \"lprefix (lunstream g' (False, s)) (lunstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lunstream g' (True, s)) (ldropWhile P (lunstream g s)) &&&\n    lprefix (lunstream g' (False, s)) (lunstream g s)", "by(induction g' arbitrary: s rule: lunstream.fixp_induct)(simp_all add: lunstream_simps split: step.split)"], ["proof (state)\nthis:\n  lprefix (lunstream g' (True, s)) (ldropWhile P (lunstream g s))\n  lprefix (lunstream g' (False, s)) (lunstream g s)\n\ngoal (1 subgoal):\n 1. lunstream g' (True, s) = ldropWhile P (lunstream g s)", "moreover"], ["proof (state)\nthis:\n  lprefix (lunstream g' (True, s)) (ldropWhile P (lunstream g s))\n  lprefix (lunstream g' (False, s)) (lunstream g s)\n\ngoal (1 subgoal):\n 1. lunstream g' (True, s) = ldropWhile P (lunstream g s)", "have \"lprefix ?rhs ?lhs\" \"lprefix (lunstream g s) (lunstream g' (False, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (ldropWhile P (lunstream g s)) (lunstream g' (True, s)) &&&\n    lprefix (lunstream g s) (lunstream g' (False, s))", "by(induction g arbitrary: s rule: lunstream.fixp_induct)(simp_all add: lunstream_simps split: step.split)"], ["proof (state)\nthis:\n  lprefix (ldropWhile P (lunstream g s)) (lunstream g' (True, s))\n  lprefix (lunstream g s) (lunstream g' (False, s))\n\ngoal (1 subgoal):\n 1. lunstream g' (True, s) = ldropWhile P (lunstream g s)", "ultimately"], ["proof (chain)\npicking this:\n  lprefix (lunstream g' (True, s)) (ldropWhile P (lunstream g s))\n  lprefix (lunstream g' (False, s)) (lunstream g s)\n  lprefix (ldropWhile P (lunstream g s)) (lunstream g' (True, s))\n  lprefix (lunstream g s) (lunstream g' (False, s))", "show ?thesis"], ["proof (prove)\nusing this:\n  lprefix (lunstream g' (True, s)) (ldropWhile P (lunstream g s))\n  lprefix (lunstream g' (False, s)) (lunstream g s)\n  lprefix (ldropWhile P (lunstream g s)) (lunstream g' (True, s))\n  lprefix (lunstream g s) (lunstream g' (False, s))\n\ngoal (1 subgoal):\n 1. lunstream g' (True, s) = ldropWhile P (lunstream g s)", "by(blast intro: lprefix_antisym)"], ["proof (state)\nthis:\n  lunstream g' (True, s) = ldropWhile P (lunstream g s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldropWhile_trans_fusion2 [stream_fusion]:\n  \"lunstream (ldropWhile_trans P (lgenerator g)) (True, s) = ldropWhile P (lunstream' g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream (dropWhile_raw P (lgenerator g)) (True, s) =\n    ldropWhile P (lunstream' g s)", "by transfer(rule ldropWhile_trans_fusion)"], ["", "subsubsection \\<open>@{const lzip}\\<close>"], ["", "abbreviation (input) lzip_trans :: \"('a, 's1) lgenerator \\<Rightarrow> ('b, 's2) lgenerator \\<Rightarrow> ('a \\<times> 'b, 's1 \\<times> 's2 \\<times> 'a option) lgenerator\"\nwhere \"lzip_trans \\<equiv> zip_raw\""], ["", "lemma lzip_trans_fusion [stream_fusion]:\n  fixes g h gh defines [simp]: \"gh \\<equiv> lzip_trans g h\"\n  shows \"lunstream gh (sg, sh, None) = lzip (lunstream g sg) (lunstream h sh)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream gh (sg, sh, None) = lzip (lunstream g sg) (lunstream h sh)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lunstream gh (sg, sh, None) = lzip (lunstream g sg) (lunstream h sh)", "have \"lprefix ?lhs ?rhs\"\n    and \"\\<And>x. lprefix (lunstream gh (sg, sh, Some x)) (lzip (LCons x (lunstream g sg)) (lunstream h sh))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lunstream gh (sg, sh, None))\n     (lzip (lunstream g sg) (lunstream h sh)) &&&\n    (\\<And>x.\n        lprefix (lunstream gh (sg, sh, Some x))\n         (lzip (LCons x (lunstream g sg)) (lunstream h sh)))", "proof(induction gh arbitrary: sg sh rule: lunstream.fixp_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lunstreama (x, xa, None))\n              (lzip (lunstream g x) (lunstream h xa))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lunstreama (xa, xb, Some x))\n              (lzip (LCons x (lunstream g xa)) (lunstream h xb))))\n 2. \\<And>sg sh. lprefix LNil (lzip (lunstream g sg) (lunstream h sh))\n 3. \\<And>x sg sh.\n       lprefix LNil (lzip (LCons x (lunstream g sg)) (lunstream h sh))\n 4. \\<And>s sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (s (sg, sh, None))\n                    (lzip (lunstream g sg) (lunstream h sh));\n        \\<And>x sg sh.\n           lprefix (s (sg, sh, Some x))\n            (lzip (LCons x (lunstream g sg)) (lunstream h sh));\n        llist.le_fun s (lunstream gh)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case gh (sg, sh, None) of Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lzip (lunstream g sg) (lunstream h sh))\n 5. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (s (sg, sh, None))\n                    (lzip (lunstream g sg) (lunstream h sh));\n        \\<And>x sg sh.\n           lprefix (s (sg, sh, Some x))\n            (lzip (LCons x (lunstream g sg)) (lunstream h sh));\n        llist.le_fun s (lunstream gh)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case gh (sg, sh, Some x) of\n                           Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lzip (LCons x (lunstream g sg)) (lunstream h sh))", "case (3 lunstream)"], ["proof (state)\nthis:\n  lprefix (lunstream (?sg, ?sh, None))\n   (lzip (lunstream g ?sg) (lunstream h ?sh))\n  lprefix (lunstream (?sg, ?sh, Some ?x))\n   (lzip (LCons ?x (lunstream g ?sg)) (lunstream h ?sh))\n  llist.le_fun lunstream (lunstream gh)\n\ngoal (5 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lunstreama (x, xa, None))\n              (lzip (lunstream g x) (lunstream h xa))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lunstreama (xa, xb, Some x))\n              (lzip (LCons x (lunstream g xa)) (lunstream h xb))))\n 2. \\<And>sg sh. lprefix LNil (lzip (lunstream g sg) (lunstream h sh))\n 3. \\<And>x sg sh.\n       lprefix LNil (lzip (LCons x (lunstream g sg)) (lunstream h sh))\n 4. \\<And>s sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (s (sg, sh, None))\n                    (lzip (lunstream g sg) (lunstream h sh));\n        \\<And>x sg sh.\n           lprefix (s (sg, sh, Some x))\n            (lzip (LCons x (lunstream g sg)) (lunstream h sh));\n        llist.le_fun s (lunstream gh)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case gh (sg, sh, None) of Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lzip (lunstream g sg) (lunstream h sh))\n 5. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (s (sg, sh, None))\n                    (lzip (lunstream g sg) (lunstream h sh));\n        \\<And>x sg sh.\n           lprefix (s (sg, sh, Some x))\n            (lzip (LCons x (lunstream g sg)) (lunstream h sh));\n        llist.le_fun s (lunstream gh)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case gh (sg, sh, Some x) of\n                           Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lzip (LCons x (lunstream g sg)) (lunstream h sh))", "{"], ["proof (state)\nthis:\n  lprefix (lunstream (?sg, ?sh, None))\n   (lzip (lunstream g ?sg) (lunstream h ?sh))\n  lprefix (lunstream (?sg, ?sh, Some ?x))\n   (lzip (LCons ?x (lunstream g ?sg)) (lunstream h ?sh))\n  llist.le_fun lunstream (lunstream gh)\n\ngoal (5 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lunstreama (x, xa, None))\n              (lzip (lunstream g x) (lunstream h xa))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lunstreama (xa, xb, Some x))\n              (lzip (LCons x (lunstream g xa)) (lunstream h xb))))\n 2. \\<And>sg sh. lprefix LNil (lzip (lunstream g sg) (lunstream h sh))\n 3. \\<And>x sg sh.\n       lprefix LNil (lzip (LCons x (lunstream g sg)) (lunstream h sh))\n 4. \\<And>s sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (s (sg, sh, None))\n                    (lzip (lunstream g sg) (lunstream h sh));\n        \\<And>x sg sh.\n           lprefix (s (sg, sh, Some x))\n            (lzip (LCons x (lunstream g sg)) (lunstream h sh));\n        llist.le_fun s (lunstream gh)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case gh (sg, sh, None) of Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lzip (lunstream g sg) (lunstream h sh))\n 5. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (s (sg, sh, None))\n                    (lzip (lunstream g sg) (lunstream h sh));\n        \\<And>x sg sh.\n           lprefix (s (sg, sh, Some x))\n            (lzip (LCons x (lunstream g sg)) (lunstream h sh));\n        llist.le_fun s (lunstream gh)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case gh (sg, sh, Some x) of\n                           Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lzip (LCons x (lunstream g sg)) (lunstream h sh))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lunstreama (x, xa, None))\n              (lzip (lunstream g x) (lunstream h xa))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lunstreama (xa, xb, Some x))\n              (lzip (LCons x (lunstream g xa)) (lunstream h xb))))\n 2. \\<And>sg sh. lprefix LNil (lzip (lunstream g sg) (lunstream h sh))\n 3. \\<And>x sg sh.\n       lprefix LNil (lzip (LCons x (lunstream g sg)) (lunstream h sh))\n 4. \\<And>s sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (s (sg, sh, None))\n                    (lzip (lunstream g sg) (lunstream h sh));\n        \\<And>x sg sh.\n           lprefix (s (sg, sh, Some x))\n            (lzip (LCons x (lunstream g sg)) (lunstream h sh));\n        llist.le_fun s (lunstream gh)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case gh (sg, sh, None) of Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lzip (lunstream g sg) (lunstream h sh))\n 5. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (s (sg, sh, None))\n                    (lzip (lunstream g sg) (lunstream h sh));\n        \\<And>x sg sh.\n           lprefix (s (sg, sh, Some x))\n            (lzip (LCons x (lunstream g sg)) (lunstream h sh));\n        llist.le_fun s (lunstream gh)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case gh (sg, sh, Some x) of\n                           Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lzip (LCons x (lunstream g sg)) (lunstream h sh))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix\n     (case gh (sg, sh, None) of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream s'))\n     (lzip (lunstream g sg) (lunstream h sh))", "using 3"], ["proof (prove)\nusing this:\n  lprefix (lunstream (?sg, ?sh, None))\n   (lzip (lunstream g ?sg) (lunstream h ?sh))\n  lprefix (lunstream (?sg, ?sh, Some ?x))\n   (lzip (LCons ?x (lunstream g ?sg)) (lunstream h ?sh))\n  llist.le_fun lunstream (lunstream gh)\n\ngoal (1 subgoal):\n 1. lprefix\n     (case gh (sg, sh, None) of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream s'))\n     (lzip (lunstream g sg) (lunstream h sh))", "by(cases \"g sg\")(simp_all add: lunstream_simps)"], ["proof (state)\nthis:\n  lprefix\n   (case gh (sg, sh, None) of Done \\<Rightarrow> LNil\n    | Skip s' \\<Rightarrow> lunstream s'\n    | Yield x s' \\<Rightarrow> LCons x (lunstream s'))\n   (lzip (lunstream g sg) (lunstream h sh))\n\ngoal (4 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lunstreama (x, xa, None))\n              (lzip (lunstream g x) (lunstream h xa))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lunstreama (xa, xb, Some x))\n              (lzip (LCons x (lunstream g xa)) (lunstream h xb))))\n 2. \\<And>sg sh. lprefix LNil (lzip (lunstream g sg) (lunstream h sh))\n 3. \\<And>x sg sh.\n       lprefix LNil (lzip (LCons x (lunstream g sg)) (lunstream h sh))\n 4. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (s (sg, sh, None))\n                    (lzip (lunstream g sg) (lunstream h sh));\n        \\<And>x sg sh.\n           lprefix (s (sg, sh, Some x))\n            (lzip (LCons x (lunstream g sg)) (lunstream h sh));\n        llist.le_fun s (lunstream gh)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case gh (sg, sh, Some x) of\n                           Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lzip (LCons x (lunstream g sg)) (lunstream h sh))", "}"], ["proof (state)\nthis:\n  lprefix\n   (case gh (?sga2, ?sha2, None) of Done \\<Rightarrow> LNil\n    | Skip s' \\<Rightarrow> lunstream s'\n    | Yield x s' \\<Rightarrow> LCons x (lunstream s'))\n   (lzip (lunstream g ?sga2) (lunstream h ?sha2))\n\ngoal (4 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lunstreama (x, xa, None))\n              (lzip (lunstream g x) (lunstream h xa))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lunstreama (xa, xb, Some x))\n              (lzip (LCons x (lunstream g xa)) (lunstream h xb))))\n 2. \\<And>sg sh. lprefix LNil (lzip (lunstream g sg) (lunstream h sh))\n 3. \\<And>x sg sh.\n       lprefix LNil (lzip (LCons x (lunstream g sg)) (lunstream h sh))\n 4. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (s (sg, sh, None))\n                    (lzip (lunstream g sg) (lunstream h sh));\n        \\<And>x sg sh.\n           lprefix (s (sg, sh, Some x))\n            (lzip (LCons x (lunstream g sg)) (lunstream h sh));\n        llist.le_fun s (lunstream gh)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case gh (sg, sh, Some x) of\n                           Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lzip (LCons x (lunstream g sg)) (lunstream h sh))", "{"], ["proof (state)\nthis:\n  lprefix\n   (case gh (?sga2, ?sha2, None) of Done \\<Rightarrow> LNil\n    | Skip s' \\<Rightarrow> lunstream s'\n    | Yield x s' \\<Rightarrow> LCons x (lunstream s'))\n   (lzip (lunstream g ?sga2) (lunstream h ?sha2))\n\ngoal (4 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lunstreama (x, xa, None))\n              (lzip (lunstream g x) (lunstream h xa))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lunstreama (xa, xb, Some x))\n              (lzip (LCons x (lunstream g xa)) (lunstream h xb))))\n 2. \\<And>sg sh. lprefix LNil (lzip (lunstream g sg) (lunstream h sh))\n 3. \\<And>x sg sh.\n       lprefix LNil (lzip (LCons x (lunstream g sg)) (lunstream h sh))\n 4. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (s (sg, sh, None))\n                    (lzip (lunstream g sg) (lunstream h sh));\n        \\<And>x sg sh.\n           lprefix (s (sg, sh, Some x))\n            (lzip (LCons x (lunstream g sg)) (lunstream h sh));\n        llist.le_fun s (lunstream gh)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case gh (sg, sh, Some x) of\n                           Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lzip (LCons x (lunstream g sg)) (lunstream h sh))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lunstreama (x, xa, None))\n              (lzip (lunstream g x) (lunstream h xa))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lunstreama (xa, xb, Some x))\n              (lzip (LCons x (lunstream g xa)) (lunstream h xb))))\n 2. \\<And>sg sh. lprefix LNil (lzip (lunstream g sg) (lunstream h sh))\n 3. \\<And>x sg sh.\n       lprefix LNil (lzip (LCons x (lunstream g sg)) (lunstream h sh))\n 4. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (s (sg, sh, None))\n                    (lzip (lunstream g sg) (lunstream h sh));\n        \\<And>x sg sh.\n           lprefix (s (sg, sh, Some x))\n            (lzip (LCons x (lunstream g sg)) (lunstream h sh));\n        llist.le_fun s (lunstream gh)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (case gh (sg, sh, Some x) of\n                           Done \\<Rightarrow> LNil\n                           | Skip x \\<Rightarrow> s x\n                           | Yield x s' \\<Rightarrow> LCons x (s s'))\n                          (lzip (LCons x (lunstream g sg)) (lunstream h sh))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix\n     (case gh (sg, sh, Some x) of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream s'))\n     (lzip (LCons x (lunstream g sg)) (lunstream h sh))", "using 3"], ["proof (prove)\nusing this:\n  lprefix (lunstream (?sg, ?sh, None))\n   (lzip (lunstream g ?sg) (lunstream h ?sh))\n  lprefix (lunstream (?sg, ?sh, Some ?x))\n   (lzip (LCons ?x (lunstream g ?sg)) (lunstream h ?sh))\n  llist.le_fun lunstream (lunstream gh)\n\ngoal (1 subgoal):\n 1. lprefix\n     (case gh (sg, sh, Some x) of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream s'))\n     (lzip (LCons x (lunstream g sg)) (lunstream h sh))", "by(cases \"h sh\")(simp_all add: lunstream_simps)"], ["proof (state)\nthis:\n  lprefix\n   (case gh (sg, sh, Some x) of Done \\<Rightarrow> LNil\n    | Skip s' \\<Rightarrow> lunstream s'\n    | Yield x s' \\<Rightarrow> LCons x (lunstream s'))\n   (lzip (LCons x (lunstream g sg)) (lunstream h sh))\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lunstreama (x, xa, None))\n              (lzip (lunstream g x) (lunstream h xa))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lunstreama (xa, xb, Some x))\n              (lzip (LCons x (lunstream g xa)) (lunstream h xb))))\n 2. \\<And>sg sh. lprefix LNil (lzip (lunstream g sg) (lunstream h sh))\n 3. \\<And>x sg sh.\n       lprefix LNil (lzip (LCons x (lunstream g sg)) (lunstream h sh))", "}"], ["proof (state)\nthis:\n  lprefix\n   (case gh (?sga2, ?sha2, Some ?x2) of Done \\<Rightarrow> LNil\n    | Skip s' \\<Rightarrow> lunstream s'\n    | Yield x s' \\<Rightarrow> LCons x (lunstream s'))\n   (lzip (LCons ?x2 (lunstream g ?sga2)) (lunstream h ?sha2))\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lunstreama (x, xa, None))\n              (lzip (lunstream g x) (lunstream h xa))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lunstreama (xa, xb, Some x))\n              (lzip (LCons x (lunstream g xa)) (lunstream h xb))))\n 2. \\<And>sg sh. lprefix LNil (lzip (lunstream g sg) (lunstream h sh))\n 3. \\<And>x sg sh.\n       lprefix LNil (lzip (LCons x (lunstream g sg)) (lunstream h sh))", "qed simp_all"], ["proof (state)\nthis:\n  lprefix (lunstream gh (sg, sh, None))\n   (lzip (lunstream g sg) (lunstream h sh))\n  lprefix (lunstream gh (sg, sh, Some ?x))\n   (lzip (LCons ?x (lunstream g sg)) (lunstream h sh))\n\ngoal (1 subgoal):\n 1. lunstream gh (sg, sh, None) = lzip (lunstream g sg) (lunstream h sh)", "moreover"], ["proof (state)\nthis:\n  lprefix (lunstream gh (sg, sh, None))\n   (lzip (lunstream g sg) (lunstream h sh))\n  lprefix (lunstream gh (sg, sh, Some ?x))\n   (lzip (LCons ?x (lunstream g sg)) (lunstream h sh))\n\ngoal (1 subgoal):\n 1. lunstream gh (sg, sh, None) = lzip (lunstream g sg) (lunstream h sh)", "note [cont_intro] = ccpo.admissible_leI[OF llist_ccpo]"], ["proof (state)\nthis:\n  \\<lbrakk>mcont ?luba ?orda lSup lprefix ?f;\n   mcont ?luba ?orda lSup lprefix ?g\\<rbrakk>\n  \\<Longrightarrow> ccpo.admissible ?luba ?orda\n                     (\\<lambda>x. lprefix (?f x) (?g x))\n\ngoal (1 subgoal):\n 1. lunstream gh (sg, sh, None) = lzip (lunstream g sg) (lunstream h sh)", "have \"lprefix ?rhs ?lhs\" \n    and \"\\<And>x. lprefix (lzip (LCons x (lunstream g sg)) (lunstream h sh)) (lunstream gh (sg, sh, Some x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lzip (lunstream g sg) (lunstream h sh))\n     (lunstream gh (sg, sh, None)) &&&\n    (\\<And>x.\n        lprefix (lzip (LCons x (lunstream g sg)) (lunstream h sh))\n         (lunstream gh (sg, sh, Some x)))", "proof(induction g arbitrary: sg sh rule: lunstream.fixp_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))\n 4. \\<And>s sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (case g sg of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s'))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, None))\n 5. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip x \\<Rightarrow> s x\n                               | Yield x s' \\<Rightarrow> LCons x (s s')))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, Some x))", "case (3 lunstream_g)"], ["proof (state)\nthis:\n  lprefix (lzip (lunstream_g ?sg) (lunstream h ?sh))\n   (lunstream gh (?sg, ?sh, None))\n  lprefix (lzip (LCons ?x (lunstream_g ?sg)) (lunstream h ?sh))\n   (lunstream gh (?sg, ?sh, Some ?x))\n  llist.le_fun lunstream_g (lunstream g)\n\ngoal (5 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))\n 4. \\<And>s sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (case g sg of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s'))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, None))\n 5. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip x \\<Rightarrow> s x\n                               | Yield x s' \\<Rightarrow> LCons x (s s')))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, Some x))", "note IH = \"3.IH\""], ["proof (state)\nthis:\n  lprefix (lzip (lunstream_g ?sg) (lunstream h ?sh))\n   (lunstream gh (?sg, ?sh, None))\n  lprefix (lzip (LCons ?x (lunstream_g ?sg)) (lunstream h ?sh))\n   (lunstream gh (?sg, ?sh, Some ?x))\n\ngoal (5 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))\n 4. \\<And>s sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (case g sg of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s'))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, None))\n 5. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip x \\<Rightarrow> s x\n                               | Yield x s' \\<Rightarrow> LCons x (s s')))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, Some x))", "{"], ["proof (state)\nthis:\n  lprefix (lzip (lunstream_g ?sg) (lunstream h ?sh))\n   (lunstream gh (?sg, ?sh, None))\n  lprefix (lzip (LCons ?x (lunstream_g ?sg)) (lunstream h ?sh))\n   (lunstream gh (?sg, ?sh, Some ?x))\n\ngoal (5 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))\n 4. \\<And>s sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (case g sg of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s'))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, None))\n 5. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip x \\<Rightarrow> s x\n                               | Yield x s' \\<Rightarrow> LCons x (s s')))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, Some x))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))\n 4. \\<And>s sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (case g sg of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s'))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, None))\n 5. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip x \\<Rightarrow> s x\n                               | Yield x s' \\<Rightarrow> LCons x (s s')))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, Some x))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix\n     (lzip\n       (case g sg of Done \\<Rightarrow> LNil\n        | Skip s' \\<Rightarrow> lunstream_g s'\n        | Yield x s' \\<Rightarrow> LCons x (lunstream_g s'))\n       (lunstream h sh))\n     (lunstream gh (sg, sh, None))", "using 3"], ["proof (prove)\nusing this:\n  lprefix (lzip (lunstream_g ?sg) (lunstream h ?sh))\n   (lunstream gh (?sg, ?sh, None))\n  lprefix (lzip (LCons ?x (lunstream_g ?sg)) (lunstream h ?sh))\n   (lunstream gh (?sg, ?sh, Some ?x))\n  llist.le_fun lunstream_g (lunstream g)\n\ngoal (1 subgoal):\n 1. lprefix\n     (lzip\n       (case g sg of Done \\<Rightarrow> LNil\n        | Skip s' \\<Rightarrow> lunstream_g s'\n        | Yield x s' \\<Rightarrow> LCons x (lunstream_g s'))\n       (lunstream h sh))\n     (lunstream gh (sg, sh, None))", "by(cases \"g sg\")(simp_all add: lunstream_simps fun_ord_def)"], ["proof (state)\nthis:\n  lprefix\n   (lzip\n     (case g sg of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream_g s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream_g s'))\n     (lunstream h sh))\n   (lunstream gh (sg, sh, None))\n\ngoal (4 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))\n 4. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip x \\<Rightarrow> s x\n                               | Yield x s' \\<Rightarrow> LCons x (s s')))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, Some x))", "}"], ["proof (state)\nthis:\n  lprefix\n   (lzip\n     (case g ?sga2 of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream_g s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream_g s'))\n     (lunstream h ?sha2))\n   (lunstream gh (?sga2, ?sha2, None))\n\ngoal (4 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))\n 4. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip x \\<Rightarrow> s x\n                               | Yield x s' \\<Rightarrow> LCons x (s s')))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, Some x))", "{"], ["proof (state)\nthis:\n  lprefix\n   (lzip\n     (case g ?sga2 of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> lunstream_g s'\n      | Yield x s' \\<Rightarrow> LCons x (lunstream_g s'))\n     (lunstream h ?sha2))\n   (lunstream gh (?sga2, ?sha2, None))\n\ngoal (4 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))\n 4. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip x \\<Rightarrow> s x\n                               | Yield x s' \\<Rightarrow> LCons x (s s')))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, Some x))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))\n 4. \\<And>s x sg sh.\n       \\<lbrakk>\\<And>sg sh.\n                   lprefix (lzip (s sg) (lunstream h sh))\n                    (lunstream gh (sg, sh, None));\n        \\<And>x sg sh.\n           lprefix (lzip (LCons x (s sg)) (lunstream h sh))\n            (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream g)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip x \\<Rightarrow> s x\n                               | Yield x s' \\<Rightarrow> LCons x (s s')))\n                            (lunstream h sh))\n                          (lunstream gh (sg, sh, Some x))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix\n     (lzip\n       (LCons x\n         (case g sg of Done \\<Rightarrow> LNil\n          | Skip s' \\<Rightarrow> lunstream_g s'\n          | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n       (lunstream h sh))\n     (lunstream gh (sg, sh, Some x))", "proof(induction h arbitrary: sh sg x rule: lunstream.fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa xaa.\n            lprefix\n             (lzip\n               (LCons xaa\n                 (case g xa of Done \\<Rightarrow> LNil\n                  | Skip x \\<Rightarrow> lunstream_g x\n                  | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n               (lunstreama x))\n             (lunstream gh (xa, x, Some xaa)))\n 2. \\<And>sh sg x.\n       lprefix\n        (lzip\n          (LCons x\n            (case g sg of Done \\<Rightarrow> LNil\n             | Skip x \\<Rightarrow> lunstream_g x\n             | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n          LNil)\n        (lunstream gh (sg, sh, Some x))\n 3. \\<And>s sh sg x.\n       \\<lbrakk>\\<And>sh sg x.\n                   lprefix\n                    (lzip\n                      (LCons x\n                        (case g sg of Done \\<Rightarrow> LNil\n                         | Skip x \\<Rightarrow> lunstream_g x\n                         | Yield x s' \\<Rightarrow>\n                             LCons x (lunstream_g s')))\n                      (s sh))\n                    (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream h)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip x \\<Rightarrow> lunstream_g x\n                               | Yield x s' \\<Rightarrow>\n                                   LCons x (lunstream_g s')))\n                            (case h sh of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s')))\n                          (lunstream gh (sg, sh, Some x))", "case (3 unstream_h)"], ["proof (state)\nthis:\n  lprefix\n   (lzip\n     (LCons ?x\n       (case g ?sg of Done \\<Rightarrow> LNil\n        | Skip a \\<Rightarrow> lunstream_g a\n        | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n     (unstream_h ?sh))\n   (lunstream gh (?sg, ?sh, Some ?x))\n  llist.le_fun unstream_h (lunstream h)\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa xaa.\n            lprefix\n             (lzip\n               (LCons xaa\n                 (case g xa of Done \\<Rightarrow> LNil\n                  | Skip x \\<Rightarrow> lunstream_g x\n                  | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n               (lunstreama x))\n             (lunstream gh (xa, x, Some xaa)))\n 2. \\<And>sh sg x.\n       lprefix\n        (lzip\n          (LCons x\n            (case g sg of Done \\<Rightarrow> LNil\n             | Skip x \\<Rightarrow> lunstream_g x\n             | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n          LNil)\n        (lunstream gh (sg, sh, Some x))\n 3. \\<And>s sh sg x.\n       \\<lbrakk>\\<And>sh sg x.\n                   lprefix\n                    (lzip\n                      (LCons x\n                        (case g sg of Done \\<Rightarrow> LNil\n                         | Skip x \\<Rightarrow> lunstream_g x\n                         | Yield x s' \\<Rightarrow>\n                             LCons x (lunstream_g s')))\n                      (s sh))\n                    (lunstream gh (sg, sh, Some x));\n        llist.le_fun s (lunstream h)\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip x \\<Rightarrow> lunstream_g x\n                               | Yield x s' \\<Rightarrow>\n                                   LCons x (lunstream_g s')))\n                            (case h sh of Done \\<Rightarrow> LNil\n                             | Skip x \\<Rightarrow> s x\n                             | Yield x s' \\<Rightarrow> LCons x (s s')))\n                          (lunstream gh (sg, sh, Some x))", "thus ?case"], ["proof (prove)\nusing this:\n  lprefix\n   (lzip\n     (LCons ?x\n       (case g ?sg of Done \\<Rightarrow> LNil\n        | Skip a \\<Rightarrow> lunstream_g a\n        | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n     (unstream_h ?sh))\n   (lunstream gh (?sg, ?sh, Some ?x))\n  llist.le_fun unstream_h (lunstream h)\n\ngoal (1 subgoal):\n 1. lprefix\n     (lzip\n       (LCons x\n         (case g sg of Done \\<Rightarrow> LNil\n          | Skip a \\<Rightarrow> lunstream_g a\n          | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n       (case h sh of Done \\<Rightarrow> LNil\n        | Skip s' \\<Rightarrow> unstream_h s'\n        | Yield x s' \\<Rightarrow> LCons x (unstream_h s')))\n     (lunstream gh (sg, sh, Some x))", "proof(cases \"h sh\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x sg sh.\n                lprefix\n                 (lzip\n                   (LCons x\n                     (case g sg of Done \\<Rightarrow> LNil\n                      | Skip a \\<Rightarrow> lunstream_g a\n                      | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n                   (unstream_h sh))\n                 (lunstream gh (sg, sh, Some x));\n     llist.le_fun unstream_h (lunstream h); h sh = Done\\<rbrakk>\n    \\<Longrightarrow> lprefix\n                       (lzip\n                         (LCons x\n                           (case g sg of Done \\<Rightarrow> LNil\n                            | Skip a \\<Rightarrow> lunstream_g a\n                            | Yield x s' \\<Rightarrow>\n                                LCons x (lunstream_g s')))\n                         (case h sh of Done \\<Rightarrow> LNil\n                          | Skip s' \\<Rightarrow> unstream_h s'\n                          | Yield x s' \\<Rightarrow>\n                              LCons x (unstream_h s')))\n                       (lunstream gh (sg, sh, Some x))\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x sg sh.\n                   lprefix\n                    (lzip\n                      (LCons x\n                        (case g sg of Done \\<Rightarrow> LNil\n                         | Skip a \\<Rightarrow> lunstream_g a\n                         | Yield x s' \\<Rightarrow>\n                             LCons x (lunstream_g s')))\n                      (unstream_h sh))\n                    (lunstream gh (sg, sh, Some x));\n        llist.le_fun unstream_h (lunstream h); h sh = Skip x2\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip a \\<Rightarrow> lunstream_g a\n                               | Yield x s' \\<Rightarrow>\n                                   LCons x (lunstream_g s')))\n                            (case h sh of Done \\<Rightarrow> LNil\n                             | Skip s' \\<Rightarrow> unstream_h s'\n                             | Yield x s' \\<Rightarrow>\n                                 LCons x (unstream_h s')))\n                          (lunstream gh (sg, sh, Some x))\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x sg sh.\n                   lprefix\n                    (lzip\n                      (LCons x\n                        (case g sg of Done \\<Rightarrow> LNil\n                         | Skip a \\<Rightarrow> lunstream_g a\n                         | Yield x s' \\<Rightarrow>\n                             LCons x (lunstream_g s')))\n                      (unstream_h sh))\n                    (lunstream gh (sg, sh, Some x));\n        llist.le_fun unstream_h (lunstream h); h sh = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip a \\<Rightarrow> lunstream_g a\n                               | Yield x s' \\<Rightarrow>\n                                   LCons x (lunstream_g s')))\n                            (case h sh of Done \\<Rightarrow> LNil\n                             | Skip s' \\<Rightarrow> unstream_h s'\n                             | Yield x s' \\<Rightarrow>\n                                 LCons x (unstream_h s')))\n                          (lunstream gh (sg, sh, Some x))", "case (Yield y sh')"], ["proof (state)\nthis:\n  h sh = Yield y sh'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x sg sh.\n                lprefix\n                 (lzip\n                   (LCons x\n                     (case g sg of Done \\<Rightarrow> LNil\n                      | Skip a \\<Rightarrow> lunstream_g a\n                      | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n                   (unstream_h sh))\n                 (lunstream gh (sg, sh, Some x));\n     llist.le_fun unstream_h (lunstream h); h sh = Done\\<rbrakk>\n    \\<Longrightarrow> lprefix\n                       (lzip\n                         (LCons x\n                           (case g sg of Done \\<Rightarrow> LNil\n                            | Skip a \\<Rightarrow> lunstream_g a\n                            | Yield x s' \\<Rightarrow>\n                                LCons x (lunstream_g s')))\n                         (case h sh of Done \\<Rightarrow> LNil\n                          | Skip s' \\<Rightarrow> unstream_h s'\n                          | Yield x s' \\<Rightarrow>\n                              LCons x (unstream_h s')))\n                       (lunstream gh (sg, sh, Some x))\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x sg sh.\n                   lprefix\n                    (lzip\n                      (LCons x\n                        (case g sg of Done \\<Rightarrow> LNil\n                         | Skip a \\<Rightarrow> lunstream_g a\n                         | Yield x s' \\<Rightarrow>\n                             LCons x (lunstream_g s')))\n                      (unstream_h sh))\n                    (lunstream gh (sg, sh, Some x));\n        llist.le_fun unstream_h (lunstream h); h sh = Skip x2\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip a \\<Rightarrow> lunstream_g a\n                               | Yield x s' \\<Rightarrow>\n                                   LCons x (lunstream_g s')))\n                            (case h sh of Done \\<Rightarrow> LNil\n                             | Skip s' \\<Rightarrow> unstream_h s'\n                             | Yield x s' \\<Rightarrow>\n                                 LCons x (unstream_h s')))\n                          (lunstream gh (sg, sh, Some x))\n 3. \\<And>x31 x32.\n       \\<lbrakk>\\<And>x sg sh.\n                   lprefix\n                    (lzip\n                      (LCons x\n                        (case g sg of Done \\<Rightarrow> LNil\n                         | Skip a \\<Rightarrow> lunstream_g a\n                         | Yield x s' \\<Rightarrow>\n                             LCons x (lunstream_g s')))\n                      (unstream_h sh))\n                    (lunstream gh (sg, sh, Some x));\n        llist.le_fun unstream_h (lunstream h); h sh = Yield x31 x32\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip a \\<Rightarrow> lunstream_g a\n                               | Yield x s' \\<Rightarrow>\n                                   LCons x (lunstream_g s')))\n                            (case h sh of Done \\<Rightarrow> LNil\n                             | Skip s' \\<Rightarrow> unstream_h s'\n                             | Yield x s' \\<Rightarrow>\n                                 LCons x (unstream_h s')))\n                          (lunstream gh (sg, sh, Some x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  h sh = Yield y sh'\n\ngoal (1 subgoal):\n 1. lprefix\n     (lzip\n       (LCons x\n         (case g sg of Done \\<Rightarrow> LNil\n          | Skip a \\<Rightarrow> lunstream_g a\n          | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n       (case h sh of Done \\<Rightarrow> LNil\n        | Skip s' \\<Rightarrow> unstream_h s'\n        | Yield x s' \\<Rightarrow> LCons x (unstream_h s')))\n     (lunstream gh (sg, sh, Some x))", "using \"3.prems\" IH \"3.hyps\""], ["proof (prove)\nusing this:\n  h sh = Yield y sh'\n  lprefix (lzip (lunstream_g ?sg) (lunstream h ?sh))\n   (lunstream gh (?sg, ?sh, None))\n  lprefix (lzip (LCons ?x (lunstream_g ?sg)) (lunstream h ?sh))\n   (lunstream gh (?sg, ?sh, Some ?x))\n  llist.le_fun unstream_h (lunstream h)\n\ngoal (1 subgoal):\n 1. lprefix\n     (lzip\n       (LCons x\n         (case g sg of Done \\<Rightarrow> LNil\n          | Skip a \\<Rightarrow> lunstream_g a\n          | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n       (case h sh of Done \\<Rightarrow> LNil\n        | Skip s' \\<Rightarrow> unstream_h s'\n        | Yield x s' \\<Rightarrow> LCons x (unstream_h s')))\n     (lunstream gh (sg, sh, Some x))", "by(cases \"g sg\")(auto 4 3 simp add: lunstream_simps fun_ord_def intro: monotone_lzip2[THEN monotoneD] lprefix_trans)"], ["proof (state)\nthis:\n  lprefix\n   (lzip\n     (LCons x\n       (case g sg of Done \\<Rightarrow> LNil\n        | Skip a \\<Rightarrow> lunstream_g a\n        | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n     (case h sh of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> unstream_h s'\n      | Yield x s' \\<Rightarrow> LCons x (unstream_h s')))\n   (lunstream gh (sg, sh, Some x))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x sg sh.\n                lprefix\n                 (lzip\n                   (LCons x\n                     (case g sg of Done \\<Rightarrow> LNil\n                      | Skip a \\<Rightarrow> lunstream_g a\n                      | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n                   (unstream_h sh))\n                 (lunstream gh (sg, sh, Some x));\n     llist.le_fun unstream_h (lunstream h); h sh = Done\\<rbrakk>\n    \\<Longrightarrow> lprefix\n                       (lzip\n                         (LCons x\n                           (case g sg of Done \\<Rightarrow> LNil\n                            | Skip a \\<Rightarrow> lunstream_g a\n                            | Yield x s' \\<Rightarrow>\n                                LCons x (lunstream_g s')))\n                         (case h sh of Done \\<Rightarrow> LNil\n                          | Skip s' \\<Rightarrow> unstream_h s'\n                          | Yield x s' \\<Rightarrow>\n                              LCons x (unstream_h s')))\n                       (lunstream gh (sg, sh, Some x))\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>x sg sh.\n                   lprefix\n                    (lzip\n                      (LCons x\n                        (case g sg of Done \\<Rightarrow> LNil\n                         | Skip a \\<Rightarrow> lunstream_g a\n                         | Yield x s' \\<Rightarrow>\n                             LCons x (lunstream_g s')))\n                      (unstream_h sh))\n                    (lunstream gh (sg, sh, Some x));\n        llist.le_fun unstream_h (lunstream h); h sh = Skip x2\\<rbrakk>\n       \\<Longrightarrow> lprefix\n                          (lzip\n                            (LCons x\n                              (case g sg of Done \\<Rightarrow> LNil\n                               | Skip a \\<Rightarrow> lunstream_g a\n                               | Yield x s' \\<Rightarrow>\n                                   LCons x (lunstream_g s')))\n                            (case h sh of Done \\<Rightarrow> LNil\n                             | Skip s' \\<Rightarrow> unstream_h s'\n                             | Yield x s' \\<Rightarrow>\n                                 LCons x (unstream_h s')))\n                          (lunstream gh (sg, sh, Some x))", "qed(simp_all add: lunstream_simps)"], ["proof (state)\nthis:\n  lprefix\n   (lzip\n     (LCons x\n       (case g sg of Done \\<Rightarrow> LNil\n        | Skip a \\<Rightarrow> lunstream_g a\n        | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n     (case h sh of Done \\<Rightarrow> LNil\n      | Skip s' \\<Rightarrow> unstream_h s'\n      | Yield x s' \\<Rightarrow> LCons x (unstream_h s')))\n   (lunstream gh (sg, sh, Some x))\n\ngoal (2 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         \\<forall>x xa xaa.\n            lprefix\n             (lzip\n               (LCons xaa\n                 (case g xa of Done \\<Rightarrow> LNil\n                  | Skip x \\<Rightarrow> lunstream_g x\n                  | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n               (lunstreama x))\n             (lunstream gh (xa, x, Some xaa)))\n 2. \\<And>sh sg x.\n       lprefix\n        (lzip\n          (LCons x\n            (case g sg of Done \\<Rightarrow> LNil\n             | Skip x \\<Rightarrow> lunstream_g x\n             | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n          LNil)\n        (lunstream gh (sg, sh, Some x))", "qed simp_all"], ["proof (state)\nthis:\n  lprefix\n   (lzip\n     (LCons x\n       (case g sg of Done \\<Rightarrow> LNil\n        | Skip s' \\<Rightarrow> lunstream_g s'\n        | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n     (lunstream h sh))\n   (lunstream gh (sg, sh, Some x))\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))", "}"], ["proof (state)\nthis:\n  lprefix\n   (lzip\n     (LCons ?x2\n       (case g ?sga2 of Done \\<Rightarrow> LNil\n        | Skip s' \\<Rightarrow> lunstream_g s'\n        | Yield x s' \\<Rightarrow> LCons x (lunstream_g s')))\n     (lunstream h ?sha2))\n   (lunstream gh (?sga2, ?sha2, Some ?x2))\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))\n 3. \\<And>x sg sh.\n       lprefix (lzip (LCons x LNil) (lunstream h sh))\n        (lunstream gh (sg, sh, Some x))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lzip (LCons x LNil) (lunstream h sh))\n     (lunstream gh (sg, sh, Some x))", "by(induction h arbitrary: sh rule: lunstream.fixp_induct)(simp_all add: lunstream_simps split: step.split)"], ["proof (state)\nthis:\n  lprefix (lzip (LCons x LNil) (lunstream h sh))\n   (lunstream gh (sg, sh, Some x))\n\ngoal (2 subgoals):\n 1. llist.admissible\n     (\\<lambda>lunstreama.\n         (\\<forall>x xa.\n             lprefix (lzip (lunstreama x) (lunstream h xa))\n              (lunstream gh (x, xa, None))) \\<and>\n         (\\<forall>x xa xb.\n             lprefix (lzip (LCons x (lunstreama xa)) (lunstream h xb))\n              (lunstream gh (xa, xb, Some x))))\n 2. \\<And>sg sh.\n       lprefix (lzip LNil (lunstream h sh)) (lunstream gh (sg, sh, None))", "qed simp_all"], ["proof (state)\nthis:\n  lprefix (lzip (lunstream g sg) (lunstream h sh))\n   (lunstream gh (sg, sh, None))\n  lprefix (lzip (LCons ?x (lunstream g sg)) (lunstream h sh))\n   (lunstream gh (sg, sh, Some ?x))\n\ngoal (1 subgoal):\n 1. lunstream gh (sg, sh, None) = lzip (lunstream g sg) (lunstream h sh)", "ultimately"], ["proof (chain)\npicking this:\n  lprefix (lunstream gh (sg, sh, None))\n   (lzip (lunstream g sg) (lunstream h sh))\n  lprefix (lunstream gh (sg, sh, Some ?x))\n   (lzip (LCons ?x (lunstream g sg)) (lunstream h sh))\n  lprefix (lzip (lunstream g sg) (lunstream h sh))\n   (lunstream gh (sg, sh, None))\n  lprefix (lzip (LCons ?x (lunstream g sg)) (lunstream h sh))\n   (lunstream gh (sg, sh, Some ?x))", "show ?thesis"], ["proof (prove)\nusing this:\n  lprefix (lunstream gh (sg, sh, None))\n   (lzip (lunstream g sg) (lunstream h sh))\n  lprefix (lunstream gh (sg, sh, Some ?x))\n   (lzip (LCons ?x (lunstream g sg)) (lunstream h sh))\n  lprefix (lzip (lunstream g sg) (lunstream h sh))\n   (lunstream gh (sg, sh, None))\n  lprefix (lzip (LCons ?x (lunstream g sg)) (lunstream h sh))\n   (lunstream gh (sg, sh, Some ?x))\n\ngoal (1 subgoal):\n 1. lunstream gh (sg, sh, None) = lzip (lunstream g sg) (lunstream h sh)", "by(blast intro: lprefix_antisym)"], ["proof (state)\nthis:\n  lunstream gh (sg, sh, None) = lzip (lunstream g sg) (lunstream h sh)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lzip_trans_fusion2 [stream_fusion]:\n  \"lunstream (lzip_trans (lgenerator g) h) (sg, sh, None) = lzip (lunstream' g sg) (lunstream h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream (zip_raw (lgenerator g) h) (sg, sh, None) =\n    lzip (lunstream' g sg) (lunstream h sh)", "by transfer(rule lzip_trans_fusion)"], ["", "lemma lzip_trans_fusion3 [stream_fusion]:\n  \"lunstream (lzip_trans g (lgenerator h)) (sg, sh, None) = lzip (lunstream g sg) (lunstream' h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream (zip_raw g (lgenerator h)) (sg, sh, None) =\n    lzip (lunstream g sg) (lunstream' h sh)", "by transfer(rule lzip_trans_fusion)"], ["", "lift_definition lzip_trans' :: \"('a, 's1) lgenerator' \\<Rightarrow> ('b, 's2) lgenerator' \\<Rightarrow> ('a \\<times> 'b, 's1 \\<times> 's2 \\<times> 'a option) lgenerator'\"\nis \"lzip_trans\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> productive (zip_raw fun1 fun2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (zip_raw fun1 fun2)", "fix g :: \"('a, 's1) lgenerator\" and h :: \"('b, 's2) lgenerator\" and s :: \"'s1 \\<times> 's2 \\<times> 'a option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (zip_raw fun1 fun2)", "assume \"productive g\" and \"productive h\""], ["proof (state)\nthis:\n  productive g\n  productive h\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (zip_raw fun1 fun2)", "obtain sg sh mx where s: \"s = (sg, sh, mx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sg sh mx.\n        s = (sg, sh, mx) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s)"], ["proof (state)\nthis:\n  s = (sg, sh, mx)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (zip_raw fun1 fun2)", "{"], ["proof (state)\nthis:\n  s = (sg, sh, mx)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (zip_raw fun1 fun2)", "fix x sg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (zip_raw fun1 fun2)", "from \\<open>productive h\\<close>"], ["proof (chain)\npicking this:\n  productive h", "have \"sh \\<in> productive_on h\""], ["proof (prove)\nusing this:\n  productive h\n\ngoal (1 subgoal):\n 1. sh \\<in> productive_on h", ".."], ["proof (state)\nthis:\n  sh \\<in> productive_on h\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (zip_raw fun1 fun2)", "hence \"(sg, sh, Some x) \\<in> productive_on (lzip_trans g h)\""], ["proof (prove)\nusing this:\n  sh \\<in> productive_on h\n\ngoal (1 subgoal):\n 1. (sg, sh, Some x) \\<in> productive_on (zip_raw g h)", "by(induction)(auto simp add: intro: productive_on.intros)"], ["proof (state)\nthis:\n  (sg, sh, Some x) \\<in> productive_on (zip_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (zip_raw fun1 fun2)", "}"], ["proof (state)\nthis:\n  (?sga2, sh, Some ?x2) \\<in> productive_on (zip_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (zip_raw fun1 fun2)", "moreover"], ["proof (state)\nthis:\n  (?sga2, sh, Some ?x2) \\<in> productive_on (zip_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (zip_raw fun1 fun2)", "from \\<open>productive g\\<close>"], ["proof (chain)\npicking this:\n  productive g", "have \"sg \\<in> productive_on g\""], ["proof (prove)\nusing this:\n  productive g\n\ngoal (1 subgoal):\n 1. sg \\<in> productive_on g", ".."], ["proof (state)\nthis:\n  sg \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (zip_raw fun1 fun2)", "then"], ["proof (chain)\npicking this:\n  sg \\<in> productive_on g", "have \"(sg, sh, None) \\<in> productive_on (lzip_trans g h)\""], ["proof (prove)\nusing this:\n  sg \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. (sg, sh, None) \\<in> productive_on (zip_raw g h)", "by induction(auto intro: productive_on.intros calculation)"], ["proof (state)\nthis:\n  (sg, sh, None) \\<in> productive_on (zip_raw g h)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (zip_raw fun1 fun2)", "ultimately"], ["proof (chain)\npicking this:\n  (?sga2, sh, Some ?x2) \\<in> productive_on (zip_raw g h)\n  (sg, sh, None) \\<in> productive_on (zip_raw g h)", "show \"s \\<in> productive_on (lzip_trans g h)\""], ["proof (prove)\nusing this:\n  (?sga2, sh, Some ?x2) \\<in> productive_on (zip_raw g h)\n  (sg, sh, None) \\<in> productive_on (zip_raw g h)\n\ngoal (1 subgoal):\n 1. s \\<in> productive_on (zip_raw g h)", "unfolding s"], ["proof (prove)\nusing this:\n  (?sga2, sh, Some ?x2) \\<in> productive_on (zip_raw g h)\n  (sg, sh, None) \\<in> productive_on (zip_raw g h)\n\ngoal (1 subgoal):\n 1. (sg, sh, mx) \\<in> productive_on (zip_raw g h)", "by(cases mx) auto"], ["proof (state)\nthis:\n  s \\<in> productive_on (zip_raw g h)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lzip_trans'_fusion [stream_fusion]:\n  \"lunstream' (lzip_trans' g h) (sg, sh, None) = lzip (lunstream' g sg) (lunstream' h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream' (lzip_trans' g h) (sg, sh, None) =\n    lzip (lunstream' g sg) (lunstream' h sh)", "by transfer(rule lzip_trans_fusion)"], ["", "subsubsection \\<open>@{const lappend}\\<close>"], ["", "lift_definition lappend_trans :: \"('a, 'sg) lgenerator' \\<Rightarrow> ('a, 'sh) lgenerator \\<Rightarrow> 'sh \\<Rightarrow> ('a, 'sg + 'sh) lgenerator\"\nis append_raw"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lunstream_append_raw:\n  fixes g h sh gh defines [simp]: \"gh \\<equiv> append_raw g h sh\"\n  assumes \"productive g\"\n  shows \"lunstream gh (Inl sg) = lappend (lunstream g sg) (lunstream h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream gh (Inl sg) = lappend (lunstream g sg) (lunstream h sh)", "proof(coinduction arbitrary: sg rule: llist.coinduct_strong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sg.\n       lnull (lunstream gh (Inl sg)) =\n       lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n       (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n        \\<not> lnull\n                (lappend (lunstream g sg)\n                  (lunstream h sh)) \\<longrightarrow>\n        lhd (lunstream gh (Inl sg)) =\n        lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n        ((\\<exists>sga.\n             ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sga) \\<and>\n             ltl (lappend (lunstream g sg) (lunstream h sh)) =\n             lappend (lunstream g sga) (lunstream h sh)) \\<or>\n         ltl (lunstream gh (Inl sg)) =\n         ltl (lappend (lunstream g sg) (lunstream h sh))))", "case (Eq_llist sg)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>sg.\n       lnull (lunstream gh (Inl sg)) =\n       lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n       (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n        \\<not> lnull\n                (lappend (lunstream g sg)\n                  (lunstream h sh)) \\<longrightarrow>\n        lhd (lunstream gh (Inl sg)) =\n        lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n        ((\\<exists>sga.\n             ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sga) \\<and>\n             ltl (lappend (lunstream g sg) (lunstream h sh)) =\n             lappend (lunstream g sga) (lunstream h sh)) \\<or>\n         ltl (lunstream gh (Inl sg)) =\n         ltl (lappend (lunstream g sg) (lunstream h sh))))", "{"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>sg.\n       lnull (lunstream gh (Inl sg)) =\n       lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n       (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n        \\<not> lnull\n                (lappend (lunstream g sg)\n                  (lunstream h sh)) \\<longrightarrow>\n        lhd (lunstream gh (Inl sg)) =\n        lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n        ((\\<exists>sga.\n             ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sga) \\<and>\n             ltl (lappend (lunstream g sg) (lunstream h sh)) =\n             lappend (lunstream g sga) (lunstream h sh)) \\<or>\n         ltl (lunstream gh (Inl sg)) =\n         ltl (lappend (lunstream g sg) (lunstream h sh))))", "fix sh'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sg.\n       lnull (lunstream gh (Inl sg)) =\n       lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n       (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n        \\<not> lnull\n                (lappend (lunstream g sg)\n                  (lunstream h sh)) \\<longrightarrow>\n        lhd (lunstream gh (Inl sg)) =\n        lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n        ((\\<exists>sga.\n             ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sga) \\<and>\n             ltl (lappend (lunstream g sg) (lunstream h sh)) =\n             lappend (lunstream g sga) (lunstream h sh)) \\<or>\n         ltl (lunstream gh (Inl sg)) =\n         ltl (lappend (lunstream g sg) (lunstream h sh))))", "have \"lprefix (lunstream gh (Inr sh')) (lunstream h sh')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lunstream gh (Inr sh')) (lunstream h sh')", "by(induction gh arbitrary: sh' rule: lunstream.fixp_induct)(simp_all add: lunstream_simps split: step.split)"], ["proof (state)\nthis:\n  lprefix (lunstream gh (Inr sh')) (lunstream h sh')\n\ngoal (1 subgoal):\n 1. \\<And>sg.\n       lnull (lunstream gh (Inl sg)) =\n       lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n       (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n        \\<not> lnull\n                (lappend (lunstream g sg)\n                  (lunstream h sh)) \\<longrightarrow>\n        lhd (lunstream gh (Inl sg)) =\n        lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n        ((\\<exists>sga.\n             ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sga) \\<and>\n             ltl (lappend (lunstream g sg) (lunstream h sh)) =\n             lappend (lunstream g sga) (lunstream h sh)) \\<or>\n         ltl (lunstream gh (Inl sg)) =\n         ltl (lappend (lunstream g sg) (lunstream h sh))))", "moreover"], ["proof (state)\nthis:\n  lprefix (lunstream gh (Inr sh')) (lunstream h sh')\n\ngoal (1 subgoal):\n 1. \\<And>sg.\n       lnull (lunstream gh (Inl sg)) =\n       lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n       (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n        \\<not> lnull\n                (lappend (lunstream g sg)\n                  (lunstream h sh)) \\<longrightarrow>\n        lhd (lunstream gh (Inl sg)) =\n        lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n        ((\\<exists>sga.\n             ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sga) \\<and>\n             ltl (lappend (lunstream g sg) (lunstream h sh)) =\n             lappend (lunstream g sga) (lunstream h sh)) \\<or>\n         ltl (lunstream gh (Inl sg)) =\n         ltl (lappend (lunstream g sg) (lunstream h sh))))", "have \"lprefix (lunstream h sh') (lunstream gh (Inr sh'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lunstream h sh') (lunstream gh (Inr sh'))", "by(induction h arbitrary: sh' rule: lunstream.fixp_induct)(simp_all add: lunstream_simps split: step.split)"], ["proof (state)\nthis:\n  lprefix (lunstream h sh') (lunstream gh (Inr sh'))\n\ngoal (1 subgoal):\n 1. \\<And>sg.\n       lnull (lunstream gh (Inl sg)) =\n       lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n       (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n        \\<not> lnull\n                (lappend (lunstream g sg)\n                  (lunstream h sh)) \\<longrightarrow>\n        lhd (lunstream gh (Inl sg)) =\n        lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n        ((\\<exists>sga.\n             ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sga) \\<and>\n             ltl (lappend (lunstream g sg) (lunstream h sh)) =\n             lappend (lunstream g sga) (lunstream h sh)) \\<or>\n         ltl (lunstream gh (Inl sg)) =\n         ltl (lappend (lunstream g sg) (lunstream h sh))))", "ultimately"], ["proof (chain)\npicking this:\n  lprefix (lunstream gh (Inr sh')) (lunstream h sh')\n  lprefix (lunstream h sh') (lunstream gh (Inr sh'))", "have \"lunstream gh (Inr sh') = lunstream h sh'\""], ["proof (prove)\nusing this:\n  lprefix (lunstream gh (Inr sh')) (lunstream h sh')\n  lprefix (lunstream h sh') (lunstream gh (Inr sh'))\n\ngoal (1 subgoal):\n 1. lunstream gh (Inr sh') = lunstream h sh'", "by(blast intro: lprefix_antisym)"], ["proof (state)\nthis:\n  lunstream gh (Inr sh') = lunstream h sh'\n\ngoal (1 subgoal):\n 1. \\<And>sg.\n       lnull (lunstream gh (Inl sg)) =\n       lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n       (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n        \\<not> lnull\n                (lappend (lunstream g sg)\n                  (lunstream h sh)) \\<longrightarrow>\n        lhd (lunstream gh (Inl sg)) =\n        lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n        ((\\<exists>sga.\n             ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sga) \\<and>\n             ltl (lappend (lunstream g sg) (lunstream h sh)) =\n             lappend (lunstream g sga) (lunstream h sh)) \\<or>\n         ltl (lunstream gh (Inl sg)) =\n         ltl (lappend (lunstream g sg) (lunstream h sh))))", "}"], ["proof (state)\nthis:\n  lunstream gh (Inr ?sh'2) = lunstream h ?sh'2\n\ngoal (1 subgoal):\n 1. \\<And>sg.\n       lnull (lunstream gh (Inl sg)) =\n       lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n       (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n        \\<not> lnull\n                (lappend (lunstream g sg)\n                  (lunstream h sh)) \\<longrightarrow>\n        lhd (lunstream gh (Inl sg)) =\n        lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n        ((\\<exists>sga.\n             ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sga) \\<and>\n             ltl (lappend (lunstream g sg) (lunstream h sh)) =\n             lappend (lunstream g sga) (lunstream h sh)) \\<or>\n         ltl (lunstream gh (Inl sg)) =\n         ltl (lappend (lunstream g sg) (lunstream h sh))))", "note Inr = this[unfolded gh_def]"], ["proof (state)\nthis:\n  lunstream (append_raw g h sh) (Inr ?sh'2) = lunstream h ?sh'2\n\ngoal (1 subgoal):\n 1. \\<And>sg.\n       lnull (lunstream gh (Inl sg)) =\n       lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n       (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n        \\<not> lnull\n                (lappend (lunstream g sg)\n                  (lunstream h sh)) \\<longrightarrow>\n        lhd (lunstream gh (Inl sg)) =\n        lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n        ((\\<exists>sga.\n             ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sga) \\<and>\n             ltl (lappend (lunstream g sg) (lunstream h sh)) =\n             lappend (lunstream g sga) (lunstream h sh)) \\<or>\n         ltl (lunstream gh (Inl sg)) =\n         ltl (lappend (lunstream g sg) (lunstream h sh))))", "from \\<open>productive g\\<close>"], ["proof (chain)\npicking this:\n  productive g", "have sg: \"sg \\<in> productive_on g\""], ["proof (prove)\nusing this:\n  productive g\n\ngoal (1 subgoal):\n 1. sg \\<in> productive_on g", ".."], ["proof (state)\nthis:\n  sg \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. \\<And>sg.\n       lnull (lunstream gh (Inl sg)) =\n       lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n       (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n        \\<not> lnull\n                (lappend (lunstream g sg)\n                  (lunstream h sh)) \\<longrightarrow>\n        lhd (lunstream gh (Inl sg)) =\n        lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n        ((\\<exists>sga.\n             ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sga) \\<and>\n             ltl (lappend (lunstream g sg) (lunstream h sh)) =\n             lappend (lunstream g sga) (lunstream h sh)) \\<or>\n         ltl (lunstream gh (Inl sg)) =\n         ltl (lappend (lunstream g sg) (lunstream h sh))))", "then"], ["proof (chain)\npicking this:\n  sg \\<in> productive_on g", "show ?case"], ["proof (prove)\nusing this:\n  sg \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. lnull (lunstream gh (Inl sg)) =\n    lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n    (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n     \\<not> lnull\n             (lappend (lunstream g sg) (lunstream h sh)) \\<longrightarrow>\n     lhd (lunstream gh (Inl sg)) =\n     lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n     ((\\<exists>sg.\n          ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sg) \\<and>\n          ltl (lappend (lunstream g sg) (lunstream h sh)) =\n          lappend (lunstream g sg) (lunstream h sh)) \\<or>\n      ltl (lunstream gh (Inl sg)) =\n      ltl (lappend (lunstream g sg) (lunstream h sh))))", "by induction(auto simp add: lunstream_sels Inr)"], ["proof (state)\nthis:\n  lnull (lunstream gh (Inl sg)) =\n  lnull (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n  (\\<not> lnull (lunstream gh (Inl sg)) \\<longrightarrow>\n   \\<not> lnull\n           (lappend (lunstream g sg) (lunstream h sh)) \\<longrightarrow>\n   lhd (lunstream gh (Inl sg)) =\n   lhd (lappend (lunstream g sg) (lunstream h sh)) \\<and>\n   ((\\<exists>sg.\n        ltl (lunstream gh (Inl sg)) = lunstream gh (Inl sg) \\<and>\n        ltl (lappend (lunstream g sg) (lunstream h sh)) =\n        lappend (lunstream g sg) (lunstream h sh)) \\<or>\n    ltl (lunstream gh (Inl sg)) =\n    ltl (lappend (lunstream g sg) (lunstream h sh))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lappend_trans_fusion [stream_fusion]:\n  \"lunstream (lappend_trans g h sh) (Inl sg) = lappend (lunstream' g sg) (lunstream h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream (lappend_trans g h sh) (Inl sg) =\n    lappend (lunstream' g sg) (lunstream h sh)", "by transfer(rule lunstream_append_raw)"], ["", "lift_definition lappend_trans' :: \"('a, 'sg) lgenerator' \\<Rightarrow> ('a, 'sh) lgenerator' \\<Rightarrow> 'sh \\<Rightarrow> ('a, 'sg + 'sh) lgenerator'\"\nis append_raw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> productive (append_raw fun1 fun2 sh)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "fix g :: \"('a, 'sg) lgenerator\" and h :: \"('a, 'sh) lgenerator\" and sh s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "assume \"productive g\" \"productive h\""], ["proof (state)\nthis:\n  productive g\n  productive h\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "{"], ["proof (state)\nthis:\n  productive g\n  productive h\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "fix sh'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "from \\<open>productive h\\<close>"], ["proof (chain)\npicking this:\n  productive h", "have \"sh' \\<in> productive_on h\""], ["proof (prove)\nusing this:\n  productive h\n\ngoal (1 subgoal):\n 1. sh' \\<in> productive_on h", ".."], ["proof (state)\nthis:\n  sh' \\<in> productive_on h\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "then"], ["proof (chain)\npicking this:\n  sh' \\<in> productive_on h", "have \"Inr sh' \\<in> productive_on (append_raw g h sh)\""], ["proof (prove)\nusing this:\n  sh' \\<in> productive_on h\n\ngoal (1 subgoal):\n 1. Inr sh' \\<in> productive_on (append_raw g h sh)", "by induction (auto intro: productive_on.intros)"], ["proof (state)\nthis:\n  Inr sh' \\<in> productive_on (append_raw g h sh)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "}"], ["proof (state)\nthis:\n  Inr ?sh'2 \\<in> productive_on (append_raw g h sh)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "moreover"], ["proof (state)\nthis:\n  Inr ?sh'2 \\<in> productive_on (append_raw g h sh)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "{"], ["proof (state)\nthis:\n  Inr ?sh'2 \\<in> productive_on (append_raw g h sh)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "fix sg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "from \\<open>productive g\\<close>"], ["proof (chain)\npicking this:\n  productive g", "have \"sg \\<in> productive_on g\""], ["proof (prove)\nusing this:\n  productive g\n\ngoal (1 subgoal):\n 1. sg \\<in> productive_on g", ".."], ["proof (state)\nthis:\n  sg \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "then"], ["proof (chain)\npicking this:\n  sg \\<in> productive_on g", "have \"Inl sg \\<in> productive_on (append_raw g h sh)\""], ["proof (prove)\nusing this:\n  sg \\<in> productive_on g\n\ngoal (1 subgoal):\n 1. Inl sg \\<in> productive_on (append_raw g h sh)", "by induction(auto intro: productive_on.intros calculation)"], ["proof (state)\nthis:\n  Inl sg \\<in> productive_on (append_raw g h sh)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "}"], ["proof (state)\nthis:\n  Inl ?sg2 \\<in> productive_on (append_raw g h sh)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 sh s.\n       \\<lbrakk>productive fun1; productive fun2\\<rbrakk>\n       \\<Longrightarrow> s \\<in> productive_on (append_raw fun1 fun2 sh)", "ultimately"], ["proof (chain)\npicking this:\n  Inr ?sh'2 \\<in> productive_on (append_raw g h sh)\n  Inl ?sg2 \\<in> productive_on (append_raw g h sh)", "show \"s \\<in> productive_on (append_raw g h sh)\""], ["proof (prove)\nusing this:\n  Inr ?sh'2 \\<in> productive_on (append_raw g h sh)\n  Inl ?sg2 \\<in> productive_on (append_raw g h sh)\n\ngoal (1 subgoal):\n 1. s \\<in> productive_on (append_raw g h sh)", "by(cases s) auto"], ["proof (state)\nthis:\n  s \\<in> productive_on (append_raw g h sh)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lappend_trans'_fusion [stream_fusion]:\n  \"lunstream' (lappend_trans' g h sh) (Inl sg) = lappend (lunstream' g sg) (lunstream' h sh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream' (lappend_trans' g h sh) (Inl sg) =\n    lappend (lunstream' g sg) (lunstream' h sh)", "by transfer(rule lunstream_append_raw)"], ["", "subsubsection \\<open>@{const lfilter}\\<close>"], ["", "definition lfilter_trans :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a, 's) lgenerator \\<Rightarrow> ('a, 's) lgenerator\"\nwhere \"lfilter_trans = filter_raw\""], ["", "lemma lunstream_lfilter_trans [stream_fusion]:\n  fixes P g g' defines [simp]: \"g' \\<equiv> lfilter_trans P g\"\n  shows \"lunstream g' s = lfilter P (lunstream g s)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream g' s = lfilter P (lunstream g s)", "proof(rule lprefix_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. lprefix (lunstream g' s) (lfilter P (lunstream g s))\n 2. lprefix (lfilter P (lunstream g s)) (lunstream g' s)", "show \"lprefix ?lhs ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lunstream g' s) (lfilter P (lunstream g s))", "by(induction g' arbitrary: s rule: lunstream.fixp_induct)\n      (simp_all add: lfilter_trans_def filter_raw_def lunstream_simps split: step.split)"], ["proof (state)\nthis:\n  lprefix (lunstream g' s) (lfilter P (lunstream g s))\n\ngoal (1 subgoal):\n 1. lprefix (lfilter P (lunstream g s)) (lunstream g' s)", "show \"lprefix ?rhs ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (lfilter P (lunstream g s)) (lunstream g' s)", "by(induction g arbitrary: s rule: lunstream.fixp_induct) \n    (simp_all add: lfilter_trans_def filter_raw_def lunstream_simps split: step.split)"], ["proof (state)\nthis:\n  lprefix (lfilter P (lunstream g s)) (lunstream g' s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lunstream_lfilter_trans2 [stream_fusion]:\n  \"lunstream (lfilter_trans P (lgenerator g)) s = lfilter P (lunstream' g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream (lfilter_trans P (lgenerator g)) s =\n    lfilter P (lunstream' g s)", "by transfer(rule lunstream_lfilter_trans)"], ["", "subsubsection \\<open>@{const llist_of}\\<close>"], ["", "lift_definition llist_of_trans :: \"('a, 's) generator \\<Rightarrow> ('a, 's) lgenerator'\"\nis \"\\<lambda>x. x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. terminates fun \\<Longrightarrow> productive fun", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun s. terminates fun \\<Longrightarrow> s \\<in> productive_on fun", "fix g :: \"('a, 's) raw_generator\" and s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun s. terminates fun \\<Longrightarrow> s \\<in> productive_on fun", "assume \"terminates g\""], ["proof (state)\nthis:\n  terminates g\n\ngoal (1 subgoal):\n 1. \\<And>fun s. terminates fun \\<Longrightarrow> s \\<in> productive_on fun", "hence \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by(simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>fun s. terminates fun \\<Longrightarrow> s \\<in> productive_on fun", "then"], ["proof (chain)\npicking this:\n  s \\<in> terminates_on g", "show \"s \\<in> productive_on g\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. s \\<in> productive_on g", "by(induction)(auto intro: productive_on.intros)"], ["proof (state)\nthis:\n  s \\<in> productive_on g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lunstream_llist_of_trans [stream_fusion]:\n  \"lunstream' (llist_of_trans g) s = llist_of (unstream g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunstream' (llist_of_trans g) s = llist_of (unstream g s)", "apply(induction s taking: g rule: unstream.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   lunstream' (llist_of_trans g) x2 =\n                   llist_of (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           lunstream' (llist_of_trans g) x32 =\n           llist_of (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> lunstream' (llist_of_trans g) s =\n                         llist_of (unstream g s)", "apply(rule llist.expand)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   lunstream' (llist_of_trans g) x2 =\n                   llist_of (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           lunstream' (llist_of_trans g) x32 =\n           llist_of (unstream g x32)\\<rbrakk>\n       \\<Longrightarrow> lnull (lunstream' (llist_of_trans g) s) =\n                         lnull (llist_of (unstream g s))\n 2. \\<And>s.\n       \\<lbrakk>\\<And>x2.\n                   generator g s = Skip x2 \\<Longrightarrow>\n                   lunstream' (llist_of_trans g) x2 =\n                   llist_of (unstream g x2);\n        \\<And>x31 x32.\n           generator g s = Yield x31 x32 \\<Longrightarrow>\n           lunstream' (llist_of_trans g) x32 = llist_of (unstream g x32);\n        \\<not> lnull (lunstream' (llist_of_trans g) s);\n        \\<not> lnull (llist_of (unstream g s))\\<rbrakk>\n       \\<Longrightarrow> lhd (lunstream' (llist_of_trans g) s) =\n                         lhd (llist_of (unstream g s)) \\<and>\n                         ltl (lunstream' (llist_of_trans g) s) =\n                         ltl (llist_of (unstream g s))", "apply(auto intro: llist.expand simp add: llist_of_trans.rep_eq lunstream_sels lunstream'.rep_eq split: step.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We cannot define a stream version of @{const list_of} because we would have to test\n  for finiteness first and therefore traverse the list twice.\\<close>"], ["", "end"]]}