{"file_name": "/home/qj213/afp-2021-10-22/thys/Stream_Fusion_Code/Stream_Fusion_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stream_Fusion_Code", "problem_names": ["lemma fixes rhs z\n  defines \"rhs \\<equiv> nth_cons (flatten (\\<lambda>s'. s') (upto_prod 17) (upto_prod z)) (2, None) 8\"\n  shows \"nth (List.maps (\\<lambda>x. upto x 17) (upto 2 z)) 8 = rhs\"", "lemma fixes rhs z\n  defines \"rhs \\<equiv> nth_cons (flatten (\\<lambda>s. (s, 1)) (fix_gen (\\<lambda>x. upto_prod (id x))) (upto_prod z)) (2, None) 8\"\n  shows \"nth (List.maps (\\<lambda>x. upto 1 (id x)) (upto 2 z)) 8 = rhs\"", "lemma fixes rhs n\n  defines \"rhs \\<equiv> List.maps (\\<lambda>x. [Suc 0..<sum_list_cons (replicate_prod x) x]) [2..<n]\"\n  shows \"(concat (map (\\<lambda>x. [1..<sum_list (replicate x x)]) [2..<n])) = rhs\"", "lemma unstream_if [stream_fusion]:\n  \"unstream (if b then g else g') (if b then s else s') =\n   (if b then unstream g s else unstream g' s')\"", "lemma if_same [code_unfold]: \"(if b then x else x) = x\""], "translations": [["", "lemma fixes rhs z\n  defines \"rhs \\<equiv> nth_cons (flatten (\\<lambda>s'. s') (upto_prod 17) (upto_prod z)) (2, None) 8\"\n  shows \"nth (List.maps (\\<lambda>x. upto x 17) (upto 2 z)) 8 = rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.maps (\\<lambda>x. [x..17]) [2..z] ! 8 = rhs", "using [[simproc add: stream_fusion, stream_fusion_trace]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.maps (\\<lambda>x. [x..17]) [2..z] ! 8 = rhs", "apply(simp del: id_apply) \\<comment> \\<open>fuses\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_cons (flatten (\\<lambda>s'. s') (upto_prod 17) (upto_prod z))\n     (2, None) 8 =\n    rhs", "by(unfold rhs_def) rule"], ["", "lemma fixes rhs z\n  defines \"rhs \\<equiv> nth_cons (flatten (\\<lambda>s. (s, 1)) (fix_gen (\\<lambda>x. upto_prod (id x))) (upto_prod z)) (2, None) 8\"\n  shows \"nth (List.maps (\\<lambda>x. upto 1 (id x)) (upto 2 z)) 8 = rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.maps (\\<lambda>x. [1..id x]) [2..z] ! 8 = rhs", "using [[simproc add: stream_fusion, stream_fusion_trace]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.maps (\\<lambda>x. [1..id x]) [2..z] ! 8 = rhs", "apply(simp del: id_apply) \\<comment> \\<open>fuses\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_cons\n     (flatten (\\<lambda>s. (s, 1)) (fix_gen (\\<lambda>x. upto_prod (id x)))\n       (upto_prod z))\n     (2, None) 8 =\n    rhs", "by(unfold rhs_def) rule"], ["", "lemma fixes rhs n\n  defines \"rhs \\<equiv> List.maps (\\<lambda>x. [Suc 0..<sum_list_cons (replicate_prod x) x]) [2..<n]\"\n  shows \"(concat (map (\\<lambda>x. [1..<sum_list (replicate x x)]) [2..<n])) = rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>x. [1..<sum_list (replicate x x)]) [2..<n]) = rhs", "using [[simproc add: stream_fusion, stream_fusion_trace]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>x. [1..<sum_list (replicate x x)]) [2..<n]) = rhs", "apply(simp add: concat_map_maps) \\<comment> \\<open>fuses partially\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.maps (\\<lambda>x. [Suc 0..<sum_list_cons (replicate_prod x) x])\n     [2..<n] =\n    rhs", "by(unfold rhs_def) rule"], ["", "subsection \\<open>Micro-benchmarks from Farmer et al. \\cite{FarmerHoenerGill2014PEPM}\\<close>"], ["", "definition test_enum :: \"nat \\<Rightarrow> nat\" \\<comment> \\<open>@{const id} required to avoid eta contraction\\<close>\nwhere \"test_enum n = foldl (+) 0 (List.maps (\\<lambda>x. upt 1 (id x)) (upt 1 n))\""], ["", "definition test_nested :: \"nat \\<Rightarrow> nat\"\nwhere \"test_nested n = foldl (+) 0 (List.maps (\\<lambda>x. List.maps (\\<lambda>y. upt y x) (upt 1 x)) (upt 1 n))\""], ["", "definition test_merge :: \"integer \\<Rightarrow> nat\"\nwhere \"test_merge n = foldl (+) 0 (List.maps (\\<lambda>x. if 2 dvd x then upt 1 x else upt 2 x) (upt 1 (nat_of_integer n)))\""], ["", "text \\<open>\n  This rule performs the merge operation from \\cite[\\S 5.2]{FarmerHoenerGill2014PEPM} for \\<open>if\\<close>.\n  In general, we would also need it for all case operators.\n\\<close>"], ["", "lemma unstream_if [stream_fusion]:\n  \"unstream (if b then g else g') (if b then s else s') =\n   (if b then unstream g s else unstream g' s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unstream (if b then g else g') (if b then s else s') =\n    (if b then unstream g s else unstream g' s')", "by simp"], ["", "lemma if_same [code_unfold]: \"(if b then x else x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then x else x) = x", "by simp"], ["", "code_thms test_enum"], ["", "code_thms test_nested"], ["", "code_thms test_merge"], ["", "subsection \\<open>Test stream fusion in the code generator\\<close>"], ["", "definition fuse_test :: integer\nwhere \"fuse_test = \n  integer_of_int (lhd (lfilter (\\<lambda>x. x < 1) (lappend (lmap (\\<lambda>x. x + 1) (llist_of (map (\\<lambda>x. if x = 0 then undefined else x) [-3..5]))) (repeat 3))))\""], ["", "ML_val \\<open>val ~2 = @{code fuse_test}\\<close> \\<comment> \\<open>If this test fails with exception Fail, then the stream fusion simproc failed. This test exploits\n  that stream fusion introduces laziness.\\<close>"], ["", "end"]]}