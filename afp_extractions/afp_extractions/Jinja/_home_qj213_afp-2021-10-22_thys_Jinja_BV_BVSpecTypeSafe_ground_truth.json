{"file_name": "/home/qj213/afp-2021-10-22/thys/Jinja/BV/BVSpecTypeSafe.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jinja", "problem_names": ["lemmas defs1 = correct_state_def conf_f_def wt_instr_def eff_def norm_eff_def app_def xcpt_app_def", "lemmas widen_rules [intro] = conf_widen confT_widen confs_widens confTs_widen", "lemma Invoke_handlers:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> \n  \\<exists>(f,t,D,h,d) \\<in> set (relevant_entries P (Invoke n M) pc xt). \n   P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and> pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\"", "lemma uncaught_xcpt_correct:\n  assumes wt: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes h:  \"h xcp = Some obj\"\n  shows \"\\<And>f. P,\\<Phi> \\<turnstile> (None, h, f#frs)\\<surd> \\<Longrightarrow> P,\\<Phi> \\<turnstile> (find_handler P xcp h frs) \\<surd>\" \n  (is \"\\<And>f. ?correct (None, h, f#frs) \\<Longrightarrow> ?correct (?find frs)\")", "lemma exec_instr_xcpt_h:\n  \"\\<lbrakk>  fst (exec_instr (ins!pc) P h stk vars Cl M pc frs) = Some xcp;\n       P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M;\n       P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>obj. h xcp = Some obj\" \n  (is \"\\<lbrakk> ?xcpt; ?wt; ?correct \\<rbrakk> \\<Longrightarrow> ?thesis\")", "lemma conf_sys_xcpt:\n  \"\\<lbrakk>preallocated h; C \\<in> sys_xcpts\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> Addr (addr_of_sys_xcpt C) :\\<le> Class C\"", "lemma match_ex_table_SomeD:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> \n  \\<exists>(f,t,D,h,d) \\<in> set xt. matches_ex_entry P C pc (f,t,D,h,d) \\<and> h = pc' \\<and> d=d'\"", "lemma xcpt_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wtp:  \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes xp:   \"fst (exec_instr (ins!pc) P h stk loc C M pc frs) = Some xcp\"\n  assumes s':   \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs)\"\n  assumes correct: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Invoke_correct: \n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth_C: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:    \"ins ! pc = Invoke M' n\"\n  assumes wti:    \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes \\<sigma>': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs)\"\n  assumes approx: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_xcp: \"fst (exec_instr (ins!pc) P h stk loc C M pc frs) = None\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Return_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wt_prog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins: \"ins ! pc = Return\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs)\"\n  assumes correct: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Load_correct:\n\"\\<lbrakk> wf_prog wt P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n    ins!pc = Load idx; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs); \n    P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk>\n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Store_correct:\n\"\\<lbrakk> wf_prog wt P;\n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C;\n  ins!pc = Store idx;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M;\n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs);\n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk>\n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Push_correct:\n\"\\<lbrakk> wf_prog wt P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n    ins!pc = Push v;\n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs);\n    P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk>\n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Cast_conf2:\n  \"\\<lbrakk> wf_prog ok P; P,h \\<turnstile> v :\\<le> T; is_refT T; cast_ok P C h v; \n     P \\<turnstile> Class C \\<le> T'; is_class P C\\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\"", "lemma Checkcast_correct:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n    ins!pc = Checkcast D; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n    P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n    fst (exec_instr (ins!pc) P h stk loc C M pc frs) = None \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemmas widens_Cons [iff] = list_all2_Cons1 [of \"widen P\"] for P", "lemma Getfield_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Getfield F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes xc: \"fst (exec_instr (ins!pc) P h stk loc C M pc frs) = None\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Putfield_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Putfield F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes xc: \"fst (exec_instr (ins!pc) P h stk loc C M pc frs) = None\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma has_fields_b_fields: \n  \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs\"", "lemma oconf_blank [intro, simp]:\n    \"\\<lbrakk>is_class P C; wf_prog wt P\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> blank P C \\<surd>\"", "lemma obj_ty_blank [iff]: \"obj_ty (blank P C) = Class C\"", "lemma New_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:  \"ins!pc = New X\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes exec: \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs)\"\n  assumes conf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"fst (exec_instr (ins!pc) P h stk loc C M pc frs) = None\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Goto_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = Goto branch; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma IfFalse_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = IfFalse branch; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma CmpEq_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = CmpEq;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Pop_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = Pop;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma IAdd_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = IAdd; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma Throw_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = Throw; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  fst (exec_instr (ins!pc) P h stk loc C M pc frs) = None \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "theorem instr_correct:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C;\n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs); \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma correct_state_impl_Some_method:\n  \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \n  \\<Longrightarrow> \\<exists>m Ts T. P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in C\"", "lemma BV_correct_1 [rule_format]:\n\"\\<And>\\<sigma>. \\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P,\\<Phi> \\<turnstile> \\<sigma>\\<surd>\\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' \\<longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "theorem progress:\n  \"\\<lbrakk> xp=None; frs\\<noteq>[] \\<rbrakk> \\<Longrightarrow> \\<exists>\\<sigma>'. P \\<turnstile> (xp,h,frs) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'\"", "lemma progress_conform:\n  \"\\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P,\\<Phi> \\<turnstile> (xp,h,frs)\\<surd>; xp=None; frs\\<noteq>[]\\<rbrakk> \n  \\<Longrightarrow> \\<exists>\\<sigma>'. P \\<turnstile> (xp,h,frs) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' \\<and> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "theorem BV_correct [rule_format]:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' \\<rbrakk> \\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>\\<surd> \\<longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\"", "lemma hconf_start:   \n  assumes wf: \"wf_prog wf_mb P\"\n  shows \"P \\<turnstile> (start_heap P) \\<surd>\"", "lemma BV_correct_initial: \n  shows \"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P \\<turnstile> C sees M:[]\\<rightarrow>T = m in C \\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> \\<turnstile> start_state P C M \\<surd>\"", "theorem typesafe:\n  assumes welltyped:   \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes main_method: \"P \\<turnstile> C sees M:[]\\<rightarrow>T = m in C\"\n  shows \"P \\<turnstile> start_state P C M -jvm\\<rightarrow> \\<sigma>  \\<Longrightarrow>  P,\\<Phi> \\<turnstile> \\<sigma> \\<surd>\""], "translations": [["", "lemmas defs1 = correct_state_def conf_f_def wt_instr_def eff_def norm_eff_def app_def xcpt_app_def"], ["", "lemmas widen_rules [intro] = conf_widen confT_widen confs_widens confTs_widen"], ["", "subsection \\<open>Exception Handling\\<close>"], ["", "text \\<open>\n  For the \\<open>Invoke\\<close> instruction the BV has checked all handlers\n  that guard the current \\<open>pc\\<close>.\n\\<close>"], ["", "lemma Invoke_handlers:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> \n  \\<exists>(f,t,D,h,d) \\<in> set (relevant_entries P (Invoke n M) pc xt). \n   P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and> pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_ex_table P C pc xt = \\<lfloor>(pc', d')\\<rfloor> \\<Longrightarrow>\n    \\<exists>(f, t, D, h, d)\n             \\<in>set (relevant_entries P (Invoke n M) pc xt).\n       P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and>\n       pc \\<in> {f..<t} \\<and> pc' = h \\<and> d' = d", "by (induct xt) (auto simp add: relevant_entries_def matches_ex_entry_def \n                                 is_relevant_entry_def split: if_split_asm)"], ["", "text \\<open>\n  We can prove separately that the recursive search for exception\n  handlers (\\<open>find_handler\\<close>) in the frame stack results in \n  a conforming state (if there was no matching exception handler \n  in the current frame). We require that the exception is a valid\n  heap address, and that the state before the exception occurred\n  conforms. \n\\<close>"], ["", "term find_handler"], ["", "lemma uncaught_xcpt_correct:\n  assumes wt: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes h:  \"h xcp = Some obj\"\n  shows \"\\<And>f. P,\\<Phi> \\<turnstile> (None, h, f#frs)\\<surd> \\<Longrightarrow> P,\\<Phi> \\<turnstile> (find_handler P xcp h frs) \\<surd>\" \n  (is \"\\<And>f. ?correct (None, h, f#frs) \\<Longrightarrow> ?correct (?find frs)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h frs [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h frs [ok]", "proof (induct frs) \n  \\<comment> \\<open>the base\n case is trivial as it should be\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       P,\\<Phi> |- (None, h, [f]) [ok] \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h [] [ok]\n 2. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n                   P,\\<Phi> |- find_handler P xcp h frs [ok];\n        P,\\<Phi> |- (None, h, f # a # frs) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) [ok]", "show \"?correct (?find [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h [] [ok]", "by (simp add: correct_state_def)"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h [] [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n                   P,\\<Phi> |- find_handler P xcp h frs [ok];\n        P,\\<Phi> |- (None, h, f # a # frs) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) [ok]", "next\n  \\<comment> \\<open>we will need both forms @{text wf_jvm_prog} and @{text wf_prog} later\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n                   P,\\<Phi> |- find_handler P xcp h frs [ok];\n        P,\\<Phi> |- (None, h, f # a # frs) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) [ok]", "from wt"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain mb where wf: \"wf_prog mb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>mb. wf_prog mb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)\n\n  \\<comment> \\<open>the assumption for the cons case:\\<close>"], ["proof (state)\nthis:\n  wf_prog mb P\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n                   P,\\<Phi> |- find_handler P xcp h frs [ok];\n        P,\\<Phi> |- (None, h, f # a # frs) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) [ok]", "fix f f' frs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n                   P,\\<Phi> |- find_handler P xcp h frs [ok];\n        P,\\<Phi> |- (None, h, f # a # frs) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) [ok]", "assume cr: \"?correct (None, h, f#f'#frs')\" \n\n  \\<comment> \\<open>the induction hypothesis:\\<close>"], ["proof (state)\nthis:\n  P,\\<Phi> |- (None, h, f # f' # frs') [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n                   P,\\<Phi> |- find_handler P xcp h frs [ok];\n        P,\\<Phi> |- (None, h, f # a # frs) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) [ok]", "assume IH: \"\\<And>f. ?correct (None, h, f#frs') \\<Longrightarrow> ?correct (?find frs')\""], ["proof (state)\nthis:\n  P,\\<Phi> |- (None, h, ?f # frs') [ok] \\<Longrightarrow>\n  P,\\<Phi> |- find_handler P xcp h frs' [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n                   P,\\<Phi> |- find_handler P xcp h frs [ok];\n        P,\\<Phi> |- (None, h, f # a # frs) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) [ok]", "from cr"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f # f' # frs') [ok]", "have cr': \"?correct (None, h, f'#frs')\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f # f' # frs') [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (None, h, f' # frs') [ok]", "by (fastforce simp add: correct_state_def)"], ["proof (state)\nthis:\n  P,\\<Phi> |- (None, h, f' # frs') [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n                   P,\\<Phi> |- find_handler P xcp h frs [ok];\n        P,\\<Phi> |- (None, h, f # a # frs) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) [ok]", "obtain stk loc C M pc where [simp]: \"f' = (stk,loc,C,M,pc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stk loc C M pc.\n        f' = (stk, loc, C, M, pc) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases f')"], ["proof (state)\nthis:\n  f' = (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n                   P,\\<Phi> |- find_handler P xcp h frs [ok];\n        P,\\<Phi> |- (None, h, f # a # frs) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) [ok]", "from cr"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f # f' # frs') [ok]", "obtain Ts T mxs mxl\\<^sub>0 ins xt where\n    meth: \"P \\<turnstile> C sees M:Ts \\<rightarrow> T = (mxs,mxl\\<^sub>0,ins,xt) in C\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f # f' # frs') [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T mxs mxl\\<^sub>0 ins xt.\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (simp add: correct_state_def, blast)"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n                   P,\\<Phi> |- find_handler P xcp h frs [ok];\n        P,\\<Phi> |- (None, h, f # a # frs) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) [ok]", "hence [simp]: \"ex_table_of P C M = xt\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n\ngoal (1 subgoal):\n 1. ex_table_of P C M = xt", "by simp"], ["proof (state)\nthis:\n  ex_table_of P C M = xt\n\ngoal (1 subgoal):\n 1. \\<And>a frs f.\n       \\<lbrakk>\\<And>f.\n                   P,\\<Phi> |- (None, h, f # frs) [ok] \\<Longrightarrow>\n                   P,\\<Phi> |- find_handler P xcp h frs [ok];\n        P,\\<Phi> |- (None, h, f # a # frs) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- find_handler P xcp h (a # frs) [ok]", "show \"?correct (?find (f'#frs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "proof (cases \"match_ex_table P (cname_of h xcp) pc xt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow>\n    P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]\n 2. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "case None"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = None\n\ngoal (2 subgoals):\n 1. match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow>\n    P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]\n 2. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "with cr' IH [of f']"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f' # frs') [ok]\n  P,\\<Phi> |- (None, h, f' # frs') [ok] \\<Longrightarrow>\n  P,\\<Phi> |- find_handler P xcp h frs' [ok]\n  match_ex_table P (cname_of h xcp) pc xt = None", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f' # frs') [ok]\n  P,\\<Phi> |- (None, h, f' # frs') [ok] \\<Longrightarrow>\n  P,\\<Phi> |- find_handler P xcp h frs' [ok]\n  match_ex_table P (cname_of h xcp) pc xt = None\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "fix pc_d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "assume \"match_ex_table P (cname_of h xcp) pc xt = Some pc_d\""], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "then"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>", "obtain pc' d' where \n      match: \"match_ex_table P (cname_of h xcp) pc xt = Some (pc',d')\"\n      (is \"?match (cname_of h xcp) = _\")"], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>pc' d'.\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc', d')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases pc_d) auto"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "from wt meth cr' [simplified]"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs') [ok]", "have wti: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs') [ok]\n\ngoal (1 subgoal):\n 1. P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "by (fastforce simp add: correct_state_def conf_f_def\n                   dest: sees_method_fun\n                   elim!: wt_jvm_prog_impl_wt_instr)"], ["proof (state)\nthis:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "from cr meth"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f # f' # frs') [ok]\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C", "obtain n M' ST LT where\n      ins: \"ins!pc = Invoke n M'\" (is \"_ = ?i\") and\n      \\<Phi>: \"\\<Phi> C M ! pc = Some (ST, LT)\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f # f' # frs') [ok]\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>n M' ST LT.\n        \\<lbrakk>ins ! pc = Invoke n M';\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun simp add: correct_state_def)"], ["proof (state)\nthis:\n  ins ! pc = Invoke n M'\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "from ins match"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke n M'\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>", "obtain f t D where\n      rel: \"(f,t,D,pc',d') \\<in> set (relevant_entries P (ins!pc) pc xt)\" and\n      D: \"P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  ins ! pc = Invoke n M'\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>f t D.\n        \\<lbrakk>(f, t, D, pc', d')\n                 \\<in> set (relevant_entries P (ins ! pc) pc xt);\n         P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: Invoke_handlers)"], ["proof (state)\nthis:\n  (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "from rel"], ["proof (chain)\npicking this:\n  (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)", "have \n      \"(pc', Some (Class D # drop (size ST - d') ST, LT)) \\<in> set (xcpt_eff (ins!pc) P pc (ST,LT) xt)\"\n      (is \"(_, Some (?ST',_)) \\<in> _\")"], ["proof (prove)\nusing this:\n  (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n\ngoal (1 subgoal):\n 1. (pc', \\<lfloor>(Class D # drop (length ST - d') ST, LT)\\<rfloor>)\n    \\<in> set (xcpt_eff (ins ! pc) P pc (ST, LT) xt)", "by (force simp add: xcpt_eff_def image_def)"], ["proof (state)\nthis:\n  (pc', \\<lfloor>(Class D # drop (length ST - d') ST, LT)\\<rfloor>)\n  \\<in> set (xcpt_eff (ins ! pc) P pc (ST, LT) xt)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "with wti \\<Phi>"], ["proof (chain)\npicking this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  (pc', \\<lfloor>(Class D # drop (length ST - d') ST, LT)\\<rfloor>)\n  \\<in> set (xcpt_eff (ins ! pc) P pc (ST, LT) xt)", "obtain \n      pc: \"pc' < size ins\" and\n      \"P \\<turnstile> Some (?ST', LT) \\<le>' \\<Phi> C M ! pc'\""], ["proof (prove)\nusing this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  (pc', \\<lfloor>(Class D # drop (length ST - d') ST, LT)\\<rfloor>)\n  \\<in> set (xcpt_eff (ins ! pc) P pc (ST, LT) xt)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>pc' < length ins;\n      P \\<turnstile> \\<lfloor>(Class D # drop (length ST - d') ST,\n                               LT)\\<rfloor> \\<le>' \\<Phi> C M ! pc'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp add: defs1) blast"], ["proof (state)\nthis:\n  pc' < length ins\n  P \\<turnstile> \\<lfloor>(Class D # drop (length ST - d') ST,\n                           LT)\\<rfloor> \\<le>' \\<Phi> C M ! pc'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "then"], ["proof (chain)\npicking this:\n  pc' < length ins\n  P \\<turnstile> \\<lfloor>(Class D # drop (length ST - d') ST,\n                           LT)\\<rfloor> \\<le>' \\<Phi> C M ! pc'", "obtain ST' LT' where\n      \\<Phi>': \"\\<Phi> C M ! pc' = Some (ST',LT')\" and\n      less: \"P \\<turnstile> (?ST', LT) \\<le>\\<^sub>i (ST',LT')\""], ["proof (prove)\nusing this:\n  pc' < length ins\n  P \\<turnstile> \\<lfloor>(Class D # drop (length ST - d') ST,\n                           LT)\\<rfloor> \\<le>' \\<Phi> C M ! pc'\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT'.\n        \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> (Class D # drop (length ST - d') ST,\n                         LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "from cr' \\<Phi> meth"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f' # frs') [ok]\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C", "have \"conf_f P h (ST, LT) ins f'\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f' # frs') [ok]\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n\ngoal (1 subgoal):\n 1. conf_f P h (ST, LT) ins f'", "by (unfold correct_state_def) (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  conf_f P h (ST, LT) ins f'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "hence loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and \n          stk: \"P,h \\<turnstile> stk [:\\<le>] ST\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins f'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT &&&\n    P,h \\<turnstile> stk [:\\<le>] ST", "by (unfold conf_f_def) auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "hence [simp]: \"size stk = size ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. length stk = length ST", "by (simp add: list_all2_lengthD)"], ["proof (state)\nthis:\n  length stk = length ST\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "let ?f = \"(Addr xcp # drop (length stk - d') stk, loc, C, M, pc')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "have \"conf_f P h (ST',LT') ins ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "from wf less loc"], ["proof (chain)\npicking this:\n  wf_prog mb P\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  wf_prog mb P\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "by simp blast"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "from D h"], ["proof (chain)\npicking this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  h xcp = \\<lfloor>obj\\<rfloor>", "have \"P,h \\<turnstile> Addr xcp :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr xcp :\\<le> Class D", "by (simp add: conf_def obj_ty_def case_prod_unfold)"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n\ngoal (1 subgoal):\n 1. conf_f P h (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "with less stk"], ["proof (chain)\npicking this:\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> Addr xcp :\\<le> Class D", "have \"P,h \\<turnstile> Addr xcp # drop (length stk - d') stk  [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr xcp # drop (length stk - d') stk [:\\<le>] ST'", "by (auto intro!: list_all2_dropI)"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr xcp # drop (length stk - d') stk [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P,h \\<turnstile> Addr xcp # drop (length stk - d') stk [:\\<le>] ST'", "show ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P,h \\<turnstile> Addr xcp # drop (length stk - d') stk [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "using pc"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P,h \\<turnstile> Addr xcp # drop (length stk - d') stk [:\\<le>] ST'\n  pc' < length ins\n\ngoal (1 subgoal):\n 1. conf_f P h (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "by (simp add: conf_f_def)"], ["proof (state)\nthis:\n  conf_f P h (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conf_f P h (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P (cname_of h xcp) pc xt =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "with cr' match \\<Phi>' meth pc"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, f' # frs') [ok]\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  pc' < length ins\n  conf_f P h (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "show ?thesis"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, f' # frs') [ok]\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  pc' < length ins\n  conf_f P h (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]", "by (unfold correct_state_def) (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h (f' # frs') [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text \\<open>\n  The requirement of lemma \\<open>uncaught_xcpt_correct\\<close> (that\n  the exception is a valid reference on the heap) is always met\n  for welltyped instructions and conformant states:\n\\<close>"], ["", "lemma exec_instr_xcpt_h:\n  \"\\<lbrakk>  fst (exec_instr (ins!pc) P h stk vars Cl M pc frs) = Some xcp;\n       P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M;\n       P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk>\n  \\<Longrightarrow> \\<exists>obj. h xcp = Some obj\" \n  (is \"\\<lbrakk> ?xcpt; ?wt; ?correct \\<rbrakk> \\<Longrightarrow> ?thesis\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "note [simp] = split_beta"], ["proof (state)\nthis:\n  (case ?prod of (x, xa) \\<Rightarrow> ?f x xa) = ?f (fst ?prod) (snd ?prod)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "note [split] = if_split_asm option.split_asm"], ["proof (state)\nthis:\n  ?P (if ?Q then ?x else ?y) =\n  (\\<not> (?Q \\<and> \\<not> ?P ?x \\<or> \\<not> ?Q \\<and> \\<not> ?P ?y))\n  ?P (case ?option of None \\<Rightarrow> ?f1.0\n      | \\<lfloor>x\\<rfloor> \\<Rightarrow> ?f2.0 x) =\n  (\\<not> (?option = None \\<and> \\<not> ?P ?f1.0 \\<or>\n           (\\<exists>x2.\n               ?option = \\<lfloor>x2\\<rfloor> \\<and> \\<not> ?P (?f2.0 x2))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "assume wt: ?wt ?correct"], ["proof (state)\nthis:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "hence pre: \"preallocated h\""], ["proof (prove)\nusing this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n\ngoal (1 subgoal):\n 1. preallocated h", "by (simp add: correct_state_def hconf_def)"], ["proof (state)\nthis:\n  preallocated h\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "assume xcpt: ?xcpt"], ["proof (state)\nthis:\n  fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n  \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n             \\<lfloor>xcp\\<rfloor>;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "with pre"], ["proof (chain)\npicking this:\n  preallocated h\n  fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n  \\<lfloor>xcp\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  preallocated h\n  fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n  \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "proof (cases \"ins!pc\")"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 2. \\<And>x2.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 3. \\<And>x3.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 4. \\<And>x4.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 5. \\<And>x51 x52.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 6. \\<And>x61 x62.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 7. \\<And>x7.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 8. \\<And>x81 x82.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 9. \\<lbrakk>preallocated h;\n     fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 10. \\<lbrakk>preallocated h;\n      fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\nA total of 15 subgoals...", "case Throw"], ["proof (state)\nthis:\n  ins ! pc = Throw\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 2. \\<And>x2.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 3. \\<And>x3.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 4. \\<And>x4.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 5. \\<And>x51 x52.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 6. \\<And>x61 x62.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 7. \\<And>x7.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 8. \\<And>x81 x82.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 9. \\<lbrakk>preallocated h;\n     fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 10. \\<lbrakk>preallocated h;\n      fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\nA total of 15 subgoals...", "with xcpt wt pre"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n  \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n  preallocated h\n  ins ! pc = Throw", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n  \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n  preallocated h\n  ins ! pc = Throw\n\ngoal (1 subgoal):\n 1. \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>", "by (clarsimp iff: list_all2_Cons2 simp add: defs1) \n         (auto dest: non_npD simp: is_refT_def elim: preallocatedE)"], ["proof (state)\nthis:\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 2. \\<And>x2.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 3. \\<And>x3.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 4. \\<And>x4.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 5. \\<And>x51 x52.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 6. \\<And>x61 x62.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 7. \\<And>x7.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 8. \\<And>x81 x82.\n       \\<lbrakk>preallocated h;\n        fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 9. \\<lbrakk>preallocated h;\n     fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n 10. \\<lbrakk>preallocated h;\n      fst (exec_instr (ins ! pc) P h stk vars Cl M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\nA total of 14 subgoals...", "qed (auto elim: preallocatedE)"], ["proof (state)\nthis:\n  \\<exists>obj. h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma conf_sys_xcpt:\n  \"\\<lbrakk>preallocated h; C \\<in> sys_xcpts\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> Addr (addr_of_sys_xcpt C) :\\<le> Class C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preallocated h; C \\<in> sys_xcpts\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> Addr\n  (addr_of_sys_xcpt C) :\\<le> Class C", "by (auto elim: preallocatedE)"], ["", "lemma match_ex_table_SomeD:\n  \"match_ex_table P C pc xt = Some (pc',d') \\<Longrightarrow> \n  \\<exists>(f,t,D,h,d) \\<in> set xt. matches_ex_entry P C pc (f,t,D,h,d) \\<and> h = pc' \\<and> d=d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_ex_table P C pc xt = \\<lfloor>(pc', d')\\<rfloor> \\<Longrightarrow>\n    \\<exists>(f, t, D, h, d)\\<in>set xt.\n       matches_ex_entry P C pc (f, t, D, h, d) \\<and> h = pc' \\<and> d = d'", "by (induct xt) (auto split: if_split_asm)"], ["", "text \\<open>\n  Finally we can state that, whenever an exception occurs, the\n  next state always conforms:\n\\<close>"], ["", "lemma xcpt_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wtp:  \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes xp:   \"fst (exec_instr (ins!pc) P h stk loc C M pc frs) = Some xcp\"\n  assumes s':   \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs)\"\n  assumes correct: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wtp"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wf: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note conf_sys_xcpt [elim!]"], ["proof (state)\nthis:\n  \\<lbrakk>preallocated ?h; ?C \\<in> sys_xcpts\\<rbrakk>\n  \\<Longrightarrow> ?P,?h \\<turnstile> Addr\n  (addr_of_sys_xcpt ?C) :\\<le> Class ?C\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note xp' = meth s' xp"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note wtp"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from xp wt correct"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]", "obtain obj where h: \"h xcp = Some obj\""], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>obj.\n        h xcp = \\<lfloor>obj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: exec_instr_xcpt_h)"], ["proof (state)\nthis:\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note correct"], ["proof (state)\nthis:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  h xcp = \\<lfloor>obj\\<rfloor>\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]", "have \"P,\\<Phi> \\<turnstile> find_handler P xcp h frs \\<surd>\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  h xcp = \\<lfloor>obj\\<rfloor>\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- find_handler P xcp h frs [ok]", "by (rule uncaught_xcpt_correct)"], ["proof (state)\nthis:\n  P,\\<Phi> |- find_handler P xcp h frs [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with xp'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  P,\\<Phi> |- find_handler P xcp h frs [ok]", "have \"match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow> ?thesis\" \n    (is \"?m (cname_of h xcp) = _ \\<Longrightarrow> _\" is \"?match = _ \\<Longrightarrow> _\")"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  P,\\<Phi> |- find_handler P xcp h frs [ok]\n\ngoal (1 subgoal):\n 1. match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma>' [ok]", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "fix pc_d"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume \"?match = Some pc_d\""], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>", "obtain pc' d' where some_handler: \"?match = Some (pc',d')\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>pc_d\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>pc' d'.\n        match_ex_table P (cname_of h xcp) pc xt =\n        \\<lfloor>(pc', d')\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases pc_d) auto"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from correct meth"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C", "obtain ST LT where\n      h_ok:  \"P \\<turnstile> h \\<surd>\" and\n      \\<Phi>_pc: \"\\<Phi> C M ! pc = Some (ST, LT)\" and\n      frame:  \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\" and\n      frames: \"conf_fs P h \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold correct_state_def) (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from h_ok"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>", "have preh: \"preallocated h\""], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n\ngoal (1 subgoal):\n 1. preallocated h", "by (simp add: hconf_def)"], ["proof (state)\nthis:\n  preallocated h\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "obtain \n      stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and\n      loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n      pc:  \"pc < size ins\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,h \\<turnstile> stk [:\\<le>] ST;\n      P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n      pc < length ins\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold conf_f_def) auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST", "have [simp]: \"size stk = size ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. length stk = length ST", ".."], ["proof (state)\nthis:\n  length stk = length ST\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wt \\<Phi>_pc"], ["proof (chain)\npicking this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have\n      eff: \"\\<forall>(pc', s')\\<in>set (xcpt_eff (ins!pc) P pc (ST,LT) xt).\n             pc' < size ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M!pc'\""], ["proof (prove)\nusing this:\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n       pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'", "by (auto simp add: defs1)"], ["proof (state)\nthis:\n  \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?stk' = \"Addr xcp # drop (length stk - d') stk\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?f = \"(?stk', loc, C, M, pc')\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from some_handler xp'"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>", "have \\<sigma>': \"\\<sigma>' = (None, h, ?f#frs)\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h, (Addr xcp # drop (length stk - d') stk, loc, C, M, pc') # frs)", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h, (Addr xcp # drop (length stk - d') stk, loc, C, M, pc') # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from some_handler"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>", "obtain f t D where\n      xt: \"(f,t,D,pc',d') \\<in> set xt\" and\n      \"matches_ex_entry P (cname_of h xcp) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = \\<lfloor>(pc', d')\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>f t D.\n        \\<lbrakk>(f, t, D, pc', d') \\<in> set xt;\n         matches_ex_entry P (cname_of h xcp) pc (f, t, D, pc', d')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: match_ex_table_SomeD)"], ["proof (state)\nthis:\n  (f, t, D, pc', d') \\<in> set xt\n  matches_ex_entry P (cname_of h xcp) pc (f, t, D, pc', d')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "hence match: \"P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\"  \"pc \\<in> {f..<t}\""], ["proof (prove)\nusing this:\n  (f, t, D, pc', d') \\<in> set xt\n  matches_ex_entry P (cname_of h xcp) pc (f, t, D, pc', d')\n\ngoal (1 subgoal):\n 1. P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D &&& pc \\<in> {f..<t}", "by (auto simp: matches_ex_entry_def)"], ["proof (state)\nthis:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from xp"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>", "obtain\n      \"(f,t,D,pc',d') \\<in> set (relevant_entries P (ins!pc) pc xt)\" and\n      conf: \"P,h \\<turnstile> Addr xcp :\\<le> Class D\""], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>(f, t, D, pc', d')\n              \\<in> set (relevant_entries P (ins ! pc) pc xt);\n      P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"ins!pc\")"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 15 subgoals...", "case Return"], ["proof (state)\nthis:\n  ins ! pc = Return\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 15 subgoals...", "with xp"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  ins ! pc = Return", "have False"], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  ins ! pc = Return\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  False\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = Pop\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 15 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = IAdd\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = IAdd\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 14 subgoals...", "case New"], ["proof (state)\nthis:\n  ins ! pc = New x4_\n\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = IAdd\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 14 subgoals...", "with xp"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  ins ! pc = New x4_", "have [simp]: \"xcp = addr_of_sys_xcpt OutOfMemory\""], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  ins ! pc = New x4_\n\ngoal (1 subgoal):\n 1. xcp = addr_of_sys_xcpt OutOfMemory", "by simp"], ["proof (state)\nthis:\n  xcp = addr_of_sys_xcpt OutOfMemory\n\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = IAdd\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 14 subgoals...", "with New match preh"], ["proof (chain)\npicking this:\n  ins ! pc = New x4_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt OutOfMemory", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  ins ! pc = New x4_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt OutOfMemory\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (14 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = IAdd\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 14 subgoals...", "with match preh xt"], ["proof (chain)\npicking this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (1 subgoal):\n 1. thesis", "by (fastforce simp add: relevant_entries_def intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x12.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n         \\<lfloor>xcp\\<rfloor>;\n         ins ! pc = Goto x12\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x12.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n         \\<lfloor>xcp\\<rfloor>;\n         ins ! pc = Goto x12\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 13 subgoals...", "case Getfield"], ["proof (state)\nthis:\n  ins ! pc = Getfield x51_ x52_\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x12.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n         \\<lfloor>xcp\\<rfloor>;\n         ins ! pc = Goto x12\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 13 subgoals...", "with xp"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  ins ! pc = Getfield x51_ x52_", "have [simp]: \"xcp = addr_of_sys_xcpt NullPointer\""], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  ins ! pc = Getfield x51_ x52_\n\ngoal (1 subgoal):\n 1. xcp = addr_of_sys_xcpt NullPointer", "by (simp add: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  xcp = addr_of_sys_xcpt NullPointer\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x12.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n         \\<lfloor>xcp\\<rfloor>;\n         ins ! pc = Goto x12\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 13 subgoals...", "with Getfield match preh"], ["proof (chain)\npicking this:\n  ins ! pc = Getfield x51_ x52_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt NullPointer", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  ins ! pc = Getfield x51_ x52_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt NullPointer\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x12.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n         \\<lfloor>xcp\\<rfloor>;\n         ins ! pc = Goto x12\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 13 subgoals...", "with match preh xt"], ["proof (chain)\npicking this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (1 subgoal):\n 1. thesis", "by (fastforce simp add: relevant_entries_def intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = CmpEq\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = CmpEq\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 12 subgoals...", "case Putfield"], ["proof (state)\nthis:\n  ins ! pc = Putfield x61_ x62_\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = CmpEq\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 12 subgoals...", "with xp"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  ins ! pc = Putfield x61_ x62_", "have [simp]: \"xcp = addr_of_sys_xcpt NullPointer\""], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  ins ! pc = Putfield x61_ x62_\n\ngoal (1 subgoal):\n 1. xcp = addr_of_sys_xcpt NullPointer", "by (simp add: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  xcp = addr_of_sys_xcpt NullPointer\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = CmpEq\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 12 subgoals...", "with Putfield match preh"], ["proof (chain)\npicking this:\n  ins ! pc = Putfield x61_ x62_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt NullPointer", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  ins ! pc = Putfield x61_ x62_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt NullPointer\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x61 x62.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = CmpEq\\<rbrakk>\n     \\<Longrightarrow> thesis\nA total of 12 subgoals...", "with match preh xt"], ["proof (chain)\npicking this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (1 subgoal):\n 1. thesis", "by (fastforce simp add: relevant_entries_def intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x14.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n         \\<lfloor>xcp\\<rfloor>;\n         ins ! pc = IfFalse x14\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x14.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n         \\<lfloor>xcp\\<rfloor>;\n         ins ! pc = IfFalse x14\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 11 subgoals...", "case Checkcast"], ["proof (state)\nthis:\n  ins ! pc = Checkcast x7_\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x14.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n         \\<lfloor>xcp\\<rfloor>;\n         ins ! pc = IfFalse x14\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 11 subgoals...", "with xp"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  ins ! pc = Checkcast x7_", "have [simp]: \"xcp = addr_of_sys_xcpt ClassCast\""], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  ins ! pc = Checkcast x7_\n\ngoal (1 subgoal):\n 1. xcp = addr_of_sys_xcpt ClassCast", "by (simp add: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  xcp = addr_of_sys_xcpt ClassCast\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x14.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n         \\<lfloor>xcp\\<rfloor>;\n         ins ! pc = IfFalse x14\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 11 subgoals...", "with Checkcast match preh"], ["proof (chain)\npicking this:\n  ins ! pc = Checkcast x7_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt ClassCast", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  ins ! pc = Checkcast x7_\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  xcp = addr_of_sys_xcpt ClassCast\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x7.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 10. \\<And>x14.\n        \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                          \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                  P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                 \\<Longrightarrow> thesis;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n         \\<lfloor>xcp\\<rfloor>;\n         ins ! pc = IfFalse x14\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 11 subgoals...", "with match preh xt"], ["proof (chain)\npicking this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  (f, t, D, pc', d') \\<in> set xt\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (1 subgoal):\n 1. thesis", "by (fastforce simp add: relevant_entries_def intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = Throw\\<rbrakk>\n     \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = Throw\\<rbrakk>\n     \\<Longrightarrow> thesis", "case Invoke"], ["proof (state)\nthis:\n  ins ! pc = Invoke x81_ x82_\n\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = Throw\\<rbrakk>\n     \\<Longrightarrow> thesis", "with xp match"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc = Invoke x81_ x82_", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  ins ! pc = Invoke x81_ x82_\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = Throw\\<rbrakk>\n     \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = Throw\\<rbrakk>\n     \\<Longrightarrow> thesis", "from xp wt correct"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]", "obtain obj where xcp: \"h xcp = Some obj\""], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>obj.\n        h xcp = \\<lfloor>obj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: exec_instr_xcpt_h)"], ["proof (state)\nthis:\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (10 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x81 x82.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 7. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 9. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                       \\<in> set (relevant_entries P (ins ! pc) pc xt);\n               P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n              \\<Longrightarrow> thesis;\n      fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n      \\<lfloor>xcp\\<rfloor>;\n      ins ! pc = Throw\\<rbrakk>\n     \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. thesis", "using xt match"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n  (f, t, D, pc', d') \\<in> set xt\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp add: relevant_entries_def conf_def case_prod_unfold intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> thesis", "case Throw"], ["proof (state)\nthis:\n  ins ! pc = Throw\n\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> thesis", "with xp match preh"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  ins ! pc = Throw", "have \"is_relevant_entry P (ins!pc) pc (f,t,D,pc',d')\""], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n  preallocated h\n  ins ! pc = Throw\n\ngoal (1 subgoal):\n 1. is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')", "by (simp add: is_relevant_entry_def)"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> thesis", "from xp wt correct"], ["proof (chain)\npicking this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]", "obtain obj where xcp: \"h xcp = Some obj\""], ["proof (prove)\nusing this:\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = \\<lfloor>xcp\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>obj.\n        h xcp = \\<lfloor>obj\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: exec_instr_xcpt_h)"], ["proof (state)\nthis:\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (9 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n\ngoal (1 subgoal):\n 1. thesis", "using xt match"], ["proof (prove)\nusing this:\n  is_relevant_entry P (ins ! pc) pc (f, t, D, pc', d')\n  h xcp = \\<lfloor>obj\\<rfloor>\n  (f, t, D, pc', d') \\<in> set xt\n  P \\<turnstile> cname_of h xcp \\<preceq>\\<^sup>* D\n  pc \\<in> {f..<t}\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp add: relevant_entries_def conf_def case_prod_unfold intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (8 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>x12.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                      \\<in> set (relevant_entries P (ins ! pc) pc xt);\n              P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n     \\<lfloor>xcp\\<rfloor>;\n     ins ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> thesis\n 8. \\<And>x14.\n       \\<lbrakk>\\<lbrakk>(f, t, D, pc', d')\n                         \\<in> set (relevant_entries P (ins ! pc) pc xt);\n                 P,h \\<turnstile> Addr xcp :\\<le> Class D\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>xcp\\<rfloor>;\n        ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed auto"], ["proof (state)\nthis:\n  (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with eff"], ["proof (chain)\npicking this:\n  \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'\n  (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  P,h \\<turnstile> Addr xcp :\\<le> Class D", "obtain ST' LT' where\n      \\<Phi>_pc': \"\\<Phi> C M ! pc' = Some (ST', LT')\" and\n      pc':   \"pc' < size ins\" and\n      less:  \"P \\<turnstile> (Class D # drop (size ST - d') ST, LT) \\<le>\\<^sub>i (ST', LT')\""], ["proof (prove)\nusing this:\n  \\<forall>(pc', s')\\<in>set (xcpt_eff (ins ! pc) P pc (ST, LT) xt).\n     pc' < length ins \\<and> P \\<turnstile> s' \\<le>' \\<Phi> C M ! pc'\n  (f, t, D, pc', d') \\<in> set (relevant_entries P (ins ! pc) pc xt)\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT'.\n        \\<lbrakk>\\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n         pc' < length ins;\n         P \\<turnstile> (Class D # drop (length ST - d') ST,\n                         LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp add: xcpt_eff_def sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  pc' < length ins\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with conf loc stk"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  pc' < length ins\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')", "have \"conf_f P h (ST',LT') ins ?f\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr xcp :\\<le> Class D\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P,h \\<turnstile> stk [:\\<le>] ST\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  pc' < length ins\n  P \\<turnstile> (Class D # drop (length ST - d') ST,\n                  LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. conf_f P h (ST', LT') ins\n     (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "by (auto simp add: defs1 intro: list_all2_dropI)"], ["proof (state)\nthis:\n  conf_f P h (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with meth h_ok frames \\<Phi>_pc' \\<sigma>'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P \\<turnstile> h \\<surd>\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  \\<sigma>' =\n  (None, h, (Addr xcp # drop (length stk - d') stk, loc, C, M, pc') # frs)\n  conf_f P h (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')", "have ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P \\<turnstile> h \\<surd>\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  \\<Phi> C M ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  \\<sigma>' =\n  (None, h, (Addr xcp # drop (length stk - d') stk, loc, C, M, pc') # frs)\n  conf_f P h (ST', LT') ins\n   (Addr xcp # drop (length stk - d') stk, loc, C, M, pc')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by (unfold correct_state_def) (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  match_ex_table P (cname_of h xcp) pc xt =\n  \\<lfloor>?pc_d2\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  match_ex_table P (cname_of h xcp) pc xt =\n  \\<lfloor>?pc_d2\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  match_ex_table P (cname_of h xcp) pc xt = None \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n  match_ex_table P (cname_of h xcp) pc xt =\n  \\<lfloor>?pc_d2\\<rfloor> \\<Longrightarrow>\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by (cases \"?match\") blast+"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "subsection \\<open>Single Instructions\\<close>"], ["", "text \\<open>\n  In this section we prove for each single (welltyped) instruction\n  that the state after execution of the instruction still conforms.\n  Since we have already handled exceptions above, we can now assume that\n  no exception occurs in this step.\n\\<close>"], ["", "declare defs1 [simp]"], ["", "lemma Invoke_correct: \n  fixes \\<sigma>' :: jvm_state\n  assumes wtprog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth_C: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:    \"ins ! pc = Invoke M' n\"\n  assumes wti:    \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes \\<sigma>': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs)\"\n  assumes approx: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_xcp: \"fst (exec_instr (ins!pc) P h stk loc C M pc frs) = None\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note split_paired_Ex [simp del]"], ["proof (state)\nthis:\n  (\\<exists>x. ?P x) = (\\<exists>a b. ?P (a, b))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wtprog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wfprog: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins meth_C approx"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]", "obtain ST LT where\n    heap_ok: \"P\\<turnstile> h\\<surd>\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    frame:   \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\" and\n    frames:  \"conf_fs P h \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins wti \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "have n: \"n < size ST\""], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. n < length ST", "by simp"], ["proof (state)\nthis:\n  n < length ST\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  n < length ST\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume \"stk!n = Null\""], ["proof (state)\nthis:\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with ins no_xcp"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\n  stk ! n = Null", "have False"], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. False", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "hence ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", ".."], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  stk ! n = Null \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  stk ! n = Null \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  stk ! n = Null \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume \"ST!n = NT\""], ["proof (state)\nthis:\n  ST ! n = NT\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  ST ! n = NT\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "have \"P,h \\<turnstile> stk [:\\<le>] ST\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk [:\\<le>] ST", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with n"], ["proof (chain)\npicking this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> stk!n :\\<le> ST!n\""], ["proof (prove)\nusing this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk ! n :\\<le> ST ! n", "by (simp add: list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  ST ! n = NT\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n", "have \"stk!n = Null\""], ["proof (prove)\nusing this:\n  ST ! n = NT\n  P,h \\<turnstile> stk ! n :\\<le> ST ! n\n\ngoal (1 subgoal):\n 1. stk ! n = Null", "by simp"], ["proof (state)\nthis:\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with ins no_xcp"], ["proof (chain)\npicking this:\n  ins ! pc = Invoke M' n\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\n  stk ! n = Null", "have False"], ["proof (prove)\nusing this:\n  ins ! pc = Invoke M' n\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. False", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "hence ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", ".."], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  ST ! n = NT \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  ST ! n = NT \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  ST ! n = NT \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume NT: \"ST!n \\<noteq> NT\" and Null: \"stk!n \\<noteq> Null\""], ["proof (state)\nthis:\n  ST ! n \\<noteq> NT\n  stk ! n \\<noteq> Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from NT ins wti \\<Phi>_pc"], ["proof (chain)\npicking this:\n  ST ! n \\<noteq> NT\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>", "obtain D D' Ts T m ST' LT' where\n      D:   \"ST!n = Class D\" and\n      pc': \"pc+1 < size ins\" and\n      m_D: \"P \\<turnstile> D sees M': Ts\\<rightarrow>T = m in D'\" and\n      Ts:  \"P \\<turnstile> rev (take n ST) [\\<le>] Ts\" and\n      \\<Phi>':  \"\\<Phi> C M ! (pc+1) = Some (ST', LT')\" and\n      LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and\n      ST': \"P \\<turnstile> (T # drop (n+1) ST) [\\<le>] ST'\""], ["proof (prove)\nusing this:\n  ST ! n \\<noteq> NT\n  ins ! pc = Invoke M' n\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>D Ts T m D' ST' LT'.\n        \\<lbrakk>ST ! n = Class D; pc + 1 < length ins;\n         P \\<turnstile> D sees M': Ts\\<rightarrow>T = m in D';\n         P \\<turnstile> rev (take n ST) [\\<le>] Ts;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         P \\<turnstile> (T # drop (n + 1) ST) [\\<le>] ST'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp add: sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  ST ! n = Class D\n  pc + 1 < length ins\n  P \\<turnstile> D sees M': Ts\\<rightarrow>T = m in D'\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> (T # drop (n + 1) ST) [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from frame"], ["proof (chain)\npicking this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)", "obtain \n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and\n    loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\""], ["proof (prove)\nusing this:\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,h \\<turnstile> stk [:\\<le>] ST;\n      P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from n stk D"], ["proof (chain)\npicking this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST ! n = Class D", "have \"P,h \\<turnstile> stk!n :\\<le> Class D\""], ["proof (prove)\nusing this:\n  n < length ST\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST ! n = Class D\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk ! n :\\<le> Class D", "by (auto simp add: list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk ! n :\\<le> Class D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with Null"], ["proof (chain)\npicking this:\n  stk ! n \\<noteq> Null\n  P,h \\<turnstile> stk ! n :\\<le> Class D", "obtain a C' fs where\n      Addr:   \"stk!n = Addr a\" and\n      obj:    \"h a = Some (C',fs)\" and\n      C'subD: \"P \\<turnstile> C' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  stk ! n \\<noteq> Null\n  P,h \\<turnstile> stk ! n :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>a C' fs.\n        \\<lbrakk>stk ! n = Addr a; h a = \\<lfloor>(C', fs)\\<rfloor>;\n         P \\<turnstile> C' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest!: conf_ClassD)"], ["proof (state)\nthis:\n  stk ! n = Addr a\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with wfprog m_D"], ["proof (chain)\npicking this:\n  wf_prog wfmb P\n  P \\<turnstile> D sees M': Ts\\<rightarrow>T = m in D'\n  stk ! n = Addr a\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D", "obtain Ts' T' m' D'' mxs' mxl' ins' xt' where\n      m_C': \"P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = (mxs',mxl',ins',xt') in D''\" and\n      T':   \"P \\<turnstile> T' \\<le> T\" and\n      Ts':  \"P \\<turnstile> Ts [\\<le>] Ts'\""], ["proof (prove)\nusing this:\n  wf_prog wfmb P\n  P \\<turnstile> D sees M': Ts\\<rightarrow>T = m in D'\n  stk ! n = Addr a\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. (\\<And>Ts' T' mxs' mxl' ins' xt' D''.\n        \\<lbrakk>P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = (mxs',\n                            mxl', ins', xt') in D'';\n         subtype P T' T; P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_mono)"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n             xt') in D''\n  subtype P T' T\n  P \\<turnstile> Ts [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?loc' = \"Addr a # rev (take n stk) @ replicate mxl' undefined\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?f' = \"([], ?loc', D'', M', 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?f  = \"(stk, loc, C, M, pc)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from Addr obj m_C' ins \\<sigma>' meth_C"], ["proof (chain)\npicking this:\n  stk ! n = Addr a\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n             xt') in D''\n  ins ! pc = Invoke M' n\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C", "have s': \"\\<sigma>' = (None, h, ?f' # ?f # frs)\""], ["proof (prove)\nusing this:\n  stk ! n = Addr a\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n             xt') in D''\n  ins ! pc = Invoke M' n\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h,\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M',\n      0) #\n     (stk, loc, C, M, pc) # frs)", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0) #\n   (stk, loc, C, M, pc) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from Ts n"], ["proof (chain)\npicking this:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n  n < length ST", "have [simp]: \"size Ts = n\""], ["proof (prove)\nusing this:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n  n < length ST\n\ngoal (1 subgoal):\n 1. length Ts = n", "by (auto dest: list_all2_lengthD simp: min_def)"], ["proof (state)\nthis:\n  length Ts = n\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with Ts'"], ["proof (chain)\npicking this:\n  P \\<turnstile> Ts [\\<le>] Ts'\n  length Ts = n", "have [simp]: \"size Ts' = n\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Ts [\\<le>] Ts'\n  length Ts = n\n\ngoal (1 subgoal):\n 1. length Ts' = n", "by (auto dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  length Ts' = n\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from m_C' wfprog"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n             xt') in D''\n  wf_prog wfmb P", "obtain mD'': \"P \\<turnstile> D'' sees M':Ts'\\<rightarrow>T'=(mxs',mxl',ins',xt') in D''\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n             xt') in D''\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. (P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n                 xt') in D'' \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "by (fast dest: sees_method_idemp)"], ["proof (state)\nthis:\n  P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n              xt') in D''\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n              xt') in D''\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with wtprog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n              xt') in D''", "obtain start: \"wt_start P D'' Ts' mxl' (\\<Phi> D'' M')\" and ins': \"ins' \\<noteq> []\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n              xt') in D''\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>wt_start P D'' Ts' mxl' (\\<Phi> D'' M');\n      ins' \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: wt_jvm_prog_impl_wt_start)"], ["proof (state)\nthis:\n  wt_start P D'' Ts' mxl' (\\<Phi> D'' M')\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "then"], ["proof (chain)\npicking this:\n  wt_start P D'' Ts' mxl' (\\<Phi> D'' M')\n  ins' \\<noteq> []", "obtain LT\\<^sub>0 where LT\\<^sub>0: \"\\<Phi> D'' M' ! 0 = Some ([], LT\\<^sub>0)\""], ["proof (prove)\nusing this:\n  wt_start P D'' Ts' mxl' (\\<Phi> D'' M')\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>LT\\<^sub>0.\n        \\<Phi> D'' M' ! 0 =\n        \\<lfloor>([], LT\\<^sub>0)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp add: wt_start_def defs1 sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have \"conf_f P h ([], LT\\<^sub>0) ins' ?f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "let ?LT = \"OK (Class D'') # (map OK Ts') @ (replicate mxl' Err)\""], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "from stk"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST", "have \"P,h \\<turnstile> take n stk [:\\<le>] take n ST\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> take n stk [:\\<le>] take n ST", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "hence \"P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> take n stk [:\\<le>] take n ST\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] rev (take n ST)\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "note Ts"], ["proof (state)\nthis:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "also"], ["proof (state)\nthis:\n  P \\<turnstile> rev (take n ST) [\\<le>] Ts\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "note Ts'"], ["proof (state)\nthis:\n  P \\<turnstile> Ts [\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "finally"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] Ts'", "have \"P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>] Ts'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts'", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts'\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> rev (take n stk) [:\\<le>\\<^sub>\\<top>] map OK Ts'\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "have \"P,h \\<turnstile> replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> replicate mxl'\n                      undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "from m_C'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n             xt') in D''", "have \"P \\<turnstile> C' \\<preceq>\\<^sup>* D''\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n             xt') in D''\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' \\<preceq>\\<^sup>* D''", "by (rule sees_method_decl_above)"], ["proof (state)\nthis:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D''\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "with obj"], ["proof (chain)\npicking this:\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D''", "have \"P,h \\<turnstile> Addr a :\\<le> Class D''\""], ["proof (prove)\nusing this:\n  h a = \\<lfloor>(C', fs)\\<rfloor>\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D''\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr a :\\<le> Class D''", "by (simp add: conf_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr a :\\<le> Class D''\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] map OK Ts' @\n              replicate mxl' Err\n  P,h \\<turnstile> Addr a :\\<le> Class D''", "have \"P,h \\<turnstile> ?loc' [:\\<le>\\<^sub>\\<top>] ?LT\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> rev (take n stk) @\n                   replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] map OK Ts' @\n              replicate mxl' Err\n  P,h \\<turnstile> Addr a :\\<le> Class D''\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr a #\n                     rev (take n stk) @\n                     replicate mxl'\n                      undefined [:\\<le>\\<^sub>\\<top>] OK (Class D'') #\n                map OK Ts' @ replicate mxl' Err", "by simp"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] OK (Class D'') #\n              map OK Ts' @ replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "also"], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl'\n                    undefined [:\\<le>\\<^sub>\\<top>] OK (Class D'') #\n              map OK Ts' @ replicate mxl' Err\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "from start LT\\<^sub>0"], ["proof (chain)\npicking this:\n  wt_start P D'' Ts' mxl' (\\<Phi> D'' M')\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>", "have \"P \\<turnstile> \\<dots> [\\<le>\\<^sub>\\<top>] LT\\<^sub>0\""], ["proof (prove)\nusing this:\n  wt_start P D'' Ts' mxl' (\\<Phi> D'' M')\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (OK (Class D'') #\n                    map OK Ts' @\n                    replicate mxl' Err) [\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "by (simp add: wt_start_def)"], ["proof (state)\nthis:\n  P \\<turnstile> (OK (Class D'') #\n                  map OK Ts' @\n                  replicate mxl' Err) [\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "finally"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "have \"P,h \\<turnstile> ?loc' [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Addr a #\n                     rev (take n stk) @\n                     replicate mxl'\n                      undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0", "."], ["proof (state)\nthis:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "using ins'"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> Addr a #\n                   rev (take n stk) @\n                   replicate mxl' undefined [:\\<le>\\<^sub>\\<top>] LT\\<^sub>0\n  ins' \\<noteq> []\n\ngoal (1 subgoal):\n 1. conf_f P h ([], LT\\<^sub>0) ins'\n     ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "by simp"], ["proof (state)\nthis:\n  conf_f P h ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conf_f P h ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n              xt') in D''\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)", "have ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n              xt') in D''\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "using s' \\<Phi>_pc approx meth_C m_D T' ins D"], ["proof (prove)\nusing this:\n  P \\<turnstile> D'' sees M': Ts'\\<rightarrow>T' = (mxs', mxl', ins',\n              xt') in D''\n  \\<Phi> D'' M' ! 0 = \\<lfloor>([], LT\\<^sub>0)\\<rfloor>\n  conf_f P h ([], LT\\<^sub>0) ins'\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0)\n  \\<sigma>' =\n  (None, h,\n   ([], Addr a # rev (take n stk) @ replicate mxl' undefined, D'', M', 0) #\n   (stk, loc, C, M, pc) # frs)\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P \\<turnstile> D sees M': Ts\\<rightarrow>T = m in D'\n  subtype P T' T\n  ins ! pc = Invoke M' n\n  ST ! n = Class D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by (fastforce dest: sees_method_fun [of _ C])"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  \\<lbrakk>ST ! n \\<noteq> NT; stk ! n \\<noteq> Null\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  stk ! n = Null \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ST ! n = NT \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  \\<lbrakk>ST ! n \\<noteq> NT; stk ! n \\<noteq> Null\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  stk ! n = Null \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  ST ! n = NT \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  \\<lbrakk>ST ! n \\<noteq> NT; stk ! n \\<noteq> Null\\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by blast"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "declare list_all2_Cons2 [iff]"], ["", "lemma Return_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wt_prog: \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins: \"ins ! pc = Return\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs)\"\n  assumes correct: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wt_prog"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P", "obtain wfmb where wf: \"wf_prog wfmb P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. (\\<And>wfmb. wf_prog wfmb P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wf_jvm_prog_phi_def)"], ["proof (state)\nthis:\n  wf_prog wfmb P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from meth ins s'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)", "have \"frs = [] \\<Longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n\ngoal (1 subgoal):\n 1. frs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "by (simp add: correct_state_def)"], ["proof (state)\nthis:\n  frs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  frs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "{"], ["proof (state)\nthis:\n  frs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "fix f frs'"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "assume frs': \"frs = f#frs'\""], ["proof (state)\nthis:\n  frs = f # frs'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  frs = f # frs'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "obtain stk' loc' C' M' pc' where \n      f: \"f = (stk',loc',C',M',pc')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stk' loc' C' M' pc'.\n        f = (stk', loc', C', M', pc') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases f)"], ["proof (state)\nthis:\n  f = (stk', loc', C', M', pc')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  f = (stk', loc', C', M', pc')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note meth ins s'"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  frs = f # frs'\n  f = (stk', loc', C', M', pc')\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)", "have \\<sigma>':\n      \"\\<sigma>' = (None,h,(hd stk#(drop (1+size Ts) stk'),loc',C',M',pc'+1)#frs')\"\n      (is \"\\<sigma>' = (None,h,?f'#frs')\")"], ["proof (prove)\nusing this:\n  frs = f # frs'\n  f = (stk', loc', C', M', pc')\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  ins ! pc = Return\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h,\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1) # frs')", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h,\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1) # frs')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from correct meth"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C", "obtain ST LT where\n      h_ok:   \"P \\<turnstile> h \\<surd>\" and\n      \\<Phi>_pc: \"\\<Phi> C M ! pc = Some (ST, LT)\" and\n      frame:  \"conf_f P h (ST, LT) ins (stk,loc,C,M,pc)\" and\n      frames: \"conf_fs P h \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun simp add: correct_state_def)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \\<Phi>_pc ins wt"], ["proof (chain)\npicking this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = Return\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain U ST\\<^sub>0 where \"ST = U # ST\\<^sub>0\" \"P \\<turnstile> U \\<le> T\""], ["proof (prove)\nusing this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = Return\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>U ST\\<^sub>0.\n        \\<lbrakk>ST = U # ST\\<^sub>0; subtype P U T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wt_instr_def app_def) blast"], ["proof (state)\nthis:\n  ST = U # ST\\<^sub>0\n  subtype P U T\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with wf frame"], ["proof (chain)\npicking this:\n  wf_prog wfmb P\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  ST = U # ST\\<^sub>0\n  subtype P U T", "have hd_stk: \"P,h \\<turnstile> hd stk :\\<le> T\""], ["proof (prove)\nusing this:\n  wf_prog wfmb P\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  ST = U # ST\\<^sub>0\n  subtype P U T\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk :\\<le> T", "by (auto simp add: conf_f_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk :\\<le> T\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from f frs' frames"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc')\n  frs = f # frs'\n  conf_fs P h \\<Phi> M (length Ts) T frs", "obtain ST' LT' Ts'' T'' mxs' mxl\\<^sub>0' ins' xt' D Ts' T' m D' where\n      \\<Phi>': \"\\<Phi> C' M' ! pc' = Some (ST', LT')\" and\n      meth_C':  \"P \\<turnstile> C' sees M':Ts''\\<rightarrow>T''=(mxs',mxl\\<^sub>0',ins',xt') in C'\" and\n      ins': \"ins' ! pc' = Invoke M (size Ts)\" and\n      D: \"ST' ! (size Ts) = Class D\" and\n      meth_D: \"P \\<turnstile> D sees M: Ts'\\<rightarrow>T' = m in D'\" and\n      T': \"P \\<turnstile> T \\<le> T'\" and\n      frame':   \"conf_f P h (ST',LT') ins' f\" and\n      conf_fs:  \"conf_fs P h \\<Phi> M' (size Ts'') T'' frs'\""], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc')\n  frs = f # frs'\n  conf_fs P h \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT' Ts'' T'' mxs' mxl\\<^sub>0' ins' xt' D Ts' T' m D'.\n        \\<lbrakk>\\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> C' sees M': Ts''\\<rightarrow>T'' = (mxs',\n                      mxl\\<^sub>0', ins', xt') in C';\n         ins' ! pc' = Invoke M (length Ts); ST' ! length Ts = Class D;\n         P \\<turnstile> D sees M: Ts'\\<rightarrow>T' = m in D';\n         subtype P T T'; conf_f P h (ST', LT') ins' f;\n         conf_fs P h \\<Phi> M' (length Ts'') T'' frs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> C' sees M': Ts''\\<rightarrow>T'' = (mxs', mxl\\<^sub>0',\n               ins', xt') in C'\n  ins' ! pc' = Invoke M (length Ts)\n  ST' ! length Ts = Class D\n  P \\<turnstile> D sees M: Ts'\\<rightarrow>T' = m in D'\n  subtype P T T'\n  conf_f P h (ST', LT') ins' f\n  conf_fs P h \\<Phi> M' (length Ts'') T'' frs'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from f frame'"], ["proof (chain)\npicking this:\n  f = (stk', loc', C', M', pc')\n  conf_f P h (ST', LT') ins' f", "obtain\n      stk': \"P,h \\<turnstile> stk' [:\\<le>] ST'\" and\n      loc': \"P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\" and\n      pc':  \"pc' < size ins'\""], ["proof (prove)\nusing this:\n  f = (stk', loc', C', M', pc')\n  conf_f P h (ST', LT') ins' f\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,h \\<turnstile> stk' [:\\<le>] ST';\n      P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT';\n      pc' < length ins'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: conf_f_def)"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  pc' < length ins'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wt_prog meth_C' pc'"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C' sees M': Ts''\\<rightarrow>T'' = (mxs', mxl\\<^sub>0',\n               ins', xt') in C'\n  pc' < length ins'", "have \"P,T'',mxs',size ins',xt' \\<turnstile> ins'!pc',pc' :: \\<Phi> C' M'\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C' sees M': Ts''\\<rightarrow>T'' = (mxs', mxl\\<^sub>0',\n               ins', xt') in C'\n  pc' < length ins'\n\ngoal (1 subgoal):\n 1. P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'", "by (rule wt_jvm_prog_impl_wt_instr)"], ["proof (state)\nthis:\n  P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with ins' \\<Phi>' D meth_D"], ["proof (chain)\npicking this:\n  ins' ! pc' = Invoke M (length Ts)\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  ST' ! length Ts = Class D\n  P \\<turnstile> D sees M: Ts'\\<rightarrow>T' = m in D'\n  P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'", "obtain aTs ST'' LT'' where\n      \\<Phi>_suc:   \"\\<Phi> C' M' ! Suc pc' = Some (ST'', LT'')\" and\n      less:    \"P \\<turnstile> (T' # drop (size Ts+1) ST', LT') \\<le>\\<^sub>i (ST'', LT'')\" and\n      suc_pc': \"Suc pc' < size ins'\""], ["proof (prove)\nusing this:\n  ins' ! pc' = Invoke M (length Ts)\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  ST' ! length Ts = Class D\n  P \\<turnstile> D sees M: Ts'\\<rightarrow>T' = m in D'\n  P,T'',mxs',length ins',xt' \\<turnstile> ins' ! pc',pc' :: \\<Phi> C' M'\n\ngoal (1 subgoal):\n 1. (\\<And>ST'' LT''.\n        \\<lbrakk>\\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>;\n         P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                         LT') \\<le>\\<^sub>i (ST'', LT'');\n         Suc pc' < length ins'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp add: sup_state_opt_any_Some)"], ["proof (state)\nthis:\n  \\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')\n  Suc pc' < length ins'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from hd_stk T'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> hd stk :\\<le> T\n  subtype P T T'", "have hd_stk': \"P,h \\<turnstile> hd stk :\\<le> T'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> hd stk :\\<le> T\n  subtype P T T'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk :\\<le> T'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk :\\<le> T'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "have frame'':\n      \"conf_f P h (ST'',LT'') ins' ?f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "from stk'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'", "have \"P,h \\<turnstile> drop (1+size Ts) stk' [:\\<le>] drop (1+size Ts) ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> drop (1 + length Ts)\n                      stk' [:\\<le>] drop (1 + length Ts) ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "with hd_stk' less"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> hd stk :\\<le> T'\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'", "have \"P,h \\<turnstile> hd stk # drop (1+size Ts) stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> hd stk :\\<le> T'\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''", "by auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "from wf loc' less"], ["proof (chain)\npicking this:\n  wf_prog wfmb P\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')", "have \"P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\""], ["proof (prove)\nusing this:\n  wf_prog wfmb P\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> (T' # drop (length Ts + 1) ST',\n                  LT') \\<le>\\<^sub>i (ST'', LT'')\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''", "by auto"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "note suc_pc'"], ["proof (state)\nthis:\n  Suc pc' < length ins'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "ultimately"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n  P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n  Suc pc' < length ins'", "show ?thesis"], ["proof (prove)\nusing this:\n  P,h \\<turnstile> drop (1 + length Ts)\n                    stk' [:\\<le>] drop (1 + length Ts) ST'\n  P,h \\<turnstile> hd stk # drop (1 + length Ts) stk' [:\\<le>] ST''\n  P,h \\<turnstile> loc' [:\\<le>\\<^sub>\\<top>] LT''\n  Suc pc' < length ins'\n\ngoal (1 subgoal):\n 1. conf_f P h (ST'', LT'') ins'\n     (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "by (simp add: conf_f_def)"], ["proof (state)\nthis:\n  conf_f P h (ST'', LT'') ins'\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conf_f P h (ST'', LT'') ins'\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with \\<sigma>' frs' f meth h_ok hd_stk \\<Phi>_suc frames meth_C' \\<Phi>'"], ["proof (chain)\npicking this:\n  \\<sigma>' =\n  (None, h,\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1) # frs')\n  frs = f # frs'\n  f = (stk', loc', C', M', pc')\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile> hd stk :\\<le> T\n  \\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C' sees M': Ts''\\<rightarrow>T'' = (mxs', mxl\\<^sub>0',\n               ins', xt') in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  conf_f P h (ST'', LT'') ins'\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' =\n  (None, h,\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1) # frs')\n  frs = f # frs'\n  f = (stk', loc', C', M', pc')\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P \\<turnstile> h \\<surd>\n  P,h \\<turnstile> hd stk :\\<le> T\n  \\<Phi> C' M' ! Suc pc' = \\<lfloor>(ST'', LT'')\\<rfloor>\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C' sees M': Ts''\\<rightarrow>T'' = (mxs', mxl\\<^sub>0',\n               ins', xt') in C'\n  \\<Phi> C' M' ! pc' = \\<lfloor>(ST', LT')\\<rfloor>\n  conf_f P h (ST'', LT'') ins'\n   (hd stk # drop (1 + length Ts) stk', loc', C', M', pc' + 1)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by (fastforce dest: sees_method_fun [of _ C'])"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "}"], ["proof (state)\nthis:\n  frs = ?f2 # ?frs'2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  frs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  frs = ?f2 # ?frs'2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "show ?thesis"], ["proof (prove)\nusing this:\n  frs = [] \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n  frs = ?f2 # ?frs'2 \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by (cases frs) blast+"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "declare sup_state_opt_any_Some [iff]"], ["", "declare not_Err_eq [iff]"], ["", "lemma Load_correct:\n\"\\<lbrakk> wf_prog wt P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n    ins!pc = Load idx; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs); \n    P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk>\n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = Load idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "by (fastforce dest: sees_method_fun [of _ C] elim!: confTs_confT_sup)"], ["", "declare [[simproc del: list_to_set_comprehension]]"], ["", "lemma Store_correct:\n\"\\<lbrakk> wf_prog wt P;\n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C;\n  ins!pc = Store idx;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M;\n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs);\n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk>\n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = Store idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = Store idx;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ts ST LT z zs ab bb.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (zs, loc[idx := z], C, M, Suc pc) # frs);\n        wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        ins ! pc = Store idx; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Store idx) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        idx < length LT; Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT[idx := OK ts] [\\<le>\\<^sub>\\<top>] bb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                            P,h \\<turnstile> loc\n                            [idx := z] [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ts ST LT z zs ab bb.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (zs, loc[idx := z], C, M, Suc pc) # frs);\n        wf_prog wt P; ins ! pc = Store idx; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Store idx) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        idx < length LT; Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT[idx := OK ts] [\\<le>\\<^sub>\\<top>] bb;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                            P,h \\<turnstile> loc\n                            [idx := z] [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts ST LT z zs ab bb.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (zs, loc[idx := z], C, M, Suc pc) # frs);\n        wf_prog wt P; ins ! pc = Store idx; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        \\<forall>x\\<in>set (relevant_entries P (Store idx) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        idx < length LT; Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff (Store idx) P pc (ts # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT[idx := OK ts] [\\<le>\\<^sub>\\<top>] bb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                            P,h \\<turnstile> loc\n                            [idx := z] [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (blast intro!: list_all2_update_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Push_correct:\n\"\\<lbrakk> wf_prog wt P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n    ins!pc = Push v;\n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs);\n    P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk>\n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = Push v;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = Push v;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT y bb z zs.\n       \\<lbrakk>\\<sigma>' = (None, h, (v # stk, loc, C, M, Suc pc) # frs);\n        wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        ins ! pc = Push v; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Push v) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length ST \\<and> d < mxs);\n        Suc pc < length ins; length ST < mxs;\n        typeof v = \\<lfloor>y\\<rfloor>;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(z # zs, bb)\\<rfloor>;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb; subtype P y z;\n        P \\<turnstile> ST [\\<le>] zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> v :\\<le> z \\<and>\n                            P,h \\<turnstile> stk [:\\<le>] zs \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT y bb z zs.\n       \\<lbrakk>\\<sigma>' = (None, h, (v # stk, loc, C, M, Suc pc) # frs);\n        wf_prog wt P; ins ! pc = Push v; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P (Push v) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length ST \\<and> d < mxs);\n        Suc pc < length ins; length ST < mxs;\n        typeof v = \\<lfloor>y\\<rfloor>;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(z # zs, bb)\\<rfloor>;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb; subtype P y z;\n        P \\<turnstile> ST [\\<le>] zs;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> v :\\<le> z \\<and>\n                            P,h \\<turnstile> stk [:\\<le>] zs \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ST LT y bb z zs.\n       \\<lbrakk>\\<sigma>' = (None, h, (v # stk, loc, C, M, Suc pc) # frs);\n        wf_prog wt P; ins ! pc = Push v; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        conf_fs P h \\<Phi> M (length Ts) T frs;\n        \\<forall>x\\<in>set (relevant_entries P (Push v) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length ST \\<and> d < mxs);\n        Suc pc < length ins; length ST < mxs;\n        typeof v = \\<lfloor>y\\<rfloor>;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Push v) P pc (ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(z # zs, bb)\\<rfloor>;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb; subtype P y z;\n        P \\<turnstile> ST [\\<le>] zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> v :\\<le> z \\<and>\n                            P,h \\<turnstile> stk [:\\<le>] zs \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (blast dest: typeof_lit_conf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Cast_conf2:\n  \"\\<lbrakk> wf_prog ok P; P,h \\<turnstile> v :\\<le> T; is_refT T; cast_ok P C h v; \n     P \\<turnstile> Class C \\<le> T'; is_class P C\\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T; is_refT T;\n     cast_ok P C h v; subtype P (Class C) T'; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T; is_refT T;\n     cast_ok P C h v; subtype P (Class C) T'; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply (unfold cast_ok_def is_refT_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n     T = NT \\<or> (\\<exists>C. T = Class C);\n     v = Null \\<or>\n     P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n     subtype P (Class C) T'; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply (frule Class_widen)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n     T = NT \\<or> (\\<exists>C. T = Class C);\n     v = Null \\<or>\n     P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n     subtype P (Class C) T'; is_class P C; \\<exists>D. T' = Class D\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply (elim exE disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>D.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = NT;\n        v = Null\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\n 2. \\<And>D.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = NT;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\n 3. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        v = Null\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\n 4. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>D.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = NT;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\n 2. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        v = Null\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\n 3. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        v = Null\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\n 2. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D Ca.\n       \\<lbrakk>wf_prog ok P; P,h \\<turnstile> v :\\<le> T;\n        subtype P (Class C) T'; is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply (clarsimp simp add: conf_def obj_ty_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D Ca T'a.\n       \\<lbrakk>wf_prog ok P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'a\\<rfloor>;\n        subtype P T'a (Class Ca)\\<rbrakk>\n       \\<Longrightarrow> subtype P T'a (Class D)", "apply (cases v)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>D Ca T'a.\n       \\<lbrakk>wf_prog ok P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'a\\<rfloor>;\n        subtype P T'a (Class Ca); v = Unit\\<rbrakk>\n       \\<Longrightarrow> subtype P T'a (Class D)\n 2. \\<And>D Ca T'a.\n       \\<lbrakk>wf_prog ok P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'a\\<rfloor>;\n        subtype P T'a (Class Ca); v = Null\\<rbrakk>\n       \\<Longrightarrow> subtype P T'a (Class D)\n 3. \\<And>D Ca T'a x3.\n       \\<lbrakk>wf_prog ok P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'a\\<rfloor>;\n        subtype P T'a (Class Ca); v = Bool x3\\<rbrakk>\n       \\<Longrightarrow> subtype P T'a (Class D)\n 4. \\<And>D Ca T'a x4.\n       \\<lbrakk>wf_prog ok P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'a\\<rfloor>;\n        subtype P T'a (Class Ca); v = Intg x4\\<rbrakk>\n       \\<Longrightarrow> subtype P T'a (Class D)\n 5. \\<And>D Ca T'a x5.\n       \\<lbrakk>wf_prog ok P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        is_class P C; T' = Class D; T = Class Ca;\n        P \\<turnstile> cname_of h (the_Addr v) \\<preceq>\\<^sup>* C;\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'a\\<rfloor>;\n        subtype P T'a (Class Ca); v = Addr x5\\<rbrakk>\n       \\<Longrightarrow> subtype P T'a (Class D)", "apply (auto intro: rtrancl_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Checkcast_correct:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n    P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n    ins!pc = Checkcast D; \n    P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n    Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n    P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n    fst (exec_instr (ins!pc) P h stk loc C M pc frs) = None \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = Checkcast D;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = Checkcast D;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (clarsimp simp add: wf_jvm_prog_phi_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ba Taa ST baa z zs za zsa.\n       \\<lbrakk>wf_prog\n                 (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n                     wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                      (\\<Phi> C M))\n                 P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        ins ! pc = Checkcast D; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, ba)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] ba; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<sigma>' = (None, h, (z # zs, loc, C, M, Suc pc) # frs);\n        \\<forall>x\\<in>set (relevant_entries P (Checkcast D) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        is_class P D; is_refT Taa;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(za # zsa, baa)\\<rfloor>;\n        cast_ok P D h z; P \\<turnstile> ba [\\<le>\\<^sub>\\<top>] baa;\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST; subtype P (Class D) za;\n        P \\<turnstile> ST [\\<le>] zsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> z :\\<le> za \\<and>\n                            P,h \\<turnstile> zs [:\\<le>] zsa \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] baa \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ba Taa ST baa z zs za zsa.\n       \\<lbrakk>wf_prog\n                 (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n                     wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                      (\\<Phi> C M))\n                 P;\n        ins ! pc = Checkcast D; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Taa # ST, ba)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] ba; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<sigma>' = (None, h, (z # zs, loc, C, M, Suc pc) # frs);\n        \\<forall>x\\<in>set (relevant_entries P (Checkcast D) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Checkcast D) P pc (Taa # ST, ba) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        is_class P D; is_refT Taa;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(za # zsa, baa)\\<rfloor>;\n        cast_ok P D h z; P \\<turnstile> ba [\\<le>\\<^sub>\\<top>] baa;\n        stk = z # zs; P,h \\<turnstile> z :\\<le> Taa;\n        P,h \\<turnstile> zs [:\\<le>] ST; subtype P (Class D) za;\n        P \\<turnstile> ST [\\<le>] zsa;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> z :\\<le> za \\<and>\n                            P,h \\<turnstile> zs [:\\<le>] zsa \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] baa \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (blast intro: Cast_conf2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "declare split_paired_All [simp del]"], ["", "lemmas widens_Cons [iff] = list_all2_Cons1 [of \"widen P\"] for P"], ["", "lemma Getfield_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Getfield F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes xc: \"fst (exec_instr (ins!pc) P h stk loc C M pc frs) = None\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]", "obtain ST LT where    \n    \"h\\<surd>\": \"P \\<turnstile> h \\<surd>\" and\n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    fs: \"conf_fs P h \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_fs P h \\<Phi> M (length Ts) T frs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i \\<Phi> wt"], ["proof (chain)\npicking this:\n  ins ! pc = Getfield F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain oT ST'' vT ST' LT' vT' where \n    oT: \"P \\<turnstile> oT \\<le> Class D\" and\n    ST: \"ST = oT # ST''\" and\n    F:  \"P \\<turnstile> D sees F:vT in D\" and\n    pc': \"pc+1 < size ins\"  and\n    \\<Phi>': \"\\<Phi> C M ! (pc+1) = Some (vT'#ST', LT')\" and\n    ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\" and  \n    vT': \"P \\<turnstile> vT \\<le> vT'\""], ["proof (prove)\nusing this:\n  ins ! pc = Getfield F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>oT ST'' vT vT' ST' LT'.\n        \\<lbrakk>subtype P oT (Class D); ST = oT # ST'';\n         P \\<turnstile> D sees F:vT in D; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT';\n         subtype P vT vT'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  subtype P oT (Class D)\n  ST = oT # ST''\n  P \\<turnstile> D sees F:vT in D\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n  subtype P vT vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = oT # ST''", "obtain ref stk' where \n    stk': \"stk = ref#stk'\" and\n    ref:  \"P,h \\<turnstile> ref :\\<le> oT\" and\n    ST'': \"P,h \\<turnstile> stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = oT # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>ref stk'.\n        \\<lbrakk>stk = ref # stk'; P,h \\<turnstile> ref :\\<le> oT;\n         P,h \\<turnstile> stk' [:\\<le>] ST''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = ref # stk'\n  P,h \\<turnstile> ref :\\<le> oT\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk' i mC s' xc"], ["proof (chain)\npicking this:\n  stk = ref # stk'\n  ins ! pc = Getfield F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None", "have \"ref \\<noteq> Null\""], ["proof (prove)\nusing this:\n  stk = ref # stk'\n  ins ! pc = Getfield F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null", "by (simp add: split_beta split:if_split_asm)"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ref oT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> oT\n  subtype P oT (Class D)", "have \"P,h \\<turnstile> ref :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> oT\n  subtype P oT (Class D)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> ref :\\<le> Class D", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D", "obtain a D' fs where \n    a: \"ref = Addr a\" and h: \"h a = Some (D', fs)\" and D': \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>a D' fs.\n        \\<lbrakk>ref = Addr a; h a = \\<lfloor>(D', fs)\\<rfloor>;\n         P \\<turnstile> D' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: non_npD)"], ["proof (state)\nthis:\n  ref = Addr a\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from D' F"], ["proof (chain)\npicking this:\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  P \\<turnstile> D sees F:vT in D", "have has_field: \"P \\<turnstile> D' has F:vT in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n  P \\<turnstile> D sees F:vT in D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F:vT in D", "by (blast intro: has_field_mono has_visible_field)"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F:vT in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F:vT in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \"h\\<surd>\" h"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>\n  h a = \\<lfloor>(D', fs)\\<rfloor>", "have \"P,h \\<turnstile> (D', fs) \\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> (D', fs) \\<surd>", "by (rule hconfD)"], ["proof (state)\nthis:\n  P,h \\<turnstile> (D', fs) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> D' has F:vT in D\n  P,h \\<turnstile> (D', fs) \\<surd>", "obtain v where v: \"fs (F, D) = Some v\" \"P,h \\<turnstile> v :\\<le> vT\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D' has F:vT in D\n  P,h \\<turnstile> (D', fs) \\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>fs (F, D) = \\<lfloor>v\\<rfloor>;\n         P,h \\<turnstile> v :\\<le> vT\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp add: oconf_def has_field_def)        \n       (blast dest: has_fields_fun)"], ["proof (state)\nthis:\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from a h i mC s' stk' v"], ["proof (chain)\npicking this:\n  ref = Addr a\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  ins ! pc = Getfield F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  stk = ref # stk'\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT", "have \"\\<sigma>' = (None, h, (v#stk',loc,C,M,pc+1)#frs)\""], ["proof (prove)\nusing this:\n  ref = Addr a\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  ins ! pc = Getfield F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  stk = ref # stk'\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n\ngoal (1 subgoal):\n 1. \\<sigma>' = (None, h, (v # stk', loc, C, M, pc + 1) # frs)", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (v # stk', loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' = (None, h, (v # stk', loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ST'' ST'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'", "have \"P,h \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk' [:\\<le>] ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from v vT'"], ["proof (chain)\npicking this:\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  subtype P vT vT'", "have \"P,h \\<turnstile> v :\\<le> vT'\""], ["proof (prove)\nusing this:\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  subtype P vT vT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> vT'", "by blast"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from loc LT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note \"h\\<surd>\" mC \\<Phi>' pc' v fs"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  conf_fs P h \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' = (None, h, (v # stk', loc, C, M, pc + 1) # frs)\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> v :\\<le> vT'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> h \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  conf_fs P h \\<Phi> M (length Ts) T frs", "show \"P,\\<Phi> \\<turnstile> \\<sigma>' \\<surd>\""], ["proof (prove)\nusing this:\n  \\<sigma>' = (None, h, (v # stk', loc, C, M, pc + 1) # frs)\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  P,h \\<turnstile> v :\\<le> vT'\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  P \\<turnstile> h \\<surd>\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(vT' # ST', LT')\\<rfloor>\n  pc + 1 < length ins\n  fs (F, D) = \\<lfloor>v\\<rfloor>\n  P,h \\<turnstile> v :\\<le> vT\n  conf_fs P h \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma Putfield_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf: \"wf_prog wt P\"\n  assumes mC: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes i:  \"ins!pc = Putfield F D\"\n  assumes wt: \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes s': \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs)\"\n  assumes cf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes xc: \"fst (exec_instr (ins!pc) P h stk loc C M pc frs) = None\"\n\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from mC cf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]", "obtain ST LT where    \n    \"h\\<surd>\": \"P \\<turnstile> h \\<surd>\" and    \n    \\<Phi>: \"\\<Phi> C M ! pc = Some (ST,LT)\" and\n    stk: \"P,h \\<turnstile> stk [:\\<le>] ST\" and loc: \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\" and\n    pc: \"pc < size ins\" and \n    fs: \"conf_fs P h \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         P,h \\<turnstile> stk [:\\<le>] ST;\n         P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length ins;\n         conf_fs P h \\<Phi> M (length Ts) T frs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,h \\<turnstile> stk [:\\<le>] ST\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  pc < length ins\n  conf_fs P h \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from i \\<Phi> wt"], ["proof (chain)\npicking this:\n  ins ! pc = Putfield F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain vT vT' oT ST'' ST' LT' where \n    ST: \"ST = vT # oT # ST''\" and\n    field: \"P \\<turnstile> D sees F:vT' in D\" and\n    oT: \"P \\<turnstile> oT \\<le> Class D\" and vT: \"P \\<turnstile> vT \\<le> vT'\" and\n    pc': \"pc+1 < size ins\" and \n    \\<Phi>': \"\\<Phi> C M!(pc+1) = Some (ST',LT')\" and\n    ST': \"P \\<turnstile> ST'' [\\<le>] ST'\" and LT': \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  ins ! pc = Putfield F D\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>vT oT ST'' vT' ST' LT'.\n        \\<lbrakk>ST = vT # oT # ST''; P \\<turnstile> D sees F:vT' in D;\n         subtype P oT (Class D); subtype P vT vT'; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> ST'' [\\<le>] ST';\n         P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  ST = vT # oT # ST''\n  P \\<turnstile> D sees F:vT' in D\n  subtype P oT (Class D)\n  subtype P vT vT'\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> ST'' [\\<le>] ST'\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk ST"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = vT # oT # ST''", "obtain v ref stk' where \n    stk': \"stk = v#ref#stk'\" and\n    v:    \"P,h \\<turnstile> v :\\<le> vT\" and \n    ref:  \"P,h \\<turnstile> ref :\\<le> oT\" and\n    ST'': \"P,h \\<turnstile> stk' [:\\<le>] ST''\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk [:\\<le>] ST\n  ST = vT # oT # ST''\n\ngoal (1 subgoal):\n 1. (\\<And>v ref stk'.\n        \\<lbrakk>stk = v # ref # stk'; P,h \\<turnstile> v :\\<le> vT;\n         P,h \\<turnstile> ref :\\<le> oT;\n         P,h \\<turnstile> stk' [:\\<le>] ST''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stk = v # ref # stk'\n  P,h \\<turnstile> v :\\<le> vT\n  P,h \\<turnstile> ref :\\<le> oT\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from stk' i mC s' xc"], ["proof (chain)\npicking this:\n  stk = v # ref # stk'\n  ins ! pc = Putfield F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None", "have \"ref \\<noteq> Null\""], ["proof (prove)\nusing this:\n  stk = v # ref # stk'\n  ins ! pc = Putfield F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\n\ngoal (1 subgoal):\n 1. ref \\<noteq> Null", "by (auto simp add: split_beta)"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  ref \\<noteq> Null\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ref oT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> ref :\\<le> oT\n  subtype P oT (Class D)", "have \"P,h \\<turnstile> ref :\\<le> Class D\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> ref :\\<le> oT\n  subtype P oT (Class D)\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> ref :\\<le> Class D", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D", "obtain a D' fs where \n    a: \"ref = Addr a\" and h: \"h a = Some (D', fs)\" and D': \"P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  ref \\<noteq> Null\n  P,h \\<turnstile> ref :\\<le> Class D\n\ngoal (1 subgoal):\n 1. (\\<And>a D' fs.\n        \\<lbrakk>ref = Addr a; h a = \\<lfloor>(D', fs)\\<rfloor>;\n         P \\<turnstile> D' \\<preceq>\\<^sup>* D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: non_npD)"], ["proof (state)\nthis:\n  ref = Addr a\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from v vT"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> v :\\<le> vT\n  subtype P vT vT'", "have vT': \"P,h \\<turnstile> v :\\<le> vT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> v :\\<le> vT\n  subtype P vT vT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> vT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> v :\\<le> vT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from field D'"], ["proof (chain)\npicking this:\n  P \\<turnstile> D sees F:vT' in D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D", "have has_field: \"P \\<turnstile> D' has F:vT' in D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D sees F:vT' in D\n  P \\<turnstile> D' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D' has F:vT' in D", "by (blast intro: has_field_mono has_visible_field)"], ["proof (state)\nthis:\n  P \\<turnstile> D' has F:vT' in D\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "let ?h' = \"h(a\\<mapsto>(D', fs((F, D)\\<mapsto>v)))\" and ?f' = \"(stk',loc,C,M,pc+1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from h"], ["proof (chain)\npicking this:\n  h a = \\<lfloor>(D', fs)\\<rfloor>", "have hext: \"h \\<unlhd> ?h'\""], ["proof (prove)\nusing this:\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))", "by (rule hext_upd_obj)"], ["proof (state)\nthis:\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from a h i mC s' stk'"], ["proof (chain)\npicking this:\n  ref = Addr a\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  ins ! pc = Putfield F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  stk = v # ref # stk'", "have \"\\<sigma>' = (None, ?h', ?f'#frs)\""], ["proof (prove)\nusing this:\n  ref = Addr a\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  ins ! pc = Putfield F D\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  stk = v # ref # stk'\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))),\n     (stk', loc, C, M, pc + 1) # frs)", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))),\n   (stk', loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))),\n   (stk', loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \"h\\<surd>\" h"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>\n  h a = \\<lfloor>(D', fs)\\<rfloor>", "have \"P,h \\<turnstile> (D',fs)\\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> (D', fs) \\<surd>", "by (rule hconfD)"], ["proof (state)\nthis:\n  P,h \\<turnstile> (D', fs) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with has_field vT'"], ["proof (chain)\npicking this:\n  P \\<turnstile> D' has F:vT' in D\n  P,h \\<turnstile> v :\\<le> vT'\n  P,h \\<turnstile> (D', fs) \\<surd>", "have \"P,h \\<turnstile> (D',fs((F, D)\\<mapsto>v))\\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D' has F:vT' in D\n  P,h \\<turnstile> v :\\<le> vT'\n  P,h \\<turnstile> (D', fs) \\<surd>\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> (D', fs((F, D) \\<mapsto> v)) \\<surd>", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> (D', fs((F, D) \\<mapsto> v)) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with \"h\\<surd>\" h"], ["proof (chain)\npicking this:\n  P \\<turnstile> h \\<surd>\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  P,h \\<turnstile> (D', fs((F, D) \\<mapsto> v)) \\<surd>", "have \"P \\<turnstile> ?h'\\<surd>\""], ["proof (prove)\nusing this:\n  P \\<turnstile> h \\<surd>\n  h a = \\<lfloor>(D', fs)\\<rfloor>\n  P,h \\<turnstile> (D', fs((F, D) \\<mapsto> v)) \\<surd>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))) \\<surd>", "by (rule hconf_upd_obj)"], ["proof (state)\nthis:\n  P \\<turnstile> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ST'' ST'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'", "have \"P,h \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST''\n  P \\<turnstile> ST'' [\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> stk' [:\\<le>] ST'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from this hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))", "have \"P,?h' \\<turnstile> stk' [:\\<le>] ST'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> stk' [:\\<le>] ST'\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))\n\ngoal (1 subgoal):\n 1. P,h(a \\<mapsto>\n    (D', fs((F, D) \\<mapsto> v))) \\<turnstile> stk' [:\\<le>] ST'", "by (rule confs_hext)"], ["proof (state)\nthis:\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> stk' [:\\<le>] ST'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from loc LT'"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'", "have \"P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT\n  P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", ".."], ["proof (state)\nthis:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from this hext"], ["proof (chain)\npicking this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))", "have \"P,?h' \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\""], ["proof (prove)\nusing this:\n  P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))\n\ngoal (1 subgoal):\n 1. P,h(a \\<mapsto>\n    (D', fs((F, D) \\<mapsto> v))) \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "by (rule confTs_hext)"], ["proof (state)\nthis:\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from fs hext"], ["proof (chain)\npicking this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))", "have \"conf_fs P ?h' \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))\n\ngoal (1 subgoal):\n 1. conf_fs P (h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))) \\<Phi> M\n     (length Ts) T frs", "by (rule conf_fs_hext)"], ["proof (state)\nthis:\n  conf_fs P (h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))) \\<Phi> M\n   (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_fs P (h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))) \\<Phi> M\n   (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "note mC \\<Phi>' pc'"], ["proof (state)\nthis:\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' =\n  (None, h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))),\n   (stk', loc, C, M, pc + 1) # frs)\n  P \\<turnstile> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))) \\<surd>\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> stk' [:\\<le>] ST'\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P (h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))) \\<Phi> M\n   (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins", "show \"P,\\<Phi> \\<turnstile> \\<sigma>' \\<surd>\""], ["proof (prove)\nusing this:\n  \\<sigma>' =\n  (None, h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))),\n   (stk', loc, C, M, pc + 1) # frs)\n  P \\<turnstile> h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v))) \\<surd>\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> stk' [:\\<le>] ST'\n  P,h(a \\<mapsto>\n  (D', fs((F, D) \\<mapsto> v))) \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'\n  conf_fs P (h(a \\<mapsto> (D', fs((F, D) \\<mapsto> v)))) \\<Phi> M\n   (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  pc + 1 < length ins\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)\n  \n(* FIXME: move *)"], ["", "lemma has_fields_b_fields: \n  \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs", "apply (unfold fields_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    (THE FDTs. P \\<turnstile> C has_fields FDTs) = FDTs", "apply (blast intro: the_equality has_fields_fun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n  \n(* FIXME: move *)"], ["", "lemma oconf_blank [intro, simp]:\n    \"\\<lbrakk>is_class P C; wf_prog wt P\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> blank P C \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_class P C; wf_prog wt P\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> blank P C \\<surd>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_class P C; wf_prog wt P\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> blank P C \\<surd>", "by (fastforce simp add: blank_def has_fields_b_fields oconf_init_fields\n               dest: wf_Fields_Ex)"], ["", "(*>*)"], ["", "lemma obj_ty_blank [iff]: \"obj_ty (blank P C) = Class C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_ty (blank P C) = Class C", "by (simp add: blank_def)"], ["", "lemma New_correct:\n  fixes \\<sigma>' :: jvm_state\n  assumes wf:   \"wf_prog wt P\"\n  assumes meth: \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C\"\n  assumes ins:  \"ins!pc = New X\"\n  assumes wt:   \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\"\n  assumes exec: \"Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs)\"\n  assumes conf: \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>\"\n  assumes no_x: \"fst (exec_instr (ins!pc) P h stk loc C M pc frs) = None\"\n  shows \"P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins conf meth"], ["proof (chain)\npicking this:\n  ins ! pc = New X\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C", "obtain ST LT where\n    heap_ok: \"P\\<turnstile> h\\<surd>\" and\n    \\<Phi>_pc:    \"\\<Phi> C M!pc = Some (ST,LT)\" and\n    frame:   \"conf_f P h (ST,LT) ins (stk,loc,C,M,pc)\" and\n    frames:  \"conf_fs P h \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  ins ! pc = New X\n  P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n\ngoal (1 subgoal):\n 1. (\\<And>ST LT.\n        \\<lbrakk>P \\<turnstile> h \\<surd>;\n         \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>;\n         conf_f P h (ST, LT) ins (stk, loc, C, M, pc);\n         conf_fs P h \\<Phi> M (length Ts) T frs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: sees_method_fun)"], ["proof (state)\nthis:\n  P \\<turnstile> h \\<surd>\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  conf_fs P h \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from \\<Phi>_pc ins wt"], ["proof (chain)\npicking this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = New X\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "obtain ST' LT' where\n    is_class_X: \"is_class P X\" and\n    mxs:       \"size ST < mxs\" and\n    suc_pc:     \"pc+1 < size ins\" and\n    \\<Phi>_suc:      \"\\<Phi> C M!(pc+1) = Some (ST', LT')\" and\n    less:       \"P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\""], ["proof (prove)\nusing this:\n  \\<Phi> C M ! pc = \\<lfloor>(ST, LT)\\<rfloor>\n  ins ! pc = New X\n  P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n\ngoal (1 subgoal):\n 1. (\\<And>ST' LT'.\n        \\<lbrakk>is_class P X; length ST < mxs; pc + 1 < length ins;\n         \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>;\n         P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_class P X\n  length ST < mxs\n  pc + 1 < length ins\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n  P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from ins no_x"], ["proof (chain)\npicking this:\n  ins ! pc = New X\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None", "obtain oref where new_Addr: \"new_Addr h = Some oref\""], ["proof (prove)\nusing this:\n  ins ! pc = New X\n  fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\n\ngoal (1 subgoal):\n 1. (\\<And>oref.\n        new_Addr h = \\<lfloor>oref\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  new_Addr h = \\<lfloor>oref\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "hence h: \"h oref = None\""], ["proof (prove)\nusing this:\n  new_Addr h = \\<lfloor>oref\\<rfloor>\n\ngoal (1 subgoal):\n 1. h oref = None", "by (rule new_Addr_SomeD)"], ["proof (state)\nthis:\n  h oref = None\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with exec ins meth new_Addr"], ["proof (chain)\npicking this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  ins ! pc = New X\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  new_Addr h = \\<lfloor>oref\\<rfloor>\n  h oref = None", "have \\<sigma>':\n    \"\\<sigma>' = (None, h(oref \\<mapsto> blank P X), (Addr oref#stk,loc,C,M,pc+1)#frs)\"\n    (is \"\\<sigma>' = (None, ?h', ?f # frs)\")"], ["proof (prove)\nusing this:\n  \\<lfloor>\\<sigma>'\\<rfloor> =\n  exec (P, None, h, (stk, loc, C, M, pc) # frs)\n  ins ! pc = New X\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  new_Addr h = \\<lfloor>oref\\<rfloor>\n  h oref = None\n\ngoal (1 subgoal):\n 1. \\<sigma>' =\n    (None, h(oref \\<mapsto> blank P X),\n     (Addr oref # stk, loc, C, M, pc + 1) # frs)", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h(oref \\<mapsto> blank P X),\n   (Addr oref # stk, loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' =\n  (None, h(oref \\<mapsto> blank P X),\n   (Addr oref # stk, loc, C, M, pc + 1) # frs)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from wf h heap_ok is_class_X"], ["proof (chain)\npicking this:\n  wf_prog wt P\n  h oref = None\n  P \\<turnstile> h \\<surd>\n  is_class P X", "have h': \"P \\<turnstile> ?h' \\<surd>\""], ["proof (prove)\nusing this:\n  wf_prog wt P\n  h oref = None\n  P \\<turnstile> h \\<surd>\n  is_class P X\n\ngoal (1 subgoal):\n 1. P \\<turnstile> h(oref \\<mapsto> blank P X) \\<surd>", "by (auto intro: hconf_new)"], ["proof (state)\nthis:\n  P \\<turnstile> h(oref \\<mapsto> blank P X) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> h(oref \\<mapsto> blank P X) \\<surd>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from h frame less suc_pc wf"], ["proof (chain)\npicking this:\n  h oref = None\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\n  pc + 1 < length ins\n  wf_prog wt P", "have \"conf_f P ?h' (ST', LT') ins ?f\""], ["proof (prove)\nusing this:\n  h oref = None\n  conf_f P h (ST, LT) ins (stk, loc, C, M, pc)\n  P \\<turnstile> (Class X # ST, LT) \\<le>\\<^sub>i (ST', LT')\n  pc + 1 < length ins\n  wf_prog wt P\n\ngoal (1 subgoal):\n 1. conf_f P (h(oref \\<mapsto> blank P X)) (ST', LT') ins\n     (Addr oref # stk, loc, C, M, pc + 1)", "apply (clarsimp simp add: fun_upd_apply conf_def blank_def split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z zs.\n       \\<lbrakk>h oref = None; Suc pc < length ins; wf_prog wt P;\n        P,h \\<turnstile> stk [:\\<le>] ST;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT'; ST' = z # zs;\n        subtype P (Class X) z; P \\<turnstile> ST [\\<le>] zs\\<rbrakk>\n       \\<Longrightarrow> P,h(oref \\<mapsto>\n                         (X, init_fields\n                              (fields P\n                                X))) \\<turnstile> stk [:\\<le>] zs \\<and>\n                         P,h(oref \\<mapsto>\n                         (X, init_fields\n                              (fields P\n                                X))) \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT'", "apply (auto intro: confs_hext confTs_hext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  conf_f P (h(oref \\<mapsto> blank P X)) (ST', LT') ins\n   (Addr oref # stk, loc, C, M, pc + 1)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "moreover"], ["proof (state)\nthis:\n  conf_f P (h(oref \\<mapsto> blank P X)) (ST', LT') ins\n   (Addr oref # stk, loc, C, M, pc + 1)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "from h"], ["proof (chain)\npicking this:\n  h oref = None", "have \"h \\<unlhd> ?h'\""], ["proof (prove)\nusing this:\n  h oref = None\n\ngoal (1 subgoal):\n 1. h \\<unlhd> h(oref \\<mapsto> blank P X)", "by simp"], ["proof (state)\nthis:\n  h \\<unlhd> h(oref \\<mapsto> blank P X)\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "with frames"], ["proof (chain)\npicking this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h(oref \\<mapsto> blank P X)", "have \"conf_fs P ?h' \\<Phi> M (size Ts) T frs\""], ["proof (prove)\nusing this:\n  conf_fs P h \\<Phi> M (length Ts) T frs\n  h \\<unlhd> h(oref \\<mapsto> blank P X)\n\ngoal (1 subgoal):\n 1. conf_fs P (h(oref \\<mapsto> blank P X)) \\<Phi> M (length Ts) T frs", "by (rule conf_fs_hext)"], ["proof (state)\nthis:\n  conf_fs P (h(oref \\<mapsto> blank P X)) \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' =\n  (None, h(oref \\<mapsto> blank P X),\n   (Addr oref # stk, loc, C, M, pc + 1) # frs)\n  P \\<turnstile> h(oref \\<mapsto> blank P X) \\<surd>\n  conf_f P (h(oref \\<mapsto> blank P X)) (ST', LT') ins\n   (Addr oref # stk, loc, C, M, pc + 1)\n  conf_fs P (h(oref \\<mapsto> blank P X)) \\<Phi> M (length Ts) T frs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' =\n  (None, h(oref \\<mapsto> blank P X),\n   (Addr oref # stk, loc, C, M, pc + 1) # frs)\n  P \\<turnstile> h(oref \\<mapsto> blank P X) \\<surd>\n  conf_f P (h(oref \\<mapsto> blank P X)) (ST', LT') ins\n   (Addr oref # stk, loc, C, M, pc + 1)\n  conf_fs P (h(oref \\<mapsto> blank P X)) \\<Phi> M (length Ts) T frs\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "using meth \\<Phi>_suc"], ["proof (prove)\nusing this:\n  \\<sigma>' =\n  (None, h(oref \\<mapsto> blank P X),\n   (Addr oref # stk, loc, C, M, pc + 1) # frs)\n  P \\<turnstile> h(oref \\<mapsto> blank P X) \\<surd>\n  conf_f P (h(oref \\<mapsto> blank P X)) (ST', LT') ins\n   (Addr oref # stk, loc, C, M, pc + 1)\n  conf_fs P (h(oref \\<mapsto> blank P X)) \\<Phi> M (length Ts) T frs\n  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n         xt) in C\n  \\<Phi> C M ! (pc + 1) = \\<lfloor>(ST', LT')\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma>' [ok]", "by fastforce"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma>' [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma Goto_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = Goto branch; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = Goto branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = Goto branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b Tsa Ta mxsa mxl\\<^sub>0' is xta ab bb.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (stk, loc, C, M, nat (int pc + branch)) # frs);\n        wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        ins ! pc = Goto branch; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(a, b)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] a;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs; 0 \\<le> int pc + branch;\n        \\<forall>x\\<in>set (relevant_entries P (Goto branch) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length a \\<and> d < mxs);\n        nat (int pc + branch) < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Goto branch) P pc (a, b) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Goto branch) P pc (a, b) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! nat (int pc + branch) = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> a [\\<le>] ab;\n        P \\<turnstile> b [\\<le>\\<^sub>\\<top>] bb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> stk [:\\<le>] ab \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            nat (int pc + branch) < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b Tsa Ta mxsa mxl\\<^sub>0' is xta ab bb.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (stk, loc, C, M, nat (int pc + branch)) # frs);\n        wf_prog wt P; ins ! pc = Goto branch; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(a, b)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] a;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs; 0 \\<le> int pc + branch;\n        \\<forall>x\\<in>set (relevant_entries P (Goto branch) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> length a \\<and> d < mxs);\n        nat (int pc + branch) < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Goto branch) P pc (a, b) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (Goto branch) P pc (a, b) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! nat (int pc + branch) = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> a [\\<le>] ab;\n        P \\<turnstile> b [\\<le>\\<^sub>\\<top>] bb;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> stk [:\\<le>] ab \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            nat (int pc + branch) < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma IfFalse_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = IfFalse branch; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = IfFalse branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = IfFalse branch;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT z zs ab bb ac bc.\n       \\<lbrakk>\\<sigma>' =\n                (None, h,\n                 (zs, loc, C, M,\n                  if z = Bool False then nat (int pc + branch)\n                  else pc + 1) #\n                 frs);\n        wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        ins ! pc = IfFalse branch; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Boolean # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs; 0 \\<le> int pc + branch;\n        \\<forall>x\\<in>set (relevant_entries P (IfFalse branch) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        stk = z # zs; Suc pc < length ins;\n        P,h \\<turnstile> z :\\<le> Boolean; P,h \\<turnstile> zs [:\\<le>] ST;\n        nat (int pc + branch) < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (IfFalse branch) P pc\n                             (Boolean # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (IfFalse branch) P pc\n                             (Boolean # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        \\<Phi> C M ! nat (int pc + branch) = \\<lfloor>(ac, bc)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] ac;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bc\\<rbrakk>\n       \\<Longrightarrow> (z = Bool False \\<longrightarrow>\n                          (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n   mxl\\<^sub>0, is, xt) in C) \\<and>\n                              P,h \\<turnstile> zs [:\\<le>] ac \\<and>\n                              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bc \\<and>\n                              nat (int pc + branch) < length is \\<and>\n                              conf_fs P h \\<Phi> M (length Ts) T\n                               frs)) \\<and>\n                         (z \\<noteq> Bool False \\<longrightarrow>\n                          (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n   mxl\\<^sub>0, is, xt) in C) \\<and>\n                              P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                              Suc pc < length is \\<and>\n                              conf_fs P h \\<Phi> M (length Ts) T frs))", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT z zs ab bb ac bc.\n       \\<lbrakk>\\<sigma>' =\n                (None, h,\n                 (zs, loc, C, M,\n                  if z = Bool False then nat (int pc + branch)\n                  else pc + 1) #\n                 frs);\n        wf_prog wt P; ins ! pc = IfFalse branch; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Boolean # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs; 0 \\<le> int pc + branch;\n        \\<forall>x\\<in>set (relevant_entries P (IfFalse branch) pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        stk = z # zs; Suc pc < length ins;\n        P,h \\<turnstile> z :\\<le> Boolean; P,h \\<turnstile> zs [:\\<le>] ST;\n        nat (int pc + branch) < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (IfFalse branch) P pc\n                             (Boolean # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff (IfFalse branch) P pc\n                             (Boolean # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        \\<Phi> C M ! nat (int pc + branch) = \\<lfloor>(ac, bc)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] ac;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bc;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> (z = Bool False \\<longrightarrow>\n                          (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n   mxl\\<^sub>0, is, xt) in C) \\<and>\n                              P,h \\<turnstile> zs [:\\<le>] ac \\<and>\n                              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bc \\<and>\n                              nat (int pc + branch) < length is \\<and>\n                              conf_fs P h \\<Phi> M (length Ts) T\n                               frs)) \\<and>\n                         (z \\<noteq> Bool False \\<longrightarrow>\n                          (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                              (\\<exists>xt.\n                                  P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n   mxl\\<^sub>0, is, xt) in C) \\<and>\n                              P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                              P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                              Suc pc < length is \\<and>\n                              conf_fs P h \\<Phi> M (length Ts) T frs))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma CmpEq_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = CmpEq;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = CmpEq;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = CmpEq;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta T\\<^sub>1 T\\<^sub>2 ST LT z bb za\n       zsa zs.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (Bool (za = z) # zsa, loc, C, M, Suc pc) # frs);\n        wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        ins ! pc = CmpEq; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc =\n        \\<lfloor>(T\\<^sub>1 # T\\<^sub>2 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P CmpEq pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        \\<not> is_refT T\\<^sub>1 \\<and> T\\<^sub>2 = T\\<^sub>1 \\<or>\n        is_refT T\\<^sub>1 \\<and> is_refT T\\<^sub>2;\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff CmpEq P pc\n                             (T\\<^sub>1 # T\\<^sub>2 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        stk = z # za # zsa;\n        \\<forall>x\\<in>set (xcpt_eff CmpEq P pc\n                             (T\\<^sub>1 # T\\<^sub>2 # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        P,h \\<turnstile> z :\\<le> T\\<^sub>1;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(Boolean # zs, bb)\\<rfloor>;\n        P,h \\<turnstile> za :\\<le> T\\<^sub>2;\n        P,h \\<turnstile> zsa [:\\<le>] ST;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> zsa [:\\<le>] zs \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta T\\<^sub>1 T\\<^sub>2 ST LT z bb za\n       zsa zs.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (Bool (za = z) # zsa, loc, C, M, Suc pc) # frs);\n        wf_prog wt P; ins ! pc = CmpEq; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc =\n        \\<lfloor>(T\\<^sub>1 # T\\<^sub>2 # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P CmpEq pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        \\<not> is_refT T\\<^sub>1 \\<and> T\\<^sub>2 = T\\<^sub>1 \\<or>\n        is_refT T\\<^sub>1 \\<and> is_refT T\\<^sub>2;\n        Suc pc < length ins;\n        \\<forall>x\\<in>set (xcpt_eff CmpEq P pc\n                             (T\\<^sub>1 # T\\<^sub>2 # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        stk = z # za # zsa;\n        \\<forall>x\\<in>set (xcpt_eff CmpEq P pc\n                             (T\\<^sub>1 # T\\<^sub>2 # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        P,h \\<turnstile> z :\\<le> T\\<^sub>1;\n        \\<Phi> C M ! Suc pc = \\<lfloor>(Boolean # zs, bb)\\<rfloor>;\n        P,h \\<turnstile> za :\\<le> T\\<^sub>2;\n        P,h \\<turnstile> zsa [:\\<le>] ST;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] zs;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> zsa [:\\<le>] zs \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Pop_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = Pop;\n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = Pop;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = Pop;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ts ST LT z zs ab bb.\n       \\<lbrakk>\\<sigma>' = (None, h, (zs, loc, C, M, Suc pc) # frs);\n        wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        ins ! pc = Pop; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P Pop pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins; stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff Pop P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        \\<forall>x\\<in>set (xcpt_eff Pop P pc (ts # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ts ST LT z zs ab bb.\n       \\<lbrakk>\\<sigma>' = (None, h, (zs, loc, C, M, Suc pc) # frs);\n        wf_prog wt P; ins ! pc = Pop; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(ts # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P Pop pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow> d \\<le> Suc (length ST) \\<and> d < mxs);\n        Suc pc < length ins; stk = z # zs;\n        \\<forall>x\\<in>set (xcpt_eff Pop P pc (ts # ST, LT) xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        P,h \\<turnstile> z :\\<le> ts; P,h \\<turnstile> zs [:\\<le>] ST;\n        \\<forall>x\\<in>set (xcpt_eff Pop P pc (ts # ST, LT) xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(ab, bb)\\<rfloor>;\n        P \\<turnstile> ST [\\<le>] ab;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> zs [:\\<le>] ab \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma IAdd_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = IAdd; \n  P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = IAdd;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = IAdd;\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (clarsimp simp add: conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT zsa bb i ia zs.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (Intg (ia + i) # zsa, loc, C, M, Suc pc) # frs);\n        wf_prog wt P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        ins ! pc = IAdd; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Integer # Integer # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P IAdd pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins; stk = Intg i # Intg ia # zsa;\n        \\<forall>x\\<in>set (xcpt_eff IAdd P pc (Integer # Integer # ST, LT)\n                             xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff IAdd P pc (Integer # Integer # ST, LT)\n                             xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(Integer # zs, bb)\\<rfloor>;\n        P,h \\<turnstile> zsa [:\\<le>] ST;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> zsa [:\\<le>] zs \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta ST LT zsa bb i ia zs.\n       \\<lbrakk>\\<sigma>' =\n                (None, h, (Intg (ia + i) # zsa, loc, C, M, Suc pc) # frs);\n        wf_prog wt P; ins ! pc = IAdd; P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(Integer # Integer # ST, LT)\\<rfloor>;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        \\<forall>x\\<in>set (relevant_entries P IAdd pc xt).\n           case x of\n           (f, t, C, ab) \\<Rightarrow>\n             is_class P C \\<and>\n             (case ab of\n              (h, d) \\<Rightarrow>\n                d \\<le> Suc (Suc (length ST)) \\<and> d < mxs);\n        Suc pc < length ins; stk = Intg i # Intg ia # zsa;\n        \\<forall>x\\<in>set (xcpt_eff IAdd P pc (Integer # Integer # ST, LT)\n                             xt).\n           case x of (pc', \\<tau>') \\<Rightarrow> pc' < length ins;\n        \\<forall>x\\<in>set (xcpt_eff IAdd P pc (Integer # Integer # ST, LT)\n                             xt).\n           case x of\n           (pc', \\<tau>') \\<Rightarrow>\n             P \\<turnstile> \\<tau>' \\<le>' \\<Phi> C M ! pc';\n        \\<Phi> C M ! Suc pc = \\<lfloor>(Integer # zs, bb)\\<rfloor>;\n        P,h \\<turnstile> zsa [:\\<le>] ST;\n        P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] bb;\n        P \\<turnstile> ST [\\<le>] zs;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            P,h \\<turnstile> zsa [:\\<le>] zs \\<and>\n                            P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] bb \\<and>\n                            Suc pc < length is \\<and>\n                            conf_fs P h \\<Phi> M (length Ts) T frs", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Throw_correct:\n\"\\<lbrakk> wf_prog wt P; \n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C; \n  ins ! pc = Throw; \n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs) ; \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd>;\n  fst (exec_instr (ins!pc) P h stk loc C M pc frs) = None \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wt P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     ins ! pc = Throw;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "by simp"], ["", "text \\<open>\n  The next theorem collects the results of the sections above,\n  i.e.~exception handling and the execution step for each \n  instruction. It states type safety for single step execution:\n  in welltyped programs, a conforming state is transformed\n  into another conforming state when one instruction is executed.\n\\<close>"], ["", "theorem instr_correct:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n  P \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs,mxl\\<^sub>0,ins,xt) in C;\n  Some \\<sigma>' = exec (P, None, h, (stk,loc,C,M,pc)#frs); \n  P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \\<rbrakk> \n\\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (subgoal_tac \"P,T,mxs,size ins,xt \\<turnstile> ins!pc,pc :: \\<Phi> C M\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,T,mxs,length\n                               ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> P,T,mxs,length\n                               ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (erule wt_jvm_prog_impl_wt_instr, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0,\n                    ins, xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok]\\<rbrakk>\n    \\<Longrightarrow> pc < length ins\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta a b.\n       \\<lbrakk>P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n                       mxl\\<^sub>0, ins, xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        (case exec_instr (ins ! pc) P h stk loc C M pc frs of\n         (xcpt', h', frs') \\<Rightarrow>\n           \\<lfloor>case xcpt' of None \\<Rightarrow> (None, h', frs')\n                    | \\<lfloor>a\\<rfloor> \\<Rightarrow>\n                        find_handler P a h\n                         ((stk, loc, C, M, pc) # frs)\\<rfloor>);\n        P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(a, b)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] a;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs\\<rbrakk>\n       \\<Longrightarrow> pc < length ins\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (drule (1) sees_method_fun)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Tsa Ta mxsa mxl\\<^sub>0' is xta a b.\n       \\<lbrakk>\\<lfloor>\\<sigma>'\\<rfloor> =\n                (case exec_instr (ins ! pc) P h stk loc C M pc frs of\n                 (xcpt', h', frs') \\<Rightarrow>\n                   \\<lfloor>case xcpt' of\n                            None \\<Rightarrow> (None, h', frs')\n                            | \\<lfloor>a\\<rfloor> \\<Rightarrow>\n                                find_handler P a h\n                                 ((stk, loc, C, M, pc) # frs)\\<rfloor>);\n        P \\<turnstile> h \\<surd>;\n        P \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxl\\<^sub>0',\n                 is, xta) in C;\n        \\<Phi> C M ! pc = \\<lfloor>(a, b)\\<rfloor>;\n        P,h \\<turnstile> stk [:\\<le>] a;\n        P,h \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] b; pc < length is;\n        conf_fs P h \\<Phi> M (length Tsa) Ta frs;\n        Tsa = Ts \\<and>\n        Ta = T \\<and>\n        (mxsa, mxl\\<^sub>0', is, xta) = (mxs, mxl\\<^sub>0, ins, xt) \\<and>\n        C = C\\<rbrakk>\n       \\<Longrightarrow> pc < length ins\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (cases \"fst (exec_instr (ins!pc) P h stk loc C M pc frs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) =\n        \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (erule xcpt_correct, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n            xt) in C;\n     \\<lfloor>\\<sigma>'\\<rfloor> =\n     exec (P, None, h, (stk, loc, C, M, pc) # frs);\n     P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n     P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n     fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (frule wt_jvm_progD, erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (cases \"ins!pc\")"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>wt x1.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Load x1\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt x2.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt x3.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>wt x4.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>wt x51 x52.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>wt x61 x62.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>wt x7.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>wt x81 x82.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>wt.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n                xt) in C;\n         \\<lfloor>\\<sigma>'\\<rfloor> =\n         exec (P, None, h, (stk, loc, C, M, pc) # frs);\n         P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n         wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n        \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 15 subgoals...", "apply (rule Load_correct, assumption+)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>wt x2.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Store x2\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt x3.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt x4.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>wt x51 x52.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>wt x61 x62.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>wt x7.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>wt x81 x82.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>wt.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n                xt) in C;\n         \\<lfloor>\\<sigma>'\\<rfloor> =\n         exec (P, None, h, (stk, loc, C, M, pc) # frs);\n         P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n         wf_prog wt P; ins ! pc = IAdd\\<rbrakk>\n        \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 14 subgoals...", "apply (rule Store_correct, assumption+)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>wt x3.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Push x3\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt x4.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt x51 x52.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>wt x61 x62.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>wt x7.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>wt x81 x82.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IAdd\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>wt x12.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n                xt) in C;\n         \\<lfloor>\\<sigma>'\\<rfloor> =\n         exec (P, None, h, (stk, loc, C, M, pc) # frs);\n         P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n         wf_prog wt P; ins ! pc = Goto x12\\<rbrakk>\n        \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 13 subgoals...", "apply (rule Push_correct, assumption+)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>wt x4.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = New x4\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt x51 x52.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt x61 x62.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>wt x7.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>wt x81 x82.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IAdd\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>wt.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n                xt) in C;\n         \\<lfloor>\\<sigma>'\\<rfloor> =\n         exec (P, None, h, (stk, loc, C, M, pc) # frs);\n         P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n         wf_prog wt P; ins ! pc = CmpEq\\<rbrakk>\n        \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 12 subgoals...", "apply (rule New_correct, assumption+)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>wt x51 x52.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Getfield x51 x52\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt x61 x62.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt x7.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>wt x81 x82.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IAdd\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = CmpEq\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>wt x14.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n                xt) in C;\n         \\<lfloor>\\<sigma>'\\<rfloor> =\n         exec (P, None, h, (stk, loc, C, M, pc) # frs);\n         P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n         wf_prog wt P; ins ! pc = IfFalse x14\\<rbrakk>\n        \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\nA total of 11 subgoals...", "apply (rule Getfield_correct, assumption+)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>wt x61 x62.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Putfield x61 x62\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt x7.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt x81 x82.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IAdd\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = CmpEq\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>wt x14.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 10. \\<And>wt.\n        \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n         P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n                xt) in C;\n         \\<lfloor>\\<sigma>'\\<rfloor> =\n         exec (P, None, h, (stk, loc, C, M, pc) # frs);\n         P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n         P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n         fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n         wf_prog wt P; ins ! pc = Throw\\<rbrakk>\n        \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule Putfield_correct, assumption+)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>wt x7.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Checkcast x7\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt x81 x82.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IAdd\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = CmpEq\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>wt x14.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 9. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Throw\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule Checkcast_correct, assumption+)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>wt x81 x82.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Invoke x81 x82\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IAdd\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = CmpEq\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>wt x14.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 8. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Throw\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule Invoke_correct, assumption+)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Return\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IAdd\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = CmpEq\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>wt x14.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 7. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Throw\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule Return_correct, assumption+)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Pop\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IAdd\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = CmpEq\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>wt x14.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 6. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Throw\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule Pop_correct, assumption+)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IAdd\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = CmpEq\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>wt x14.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 5. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Throw\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule IAdd_correct, assumption+)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>wt x12.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Goto x12\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = CmpEq\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt x14.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 4. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Throw\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule Goto_correct, assumption+)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = CmpEq\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt x14.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Throw\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule CmpEq_correct, assumption+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>wt x14.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = IfFalse x14\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Throw\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule IfFalse_correct, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wt.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl\\<^sub>0, ins,\n               xt) in C;\n        \\<lfloor>\\<sigma>'\\<rfloor> =\n        exec (P, None, h, (stk, loc, C, M, pc) # frs);\n        P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok];\n        P,T,mxs,length ins,xt \\<turnstile> ins ! pc,pc :: \\<Phi> C M;\n        fst (exec_instr (ins ! pc) P h stk loc C M pc frs) = None;\n        wf_prog wt P; ins ! pc = Throw\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule Throw_correct, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsection \\<open>Main\\<close>"], ["", "lemma correct_state_impl_Some_method:\n  \"P,\\<Phi> \\<turnstile> (None, h, (stk,loc,C,M,pc)#frs)\\<surd> \n  \\<Longrightarrow> \\<exists>m Ts T. P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,\\<Phi> |- (None, h, (stk, loc, C, M, pc) # frs) [ok] \\<Longrightarrow>\n    \\<exists>m Ts T. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C", "by fastforce"], ["", "lemma BV_correct_1 [rule_format]:\n\"\\<And>\\<sigma>. \\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P,\\<Phi> \\<turnstile> \\<sigma>\\<surd>\\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' \\<longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- \\<sigma> [ok]\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>' \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- \\<sigma> [ok]\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>' \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (simp only: split_tupled_all exec_1_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (a, aa, b) [ok]\\<rbrakk>\n       \\<Longrightarrow> exec (P, a, aa, b) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (rename_tac xp h frs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp h frs.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (case_tac xp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = None\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (case_tac frs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xp h frs.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = None; frs = []\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs a list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = None; frs = a # list\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 3. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs a list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = None; frs = a # list\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (simp only: split_tupled_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs a aa ab ac b list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, b) # list) [ok]; xp = None;\n        frs = (a, aa, ab, ac, b) # list\\<rbrakk>\n       \\<Longrightarrow> exec (P, None, h, (a, aa, ab, ac, b) # list) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply hypsubst"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs a aa ab ac b list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, b) # list) [ok]\\<rbrakk>\n       \\<Longrightarrow> exec (P, None, h, (a, aa, ab, ac, b) # list) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (frule correct_state_impl_Some_method)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs a aa ab ac b list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, b) # list) [ok];\n        \\<exists>m Ts T.\n           P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = m in ab\\<rbrakk>\n       \\<Longrightarrow> exec (P, None, h, (a, aa, ab, ac, b) # list) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, b) # list) [ok];\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = (ad, ae, af,\n                 ba) in ab;\n        exec (P, None, h, (a, aa, ab, ac, b) # list) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule instr_correct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, b) # list) [ok];\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = (ad, ae, af,\n                 ba) in ab;\n        exec (P, None, h, (a, aa, ab, ac, b) # list) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n 2. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, b) # list) [ok];\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = (ad, ae, af,\n                 ba) in ab;\n        exec (P, None, h, (a, aa, ab, ac, b) # list) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> ?C13 xp h frs a aa ab ac b list ad\n   ae af ba Ts\n   T sees ?M13 xp h frs a aa ab ac b list ad ae af ba Ts\n           T: ?Ts13 xp h frs a aa ab ac b list ad ae af ba Ts\n               T\\<rightarrow>?T13 xp h frs a aa ab ac b list ad ae af ba Ts\n                              T = (?mxs13 xp h frs a aa ab ac b list ad ae\n                                    af ba Ts T,\n                                   ?mxl\\<^sub>013 xp h frs a aa ab ac b list\n                                    ad ae af ba Ts T,\n                                   ?ins13 xp h frs a aa ab ac b list ad ae\n                                    af ba Ts T,\n                                   ?xt13 xp h frs a aa ab ac b list ad ae af\n                                    ba Ts\n                                    T) in ?C13 xp h frs a aa ab ac b list ad\n     ae af ba Ts T\n 3. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, b) # list) [ok];\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = (ad, ae, af,\n                 ba) in ab;\n        exec (P, None, h, (a, aa, ab, ac, b) # list) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>\\<sigma>'\\<rfloor> =\n                         exec\n                          (P, None,\n                           ?h13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n                           (?stk13 xp h frs a aa ab ac b list ad ae af ba Ts\n                             T,\n                            ?loc13 xp h frs a aa ab ac b list ad ae af ba Ts\n                             T,\n                            ?C13 xp h frs a aa ab ac b list ad ae af ba Ts\n                             T,\n                            ?M13 xp h frs a aa ab ac b list ad ae af ba Ts\n                             T,\n                            ?pc13 xp h frs a aa ab ac b list ad ae af ba Ts\n                             T) #\n                           ?frs13 xp h frs a aa ab ac b list ad ae af ba Ts\n                            T)\n 4. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, b) # list) [ok];\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = (ad, ae, af,\n                 ba) in ab;\n        exec (P, None, h, (a, aa, ab, ac, b) # list) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (None,\n?h13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n(?stk13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n ?loc13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n ?C13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n ?M13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n ?pc13 xp h frs a aa ab ac b list ad ae af ba Ts T) #\n?frs13 xp h frs a aa ab ac b list ad ae af ba Ts T) [ok]\n 5. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply assumption+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, b) # list) [ok];\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = (ad, ae, af,\n                 ba) in ab;\n        exec (P, None, h, (a, aa, ab, ac, b) # list) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>\\<sigma>'\\<rfloor> =\n                         exec\n                          (P, None,\n                           ?h13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n                           (?stk13 xp h frs a aa ab ac b list ad ae af ba Ts\n                             T,\n                            ?loc13 xp h frs a aa ab ac b list ad ae af ba Ts\n                             T,\n                            ab, ac,\n                            ?pc13 xp h frs a aa ab ac b list ad ae af ba Ts\n                             T) #\n                           ?frs13 xp h frs a aa ab ac b list ad ae af ba Ts\n                            T)\n 2. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, b) # list) [ok];\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = (ad, ae, af,\n                 ba) in ab;\n        exec (P, None, h, (a, aa, ab, ac, b) # list) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (None,\n?h13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n(?stk13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n ?loc13 xp h frs a aa ab ac b list ad ae af ba Ts T, ab, ac,\n ?pc13 xp h frs a aa ab ac b list ad ae af ba Ts T) #\n?frs13 xp h frs a aa ab ac b list ad ae af ba Ts T) [ok]\n 3. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (rule sym)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, b) # list) [ok];\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = (ad, ae, af,\n                 ba) in ab;\n        exec (P, None, h, (a, aa, ab, ac, b) # list) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec\n                          (P, None,\n                           ?h13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n                           (?stk13 xp h frs a aa ab ac b list ad ae af ba Ts\n                             T,\n                            ?loc13 xp h frs a aa ab ac b list ad ae af ba Ts\n                             T,\n                            ab, ac,\n                            ?pc13 xp h frs a aa ab ac b list ad ae af ba Ts\n                             T) #\n                           ?frs13 xp h frs a aa ab ac b list ad ae af ba Ts\n                            T) =\n                         \\<lfloor>\\<sigma>'\\<rfloor>\n 2. \\<And>xp h frs a aa ab ac b list ad ae af ba Ts T.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (None, h, (a, aa, ab, ac, b) # list) [ok];\n        P \\<turnstile> ab sees ac: Ts\\<rightarrow>T = (ad, ae, af,\n                 ba) in ab;\n        exec (P, None, h, (a, aa, ab, ac, b) # list) =\n        \\<lfloor>\\<sigma>'\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (None,\n?h13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n(?stk13 xp h frs a aa ab ac b list ad ae af ba Ts T,\n ?loc13 xp h frs a aa ab ac b list ad ae af ba Ts T, ab, ac,\n ?pc13 xp h frs a aa ab ac b list ad ae af ba Ts T) #\n?frs13 xp h frs a aa ab ac b list ad ae af ba Ts T) [ok]\n 3. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply (case_tac frs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xp h frs a.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>;\n        frs = []\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]\n 2. \\<And>xp h frs a aa list.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P,\\<Phi> |- (xp, h, frs) [ok]; xp = \\<lfloor>a\\<rfloor>;\n        frs = aa # list\\<rbrakk>\n       \\<Longrightarrow> exec (P, xp, h, frs) =\n                         \\<lfloor>\\<sigma>'\\<rfloor> \\<longrightarrow>\n                         P,\\<Phi> |- \\<sigma>' [ok]", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "theorem progress:\n  \"\\<lbrakk> xp=None; frs\\<noteq>[] \\<rbrakk> \\<Longrightarrow> \\<exists>\\<sigma>'. P \\<turnstile> (xp,h,frs) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xp = None; frs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>'. P \\<turnstile>\n                         (xp, h, frs) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'", "by (clarsimp simp add: exec_1_iff neq_Nil_conv split_beta\n               simp del: split_paired_Ex)"], ["", "lemma progress_conform:\n  \"\\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P,\\<Phi> \\<turnstile> (xp,h,frs)\\<surd>; xp=None; frs\\<noteq>[]\\<rbrakk> \n  \\<Longrightarrow> \\<exists>\\<sigma>'. P \\<turnstile> (xp,h,frs) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' \\<and> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P,\\<Phi> |- (xp, h, frs) [ok]; xp = None; frs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>'.\n                         P \\<turnstile>\n                         (xp, h, frs) -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>' \\<and> P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P,\\<Phi> |- (xp, h, frs) [ok]; xp = None; frs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>'.\n                         P \\<turnstile>\n                         (xp, h, frs) -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>' \\<and> P,\\<Phi> |- \\<sigma>' [ok]", "apply (drule progress)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P,\\<Phi> |- (xp, h, frs) [ok]; frs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ?frs \\<noteq> []\n 2. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P,\\<Phi> |- (xp, h, frs) [ok]; frs \\<noteq> [];\n     \\<exists>\\<sigma>'. ?P \\<turnstile>\n        (xp, ?h, ?frs) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>'.\n                         P \\<turnstile>\n                         (xp, h, frs) -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>' \\<and> P,\\<Phi> |- \\<sigma>' [ok]", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P,\\<Phi> |- (xp, h, frs) [ok]; frs \\<noteq> [];\n     \\<exists>\\<sigma>'. ?P \\<turnstile>\n        (xp, ?h, frs) -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>'.\n                         P \\<turnstile>\n                         (xp, h, frs) -jvm\\<rightarrow>\\<^sub>1\n                         \\<sigma>' \\<and> P,\\<Phi> |- \\<sigma>' [ok]", "apply (fast intro: BV_correct_1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "theorem BV_correct [rule_format]:\n\"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' \\<rbrakk> \\<Longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>\\<surd> \\<longrightarrow> P,\\<Phi> \\<turnstile> \\<sigma>'\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n                      P,\\<Phi> |- \\<sigma>' [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n                      P,\\<Phi> |- \\<sigma>' [ok]", "apply (simp only: exec_all_def1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     (\\<sigma>, \\<sigma>') \\<in> (exec_1 P)\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n                      P,\\<Phi> |- \\<sigma>' [ok]", "apply (erule rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow> P,\\<Phi> |- \\<sigma> [ok]\n 2. \\<And>y z.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        (\\<sigma>, y) \\<in> (exec_1 P)\\<^sup>*;\n        P \\<turnstile> y -jvm\\<rightarrow>\\<^sub>1 z;\n        P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n        P,\\<Phi> |- y [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n                         P,\\<Phi> |- z [ok]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        (\\<sigma>, y) \\<in> (exec_1 P)\\<^sup>*;\n        P \\<turnstile> y -jvm\\<rightarrow>\\<^sub>1 z;\n        P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n        P,\\<Phi> |- y [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- \\<sigma> [ok] \\<longrightarrow>\n                         P,\\<Phi> |- z [ok]", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        (\\<sigma>, a, aa, b) \\<in> (exec_1 P)\\<^sup>*;\n        P \\<turnstile> (a, aa, b) -jvm\\<rightarrow>\\<^sub>1 (ab, ac, ba);\n        P,\\<Phi> |- \\<sigma> [ok]; P,\\<Phi> |- (a, aa, b) [ok]\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- (ab, ac, ba) [ok]", "apply (erule (2) BV_correct_1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma hconf_start:   \n  assumes wf: \"wf_prog wf_mb P\"\n  shows \"P \\<turnstile> (start_heap P) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> start_heap P \\<surd>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> start_heap P \\<surd>", "apply (unfold hconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a obj.\n        start_heap P a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n        P,start_heap P \\<turnstile> obj \\<surd>) \\<and>\n    preallocated (start_heap P)", "apply (simp add: preallocated_start)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a obj.\n       start_heap P a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n       P,start_heap P \\<turnstile> obj \\<surd>", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       start_heap P a = \\<lfloor>(aa, b)\\<rfloor> \\<Longrightarrow>\n       P,start_heap P \\<turnstile> (aa, b) \\<surd>", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lfloor>(aa, b)\\<rfloor> = start_heap P a \\<Longrightarrow>\n       P,start_heap P \\<turnstile> (aa, b) \\<surd>", "apply (unfold start_heap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lfloor>(aa, b)\\<rfloor> =\n       [addr_of_sys_xcpt NullPointer \\<mapsto> blank P NullPointer,\n        addr_of_sys_xcpt ClassCast \\<mapsto> blank P ClassCast,\n        addr_of_sys_xcpt OutOfMemory \\<mapsto> blank P OutOfMemory]\n        a \\<Longrightarrow>\n       P,[addr_of_sys_xcpt NullPointer \\<mapsto> blank P NullPointer,\n          addr_of_sys_xcpt ClassCast \\<mapsto> blank P ClassCast,\n          addr_of_sys_xcpt OutOfMemory \\<mapsto>\n          blank P OutOfMemory] \\<turnstile> (aa, b) \\<surd>", "apply (insert wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<lfloor>(aa, b)\\<rfloor> =\n                [addr_of_sys_xcpt NullPointer \\<mapsto> blank P NullPointer,\n                 addr_of_sys_xcpt ClassCast \\<mapsto> blank P ClassCast,\n                 addr_of_sys_xcpt OutOfMemory \\<mapsto> blank P OutOfMemory]\n                 a;\n        wf_prog wf_mb P\\<rbrakk>\n       \\<Longrightarrow> P,[addr_of_sys_xcpt NullPointer \\<mapsto>\n                            blank P NullPointer, addr_of_sys_xcpt ClassCast \n                            \\<mapsto> blank P ClassCast,\n                            addr_of_sys_xcpt OutOfMemory \\<mapsto>\n                            blank P\n                             OutOfMemory] \\<turnstile> (aa, b) \\<surd>", "apply (auto simp add: fun_upd_apply is_class_xcpt split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma BV_correct_initial: \n  shows \"\\<lbrakk> wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P; P \\<turnstile> C sees M:[]\\<rightarrow>T = m in C \\<rbrakk>\n  \\<Longrightarrow> P,\\<Phi> \\<turnstile> start_state P C M \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: []\\<rightarrow>T = m in C\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- start_state P C M [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n     P \\<turnstile> C sees M: []\\<rightarrow>T = m in C\\<rbrakk>\n    \\<Longrightarrow> P,\\<Phi> |- start_state P C M [ok]", "apply (cases m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: []\\<rightarrow>T = m in C;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- start_state P C M [ok]", "apply (unfold  start_state_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: []\\<rightarrow>T = m in C;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> P,\\<Phi> |- let (D, Ts, T, mxs, mxl\\<^sub>0, b) =\n     method P C M\n                                     in (None, start_heap P,\n   [([], Null # replicate mxl\\<^sub>0 undefined, C, M, 0)]) [ok]", "apply (unfold correct_state_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: []\\<rightarrow>T = m in C;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> case let (D, Ts, T, mxs, mxl\\<^sub>0, b) =\n                                    method P C M\n                              in (None, start_heap P,\n                                  [([],\n                                    Null # replicate mxl\\<^sub>0 undefined,\n                                    C, M, 0)]) of\n                         (None, h, []) \\<Rightarrow> True\n                         | (None, h, f # fs) \\<Rightarrow>\n                             P \\<turnstile> h \\<surd> \\<and>\n                             (let (stk, loc, C, M, pc) = f\n                              in \\<exists>Ts T mxs mxl\\<^sub>0 is xt \\<tau>.\n                                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n     mxl\\<^sub>0, is, xt) in C \\<and>\n                                    \\<Phi> C M ! pc =\n                                    \\<lfloor>\\<tau>\\<rfloor> \\<and>\n                                    conf_f P h \\<tau> is f \\<and>\n                                    conf_fs P h \\<Phi> M (length Ts) T fs)\n                         | (\\<lfloor>x\\<rfloor>, h, frs) \\<Rightarrow>\n                             frs = []", "apply (simp del: defs1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: []\\<rightarrow>T = (a, b, c, d) in C;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> start_heap P \\<surd> \\<and>\n                         (\\<exists>Ts T mxs mxl\\<^sub>0 is.\n                             (\\<exists>xt.\n                                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n  mxl\\<^sub>0, is, xt) in C) \\<and>\n                             (\\<exists>a ba.\n                                 \\<Phi> C M ! 0 =\n                                 \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                 conf_f P (start_heap P) (a, ba) is\n                                  ([], Null # replicate b undefined, C, M,\n                                   0)))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: []\\<rightarrow>T = (a, b, c, d) in C;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> start_heap P \\<surd>\n 2. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: []\\<rightarrow>T = (a, b, c, d) in C;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            (\\<exists>a ba.\n                                \\<Phi> C M ! 0 =\n                                \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                conf_f P (start_heap P) (a, ba) is\n                                 ([], Null # replicate b undefined, C, M,\n                                  0))", "apply (simp add: wf_jvm_prog_phi_def hconf_start)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P;\n        P \\<turnstile> C sees M: []\\<rightarrow>T = (a, b, c, d) in C;\n        m = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            (\\<exists>a ba.\n                                \\<Phi> C M ! 0 =\n                                \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                conf_f P (start_heap P) (a, ba) is\n                                 ([], Null # replicate b undefined, C, M,\n                                  0))", "apply (drule wt_jvm_prog_impl_wt_start, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>P \\<turnstile> C sees M: []\\<rightarrow>T = (a, b, c,\n                       d) in C;\n        m = (a, b, c, d);\n        0 < length c \\<and> wt_start P C [] b (\\<Phi> C M)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            (\\<exists>a ba.\n                                \\<Phi> C M ! 0 =\n                                \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                conf_f P (start_heap P) (a, ba) is\n                                 ([], Null # replicate b undefined, C, M,\n                                  0))", "apply (unfold conf_f_def wt_start_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>P \\<turnstile> C sees M: []\\<rightarrow>T = (a, b, c,\n                       d) in C;\n        m = (a, b, c, d);\n        0 < length c \\<and>\n        P \\<turnstile> \\<lfloor>([],\n                                 OK (Class C) #\n                                 map OK [] @\n                                 replicate b\n                                  Err)\\<rfloor> \\<le>' \\<Phi> C M !\n                 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ts T mxs mxl\\<^sub>0 is.\n                            (\\<exists>xt.\n                                P \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n mxl\\<^sub>0, is, xt) in C) \\<and>\n                            (\\<exists>a ba.\n                                \\<Phi> C M ! 0 =\n                                \\<lfloor>(a, ba)\\<rfloor> \\<and>\n                                (case (a, ba) of\n                                 (ST, LT) \\<Rightarrow>\n                                   \\<lambda>is (stk, loc, C, M, pc).\nP,start_heap P \\<turnstile> stk [:\\<le>] ST \\<and>\nP,start_heap P \\<turnstile> loc [:\\<le>\\<^sub>\\<top>] LT \\<and>\npc < length is)\n                                 is ([], Null # replicate b undefined, C, M,\n                                     0))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[simproc add: list_to_set_comprehension]]"], ["", "(*>*)"], ["", "theorem typesafe:\n  assumes welltyped:   \"wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\"\n  assumes main_method: \"P \\<turnstile> C sees M:[]\\<rightarrow>T = m in C\"\n  shows \"P \\<turnstile> start_state P C M -jvm\\<rightarrow> \\<sigma>  \\<Longrightarrow>  P,\\<Phi> \\<turnstile> \\<sigma> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> start_state P C M -jvm\\<rightarrow>\n    \\<sigma> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma> [ok]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> start_state P C M -jvm\\<rightarrow>\n    \\<sigma> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma> [ok]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> start_state P C M -jvm\\<rightarrow>\n    \\<sigma> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma> [ok]", "from welltyped main_method"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M: []\\<rightarrow>T = m in C", "have \"P,\\<Phi> \\<turnstile> start_state P C M \\<surd>\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n  P \\<turnstile> C sees M: []\\<rightarrow>T = m in C\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- start_state P C M [ok]", "by (rule BV_correct_initial)"], ["proof (state)\nthis:\n  P,\\<Phi> |- start_state P C M [ok]\n\ngoal (1 subgoal):\n 1. P \\<turnstile> start_state P C M -jvm\\<rightarrow>\n    \\<sigma> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma> [ok]", "moreover"], ["proof (state)\nthis:\n  P,\\<Phi> |- start_state P C M [ok]\n\ngoal (1 subgoal):\n 1. P \\<turnstile> start_state P C M -jvm\\<rightarrow>\n    \\<sigma> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma> [ok]", "assume \"P \\<turnstile> start_state P C M -jvm\\<rightarrow> \\<sigma>\""], ["proof (state)\nthis:\n  P \\<turnstile> start_state P C M -jvm\\<rightarrow> \\<sigma>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> start_state P C M -jvm\\<rightarrow>\n    \\<sigma> \\<Longrightarrow>\n    P,\\<Phi> |- \\<sigma> [ok]", "ultimately"], ["proof (chain)\npicking this:\n  P,\\<Phi> |- start_state P C M [ok]\n  P \\<turnstile> start_state P C M -jvm\\<rightarrow> \\<sigma>", "show \"P,\\<Phi> \\<turnstile> \\<sigma> \\<surd>\""], ["proof (prove)\nusing this:\n  P,\\<Phi> |- start_state P C M [ok]\n  P \\<turnstile> start_state P C M -jvm\\<rightarrow> \\<sigma>\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma> [ok]", "using welltyped"], ["proof (prove)\nusing this:\n  P,\\<Phi> |- start_state P C M [ok]\n  P \\<turnstile> start_state P C M -jvm\\<rightarrow> \\<sigma>\n  wf_jvm_prog\\<^bsub>\\<Phi>\\<^esub> P\n\ngoal (1 subgoal):\n 1. P,\\<Phi> |- \\<sigma> [ok]", "by - (rule BV_correct)"], ["proof (state)\nthis:\n  P,\\<Phi> |- \\<sigma> [ok]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"]]}