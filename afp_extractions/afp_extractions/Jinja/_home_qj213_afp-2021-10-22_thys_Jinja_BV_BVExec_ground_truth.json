{"file_name": "/home/qj213/afp-2021-10-22/thys/Jinja/BV/BVExec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jinja", "problem_names": ["theorem (in start_context) is_bcv_kiljvm:\n  \"is_bcv r Err step (size is) A (kiljvm P mxs mxl T\\<^sub>r is xt)\"", "lemma subset_replicate [intro?]: \"set (replicate n x) \\<subseteq> {x}\"", "lemma in_set_replicate:\n  assumes \"x \\<in> set (replicate n y)\"\n  shows \"x = y\"", "lemma (in start_context) start_in_A [intro?]:\n  \"0 < size is \\<Longrightarrow> start \\<in> list (size is) A\"", "theorem (in start_context) wt_kil_correct:\n  assumes wtk: \"wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\"\n  shows \"\\<exists>\\<tau>s. wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\"", "theorem (in start_context) wt_kil_complete:\n  assumes wtm: \"wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\"\n  shows \"wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\"", "theorem jvm_kildall_correct:\n  \"wf_jvm_prog\\<^sub>k P = wf_jvm_prog P\""], "translations": [["", "theorem (in start_context) is_bcv_kiljvm:\n  \"is_bcv r Err step (size is) A (kiljvm P mxs mxl T\\<^sub>r is xt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bcv r Err step (length is) A (kiljvm P mxs mxl T\\<^sub>r is xt)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bcv r Err step (length is) A (kiljvm P mxs mxl T\\<^sub>r is xt)", "apply (insert wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog p P \\<Longrightarrow>\n    is_bcv r Err step (length is) A (kiljvm P mxs mxl T\\<^sub>r is xt)", "apply (unfold kiljvm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog p P \\<Longrightarrow>\n    is_bcv r Err step (length is) A\n     (kildall (JVM_SemiType.le P mxs mxl) (JVM_SemiType.sup P mxs mxl)\n       (exec P mxs T\\<^sub>r xt is))", "apply (fold r_def f_def step_def_exec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog p P \\<Longrightarrow>\n    is_bcv r Err step (length is) A (kildall r f step)", "apply (rule is_bcv_kildall)"], ["proof (prove)\ngoal (6 subgoals):\n 1. wf_prog p P \\<Longrightarrow> Semilat A r f\n 2. wf_prog p P \\<Longrightarrow> acc r\n 3. wf_prog p P \\<Longrightarrow> Semilat.top r Err\n 4. wf_prog p P \\<Longrightarrow> pres_type step (length is) A\n 5. wf_prog p P \\<Longrightarrow> bounded step (length is)\n 6. wf_prog p P \\<Longrightarrow> SemilatAlg.mono r step (length is) A", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. wf_prog p P \\<Longrightarrow>\n    Semilat (states P mxs (Suc (length Ts + mxl\\<^sub>0)))\n     (JVM_SemiType.le P mxs (Suc (length Ts + mxl\\<^sub>0)))\n     (JVM_SemiType.sup P mxs (Suc (length Ts + mxl\\<^sub>0)))\n 2. wf_prog p P \\<Longrightarrow> acc r\n 3. wf_prog p P \\<Longrightarrow> Semilat.top r Err\n 4. wf_prog p P \\<Longrightarrow> pres_type step (length is) A\n 5. wf_prog p P \\<Longrightarrow> bounded step (length is)\n 6. wf_prog p P \\<Longrightarrow> SemilatAlg.mono r step (length is) A", "apply (rule Semilat.intro)"], ["proof (prove)\ngoal (6 subgoals):\n 1. wf_prog p P \\<Longrightarrow>\n    semilat\n     (states P mxs (Suc (length Ts + mxl\\<^sub>0)),\n      JVM_SemiType.le P mxs (Suc (length Ts + mxl\\<^sub>0)),\n      JVM_SemiType.sup P mxs (Suc (length Ts + mxl\\<^sub>0)))\n 2. wf_prog p P \\<Longrightarrow> acc r\n 3. wf_prog p P \\<Longrightarrow> Semilat.top r Err\n 4. wf_prog p P \\<Longrightarrow> pres_type step (length is) A\n 5. wf_prog p P \\<Longrightarrow> bounded step (length is)\n 6. wf_prog p P \\<Longrightarrow> SemilatAlg.mono r step (length is) A", "apply (fold sl_def2)"], ["proof (prove)\ngoal (6 subgoals):\n 1. wf_prog p P \\<Longrightarrow>\n    semilat (JVM_SemiType.sl P mxs (Suc (length Ts + mxl\\<^sub>0)))\n 2. wf_prog p P \\<Longrightarrow> acc r\n 3. wf_prog p P \\<Longrightarrow> Semilat.top r Err\n 4. wf_prog p P \\<Longrightarrow> pres_type step (length is) A\n 5. wf_prog p P \\<Longrightarrow> bounded step (length is)\n 6. wf_prog p P \\<Longrightarrow> SemilatAlg.mono r step (length is) A", "apply (erule semilat_JVM)"], ["proof (prove)\ngoal (5 subgoals):\n 1. wf_prog p P \\<Longrightarrow> acc r\n 2. wf_prog p P \\<Longrightarrow> Semilat.top r Err\n 3. wf_prog p P \\<Longrightarrow> pres_type step (length is) A\n 4. wf_prog p P \\<Longrightarrow> bounded step (length is)\n 5. wf_prog p P \\<Longrightarrow> SemilatAlg.mono r step (length is) A", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. wf_prog p P \\<Longrightarrow>\n    acc (JVM_SemiType.le P mxs (Suc (length Ts + mxl\\<^sub>0)))\n 2. wf_prog p P \\<Longrightarrow> Semilat.top r Err\n 3. wf_prog p P \\<Longrightarrow> pres_type step (length is) A\n 4. wf_prog p P \\<Longrightarrow> bounded step (length is)\n 5. wf_prog p P \\<Longrightarrow> SemilatAlg.mono r step (length is) A", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf_prog p P \\<Longrightarrow> Semilat.top r Err\n 2. wf_prog p P \\<Longrightarrow> pres_type step (length is) A\n 3. wf_prog p P \\<Longrightarrow> bounded step (length is)\n 4. wf_prog p P \\<Longrightarrow> SemilatAlg.mono r step (length is) A", "apply (simp add: JVM_le_unfold)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf_prog p P \\<Longrightarrow> pres_type step (length is) A\n 2. wf_prog p P \\<Longrightarrow> bounded step (length is)\n 3. wf_prog p P \\<Longrightarrow> SemilatAlg.mono r step (length is) A", "apply (rule exec_pres_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf_prog p P \\<Longrightarrow> bounded step (length is)\n 2. wf_prog p P \\<Longrightarrow> SemilatAlg.mono r step (length is) A", "apply (rule bounded_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog p P \\<Longrightarrow> SemilatAlg.mono r step (length is) A", "apply (erule step_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(* FIXME: move? *)"], ["", "lemma subset_replicate [intro?]: \"set (replicate n x) \\<subseteq> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (replicate n x) \\<subseteq> {x}", "by (induct n) auto"], ["", "lemma in_set_replicate:\n  assumes \"x \\<in> set (replicate n y)\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "note assms"], ["proof (state)\nthis:\n  x \\<in> set (replicate n y)\n\ngoal (1 subgoal):\n 1. x = y", "also"], ["proof (state)\nthis:\n  x \\<in> set (replicate n y)\n\ngoal (1 subgoal):\n 1. x = y", "have \"set (replicate n y) \\<subseteq> {y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (replicate n y) \\<subseteq> {y}", ".."], ["proof (state)\nthis:\n  set (replicate n y) \\<subseteq> {y}\n\ngoal (1 subgoal):\n 1. x = y", "finally"], ["proof (chain)\npicking this:\n  x \\<in> {y}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> {y}\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma (in start_context) start_in_A [intro?]:\n  \"0 < size is \\<Longrightarrow> start \\<in> list (size is) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length is \\<Longrightarrow> start \\<in> list (length is) A", "using Ts C"], ["proof (prove)\nusing this:\n  set Ts \\<subseteq> types P\n  is_class P C\n\ngoal (1 subgoal):\n 1. 0 < length is \\<Longrightarrow> start \\<in> list (length is) A", "(*<*)"], ["proof (prove)\nusing this:\n  set Ts \\<subseteq> types P\n  is_class P C\n\ngoal (1 subgoal):\n 1. 0 < length is \\<Longrightarrow> start \\<in> list (length is) A", "apply (simp add: JVM_states_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is \\<noteq> []; set Ts \\<subseteq> types P;\n     is_class P C\\<rbrakk>\n    \\<Longrightarrow> OK \\<lfloor>([],\n                                   OK (Class C) #\n                                   map OK Ts @\n                                   replicate mxl\\<^sub>0 Err)\\<rfloor> #\n                      replicate (length is - Suc 0) (OK None)\n                      \\<in> list (length is)\n                             (err (opt (\\<Union>\n   {list n (types P) |n. n \\<le> mxs} \\<times>\n  list (Suc (length Ts + mxl\\<^sub>0)) (err (types P)))))", "apply (force intro!: listI list_appendI dest!: in_set_replicate)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "theorem (in start_context) wt_kil_correct:\n  assumes wtk: \"wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\"\n  shows \"\\<exists>\\<tau>s. wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from wtk"], ["proof (chain)\npicking this:\n  wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "obtain res where    \n    result:   \"res = kiljvm P mxs mxl T\\<^sub>r is xt start\" and\n    success:  \"\\<forall>n < size is. res!n \\<noteq> Err\" and\n    instrs:   \"0 < size is\""], ["proof (prove)\nusing this:\n  wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n\ngoal (1 subgoal):\n 1. (\\<And>res.\n        \\<lbrakk>res = kiljvm P mxs mxl T\\<^sub>r is xt start;\n         \\<forall>n<length is. res ! n \\<noteq> Err; 0 < length is\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold wt_kildall_def) simp"], ["proof (state)\nthis:\n  res = kiljvm P mxs mxl T\\<^sub>r is xt start\n  \\<forall>n<length is. res ! n \\<noteq> Err\n  0 < length is\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "have bcv: \"is_bcv r Err step (size is) A (kiljvm P mxs mxl T\\<^sub>r is xt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bcv r Err step (length is) A (kiljvm P mxs mxl T\\<^sub>r is xt)", "by (rule is_bcv_kiljvm)"], ["proof (state)\nthis:\n  is_bcv r Err step (length is) A (kiljvm P mxs mxl T\\<^sub>r is xt)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from instrs"], ["proof (chain)\npicking this:\n  0 < length is", "have \"start \\<in> list (size is) A\""], ["proof (prove)\nusing this:\n  0 < length is\n\ngoal (1 subgoal):\n 1. start \\<in> list (length is) A", ".."], ["proof (state)\nthis:\n  start \\<in> list (length is) A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "with bcv success result"], ["proof (chain)\npicking this:\n  is_bcv r Err step (length is) A (kiljvm P mxs mxl T\\<^sub>r is xt)\n  \\<forall>n<length is. res ! n \\<noteq> Err\n  res = kiljvm P mxs mxl T\\<^sub>r is xt start\n  start \\<in> list (length is) A", "have \n    \"\\<exists>ts\\<in>list (size is) A. start [\\<sqsubseteq>\\<^sub>r] ts \\<and> wt_step r Err step ts\""], ["proof (prove)\nusing this:\n  is_bcv r Err step (length is) A (kiljvm P mxs mxl T\\<^sub>r is xt)\n  \\<forall>n<length is. res ! n \\<noteq> Err\n  res = kiljvm P mxs mxl T\\<^sub>r is xt start\n  start \\<in> list (length is) A\n\ngoal (1 subgoal):\n 1. \\<exists>ts\\<in>list (length is) A.\n       start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] ts \\<and>\n       wt_step r Err step ts", "by (unfold is_bcv_def) blast"], ["proof (state)\nthis:\n  \\<exists>ts\\<in>list (length is) A.\n     start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] ts \\<and> wt_step r Err step ts\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "then"], ["proof (chain)\npicking this:\n  \\<exists>ts\\<in>list (length is) A.\n     start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] ts \\<and> wt_step r Err step ts", "obtain \\<tau>s' where\n    in_A: \"\\<tau>s' \\<in> list (size is) A\" and\n    s:    \"start [\\<sqsubseteq>\\<^sub>r] \\<tau>s'\" and\n    w:    \"wt_step r Err step \\<tau>s'\""], ["proof (prove)\nusing this:\n  \\<exists>ts\\<in>list (length is) A.\n     start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] ts \\<and> wt_step r Err step ts\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau>s'.\n        \\<lbrakk>\\<tau>s' \\<in> list (length is) A;\n         start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] \\<tau>s';\n         wt_step r Err step \\<tau>s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<tau>s' \\<in> list (length is) A\n  start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] \\<tau>s'\n  wt_step r Err step \\<tau>s'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "hence wt_err_step: \"wt_err_step (sup_state_opt P) step \\<tau>s'\""], ["proof (prove)\nusing this:\n  \\<tau>s' \\<in> list (length is) A\n  start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] \\<tau>s'\n  wt_step r Err step \\<tau>s'\n\ngoal (1 subgoal):\n 1. wt_err_step (sup_state_opt P) step \\<tau>s'", "by (simp add: wt_err_step_def JVM_le_Err_conv)"], ["proof (state)\nthis:\n  wt_err_step (sup_state_opt P) step \\<tau>s'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from in_A"], ["proof (chain)\npicking this:\n  \\<tau>s' \\<in> list (length is) A", "have l: \"size \\<tau>s' = size is\""], ["proof (prove)\nusing this:\n  \\<tau>s' \\<in> list (length is) A\n\ngoal (1 subgoal):\n 1. length \\<tau>s' = length is", "by simp"], ["proof (state)\nthis:\n  length \\<tau>s' = length is\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "moreover"], ["proof (state)\nthis:\n  length \\<tau>s' = length is\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "{"], ["proof (state)\nthis:\n  length \\<tau>s' = length is\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from in_A"], ["proof (chain)\npicking this:\n  \\<tau>s' \\<in> list (length is) A", "have \"check_types P mxs mxl \\<tau>s'\""], ["proof (prove)\nusing this:\n  \\<tau>s' \\<in> list (length is) A\n\ngoal (1 subgoal):\n 1. check_types P mxs mxl \\<tau>s'", "by (simp add: check_types_def)"], ["proof (state)\nthis:\n  check_types P mxs mxl \\<tau>s'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "also"], ["proof (state)\nthis:\n  check_types P mxs mxl \\<tau>s'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from w"], ["proof (chain)\npicking this:\n  wt_step r Err step \\<tau>s'", "have \"\\<forall>x \\<in> set \\<tau>s'. x \\<noteq> Err\""], ["proof (prove)\nusing this:\n  wt_step r Err step \\<tau>s'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set \\<tau>s'. x \\<noteq> Err", "by (auto simp add: wt_step_def all_set_conv_all_nth)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set \\<tau>s'. x \\<noteq> Err\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "hence [symmetric]: \"map OK (map ok_val \\<tau>s') = \\<tau>s'\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set \\<tau>s'. x \\<noteq> Err\n\ngoal (1 subgoal):\n 1. map OK (map ok_val \\<tau>s') = \\<tau>s'", "by (auto intro!: map_idI simp add: wt_step_def)"], ["proof (state)\nthis:\n  \\<tau>s' = map OK (map ok_val \\<tau>s')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "finally"], ["proof (chain)\npicking this:\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s'))", "have \"check_types P mxs mxl (map OK (map ok_val \\<tau>s'))\""], ["proof (prove)\nusing this:\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s'))\n\ngoal (1 subgoal):\n 1. check_types P mxs mxl (map OK (map ok_val \\<tau>s'))", "."], ["proof (state)\nthis:\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s'))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "}"], ["proof (state)\nthis:\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s'))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "moreover"], ["proof (state)\nthis:\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s'))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "{"], ["proof (state)\nthis:\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s'))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from s"], ["proof (chain)\npicking this:\n  start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] \\<tau>s'", "have \"start!0 \\<sqsubseteq>\\<^sub>r \\<tau>s'!0\""], ["proof (prove)\nusing this:\n  start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] \\<tau>s'\n\ngoal (1 subgoal):\n 1. start ! 0 \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s' ! 0", "by (rule le_listD) simp"], ["proof (state)\nthis:\n  start ! 0 \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s' ! 0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "moreover"], ["proof (state)\nthis:\n  start ! 0 \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s' ! 0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from instrs w l"], ["proof (chain)\npicking this:\n  0 < length is\n  wt_step r Err step \\<tau>s'\n  length \\<tau>s' = length is", "have \"\\<tau>s'!0 \\<noteq> Err\""], ["proof (prove)\nusing this:\n  0 < length is\n  wt_step r Err step \\<tau>s'\n  length \\<tau>s' = length is\n\ngoal (1 subgoal):\n 1. \\<tau>s' ! 0 \\<noteq> Err", "by (unfold wt_step_def) simp"], ["proof (state)\nthis:\n  \\<tau>s' ! 0 \\<noteq> Err\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "then"], ["proof (chain)\npicking this:\n  \\<tau>s' ! 0 \\<noteq> Err", "obtain \\<tau>s0 where \"\\<tau>s'!0 = OK \\<tau>s0\""], ["proof (prove)\nusing this:\n  \\<tau>s' ! 0 \\<noteq> Err\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau>s0.\n        \\<tau>s' ! 0 = OK \\<tau>s0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<tau>s' ! 0 = OK \\<tau>s0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "ultimately"], ["proof (chain)\npicking this:\n  start ! 0 \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s' ! 0\n  \\<tau>s' ! 0 = OK \\<tau>s0", "have \"wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s')\""], ["proof (prove)\nusing this:\n  start ! 0 \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s' ! 0\n  \\<tau>s' ! 0 = OK \\<tau>s0\n\ngoal (1 subgoal):\n 1. wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s')", "using l instrs"], ["proof (prove)\nusing this:\n  start ! 0 \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>s' ! 0\n  \\<tau>s' ! 0 = OK \\<tau>s0\n  length \\<tau>s' = length is\n  0 < length is\n\ngoal (1 subgoal):\n 1. wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s')", "by (unfold wt_start_def) \n         (simp add: lesub_def JVM_le_Err_conv Err.le_def)"], ["proof (state)\nthis:\n  wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "}"], ["proof (state)\nthis:\n  wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "moreover"], ["proof (state)\nthis:\n  wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "from in_A"], ["proof (chain)\npicking this:\n  \\<tau>s' \\<in> list (length is) A", "have \"set \\<tau>s' \\<subseteq> A\""], ["proof (prove)\nusing this:\n  \\<tau>s' \\<in> list (length is) A\n\ngoal (1 subgoal):\n 1. set \\<tau>s' \\<subseteq> A", "by simp"], ["proof (state)\nthis:\n  set \\<tau>s' \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "with wt_err_step bounded_step"], ["proof (chain)\npicking this:\n  wt_err_step (sup_state_opt P) step \\<tau>s'\n  bounded step (length is)\n  set \\<tau>s' \\<subseteq> A", "have \"wt_app_eff (sup_state_opt P) app eff (map ok_val \\<tau>s')\""], ["proof (prove)\nusing this:\n  wt_err_step (sup_state_opt P) step \\<tau>s'\n  bounded step (length is)\n  set \\<tau>s' \\<subseteq> A\n\ngoal (1 subgoal):\n 1. wt_app_eff (sup_state_opt P) app eff (map ok_val \\<tau>s')", "by (auto intro: wt_err_imp_wt_app_eff simp add: l)"], ["proof (state)\nthis:\n  wt_app_eff (sup_state_opt P) app eff (map ok_val \\<tau>s')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "ultimately"], ["proof (chain)\npicking this:\n  length \\<tau>s' = length is\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s'))\n  wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s')\n  wt_app_eff (sup_state_opt P) app eff (map ok_val \\<tau>s')", "have \"wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (map ok_val \\<tau>s')\""], ["proof (prove)\nusing this:\n  length \\<tau>s' = length is\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s'))\n  wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s')\n  wt_app_eff (sup_state_opt P) app eff (map ok_val \\<tau>s')\n\ngoal (1 subgoal):\n 1. wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (map ok_val \\<tau>s')", "using instrs"], ["proof (prove)\nusing this:\n  length \\<tau>s' = length is\n  check_types P mxs mxl (map OK (map ok_val \\<tau>s'))\n  wt_start P C Ts mxl\\<^sub>0 (map ok_val \\<tau>s')\n  wt_app_eff (sup_state_opt P) app eff (map ok_val \\<tau>s')\n  0 < length is\n\ngoal (1 subgoal):\n 1. wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (map ok_val \\<tau>s')", "by (simp add: wt_method_def2 check_types_def del: map_map)"], ["proof (state)\nthis:\n  wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (map ok_val \\<tau>s')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "thus ?thesis"], ["proof (prove)\nusing this:\n  wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (map ok_val \\<tau>s')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>s.\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<tau>s. wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "theorem (in start_context) wt_kil_complete:\n  assumes wtm: \"wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\"\n  shows \"wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "from wtm"], ["proof (chain)\npicking this:\n  wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s", "obtain\n    instrs:   \"0 < size is\" and\n    length:   \"length \\<tau>s = length is\" and \n    ck_type:  \"check_types P mxs mxl (map OK \\<tau>s)\" and\n    wt_start: \"wt_start P C Ts mxl\\<^sub>0 \\<tau>s\" and\n    app_eff:  \"wt_app_eff (sup_state_opt P) app eff \\<tau>s\""], ["proof (prove)\nusing this:\n  wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>0 < length is; length \\<tau>s = length is;\n      check_types P mxs mxl (map OK \\<tau>s);\n      wt_start P C Ts mxl\\<^sub>0 \\<tau>s;\n      wt_app_eff (sup_state_opt P) app eff \\<tau>s\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: wt_method_def2 check_types_def)"], ["proof (state)\nthis:\n  0 < length is\n  length \\<tau>s = length is\n  check_types P mxs mxl (map OK \\<tau>s)\n  wt_start P C Ts mxl\\<^sub>0 \\<tau>s\n  wt_app_eff (sup_state_opt P) app eff \\<tau>s\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "from ck_type"], ["proof (chain)\npicking this:\n  check_types P mxs mxl (map OK \\<tau>s)", "have in_A: \"set (map OK \\<tau>s) \\<subseteq> A\""], ["proof (prove)\nusing this:\n  check_types P mxs mxl (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. set (map OK \\<tau>s) \\<subseteq> A", "by (simp add: check_types_def)"], ["proof (state)\nthis:\n  set (map OK \\<tau>s) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "with app_eff in_A bounded_step"], ["proof (chain)\npicking this:\n  wt_app_eff (sup_state_opt P) app eff \\<tau>s\n  set (map OK \\<tau>s) \\<subseteq> A\n  bounded step (length is)\n  set (map OK \\<tau>s) \\<subseteq> A", "have \"wt_err_step (sup_state_opt P) (err_step (size \\<tau>s) app eff) (map OK \\<tau>s)\""], ["proof (prove)\nusing this:\n  wt_app_eff (sup_state_opt P) app eff \\<tau>s\n  set (map OK \\<tau>s) \\<subseteq> A\n  bounded step (length is)\n  set (map OK \\<tau>s) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. wt_err_step (sup_state_opt P) (err_step (length \\<tau>s) app eff)\n     (map OK \\<tau>s)", "by - (erule wt_app_eff_imp_wt_err,\n          auto simp add: exec_def length states_def)"], ["proof (state)\nthis:\n  wt_err_step (sup_state_opt P) (err_step (length \\<tau>s) app eff)\n   (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "hence wt_err: \"wt_err_step (sup_state_opt P) step (map OK \\<tau>s)\""], ["proof (prove)\nusing this:\n  wt_err_step (sup_state_opt P) (err_step (length \\<tau>s) app eff)\n   (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_err_step (sup_state_opt P) step (map OK \\<tau>s)", "by (simp add: length)"], ["proof (state)\nthis:\n  wt_err_step (sup_state_opt P) step (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "have is_bcv: \"is_bcv r Err step (size is) A (kiljvm P mxs mxl T\\<^sub>r is xt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bcv r Err step (length is) A (kiljvm P mxs mxl T\\<^sub>r is xt)", "by (rule is_bcv_kiljvm)"], ["proof (state)\nthis:\n  is_bcv r Err step (length is) A (kiljvm P mxs mxl T\\<^sub>r is xt)\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "moreover"], ["proof (state)\nthis:\n  is_bcv r Err step (length is) A (kiljvm P mxs mxl T\\<^sub>r is xt)\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "from instrs"], ["proof (chain)\npicking this:\n  0 < length is", "have \"start \\<in> list (size is) A\""], ["proof (prove)\nusing this:\n  0 < length is\n\ngoal (1 subgoal):\n 1. start \\<in> list (length is) A", ".."], ["proof (state)\nthis:\n  start \\<in> list (length is) A\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "moreover"], ["proof (state)\nthis:\n  start \\<in> list (length is) A\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "let ?\\<tau>s = \"map OK \\<tau>s\""], ["proof (state)\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "have less_\\<tau>s: \"start [\\<sqsubseteq>\\<^sub>r] ?\\<tau>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] map OK \\<tau>s", "proof (rule le_listI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length start = length (map OK \\<tau>s)\n 2. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "from length instrs"], ["proof (chain)\npicking this:\n  length \\<tau>s = length is\n  0 < length is", "show \"length start = length (map OK \\<tau>s)\""], ["proof (prove)\nusing this:\n  length \\<tau>s = length is\n  0 < length is\n\ngoal (1 subgoal):\n 1. length start = length (map OK \\<tau>s)", "by simp"], ["proof (state)\nthis:\n  length start = length (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "from wt_start"], ["proof (chain)\npicking this:\n  wt_start P C Ts mxl\\<^sub>0 \\<tau>s", "have \"P \\<turnstile> ok_val (start!0) \\<le>' \\<tau>s!0\""], ["proof (prove)\nusing this:\n  wt_start P C Ts mxl\\<^sub>0 \\<tau>s\n\ngoal (1 subgoal):\n 1. P \\<turnstile> ok_val (start ! 0) \\<le>' \\<tau>s ! 0", "by (simp add: wt_start_def)"], ["proof (state)\nthis:\n  P \\<turnstile> ok_val (start ! 0) \\<le>' \\<tau>s ! 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> ok_val (start ! 0) \\<le>' \\<tau>s ! 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "from instrs length"], ["proof (chain)\npicking this:\n  0 < length is\n  length \\<tau>s = length is", "have \"0 < length \\<tau>s\""], ["proof (prove)\nusing this:\n  0 < length is\n  length \\<tau>s = length is\n\ngoal (1 subgoal):\n 1. 0 < length \\<tau>s", "by simp"], ["proof (state)\nthis:\n  0 < length \\<tau>s\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> ok_val (start ! 0) \\<le>' \\<tau>s ! 0\n  0 < length \\<tau>s", "have \"start!0 \\<sqsubseteq>\\<^sub>r ?\\<tau>s!0\""], ["proof (prove)\nusing this:\n  P \\<turnstile> ok_val (start ! 0) \\<le>' \\<tau>s ! 0\n  0 < length \\<tau>s\n\ngoal (1 subgoal):\n 1. start ! 0 \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! 0", "by (simp add: JVM_le_Err_conv lesub_def)"], ["proof (state)\nthis:\n  start ! 0 \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "moreover"], ["proof (state)\nthis:\n  start ! 0 \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "{"], ["proof (state)\nthis:\n  start ! 0 \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "fix n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "have \"OK None \\<sqsubseteq>\\<^sub>r ?\\<tau>s!n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OK None \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "by (auto simp add: JVM_le_Err_conv Err.le_def lesub_def \n                 split: err.splits)"], ["proof (state)\nthis:\n  OK None \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "hence \"\\<lbrakk>n = Suc n'; n < size start\\<rbrakk> \\<Longrightarrow> start!n \\<sqsubseteq>\\<^sub>r ?\\<tau>s!n\""], ["proof (prove)\nusing this:\n  OK None \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n = Suc n'; n < length start\\<rbrakk>\n    \\<Longrightarrow> start ! n \n                      \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>n = Suc n'; n < length start\\<rbrakk>\n  \\<Longrightarrow> start ! n \n                    \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>n = Suc ?n'2; n < length start\\<rbrakk>\n  \\<Longrightarrow> start ! n \n                    \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length start \\<Longrightarrow>\n       start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "ultimately"], ["proof (chain)\npicking this:\n  start ! 0 \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! 0\n  \\<lbrakk>n = Suc ?n'2; n < length start\\<rbrakk>\n  \\<Longrightarrow> start ! n \n                    \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "show \"n < size start \\<Longrightarrow> start!n \\<sqsubseteq>\\<^sub>r ?\\<tau>s!n\""], ["proof (prove)\nusing this:\n  start ! 0 \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! 0\n  \\<lbrakk>n = Suc ?n'2; n < length start\\<rbrakk>\n  \\<Longrightarrow> start ! n \n                    \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n\n\ngoal (1 subgoal):\n 1. n < length start \\<Longrightarrow>\n    start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n", "by (cases n, blast+)"], ["proof (state)\nthis:\n  n < length start \\<Longrightarrow>\n  start ! n \\<sqsubseteq>\\<^bsub>r\\<^esub> map OK \\<tau>s ! n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] map OK \\<tau>s\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "moreover"], ["proof (state)\nthis:\n  start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] map OK \\<tau>s\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "from ck_type length"], ["proof (chain)\npicking this:\n  check_types P mxs mxl (map OK \\<tau>s)\n  length \\<tau>s = length is", "have \"?\\<tau>s \\<in> list (size is) A\""], ["proof (prove)\nusing this:\n  check_types P mxs mxl (map OK \\<tau>s)\n  length \\<tau>s = length is\n\ngoal (1 subgoal):\n 1. map OK \\<tau>s \\<in> list (length is) A", "by (auto intro!: listI simp add: check_types_def)"], ["proof (state)\nthis:\n  map OK \\<tau>s \\<in> list (length is) A\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "moreover"], ["proof (state)\nthis:\n  map OK \\<tau>s \\<in> list (length is) A\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "from wt_err"], ["proof (chain)\npicking this:\n  wt_err_step (sup_state_opt P) step (map OK \\<tau>s)", "have \"wt_step r Err step ?\\<tau>s\""], ["proof (prove)\nusing this:\n  wt_err_step (sup_state_opt P) step (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_step r Err step (map OK \\<tau>s)", "by (simp add: wt_err_step_def JVM_le_Err_conv)"], ["proof (state)\nthis:\n  wt_step r Err step (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "ultimately"], ["proof (chain)\npicking this:\n  is_bcv r Err step (length is) A (kiljvm P mxs mxl T\\<^sub>r is xt)\n  start \\<in> list (length is) A\n  start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] map OK \\<tau>s\n  map OK \\<tau>s \\<in> list (length is) A\n  wt_step r Err step (map OK \\<tau>s)", "have \"\\<forall>p. p < size is \\<longrightarrow> kiljvm P  mxs mxl T\\<^sub>r is xt start ! p \\<noteq> Err\""], ["proof (prove)\nusing this:\n  is_bcv r Err step (length is) A (kiljvm P mxs mxl T\\<^sub>r is xt)\n  start \\<in> list (length is) A\n  start [\\<sqsubseteq>\\<^bsub>r\\<^esub>] map OK \\<tau>s\n  map OK \\<tau>s \\<in> list (length is) A\n  wt_step r Err step (map OK \\<tau>s)\n\ngoal (1 subgoal):\n 1. \\<forall>p<length is.\n       kiljvm P mxs mxl T\\<^sub>r is xt start ! p \\<noteq> Err", "by (unfold is_bcv_def) blast"], ["proof (state)\nthis:\n  \\<forall>p<length is.\n     kiljvm P mxs mxl T\\<^sub>r is xt start ! p \\<noteq> Err\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "with instrs"], ["proof (chain)\npicking this:\n  0 < length is\n  \\<forall>p<length is.\n     kiljvm P mxs mxl T\\<^sub>r is xt start ! p \\<noteq> Err", "show \"wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\""], ["proof (prove)\nusing this:\n  0 < length is\n  \\<forall>p<length is.\n     kiljvm P mxs mxl T\\<^sub>r is xt start ! p \\<noteq> Err\n\ngoal (1 subgoal):\n 1. wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt", "by (unfold wt_kildall_def) simp"], ["proof (state)\nthis:\n  wt_kildall P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "theorem jvm_kildall_correct:\n  \"wf_jvm_prog\\<^sub>k P = wf_jvm_prog P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^sub>k P = wf_jvm_prog P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^sub>k P = wf_jvm_prog P", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf_jvm_prog\\<^sub>k P \\<Longrightarrow> wf_jvm_prog P\n 2. wf_jvm_prog P \\<Longrightarrow> wf_jvm_prog\\<^sub>k P", "let ?\\<Phi> = \"\\<lambda>C M. let (C,Ts,T\\<^sub>r,(mxs,mxl\\<^sub>0,is,xt)) = method P C M in \n              SOME \\<tau>s. wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt \\<tau>s\"\n\n  \\<comment> \\<open>soundness\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. wf_jvm_prog\\<^sub>k P \\<Longrightarrow> wf_jvm_prog P\n 2. wf_jvm_prog P \\<Longrightarrow> wf_jvm_prog\\<^sub>k P", "assume wt: \"wf_jvm_prog\\<^sub>k P\""], ["proof (state)\nthis:\n  wf_jvm_prog\\<^sub>k P\n\ngoal (2 subgoals):\n 1. wf_jvm_prog\\<^sub>k P \\<Longrightarrow> wf_jvm_prog P\n 2. wf_jvm_prog P \\<Longrightarrow> wf_jvm_prog\\<^sub>k P", "hence \"wf_jvm_prog\\<^bsub>?\\<Phi>\\<^esub> P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^sub>k P\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>\\<lambda>C M.\n                          let (C, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) =\n                                method P C M\n                          in SOME \\<tau>s.\n                                wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0\n                                 is xt \\<tau>s\\<^esub>\n     P", "apply (unfold wf_jvm_prog_phi_def wf_jvm_prog\\<^sub>k_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog\n     (\\<lambda>P C' (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_kildall P C' Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt)\n     P \\<Longrightarrow>\n    wf_prog\n     (\\<lambda>Pa C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method Pa C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n          (let (C, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) = method P C M\n           in Eps (wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt)))\n     P", "apply (erule wf_prog_lift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>wf_md C M Ts Ca T m bd.\n       \\<lbrakk>wf_prog wf_md P;\n        P \\<turnstile> Ca sees M: Ts\\<rightarrow>T = m in Ca;\n        set Ts \\<subseteq> types P; bd = (M, Ts, T, m);\n        case bd of\n        (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) \\<Rightarrow>\n          wt_kildall P Ca Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\\<rbrakk>\n       \\<Longrightarrow> case bd of\n                         (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                          xt) \\<Rightarrow>\n                           wt_method P Ca Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n                            (let (C, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                                   xt) = method P Ca M\n                             in Eps (wt_method P C Ts T\\<^sub>r mxs\nmxl\\<^sub>0 is xt))", "apply (auto dest!: start_context.wt_kil_correct [OF start_context.intro] \n                intro: someI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M Ts Ca T a aa ab b.\n       \\<lbrakk>P \\<turnstile> Ca sees M: Ts\\<rightarrow>T = (a, aa, ab,\n                        b) in Ca;\n        set Ts \\<subseteq> types P; wt_kildall P Ca Ts T a aa ab b;\n        \\<not> wt_method P Ca Ts T a aa ab b\n                (Eps (wt_method P Ca Ts T a aa ab b))\\<rbrakk>\n       \\<Longrightarrow> is_class P Ca", "apply (erule sees_method_is_class)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^bsub>\\<lambda>C M.\n                        let (C, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) =\n                              method P C M\n                        in SOME \\<tau>s.\n                              wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is\n                               xt \\<tau>s\\<^esub>\n   P\n\ngoal (2 subgoals):\n 1. wf_jvm_prog\\<^sub>k P \\<Longrightarrow> wf_jvm_prog P\n 2. wf_jvm_prog P \\<Longrightarrow> wf_jvm_prog\\<^sub>k P", "thus \"wf_jvm_prog P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>\\<lambda>C M.\n                        let (C, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) =\n                              method P C M\n                        in SOME \\<tau>s.\n                              wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is\n                               xt \\<tau>s\\<^esub>\n   P\n\ngoal (1 subgoal):\n 1. wf_jvm_prog P", "by (unfold wf_jvm_prog_def) fast"], ["proof (state)\nthis:\n  wf_jvm_prog P\n\ngoal (1 subgoal):\n 1. wf_jvm_prog P \\<Longrightarrow> wf_jvm_prog\\<^sub>k P", "next\n  \\<comment> \\<open>completeness\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_jvm_prog P \\<Longrightarrow> wf_jvm_prog\\<^sub>k P", "assume wt: \"wf_jvm_prog P\""], ["proof (state)\nthis:\n  wf_jvm_prog P\n\ngoal (1 subgoal):\n 1. wf_jvm_prog P \\<Longrightarrow> wf_jvm_prog\\<^sub>k P", "thus \"wf_jvm_prog\\<^sub>k P\""], ["proof (prove)\nusing this:\n  wf_jvm_prog P\n\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^sub>k P", "apply (unfold wf_jvm_prog_def wf_jvm_prog_phi_def wf_jvm_prog\\<^sub>k_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       wf_prog\n        (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n            wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n        P \\<Longrightarrow>\n    wf_prog\n     (\\<lambda>P C' (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_kildall P C' Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt)\n     P", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       wf_prog\n        (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n            wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (\\<Phi> C M))\n        P \\<Longrightarrow>\n       wf_prog\n        (\\<lambda>P C' (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n            wt_kildall P C' Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt)\n        P", "apply (erule wf_prog_lift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> wf_md C' M Ts C'a T m bd.\n       \\<lbrakk>wf_prog wf_md P;\n        P \\<turnstile> C'a sees M: Ts\\<rightarrow>T = m in C'a;\n        set Ts \\<subseteq> types P; bd = (M, Ts, T, m);\n        case bd of\n        (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt) \\<Rightarrow>\n          wt_method P C'a Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt\n           (\\<Phi> C'a M)\\<rbrakk>\n       \\<Longrightarrow> case bd of\n                         (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is,\n                          xt) \\<Rightarrow>\n                           wt_kildall P C'a Ts T\\<^sub>r mxs mxl\\<^sub>0 is\n                            xt", "apply (auto intro!: start_context.wt_kil_complete start_context.intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> wf_md M Ts C'a T a aa ab b.\n       \\<lbrakk>wf_prog wf_md P;\n        P \\<turnstile> C'a sees M: Ts\\<rightarrow>T = (a, aa, ab, b) in C'a;\n        set Ts \\<subseteq> types P;\n        wt_method P C'a Ts T a aa ab b (\\<Phi> C'a M)\\<rbrakk>\n       \\<Longrightarrow> is_class P C'a", "apply (erule sees_method_is_class)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^sub>k P\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"]]}