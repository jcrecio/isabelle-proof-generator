{"file_name": "/home/qj213/afp-2021-10-22/thys/Jinja/DFA/LBVSpec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jinja", "problem_names": ["lemma (in lbv) wti:\n  \"wti c pc s = merge c pc (step pc s) (c!(pc+1))\"", "lemma (in lbv) wtc: \n  \"wtc c pc s = (if c!pc = \\<bottom> then wti c pc s else if s \\<sqsubseteq>\\<^sub>r c!pc then wti c pc (c!pc) else \\<top>)\"", "lemma cert_okD1 [intro?]:\n  \"cert_ok c n T B A \\<Longrightarrow> pc < n \\<Longrightarrow> c!pc \\<in> A\"", "lemma cert_okD2 [intro?]:\n  \"cert_ok c n T B A \\<Longrightarrow> c!n = B\"", "lemma cert_okD3 [intro?]:\n  \"cert_ok c n T B A \\<Longrightarrow> B \\<in> A \\<Longrightarrow> pc < n \\<Longrightarrow> c!Suc pc \\<in> A\"", "lemma cert_okD4 [intro?]:\n  \"cert_ok c n T B A \\<Longrightarrow> pc < n \\<Longrightarrow> c!pc \\<noteq> T\"", "lemma (in lbv) sup_top [simp, elim]:\n  assumes x: \"x \\<in> A\" \n  shows \"x \\<squnion>\\<^sub>f \\<top> = \\<top>\"", "lemma (in lbv) plusplussup_top [simp, elim]:\n  \"set xs \\<subseteq> A \\<Longrightarrow> xs \\<Squnion>\\<^bsub>f\\<^esub> \\<top> = \\<top>\"", "lemma (in Semilat) pp_ub1':\n  assumes S: \"snd`set S \\<subseteq> A\" \n  assumes y: \"y \\<in> A\" and ab: \"(a, b) \\<in> set S\" \n  shows \"b \\<sqsubseteq>\\<^sub>r map snd [(p', t') \\<leftarrow> S . p' = a] \\<Squnion>\\<^bsub>f\\<^esub> y\"", "lemma (in lbv) bottom_le [simp, intro!]: \"\\<bottom> \\<sqsubseteq>\\<^sub>r x\"", "lemma (in lbv) le_bottom [simp]: \"x \\<sqsubseteq>\\<^sub>r \\<bottom> = (x = \\<bottom>)\"", "lemma (in lbv) merge_Nil [simp]:\n  \"merge c pc [] x = x\"", "lemma (in lbv) merge_Cons [simp]:\n  \"merge c pc (l#ls) x = merge c pc ls (if fst l=pc+1 then snd l +_f x\n                                        else if snd l \\<sqsubseteq>\\<^sub>r c!fst l then x\n                                        else \\<top>)\"", "lemma (in lbv) merge_Err [simp]:\n  \"snd`set ss \\<subseteq> A \\<Longrightarrow> merge c pc ss \\<top> = \\<top>\"", "lemma (in lbv) merge_not_top:\n  \"\\<And>x. snd`set ss \\<subseteq> A \\<Longrightarrow> merge c pc ss x \\<noteq> \\<top> \\<Longrightarrow> \n  \\<forall>(pc',s') \\<in> set ss. (pc' \\<noteq> pc+1 \\<longrightarrow> s' \\<sqsubseteq>\\<^sub>r c!pc')\"\n  (is \"\\<And>x. ?set ss \\<Longrightarrow> ?merge ss x \\<Longrightarrow> ?P ss\")", "lemma (in lbv) merge_def:\n  shows \n  \"\\<And>x. x \\<in> A \\<Longrightarrow> snd`set ss \\<subseteq> A \\<Longrightarrow>\n  merge c pc ss x = \n  (if \\<forall>(pc',s') \\<in> set ss. pc'\\<noteq>pc+1 \\<longrightarrow> s' \\<sqsubseteq>\\<^sub>r c!pc' then\n    map snd [(p',t') \\<leftarrow> ss. p'=pc+1] \\<Squnion>\\<^bsub>f\\<^esub> x\n  else \\<top>)\" \n  (is \"\\<And>x. _ \\<Longrightarrow> _ \\<Longrightarrow> ?merge ss x = ?if ss x\" is \"\\<And>x. _ \\<Longrightarrow> _ \\<Longrightarrow> ?P ss x\")", "lemma (in lbv) merge_not_top_s:\n  assumes x:  \"x \\<in> A\" and ss: \"snd`set ss \\<subseteq> A\"\n  assumes m:  \"merge c pc ss x \\<noteq> \\<top>\"\n  shows \"merge c pc ss x = (map snd [(p',t') \\<leftarrow> ss. p'=pc+1] \\<Squnion>\\<^bsub>f\\<^esub> x)\"", "lemmas [iff] = not_Err_eq", "lemma (in lbv) wtl_Nil [simp]: \"wtl [] c pc s = s\"", "lemma (in lbv) wtl_Cons [simp]: \n  \"wtl (i#is) c pc s = \n  (let s' = wtc c pc s in if s' = \\<top> \\<or> s = \\<top> then \\<top> else wtl is c (pc+1) s')\"", "lemma (in lbv) wtl_Cons_not_top:\n  \"wtl (i#is) c pc s \\<noteq> \\<top> = \n  (wtc c pc s \\<noteq> \\<top> \\<and> s \\<noteq> T \\<and> wtl is c (pc+1) (wtc c pc s) \\<noteq> \\<top>)\"", "lemma (in lbv) wtl_top [simp]:  \"wtl ls c pc \\<top> = \\<top>\"", "lemma (in lbv) wtl_not_top:\n  \"wtl ls c pc s \\<noteq> \\<top> \\<Longrightarrow> s \\<noteq> \\<top>\"", "lemma (in lbv) wtl_append [simp]:\n  \"\\<And>pc s. wtl (a@b) c pc s = wtl b c (pc+length a) (wtl a c pc s)\"", "lemma (in lbv) wtl_take:\n  \"wtl is c pc s \\<noteq> \\<top> \\<Longrightarrow> wtl (take pc' is) c pc s \\<noteq> \\<top>\"\n  (is \"?wtl is \\<noteq> _ \\<Longrightarrow> _\")", "lemma take_Suc:\n  \"\\<forall>n. n < length l \\<longrightarrow> take (Suc n) l = (take n l)@[l!n]\" (is \"?P l\")", "lemma (in lbv) wtl_Suc:\n  assumes suc: \"pc+1 < length is\"\n  assumes wtl: \"wtl (take pc is) c 0 s \\<noteq> \\<top>\"\n  shows \"wtl (take (pc+1) is) c 0 s = wtc c pc (wtl (take pc is) c 0 s)\"", "lemma (in lbv) wtl_all:\n  assumes all: \"wtl is c 0 s \\<noteq> \\<top>\" (is \"?wtl is \\<noteq> _\") \n  assumes pc:  \"pc < length is\"\n  shows  \"wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>\"", "lemma (in lbv) merge_pres:\n  assumes s0: \"snd`set ss \\<subseteq> A\" and x: \"x \\<in> A\"\n  shows \"merge c pc ss x \\<in> A\"", "lemma pres_typeD2:\n  \"pres_type step n A \\<Longrightarrow> s \\<in> A \\<Longrightarrow> p < n \\<Longrightarrow> snd`set (step p s) \\<subseteq> A\"", "lemma (in lbv) wti_pres [intro?]:\n  assumes pres: \"pres_type step n A\" \n  assumes cert: \"c!(pc+1) \\<in> A\"\n  assumes s_pc: \"s \\<in> A\" \"pc < n\"\n  shows \"wti c pc s \\<in> A\"", "lemma (in lbv) wtc_pres:\n  assumes \"pres_type step n A\"\n  assumes \"c!pc \\<in> A\" and \"c!(pc+1) \\<in> A\"\n  assumes \"s \\<in> A\" and \"pc < n\"\n  shows \"wtc c pc s \\<in> A\"", "lemma (in lbv) wtl_pres:\n  assumes pres: \"pres_type step (length is) A\"\n  assumes cert: \"cert_ok c (length is) \\<top> \\<bottom> A\"\n  assumes s:    \"s \\<in> A\" \n  assumes all:  \"wtl is c 0 s \\<noteq> \\<top>\"\n  shows \"pc < length is \\<Longrightarrow> wtl (take pc is) c 0 s \\<in> A\"\n  (is \"?len pc \\<Longrightarrow> ?wtl pc \\<in> A\")"], "translations": [["", "lemma (in lbv) wti:\n  \"wti c pc s = merge c pc (step pc s) (c!(pc+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wti c pc s = merge c pc (step pc s) (c ! (pc + 1))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wti c pc s = merge c pc (step pc s) (c ! (pc + 1))", "by (simp add: wti_def mrg_def wtl_inst_def)"], ["", "(*>*)"], ["", "lemma (in lbv) wtc: \n  \"wtc c pc s = (if c!pc = \\<bottom> then wti c pc s else if s \\<sqsubseteq>\\<^sub>r c!pc then wti c pc (c!pc) else \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtc c pc s =\n    (if c ! pc = \\<bottom> then wti c pc s\n     else if s \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc then wti c pc (c ! pc)\n          else \\<top>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtc c pc s =\n    (if c ! pc = \\<bottom> then wti c pc s\n     else if s \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc then wti c pc (c ! pc)\n          else \\<top>)", "by (unfold wtc_def wti_def wtl_cert_def) rule"], ["", "(*>*)"], ["", "lemma cert_okD1 [intro?]:\n  \"cert_ok c n T B A \\<Longrightarrow> pc < n \\<Longrightarrow> c!pc \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cert_ok c n T B A; pc < n\\<rbrakk>\n    \\<Longrightarrow> c ! pc \\<in> A", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cert_ok c n T B A; pc < n\\<rbrakk>\n    \\<Longrightarrow> c ! pc \\<in> A", "by (unfold cert_ok_def) fast"], ["", "(*>*)"], ["", "lemma cert_okD2 [intro?]:\n  \"cert_ok c n T B A \\<Longrightarrow> c!n = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cert_ok c n T B A \\<Longrightarrow> c ! n = B", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cert_ok c n T B A \\<Longrightarrow> c ! n = B", "by (simp add: cert_ok_def)"], ["", "(*>*)"], ["", "lemma cert_okD3 [intro?]:\n  \"cert_ok c n T B A \\<Longrightarrow> B \\<in> A \\<Longrightarrow> pc < n \\<Longrightarrow> c!Suc pc \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cert_ok c n T B A; B \\<in> A; pc < n\\<rbrakk>\n    \\<Longrightarrow> c ! Suc pc \\<in> A", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cert_ok c n T B A; B \\<in> A; pc < n\\<rbrakk>\n    \\<Longrightarrow> c ! Suc pc \\<in> A", "by (drule Suc_leI) (auto simp add: le_eq_less_or_eq dest: cert_okD1 cert_okD2)"], ["", "(*>*)"], ["", "lemma cert_okD4 [intro?]:\n  \"cert_ok c n T B A \\<Longrightarrow> pc < n \\<Longrightarrow> c!pc \\<noteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cert_ok c n T B A; pc < n\\<rbrakk>\n    \\<Longrightarrow> c ! pc \\<noteq> T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cert_ok c n T B A; pc < n\\<rbrakk>\n    \\<Longrightarrow> c ! pc \\<noteq> T", "by (simp add: cert_ok_def)"], ["", "(*>*)"], ["", "declare Let_def [simp]"], ["", "subsection \"more semilattice lemmas\""], ["", "lemma (in lbv) sup_top [simp, elim]:\n  assumes x: \"x \\<in> A\" \n  shows \"x \\<squnion>\\<^sub>f \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion>\\<^bsub>f\\<^esub> \\<top> = \\<top>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion>\\<^bsub>f\\<^esub> \\<top> = \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<squnion>\\<^bsub>f\\<^esub> \\<top> = \\<top>", "from top"], ["proof (chain)\npicking this:\n  Semilat.top r \\<top>", "have \"x \\<squnion>\\<^sub>f \\<top> \\<sqsubseteq>\\<^sub>r \\<top>\""], ["proof (prove)\nusing this:\n  Semilat.top r \\<top>\n\ngoal (1 subgoal):\n 1. x \\<squnion>\\<^bsub>f\\<^esub> \\<top> \n    \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<top>", ".."], ["proof (state)\nthis:\n  x \\<squnion>\\<^bsub>f\\<^esub> \\<top> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<top>\n\ngoal (1 subgoal):\n 1. x \\<squnion>\\<^bsub>f\\<^esub> \\<top> = \\<top>", "moreover"], ["proof (state)\nthis:\n  x \\<squnion>\\<^bsub>f\\<^esub> \\<top> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<top>\n\ngoal (1 subgoal):\n 1. x \\<squnion>\\<^bsub>f\\<^esub> \\<top> = \\<top>", "from x T_A"], ["proof (chain)\npicking this:\n  x \\<in> A\n  \\<top> \\<in> A", "have \"\\<top> \\<sqsubseteq>\\<^sub>r x \\<squnion>\\<^sub>f \\<top>\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  \\<top> \\<in> A\n\ngoal (1 subgoal):\n 1. \\<top> \n    \\<sqsubseteq>\\<^bsub>r\\<^esub> x \\<squnion>\\<^bsub>f\\<^esub> \\<top>", ".."], ["proof (state)\nthis:\n  \\<top> \\<sqsubseteq>\\<^bsub>r\\<^esub> x \\<squnion>\\<^bsub>f\\<^esub> \\<top>\n\ngoal (1 subgoal):\n 1. x \\<squnion>\\<^bsub>f\\<^esub> \\<top> = \\<top>", "ultimately"], ["proof (chain)\npicking this:\n  x \\<squnion>\\<^bsub>f\\<^esub> \\<top> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<top>\n  \\<top> \\<sqsubseteq>\\<^bsub>r\\<^esub> x \\<squnion>\\<^bsub>f\\<^esub> \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<squnion>\\<^bsub>f\\<^esub> \\<top> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<top>\n  \\<top> \\<sqsubseteq>\\<^bsub>r\\<^esub> x \\<squnion>\\<^bsub>f\\<^esub> \\<top>\n\ngoal (1 subgoal):\n 1. x \\<squnion>\\<^bsub>f\\<^esub> \\<top> = \\<top>", ".."], ["proof (state)\nthis:\n  x \\<squnion>\\<^bsub>f\\<^esub> \\<top> = \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma (in lbv) plusplussup_top [simp, elim]:\n  \"set xs \\<subseteq> A \\<Longrightarrow> xs \\<Squnion>\\<^bsub>f\\<^esub> \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> A \\<Longrightarrow>\n    xs \\<Squnion>\\<^bsub>f\\<^esub> \\<top> = \\<top>", "by (induct xs) auto"], ["", "lemma (in Semilat) pp_ub1':\n  assumes S: \"snd`set S \\<subseteq> A\" \n  assumes y: \"y \\<in> A\" and ab: \"(a, b) \\<in> set S\" \n  shows \"b \\<sqsubseteq>\\<^sub>r map snd [(p', t') \\<leftarrow> S . p' = a] \\<Squnion>\\<^bsub>f\\<^esub> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sqsubseteq>\\<^bsub>r\\<^esub> map snd\n(filter (\\<lambda>(p', t'). p' = a) S) \n                                     \\<Squnion>\\<^bsub>f\\<^esub> y", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sqsubseteq>\\<^bsub>r\\<^esub> map snd\n(filter (\\<lambda>(p', t'). p' = a) S) \n                                     \\<Squnion>\\<^bsub>f\\<^esub> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<sqsubseteq>\\<^bsub>r\\<^esub> map snd\n(filter (\\<lambda>(p', t'). p' = a) S) \n                                     \\<Squnion>\\<^bsub>f\\<^esub> y", "from S"], ["proof (chain)\npicking this:\n  snd ` set S \\<subseteq> A", "have \"\\<forall>(x,y) \\<in> set S. y \\<in> A\""], ["proof (prove)\nusing this:\n  snd ` set S \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<forall>(x, y)\\<in>set S. y \\<in> A", "by auto"], ["proof (state)\nthis:\n  \\<forall>(x, y)\\<in>set S. y \\<in> A\n\ngoal (1 subgoal):\n 1. b \\<sqsubseteq>\\<^bsub>r\\<^esub> map snd\n(filter (\\<lambda>(p', t'). p' = a) S) \n                                     \\<Squnion>\\<^bsub>f\\<^esub> y", "with Semilat_axioms"], ["proof (chain)\npicking this:\n  Semilat A r f\n  \\<forall>(x, y)\\<in>set S. y \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  Semilat A r f\n  \\<forall>(x, y)\\<in>set S. y \\<in> A\n\ngoal (1 subgoal):\n 1. b \\<sqsubseteq>\\<^bsub>r\\<^esub> map snd\n(filter (\\<lambda>(p', t'). p' = a) S) \n                                     \\<Squnion>\\<^bsub>f\\<^esub> y", "using y ab"], ["proof (prove)\nusing this:\n  Semilat A r f\n  \\<forall>(x, y)\\<in>set S. y \\<in> A\n  y \\<in> A\n  (a, b) \\<in> set S\n\ngoal (1 subgoal):\n 1. b \\<sqsubseteq>\\<^bsub>r\\<^esub> map snd\n(filter (\\<lambda>(p', t'). p' = a) S) \n                                     \\<Squnion>\\<^bsub>f\\<^esub> y", "by (rule ub1')"], ["proof (state)\nthis:\n  b \\<sqsubseteq>\\<^bsub>r\\<^esub> map snd\n                                    (filter (\\<lambda>(p', t'). p' = a) S) \n                                   \\<Squnion>\\<^bsub>f\\<^esub> y\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma (in lbv) bottom_le [simp, intro!]: \"\\<bottom> \\<sqsubseteq>\\<^sub>r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<sqsubseteq>\\<^bsub>r\\<^esub> x", "by (insert bot) (simp add: bottom_def)"], ["", "lemma (in lbv) le_bottom [simp]: \"x \\<sqsubseteq>\\<^sub>r \\<bottom> = (x = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<bottom>) = (x = \\<bottom>)", "by (blast intro: antisym_r)"], ["", "subsection \"merge\""], ["", "lemma (in lbv) merge_Nil [simp]:\n  \"merge c pc [] x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge c pc [] x = x", "by (simp add: mrg_def)"], ["", "lemma (in lbv) merge_Cons [simp]:\n  \"merge c pc (l#ls) x = merge c pc ls (if fst l=pc+1 then snd l +_f x\n                                        else if snd l \\<sqsubseteq>\\<^sub>r c!fst l then x\n                                        else \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge c pc (l # ls) x =\n    merge c pc ls\n     (if fst l = pc + 1 then snd l \\<squnion>\\<^bsub>f\\<^esub> x\n      else if snd l \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! fst l then x\n           else \\<top>)", "by (simp add: mrg_def split_beta)"], ["", "lemma (in lbv) merge_Err [simp]:\n  \"snd`set ss \\<subseteq> A \\<Longrightarrow> merge c pc ss \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set ss \\<subseteq> A \\<Longrightarrow>\n    merge c pc ss \\<top> = \\<top>", "by (induct ss) auto"], ["", "lemma (in lbv) merge_not_top:\n  \"\\<And>x. snd`set ss \\<subseteq> A \\<Longrightarrow> merge c pc ss x \\<noteq> \\<top> \\<Longrightarrow> \n  \\<forall>(pc',s') \\<in> set ss. (pc' \\<noteq> pc+1 \\<longrightarrow> s' \\<sqsubseteq>\\<^sub>r c!pc')\"\n  (is \"\\<And>x. ?set ss \\<Longrightarrow> ?merge ss x \\<Longrightarrow> ?P ss\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>snd ` set ss \\<subseteq> A;\n        merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>snd ` set ss \\<subseteq> A;\n        merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "proof (induct ss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>snd ` set [] \\<subseteq> A;\n        merge c pc [] x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set [].\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n 2. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "show \"?P []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set [].\n       case a of\n       (pc', s') \\<Rightarrow>\n         pc' \\<noteq> pc + 1 \\<longrightarrow>\n         s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set [].\n     case a of\n     (pc', s') \\<Rightarrow>\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "fix x ls l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "assume \"?set (l#ls)\""], ["proof (state)\nthis:\n  snd ` set (l # ls) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "then"], ["proof (chain)\npicking this:\n  snd ` set (l # ls) \\<subseteq> A", "obtain set: \"snd`set ls \\<subseteq> A\""], ["proof (prove)\nusing this:\n  snd ` set (l # ls) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (snd ` set ls \\<subseteq> A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  snd ` set ls \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "assume merge: \"?merge (l#ls) x\""], ["proof (state)\nthis:\n  merge c pc (l # ls) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "moreover"], ["proof (state)\nthis:\n  merge c pc (l # ls) x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "obtain pc' s' where [simp]: \"l = (pc',s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pc' s'. l = (pc', s') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l)"], ["proof (state)\nthis:\n  l = (pc', s')\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "ultimately"], ["proof (chain)\npicking this:\n  merge c pc (l # ls) x \\<noteq> \\<top>\n  l = (pc', s')", "obtain x' where merge': \"?merge ls x'\""], ["proof (prove)\nusing this:\n  merge c pc (l # ls) x \\<noteq> \\<top>\n  l = (pc', s')\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        merge c pc ls x' \\<noteq> \\<top> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  merge c pc ls x' \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "assume \"\\<And>x. ?set ls \\<Longrightarrow> ?merge ls x \\<Longrightarrow> ?P ls\""], ["proof (state)\nthis:\n  \\<lbrakk>snd ` set ls \\<subseteq> A;\n   merge c pc ls ?x \\<noteq> \\<top>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set ls.\n                       case a of\n                       (pc', s') \\<Rightarrow>\n                         pc' \\<noteq> pc + 1 \\<longrightarrow>\n                         s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "hence \"?P ls\""], ["proof (prove)\nusing this:\n  \\<lbrakk>snd ` set ls \\<subseteq> A;\n   merge c pc ls ?x \\<noteq> \\<top>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set ls.\n                       case a of\n                       (pc', s') \\<Rightarrow>\n                         pc' \\<noteq> pc + 1 \\<longrightarrow>\n                         s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set ls.\n       case a of\n       (pc', s') \\<Rightarrow>\n         pc' \\<noteq> pc + 1 \\<longrightarrow>\n         s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "using set merge'"], ["proof (prove)\nusing this:\n  \\<lbrakk>snd ` set ls \\<subseteq> A;\n   merge c pc ls ?x \\<noteq> \\<top>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set ls.\n                       case a of\n                       (pc', s') \\<Rightarrow>\n                         pc' \\<noteq> pc + 1 \\<longrightarrow>\n                         s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n  snd ` set ls \\<subseteq> A\n  merge c pc ls x' \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set ls.\n       case a of\n       (pc', s') \\<Rightarrow>\n         pc' \\<noteq> pc + 1 \\<longrightarrow>\n         s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "."], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ls.\n     case a of\n     (pc', s') \\<Rightarrow>\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "moreover"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ls.\n     case a of\n     (pc', s') \\<Rightarrow>\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "from merge set"], ["proof (chain)\npicking this:\n  merge c pc (l # ls) x \\<noteq> \\<top>\n  snd ` set ls \\<subseteq> A", "have \"pc' \\<noteq> pc+1 \\<longrightarrow> s' \\<sqsubseteq>\\<^sub>r c!pc'\""], ["proof (prove)\nusing this:\n  merge c pc (l # ls) x \\<noteq> \\<top>\n  snd ` set ls \\<subseteq> A\n\ngoal (1 subgoal):\n 1. pc' \\<noteq> pc + 1 \\<longrightarrow>\n    s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>snd ` set ss \\<subseteq> A;\n                    merge c pc ss x \\<noteq> \\<top>\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>(pc', s')\\<in>set ss.\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc';\n        snd ` set (a # ss) \\<subseteq> A;\n        merge c pc (a # ss) x \\<noteq> \\<top>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(pc', s')\\<in>set (a # ss).\n                            pc' \\<noteq> pc + 1 \\<longrightarrow>\n                            s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set ls.\n     case a of\n     (pc', s') \\<Rightarrow>\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "show \"?P (l#ls)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ls.\n     case a of\n     (pc', s') \\<Rightarrow>\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n  pc' \\<noteq> pc + 1 \\<longrightarrow>\n  s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (l # ls).\n       case a of\n       (pc', s') \\<Rightarrow>\n         pc' \\<noteq> pc + 1 \\<longrightarrow>\n         s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (l # ls).\n     case a of\n     (pc', s') \\<Rightarrow>\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma (in lbv) merge_def:\n  shows \n  \"\\<And>x. x \\<in> A \\<Longrightarrow> snd`set ss \\<subseteq> A \\<Longrightarrow>\n  merge c pc ss x = \n  (if \\<forall>(pc',s') \\<in> set ss. pc'\\<noteq>pc+1 \\<longrightarrow> s' \\<sqsubseteq>\\<^sub>r c!pc' then\n    map snd [(p',t') \\<leftarrow> ss. p'=pc+1] \\<Squnion>\\<^bsub>f\\<^esub> x\n  else \\<top>)\" \n  (is \"\\<And>x. _ \\<Longrightarrow> _ \\<Longrightarrow> ?merge ss x = ?if ss x\" is \"\\<And>x. _ \\<Longrightarrow> _ \\<Longrightarrow> ?P ss x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc ss x =\n                         (if \\<forall>(pc', s')\\<in>set ss.\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  ss) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc ss x =\n                         (if \\<forall>(pc', s')\\<in>set ss.\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  ss) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "proof (induct ss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> A; snd ` set [] \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc [] x =\n                         (if \\<forall>(pc', s')\\<in>set [].\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  []) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)\n 2. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> A; snd ` set [] \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc [] x =\n                         (if \\<forall>(pc', s')\\<in>set [].\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  []) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)\n 2. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "show \"?P [] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge c pc [] x =\n    (if \\<forall>a\\<in>set [].\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) []) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "by simp"], ["proof (state)\nthis:\n  merge c pc [] x =\n  (if \\<forall>a\\<in>set [].\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           []) \n        \\<Squnion>\\<^bsub>f\\<^esub> x\n   else \\<top>)\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "assume x: \"x \\<in> A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "fix l::\"nat \\<times> 'a\" and ls"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "assume \"snd`set (l#ls) \\<subseteq> A\""], ["proof (state)\nthis:\n  snd ` set (l # ls) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "then"], ["proof (chain)\npicking this:\n  snd ` set (l # ls) \\<subseteq> A", "obtain l: \"snd l \\<in> A\" and ls: \"snd`set ls \\<subseteq> A\""], ["proof (prove)\nusing this:\n  snd ` set (l # ls) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>snd l \\<in> A; snd ` set ls \\<subseteq> A\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd l \\<in> A\n  snd ` set ls \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "assume \"\\<And>x. x \\<in> A \\<Longrightarrow> snd`set ls \\<subseteq> A \\<Longrightarrow> ?P ls x\""], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> A; snd ` set ls \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> merge c pc ls ?x =\n                    (if \\<forall>a\\<in>set ls.\n                           case a of\n                           (pc', s') \\<Rightarrow>\n                             pc' \\<noteq> pc + 1 \\<longrightarrow>\n                             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                     then map snd\n                           (filter\n                             (\\<lambda>a.\n                                 case a of\n                                 (p', t') \\<Rightarrow> p' = pc + 1)\n                             ls) \n                          \\<Squnion>\\<^bsub>f\\<^esub> ?x\n                     else \\<top>)\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "hence IH: \"\\<And>x. x \\<in> A \\<Longrightarrow> ?P ls x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> A; snd ` set ls \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> merge c pc ls ?x =\n                    (if \\<forall>a\\<in>set ls.\n                           case a of\n                           (pc', s') \\<Rightarrow>\n                             pc' \\<noteq> pc + 1 \\<longrightarrow>\n                             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                     then map snd\n                           (filter\n                             (\\<lambda>a.\n                                 case a of\n                                 (p', t') \\<Rightarrow> p' = pc + 1)\n                             ls) \n                          \\<Squnion>\\<^bsub>f\\<^esub> ?x\n                     else \\<top>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       merge c pc ls x =\n       (if \\<forall>a\\<in>set ls.\n              case a of\n              (pc', s') \\<Rightarrow>\n                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n        then map snd\n              (filter\n                (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n                ls) \n             \\<Squnion>\\<^bsub>f\\<^esub> x\n        else \\<top>)", "using ls"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> A; snd ` set ls \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> merge c pc ls ?x =\n                    (if \\<forall>a\\<in>set ls.\n                           case a of\n                           (pc', s') \\<Rightarrow>\n                             pc' \\<noteq> pc + 1 \\<longrightarrow>\n                             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                     then map snd\n                           (filter\n                             (\\<lambda>a.\n                                 case a of\n                                 (p', t') \\<Rightarrow> p' = pc + 1)\n                             ls) \n                          \\<Squnion>\\<^bsub>f\\<^esub> ?x\n                     else \\<top>)\n  snd ` set ls \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       merge c pc ls x =\n       (if \\<forall>a\\<in>set ls.\n              case a of\n              (pc', s') \\<Rightarrow>\n                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n        then map snd\n              (filter\n                (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n                ls) \n             \\<Squnion>\\<^bsub>f\\<^esub> x\n        else \\<top>)", "by iprover"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow>\n  merge c pc ls ?x =\n  (if \\<forall>a\\<in>set ls.\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           ls) \n        \\<Squnion>\\<^bsub>f\\<^esub> ?x\n   else \\<top>)\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "obtain pc' s' where [simp]: \"l = (pc',s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pc' s'. l = (pc', s') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l)"], ["proof (state)\nthis:\n  l = (pc', s')\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "hence \"?merge (l#ls) x = ?merge ls \n    (if pc'=pc+1 then s' \\<squnion>\\<^sub>f x else if s' \\<sqsubseteq>\\<^sub>r c!pc' then x else \\<top>)\"\n    (is \"?merge (l#ls) x = ?merge ls ?if'\")"], ["proof (prove)\nusing this:\n  l = (pc', s')\n\ngoal (1 subgoal):\n 1. merge c pc (l # ls) x =\n    merge c pc ls\n     (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n      else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)", "by simp"], ["proof (state)\nthis:\n  merge c pc (l # ls) x =\n  merge c pc ls\n   (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n    else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "also"], ["proof (state)\nthis:\n  merge c pc (l # ls) x =\n  merge c pc ls\n   (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n    else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "have \"\\<dots> = ?if ls ?if'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge c pc ls\n     (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n      else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x\n           else \\<top>) =\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merge c pc ls\n     (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n      else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x\n           else \\<top>) =\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>)", "from l"], ["proof (chain)\npicking this:\n  snd l \\<in> A", "have \"s' \\<in> A\""], ["proof (prove)\nusing this:\n  snd l \\<in> A\n\ngoal (1 subgoal):\n 1. s' \\<in> A", "by simp"], ["proof (state)\nthis:\n  s' \\<in> A\n\ngoal (1 subgoal):\n 1. merge c pc ls\n     (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n      else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x\n           else \\<top>) =\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>)", "with x"], ["proof (chain)\npicking this:\n  x \\<in> A\n  s' \\<in> A", "have \"s' \\<squnion>\\<^sub>f x \\<in> A\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  s' \\<in> A\n\ngoal (1 subgoal):\n 1. s' \\<squnion>\\<^bsub>f\\<^esub> x \\<in> A", "by simp"], ["proof (state)\nthis:\n  s' \\<squnion>\\<^bsub>f\\<^esub> x \\<in> A\n\ngoal (1 subgoal):\n 1. merge c pc ls\n     (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n      else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x\n           else \\<top>) =\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>)", "with x T_A"], ["proof (chain)\npicking this:\n  x \\<in> A\n  \\<top> \\<in> A\n  s' \\<squnion>\\<^bsub>f\\<^esub> x \\<in> A", "have \"?if' \\<in> A\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  \\<top> \\<in> A\n  s' \\<squnion>\\<^bsub>f\\<^esub> x \\<in> A\n\ngoal (1 subgoal):\n 1. (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n     else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n    \\<in> A", "by auto"], ["proof (state)\nthis:\n  (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n   else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n  \\<in> A\n\ngoal (1 subgoal):\n 1. merge c pc ls\n     (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n      else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x\n           else \\<top>) =\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>)", "hence \"?P ls ?if'\""], ["proof (prove)\nusing this:\n  (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n   else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n  \\<in> A\n\ngoal (1 subgoal):\n 1. merge c pc ls\n     (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n      else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x\n           else \\<top>) =\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>)", "by (rule IH)"], ["proof (state)\nthis:\n  merge c pc ls\n   (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n    else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>) =\n  (if \\<forall>a\\<in>set ls.\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           ls) \n        \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                                     then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                                     else if s' \n       \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n    then x else \\<top>)\n   else \\<top>)\n\ngoal (1 subgoal):\n 1. merge c pc ls\n     (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n      else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x\n           else \\<top>) =\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  merge c pc ls\n   (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n    else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>) =\n  (if \\<forall>a\\<in>set ls.\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           ls) \n        \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                                     then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                                     else if s' \n       \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n    then x else \\<top>)\n   else \\<top>)\n\ngoal (1 subgoal):\n 1. merge c pc ls\n     (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n      else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x\n           else \\<top>) =\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>)", "by simp"], ["proof (state)\nthis:\n  merge c pc ls\n   (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n    else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>) =\n  (if \\<forall>a\\<in>set ls.\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           ls) \n        \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                                     then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                                     else if s' \n       \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n    then x else \\<top>)\n   else \\<top>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge c pc ls\n   (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n    else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>) =\n  (if \\<forall>a\\<in>set ls.\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           ls) \n        \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                                     then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                                     else if s' \n       \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n    then x else \\<top>)\n   else \\<top>)\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "also"], ["proof (state)\nthis:\n  merge c pc ls\n   (if pc' = pc + 1 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n    else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>) =\n  (if \\<forall>a\\<in>set ls.\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           ls) \n        \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                                     then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                                     else if s' \n       \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n    then x else \\<top>)\n   else \\<top>)\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "have \"\\<dots> = ?if (l#ls) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "proof (cases \"\\<forall>(pc', s')\\<in>set (l#ls). pc'\\<noteq>pc+1 \\<longrightarrow> s' \\<sqsubseteq>\\<^sub>r c!pc'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(pc', s')\\<in>set (l # ls).\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)\n 2. \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n               pc' \\<noteq> pc + 1 \\<longrightarrow>\n               s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc') \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "case True"], ["proof (state)\nthis:\n  \\<forall>(pc', s')\\<in>set (l # ls).\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (2 subgoals):\n 1. \\<forall>(pc', s')\\<in>set (l # ls).\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)\n 2. \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n               pc' \\<noteq> pc + 1 \\<longrightarrow>\n               s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc') \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "hence \"\\<forall>(pc', s')\\<in>set ls. pc'\\<noteq>pc+1 \\<longrightarrow> s' \\<sqsubseteq>\\<^sub>r c!pc'\""], ["proof (prove)\nusing this:\n  \\<forall>(pc', s')\\<in>set (l # ls).\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', s')\\<in>set ls.\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "by auto"], ["proof (state)\nthis:\n  \\<forall>(pc', s')\\<in>set ls.\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (2 subgoals):\n 1. \\<forall>(pc', s')\\<in>set (l # ls).\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)\n 2. \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n               pc' \\<noteq> pc + 1 \\<longrightarrow>\n               s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc') \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>(pc', s')\\<in>set ls.\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (2 subgoals):\n 1. \\<forall>(pc', s')\\<in>set (l # ls).\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)\n 2. \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n               pc' \\<noteq> pc + 1 \\<longrightarrow>\n               s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc') \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "from True"], ["proof (chain)\npicking this:\n  \\<forall>(pc', s')\\<in>set (l # ls).\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "have \n        \"map snd [(p',t') \\<leftarrow> ls . p'=pc+1] \\<Squnion>\\<^bsub>f\\<^esub> ?if' = \n        (map snd [(p',t') \\<leftarrow> l#ls . p'=pc+1] \\<Squnion>\\<^bsub>f\\<^esub> x)\""], ["proof (prove)\nusing this:\n  \\<forall>(pc', s')\\<in>set (l # ls).\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (1 subgoal):\n 1. map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ls) \n    \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                                 then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                                 else if s' \n   \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen x else \\<top>) =\n    map snd (filter (\\<lambda>(p', t'). p' = pc + 1) (l # ls)) \n    \\<Squnion>\\<^bsub>f\\<^esub> x", "by simp"], ["proof (state)\nthis:\n  map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ls) \n  \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                               then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                               else if s' \n \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                                    then x else \\<top>) =\n  map snd (filter (\\<lambda>(p', t'). p' = pc + 1) (l # ls)) \n  \\<Squnion>\\<^bsub>f\\<^esub> x\n\ngoal (2 subgoals):\n 1. \\<forall>(pc', s')\\<in>set (l # ls).\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)\n 2. \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n               pc' \\<noteq> pc + 1 \\<longrightarrow>\n               s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc') \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>(pc', s')\\<in>set ls.\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n  map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ls) \n  \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                               then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                               else if s' \n \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                                    then x else \\<top>) =\n  map snd (filter (\\<lambda>(p', t'). p' = pc + 1) (l # ls)) \n  \\<Squnion>\\<^bsub>f\\<^esub> x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(pc', s')\\<in>set ls.\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n  map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ls) \n  \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                               then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                               else if s' \n \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                                    then x else \\<top>) =\n  map snd (filter (\\<lambda>(p', t'). p' = pc + 1) (l # ls)) \n  \\<Squnion>\\<^bsub>f\\<^esub> x\n\ngoal (1 subgoal):\n 1. (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "using True"], ["proof (prove)\nusing this:\n  \\<forall>(pc', s')\\<in>set ls.\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n  map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ls) \n  \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                               then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                               else if s' \n \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                                    then x else \\<top>) =\n  map snd (filter (\\<lambda>(p', t'). p' = pc + 1) (l # ls)) \n  \\<Squnion>\\<^bsub>f\\<^esub> x\n  \\<forall>(pc', s')\\<in>set (l # ls).\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (1 subgoal):\n 1. (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "by simp"], ["proof (state)\nthis:\n  (if \\<forall>a\\<in>set ls.\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           ls) \n        \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                                     then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                                     else if s' \n       \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n    then x else \\<top>)\n   else \\<top>) =\n  (if \\<forall>a\\<in>set (l # ls).\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           (l # ls)) \n        \\<Squnion>\\<^bsub>f\\<^esub> x\n   else \\<top>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n               pc' \\<noteq> pc + 1 \\<longrightarrow>\n               s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc') \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n               pc' \\<noteq> pc + 1 \\<longrightarrow>\n               s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc') \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n               pc' \\<noteq> pc + 1 \\<longrightarrow>\n               s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc') \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n               pc' \\<noteq> pc + 1 \\<longrightarrow>\n               s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc') \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "from ls"], ["proof (chain)\npicking this:\n  snd ` set ls \\<subseteq> A", "have \"set (map snd [(p', t') \\<leftarrow> ls . p' = Suc pc]) \\<subseteq> A\""], ["proof (prove)\nusing this:\n  snd ` set ls \\<subseteq> A\n\ngoal (1 subgoal):\n 1. set (map snd (filter (\\<lambda>(p', t'). p' = Suc pc) ls)) \\<subseteq> A", "by auto"], ["proof (state)\nthis:\n  set (map snd (filter (\\<lambda>(p', t'). p' = Suc pc) ls)) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n               pc' \\<noteq> pc + 1 \\<longrightarrow>\n               s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc') \\<Longrightarrow>\n    (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc')\n  set (map snd (filter (\\<lambda>(p', t'). p' = Suc pc) ls)) \\<subseteq> A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>(pc', s')\\<in>set (l # ls).\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc')\n  set (map snd (filter (\\<lambda>(p', t'). p' = Suc pc) ls)) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (if \\<forall>a\\<in>set ls.\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1) ls) \n          \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n then s' \\<squnion>\\<^bsub>f\\<^esub> x\n else if s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc' then x else \\<top>)\n     else \\<top>) =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "by auto"], ["proof (state)\nthis:\n  (if \\<forall>a\\<in>set ls.\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           ls) \n        \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                                     then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                                     else if s' \n       \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n    then x else \\<top>)\n   else \\<top>) =\n  (if \\<forall>a\\<in>set (l # ls).\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           (l # ls)) \n        \\<Squnion>\\<^bsub>f\\<^esub> x\n   else \\<top>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if \\<forall>a\\<in>set ls.\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           ls) \n        \\<Squnion>\\<^bsub>f\\<^esub> (if pc' = pc + 1\n                                     then s' \\<squnion>\\<^bsub>f\\<^esub> x\n                                     else if s' \n       \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n    then x else \\<top>)\n   else \\<top>) =\n  (if \\<forall>a\\<in>set (l # ls).\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           (l # ls)) \n        \\<Squnion>\\<^bsub>f\\<^esub> x\n   else \\<top>)\n\ngoal (1 subgoal):\n 1. \\<And>a ss x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> A; snd ` set ss \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> merge c pc ss x =\n                                     (if \\<forall>(pc', s')\\<in>set ss.\n      pc' \\<noteq> pc + 1 \\<longrightarrow>\n      s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\nthen map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n     \\<Squnion>\\<^bsub>f\\<^esub> x\nelse \\<top>);\n        x \\<in> A; snd ` set (a # ss) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> merge c pc (a # ss) x =\n                         (if \\<forall>(pc', s')\\<in>set (a # ss).\n                                pc' \\<noteq> pc + 1 \\<longrightarrow>\n                                s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n                          then map snd\n                                (filter (\\<lambda>(p', t'). p' = pc + 1)\n                                  (a # ss)) \n                               \\<Squnion>\\<^bsub>f\\<^esub> x\n                          else \\<top>)", "finally"], ["proof (chain)\npicking this:\n  merge c pc (l # ls) x =\n  (if \\<forall>a\\<in>set (l # ls).\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           (l # ls)) \n        \\<Squnion>\\<^bsub>f\\<^esub> x\n   else \\<top>)", "show \"?P (l#ls) x\""], ["proof (prove)\nusing this:\n  merge c pc (l # ls) x =\n  (if \\<forall>a\\<in>set (l # ls).\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           (l # ls)) \n        \\<Squnion>\\<^bsub>f\\<^esub> x\n   else \\<top>)\n\ngoal (1 subgoal):\n 1. merge c pc (l # ls) x =\n    (if \\<forall>a\\<in>set (l # ls).\n           case a of\n           (pc', s') \\<Rightarrow>\n             pc' \\<noteq> pc + 1 \\<longrightarrow>\n             s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n     then map snd\n           (filter\n             (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n             (l # ls)) \n          \\<Squnion>\\<^bsub>f\\<^esub> x\n     else \\<top>)", "."], ["proof (state)\nthis:\n  merge c pc (l # ls) x =\n  (if \\<forall>a\\<in>set (l # ls).\n         case a of\n         (pc', s') \\<Rightarrow>\n           pc' \\<noteq> pc + 1 \\<longrightarrow>\n           s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n   then map snd\n         (filter (\\<lambda>a. case a of (p', t') \\<Rightarrow> p' = pc + 1)\n           (l # ls)) \n        \\<Squnion>\\<^bsub>f\\<^esub> x\n   else \\<top>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma (in lbv) merge_not_top_s:\n  assumes x:  \"x \\<in> A\" and ss: \"snd`set ss \\<subseteq> A\"\n  assumes m:  \"merge c pc ss x \\<noteq> \\<top>\"\n  shows \"merge c pc ss x = (map snd [(p',t') \\<leftarrow> ss. p'=pc+1] \\<Squnion>\\<^bsub>f\\<^esub> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge c pc ss x =\n    map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n    \\<Squnion>\\<^bsub>f\\<^esub> x", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge c pc ss x =\n    map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n    \\<Squnion>\\<^bsub>f\\<^esub> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merge c pc ss x =\n    map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n    \\<Squnion>\\<^bsub>f\\<^esub> x", "from ss m"], ["proof (chain)\npicking this:\n  snd ` set ss \\<subseteq> A\n  merge c pc ss x \\<noteq> \\<top>", "have \"\\<forall>(pc',s') \\<in> set ss. (pc' \\<noteq> pc+1 \\<longrightarrow> s' <=_r c!pc')\""], ["proof (prove)\nusing this:\n  snd ` set ss \\<subseteq> A\n  merge c pc ss x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<forall>(pc', s')\\<in>set ss.\n       pc' \\<noteq> pc + 1 \\<longrightarrow>\n       s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "by (rule merge_not_top)"], ["proof (state)\nthis:\n  \\<forall>(pc', s')\\<in>set ss.\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (1 subgoal):\n 1. merge c pc ss x =\n    map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n    \\<Squnion>\\<^bsub>f\\<^esub> x", "with x ss m"], ["proof (chain)\npicking this:\n  x \\<in> A\n  snd ` set ss \\<subseteq> A\n  merge c pc ss x \\<noteq> \\<top>\n  \\<forall>(pc', s')\\<in>set ss.\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> A\n  snd ` set ss \\<subseteq> A\n  merge c pc ss x \\<noteq> \\<top>\n  \\<forall>(pc', s')\\<in>set ss.\n     pc' \\<noteq> pc + 1 \\<longrightarrow>\n     s' \\<sqsubseteq>\\<^bsub>r\\<^esub> c ! pc'\n\ngoal (1 subgoal):\n 1. merge c pc ss x =\n    map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n    \\<Squnion>\\<^bsub>f\\<^esub> x", "by - (drule merge_def, auto split: if_split_asm)"], ["proof (state)\nthis:\n  merge c pc ss x =\n  map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n  \\<Squnion>\\<^bsub>f\\<^esub> x\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "subsection \"wtl-inst-list\""], ["", "lemmas [iff] = not_Err_eq"], ["", "lemma (in lbv) wtl_Nil [simp]: \"wtl [] c pc s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtl [] c pc s = s", "by (simp add: wtl_def)"], ["", "lemma (in lbv) wtl_Cons [simp]: \n  \"wtl (i#is) c pc s = \n  (let s' = wtc c pc s in if s' = \\<top> \\<or> s = \\<top> then \\<top> else wtl is c (pc+1) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtl (i # is) c pc s =\n    (let s' = wtc c pc s\n     in if s' = \\<top> \\<or> s = \\<top> then \\<top>\n        else wtl is c (pc + 1) s')", "by (simp add: wtl_def wtc_def)"], ["", "lemma (in lbv) wtl_Cons_not_top:\n  \"wtl (i#is) c pc s \\<noteq> \\<top> = \n  (wtc c pc s \\<noteq> \\<top> \\<and> s \\<noteq> T \\<and> wtl is c (pc+1) (wtc c pc s) \\<noteq> \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wtl (i # is) c pc s \\<noteq> \\<top>) =\n    (wtc c pc s \\<noteq> \\<top> \\<and>\n     s \\<noteq> \\<top> \\<and>\n     wtl is c (pc + 1) (wtc c pc s) \\<noteq> \\<top>)", "by (auto simp del: split_paired_Ex)"], ["", "lemma (in lbv) wtl_top [simp]:  \"wtl ls c pc \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtl ls c pc \\<top> = \\<top>", "by (cases ls) auto"], ["", "lemma (in lbv) wtl_not_top:\n  \"wtl ls c pc s \\<noteq> \\<top> \\<Longrightarrow> s \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtl ls c pc s \\<noteq> \\<top> \\<Longrightarrow> s \\<noteq> \\<top>", "by (cases \"s=\\<top>\") auto"], ["", "lemma (in lbv) wtl_append [simp]:\n  \"\\<And>pc s. wtl (a@b) c pc s = wtl b c (pc+length a) (wtl a c pc s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pc s. wtl (a @ b) c pc s = wtl b c (pc + length a) (wtl a c pc s)", "by (induct a) auto"], ["", "lemma (in lbv) wtl_take:\n  \"wtl is c pc s \\<noteq> \\<top> \\<Longrightarrow> wtl (take pc' is) c pc s \\<noteq> \\<top>\"\n  (is \"?wtl is \\<noteq> _ \\<Longrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtl is c pc s \\<noteq> \\<top> \\<Longrightarrow>\n    wtl (take pc' is) c pc s \\<noteq> \\<top>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtl is c pc s \\<noteq> \\<top> \\<Longrightarrow>\n    wtl (take pc' is) c pc s \\<noteq> \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wtl is c pc s \\<noteq> \\<top> \\<Longrightarrow>\n    wtl (take pc' is) c pc s \\<noteq> \\<top>", "assume \"?wtl is \\<noteq> \\<top>\""], ["proof (state)\nthis:\n  wtl is c pc s \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. wtl is c pc s \\<noteq> \\<top> \\<Longrightarrow>\n    wtl (take pc' is) c pc s \\<noteq> \\<top>", "hence \"?wtl (take pc' is @ drop pc' is) \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  wtl is c pc s \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. wtl (take pc' is @ drop pc' is) c pc s \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  wtl (take pc' is @ drop pc' is) c pc s \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. wtl is c pc s \\<noteq> \\<top> \\<Longrightarrow>\n    wtl (take pc' is) c pc s \\<noteq> \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  wtl (take pc' is @ drop pc' is) c pc s \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. wtl (take pc' is) c pc s \\<noteq> \\<top>", "by (auto dest!: wtl_not_top simp del: append_take_drop_id)"], ["proof (state)\nthis:\n  wtl (take pc' is) c pc s \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma take_Suc:\n  \"\\<forall>n. n < length l \\<longrightarrow> take (Suc n) l = (take n l)@[l!n]\" (is \"?P l\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<length l. take (Suc n) l = take n l @ [l ! n]", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<length l. take (Suc n) l = take n l @ [l ! n]", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>n<length []. take (Suc n) [] = take n [] @ [[] ! n]\n 2. \\<And>a l.\n       \\<forall>n<length l.\n          take (Suc n) l = take n l @ [l ! n] \\<Longrightarrow>\n       \\<forall>n<length (a # l).\n          take (Suc n) (a # l) = take n (a # l) @ [(a # l) ! n]", "show \"?P []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<length []. take (Suc n) [] = take n [] @ [[] ! n]", "by simp"], ["proof (state)\nthis:\n  \\<forall>n<length []. take (Suc n) [] = take n [] @ [[] ! n]\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<forall>n<length l.\n          take (Suc n) l = take n l @ [l ! n] \\<Longrightarrow>\n       \\<forall>n<length (a # l).\n          take (Suc n) (a # l) = take n (a # l) @ [(a # l) ! n]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<forall>n<length l.\n          take (Suc n) l = take n l @ [l ! n] \\<Longrightarrow>\n       \\<forall>n<length (a # l).\n          take (Suc n) (a # l) = take n (a # l) @ [(a # l) ! n]", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<forall>n<length l.\n          take (Suc n) l = take n l @ [l ! n] \\<Longrightarrow>\n       \\<forall>n<length (a # l).\n          take (Suc n) (a # l) = take n (a # l) @ [(a # l) ! n]", "assume IH: \"?P xs\""], ["proof (state)\nthis:\n  \\<forall>n<length xs. take (Suc n) xs = take n xs @ [xs ! n]\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<forall>n<length l.\n          take (Suc n) l = take n l @ [l ! n] \\<Longrightarrow>\n       \\<forall>n<length (a # l).\n          take (Suc n) (a # l) = take n (a # l) @ [(a # l) ! n]", "show \"?P (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<length (x # xs).\n       take (Suc n) (x # xs) = take n (x # xs) @ [(x # xs) ! n]", "proof (intro strip)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length (x # xs) \\<Longrightarrow>\n       take (Suc n) (x # xs) = take n (x # xs) @ [(x # xs) ! n]", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length (x # xs) \\<Longrightarrow>\n       take (Suc n) (x # xs) = take n (x # xs) @ [(x # xs) ! n]", "assume \"n < length (x#xs)\""], ["proof (state)\nthis:\n  n < length (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length (x # xs) \\<Longrightarrow>\n       take (Suc n) (x # xs) = take n (x # xs) @ [(x # xs) ! n]", "with IH"], ["proof (chain)\npicking this:\n  \\<forall>n<length xs. take (Suc n) xs = take n xs @ [xs ! n]\n  n < length (x # xs)", "show \"take (Suc n) (x # xs) = take n (x # xs) @ [(x # xs) ! n]\""], ["proof (prove)\nusing this:\n  \\<forall>n<length xs. take (Suc n) xs = take n xs @ [xs ! n]\n  n < length (x # xs)\n\ngoal (1 subgoal):\n 1. take (Suc n) (x # xs) = take n (x # xs) @ [(x # xs) ! n]", "by (cases n, auto)"], ["proof (state)\nthis:\n  take (Suc n) (x # xs) = take n (x # xs) @ [(x # xs) ! n]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n<length (x # xs).\n     take (Suc n) (x # xs) = take n (x # xs) @ [(x # xs) ! n]\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma (in lbv) wtl_Suc:\n  assumes suc: \"pc+1 < length is\"\n  assumes wtl: \"wtl (take pc is) c 0 s \\<noteq> \\<top>\"\n  shows \"wtl (take (pc+1) is) c 0 s = wtc c pc (wtl (take pc is) c 0 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtl (take (pc + 1) is) c 0 s = wtc c pc (wtl (take pc is) c 0 s)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtl (take (pc + 1) is) c 0 s = wtc c pc (wtl (take pc is) c 0 s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wtl (take (pc + 1) is) c 0 s = wtc c pc (wtl (take pc is) c 0 s)", "from suc"], ["proof (chain)\npicking this:\n  pc + 1 < length is", "have \"take (pc+1) is=(take pc is)@[is!pc]\""], ["proof (prove)\nusing this:\n  pc + 1 < length is\n\ngoal (1 subgoal):\n 1. take (pc + 1) is = take pc is @ [is ! pc]", "by (simp add: take_Suc)"], ["proof (state)\nthis:\n  take (pc + 1) is = take pc is @ [is ! pc]\n\ngoal (1 subgoal):\n 1. wtl (take (pc + 1) is) c 0 s = wtc c pc (wtl (take pc is) c 0 s)", "with suc wtl"], ["proof (chain)\npicking this:\n  pc + 1 < length is\n  wtl (take pc is) c 0 s \\<noteq> \\<top>\n  take (pc + 1) is = take pc is @ [is ! pc]", "show ?thesis"], ["proof (prove)\nusing this:\n  pc + 1 < length is\n  wtl (take pc is) c 0 s \\<noteq> \\<top>\n  take (pc + 1) is = take pc is @ [is ! pc]\n\ngoal (1 subgoal):\n 1. wtl (take (pc + 1) is) c 0 s = wtc c pc (wtl (take pc is) c 0 s)", "by (simp add: min_def)"], ["proof (state)\nthis:\n  wtl (take (pc + 1) is) c 0 s = wtc c pc (wtl (take pc is) c 0 s)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma (in lbv) wtl_all:\n  assumes all: \"wtl is c 0 s \\<noteq> \\<top>\" (is \"?wtl is \\<noteq> _\") \n  assumes pc:  \"pc < length is\"\n  shows  \"wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>", "from pc"], ["proof (chain)\npicking this:\n  pc < length is", "have \"0 < length (drop pc is)\""], ["proof (prove)\nusing this:\n  pc < length is\n\ngoal (1 subgoal):\n 1. 0 < length (drop pc is)", "by simp"], ["proof (state)\nthis:\n  0 < length (drop pc is)\n\ngoal (1 subgoal):\n 1. wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>", "then"], ["proof (chain)\npicking this:\n  0 < length (drop pc is)", "obtain i r where Cons: \"drop pc is = i#r\""], ["proof (prove)\nusing this:\n  0 < length (drop pc is)\n\ngoal (1 subgoal):\n 1. (\\<And>i r.\n        drop pc is = i # r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: neq_Nil_conv simp del: length_drop drop_eq_Nil)"], ["proof (state)\nthis:\n  drop pc is = i # r\n\ngoal (1 subgoal):\n 1. wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>", "hence \"i#r = drop pc is\""], ["proof (prove)\nusing this:\n  drop pc is = i # r\n\ngoal (1 subgoal):\n 1. i # r = drop pc is", ".."], ["proof (state)\nthis:\n  i # r = drop pc is\n\ngoal (1 subgoal):\n 1. wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>", "with all"], ["proof (chain)\npicking this:\n  wtl is c 0 s \\<noteq> \\<top>\n  i # r = drop pc is", "have take: \"?wtl (take pc is@i#r) \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  wtl is c 0 s \\<noteq> \\<top>\n  i # r = drop pc is\n\ngoal (1 subgoal):\n 1. wtl (take pc is @ i # r) c 0 s \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  wtl (take pc is @ i # r) c 0 s \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>", "from pc"], ["proof (chain)\npicking this:\n  pc < length is", "have \"is!pc = drop pc is ! 0\""], ["proof (prove)\nusing this:\n  pc < length is\n\ngoal (1 subgoal):\n 1. is ! pc = drop pc is ! 0", "by simp"], ["proof (state)\nthis:\n  is ! pc = drop pc is ! 0\n\ngoal (1 subgoal):\n 1. wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>", "with Cons"], ["proof (chain)\npicking this:\n  drop pc is = i # r\n  is ! pc = drop pc is ! 0", "have \"is!pc = i\""], ["proof (prove)\nusing this:\n  drop pc is = i # r\n  is ! pc = drop pc is ! 0\n\ngoal (1 subgoal):\n 1. is ! pc = i", "by simp"], ["proof (state)\nthis:\n  is ! pc = i\n\ngoal (1 subgoal):\n 1. wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>", "with take pc"], ["proof (chain)\npicking this:\n  wtl (take pc is @ i # r) c 0 s \\<noteq> \\<top>\n  pc < length is\n  is ! pc = i", "show ?thesis"], ["proof (prove)\nusing this:\n  wtl (take pc is @ i # r) c 0 s \\<noteq> \\<top>\n  pc < length is\n  is ! pc = i\n\ngoal (1 subgoal):\n 1. wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>", "by (auto simp add: min_def split: if_split_asm)"], ["proof (state)\nthis:\n  wtc c pc (wtl (take pc is) c 0 s) \\<noteq> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "subsection \"preserves-type\""], ["", "lemma (in lbv) merge_pres:\n  assumes s0: \"snd`set ss \\<subseteq> A\" and x: \"x \\<in> A\"\n  shows \"merge c pc ss x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge c pc ss x \\<in> A", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge c pc ss x \\<in> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merge c pc ss x \\<in> A", "from s0"], ["proof (chain)\npicking this:\n  snd ` set ss \\<subseteq> A", "have \"set (map snd [(p', t') \\<leftarrow> ss . p'=pc+1]) \\<subseteq> A\""], ["proof (prove)\nusing this:\n  snd ` set ss \\<subseteq> A\n\ngoal (1 subgoal):\n 1. set (map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss)) \\<subseteq> A", "by auto"], ["proof (state)\nthis:\n  set (map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss)) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. merge c pc ss x \\<in> A", "with x semilat Semilat_axioms"], ["proof (chain)\npicking this:\n  x \\<in> A\n  semilat (A, r, f)\n  Semilat A r f\n  set (map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss)) \\<subseteq> A", "have \"(map snd [(p', t') \\<leftarrow> ss . p'=pc+1] \\<Squnion>\\<^bsub>f\\<^esub> x) \\<in> A\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  semilat (A, r, f)\n  Semilat A r f\n  set (map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss)) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n    \\<Squnion>\\<^bsub>f\\<^esub> x\n    \\<in> A", "by (auto intro!: plusplus_closed)"], ["proof (state)\nthis:\n  map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n  \\<Squnion>\\<^bsub>f\\<^esub> x\n  \\<in> A\n\ngoal (1 subgoal):\n 1. merge c pc ss x \\<in> A", "with s0 x"], ["proof (chain)\npicking this:\n  snd ` set ss \\<subseteq> A\n  x \\<in> A\n  map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n  \\<Squnion>\\<^bsub>f\\<^esub> x\n  \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  snd ` set ss \\<subseteq> A\n  x \\<in> A\n  map snd (filter (\\<lambda>(p', t'). p' = pc + 1) ss) \n  \\<Squnion>\\<^bsub>f\\<^esub> x\n  \\<in> A\n\ngoal (1 subgoal):\n 1. merge c pc ss x \\<in> A", "by (simp add: merge_def T_A)"], ["proof (state)\nthis:\n  merge c pc ss x \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma pres_typeD2:\n  \"pres_type step n A \\<Longrightarrow> s \\<in> A \\<Longrightarrow> p < n \\<Longrightarrow> snd`set (step p s) \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pres_type step n A; s \\<in> A; p < n\\<rbrakk>\n    \\<Longrightarrow> snd ` set (step p s) \\<subseteq> A", "by auto (drule pres_typeD)"], ["", "lemma (in lbv) wti_pres [intro?]:\n  assumes pres: \"pres_type step n A\" \n  assumes cert: \"c!(pc+1) \\<in> A\"\n  assumes s_pc: \"s \\<in> A\" \"pc < n\"\n  shows \"wti c pc s \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wti c pc s \\<in> A", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wti c pc s \\<in> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wti c pc s \\<in> A", "from pres s_pc"], ["proof (chain)\npicking this:\n  pres_type step n A\n  s \\<in> A\n  pc < n", "have \"snd`set (step pc s) \\<subseteq> A\""], ["proof (prove)\nusing this:\n  pres_type step n A\n  s \\<in> A\n  pc < n\n\ngoal (1 subgoal):\n 1. snd ` set (step pc s) \\<subseteq> A", "by (rule pres_typeD2)"], ["proof (state)\nthis:\n  snd ` set (step pc s) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. wti c pc s \\<in> A", "with cert"], ["proof (chain)\npicking this:\n  c ! (pc + 1) \\<in> A\n  snd ` set (step pc s) \\<subseteq> A", "show ?thesis"], ["proof (prove)\nusing this:\n  c ! (pc + 1) \\<in> A\n  snd ` set (step pc s) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. wti c pc s \\<in> A", "by (simp add: wti merge_pres)"], ["proof (state)\nthis:\n  wti c pc s \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma (in lbv) wtc_pres:\n  assumes \"pres_type step n A\"\n  assumes \"c!pc \\<in> A\" and \"c!(pc+1) \\<in> A\"\n  assumes \"s \\<in> A\" and \"pc < n\"\n  shows \"wtc c pc s \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wtc c pc s \\<in> A", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wtc c pc s \\<in> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wtc c pc s \\<in> A", "have \"wti c pc s \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wti c pc s \\<in> A", "using assms(1,3-5)"], ["proof (prove)\nusing this:\n  pres_type step n A\n  c ! (pc + 1) \\<in> A\n  s \\<in> A\n  pc < n\n\ngoal (1 subgoal):\n 1. wti c pc s \\<in> A", ".."], ["proof (state)\nthis:\n  wti c pc s \\<in> A\n\ngoal (1 subgoal):\n 1. wtc c pc s \\<in> A", "moreover"], ["proof (state)\nthis:\n  wti c pc s \\<in> A\n\ngoal (1 subgoal):\n 1. wtc c pc s \\<in> A", "have \"wti c pc (c!pc) \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wti c pc (c ! pc) \\<in> A", "using assms(1,3,2,5)"], ["proof (prove)\nusing this:\n  pres_type step n A\n  c ! (pc + 1) \\<in> A\n  c ! pc \\<in> A\n  pc < n\n\ngoal (1 subgoal):\n 1. wti c pc (c ! pc) \\<in> A", ".."], ["proof (state)\nthis:\n  wti c pc (c ! pc) \\<in> A\n\ngoal (1 subgoal):\n 1. wtc c pc s \\<in> A", "ultimately"], ["proof (chain)\npicking this:\n  wti c pc s \\<in> A\n  wti c pc (c ! pc) \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  wti c pc s \\<in> A\n  wti c pc (c ! pc) \\<in> A\n\ngoal (1 subgoal):\n 1. wtc c pc s \\<in> A", "using T_A"], ["proof (prove)\nusing this:\n  wti c pc s \\<in> A\n  wti c pc (c ! pc) \\<in> A\n  \\<top> \\<in> A\n\ngoal (1 subgoal):\n 1. wtc c pc s \\<in> A", "by (simp add: wtc)"], ["proof (state)\nthis:\n  wtc c pc s \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma (in lbv) wtl_pres:\n  assumes pres: \"pres_type step (length is) A\"\n  assumes cert: \"cert_ok c (length is) \\<top> \\<bottom> A\"\n  assumes s:    \"s \\<in> A\" \n  assumes all:  \"wtl is c 0 s \\<noteq> \\<top>\"\n  shows \"pc < length is \\<Longrightarrow> wtl (take pc is) c 0 s \\<in> A\"\n  (is \"?len pc \\<Longrightarrow> ?wtl pc \\<in> A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length is \\<Longrightarrow> wtl (take pc is) c 0 s \\<in> A", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length is \\<Longrightarrow> wtl (take pc is) c 0 s \\<in> A", "proof (induct pc)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length is \\<Longrightarrow> wtl (take 0 is) c 0 s \\<in> A\n 2. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "from s"], ["proof (chain)\npicking this:\n  s \\<in> A", "show \"?wtl 0 \\<in> A\""], ["proof (prove)\nusing this:\n  s \\<in> A\n\ngoal (1 subgoal):\n 1. wtl (take 0 is) c 0 s \\<in> A", "by simp"], ["proof (state)\nthis:\n  wtl (take 0 is) c 0 s \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "assume Suc_n: \"Suc n < length is\""], ["proof (state)\nthis:\n  Suc n < length is\n\ngoal (1 subgoal):\n 1. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "hence n1: \"n+1 < length is\""], ["proof (prove)\nusing this:\n  Suc n < length is\n\ngoal (1 subgoal):\n 1. n + 1 < length is", "by simp"], ["proof (state)\nthis:\n  n + 1 < length is\n\ngoal (1 subgoal):\n 1. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "then"], ["proof (chain)\npicking this:\n  n + 1 < length is", "obtain n: \"n < length is\""], ["proof (prove)\nusing this:\n  n + 1 < length is\n\ngoal (1 subgoal):\n 1. (n < length is \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by simp"], ["proof (state)\nthis:\n  n < length is\n\ngoal (1 subgoal):\n 1. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "assume \"n < length is \\<Longrightarrow> ?wtl n \\<in> A\""], ["proof (state)\nthis:\n  n < length is \\<Longrightarrow> wtl (take n is) c 0 s \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "hence \"?wtl n \\<in> A\""], ["proof (prove)\nusing this:\n  n < length is \\<Longrightarrow> wtl (take n is) c 0 s \\<in> A\n\ngoal (1 subgoal):\n 1. wtl (take n is) c 0 s \\<in> A", "using n"], ["proof (prove)\nusing this:\n  n < length is \\<Longrightarrow> wtl (take n is) c 0 s \\<in> A\n  n < length is\n\ngoal (1 subgoal):\n 1. wtl (take n is) c 0 s \\<in> A", "."], ["proof (state)\nthis:\n  wtl (take n is) c 0 s \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "from pres _ _ this n"], ["proof (chain)\npicking this:\n  pres_type step (length is) A\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  wtl (take n is) c 0 s \\<in> A\n  n < length is", "have \"wtc c n (?wtl n) \\<in> A\""], ["proof (prove)\nusing this:\n  pres_type step (length is) A\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  wtl (take n is) c 0 s \\<in> A\n  n < length is\n\ngoal (1 subgoal):\n 1. wtc c n (wtl (take n is) c 0 s) \\<in> A", "proof (rule wtc_pres)"], ["proof (state)\ngoal (2 subgoals):\n 1. c ! n \\<in> A\n 2. c ! (n + 1) \\<in> A", "from cert n"], ["proof (chain)\npicking this:\n  cert_ok c (length is) \\<top> \\<bottom> A\n  n < length is", "show \"c!n \\<in> A\""], ["proof (prove)\nusing this:\n  cert_ok c (length is) \\<top> \\<bottom> A\n  n < length is\n\ngoal (1 subgoal):\n 1. c ! n \\<in> A", "by (rule cert_okD1)"], ["proof (state)\nthis:\n  c ! n \\<in> A\n\ngoal (1 subgoal):\n 1. c ! (n + 1) \\<in> A", "from cert n1"], ["proof (chain)\npicking this:\n  cert_ok c (length is) \\<top> \\<bottom> A\n  n + 1 < length is", "show \"c!(n+1) \\<in> A\""], ["proof (prove)\nusing this:\n  cert_ok c (length is) \\<top> \\<bottom> A\n  n + 1 < length is\n\ngoal (1 subgoal):\n 1. c ! (n + 1) \\<in> A", "by (rule cert_okD1)"], ["proof (state)\nthis:\n  c ! (n + 1) \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wtc c n (wtl (take n is) c 0 s) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "also"], ["proof (state)\nthis:\n  wtc c n (wtl (take n is) c 0 s) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "from all n"], ["proof (chain)\npicking this:\n  wtl is c 0 s \\<noteq> \\<top>\n  n < length is", "have \"?wtl n \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  wtl is c 0 s \\<noteq> \\<top>\n  n < length is\n\ngoal (1 subgoal):\n 1. wtl (take n is) c 0 s \\<noteq> \\<top>", "by - (rule wtl_take)"], ["proof (state)\nthis:\n  wtl (take n is) c 0 s \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "with n1"], ["proof (chain)\npicking this:\n  n + 1 < length is\n  wtl (take n is) c 0 s \\<noteq> \\<top>", "have \"wtc c n (?wtl n) = ?wtl (n+1)\""], ["proof (prove)\nusing this:\n  n + 1 < length is\n  wtl (take n is) c 0 s \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. wtc c n (wtl (take n is) c 0 s) = wtl (take (n + 1) is) c 0 s", "by (rule wtl_Suc [symmetric])"], ["proof (state)\nthis:\n  wtc c n (wtl (take n is) c 0 s) = wtl (take (n + 1) is) c 0 s\n\ngoal (1 subgoal):\n 1. \\<And>pc.\n       \\<lbrakk>pc < length is \\<Longrightarrow>\n                wtl (take pc is) c 0 s \\<in> A;\n        Suc pc < length is\\<rbrakk>\n       \\<Longrightarrow> wtl (take (Suc pc) is) c 0 s \\<in> A", "finally"], ["proof (chain)\npicking this:\n  wtl (take (n + 1) is) c 0 s \\<in> A", "show \"?wtl (Suc n) \\<in> A\""], ["proof (prove)\nusing this:\n  wtl (take (n + 1) is) c 0 s \\<in> A\n\ngoal (1 subgoal):\n 1. wtl (take (Suc n) is) c 0 s \\<in> A", "by simp"], ["proof (state)\nthis:\n  wtl (take (Suc n) is) c 0 s \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"]]}