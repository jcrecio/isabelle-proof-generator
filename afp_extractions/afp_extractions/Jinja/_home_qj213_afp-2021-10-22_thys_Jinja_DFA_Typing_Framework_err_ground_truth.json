{"file_name": "/home/qj213/afp-2021-10-22/thys/Jinja/DFA/Typing_Framework_err.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jinja", "problem_names": ["lemmas err_step_defs = err_step_def map_snd_def error_def", "lemma bounded_err_stepD:\n  \"\\<lbrakk> bounded (err_step n app step) n;\n     p < n; app p a; (q,b) \\<in> set (step p a) \\<rbrakk> \\<Longrightarrow> q < n\"", "lemma in_map_sndD: \"(a,b) \\<in> set (map_snd f xs) \\<Longrightarrow> \\<exists>b'. (a,b') \\<in> set xs\"", "lemma bounded_err_stepI:\n  \"\\<forall>p. p < n \\<longrightarrow> (\\<forall>s. ap p s \\<longrightarrow> (\\<forall>(q,s') \\<in> set (step p s). q < n))\n  \\<Longrightarrow> bounded (err_step n ap step) n\"", "lemma bounded_lift:\n  \"bounded step n \\<Longrightarrow> bounded (err_step n app step) n\"", "lemma le_list_map_OK [simp]:\n  \"\\<And>b. (map OK a [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) = (a [\\<sqsubseteq>\\<^sub>r] b)\"", "lemma map_snd_lessI:\n  \"set xs {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set ys \\<Longrightarrow> set (map_snd OK xs) {\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>} set (map_snd OK ys)\"", "lemma mono_lift:\n  \"\\<lbrakk> order r; app_mono r app n A; bounded (err_step n app step) n;\n    \\<forall>s p t. s \\<in> A \\<and> p < n \\<and> s \\<sqsubseteq>\\<^sub>r t \\<longrightarrow> app p t \\<longrightarrow> set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t) \\<rbrakk>\n  \\<Longrightarrow>  mono (Err.le r) (err_step n app step) n (err A)\"", "lemma in_errorD: \"(x,y) \\<in> set (error n) \\<Longrightarrow> y = Err\"", "lemma pres_type_lift:\n  \"\\<forall>s\\<in>A. \\<forall>p. p < n \\<longrightarrow> app p s \\<longrightarrow> (\\<forall>(q, s')\\<in>set (step p s). s' \\<in> A) \n  \\<Longrightarrow> pres_type (err_step n app step) n (err A)\"", "lemma wt_err_imp_wt_app_eff:\n  assumes wt: \"wt_err_step r (err_step (size ts) app step) ts\"\n  assumes b:  \"bounded (err_step (size ts) app step) (size ts)\"\n  shows \"wt_app_eff r app step (map ok_val ts)\"", "lemma wt_app_eff_imp_wt_err:\n  assumes app_eff: \"wt_app_eff r app step ts\"\n  assumes bounded: \"bounded (err_step (size ts) app step) (size ts)\"\n  shows \"wt_err_step r (err_step (size ts) app step) (map OK ts)\""], "translations": [["", "lemmas err_step_defs = err_step_def map_snd_def error_def"], ["", "lemma bounded_err_stepD:\n  \"\\<lbrakk> bounded (err_step n app step) n;\n     p < n; app p a; (q,b) \\<in> set (step p a) \\<rbrakk> \\<Longrightarrow> q < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded (err_step n app step) n; p < n; app p a;\n     (q, b) \\<in> set (step p a)\\<rbrakk>\n    \\<Longrightarrow> q < n", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded (err_step n app step) n; p < n; app p a;\n     (q, b) \\<in> set (step p a)\\<rbrakk>\n    \\<Longrightarrow> q < n", "apply (simp add: bounded_def err_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p<n.\n                \\<forall>\\<tau>.\n                   \\<forall>x\\<in>set (case \\<tau> of\n Err \\<Rightarrow> error n\n | OK \\<tau> \\<Rightarrow>\n     if app p \\<tau> then map_snd OK (step p \\<tau>) else error n).\n                      case x of (q, \\<tau>') \\<Rightarrow> q < n;\n     p < n; app p a; (q, b) \\<in> set (step p a)\\<rbrakk>\n    \\<Longrightarrow> q < n", "apply (erule allE, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p < n; app p a; (q, b) \\<in> set (step p a);\n     \\<forall>\\<tau>.\n        \\<forall>x\\<in>set (case \\<tau> of Err \\<Rightarrow> error n\n                            | OK \\<tau> \\<Rightarrow>\n                                if app p \\<tau>\n                                then map_snd OK (step p \\<tau>)\n                                else error n).\n           case x of (q, \\<tau>') \\<Rightarrow> q < n\\<rbrakk>\n    \\<Longrightarrow> q < n", "apply (erule_tac x = \"OK a\" in allE, drule bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p < n; app p a; (q, b) \\<in> set (step p a)\\<rbrakk>\n    \\<Longrightarrow> ?x12\n                      \\<in> set (case OK a of Err \\<Rightarrow> error n\n                                 | OK \\<tau> \\<Rightarrow>\n                                     if app p \\<tau>\n                                     then map_snd OK (step p \\<tau>)\n                                     else error n)\n 2. \\<lbrakk>p < n; app p a; (q, b) \\<in> set (step p a);\n     case ?x12 of (q, \\<tau>') \\<Rightarrow> q < n\\<rbrakk>\n    \\<Longrightarrow> q < n", "apply (simp add: map_snd_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p < n; app p a; (q, b) \\<in> set (step p a)\\<rbrakk>\n    \\<Longrightarrow> ?x12\n                      \\<in> (\\<lambda>x.\n                                case x of (x, y) \\<Rightarrow> (x, OK y)) `\n                            set (step p a)\n 2. \\<lbrakk>p < n; app p a; (q, b) \\<in> set (step p a);\n     case ?x12 of (q, \\<tau>') \\<Rightarrow> q < n\\<rbrakk>\n    \\<Longrightarrow> q < n", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p < n; app p a; (q, b) \\<in> set (step p a);\n     case (q, OK b) of (q, \\<tau>') \\<Rightarrow> q < n\\<rbrakk>\n    \\<Longrightarrow> q < n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma in_map_sndD: \"(a,b) \\<in> set (map_snd f xs) \\<Longrightarrow> \\<exists>b'. (a,b') \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set (map_snd f xs) \\<Longrightarrow>\n    \\<exists>b'. (a, b') \\<in> set xs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set (map_snd f xs) \\<Longrightarrow>\n    \\<exists>b'. (a, b') \\<in> set xs", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (a, b) \\<in> set (map_snd f []) \\<Longrightarrow>\n    \\<exists>b'. (a, b') \\<in> set []\n 2. \\<And>aa xs.\n       \\<lbrakk>(a, b) \\<in> set (map_snd f xs) \\<Longrightarrow>\n                \\<exists>b'. (a, b') \\<in> set xs;\n        (a, b) \\<in> set (map_snd f (aa # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b'. (a, b') \\<in> set (aa # xs)", "apply (auto simp add: map_snd_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma bounded_err_stepI:\n  \"\\<forall>p. p < n \\<longrightarrow> (\\<forall>s. ap p s \\<longrightarrow> (\\<forall>(q,s') \\<in> set (step p s). q < n))\n  \\<Longrightarrow> bounded (err_step n ap step) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p<n.\n       \\<forall>s.\n          ap p s \\<longrightarrow>\n          (\\<forall>(q, s')\\<in>set (step p s). q < n) \\<Longrightarrow>\n    bounded (err_step n ap step) n", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p<n.\n       \\<forall>s.\n          ap p s \\<longrightarrow>\n          (\\<forall>(q, s')\\<in>set (step p s). q < n) \\<Longrightarrow>\n    bounded (err_step n ap step) n", "apply (clarsimp simp: bounded_def err_step_def split: err.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p \\<tau>.\n       \\<lbrakk>\\<forall>p<n.\n                   \\<forall>s.\n                      ap p s \\<longrightarrow>\n                      (\\<forall>x\\<in>set (step p s).\n                          case x of (q, s') \\<Rightarrow> q < n);\n        p < n\\<rbrakk>\n       \\<Longrightarrow> (\\<tau> = Err \\<longrightarrow>\n                          (\\<forall>x\\<in>set (error n).\n                              case x of\n                              (q, \\<tau>') \\<Rightarrow> q < n)) \\<and>\n                         (\\<forall>x2.\n                             (ap p x2 \\<longrightarrow>\n                              \\<tau> = OK x2 \\<longrightarrow>\n                              (\\<forall>x\\<in>set (map_snd OK (step p x2)).\n                                  case x of\n                                  (q, \\<tau>') \\<Rightarrow> q < n)) \\<and>\n                             (\\<not> ap p x2 \\<longrightarrow>\n                              \\<tau> = OK x2 \\<longrightarrow>\n                              (\\<forall>x\\<in>set (error n).\n                                  case x of\n                                  (q, \\<tau>') \\<Rightarrow> q < n)))", "apply (simp add: error_def image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p \\<tau>.\n       \\<lbrakk>\\<forall>p<n.\n                   \\<forall>s.\n                      ap p s \\<longrightarrow>\n                      (\\<forall>x\\<in>set (step p s).\n                          case x of (q, s') \\<Rightarrow> q < n);\n        p < n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x2.\n                            ap p x2 \\<longrightarrow>\n                            \\<tau> = OK x2 \\<longrightarrow>\n                            (\\<forall>(q, \\<tau>')\n\\<in>set (map_snd OK (step p x2)).\n                                q < n)", "apply (blast dest: in_map_sndD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma bounded_lift:\n  \"bounded step n \\<Longrightarrow> bounded (err_step n app step) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded step n \\<Longrightarrow> bounded (err_step n app step) n", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded step n \\<Longrightarrow> bounded (err_step n app step) n", "apply (unfold bounded_def err_step_def error_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p<n.\n       \\<forall>\\<tau>.\n          \\<forall>(q, \\<tau>')\\<in>set (step p \\<tau>).\n             q < n \\<Longrightarrow>\n    \\<forall>p<n.\n       \\<forall>\\<tau>.\n          \\<forall>(q, \\<tau>')\n                   \\<in>set (case \\<tau> of\n                             Err \\<Rightarrow>\n                               map (\\<lambda>x. (x, Err)) [0..<n]\n                             | OK \\<tau> \\<Rightarrow>\n                                 if app p \\<tau>\n                                 then map_snd OK (step p \\<tau>)\n                                 else map (\\<lambda>x. (x, Err)) [0..<n]).\n             q < n", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p \\<tau> a b.\n       \\<lbrakk>\\<forall>p<n.\n                   \\<forall>\\<tau>.\n                      \\<forall>(q, \\<tau>')\\<in>set (step p \\<tau>). q < n;\n        p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of\n                   Err \\<Rightarrow> map (\\<lambda>x. (x, Err)) [0..<n]\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else map (\\<lambda>x. (x, Err)) [0..<n])\\<rbrakk>\n       \\<Longrightarrow> a < n", "apply (erule allE, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p \\<tau> a b.\n       \\<lbrakk>p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of\n                   Err \\<Rightarrow> map (\\<lambda>x. (x, Err)) [0..<n]\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else map (\\<lambda>x. (x, Err)) [0..<n]);\n        \\<forall>\\<tau>.\n           \\<forall>(q, \\<tau>')\\<in>set (step p \\<tau>). q < n\\<rbrakk>\n       \\<Longrightarrow> a < n", "apply (case_tac \\<tau>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p \\<tau> a b.\n       \\<lbrakk>p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of\n                   Err \\<Rightarrow> map (\\<lambda>x. (x, Err)) [0..<n]\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else map (\\<lambda>x. (x, Err)) [0..<n]);\n        \\<forall>\\<tau>.\n           \\<forall>(q, \\<tau>')\\<in>set (step p \\<tau>). q < n;\n        \\<tau> = Err\\<rbrakk>\n       \\<Longrightarrow> a < n\n 2. \\<And>p \\<tau> a b x2.\n       \\<lbrakk>p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of\n                   Err \\<Rightarrow> map (\\<lambda>x. (x, Err)) [0..<n]\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else map (\\<lambda>x. (x, Err)) [0..<n]);\n        \\<forall>\\<tau>.\n           \\<forall>(q, \\<tau>')\\<in>set (step p \\<tau>). q < n;\n        \\<tau> = OK x2\\<rbrakk>\n       \\<Longrightarrow> a < n", "apply (auto simp add: map_snd_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma le_list_map_OK [simp]:\n  \"\\<And>b. (map OK a [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) = (a [\\<sqsubseteq>\\<^sub>r] b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       (map OK a [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) =\n       (a [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       (map OK a [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) =\n       (a [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b)", "apply (induct a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       (map OK [] [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) =\n       ([] [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b)\n 2. \\<And>a1 a2 b.\n       (\\<And>b.\n           (map OK a2 [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) =\n           (a2 [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b)) \\<Longrightarrow>\n       (map OK (a1 # a2) [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) =\n       (a1 # a2 [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 b.\n       (\\<And>b.\n           (map OK a2 [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) =\n           (a2 [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b)) \\<Longrightarrow>\n       (map OK (a1 # a2) [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) =\n       (a1 # a2 [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 b.\n       (\\<And>b.\n           (map OK a2 [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) =\n           (a2 [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b)) \\<Longrightarrow>\n       (OK a1 # map OK a2 \n        [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) =\n       (a1 # a2 [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b)", "apply (case_tac b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a1 a2 b.\n       \\<lbrakk>\\<And>b.\n                   (map OK a2 \n                    [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) =\n                   (a2 [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b);\n        b = []\\<rbrakk>\n       \\<Longrightarrow> (OK a1 # map OK a2 \n                          [\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>] map OK b) =\n                         (a1 # a2 [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b)\n 2. \\<And>a1 a2 b a list.\n       \\<lbrakk>\\<And>b.\n                   (map OK a2 \n                    [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) =\n                   (a2 [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b);\n        b = a # list\\<rbrakk>\n       \\<Longrightarrow> (OK a1 # map OK a2 \n                          [\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>] map OK b) =\n                         (a1 # a2 [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 b a list.\n       \\<lbrakk>\\<And>b.\n                   (map OK a2 \n                    [\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>] map OK b) =\n                   (a2 [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b);\n        b = a # list\\<rbrakk>\n       \\<Longrightarrow> (OK a1 # map OK a2 \n                          [\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>] map OK b) =\n                         (a1 # a2 [\\<sqsubseteq>\\<^bsub>r\\<^esub>] b)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma map_snd_lessI:\n  \"set xs {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set ys \\<Longrightarrow> set (map_snd OK xs) {\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>} set (map_snd OK ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set ys \\<Longrightarrow>\n    set (map_snd OK xs) \n    {\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>} set (map_snd OK ys)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set ys \\<Longrightarrow>\n    set (map_snd OK xs) \n    {\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>} set (map_snd OK ys)", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set [] {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set ys \\<Longrightarrow>\n    set (map_snd OK []) \n    {\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>} set (map_snd OK ys)\n 2. \\<And>a xs.\n       \\<lbrakk>set xs \n                {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set ys \\<Longrightarrow>\n                set (map_snd OK xs) \n                {\\<sqsubseteq>\\<^bsub>Err.le r\\<^esub>} set (map_snd OK ys);\n        set (a # xs) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set ys\\<rbrakk>\n       \\<Longrightarrow> set (map_snd OK (a # xs)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (map_snd OK ys)", "apply (unfold lesubstep_type_def map_snd_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>(p, \\<tau>)\\<in>set [].\n       \\<exists>\\<tau>'.\n          (p, \\<tau>') \\<in> set ys \\<and>\n          \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>' \\<Longrightarrow>\n    \\<forall>(p, \\<tau>)\\<in>set (map (\\<lambda>(x, y). (x, OK y)) []).\n       \\<exists>\\<tau>'.\n          (p, \\<tau>')\n          \\<in> set (map (\\<lambda>(x, y). (x, OK y)) ys) \\<and>\n          \\<tau> \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>(p, \\<tau>)\\<in>set xs.\n                   \\<exists>\\<tau>'.\n                      (p, \\<tau>') \\<in> set ys \\<and>\n                      \\<tau> \n                      \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>' \\<Longrightarrow>\n                \\<forall>(p, \\<tau>)\n                         \\<in>set (map (\\<lambda>(x, y). (x, OK y)) xs).\n                   \\<exists>\\<tau>'.\n                      (p, \\<tau>')\n                      \\<in> set (map (\\<lambda>(x, y). (x, OK y)) ys) \\<and>\n                      \\<tau> \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>';\n        \\<forall>(p, \\<tau>)\\<in>set (a # xs).\n           \\<exists>\\<tau>'.\n              (p, \\<tau>') \\<in> set ys \\<and>\n              \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(p, \\<tau>)\n                                  \\<in>set\n  (map (\\<lambda>(x, y). (x, OK y)) (a # xs)).\n                            \\<exists>\\<tau>'.\n                               (p, \\<tau>')\n                               \\<in> set\n(map (\\<lambda>(x, y). (x, OK y)) ys) \\<and>\n                               \\<tau> \n                               \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma mono_lift:\n  \"\\<lbrakk> order r; app_mono r app n A; bounded (err_step n app step) n;\n    \\<forall>s p t. s \\<in> A \\<and> p < n \\<and> s \\<sqsubseteq>\\<^sub>r t \\<longrightarrow> app p t \\<longrightarrow> set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t) \\<rbrakk>\n  \\<Longrightarrow>  mono (Err.le r) (err_step n app step) n (err A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order r; app_mono r app n A; bounded (err_step n app step) n;\n     \\<forall>s p t.\n        s \\<in> A \\<and>\n        p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n        app p t \\<longrightarrow>\n        set (step p s) \n        {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t)\\<rbrakk>\n    \\<Longrightarrow> SemilatAlg.mono (Err.le r) (err_step n app step) n\n                       (err A)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order r; app_mono r app n A; bounded (err_step n app step) n;\n     \\<forall>s p t.\n        s \\<in> A \\<and>\n        p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n        app p t \\<longrightarrow>\n        set (step p s) \n        {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t)\\<rbrakk>\n    \\<Longrightarrow> SemilatAlg.mono (Err.le r) (err_step n app step) n\n                       (err A)", "apply (simp only: app_mono_def SemilatAlg.mono_def err_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order r;\n     \\<forall>s p t.\n        s \\<in> A \\<and>\n        p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n        app p t \\<longrightarrow> app p s;\n     bounded (err_step n app step) n;\n     \\<forall>s p t.\n        s \\<in> A \\<and>\n        p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n        app p t \\<longrightarrow>\n        set (step p s) \n        {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<tau> p \\<tau>'.\n                         \\<tau> \\<in> err A \\<and>\n                         p < n \\<and>\n                         \\<tau> \n                         \\<sqsubseteq>\\<^bsub>Err.le\n         r\\<^esub> \\<tau>' \\<longrightarrow>\n                         set (case \\<tau> of Err \\<Rightarrow> error n\n                              | OK \\<tau> \\<Rightarrow>\n                                  if app p \\<tau>\n                                  then map_snd OK (step p \\<tau>)\n                                  else error n) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                          | OK \\<tau> \\<Rightarrow>\n                              if app p \\<tau>\n                              then map_snd OK (step p \\<tau>) else error n)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p \\<tau>'.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        \\<tau> \\<in> err A; p < n;\n        \\<tau> \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> set (case \\<tau> of Err \\<Rightarrow> error n\n                              | OK \\<tau> \\<Rightarrow>\n                                  if app p \\<tau>\n                                  then map_snd OK (step p \\<tau>)\n                                  else error n) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                          | OK \\<tau> \\<Rightarrow>\n                              if app p \\<tau>\n                              then map_snd OK (step p \\<tau>) else error n)", "apply (case_tac \\<tau>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p \\<tau>'.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        \\<tau> \\<in> err A; p < n;\n        \\<tau> \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>';\n        \\<tau> = Err\\<rbrakk>\n       \\<Longrightarrow> set (case \\<tau> of Err \\<Rightarrow> error n\n                              | OK \\<tau> \\<Rightarrow>\n                                  if app p \\<tau>\n                                  then map_snd OK (step p \\<tau>)\n                                  else error n) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                          | OK \\<tau> \\<Rightarrow>\n                              if app p \\<tau>\n                              then map_snd OK (step p \\<tau>) else error n)\n 2. \\<And>\\<tau> p \\<tau>' x2.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        \\<tau> \\<in> err A; p < n;\n        \\<tau> \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>';\n        \\<tau> = OK x2\\<rbrakk>\n       \\<Longrightarrow> set (case \\<tau> of Err \\<Rightarrow> error n\n                              | OK \\<tau> \\<Rightarrow>\n                                  if app p \\<tau>\n                                  then map_snd OK (step p \\<tau>)\n                                  else error n) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                          | OK \\<tau> \\<Rightarrow>\n                              if app p \\<tau>\n                              then map_snd OK (step p \\<tau>) else error n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p \\<tau>' x2.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        \\<tau> \\<in> err A; p < n;\n        \\<tau> \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>';\n        \\<tau> = OK x2\\<rbrakk>\n       \\<Longrightarrow> set (case \\<tau> of Err \\<Rightarrow> error n\n                              | OK \\<tau> \\<Rightarrow>\n                                  if app p \\<tau>\n                                  then map_snd OK (step p \\<tau>)\n                                  else error n) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                          | OK \\<tau> \\<Rightarrow>\n                              if app p \\<tau>\n                              then map_snd OK (step p \\<tau>) else error n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p \\<tau>' x2.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n;\n        OK x2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>';\n        \\<tau> = OK x2\\<rbrakk>\n       \\<Longrightarrow> (app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n)) \\<and>\n                         (\\<not> app p x2 \\<longrightarrow>\n                          set (error n) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n))", "apply (case_tac \\<tau>')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n;\n        OK x2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'; \\<tau> = OK x2;\n        \\<tau>' = Err\\<rbrakk>\n       \\<Longrightarrow> (app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n)) \\<and>\n                         (\\<not> app p x2 \\<longrightarrow>\n                          set (error n) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n))\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n;\n        OK x2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'; \\<tau> = OK x2;\n        \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> (app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n)) \\<and>\n                         (\\<not> app p x2 \\<longrightarrow>\n                          set (error n) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; \\<tau> = OK x2; \\<tau>' = Err\\<rbrakk>\n       \\<Longrightarrow> app p x2 \\<longrightarrow>\n                         set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (error n)\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n;\n        OK x2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'; \\<tau> = OK x2;\n        \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> (app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n)) \\<and>\n                         (\\<not> app p x2 \\<longrightarrow>\n                          set (error n) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n))", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; app p x2\\<rbrakk>\n       \\<Longrightarrow> set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (error n)\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n;\n        OK x2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'; \\<tau> = OK x2;\n        \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> (app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n)) \\<and>\n                         (\\<not> app p x2 \\<longrightarrow>\n                          set (error n) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n))", "apply (simp add: lesubstep_type_def error_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p x2.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           (\\<forall>(pa, \\<tau>)\\<in>set (step p s).\n               \\<exists>\\<tau>'.\n                  (pa, \\<tau>') \\<in> set (step p t) \\<and>\n                  \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>');\n        x2 \\<in> A; p < n; app p x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(p, \\<tau>)\n                                  \\<in>set (map_snd OK (step p x2)).\n                            \\<exists>\\<tau>'.\n                               (p, \\<tau>')\n                               \\<in> (\\<lambda>x. (x, Err)) ` {0..<n} \\<and>\n                               \\<tau> \n                               \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n;\n        OK x2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'; \\<tau> = OK x2;\n        \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> (app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n)) \\<and>\n                         (\\<not> app p x2 \\<longrightarrow>\n                          set (error n) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n))", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p x2 a b.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           (\\<forall>(pa, \\<tau>)\\<in>set (step p s).\n               \\<exists>\\<tau>'.\n                  (pa, \\<tau>') \\<in> set (step p t) \\<and>\n                  \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>');\n        x2 \\<in> A; p < n; app p x2;\n        (a, b) \\<in> set (map_snd OK (step p x2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>'.\n                            (a, \\<tau>')\n                            \\<in> (\\<lambda>x. (x, Err)) ` {0..<n} \\<and>\n                            b \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n;\n        OK x2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'; \\<tau> = OK x2;\n        \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> (app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n)) \\<and>\n                         (\\<not> app p x2 \\<longrightarrow>\n                          set (error n) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n))", "apply (drule in_map_sndD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p x2 a b.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           (\\<forall>(pa, \\<tau>)\\<in>set (step p s).\n               \\<exists>\\<tau>'.\n                  (pa, \\<tau>') \\<in> set (step p t) \\<and>\n                  \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>');\n        x2 \\<in> A; p < n; app p x2;\n        \\<exists>b'. (a, b') \\<in> set (step p x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>'.\n                            (a, \\<tau>')\n                            \\<in> (\\<lambda>x. (x, Err)) ` {0..<n} \\<and>\n                            b \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n;\n        OK x2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'; \\<tau> = OK x2;\n        \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> (app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n)) \\<and>\n                         (\\<not> app p x2 \\<longrightarrow>\n                          set (error n) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n))", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p x2 a b b'.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           (\\<forall>(pa, \\<tau>)\\<in>set (step p s).\n               \\<exists>\\<tau>'.\n                  (pa, \\<tau>') \\<in> set (step p t) \\<and>\n                  \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>');\n        x2 \\<in> A; p < n; app p x2; (a, b') \\<in> set (step p x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>'.\n                            (a, \\<tau>')\n                            \\<in> (\\<lambda>x. (x, Err)) ` {0..<n} \\<and>\n                            b \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n;\n        OK x2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'; \\<tau> = OK x2;\n        \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> (app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n)) \\<and>\n                         (\\<not> app p x2 \\<longrightarrow>\n                          set (error n) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n))", "apply (drule bounded_err_stepD, assumption+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p x2 a b b'.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           (\\<forall>(pa, \\<tau>)\\<in>set (step p s).\n               \\<exists>\\<tau>'.\n                  (pa, \\<tau>') \\<in> set (step p t) \\<and>\n                  \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>');\n        x2 \\<in> A; p < n; app p x2; (a, b') \\<in> set (step p x2);\n        a < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>'.\n                            (a, \\<tau>')\n                            \\<in> (\\<lambda>x. (x, Err)) ` {0..<n} \\<and>\n                            b \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n;\n        OK x2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'; \\<tau> = OK x2;\n        \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> (app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n)) \\<and>\n                         (\\<not> app p x2 \\<longrightarrow>\n                          set (error n) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n))", "apply (rule exI [of _ Err])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p x2 a b b'.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           (\\<forall>(pa, \\<tau>)\\<in>set (step p s).\n               \\<exists>\\<tau>'.\n                  (pa, \\<tau>') \\<in> set (step p t) \\<and>\n                  \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>');\n        x2 \\<in> A; p < n; app p x2; (a, b') \\<in> set (step p x2);\n        a < n\\<rbrakk>\n       \\<Longrightarrow> (a, Err)\n                         \\<in> (\\<lambda>x. (x, Err)) ` {0..<n} \\<and>\n                         b \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> Err\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n;\n        OK x2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'; \\<tau> = OK x2;\n        \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> (app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n)) \\<and>\n                         (\\<not> app p x2 \\<longrightarrow>\n                          set (error n) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n;\n        OK x2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'; \\<tau> = OK x2;\n        \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> (app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n)) \\<and>\n                         (\\<not> app p x2 \\<longrightarrow>\n                          set (error n) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (case \\<tau>' of Err \\<Rightarrow> error n\n                           | OK \\<tau> \\<Rightarrow>\n                               if app p \\<tau>\n                               then map_snd OK (step p \\<tau>)\n                               else error n))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow> app p s;\n        bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> (app p x2a \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (map_snd OK (step p x2a))) \\<and>\n                         (\\<not> app p x2a \\<longrightarrow>\n                          app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (error n))", "apply (erule allE, erule allE, erule allE, erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> ?s37 \\<tau> p \\<tau>' x2 x2a \\<in> A \\<and>\n                         ?p39 \\<tau> p \\<tau>' x2 x2a < n \\<and>\n                         ?s37 \\<tau> p \\<tau>' x2 x2a \n                         \\<sqsubseteq>\\<^bsub>r\\<^esub> ?t41 \\<tau> p\n                   \\<tau>' x2 x2a\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app (?p39 \\<tau> p \\<tau>' x2 x2a)\n         (?t41 \\<tau> p \\<tau>' x2 x2a) \\<longrightarrow>\n        app (?p39 \\<tau> p \\<tau>' x2 x2a)\n         (?s37 \\<tau> p \\<tau>' x2 x2a)\\<rbrakk>\n       \\<Longrightarrow> (app p x2a \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (map_snd OK (step p x2a))) \\<and>\n                         (\\<not> app p x2a \\<longrightarrow>\n                          app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (error n))", "apply (rule conjI, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> ?p39 \\<tau> p \\<tau>' x2 x2a < n \\<and>\n                         x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> ?t41 \\<tau> p\n                      \\<tau>' x2 x2a\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app (?p39 \\<tau> p \\<tau>' x2 x2a)\n         (?t41 \\<tau> p \\<tau>' x2 x2a) \\<longrightarrow>\n        app (?p39 \\<tau> p \\<tau>' x2 x2a) x2\\<rbrakk>\n       \\<Longrightarrow> (app p x2a \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (map_snd OK (step p x2a))) \\<and>\n                         (\\<not> app p x2a \\<longrightarrow>\n                          app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (error n))", "apply (rule conjI, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a\\<rbrakk>\n       \\<Longrightarrow> x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> ?t41 \\<tau> p\n                      \\<tau>' x2 x2a\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app p (?t41 \\<tau> p \\<tau>' x2 x2a) \\<longrightarrow>\n        app p x2\\<rbrakk>\n       \\<Longrightarrow> (app p x2a \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (map_snd OK (step p x2a))) \\<and>\n                         (\\<not> app p x2a \\<longrightarrow>\n                          app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (error n))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app p x2a \\<longrightarrow> app p x2\\<rbrakk>\n       \\<Longrightarrow> (app p x2a \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (map_snd OK (step p x2a))) \\<and>\n                         (\\<not> app p x2a \\<longrightarrow>\n                          app p x2 \\<longrightarrow>\n                          set (map_snd OK (step p x2)) \n                          {\\<sqsubseteq>\\<^bsub>Err.le\n           r\\<^esub>} set (error n))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app p x2a \\<longrightarrow> app p x2\\<rbrakk>\n       \\<Longrightarrow> app p x2a \\<longrightarrow>\n                         set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (map_snd OK (step p x2a))\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app p x2a \\<longrightarrow> app p x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> app p x2a \\<longrightarrow>\n                         app p x2 \\<longrightarrow>\n                         set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (error n)", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a; app p x2a;\n        app p x2\\<rbrakk>\n       \\<Longrightarrow> set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (map_snd OK (step p x2a))\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app p x2a \\<longrightarrow> app p x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> app p x2a \\<longrightarrow>\n                         app p x2 \\<longrightarrow>\n                         set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (error n)", "apply (erule allE, erule allE, erule allE, erule impE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n; x2 \\<in> A; p < n;\n        x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a; app p x2a; app p x2\\<rbrakk>\n       \\<Longrightarrow> ?s62 \\<tau> p \\<tau>' x2 x2a \\<in> A \\<and>\n                         ?p64 \\<tau> p \\<tau>' x2 x2a < n \\<and>\n                         ?s62 \\<tau> p \\<tau>' x2 x2a \n                         \\<sqsubseteq>\\<^bsub>r\\<^esub> ?t66 \\<tau> p\n                   \\<tau>' x2 x2a\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n; x2 \\<in> A; p < n;\n        x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a; app p x2a; app p x2;\n        app (?p64 \\<tau> p \\<tau>' x2 x2a)\n         (?t66 \\<tau> p \\<tau>' x2 x2a) \\<longrightarrow>\n        set (step (?p64 \\<tau> p \\<tau>' x2 x2a)\n              (?s62 \\<tau> p \\<tau>' x2 x2a)) \n        {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set\n    (step (?p64 \\<tau> p \\<tau>' x2 x2a)\n      (?t66 \\<tau> p \\<tau>' x2 x2a))\\<rbrakk>\n       \\<Longrightarrow> set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (map_snd OK (step p x2a))\n 3. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app p x2a \\<longrightarrow> app p x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> app p x2a \\<longrightarrow>\n                         app p x2 \\<longrightarrow>\n                         set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (error n)", "apply (rule conjI, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n; x2 \\<in> A; p < n;\n        x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a; app p x2a; app p x2\\<rbrakk>\n       \\<Longrightarrow> ?p64 \\<tau> p \\<tau>' x2 x2a < n \\<and>\n                         x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> ?t66 \\<tau> p\n                      \\<tau>' x2 x2a\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n; x2 \\<in> A; p < n;\n        x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a; app p x2a; app p x2;\n        app (?p64 \\<tau> p \\<tau>' x2 x2a)\n         (?t66 \\<tau> p \\<tau>' x2 x2a) \\<longrightarrow>\n        set (step (?p64 \\<tau> p \\<tau>' x2 x2a) x2) \n        {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set\n    (step (?p64 \\<tau> p \\<tau>' x2 x2a)\n      (?t66 \\<tau> p \\<tau>' x2 x2a))\\<rbrakk>\n       \\<Longrightarrow> set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (map_snd OK (step p x2a))\n 3. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app p x2a \\<longrightarrow> app p x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> app p x2a \\<longrightarrow>\n                         app p x2 \\<longrightarrow>\n                         set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (error n)", "apply (rule conjI, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n; x2 \\<in> A; p < n;\n        x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a; app p x2a; app p x2\\<rbrakk>\n       \\<Longrightarrow> x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> ?t66 \\<tau> p\n                      \\<tau>' x2 x2a\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n; x2 \\<in> A; p < n;\n        x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a; app p x2a; app p x2;\n        app p (?t66 \\<tau> p \\<tau>' x2 x2a) \\<longrightarrow>\n        set (step p x2) \n        {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set\n    (step p (?t66 \\<tau> p \\<tau>' x2 x2a))\\<rbrakk>\n       \\<Longrightarrow> set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (map_snd OK (step p x2a))\n 3. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app p x2a \\<longrightarrow> app p x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> app p x2a \\<longrightarrow>\n                         app p x2 \\<longrightarrow>\n                         set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (error n)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n; x2 \\<in> A; p < n;\n        x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a; app p x2a; app p x2;\n        app p x2a \\<longrightarrow>\n        set (step p x2) \n        {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p x2a)\\<rbrakk>\n       \\<Longrightarrow> set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (map_snd OK (step p x2a))\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app p x2a \\<longrightarrow> app p x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> app p x2a \\<longrightarrow>\n                         app p x2 \\<longrightarrow>\n                         set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (error n)", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n; x2 \\<in> A; p < n;\n        x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a; app p x2a; app p x2;\n        set (step p x2) \n        {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p x2a)\\<rbrakk>\n       \\<Longrightarrow> set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (map_snd OK (step p x2a))\n 2. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app p x2a \\<longrightarrow> app p x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> app p x2a \\<longrightarrow>\n                         app p x2 \\<longrightarrow>\n                         set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (error n)", "apply (rule map_snd_lessI, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<tau> = OK x2; \\<tau>' = OK x2a;\n        app p x2a \\<longrightarrow> app p x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> app p x2a \\<longrightarrow>\n                         app p x2 \\<longrightarrow>\n                         set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (error n)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p \\<tau>' x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           set (step p s) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p t);\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        app p x2a \\<longrightarrow> app p x2; \\<not> app p x2a;\n        app p x2\\<rbrakk>\n       \\<Longrightarrow> set (map_snd OK (step p x2)) \n                         {\\<sqsubseteq>\\<^bsub>Err.le\n          r\\<^esub>} set (error n)", "apply (simp add: lesubstep_type_def error_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x2 x2a.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           (\\<forall>(pa, \\<tau>)\\<in>set (step p s).\n               \\<exists>\\<tau>'.\n                  (pa, \\<tau>') \\<in> set (step p t) \\<and>\n                  \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>');\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<not> app p x2a; app p x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(p, \\<tau>)\n                                  \\<in>set (map_snd OK (step p x2)).\n                            \\<exists>\\<tau>'.\n                               (p, \\<tau>')\n                               \\<in> (\\<lambda>x. (x, Err)) ` {0..<n} \\<and>\n                               \\<tau> \n                               \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x2 x2a a b.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           (\\<forall>(pa, \\<tau>)\\<in>set (step p s).\n               \\<exists>\\<tau>'.\n                  (pa, \\<tau>') \\<in> set (step p t) \\<and>\n                  \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>');\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<not> app p x2a; app p x2;\n        (a, b) \\<in> set (map_snd OK (step p x2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>'.\n                            (a, \\<tau>')\n                            \\<in> (\\<lambda>x. (x, Err)) ` {0..<n} \\<and>\n                            b \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'", "apply (drule in_map_sndD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x2 x2a a b.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           (\\<forall>(pa, \\<tau>)\\<in>set (step p s).\n               \\<exists>\\<tau>'.\n                  (pa, \\<tau>') \\<in> set (step p t) \\<and>\n                  \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>');\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<not> app p x2a; app p x2;\n        \\<exists>b'. (a, b') \\<in> set (step p x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>'.\n                            (a, \\<tau>')\n                            \\<in> (\\<lambda>x. (x, Err)) ` {0..<n} \\<and>\n                            b \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x2 x2a a b b'.\n       \\<lbrakk>order r; bounded (err_step n app step) n;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           (\\<forall>(pa, \\<tau>)\\<in>set (step p s).\n               \\<exists>\\<tau>'.\n                  (pa, \\<tau>') \\<in> set (step p t) \\<and>\n                  \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>');\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<not> app p x2a; app p x2; (a, b') \\<in> set (step p x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>'.\n                            (a, \\<tau>')\n                            \\<in> (\\<lambda>x. (x, Err)) ` {0..<n} \\<and>\n                            b \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'", "apply (drule bounded_err_stepD, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x2 x2a a b b'.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           (\\<forall>(pa, \\<tau>)\\<in>set (step p s).\n               \\<exists>\\<tau>'.\n                  (pa, \\<tau>') \\<in> set (step p t) \\<and>\n                  \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>');\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<not> app p x2a; app p x2; (a, b') \\<in> set (step p x2);\n        a < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>'.\n                            (a, \\<tau>')\n                            \\<in> (\\<lambda>x. (x, Err)) ` {0..<n} \\<and>\n                            b \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> \\<tau>'", "apply (rule exI [of _ Err])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x2 x2a a b b'.\n       \\<lbrakk>order r;\n        \\<forall>s p t.\n           s \\<in> A \\<and>\n           p < n \\<and> s \\<sqsubseteq>\\<^bsub>r\\<^esub> t \\<longrightarrow>\n           app p t \\<longrightarrow>\n           (\\<forall>(pa, \\<tau>)\\<in>set (step p s).\n               \\<exists>\\<tau>'.\n                  (pa, \\<tau>') \\<in> set (step p t) \\<and>\n                  \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> \\<tau>');\n        x2 \\<in> A; p < n; x2 \\<sqsubseteq>\\<^bsub>r\\<^esub> x2a;\n        \\<not> app p x2a; app p x2; (a, b') \\<in> set (step p x2);\n        a < n\\<rbrakk>\n       \\<Longrightarrow> (a, Err)\n                         \\<in> (\\<lambda>x. (x, Err)) ` {0..<n} \\<and>\n                         b \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> Err", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma in_errorD: \"(x,y) \\<in> set (error n) \\<Longrightarrow> y = Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> set (error n) \\<Longrightarrow> y = Err", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> set (error n) \\<Longrightarrow> y = Err", "by (auto simp add: error_def)"], ["", "(*>*)"], ["", "lemma pres_type_lift:\n  \"\\<forall>s\\<in>A. \\<forall>p. p < n \\<longrightarrow> app p s \\<longrightarrow> (\\<forall>(q, s')\\<in>set (step p s). s' \\<in> A) \n  \\<Longrightarrow> pres_type (err_step n app step) n (err A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>A.\n       \\<forall>p<n.\n          app p s \\<longrightarrow>\n          (\\<forall>(q, s')\\<in>set (step p s).\n              s' \\<in> A) \\<Longrightarrow>\n    pres_type (err_step n app step) n (err A)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>A.\n       \\<forall>p<n.\n          app p s \\<longrightarrow>\n          (\\<forall>(q, s')\\<in>set (step p s).\n              s' \\<in> A) \\<Longrightarrow>\n    pres_type (err_step n app step) n (err A)", "apply (unfold pres_type_def err_step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>A.\n       \\<forall>p<n.\n          app p s \\<longrightarrow>\n          (\\<forall>(q, s')\\<in>set (step p s).\n              s' \\<in> A) \\<Longrightarrow>\n    \\<forall>\\<tau>\\<in>err A.\n       \\<forall>p<n.\n          \\<forall>(q, \\<tau>')\n                   \\<in>set (case \\<tau> of Err \\<Rightarrow> error n\n                             | OK \\<tau> \\<Rightarrow>\n                                 if app p \\<tau>\n                                 then map_snd OK (step p \\<tau>)\n                                 else error n).\n             \\<tau>' \\<in> err A", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p a b.\n       \\<lbrakk>\\<forall>s\\<in>A.\n                   \\<forall>p<n.\n                      app p s \\<longrightarrow>\n                      (\\<forall>(q, s')\\<in>set (step p s). s' \\<in> A);\n        \\<tau> \\<in> err A; p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of Err \\<Rightarrow> error n\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else error n)\\<rbrakk>\n       \\<Longrightarrow> b \\<in> err A", "apply (case_tac b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p a b.\n       \\<lbrakk>\\<forall>s\\<in>A.\n                   \\<forall>p<n.\n                      app p s \\<longrightarrow>\n                      (\\<forall>(q, s')\\<in>set (step p s). s' \\<in> A);\n        \\<tau> \\<in> err A; p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of Err \\<Rightarrow> error n\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else error n);\n        b = Err\\<rbrakk>\n       \\<Longrightarrow> b \\<in> err A\n 2. \\<And>\\<tau> p a b x2.\n       \\<lbrakk>\\<forall>s\\<in>A.\n                   \\<forall>p<n.\n                      app p s \\<longrightarrow>\n                      (\\<forall>(q, s')\\<in>set (step p s). s' \\<in> A);\n        \\<tau> \\<in> err A; p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of Err \\<Rightarrow> error n\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else error n);\n        b = OK x2\\<rbrakk>\n       \\<Longrightarrow> b \\<in> err A", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p a b x2.\n       \\<lbrakk>\\<forall>s\\<in>A.\n                   \\<forall>p<n.\n                      app p s \\<longrightarrow>\n                      (\\<forall>(q, s')\\<in>set (step p s). s' \\<in> A);\n        \\<tau> \\<in> err A; p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of Err \\<Rightarrow> error n\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else error n);\n        b = OK x2\\<rbrakk>\n       \\<Longrightarrow> b \\<in> err A", "apply (case_tac \\<tau>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p a b x2.\n       \\<lbrakk>\\<forall>s\\<in>A.\n                   \\<forall>p<n.\n                      app p s \\<longrightarrow>\n                      (\\<forall>(q, s')\\<in>set (step p s). s' \\<in> A);\n        \\<tau> \\<in> err A; p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of Err \\<Rightarrow> error n\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else error n);\n        b = OK x2; \\<tau> = Err\\<rbrakk>\n       \\<Longrightarrow> b \\<in> err A\n 2. \\<And>\\<tau> p a b x2 x2a.\n       \\<lbrakk>\\<forall>s\\<in>A.\n                   \\<forall>p<n.\n                      app p s \\<longrightarrow>\n                      (\\<forall>(q, s')\\<in>set (step p s). s' \\<in> A);\n        \\<tau> \\<in> err A; p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of Err \\<Rightarrow> error n\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else error n);\n        b = OK x2; \\<tau> = OK x2a\\<rbrakk>\n       \\<Longrightarrow> b \\<in> err A", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p a b x2.\n       \\<lbrakk>\\<forall>s\\<in>A.\n                   \\<forall>p<n.\n                      app p s \\<longrightarrow>\n                      (\\<forall>x\\<in>set (step p s).\n                          case x of (q, s') \\<Rightarrow> s' \\<in> A);\n        p < n; (a, OK x2) \\<in> set (error n); b = OK x2;\n        \\<tau> = Err\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> A\n 2. \\<And>\\<tau> p a b x2 x2a.\n       \\<lbrakk>\\<forall>s\\<in>A.\n                   \\<forall>p<n.\n                      app p s \\<longrightarrow>\n                      (\\<forall>(q, s')\\<in>set (step p s). s' \\<in> A);\n        \\<tau> \\<in> err A; p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of Err \\<Rightarrow> error n\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else error n);\n        b = OK x2; \\<tau> = OK x2a\\<rbrakk>\n       \\<Longrightarrow> b \\<in> err A", "apply (drule in_errorD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p a b x2.\n       \\<lbrakk>\\<forall>s\\<in>A.\n                   \\<forall>p<n.\n                      app p s \\<longrightarrow>\n                      (\\<forall>x\\<in>set (step p s).\n                          case x of (q, s') \\<Rightarrow> s' \\<in> A);\n        p < n; b = OK x2; \\<tau> = Err; OK x2 = Err\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> A\n 2. \\<And>\\<tau> p a b x2 x2a.\n       \\<lbrakk>\\<forall>s\\<in>A.\n                   \\<forall>p<n.\n                      app p s \\<longrightarrow>\n                      (\\<forall>(q, s')\\<in>set (step p s). s' \\<in> A);\n        \\<tau> \\<in> err A; p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of Err \\<Rightarrow> error n\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else error n);\n        b = OK x2; \\<tau> = OK x2a\\<rbrakk>\n       \\<Longrightarrow> b \\<in> err A", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p a b x2 x2a.\n       \\<lbrakk>\\<forall>s\\<in>A.\n                   \\<forall>p<n.\n                      app p s \\<longrightarrow>\n                      (\\<forall>(q, s')\\<in>set (step p s). s' \\<in> A);\n        \\<tau> \\<in> err A; p < n;\n        (a, b)\n        \\<in> set (case \\<tau> of Err \\<Rightarrow> error n\n                   | OK \\<tau> \\<Rightarrow>\n                       if app p \\<tau> then map_snd OK (step p \\<tau>)\n                       else error n);\n        b = OK x2; \\<tau> = OK x2a\\<rbrakk>\n       \\<Longrightarrow> b \\<in> err A", "apply (simp add: map_snd_def split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> p a b x2 x2a.\n       \\<lbrakk>b = OK x2; \\<tau> = OK x2a;\n        \\<forall>s\\<in>A.\n           \\<forall>p<n.\n              app p s \\<longrightarrow>\n              (\\<forall>x\\<in>set (step p s).\n                  case x of (q, s') \\<Rightarrow> s' \\<in> A);\n        x2a \\<in> A; p < n; app p x2a;\n        (a, OK x2)\n        \\<in> (\\<lambda>x. case x of (x, y) \\<Rightarrow> (x, OK y)) `\n              set (step p x2a)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> A\n 2. \\<And>\\<tau> p a b x2 x2a.\n       \\<lbrakk>b = OK x2; \\<tau> = OK x2a;\n        \\<forall>s\\<in>A.\n           \\<forall>p<n.\n              app p s \\<longrightarrow>\n              (\\<forall>x\\<in>set (step p s).\n                  case x of (q, s') \\<Rightarrow> s' \\<in> A);\n        x2a \\<in> A; p < n; \\<not> app p x2a;\n        (a, OK x2) \\<in> set (error n)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> A", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p a b x2 x2a.\n       \\<lbrakk>b = OK x2; \\<tau> = OK x2a;\n        \\<forall>s\\<in>A.\n           \\<forall>p<n.\n              app p s \\<longrightarrow>\n              (\\<forall>x\\<in>set (step p s).\n                  case x of (q, s') \\<Rightarrow> s' \\<in> A);\n        x2a \\<in> A; p < n; \\<not> app p x2a;\n        (a, OK x2) \\<in> set (error n)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> A", "apply (drule in_errorD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> p a b x2 x2a.\n       \\<lbrakk>b = OK x2; \\<tau> = OK x2a;\n        \\<forall>s\\<in>A.\n           \\<forall>p<n.\n              app p s \\<longrightarrow>\n              (\\<forall>x\\<in>set (step p s).\n                  case x of (q, s') \\<Rightarrow> s' \\<in> A);\n        x2a \\<in> A; p < n; \\<not> app p x2a; OK x2 = Err\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> A", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma wt_err_imp_wt_app_eff:\n  assumes wt: \"wt_err_step r (err_step (size ts) app step) ts\"\n  assumes b:  \"bounded (err_step (size ts) app step) (size ts)\"\n  shows \"wt_app_eff r app step (map ok_val ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_app_eff r app step (map ok_val ts)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_app_eff r app step (map ok_val ts)", "proof (unfold wt_app_eff_def, intro strip, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       app p (map ok_val ts ! p)\n 2. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       \\<forall>(q, \\<tau>)\\<in>set (step p (map ok_val ts ! p)).\n          \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! q", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       app p (map ok_val ts ! p)\n 2. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       \\<forall>(q, \\<tau>)\\<in>set (step p (map ok_val ts ! p)).\n          \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! q", "assume \"p < size (map ok_val ts)\""], ["proof (state)\nthis:\n  p < length (map ok_val ts)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       app p (map ok_val ts ! p)\n 2. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       \\<forall>(q, \\<tau>)\\<in>set (step p (map ok_val ts ! p)).\n          \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! q", "hence lp: \"p < size ts\""], ["proof (prove)\nusing this:\n  p < length (map ok_val ts)\n\ngoal (1 subgoal):\n 1. p < length ts", "by simp"], ["proof (state)\nthis:\n  p < length ts\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       app p (map ok_val ts ! p)\n 2. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       \\<forall>(q, \\<tau>)\\<in>set (step p (map ok_val ts ! p)).\n          \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! q", "hence ts: \"0 < size ts\""], ["proof (prove)\nusing this:\n  p < length ts\n\ngoal (1 subgoal):\n 1. 0 < length ts", "by (cases p) auto"], ["proof (state)\nthis:\n  0 < length ts\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       app p (map ok_val ts ! p)\n 2. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       \\<forall>(q, \\<tau>)\\<in>set (step p (map ok_val ts ! p)).\n          \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! q", "hence err: \"(0,Err) \\<in> set (error (size ts))\""], ["proof (prove)\nusing this:\n  0 < length ts\n\ngoal (1 subgoal):\n 1. (0, Err) \\<in> set (error (length ts))", "by (simp add: error_def)"], ["proof (state)\nthis:\n  (0, Err) \\<in> set (error (length ts))\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       app p (map ok_val ts ! p)\n 2. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       \\<forall>(q, \\<tau>)\\<in>set (step p (map ok_val ts ! p)).\n          \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! q", "from wt lp"], ["proof (chain)\npicking this:\n  wt_err_step r (err_step (length ts) app step) ts\n  p < length ts", "have [intro?]: \"\\<And>p. p < size ts \\<Longrightarrow> ts ! p \\<noteq> Err\""], ["proof (prove)\nusing this:\n  wt_err_step r (err_step (length ts) app step) ts\n  p < length ts\n\ngoal (1 subgoal):\n 1. \\<And>p. p < length ts \\<Longrightarrow> ts ! p \\<noteq> Err", "by (unfold wt_err_step_def wt_step_def) simp"], ["proof (state)\nthis:\n  ?p1 < length ts \\<Longrightarrow> ts ! ?p1 \\<noteq> Err\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       app p (map ok_val ts ! p)\n 2. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       \\<forall>(q, \\<tau>)\\<in>set (step p (map ok_val ts ! p)).\n          \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! q", "show app: \"app p (map ok_val ts ! p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app p (map ok_val ts ! p)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> app p (map ok_val ts ! p) \\<Longrightarrow> False", "from wt lp"], ["proof (chain)\npicking this:\n  wt_err_step r (err_step (length ts) app step) ts\n  p < length ts", "obtain s where\n      OKp:  \"ts ! p = OK s\" and\n      less: \"\\<forall>(q,t) \\<in> set (err_step (size ts) app step p (ts!p)). t <=_(Err.le r) ts!q\""], ["proof (prove)\nusing this:\n  wt_err_step r (err_step (length ts) app step) ts\n  p < length ts\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>ts ! p = OK s;\n         \\<forall>(q, t)\\<in>set (err_step (length ts) app step p (ts ! p)).\n            t \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> ts ! q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold wt_err_step_def wt_step_def stable_def) \n         (auto iff: not_Err_eq)"], ["proof (state)\nthis:\n  ts ! p = OK s\n  \\<forall>(q, t)\\<in>set (err_step (length ts) app step p (ts ! p)).\n     t \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> ts ! q\n\ngoal (1 subgoal):\n 1. \\<not> app p (map ok_val ts ! p) \\<Longrightarrow> False", "assume \"\\<not> app p (map ok_val ts ! p)\""], ["proof (state)\nthis:\n  \\<not> app p (map ok_val ts ! p)\n\ngoal (1 subgoal):\n 1. \\<not> app p (map ok_val ts ! p) \\<Longrightarrow> False", "with OKp lp"], ["proof (chain)\npicking this:\n  ts ! p = OK s\n  p < length ts\n  \\<not> app p (map ok_val ts ! p)", "have \"\\<not> app p s\""], ["proof (prove)\nusing this:\n  ts ! p = OK s\n  p < length ts\n  \\<not> app p (map ok_val ts ! p)\n\ngoal (1 subgoal):\n 1. \\<not> app p s", "by simp"], ["proof (state)\nthis:\n  \\<not> app p s\n\ngoal (1 subgoal):\n 1. \\<not> app p (map ok_val ts ! p) \\<Longrightarrow> False", "with OKp"], ["proof (chain)\npicking this:\n  ts ! p = OK s\n  \\<not> app p s", "have \"err_step (size ts) app step p (ts!p) = error (size ts)\""], ["proof (prove)\nusing this:\n  ts ! p = OK s\n  \\<not> app p s\n\ngoal (1 subgoal):\n 1. err_step (length ts) app step p (ts ! p) = error (length ts)", "by (simp add: err_step_def)"], ["proof (state)\nthis:\n  err_step (length ts) app step p (ts ! p) = error (length ts)\n\ngoal (1 subgoal):\n 1. \\<not> app p (map ok_val ts ! p) \\<Longrightarrow> False", "with err ts"], ["proof (chain)\npicking this:\n  (0, Err) \\<in> set (error (length ts))\n  0 < length ts\n  err_step (length ts) app step p (ts ! p) = error (length ts)", "obtain q where \n      \"(q,Err) \\<in> set (err_step (size ts) app step p (ts!p))\" and\n      q: \"q < size ts\""], ["proof (prove)\nusing this:\n  (0, Err) \\<in> set (error (length ts))\n  0 < length ts\n  err_step (length ts) app step p (ts ! p) = error (length ts)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>(q, Err)\n                 \\<in> set (err_step (length ts) app step p (ts ! p));\n         q < length ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (q, Err) \\<in> set (err_step (length ts) app step p (ts ! p))\n  q < length ts\n\ngoal (1 subgoal):\n 1. \\<not> app p (map ok_val ts ! p) \\<Longrightarrow> False", "with less"], ["proof (chain)\npicking this:\n  \\<forall>(q, t)\\<in>set (err_step (length ts) app step p (ts ! p)).\n     t \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> ts ! q\n  (q, Err) \\<in> set (err_step (length ts) app step p (ts ! p))\n  q < length ts", "have \"ts!q = Err\""], ["proof (prove)\nusing this:\n  \\<forall>(q, t)\\<in>set (err_step (length ts) app step p (ts ! p)).\n     t \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> ts ! q\n  (q, Err) \\<in> set (err_step (length ts) app step p (ts ! p))\n  q < length ts\n\ngoal (1 subgoal):\n 1. ts ! q = Err", "by auto"], ["proof (state)\nthis:\n  ts ! q = Err\n\ngoal (1 subgoal):\n 1. \\<not> app p (map ok_val ts ! p) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ts ! q = Err\n\ngoal (1 subgoal):\n 1. \\<not> app p (map ok_val ts ! p) \\<Longrightarrow> False", "from q"], ["proof (chain)\npicking this:\n  q < length ts", "have \"ts!q \\<noteq> Err\""], ["proof (prove)\nusing this:\n  q < length ts\n\ngoal (1 subgoal):\n 1. ts ! q \\<noteq> Err", ".."], ["proof (state)\nthis:\n  ts ! q \\<noteq> Err\n\ngoal (1 subgoal):\n 1. \\<not> app p (map ok_val ts ! p) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  ts ! q = Err\n  ts ! q \\<noteq> Err", "show False"], ["proof (prove)\nusing this:\n  ts ! q = Err\n  ts ! q \\<noteq> Err\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  app p (map ok_val ts ! p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map ok_val ts) \\<Longrightarrow>\n       \\<forall>(q, \\<tau>)\\<in>set (step p (map ok_val ts ! p)).\n          \\<tau> \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! q", "show \"\\<forall>(q,t)\\<in>set(step p (map ok_val ts ! p)). t \\<sqsubseteq>\\<^sub>r map ok_val ts ! q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(q, t)\\<in>set (step p (map ok_val ts ! p)).\n       t \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! q", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (step p (map ok_val ts ! p)) \\<Longrightarrow>\n       b \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! a", "fix q t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (step p (map ok_val ts ! p)) \\<Longrightarrow>\n       b \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! a", "assume q: \"(q,t) \\<in> set (step p (map ok_val ts ! p))\""], ["proof (state)\nthis:\n  (q, t) \\<in> set (step p (map ok_val ts ! p))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (step p (map ok_val ts ! p)) \\<Longrightarrow>\n       b \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! a", "from wt lp q"], ["proof (chain)\npicking this:\n  wt_err_step r (err_step (length ts) app step) ts\n  p < length ts\n  (q, t) \\<in> set (step p (map ok_val ts ! p))", "obtain s where\n      OKp:  \"ts ! p = OK s\" and\n      less: \"\\<forall>(q,t) \\<in> set (err_step (size ts) app step p (ts!p)). t <=_(Err.le r) ts!q\""], ["proof (prove)\nusing this:\n  wt_err_step r (err_step (length ts) app step) ts\n  p < length ts\n  (q, t) \\<in> set (step p (map ok_val ts ! p))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>ts ! p = OK s;\n         \\<forall>(q, t)\\<in>set (err_step (length ts) app step p (ts ! p)).\n            t \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> ts ! q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold wt_err_step_def wt_step_def stable_def) \n         (auto iff: not_Err_eq)"], ["proof (state)\nthis:\n  ts ! p = OK s\n  \\<forall>(q, t)\\<in>set (err_step (length ts) app step p (ts ! p)).\n     t \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> ts ! q\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (step p (map ok_val ts ! p)) \\<Longrightarrow>\n       b \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! a", "from b lp app q"], ["proof (chain)\npicking this:\n  bounded (err_step (length ts) app step) (length ts)\n  p < length ts\n  app p (map ok_val ts ! p)\n  (q, t) \\<in> set (step p (map ok_val ts ! p))", "have lq: \"q < size ts\""], ["proof (prove)\nusing this:\n  bounded (err_step (length ts) app step) (length ts)\n  p < length ts\n  app p (map ok_val ts ! p)\n  (q, t) \\<in> set (step p (map ok_val ts ! p))\n\ngoal (1 subgoal):\n 1. q < length ts", "by (rule bounded_err_stepD)"], ["proof (state)\nthis:\n  q < length ts\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (step p (map ok_val ts ! p)) \\<Longrightarrow>\n       b \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! a", "hence \"ts!q \\<noteq> Err\""], ["proof (prove)\nusing this:\n  q < length ts\n\ngoal (1 subgoal):\n 1. ts ! q \\<noteq> Err", ".."], ["proof (state)\nthis:\n  ts ! q \\<noteq> Err\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (step p (map ok_val ts ! p)) \\<Longrightarrow>\n       b \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! a", "then"], ["proof (chain)\npicking this:\n  ts ! q \\<noteq> Err", "obtain s' where OKq: \"ts ! q = OK s'\""], ["proof (prove)\nusing this:\n  ts ! q \\<noteq> Err\n\ngoal (1 subgoal):\n 1. (\\<And>s'. ts ! q = OK s' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto iff: not_Err_eq)"], ["proof (state)\nthis:\n  ts ! q = OK s'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (step p (map ok_val ts ! p)) \\<Longrightarrow>\n       b \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! a", "from lp lq OKp OKq app less q"], ["proof (chain)\npicking this:\n  p < length ts\n  q < length ts\n  ts ! p = OK s\n  ts ! q = OK s'\n  app p (map ok_val ts ! p)\n  \\<forall>(q, t)\\<in>set (err_step (length ts) app step p (ts ! p)).\n     t \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> ts ! q\n  (q, t) \\<in> set (step p (map ok_val ts ! p))", "show \"t \\<sqsubseteq>\\<^sub>r map ok_val ts ! q\""], ["proof (prove)\nusing this:\n  p < length ts\n  q < length ts\n  ts ! p = OK s\n  ts ! q = OK s'\n  app p (map ok_val ts ! p)\n  \\<forall>(q, t)\\<in>set (err_step (length ts) app step p (ts ! p)).\n     t \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> ts ! q\n  (q, t) \\<in> set (step p (map ok_val ts ! p))\n\ngoal (1 subgoal):\n 1. t \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! q", "by (auto simp add: err_step_def map_snd_def)"], ["proof (state)\nthis:\n  t \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(q, t)\\<in>set (step p (map ok_val ts ! p)).\n     t \\<sqsubseteq>\\<^bsub>r\\<^esub> map ok_val ts ! q\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma wt_app_eff_imp_wt_err:\n  assumes app_eff: \"wt_app_eff r app step ts\"\n  assumes bounded: \"bounded (err_step (size ts) app step) (size ts)\"\n  shows \"wt_err_step r (err_step (size ts) app step) (map OK ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_err_step r (err_step (length ts) app step) (map OK ts)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wt_err_step r (err_step (length ts) app step) (map OK ts)", "proof (unfold wt_err_step_def wt_step_def, intro strip, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow> map OK ts ! p \\<noteq> Err\n 2. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow> map OK ts ! p \\<noteq> Err\n 2. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "assume \"p < size (map OK ts)\""], ["proof (state)\nthis:\n  p < length (map OK ts)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow> map OK ts ! p \\<noteq> Err\n 2. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "hence p: \"p < size ts\""], ["proof (prove)\nusing this:\n  p < length (map OK ts)\n\ngoal (1 subgoal):\n 1. p < length ts", "by simp"], ["proof (state)\nthis:\n  p < length ts\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow> map OK ts ! p \\<noteq> Err\n 2. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "thus \"map OK ts ! p \\<noteq> Err\""], ["proof (prove)\nusing this:\n  p < length ts\n\ngoal (1 subgoal):\n 1. map OK ts ! p \\<noteq> Err", "by simp"], ["proof (state)\nthis:\n  map OK ts ! p \\<noteq> Err\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "{"], ["proof (state)\nthis:\n  map OK ts ! p \\<noteq> Err\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "fix q t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "assume q: \"(q,t) \\<in> set (err_step (size ts) app step p (map OK ts ! p))\""], ["proof (state)\nthis:\n  (q, t) \\<in> set (err_step (length ts) app step p (map OK ts ! p))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "with p app_eff"], ["proof (chain)\npicking this:\n  p < length ts\n  wt_app_eff r app step ts\n  (q, t) \\<in> set (err_step (length ts) app step p (map OK ts ! p))", "obtain \n      \"app p (ts ! p)\" \"\\<forall>(q,t) \\<in> set (step p (ts!p)). t \\<sqsubseteq>\\<^sub>r ts!q\""], ["proof (prove)\nusing this:\n  p < length ts\n  wt_app_eff r app step ts\n  (q, t) \\<in> set (err_step (length ts) app step p (map OK ts ! p))\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>app p (ts ! p);\n      \\<forall>(q, t)\\<in>set (step p (ts ! p)).\n         t \\<sqsubseteq>\\<^bsub>r\\<^esub> ts ! q\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold wt_app_eff_def) blast"], ["proof (state)\nthis:\n  app p (ts ! p)\n  \\<forall>(q, t)\\<in>set (step p (ts ! p)).\n     t \\<sqsubseteq>\\<^bsub>r\\<^esub> ts ! q\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "moreover"], ["proof (state)\nthis:\n  app p (ts ! p)\n  \\<forall>(q, t)\\<in>set (step p (ts ! p)).\n     t \\<sqsubseteq>\\<^bsub>r\\<^esub> ts ! q\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "from q p bounded"], ["proof (chain)\npicking this:\n  (q, t) \\<in> set (err_step (length ts) app step p (map OK ts ! p))\n  p < length ts\n  bounded (err_step (length ts) app step) (length ts)", "have \"q < size ts\""], ["proof (prove)\nusing this:\n  (q, t) \\<in> set (err_step (length ts) app step p (map OK ts ! p))\n  p < length ts\n  bounded (err_step (length ts) app step) (length ts)\n\ngoal (1 subgoal):\n 1. q < length ts", "by - (rule boundedD)"], ["proof (state)\nthis:\n  q < length ts\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "hence \"map OK ts ! q = OK (ts!q)\""], ["proof (prove)\nusing this:\n  q < length ts\n\ngoal (1 subgoal):\n 1. map OK ts ! q = OK (ts ! q)", "by simp"], ["proof (state)\nthis:\n  map OK ts ! q = OK (ts ! q)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "moreover"], ["proof (state)\nthis:\n  map OK ts ! q = OK (ts ! q)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "have \"p < size ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p < length ts", "by (rule p)"], ["proof (state)\nthis:\n  p < length ts\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "moreover"], ["proof (state)\nthis:\n  p < length ts\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "note q"], ["proof (state)\nthis:\n  (q, t) \\<in> set (err_step (length ts) app step p (map OK ts ! p))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "ultimately"], ["proof (chain)\npicking this:\n  app p (ts ! p)\n  \\<forall>(q, t)\\<in>set (step p (ts ! p)).\n     t \\<sqsubseteq>\\<^bsub>r\\<^esub> ts ! q\n  map OK ts ! q = OK (ts ! q)\n  p < length ts\n  (q, t) \\<in> set (err_step (length ts) app step p (map OK ts ! p))", "have \"t \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> map OK ts ! q\""], ["proof (prove)\nusing this:\n  app p (ts ! p)\n  \\<forall>(q, t)\\<in>set (step p (ts ! p)).\n     t \\<sqsubseteq>\\<^bsub>r\\<^esub> ts ! q\n  map OK ts ! q = OK (ts ! q)\n  p < length ts\n  (q, t) \\<in> set (err_step (length ts) app step p (map OK ts ! p))\n\ngoal (1 subgoal):\n 1. t \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> map OK ts ! q", "by (auto simp add: err_step_def map_snd_def)"], ["proof (state)\nthis:\n  t \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> map OK ts ! q\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "}"], ["proof (state)\nthis:\n  (?q2, ?t2)\n  \\<in> set (err_step (length ts) app step p\n              (map OK ts ! p)) \\<Longrightarrow>\n  ?t2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> map OK ts ! ?q2\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p < length (map OK ts) \\<Longrightarrow>\n       stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "thus \"stable (Err.le r) (err_step (size ts) app step) (map OK ts) p\""], ["proof (prove)\nusing this:\n  (?q2, ?t2)\n  \\<in> set (err_step (length ts) app step p\n              (map OK ts ! p)) \\<Longrightarrow>\n  ?t2 \\<sqsubseteq>\\<^bsub>Err.le r\\<^esub> map OK ts ! ?q2\n\ngoal (1 subgoal):\n 1. stable (Err.le r) (err_step (length ts) app step) (map OK ts) p", "by (unfold stable_def) blast"], ["proof (state)\nthis:\n  stable (Err.le r) (err_step (length ts) app step) (map OK ts) p\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"]]}