{"file_name": "/home/qj213/afp-2021-10-22/thys/Jinja/Compiler/PCompiler.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jinja", "problem_names": ["lemma map_of_map4:\n  \"map_of (map (\\<lambda>(x,a,b,c).(x,a,b,f c)) ts) =\n  map_option (\\<lambda>(a,b,c).(a,b,f c)) \\<circ> (map_of ts)\"", "lemma class_compP:\n  \"class P C = Some (D, fs, ms)\n  \\<Longrightarrow> class (compP f P) C = Some (D, fs, map (compM f) ms)\"", "lemma class_compPD:\n  \"class (compP f P) C = Some (D, fs, cms)\n  \\<Longrightarrow> \\<exists>ms. class P C = Some(D,fs,ms) \\<and> cms = map (compM f) ms\"", "lemma [simp]: \"is_class (compP f P) C = is_class P C\"", "lemma [simp]: \"class (compP f P) C = map_option (\\<lambda>c. snd(compC f (C,c))) (class P C)\"", "lemma sees_methods_compP:\n  \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n  compP f P \\<turnstile> C sees_methods (map_option (\\<lambda>((Ts,T,m),D). ((Ts,T,f m),D)) \\<circ> Mm)\"", "lemma sees_method_compP:\n  \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = (f m) in D\"", "lemma [simp]:\n  \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  method (compP f P) C M = (D,Ts,T,f m)\"", "lemma sees_methods_compPD:\n  \"\\<lbrakk> cP \\<turnstile> C sees_methods Mm'; cP = compP f P \\<rbrakk> \\<Longrightarrow>\n  \\<exists>Mm. P \\<turnstile> C sees_methods Mm \\<and>\n        Mm' = (map_option (\\<lambda>((Ts,T,m),D). ((Ts,T,f m),D)) \\<circ> Mm)\"", "lemma sees_method_compPD:\n  \"compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = fm in D \\<Longrightarrow>\n  \\<exists>m. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<and> f m = fm\"", "lemma [simp]: \"subcls1(compP f P) = subcls1 P\"", "lemma compP_widen[simp]: \"(compP f P \\<turnstile> T \\<le> T') = (P \\<turnstile> T \\<le> T')\"", "lemma [simp]: \"(compP f P \\<turnstile> Ts [\\<le>] Ts') = (P \\<turnstile> Ts [\\<le>] Ts')\"", "lemma [simp]: \"is_type (compP f P) T = is_type P T\"", "lemma [simp]: \"(compP (f::'a\\<Rightarrow>'b) P \\<turnstile> C has_fields FDTs) = (P \\<turnstile> C has_fields FDTs)\"\n(*<*)\n (is \"?A = ?B\")", "lemma [simp]: \"fields (compP f P) C = fields P C\"", "lemma [simp]: \"(compP f P \\<turnstile> C sees F:T in D) = (P \\<turnstile> C sees F:T in D)\"", "lemma [simp]: \"field (compP f P) F D = field P F D\"", "lemma [iff]: \"distinct_fst (compP f P) = distinct_fst P\"", "lemma [iff]: \"distinct_fst (map (compM f) ms) = distinct_fst ms\"", "lemma [iff]: \"wf_syscls (compP f P) = wf_syscls P\"", "lemma [iff]: \"wf_fdecl (compP f P) = wf_fdecl P\"", "lemma set_compP:\n \"((C,D,fs,ms') \\<in> set(compP f P)) =\n  (\\<exists>ms. (C,D,fs,ms) \\<in> set P \\<and> ms' = map (compM f) ms)\"", "lemma wf_cdecl_compPI:\n  \"\\<lbrakk> \\<And>C M Ts T m. \n     \\<lbrakk> wf_mdecl wf\\<^sub>1 P C (M,Ts,T,m); P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in C \\<rbrakk>\n     \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C (M,Ts,T, f m);\n    \\<forall>x\\<in>set P. wf_cdecl wf\\<^sub>1 P x; x \\<in> set (compP f P); wf_prog p P \\<rbrakk>\n  \\<Longrightarrow> wf_cdecl wf\\<^sub>2 (compP f P) x\"", "lemma wf_prog_compPI:\nassumes lift: \n  \"\\<And>C M Ts T m. \n    \\<lbrakk> P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in C; wf_mdecl wf\\<^sub>1 P C (M,Ts,T,m) \\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C (M,Ts,T, f m)\"\nand wf: \"wf_prog wf\\<^sub>1 P\"\nshows \"wf_prog wf\\<^sub>2 (compP f P)\""], "translations": [["", "lemma map_of_map4:\n  \"map_of (map (\\<lambda>(x,a,b,c).(x,a,b,f c)) ts) =\n  map_option (\\<lambda>(a,b,c).(a,b,f c)) \\<circ> (map_of ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(x, a, b, c). (x, a, b, f c)) ts) =\n    map_option (\\<lambda>(a, b, c). (a, b, f c)) \\<circ> map_of ts", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(x, a, b, c). (x, a, b, f c)) ts) =\n    map_option (\\<lambda>(a, b, c). (a, b, f c)) \\<circ> map_of ts", "apply(induct ts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_of\n     (map (\\<lambda>a.\n              case a of (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f c))\n       []) =\n    map_option\n     (\\<lambda>a. case a of (a, ba, c) \\<Rightarrow> (a, ba, f c)) \\<circ>\n    map_of []\n 2. \\<And>a ts.\n       map_of\n        (map (\\<lambda>a.\n                 case a of (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f c))\n          ts) =\n       map_option\n        (\\<lambda>a.\n            case a of (a, ba, c) \\<Rightarrow> (a, ba, f c)) \\<circ>\n       map_of ts \\<Longrightarrow>\n       map_of\n        (map (\\<lambda>a.\n                 case a of (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f c))\n          (a # ts)) =\n       map_option\n        (\\<lambda>a.\n            case a of (a, ba, c) \\<Rightarrow> (a, ba, f c)) \\<circ>\n       map_of (a # ts)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ts.\n       map_of\n        (map (\\<lambda>a.\n                 case a of (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f c))\n          ts) =\n       map_option\n        (\\<lambda>a.\n            case a of (a, ba, c) \\<Rightarrow> (a, ba, f c)) \\<circ>\n       map_of ts \\<Longrightarrow>\n       map_of\n        (map (\\<lambda>a.\n                 case a of (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f c))\n          (a # ts)) =\n       map_option\n        (\\<lambda>a.\n            case a of (a, ba, c) \\<Rightarrow> (a, ba, f c)) \\<circ>\n       map_of (a # ts)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ts x.\n       map_of\n        (map (\\<lambda>a.\n                 case a of (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f c))\n          ts) =\n       map_option\n        (\\<lambda>a.\n            case a of (a, ba, c) \\<Rightarrow> (a, ba, f c)) \\<circ>\n       map_of ts \\<Longrightarrow>\n       map_of\n        (map (\\<lambda>a.\n                 case a of (x, aa, ba, c) \\<Rightarrow> (x, aa, ba, f c))\n          (a # ts))\n        x =\n       (map_option\n         (\\<lambda>a.\n             case a of (a, ba, c) \\<Rightarrow> (a, ba, f c)) \\<circ>\n        map_of (a # ts))\n        x", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma class_compP:\n  \"class P C = Some (D, fs, ms)\n  \\<Longrightarrow> class (compP f P) C = Some (D, fs, map (compM f) ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n    class (compP f P) C = \\<lfloor>(D, fs, map (compM f) ms)\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<Longrightarrow>\n    class (compP f P) C = \\<lfloor>(D, fs, map (compM f) ms)\\<rfloor>", "by(simp add:class_def compP_def compC_def map_of_map4)"], ["", "(*>*)"], ["", "lemma class_compPD:\n  \"class (compP f P) C = Some (D, fs, cms)\n  \\<Longrightarrow> \\<exists>ms. class P C = Some(D,fs,ms) \\<and> cms = map (compM f) ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class (compP f P) C = \\<lfloor>(D, fs, cms)\\<rfloor> \\<Longrightarrow>\n    \\<exists>ms.\n       class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n       cms = map (compM f) ms", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class (compP f P) C = \\<lfloor>(D, fs, cms)\\<rfloor> \\<Longrightarrow>\n    \\<exists>ms.\n       class P C = \\<lfloor>(D, fs, ms)\\<rfloor> \\<and>\n       cms = map (compM f) ms", "by(clarsimp simp add:class_def compP_def compC_def map_of_map4)"], ["", "(*>*)"], ["", "lemma [simp]: \"is_class (compP f P) C = is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_class (compP f P) C = is_class P C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_class (compP f P) C = is_class P C", "by(auto simp:is_class_def dest: class_compP class_compPD)"], ["", "(*>*)"], ["", "lemma [simp]: \"class (compP f P) C = map_option (\\<lambda>c. snd(compC f (C,c))) (class P C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class (compP f P) C =\n    map_option (\\<lambda>c. snd (compC f (C, c))) (class P C)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class (compP f P) C =\n    map_option (\\<lambda>c. snd (compC f (C, c))) (class P C)", "apply(simp add:compP_def compC_def class_def map_of_map4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option\n     (\\<lambda>(D, Fdecls, Mdecls). (D, Fdecls, map (compM f) Mdecls))\n     (map_of P C) =\n    map_option\n     (\\<lambda>c.\n         snd (case c of\n              (D, Fdecls, Mdecls) \\<Rightarrow>\n                (C, D, Fdecls, map (compM f) Mdecls)))\n     (map_of P C)", "apply(simp add:split_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_methods_compP:\n  \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n  compP f P \\<turnstile> C sees_methods (map_option (\\<lambda>((Ts,T,m),D). ((Ts,T,f m),D)) \\<circ> Mm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    compP f\n     P \\<turnstile> C sees_methods map_option\n                                    (\\<lambda>((Ts, T, m), D).\n  ((Ts, T, f m), D)) \\<circ>\n                                   Mm", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    compP f\n     P \\<turnstile> C sees_methods map_option\n                                    (\\<lambda>((Ts, T, m), D).\n  ((Ts, T, f m), D)) \\<circ>\n                                   Mm", "apply(erule Methods.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> Object sees_methods map_option\n                        (\\<lambda>a.\n                            case a of\n                            (a, b) \\<Rightarrow>\n                              (case a of\n                               (Ts, a) \\<Rightarrow>\n                                 case a of\n                                 (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                               b) \\<circ>\n                       Mm\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods map_option\n                   (\\<lambda>a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (Ts, a) \\<Rightarrow>\n                            case a of\n                            (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                          b) \\<circ>\n                  Mm'", "apply(rule sees_methods_Object)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> class (compP f P) Object =\n                         \\<lfloor>(?D4 D fs ms Mm, ?fs4 D fs ms Mm,\n                                   ?ms4 D fs ms Mm)\\<rfloor>\n 2. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          (\\<lambda>a.\n                              case a of\n                              (a, b) \\<Rightarrow>\n                                (case a of\n                                 (Ts, a) \\<Rightarrow>\n                                   case a of\n                                   (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                 b) \\<circ>\n                         Mm =\n                         map_option (\\<lambda>m. (m, Object)) \\<circ>\n                         map_of (?ms4 D fs ms Mm)\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods map_option\n                   (\\<lambda>a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (Ts, a) \\<Rightarrow>\n                            case a of\n                            (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                          b) \\<circ>\n                  Mm'", "apply(erule class_compP)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          (\\<lambda>a.\n                              case a of\n                              (a, b) \\<Rightarrow>\n                                (case a of\n                                 (Ts, a) \\<Rightarrow>\n                                   case a of\n                                   (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                 b) \\<circ>\n                         Mm =\n                         map_option (\\<lambda>m. (m, Object)) \\<circ>\n                         map_of (map (compM f) ms)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods map_option\n                   (\\<lambda>a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (Ts, a) \\<Rightarrow>\n                            case a of\n                            (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                          b) \\<circ>\n                  Mm'", "apply(rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm x.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> (map_option\n                           (\\<lambda>a.\n                               case a of\n                               (a, b) \\<Rightarrow>\n                                 (case a of\n                                  (Ts, a) \\<Rightarrow>\n                                    case a of\n                                    (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                  b) \\<circ>\n                          Mm)\n                          x =\n                         (map_option (\\<lambda>m. (m, Object)) \\<circ>\n                          map_of (map (compM f) ms))\n                          x\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods map_option\n                   (\\<lambda>a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (Ts, a) \\<Rightarrow>\n                            case a of\n                            (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                          b) \\<circ>\n                  Mm'", "apply(simp add:compM_def map_of_map4 option.map_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm x.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          (case_prod\n                            (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of ms x) =\n                         map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m). (Ts, T, f m)))\n                          (map_of ms x)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods map_option\n                   (\\<lambda>a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (Ts, a) \\<Rightarrow>\n                            case a of\n                            (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                          b) \\<circ>\n                  Mm'", "apply(case_tac \"map_of ms x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>D fs ms Mm x.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        map_of ms x = None\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          (case_prod\n                            (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of ms x) =\n                         map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m). (Ts, T, f m)))\n                          (map_of ms x)\n 2. \\<And>D fs ms Mm x a.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        map_of ms x = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          (case_prod\n                            (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of ms x) =\n                         map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m). (Ts, T, f m)))\n                          (map_of ms x)\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods map_option\n                   (\\<lambda>a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (Ts, a) \\<Rightarrow>\n                            case a of\n                            (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                          b) \\<circ>\n                  Mm'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm x a.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        map_of ms x = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          (case_prod\n                            (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of ms x) =\n                         map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m). (Ts, T, f m)))\n                          (map_of ms x)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods map_option\n                   (\\<lambda>a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (Ts, a) \\<Rightarrow>\n                            case a of\n                            (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                          b) \\<circ>\n                  Mm'", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> C sees_methods map_option\n                   (\\<lambda>a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (Ts, a) \\<Rightarrow>\n                            case a of\n                            (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                          b) \\<circ>\n                  Mm'", "apply(rule sees_methods_rec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> class (compP f P) C =\n                         \\<lfloor>(?D14 C D fs ms Mm Mm',\n                                   ?fs14 C D fs ms Mm Mm',\n                                   ?ms14 C D fs ms Mm Mm')\\<rfloor>\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> ?D14 C D fs ms Mm\n    Mm' sees_methods ?Mm14 C D fs ms Mm Mm'\n 4. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          (\\<lambda>a.\n                              case a of\n                              (a, b) \\<Rightarrow>\n                                (case a of\n                                 (Ts, a) \\<Rightarrow>\n                                   case a of\n                                   (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                 b) \\<circ>\n                         Mm' =\n                         ?Mm14 C D fs ms Mm Mm' ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (?ms14 C D fs ms Mm Mm'))", "apply(erule class_compP)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> D sees_methods ?Mm14 C D fs ms Mm\n                   Mm'\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          (\\<lambda>a.\n                              case a of\n                              (a, b) \\<Rightarrow>\n                                (case a of\n                                 (Ts, a) \\<Rightarrow>\n                                   case a of\n                                   (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                 b) \\<circ>\n                         Mm' =\n                         ?Mm14 C D fs ms Mm Mm' ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (map (compM f) ms))", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> compP f\n                          P \\<turnstile> D sees_methods ?Mm14 C D fs ms Mm\n                   Mm'\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          (\\<lambda>a.\n                              case a of\n                              (a, b) \\<Rightarrow>\n                                (case a of\n                                 (Ts, a) \\<Rightarrow>\n                                   case a of\n                                   (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                 b) \\<circ>\n                         Mm' =\n                         ?Mm14 C D fs ms Mm Mm' ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (map (compM f) ms))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          (\\<lambda>a.\n                              case a of\n                              (a, b) \\<Rightarrow>\n                                (case a of\n                                 (Ts, a) \\<Rightarrow>\n                                   case a of\n                                   (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                 b) \\<circ>\n                         Mm' =\n                         (map_option\n                           (\\<lambda>a.\n                               case a of\n                               (a, b) \\<Rightarrow>\n                                 (case a of\n                                  (Ts, a) \\<Rightarrow>\n                                    case a of\n                                    (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                  b) \\<circ>\n                          Mm) ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (map (compM f) ms))", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' x.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        compP f\n         P \\<turnstile> D sees_methods map_option\n  (\\<lambda>a.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (Ts, a) \\<Rightarrow>\n           case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n         b) \\<circ>\n Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> (map_option\n                           (\\<lambda>a.\n                               case a of\n                               (a, b) \\<Rightarrow>\n                                 (case a of\n                                  (Ts, a) \\<Rightarrow>\n                                    case a of\n                                    (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                  b) \\<circ>\n                          Mm')\n                          x =\n                         ((map_option\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (Ts, a) \\<Rightarrow>\n                                     case a of\n                                     (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                   b) \\<circ>\n                           Mm) ++\n                          (map_option (\\<lambda>m. (m, C)) \\<circ>\n                           map_of (map (compM f) ms)))\n                          x", "apply(simp add:map_add_def compM_def map_of_map4 option.map_comp split:option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_method_compP:\n  \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = (f m) in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = f m in D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = f m in D", "by(fastforce elim:sees_methods_compP simp add:Method_def)"], ["", "(*>*)"], ["", "lemma [simp]:\n  \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  method (compP f P) C M = (D,Ts,T,f m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    method (compP f P) C M = (D, Ts, T, f m)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    method (compP f P) C M = (D, Ts, T, f m)", "apply(drule sees_method_compP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compP ?f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = ?f m in D \\<Longrightarrow>\n    method (compP f P) C M = (D, Ts, T, f m)", "apply(simp add:method_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compP ?f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = ?f m in D \\<Longrightarrow>\n    (THE (D, Ts, T, m).\n        compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D) =\n    (D, Ts, T, f m)", "apply(rule the_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compP ?f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = ?f m in D \\<Longrightarrow>\n    case (D, Ts, T, f m) of\n    (D, Ts, T, m) \\<Rightarrow>\n      compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D\n 2. \\<And>x.\n       \\<lbrakk>compP ?f\n                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = ?f m in D;\n        case x of\n        (D, Ts, T, m) \\<Rightarrow>\n          compP f\n           P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D\\<rbrakk>\n       \\<Longrightarrow> x = (D, Ts, T, f m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>compP f\n                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = f m in D;\n        case x of\n        (D, Ts, T, m) \\<Rightarrow>\n          compP f\n           P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D\\<rbrakk>\n       \\<Longrightarrow> x = (D, Ts, T, f m)", "apply(fastforce dest:sees_method_fun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_methods_compPD:\n  \"\\<lbrakk> cP \\<turnstile> C sees_methods Mm'; cP = compP f P \\<rbrakk> \\<Longrightarrow>\n  \\<exists>Mm. P \\<turnstile> C sees_methods Mm \\<and>\n        Mm' = (map_option (\\<lambda>((Ts,T,m),D). ((Ts,T,f m),D)) \\<circ> Mm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cP \\<turnstile> C sees_methods Mm'; cP = compP f P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Mm.\n                         P \\<turnstile> C sees_methods Mm \\<and>\n                         Mm' =\n                         map_option\n                          (\\<lambda>((Ts, T, m), D).\n                              ((Ts, T, f m), D)) \\<circ>\n                         Mm", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cP \\<turnstile> C sees_methods Mm'; cP = compP f P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Mm.\n                         P \\<turnstile> C sees_methods Mm \\<and>\n                         Mm' =\n                         map_option\n                          (\\<lambda>((Ts, T, m), D).\n                              ((Ts, T, f m), D)) \\<circ>\n                         Mm", "apply(erule Methods.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm.\n       \\<lbrakk>cP = compP f P;\n        class cP Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mma.\n                            P \\<turnstile> Object sees_methods Mma \\<and>\n                            Mm =\n                            map_option\n                             (\\<lambda>a.\n                                 case a of\n                                 (a, b) \\<Rightarrow>\n                                   (case a of\n                                    (Ts, a) \\<Rightarrow>\ncase a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                    b) \\<circ>\n                            Mma\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           map_option\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (Ts, a) \\<Rightarrow>\n                     case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                   b) \\<circ>\n           Mma;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            map_option\n                             (\\<lambda>a.\n                                 case a of\n                                 (a, b) \\<Rightarrow>\n                                   (case a of\n                                    (Ts, a) \\<Rightarrow>\ncase a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                    b) \\<circ>\n                            Mm", "apply(clarsimp simp:compC_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs b.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> Object sees_methods Mm \\<and>\n                            (\\<lambda>a.\n                                map_option (\\<lambda>m. (m, Object))\n                                 (map_of (map (compM f) b) a)) =\n                            (\\<lambda>a.\n                                map_option\n                                 (case_prod\n                                   (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                                 (Mm a))\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           map_option\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (Ts, a) \\<Rightarrow>\n                     case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                   b) \\<circ>\n           Mma;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            map_option\n                             (\\<lambda>a.\n                                 case a of\n                                 (a, b) \\<Rightarrow>\n                                   (case a of\n                                    (Ts, a) \\<Rightarrow>\ncase a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                    b) \\<circ>\n                            Mm", "apply(rule exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs b.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object sees_methods ?Mm12 D fs\n                       b \\<and>\n                         (\\<lambda>a.\n                             map_option (\\<lambda>m. (m, Object))\n                              (map_of (map (compM f) b) a)) =\n                         (\\<lambda>a.\n                             map_option\n                              (case_prod\n                                (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                              (?Mm12 D fs b a))\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           map_option\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (Ts, a) \\<Rightarrow>\n                     case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                   b) \\<circ>\n           Mma;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            map_option\n                             (\\<lambda>a.\n                                 case a of\n                                 (a, b) \\<Rightarrow>\n                                   (case a of\n                                    (Ts, a) \\<Rightarrow>\ncase a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                    b) \\<circ>\n                            Mm", "apply(rule conjI, erule sees_methods_Object)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>D fs b.\n       cP = compP f P \\<Longrightarrow>\n       ?Mm12 D fs b = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of b\n 2. \\<And>D fs b.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>a.\n                             map_option (\\<lambda>m. (m, Object))\n                              (map_of (map (compM f) b) a)) =\n                         (\\<lambda>a.\n                             map_option\n                              (case_prod\n                                (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                              (?Mm12 D fs b a))\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           map_option\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (Ts, a) \\<Rightarrow>\n                     case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                   b) \\<circ>\n           Mma;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            map_option\n                             (\\<lambda>a.\n                                 case a of\n                                 (a, b) \\<Rightarrow>\n                                   (case a of\n                                    (Ts, a) \\<Rightarrow>\ncase a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                    b) \\<circ>\n                            Mm", "apply(rule refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs b.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>a.\n                             map_option (\\<lambda>m. (m, Object))\n                              (map_of (map (compM f) b) a)) =\n                         (\\<lambda>a.\n                             map_option\n                              (case_prod\n                                (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                              ((map_option (\\<lambda>m. (m, Object)) \\<circ>\n                                map_of b)\n                                a))\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           map_option\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (Ts, a) \\<Rightarrow>\n                     case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                   b) \\<circ>\n           Mma;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            map_option\n                             (\\<lambda>a.\n                                 case a of\n                                 (a, b) \\<Rightarrow>\n                                   (case a of\n                                    (Ts, a) \\<Rightarrow>\ncase a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                    b) \\<circ>\n                            Mm", "apply(rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs b x.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_option (\\<lambda>m. (m, Object))\n                          (map_of (map (compM f) b) x) =\n                         map_option\n                          (case_prod\n                            (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                          ((map_option (\\<lambda>m. (m, Object)) \\<circ>\n                            map_of b)\n                            x)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           map_option\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (Ts, a) \\<Rightarrow>\n                     case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                   b) \\<circ>\n           Mma;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            map_option\n                             (\\<lambda>a.\n                                 case a of\n                                 (a, b) \\<Rightarrow>\n                                   (case a of\n                                    (Ts, a) \\<Rightarrow>\ncase a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                    b) \\<circ>\n                            Mm", "apply(simp add:compM_def map_of_map4 option.map_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs b x.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m). (Ts, T, f m)))\n                          (map_of b x) =\n                         map_option\n                          (case_prod\n                            (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of b x)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           map_option\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (Ts, a) \\<Rightarrow>\n                     case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                   b) \\<circ>\n           Mma;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            map_option\n                             (\\<lambda>a.\n                                 case a of\n                                 (a, b) \\<Rightarrow>\n                                   (case a of\n                                    (Ts, a) \\<Rightarrow>\ncase a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                    b) \\<circ>\n                            Mm", "apply(case_tac \"map_of b x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>D fs b x.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>;\n        map_of b x = None\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m). (Ts, T, f m)))\n                          (map_of b x) =\n                         map_option\n                          (case_prod\n                            (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of b x)\n 2. \\<And>D fs b x a.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>;\n        map_of b x = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m). (Ts, T, f m)))\n                          (map_of b x) =\n                         map_option\n                          (case_prod\n                            (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of b x)\n 3. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           map_option\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (Ts, a) \\<Rightarrow>\n                     case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                   b) \\<circ>\n           Mma;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            map_option\n                             (\\<lambda>a.\n                                 case a of\n                                 (a, b) \\<Rightarrow>\n                                   (case a of\n                                    (Ts, a) \\<Rightarrow>\ncase a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                    b) \\<circ>\n                            Mm", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D fs b x a.\n       \\<lbrakk>cP = compP f P;\n        class P Object = \\<lfloor>(D, fs, b)\\<rfloor>;\n        map_of b x = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_option\n                          ((\\<lambda>m. (m, Object)) \\<circ>\n                           (\\<lambda>(Ts, T, m). (Ts, T, f m)))\n                          (map_of b x) =\n                         map_option\n                          (case_prod\n                            (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)) \\<circ>\n                           (\\<lambda>m. (m, Object)))\n                          (map_of b x)\n 2. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           map_option\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (Ts, a) \\<Rightarrow>\n                     case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                   b) \\<circ>\n           Mma;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            map_option\n                             (\\<lambda>a.\n                                 case a of\n                                 (a, b) \\<Rightarrow>\n                                   (case a of\n                                    (Ts, a) \\<Rightarrow>\ncase a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                    b) \\<circ>\n                            Mm", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm'.\n       \\<lbrakk>cP = compP f P; class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D sees_methods Mm;\n        \\<exists>Mma.\n           P \\<turnstile> D sees_methods Mma \\<and>\n           Mm =\n           map_option\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (Ts, a) \\<Rightarrow>\n                     case a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                   b) \\<circ>\n           Mma;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            Mm' =\n                            map_option\n                             (\\<lambda>a.\n                                 case a of\n                                 (a, b) \\<Rightarrow>\n                                   (case a of\n                                    (Ts, a) \\<Rightarrow>\ncase a of (T, m) \\<Rightarrow> Pair (Ts, T, f m))\n                                    b) \\<circ>\n                            Mm", "apply(clarsimp simp:compC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs b Mma.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>a.\n     map_option (case_prod (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n      (Mma a));\n        class P C = \\<lfloor>(D, fs, b)\\<rfloor>;\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm.\n                            P \\<turnstile> C sees_methods Mm \\<and>\n                            (\\<lambda>a.\n                                map_option\n                                 (case_prod\n                                   (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                                 (Mma a)) ++\n                            (map_option (\\<lambda>m. (m, C)) \\<circ>\n                             map_of (map (compM f) b)) =\n                            (\\<lambda>a.\n                                map_option\n                                 (case_prod\n                                   (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                                 (Mm a))", "apply(rule exI, rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs b Mma.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>a.\n     map_option (case_prod (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n      (Mma a));\n        class P C = \\<lfloor>(D, fs, b)\\<rfloor>;\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C sees_methods ?Mm32 C D fs b Mma\n 2. \\<And>C D fs b Mma.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>a.\n     map_option (case_prod (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n      (Mma a));\n        class P C = \\<lfloor>(D, fs, b)\\<rfloor>;\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>a.\n                             map_option\n                              (case_prod\n                                (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                              (Mma a)) ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (map (compM f) b)) =\n                         (\\<lambda>a.\n                             map_option\n                              (case_prod\n                                (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                              (?Mm32 C D fs b Mma a))", "apply(erule (2) sees_methods_rec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs b Mma.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>a.\n     map_option (case_prod (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n      (Mma a));\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> ?Mm32 C D fs b Mma =\n                         Mma ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ> map_of b)\n 2. \\<And>C D fs b Mma.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>a.\n     map_option (case_prod (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n      (Mma a));\n        class P C = \\<lfloor>(D, fs, b)\\<rfloor>;\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>a.\n                             map_option\n                              (case_prod\n                                (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                              (Mma a)) ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (map (compM f) b)) =\n                         (\\<lambda>a.\n                             map_option\n                              (case_prod\n                                (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                              (?Mm32 C D fs b Mma a))", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs b Mma.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>a.\n     map_option (case_prod (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n      (Mma a));\n        class P C = \\<lfloor>(D, fs, b)\\<rfloor>;\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>a.\n                             map_option\n                              (case_prod\n                                (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                              (Mma a)) ++\n                         (map_option (\\<lambda>m. (m, C)) \\<circ>\n                          map_of (map (compM f) b)) =\n                         (\\<lambda>a.\n                             map_option\n                              (case_prod\n                                (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                              ((Mma ++\n                                (map_option (\\<lambda>m. (m, C)) \\<circ>\n                                 map_of b))\n                                a))", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs b Mma x.\n       \\<lbrakk>cP = compP f P; C \\<noteq> Object;\n        compP f\n         P \\<turnstile> D sees_methods (\\<lambda>a.\n     map_option (case_prod (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n      (Mma a));\n        class P C = \\<lfloor>(D, fs, b)\\<rfloor>;\n        P \\<turnstile> D sees_methods Mma\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>a.\n                              map_option\n                               (case_prod\n                                 (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                               (Mma a)) ++\n                          (map_option (\\<lambda>m. (m, C)) \\<circ>\n                           map_of (map (compM f) b)))\n                          x =\n                         map_option\n                          (case_prod\n                            (\\<lambda>(Ts, T, m). Pair (Ts, T, f m)))\n                          ((Mma ++\n                            (map_option (\\<lambda>m. (m, C)) \\<circ>\n                             map_of b))\n                            x)", "apply(simp add:map_add_def compM_def map_of_map4 option.map_comp split:option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_method_compPD:\n  \"compP f P \\<turnstile> C sees M: Ts\\<rightarrow>T = fm in D \\<Longrightarrow>\n  \\<exists>m. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<and> f m = fm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = fm in D \\<Longrightarrow>\n    \\<exists>m.\n       P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<and> f m = fm", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = fm in D \\<Longrightarrow>\n    \\<exists>m.\n       P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<and> f m = fm", "apply(simp add:Method_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Mm.\n       compP f P \\<turnstile> C sees_methods Mm \\<and>\n       Mm M = \\<lfloor>((Ts, T, fm), D)\\<rfloor> \\<Longrightarrow>\n    \\<exists>m.\n       (\\<exists>Mm.\n           P \\<turnstile> C sees_methods Mm \\<and>\n           Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>) \\<and>\n       f m = fm", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm.\n       \\<lbrakk>compP f P \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, fm), D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            (\\<exists>Mm.\n                                P \\<turnstile> C sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts, T, m), D)\\<rfloor>) \\<and>\n                            f m = fm", "apply(drule sees_methods_compPD[OF _ refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm.\n       \\<lbrakk>Mm M = \\<lfloor>((Ts, T, fm), D)\\<rfloor>;\n        \\<exists>Mma.\n           P \\<turnstile> C sees_methods Mma \\<and>\n           Mm =\n           map_option (\\<lambda>((Ts, T, m), D). ((Ts, T, f m), D)) \\<circ>\n           Mma\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            (\\<exists>Mm.\n                                P \\<turnstile> C sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts, T, m), D)\\<rfloor>) \\<and>\n                            f m = fm", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mma b.\n       \\<lbrakk>P \\<turnstile> C sees_methods Mma;\n        Mma M = \\<lfloor>((Ts, T, b), D)\\<rfloor>; fm = f b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            (\\<exists>Mm.\n                                P \\<turnstile> C sees_methods Mm \\<and>\n                                Mm M =\n                                \\<lfloor>((Ts, T, m), D)\\<rfloor>) \\<and>\n                            f m = f b", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma [simp]: \"subcls1(compP f P) = subcls1 P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls1 (compP f P) = subcls1 P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls1 (compP f P) = subcls1 P", "by(fastforce simp add: is_class_def compC_def intro:subcls1I order_antisym dest:subcls1D)"], ["", "(*>*)"], ["", "lemma compP_widen[simp]: \"(compP f P \\<turnstile> T \\<le> T') = (P \\<turnstile> T \\<le> T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> T \\<le> T' = P \\<turnstile> T \\<le> T'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> T \\<le> T' = P \\<turnstile> T \\<le> T'", "by(cases T')(simp_all add:widen_Class)"], ["", "(*>*)"], ["", "lemma [simp]: \"(compP f P \\<turnstile> Ts [\\<le>] Ts') = (P \\<turnstile> Ts [\\<le>] Ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> Ts [\\<le>] Ts' = P \\<turnstile> Ts [\\<le>] Ts'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> Ts [\\<le>] Ts' = P \\<turnstile> Ts [\\<le>] Ts'", "apply(induct Ts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> [] [\\<le>] Ts' = P \\<turnstile> [] [\\<le>] Ts'\n 2. \\<And>a Ts.\n       compP f P \\<turnstile> Ts [\\<le>] Ts' =\n       P \\<turnstile> Ts [\\<le>] Ts' \\<Longrightarrow>\n       compP f P \\<turnstile> (a # Ts) [\\<le>] Ts' =\n       P \\<turnstile> (a # Ts) [\\<le>] Ts'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Ts.\n       compP f P \\<turnstile> Ts [\\<le>] Ts' =\n       P \\<turnstile> Ts [\\<le>] Ts' \\<Longrightarrow>\n       compP f P \\<turnstile> (a # Ts) [\\<le>] Ts' =\n       P \\<turnstile> (a # Ts) [\\<le>] Ts'", "apply(cases Ts')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a Ts.\n       \\<lbrakk>compP f P \\<turnstile> Ts [\\<le>] Ts' =\n                P \\<turnstile> Ts [\\<le>] Ts';\n        Ts' = []\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> (a # Ts) [\\<le>] Ts' =\n                         P \\<turnstile> (a # Ts) [\\<le>] Ts'\n 2. \\<And>a Ts aa list.\n       \\<lbrakk>compP f P \\<turnstile> Ts [\\<le>] Ts' =\n                P \\<turnstile> Ts [\\<le>] Ts';\n        Ts' = aa # list\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> (a # Ts) [\\<le>] Ts' =\n                         P \\<turnstile> (a # Ts) [\\<le>] Ts'", "apply(auto simp:fun_of_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma [simp]: \"is_type (compP f P) T = is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type (compP f P) T = is_type P T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type (compP f P) T = is_type P T", "by(cases T) simp_all"], ["", "(*>*)"], ["", "lemma [simp]: \"(compP (f::'a\\<Rightarrow>'b) P \\<turnstile> C has_fields FDTs) = (P \\<turnstile> C has_fields FDTs)\"\n(*<*)\n (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P \\<turnstile> C has_fields FDTs) =\n    (P \\<turnstile> C has_fields FDTs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "fix cP::\"'b prog\""], ["proof (state)\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "assume \"cP \\<turnstile> C has_fields FDTs\""], ["proof (state)\nthis:\n  cP \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "hence \"cP = compP f P \\<Longrightarrow> P \\<turnstile> C has_fields FDTs\""], ["proof (prove)\nusing this:\n  cP \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. cP = compP f P \\<Longrightarrow> P \\<turnstile> C has_fields FDTs", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D has_fields FDTs;\n        cP = compP f P \\<Longrightarrow> P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class cP Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object has_fields FDTs", "case has_fields_Object"], ["proof (state)\nthis:\n  class cP Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n  cP = compP f P\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D has_fields FDTs;\n        cP = compP f P \\<Longrightarrow> P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class cP Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object has_fields FDTs", "thus ?case"], ["proof (prove)\nusing this:\n  class cP Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n  cP = compP f P\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Object has_fields FDTs_", "by(fast intro:Fields.has_fields_Object dest:class_compPD)"], ["proof (state)\nthis:\n  P \\<turnstile> Object has_fields FDTs_\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D has_fields FDTs;\n        cP = compP f P \\<Longrightarrow> P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D has_fields FDTs;\n        cP = compP f P \\<Longrightarrow> P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'", "case has_fields_rec"], ["proof (state)\nthis:\n  class cP C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  cP \\<turnstile> D_ has_fields FDTs_\n  cP = compP f P \\<Longrightarrow> P \\<turnstile> D_ has_fields FDTs_\n  FDTs'_ = map (\\<lambda>(F, T). ((F, C_), T)) fs_ @ FDTs_\n  cP = compP f P\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class cP C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; cP \\<turnstile> D has_fields FDTs;\n        cP = compP f P \\<Longrightarrow> P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        cP = compP f P\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'", "thus ?case"], ["proof (prove)\nusing this:\n  class cP C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  cP \\<turnstile> D_ has_fields FDTs_\n  cP = compP f P \\<Longrightarrow> P \\<turnstile> D_ has_fields FDTs_\n  FDTs'_ = map (\\<lambda>(F, T). ((F, C_), T)) fs_ @ FDTs_\n  cP = compP f P\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C_ has_fields FDTs'_", "by(fast intro:Fields.has_fields_rec dest:class_compPD)"], ["proof (state)\nthis:\n  P \\<turnstile> C_ has_fields FDTs'_\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cP = compP f P \\<Longrightarrow> P \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?cP2 \\<turnstile> C has_fields FDTs; ?cP2 = compP f P\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "note lem = this"], ["proof (state)\nthis:\n  \\<lbrakk>?cP2 \\<turnstile> C has_fields FDTs; ?cP2 = compP f P\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "assume ?A"], ["proof (state)\nthis:\n  compP f P \\<turnstile> C has_fields FDTs\n\ngoal (2 subgoals):\n 1. compP f P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields FDTs\n 2. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "with lem"], ["proof (chain)\npicking this:\n  \\<lbrakk>?cP2 \\<turnstile> C has_fields FDTs; ?cP2 = compP f P\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C has_fields FDTs\n  compP f P \\<turnstile> C has_fields FDTs", "show ?B"], ["proof (prove)\nusing this:\n  \\<lbrakk>?cP2 \\<turnstile> C has_fields FDTs; ?cP2 = compP f P\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C has_fields FDTs\n  compP f P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs", "by blast"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "assume ?B"], ["proof (state)\nthis:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    compP f P \\<turnstile> C has_fields FDTs", "thus ?A"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> C has_fields FDTs", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        compP f P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> C has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> Object has_fields FDTs", "case has_fields_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        compP f P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> C has_fields FDTs'\n 2. \\<And>D fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> Object has_fields FDTs", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> Object has_fields FDTs_", "by(fast intro:Fields.has_fields_Object class_compP)"], ["proof (state)\nthis:\n  compP f P \\<turnstile> Object has_fields FDTs_\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        compP f P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> C has_fields FDTs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        compP f P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> C has_fields FDTs'", "case has_fields_rec"], ["proof (state)\nthis:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ has_fields FDTs_\n  compP f P \\<turnstile> D_ has_fields FDTs_\n  FDTs'_ = map (\\<lambda>(F, T). ((F, C_), T)) fs_ @ FDTs_\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        compP f P \\<turnstile> D has_fields FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs\\<rbrakk>\n       \\<Longrightarrow> compP f P \\<turnstile> C has_fields FDTs'", "thus ?case"], ["proof (prove)\nusing this:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ has_fields FDTs_\n  compP f P \\<turnstile> D_ has_fields FDTs_\n  FDTs'_ = map (\\<lambda>(F, T). ((F, C_), T)) fs_ @ FDTs_\n\ngoal (1 subgoal):\n 1. compP f P \\<turnstile> C_ has_fields FDTs'_", "by(fast intro:Fields.has_fields_rec class_compP)"], ["proof (state)\nthis:\n  compP f P \\<turnstile> C_ has_fields FDTs'_\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compP f P \\<turnstile> C has_fields FDTs\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma [simp]: \"fields (compP f P) C = fields P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fields (compP f P) C = fields P C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fields (compP f P) C = fields P C", "by(simp add:fields_def)"], ["", "(*>*)"], ["", "lemma [simp]: \"(compP f P \\<turnstile> C sees F:T in D) = (P \\<turnstile> C sees F:T in D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P \\<turnstile> C sees F:T in D) =\n    (P \\<turnstile> C sees F:T in D)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (compP f P \\<turnstile> C sees F:T in D) =\n    (P \\<turnstile> C sees F:T in D)", "by(simp add:sees_field_def)"], ["", "(*>*)"], ["", "lemma [simp]: \"field (compP f P) F D = field P F D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field (compP f P) F D = field P F D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. field (compP f P) F D = field P F D", "by(simp add:field_def)"], ["", "(*>*)"], ["", "subsection\\<open>Invariance of @{term wf_prog} under compilation\\<close>"], ["", "lemma [iff]: \"distinct_fst (compP f P) = distinct_fst P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst (compP f P) = distinct_fst P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst (compP f P) = distinct_fst P", "apply(simp add:distinct_fst_def compP_def compC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (fst \\<circ>\n           (\\<lambda>(C, D, Fdecls, Mdecls).\n               (C, D, Fdecls, map (compM f) Mdecls)))\n       P) =\n    distinct (map fst P)", "apply(induct P)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct\n     (map (fst \\<circ>\n           (\\<lambda>a.\n               case a of\n               (C, D, Fdecls, Mdecls) \\<Rightarrow>\n                 (C, D, Fdecls, map (compM f) Mdecls)))\n       []) =\n    distinct (map fst [])\n 2. \\<And>a P.\n       distinct\n        (map (fst \\<circ>\n              (\\<lambda>a.\n                  case a of\n                  (C, D, Fdecls, Mdecls) \\<Rightarrow>\n                    (C, D, Fdecls, map (compM f) Mdecls)))\n          P) =\n       distinct (map fst P) \\<Longrightarrow>\n       distinct\n        (map (fst \\<circ>\n              (\\<lambda>a.\n                  case a of\n                  (C, D, Fdecls, Mdecls) \\<Rightarrow>\n                    (C, D, Fdecls, map (compM f) Mdecls)))\n          (a # P)) =\n       distinct (map fst (a # P))", "apply (auto simp:image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma [iff]: \"distinct_fst (map (compM f) ms) = distinct_fst ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst (map (compM f) ms) = distinct_fst ms", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst (map (compM f) ms) = distinct_fst ms", "apply(simp add:distinct_fst_def compM_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (fst \\<circ> (\\<lambda>(M, Ts, T, m). (M, Ts, T, f m))) ms) =\n    distinct (map fst ms)", "apply(induct ms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct\n     (map (fst \\<circ>\n           (\\<lambda>a.\n               case a of (M, Ts, T, m) \\<Rightarrow> (M, Ts, T, f m)))\n       []) =\n    distinct (map fst [])\n 2. \\<And>a ms.\n       distinct\n        (map (fst \\<circ>\n              (\\<lambda>a.\n                  case a of (M, Ts, T, m) \\<Rightarrow> (M, Ts, T, f m)))\n          ms) =\n       distinct (map fst ms) \\<Longrightarrow>\n       distinct\n        (map (fst \\<circ>\n              (\\<lambda>a.\n                  case a of (M, Ts, T, m) \\<Rightarrow> (M, Ts, T, f m)))\n          (a # ms)) =\n       distinct (map fst (a # ms))", "apply (auto simp:image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma [iff]: \"wf_syscls (compP f P) = wf_syscls P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_syscls (compP f P) = wf_syscls P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_syscls (compP f P) = wf_syscls P", "by(simp add:wf_syscls_def compP_def compC_def image_def Bex_def)"], ["", "(*>*)"], ["", "lemma [iff]: \"wf_fdecl (compP f P) = wf_fdecl P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fdecl (compP f P) = wf_fdecl P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fdecl (compP f P) = wf_fdecl P", "by(simp add:wf_fdecl_def)"], ["", "(*>*)"], ["", "lemma set_compP:\n \"((C,D,fs,ms') \\<in> set(compP f P)) =\n  (\\<exists>ms. (C,D,fs,ms) \\<in> set P \\<and> ms' = map (compM f) ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((C, D, fs, ms') \\<in> set (compP f P)) =\n    (\\<exists>ms. (C, D, fs, ms) \\<in> set P \\<and> ms' = map (compM f) ms)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((C, D, fs, ms') \\<in> set (compP f P)) =\n    (\\<exists>ms. (C, D, fs, ms) \\<in> set P \\<and> ms' = map (compM f) ms)", "by(fastforce simp add:compP_def compC_def image_iff Bex_def)"], ["", "(*>*)"], ["", "lemma wf_cdecl_compPI:\n  \"\\<lbrakk> \\<And>C M Ts T m. \n     \\<lbrakk> wf_mdecl wf\\<^sub>1 P C (M,Ts,T,m); P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in C \\<rbrakk>\n     \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C (M,Ts,T, f m);\n    \\<forall>x\\<in>set P. wf_cdecl wf\\<^sub>1 P x; x \\<in> set (compP f P); wf_prog p P \\<rbrakk>\n  \\<Longrightarrow> wf_cdecl wf\\<^sub>2 (compP f P) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>C M Ts T m.\n                \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n                                   (M, Ts, T, f m);\n     \\<forall>x\\<in>set P. wf_cdecl wf\\<^sub>1 P x; x \\<in> set (compP f P);\n     wf_prog p P\\<rbrakk>\n    \\<Longrightarrow> wf_cdecl wf\\<^sub>2 (compP f P) x", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>C M Ts T m.\n                \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                 P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n                                   (M, Ts, T, f m);\n     \\<forall>x\\<in>set P. wf_cdecl wf\\<^sub>1 P x; x \\<in> set (compP f P);\n     wf_prog p P\\<rbrakk>\n    \\<Longrightarrow> wf_cdecl wf\\<^sub>2 (compP f P) x", "apply(clarsimp simp add:wf_cdecl_def Ball_def set_compP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C a aa ms.\n       \\<lbrakk>\\<And>C M Ts T m.\n                   \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                   \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n(M, Ts, T, f m);\n        \\<forall>a aa ab b.\n           (a, aa, ab, b) \\<in> set P \\<longrightarrow>\n           (\\<forall>a b.\n               (a, b) \\<in> set ab \\<longrightarrow>\n               wf_fdecl P (a, b)) \\<and>\n           distinct_fst ab \\<and>\n           (\\<forall>aa ab ac ba.\n               (aa, ab, ac, ba) \\<in> set b \\<longrightarrow>\n               wf_mdecl wf\\<^sub>1 P a (aa, ab, ac, ba)) \\<and>\n           distinct_fst b \\<and>\n           (a \\<noteq> Object \\<longrightarrow>\n            is_class P aa \\<and>\n            (aa, a) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n            (\\<forall>a ab ac.\n                (\\<exists>ba. (a, ab, ac, ba) \\<in> set b) \\<longrightarrow>\n                (\\<forall>D' Ts' T'.\n                    (\\<exists>m'.\n                        P \\<turnstile> aa sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                    P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                    P \\<turnstile> ac \\<le> T')));\n        wf_prog p P; x = (C, a, aa, map (compM f) ms);\n        (C, a, aa, ms) \\<in> set P\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a aa ab b.\n                             (a, aa, ab, b)\n                             \\<in> compM f ` set ms \\<longrightarrow>\n                             wf_mdecl wf\\<^sub>2 (compP f P) C\n                              (a, aa, ab, b)) \\<and>\n                         (C \\<noteq> Object \\<longrightarrow>\n                          (\\<forall>aa ab ac.\n                              (\\<exists>b.\n                                  (aa, ab, ac, b)\n                                  \\<in> compM f ` set ms) \\<longrightarrow>\n                              (\\<forall>D' Ts' T'.\n                                  (\\<exists>m'.\ncompP f\n P \\<turnstile> a sees aa: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                                  P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                                  P \\<turnstile> ac \\<le> T')))", "apply(rename_tac C D fs ms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms.\n       \\<lbrakk>\\<And>C M Ts T m.\n                   \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                   \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n(M, Ts, T, f m);\n        \\<forall>a aa ab b.\n           (a, aa, ab, b) \\<in> set P \\<longrightarrow>\n           (\\<forall>a b.\n               (a, b) \\<in> set ab \\<longrightarrow>\n               wf_fdecl P (a, b)) \\<and>\n           distinct_fst ab \\<and>\n           (\\<forall>aa ab ac ba.\n               (aa, ab, ac, ba) \\<in> set b \\<longrightarrow>\n               wf_mdecl wf\\<^sub>1 P a (aa, ab, ac, ba)) \\<and>\n           distinct_fst b \\<and>\n           (a \\<noteq> Object \\<longrightarrow>\n            is_class P aa \\<and>\n            (aa, a) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n            (\\<forall>a ab ac.\n                (\\<exists>ba. (a, ab, ac, ba) \\<in> set b) \\<longrightarrow>\n                (\\<forall>D' Ts' T'.\n                    (\\<exists>m'.\n                        P \\<turnstile> aa sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                    P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                    P \\<turnstile> ac \\<le> T')));\n        wf_prog p P; x = (C, D, fs, map (compM f) ms);\n        (C, D, fs, ms) \\<in> set P\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a aa ab b.\n                             (a, aa, ab, b)\n                             \\<in> compM f ` set ms \\<longrightarrow>\n                             wf_mdecl wf\\<^sub>2 (compP f P) C\n                              (a, aa, ab, b)) \\<and>\n                         (C \\<noteq> Object \\<longrightarrow>\n                          (\\<forall>a aa ab.\n                              (\\<exists>b.\n                                  (a, aa, ab, b)\n                                  \\<in> compM f ` set ms) \\<longrightarrow>\n                              (\\<forall>D' Ts' T'.\n                                  (\\<exists>m'.\ncompP f\n P \\<turnstile> D sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                                  P \\<turnstile> Ts' [\\<le>] aa \\<and>\n                                  P \\<turnstile> ab \\<le> T')))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms.\n       \\<lbrakk>\\<And>C M Ts T m.\n                   \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                   \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n(M, Ts, T, f m);\n        \\<forall>a aa ab b.\n           (a, aa, ab, b) \\<in> set P \\<longrightarrow>\n           (\\<forall>a b.\n               (a, b) \\<in> set ab \\<longrightarrow>\n               wf_fdecl P (a, b)) \\<and>\n           distinct_fst ab \\<and>\n           (\\<forall>aa ab ac ba.\n               (aa, ab, ac, ba) \\<in> set b \\<longrightarrow>\n               wf_mdecl wf\\<^sub>1 P a (aa, ab, ac, ba)) \\<and>\n           distinct_fst b \\<and>\n           (a \\<noteq> Object \\<longrightarrow>\n            is_class P aa \\<and>\n            (aa, a) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n            (\\<forall>a ab ac.\n                (\\<exists>ba. (a, ab, ac, ba) \\<in> set b) \\<longrightarrow>\n                (\\<forall>D' Ts' T'.\n                    (\\<exists>m'.\n                        P \\<turnstile> aa sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                    P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                    P \\<turnstile> ac \\<le> T')));\n        wf_prog p P; x = (C, D, fs, map (compM f) ms);\n        (C, D, fs, ms) \\<in> set P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a aa ab b.\n                            (a, aa, ab, b)\n                            \\<in> compM f ` set ms \\<longrightarrow>\n                            wf_mdecl wf\\<^sub>2 (compP f P) C (a, aa, ab, b)\n 2. \\<And>C D fs ms.\n       \\<lbrakk>\\<And>C M Ts T m.\n                   \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                   \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n(M, Ts, T, f m);\n        \\<forall>a aa ab b.\n           (a, aa, ab, b) \\<in> set P \\<longrightarrow>\n           (\\<forall>a b.\n               (a, b) \\<in> set ab \\<longrightarrow>\n               wf_fdecl P (a, b)) \\<and>\n           distinct_fst ab \\<and>\n           (\\<forall>aa ab ac ba.\n               (aa, ab, ac, ba) \\<in> set b \\<longrightarrow>\n               wf_mdecl wf\\<^sub>1 P a (aa, ab, ac, ba)) \\<and>\n           distinct_fst b \\<and>\n           (a \\<noteq> Object \\<longrightarrow>\n            is_class P aa \\<and>\n            (aa, a) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n            (\\<forall>a ab ac.\n                (\\<exists>ba. (a, ab, ac, ba) \\<in> set b) \\<longrightarrow>\n                (\\<forall>D' Ts' T'.\n                    (\\<exists>m'.\n                        P \\<turnstile> aa sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                    P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                    P \\<turnstile> ac \\<le> T')));\n        wf_prog p P; x = (C, D, fs, map (compM f) ms);\n        (C, D, fs, ms) \\<in> set P\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object \\<longrightarrow>\n                         (\\<forall>a aa ab.\n                             (\\<exists>b.\n                                 (a, aa, ab, b)\n                                 \\<in> compM f ` set ms) \\<longrightarrow>\n                             (\\<forall>D' Ts' T'.\n                                 (\\<exists>m'.\n                                     compP f\nP \\<turnstile> D sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                                 P \\<turnstile> Ts' [\\<le>] aa \\<and>\n                                 P \\<turnstile> ab \\<le> T'))", "apply (clarsimp simp:compM_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms ac ad ae ba.\n       \\<lbrakk>\\<And>C M Ts T m.\n                   \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                   \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n(M, Ts, T, f m);\n        \\<forall>a aa ab b.\n           (a, aa, ab, b) \\<in> set P \\<longrightarrow>\n           (\\<forall>a b.\n               (a, b) \\<in> set ab \\<longrightarrow>\n               wf_fdecl P (a, b)) \\<and>\n           distinct_fst ab \\<and>\n           (\\<forall>aa ab ac ba.\n               (aa, ab, ac, ba) \\<in> set b \\<longrightarrow>\n               wf_mdecl wf\\<^sub>1 P a (aa, ab, ac, ba)) \\<and>\n           distinct_fst b \\<and>\n           (a \\<noteq> Object \\<longrightarrow>\n            is_class P aa \\<and>\n            (aa, a) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n            (\\<forall>a ab ac.\n                (\\<exists>ba. (a, ab, ac, ba) \\<in> set b) \\<longrightarrow>\n                (\\<forall>D' Ts' T'.\n                    (\\<exists>m'.\n                        P \\<turnstile> aa sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                    P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                    P \\<turnstile> ac \\<le> T')));\n        wf_prog p P;\n        x = (C, D, fs, map (\\<lambda>(M, Ts, T, m). (M, Ts, T, f m)) ms);\n        (C, D, fs, ms) \\<in> set P; (ac, ad, ae, ba) \\<in> set ms\\<rbrakk>\n       \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n                          (ac, ad, ae, f ba)\n 2. \\<And>C D fs ms.\n       \\<lbrakk>\\<And>C M Ts T m.\n                   \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                   \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n(M, Ts, T, f m);\n        \\<forall>a aa ab b.\n           (a, aa, ab, b) \\<in> set P \\<longrightarrow>\n           (\\<forall>a b.\n               (a, b) \\<in> set ab \\<longrightarrow>\n               wf_fdecl P (a, b)) \\<and>\n           distinct_fst ab \\<and>\n           (\\<forall>aa ab ac ba.\n               (aa, ab, ac, ba) \\<in> set b \\<longrightarrow>\n               wf_mdecl wf\\<^sub>1 P a (aa, ab, ac, ba)) \\<and>\n           distinct_fst b \\<and>\n           (a \\<noteq> Object \\<longrightarrow>\n            is_class P aa \\<and>\n            (aa, a) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n            (\\<forall>a ab ac.\n                (\\<exists>ba. (a, ab, ac, ba) \\<in> set b) \\<longrightarrow>\n                (\\<forall>D' Ts' T'.\n                    (\\<exists>m'.\n                        P \\<turnstile> aa sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                    P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                    P \\<turnstile> ac \\<le> T')));\n        wf_prog p P; x = (C, D, fs, map (compM f) ms);\n        (C, D, fs, ms) \\<in> set P\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object \\<longrightarrow>\n                         (\\<forall>a aa ab.\n                             (\\<exists>b.\n                                 (a, aa, ab, b)\n                                 \\<in> compM f ` set ms) \\<longrightarrow>\n                             (\\<forall>D' Ts' T'.\n                                 (\\<exists>m'.\n                                     compP f\nP \\<turnstile> D sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                                 P \\<turnstile> Ts' [\\<le>] aa \\<and>\n                                 P \\<turnstile> ab \\<le> T'))", "apply (drule (2) mdecl_visible)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms ac ad ae ba.\n       \\<lbrakk>\\<And>C M Ts T m.\n                   \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                   \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n(M, Ts, T, f m);\n        \\<forall>a aa ab b.\n           (a, aa, ab, b) \\<in> set P \\<longrightarrow>\n           (\\<forall>a b.\n               (a, b) \\<in> set ab \\<longrightarrow>\n               wf_fdecl P (a, b)) \\<and>\n           distinct_fst ab \\<and>\n           (\\<forall>aa ab ac ba.\n               (aa, ab, ac, ba) \\<in> set b \\<longrightarrow>\n               wf_mdecl wf\\<^sub>1 P a (aa, ab, ac, ba)) \\<and>\n           distinct_fst b \\<and>\n           (a \\<noteq> Object \\<longrightarrow>\n            is_class P aa \\<and>\n            (aa, a) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n            (\\<forall>a ab ac.\n                (\\<exists>ba. (a, ab, ac, ba) \\<in> set b) \\<longrightarrow>\n                (\\<forall>D' Ts' T'.\n                    (\\<exists>m'.\n                        P \\<turnstile> aa sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                    P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                    P \\<turnstile> ac \\<le> T')));\n        x = (C, D, fs, map (\\<lambda>(M, Ts, T, m). (M, Ts, T, f m)) ms);\n        (C, D, fs, ms) \\<in> set P; (ac, ad, ae, ba) \\<in> set ms;\n        P \\<turnstile> C sees ac: ad\\<rightarrow>ae = ba in C\\<rbrakk>\n       \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n                          (ac, ad, ae, f ba)\n 2. \\<And>C D fs ms.\n       \\<lbrakk>\\<And>C M Ts T m.\n                   \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                   \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n(M, Ts, T, f m);\n        \\<forall>a aa ab b.\n           (a, aa, ab, b) \\<in> set P \\<longrightarrow>\n           (\\<forall>a b.\n               (a, b) \\<in> set ab \\<longrightarrow>\n               wf_fdecl P (a, b)) \\<and>\n           distinct_fst ab \\<and>\n           (\\<forall>aa ab ac ba.\n               (aa, ab, ac, ba) \\<in> set b \\<longrightarrow>\n               wf_mdecl wf\\<^sub>1 P a (aa, ab, ac, ba)) \\<and>\n           distinct_fst b \\<and>\n           (a \\<noteq> Object \\<longrightarrow>\n            is_class P aa \\<and>\n            (aa, a) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n            (\\<forall>a ab ac.\n                (\\<exists>ba. (a, ab, ac, ba) \\<in> set b) \\<longrightarrow>\n                (\\<forall>D' Ts' T'.\n                    (\\<exists>m'.\n                        P \\<turnstile> aa sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                    P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                    P \\<turnstile> ac \\<le> T')));\n        wf_prog p P; x = (C, D, fs, map (compM f) ms);\n        (C, D, fs, ms) \\<in> set P\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object \\<longrightarrow>\n                         (\\<forall>a aa ab.\n                             (\\<exists>b.\n                                 (a, aa, ab, b)\n                                 \\<in> compM f ` set ms) \\<longrightarrow>\n                             (\\<forall>D' Ts' T'.\n                                 (\\<exists>m'.\n                                     compP f\nP \\<turnstile> D sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                                 P \\<turnstile> Ts' [\\<le>] aa \\<and>\n                                 P \\<turnstile> ab \\<le> T'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms.\n       \\<lbrakk>\\<And>C M Ts T m.\n                   \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                   \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n(M, Ts, T, f m);\n        \\<forall>a aa ab b.\n           (a, aa, ab, b) \\<in> set P \\<longrightarrow>\n           (\\<forall>a b.\n               (a, b) \\<in> set ab \\<longrightarrow>\n               wf_fdecl P (a, b)) \\<and>\n           distinct_fst ab \\<and>\n           (\\<forall>aa ab ac ba.\n               (aa, ab, ac, ba) \\<in> set b \\<longrightarrow>\n               wf_mdecl wf\\<^sub>1 P a (aa, ab, ac, ba)) \\<and>\n           distinct_fst b \\<and>\n           (a \\<noteq> Object \\<longrightarrow>\n            is_class P aa \\<and>\n            (aa, a) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n            (\\<forall>a ab ac.\n                (\\<exists>ba. (a, ab, ac, ba) \\<in> set b) \\<longrightarrow>\n                (\\<forall>D' Ts' T'.\n                    (\\<exists>m'.\n                        P \\<turnstile> aa sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                    P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                    P \\<turnstile> ac \\<le> T')));\n        wf_prog p P; x = (C, D, fs, map (compM f) ms);\n        (C, D, fs, ms) \\<in> set P\\<rbrakk>\n       \\<Longrightarrow> C \\<noteq> Object \\<longrightarrow>\n                         (\\<forall>a aa ab.\n                             (\\<exists>b.\n                                 (a, aa, ab, b)\n                                 \\<in> compM f ` set ms) \\<longrightarrow>\n                             (\\<forall>D' Ts' T'.\n                                 (\\<exists>m'.\n                                     compP f\nP \\<turnstile> D sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                                 P \\<turnstile> Ts' [\\<le>] aa \\<and>\n                                 P \\<turnstile> ab \\<le> T'))", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms a aa ab b ac ad ae ba D' Ts' T' m'.\n       \\<lbrakk>\\<And>C M Ts T m.\n                   \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                   \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n(M, Ts, T, f m);\n        \\<forall>a aa ab b.\n           (a, aa, ab, b) \\<in> set P \\<longrightarrow>\n           (\\<forall>a b.\n               (a, b) \\<in> set ab \\<longrightarrow>\n               wf_fdecl P (a, b)) \\<and>\n           distinct_fst ab \\<and>\n           (\\<forall>aa ab ac ba.\n               (aa, ab, ac, ba) \\<in> set b \\<longrightarrow>\n               wf_mdecl wf\\<^sub>1 P a (aa, ab, ac, ba)) \\<and>\n           distinct_fst b \\<and>\n           (a \\<noteq> Object \\<longrightarrow>\n            is_class P aa \\<and>\n            (aa, a) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n            (\\<forall>a ab ac.\n                (\\<exists>ba. (a, ab, ac, ba) \\<in> set b) \\<longrightarrow>\n                (\\<forall>D' Ts' T'.\n                    (\\<exists>m'.\n                        P \\<turnstile> aa sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                    P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                    P \\<turnstile> ac \\<le> T')));\n        wf_prog p P; x = (C, D, fs, map (compM f) ms);\n        (C, D, fs, ms) \\<in> set P; C \\<noteq> Object;\n        (a, aa, ab, b) = compM f (ac, ad, ae, ba);\n        (ac, ad, ae, ba) \\<in> set ms;\n        compP f\n         P \\<turnstile> D sees a: Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ts' [\\<le>] aa \\<and>\n                         P \\<turnstile> ab \\<le> T'", "apply(drule sees_method_compPD[where f = f])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms a aa ab b ac ad ae ba D' Ts' T' m'.\n       \\<lbrakk>\\<And>C M Ts T m.\n                   \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                   \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n(M, Ts, T, f m);\n        \\<forall>a aa ab b.\n           (a, aa, ab, b) \\<in> set P \\<longrightarrow>\n           (\\<forall>a b.\n               (a, b) \\<in> set ab \\<longrightarrow>\n               wf_fdecl P (a, b)) \\<and>\n           distinct_fst ab \\<and>\n           (\\<forall>aa ab ac ba.\n               (aa, ab, ac, ba) \\<in> set b \\<longrightarrow>\n               wf_mdecl wf\\<^sub>1 P a (aa, ab, ac, ba)) \\<and>\n           distinct_fst b \\<and>\n           (a \\<noteq> Object \\<longrightarrow>\n            is_class P aa \\<and>\n            (aa, a) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n            (\\<forall>a ab ac.\n                (\\<exists>ba. (a, ab, ac, ba) \\<in> set b) \\<longrightarrow>\n                (\\<forall>D' Ts' T'.\n                    (\\<exists>m'.\n                        P \\<turnstile> aa sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                    P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                    P \\<turnstile> ac \\<le> T')));\n        wf_prog p P; x = (C, D, fs, map (compM f) ms);\n        (C, D, fs, ms) \\<in> set P; C \\<noteq> Object;\n        (a, aa, ab, b) = compM f (ac, ad, ae, ba);\n        (ac, ad, ae, ba) \\<in> set ms;\n        \\<exists>m.\n           P \\<turnstile> D sees a: Ts'\\<rightarrow>T' = m in D' \\<and>\n           f m = m'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ts' [\\<le>] aa \\<and>\n                         P \\<turnstile> ab \\<le> T'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms a aa ab b ac ad ae ba D' Ts' T' m.\n       \\<lbrakk>\\<And>C M Ts T m.\n                   \\<lbrakk>wf_mdecl wf\\<^sub>1 P C (M, Ts, T, m);\n                    P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in C\\<rbrakk>\n                   \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C\n(M, Ts, T, f m);\n        \\<forall>a aa ab b.\n           (a, aa, ab, b) \\<in> set P \\<longrightarrow>\n           (\\<forall>a b.\n               (a, b) \\<in> set ab \\<longrightarrow>\n               wf_fdecl P (a, b)) \\<and>\n           distinct_fst ab \\<and>\n           (\\<forall>aa ab ac ba.\n               (aa, ab, ac, ba) \\<in> set b \\<longrightarrow>\n               wf_mdecl wf\\<^sub>1 P a (aa, ab, ac, ba)) \\<and>\n           distinct_fst b \\<and>\n           (a \\<noteq> Object \\<longrightarrow>\n            is_class P aa \\<and>\n            (aa, a) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n            (\\<forall>a ab ac.\n                (\\<exists>ba. (a, ab, ac, ba) \\<in> set b) \\<longrightarrow>\n                (\\<forall>D' Ts' T'.\n                    (\\<exists>m'.\n                        P \\<turnstile> aa sees a: Ts'\\<rightarrow>T' = m' in D') \\<longrightarrow>\n                    P \\<turnstile> Ts' [\\<le>] ab \\<and>\n                    P \\<turnstile> ac \\<le> T')));\n        wf_prog p P; x = (C, D, fs, map (compM f) ms);\n        (C, D, fs, ms) \\<in> set P; C \\<noteq> Object;\n        (a, aa, ab, b) = compM f (ac, ad, ae, ba);\n        (ac, ad, ae, ba) \\<in> set ms;\n        P \\<turnstile> D sees a: Ts'\\<rightarrow>T' = m in D'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Ts' [\\<le>] aa \\<and>\n                         P \\<turnstile> ab \\<le> T'", "apply(fastforce simp:image_iff compM_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma wf_prog_compPI:\nassumes lift: \n  \"\\<And>C M Ts T m. \n    \\<lbrakk> P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in C; wf_mdecl wf\\<^sub>1 P C (M,Ts,T,m) \\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf\\<^sub>2 (compP f P) C (M,Ts,T, f m)\"\nand wf: \"wf_prog wf\\<^sub>1 P\"\nshows \"wf_prog wf\\<^sub>2 (compP f P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf\\<^sub>2 (compP f P)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf\\<^sub>2 (compP f P)", "using wf"], ["proof (prove)\nusing this:\n  wf_prog wf\\<^sub>1 P\n\ngoal (1 subgoal):\n 1. wf_prog wf\\<^sub>2 (compP f P)", "by (simp add:wf_prog_def) (blast intro:wf_cdecl_compPI lift wf)"], ["", "(*>*)"], ["", "end"]]}