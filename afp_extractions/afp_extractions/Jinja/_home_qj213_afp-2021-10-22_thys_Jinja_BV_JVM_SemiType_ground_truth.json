{"file_name": "/home/qj213/afp-2021-10-22/thys/Jinja/BV/JVM_SemiType.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jinja", "problem_names": ["lemma JVM_states_unfold: \n  \"states P mxs mxl \\<equiv> err(opt((Union {list n (types P) |n. n <= mxs}) \\<times>\n                                 list mxl (err(types P))))\"", "lemma JVM_le_unfold:\n \"le P m n \\<equiv> \n  Err.le(Opt.le(Product.le(Listn.le(subtype P))(Listn.le(Err.le(subtype P)))))\"", "lemma sl_def2:\n  \"JVM_SemiType.sl P mxs mxl \\<equiv> \n  (states P mxs mxl, JVM_SemiType.le P mxs mxl, JVM_SemiType.sup P mxs mxl)\"", "lemma JVM_le_conv:\n  \"le P m n (OK t1) (OK t2) = P \\<turnstile> t1 \\<le>' t2\"", "lemma JVM_le_Err_conv:\n  \"le P m n = Err.le (sup_state_opt P)\"", "lemma err_le_unfold [iff]: \n  \"Err.le r (OK a) (OK b) = r a b\"", "lemma order_sup_state_opt [intro, simp]: \n  \"wf_prog wf_mb P \\<Longrightarrow> order (sup_state_opt P)\"", "lemma semilat_JVM [intro?]:\n  \"wf_prog wf_mb P \\<Longrightarrow> semilat (JVM_SemiType.sl P mxs mxl)\"", "lemma acc_JVM [intro]:\n  \"wf_prog wf_mb P \\<Longrightarrow> acc (JVM_SemiType.le P mxs mxl)\"", "lemma subtype_refl[iff]: \"subtype P t t\"", "lemma sup_ty_opt_refl [iff]: \"P \\<turnstile> T \\<le>\\<^sub>\\<top> T\"", "lemma Err_any_conv [iff]: \"P \\<turnstile> Err \\<le>\\<^sub>\\<top> T = (T = Err)\"", "lemma any_Err [iff]: \"P \\<turnstile> T \\<le>\\<^sub>\\<top> Err\"", "lemma OK_OK_conv [iff]:\n  \"P \\<turnstile> OK T \\<le>\\<^sub>\\<top> OK T' = P \\<turnstile> T \\<le> T'\"", "lemma any_OK_conv [iff]:\n  \"P \\<turnstile> X \\<le>\\<^sub>\\<top> OK T' = (\\<exists>T. X = OK T \\<and> P \\<turnstile> T \\<le> T')\"", "lemma OK_any_conv:\n \"P \\<turnstile> OK T \\<le>\\<^sub>\\<top> X = (X = Err \\<or> (\\<exists>T'. X = OK T' \\<and> P \\<turnstile> T \\<le> T'))\"", "lemma sup_ty_opt_trans [intro?, trans]:\n  \"\\<lbrakk>P \\<turnstile> a \\<le>\\<^sub>\\<top> b; P \\<turnstile> b \\<le>\\<^sub>\\<top> c\\<rbrakk> \\<Longrightarrow> P \\<turnstile> a \\<le>\\<^sub>\\<top> c\"", "lemma stk_convert:\n  \"P \\<turnstile> ST [\\<le>] ST' = Listn.le (subtype P) ST ST'\"", "lemma sup_loc_refl [iff]: \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT\"", "lemmas sup_loc_Cons1 [iff] = list_all2_Cons1 [of \"sup_ty_opt P\"] for P", "lemma sup_loc_def:\n  \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT' \\<equiv> Listn.le (sup_ty_opt P) LT LT'\"", "lemma sup_loc_widens_conv [iff]:\n  \"P \\<turnstile> map OK Ts [\\<le>\\<^sub>\\<top>] map OK Ts' = P \\<turnstile> Ts [\\<le>] Ts'\"", "lemma sup_loc_trans [intro?, trans]:\n  \"\\<lbrakk>P \\<turnstile> a [\\<le>\\<^sub>\\<top>] b; P \\<turnstile> b [\\<le>\\<^sub>\\<top>] c\\<rbrakk> \\<Longrightarrow> P \\<turnstile> a [\\<le>\\<^sub>\\<top>] c\"", "lemma sup_state_conv [iff]:\n  \"P \\<turnstile> (ST,LT) \\<le>\\<^sub>i (ST',LT') = (P \\<turnstile> ST [\\<le>] ST' \\<and> P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT')\"", "lemma sup_state_conv2:\n  \"P \\<turnstile> s1 \\<le>\\<^sub>i s2 = (P \\<turnstile> fst s1 [\\<le>] fst s2 \\<and> P \\<turnstile> snd s1 [\\<le>\\<^sub>\\<top>] snd s2)\"", "lemma sup_state_refl [iff]: \"P \\<turnstile> s \\<le>\\<^sub>i s\"", "lemma sup_state_trans [intro?, trans]:\n  \"\\<lbrakk>P \\<turnstile> a \\<le>\\<^sub>i b; P \\<turnstile> b \\<le>\\<^sub>i c\\<rbrakk> \\<Longrightarrow> P \\<turnstile> a \\<le>\\<^sub>i c\"", "lemma sup_state_opt_None_any [iff]:\n  \"P \\<turnstile> None \\<le>' s\"", "lemma sup_state_opt_any_None [iff]:\n  \"P \\<turnstile> s \\<le>' None = (s = None)\"", "lemma sup_state_opt_Some_Some [iff]:\n  \"P \\<turnstile> Some a \\<le>' Some b = P \\<turnstile> a \\<le>\\<^sub>i b\"", "lemma sup_state_opt_any_Some:\n  \"P \\<turnstile> (Some s) \\<le>' X = (\\<exists>s'. X = Some s' \\<and> P \\<turnstile> s \\<le>\\<^sub>i s')\"", "lemma sup_state_opt_refl [iff]: \"P \\<turnstile> s \\<le>' s\"", "lemma sup_state_opt_trans [intro?, trans]:\n  \"\\<lbrakk>P \\<turnstile> a \\<le>' b; P \\<turnstile> b \\<le>' c\\<rbrakk> \\<Longrightarrow> P \\<turnstile> a \\<le>' c\""], "translations": [["", "lemma JVM_states_unfold: \n  \"states P mxs mxl \\<equiv> err(opt((Union {list n (types P) |n. n <= mxs}) \\<times>\n                                 list mxl (err(types P))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states P mxs mxl \\<equiv>\n    err (opt (\\<Union> {list n (types P) |n. n \\<le> mxs} \\<times>\n              list mxl (err (types P))))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. states P mxs mxl \\<equiv>\n    err (opt (\\<Union> {list n (types P) |n. n \\<le> mxs} \\<times>\n              list mxl (err (types P))))", "apply (unfold states_def sl_def Opt.esl_def Err.sl_def\n         stk_esl_def loc_sl_def Product.esl_def\n         Listn.sl_def upto_esl_def SemiType.esl_def Err.esl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (case case (case case (types P, subtype P, SemiType.sup P) of\n                         (A, r, f) \\<Rightarrow>\n                           (\\<Union> {list n A |n. n \\<le> mxs}, Listn.le r,\n                            Listn.sup f) of\n                    (A, r\\<^sub>A, f\\<^sub>A) \\<Rightarrow>\n                      \\<lambda>(B, r\\<^sub>B, f\\<^sub>B).\n                         (A \\<times> B, Product.le r\\<^sub>A r\\<^sub>B,\n                          Product.sup f\\<^sub>A f\\<^sub>B))\n                    (case case case (types P, subtype P, SemiType.sup P) of\n                               (A, r, f) \\<Rightarrow>\n                                 (err A, Err.le r, lift2 f) of\n                          (A, r, f) \\<Rightarrow>\n                            (list mxl A, Listn.le r, map2 f) of\n                     (A, r, f) \\<Rightarrow>\n                       (A, r, \\<lambda>x y. OK (f x y))) of\n              (A, r, f) \\<Rightarrow> (opt A, Opt.le r, Opt.sup f) of\n         (A, r, f) \\<Rightarrow> (err A, Err.le r, lift2 f)) \\<equiv>\n    err (opt (\\<Union> {list n (types P) |n. n \\<le> mxs} \\<times>\n              list mxl (err (types P))))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma JVM_le_unfold:\n \"le P m n \\<equiv> \n  Err.le(Opt.le(Product.le(Listn.le(subtype P))(Listn.le(Err.le(subtype P)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_SemiType.le P m n \\<equiv>\n    Err.le\n     (Opt.le\n       (Product.le (Listn.le (subtype P)) (Listn.le (Err.le (subtype P)))))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_SemiType.le P m n \\<equiv>\n    Err.le\n     (Opt.le\n       (Product.le (Listn.le (subtype P)) (Listn.le (Err.le (subtype P)))))", "apply (unfold le_def sl_def Opt.esl_def Err.sl_def\n         stk_esl_def loc_sl_def Product.esl_def  \n         Listn.sl_def upto_esl_def SemiType.esl_def Err.esl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (case case (case case (types P, subtype P, SemiType.sup P) of\n                              (A, r, f) \\<Rightarrow>\n                                (\\<Union> {list n A |n. n \\<le> m},\n                                 Listn.le r, Listn.sup f) of\n                         (A, r\\<^sub>A, f\\<^sub>A) \\<Rightarrow>\n                           \\<lambda>(B, r\\<^sub>B, f\\<^sub>B).\n                              (A \\<times> B, Product.le r\\<^sub>A r\\<^sub>B,\n                               Product.sup f\\<^sub>A f\\<^sub>B))\n                         (case case case (types P, subtype P,\n    SemiType.sup P) of\n                                    (A, r, f) \\<Rightarrow>\n(err A, Err.le r, lift2 f) of\n                               (A, r, f) \\<Rightarrow>\n                                 (list n A, Listn.le r, map2 f) of\n                          (A, r, f) \\<Rightarrow>\n                            (A, r, \\<lambda>x y. OK (f x y))) of\n                   (A, r, f) \\<Rightarrow> (opt A, Opt.le r, Opt.sup f) of\n              (A, r, f) \\<Rightarrow> (err A, Err.le r, lift2 f))) \\<equiv>\n    Err.le\n     (Opt.le\n       (Product.le (Listn.le (subtype P)) (Listn.le (Err.le (subtype P)))))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sl_def2:\n  \"JVM_SemiType.sl P mxs mxl \\<equiv> \n  (states P mxs mxl, JVM_SemiType.le P mxs mxl, JVM_SemiType.sup P mxs mxl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_SemiType.sl P mxs mxl \\<equiv>\n    (states P mxs mxl, JVM_SemiType.le P mxs mxl,\n     JVM_SemiType.sup P mxs mxl)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_SemiType.sl P mxs mxl \\<equiv>\n    (states P mxs mxl, JVM_SemiType.le P mxs mxl,\n     JVM_SemiType.sup P mxs mxl)", "by (unfold JVM_SemiType.sup_def states_def JVM_SemiType.le_def) simp"], ["", "(*>*)"], ["", "lemma JVM_le_conv:\n  \"le P m n (OK t1) (OK t2) = P \\<turnstile> t1 \\<le>' t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_SemiType.le P m n (OK t1) (OK t2) = P \\<turnstile> t1 \\<le>' t2", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_SemiType.le P m n (OK t1) (OK t2) = P \\<turnstile> t1 \\<le>' t2", "by (simp add: JVM_le_unfold Err.le_def lesub_def sup_state_opt_def  \n                sup_state_def sup_ty_opt_def)"], ["", "(*>*)"], ["", "lemma JVM_le_Err_conv:\n  \"le P m n = Err.le (sup_state_opt P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_SemiType.le P m n = Err.le (sup_state_opt P)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_SemiType.le P m n = Err.le (sup_state_opt P)", "by (unfold sup_state_opt_def sup_state_def  \n             sup_ty_opt_def JVM_le_unfold) simp"], ["", "(*>*)"], ["", "lemma err_le_unfold [iff]: \n  \"Err.le r (OK a) (OK b) = r a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Err.le r (OK a) (OK b) = r a b", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Err.le r (OK a) (OK b) = r a b", "by (simp add: Err.le_def lesub_def)"], ["", "(*>*)"], ["", "subsection \\<open>Semilattice\\<close>"], ["", "lemma order_sup_state_opt [intro, simp]: \n  \"wf_prog wf_mb P \\<Longrightarrow> order (sup_state_opt P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> order (sup_state_opt P)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> order (sup_state_opt P)", "by (unfold sup_state_opt_def sup_state_def sup_ty_opt_def) blast"], ["", "(*>*)"], ["", "lemma semilat_JVM [intro?]:\n  \"wf_prog wf_mb P \\<Longrightarrow> semilat (JVM_SemiType.sl P mxs mxl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> semilat (JVM_SemiType.sl P mxs mxl)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> semilat (JVM_SemiType.sl P mxs mxl)", "apply (unfold JVM_SemiType.sl_def stk_esl_def loc_sl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow>\n    err_semilat\n     (Opt.esl\n       (Product.esl (upto_esl mxs (SemiType.esl P))\n         (Err.esl (Listn.sl mxl (Err.sl (SemiType.esl P))))))", "apply (blast intro: err_semilat_Product_esl err_semilat_upto_esl \n                      Listn_sl err_semilat_JType_esl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma acc_JVM [intro]:\n  \"wf_prog wf_mb P \\<Longrightarrow> acc (JVM_SemiType.le P mxs mxl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> acc (JVM_SemiType.le P mxs mxl)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> acc (JVM_SemiType.le P mxs mxl)", "by (unfold JVM_le_unfold) blast"], ["", "(*>*)"], ["", "subsection \\<open>Widening with \\<open>\\<top>\\<close>\\<close>"], ["", "lemma subtype_refl[iff]: \"subtype P t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtype P t t", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subtype P t t", "by (simp add: fun_of_def)"], ["", "(*>*)"], ["", "lemma sup_ty_opt_refl [iff]: \"P \\<turnstile> T \\<le>\\<^sub>\\<top> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le>\\<^sub>\\<top> T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le>\\<^sub>\\<top> T", "apply (unfold sup_ty_opt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Err.le (subtype P) T T", "apply (fold lesub_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> T", "apply (rule le_err_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. x \\<sqsubseteq>\\<^bsub>subtype P\\<^esub> x", "apply (simp add: lesub_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Err_any_conv [iff]: \"P \\<turnstile> Err \\<le>\\<^sub>\\<top> T = (T = Err)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Err \\<le>\\<^sub>\\<top> T = (T = Err)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Err \\<le>\\<^sub>\\<top> T = (T = Err)", "by (unfold sup_ty_opt_def) (rule Err_le_conv [simplified lesub_def])"], ["", "(*>*)"], ["", "lemma any_Err [iff]: \"P \\<turnstile> T \\<le>\\<^sub>\\<top> Err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le>\\<^sub>\\<top> Err", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le>\\<^sub>\\<top> Err", "by (unfold sup_ty_opt_def) (rule le_Err [simplified lesub_def])"], ["", "(*>*)"], ["", "lemma OK_OK_conv [iff]:\n  \"P \\<turnstile> OK T \\<le>\\<^sub>\\<top> OK T' = P \\<turnstile> T \\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> OK T \\<le>\\<^sub>\\<top> OK T' = subtype P T T'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> OK T \\<le>\\<^sub>\\<top> OK T' = subtype P T T'", "by (simp add: sup_ty_opt_def fun_of_def)"], ["", "(*>*)"], ["", "lemma any_OK_conv [iff]:\n  \"P \\<turnstile> X \\<le>\\<^sub>\\<top> OK T' = (\\<exists>T. X = OK T \\<and> P \\<turnstile> T \\<le> T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> X \\<le>\\<^sub>\\<top> OK T' =\n    (\\<exists>T. X = OK T \\<and> subtype P T T')", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> X \\<le>\\<^sub>\\<top> OK T' =\n    (\\<exists>T. X = OK T \\<and> subtype P T T')", "apply (unfold sup_ty_opt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Err.le (subtype P) X (OK T') =\n    (\\<exists>T. X = OK T \\<and> subtype P T T')", "apply (rule le_OK_conv [simplified lesub_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma OK_any_conv:\n \"P \\<turnstile> OK T \\<le>\\<^sub>\\<top> X = (X = Err \\<or> (\\<exists>T'. X = OK T' \\<and> P \\<turnstile> T \\<le> T'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> OK T \\<le>\\<^sub>\\<top> X =\n    (X = Err \\<or> (\\<exists>T'. X = OK T' \\<and> subtype P T T'))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> OK T \\<le>\\<^sub>\\<top> X =\n    (X = Err \\<or> (\\<exists>T'. X = OK T' \\<and> subtype P T T'))", "apply (unfold sup_ty_opt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Err.le (subtype P) (OK T) X =\n    (X = Err \\<or> (\\<exists>T'. X = OK T' \\<and> subtype P T T'))", "apply (rule OK_le_conv [simplified lesub_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sup_ty_opt_trans [intro?, trans]:\n  \"\\<lbrakk>P \\<turnstile> a \\<le>\\<^sub>\\<top> b; P \\<turnstile> b \\<le>\\<^sub>\\<top> c\\<rbrakk> \\<Longrightarrow> P \\<turnstile> a \\<le>\\<^sub>\\<top> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> a \\<le>\\<^sub>\\<top> b;\n     P \\<turnstile> b \\<le>\\<^sub>\\<top> c\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> a \\<le>\\<^sub>\\<top> c", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> a \\<le>\\<^sub>\\<top> b;\n     P \\<turnstile> b \\<le>\\<^sub>\\<top> c\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> a \\<le>\\<^sub>\\<top> c", "by (auto intro: widen_trans  \n           simp add: sup_ty_opt_def Err.le_def lesub_def fun_of_def\n           split: err.splits)"], ["", "(*>*)"], ["", "subsection \"Stack and Registers\""], ["", "lemma stk_convert:\n  \"P \\<turnstile> ST [\\<le>] ST' = Listn.le (subtype P) ST ST'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> ST [\\<le>] ST' = Listn.le (subtype P) ST ST'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> ST [\\<le>] ST' = Listn.le (subtype P) ST ST'", "by (simp add: Listn.le_def lesub_def)"], ["", "(*>*)"], ["", "lemma sup_loc_refl [iff]: \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT", "by (rule list_all2_refl) simp"], ["", "(*>*)"], ["", "lemmas sup_loc_Cons1 [iff] = list_all2_Cons1 [of \"sup_ty_opt P\"] for P"], ["", "lemma sup_loc_def:\n  \"P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT' \\<equiv> Listn.le (sup_ty_opt P) LT LT'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT' \\<equiv>\n    Listn.le (sup_ty_opt P) LT LT'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT' \\<equiv>\n    Listn.le (sup_ty_opt P) LT LT'", "by (simp add: Listn.le_def lesub_def)"], ["", "(*>*)"], ["", "lemma sup_loc_widens_conv [iff]:\n  \"P \\<turnstile> map OK Ts [\\<le>\\<^sub>\\<top>] map OK Ts' = P \\<turnstile> Ts [\\<le>] Ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> map OK Ts [\\<le>\\<^sub>\\<top>] map OK Ts' =\n    P \\<turnstile> Ts [\\<le>] Ts'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> map OK Ts [\\<le>\\<^sub>\\<top>] map OK Ts' =\n    P \\<turnstile> Ts [\\<le>] Ts'", "by (simp add: list_all2_map1 list_all2_map2)"], ["", "(*>*)"], ["", "lemma sup_loc_trans [intro?, trans]:\n  \"\\<lbrakk>P \\<turnstile> a [\\<le>\\<^sub>\\<top>] b; P \\<turnstile> b [\\<le>\\<^sub>\\<top>] c\\<rbrakk> \\<Longrightarrow> P \\<turnstile> a [\\<le>\\<^sub>\\<top>] c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> a [\\<le>\\<^sub>\\<top>] b;\n     P \\<turnstile> b [\\<le>\\<^sub>\\<top>] c\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> a [\\<le>\\<^sub>\\<top>] c", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> a [\\<le>\\<^sub>\\<top>] b;\n     P \\<turnstile> b [\\<le>\\<^sub>\\<top>] c\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> a [\\<le>\\<^sub>\\<top>] c", "by (rule list_all2_trans, rule sup_ty_opt_trans)"], ["", "(*>*)"], ["", "subsection \"State Type\""], ["", "lemma sup_state_conv [iff]:\n  \"P \\<turnstile> (ST,LT) \\<le>\\<^sub>i (ST',LT') = (P \\<turnstile> ST [\\<le>] ST' \\<and> P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (ST, LT) \\<le>\\<^sub>i (ST', LT') =\n    (P \\<turnstile> ST [\\<le>] ST' \\<and>\n     P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT')", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (ST, LT) \\<le>\\<^sub>i (ST', LT') =\n    (P \\<turnstile> ST [\\<le>] ST' \\<and>\n     P \\<turnstile> LT [\\<le>\\<^sub>\\<top>] LT')", "by (auto simp add: sup_state_def stk_convert lesub_def Product.le_def sup_loc_def)"], ["", "(*>*)"], ["", "lemma sup_state_conv2:\n  \"P \\<turnstile> s1 \\<le>\\<^sub>i s2 = (P \\<turnstile> fst s1 [\\<le>] fst s2 \\<and> P \\<turnstile> snd s1 [\\<le>\\<^sub>\\<top>] snd s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> s1 \\<le>\\<^sub>i s2 =\n    (P \\<turnstile> fst s1 [\\<le>] fst s2 \\<and>\n     P \\<turnstile> snd s1 [\\<le>\\<^sub>\\<top>] snd s2)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> s1 \\<le>\\<^sub>i s2 =\n    (P \\<turnstile> fst s1 [\\<le>] fst s2 \\<and>\n     P \\<turnstile> snd s1 [\\<le>\\<^sub>\\<top>] snd s2)", "by (cases s1, cases s2) simp"], ["", "(*>*)"], ["", "lemma sup_state_refl [iff]: \"P \\<turnstile> s \\<le>\\<^sub>i s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> s \\<le>\\<^sub>i s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> s \\<le>\\<^sub>i s", "by (auto simp add: sup_state_conv2)"], ["", "(*>*)"], ["", "lemma sup_state_trans [intro?, trans]:\n  \"\\<lbrakk>P \\<turnstile> a \\<le>\\<^sub>i b; P \\<turnstile> b \\<le>\\<^sub>i c\\<rbrakk> \\<Longrightarrow> P \\<turnstile> a \\<le>\\<^sub>i c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> a \\<le>\\<^sub>i b;\n     P \\<turnstile> b \\<le>\\<^sub>i c\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> a \\<le>\\<^sub>i c", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> a \\<le>\\<^sub>i b;\n     P \\<turnstile> b \\<le>\\<^sub>i c\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> a \\<le>\\<^sub>i c", "by (auto intro: sup_loc_trans widens_trans simp add: sup_state_conv2)"], ["", "(*>*)"], ["", "lemma sup_state_opt_None_any [iff]:\n  \"P \\<turnstile> None \\<le>' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> None \\<le>' s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> None \\<le>' s", "by (simp add: sup_state_opt_def Opt.le_def)"], ["", "(*>*)"], ["", "lemma sup_state_opt_any_None [iff]:\n  \"P \\<turnstile> s \\<le>' None = (s = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> s \\<le>' None = (s = None)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> s \\<le>' None = (s = None)", "by (simp add: sup_state_opt_def Opt.le_def)"], ["", "(*>*)"], ["", "lemma sup_state_opt_Some_Some [iff]:\n  \"P \\<turnstile> Some a \\<le>' Some b = P \\<turnstile> a \\<le>\\<^sub>i b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<lfloor>a\\<rfloor> \\<le>' \\<lfloor>b\\<rfloor> =\n    P \\<turnstile> a \\<le>\\<^sub>i b", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<lfloor>a\\<rfloor> \\<le>' \\<lfloor>b\\<rfloor> =\n    P \\<turnstile> a \\<le>\\<^sub>i b", "by (simp add: sup_state_opt_def Opt.le_def lesub_def)"], ["", "(*>*)"], ["", "lemma sup_state_opt_any_Some:\n  \"P \\<turnstile> (Some s) \\<le>' X = (\\<exists>s'. X = Some s' \\<and> P \\<turnstile> s \\<le>\\<^sub>i s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<lfloor>s\\<rfloor> \\<le>' X =\n    (\\<exists>s'.\n        X = \\<lfloor>s'\\<rfloor> \\<and> P \\<turnstile> s \\<le>\\<^sub>i s')", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<lfloor>s\\<rfloor> \\<le>' X =\n    (\\<exists>s'.\n        X = \\<lfloor>s'\\<rfloor> \\<and> P \\<turnstile> s \\<le>\\<^sub>i s')", "by (simp add: sup_state_opt_def Opt.le_def lesub_def)"], ["", "(*>*)"], ["", "lemma sup_state_opt_refl [iff]: \"P \\<turnstile> s \\<le>' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> s \\<le>' s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> s \\<le>' s", "by (simp add: sup_state_opt_def Opt.le_def lesub_def)"], ["", "(*>*)"], ["", "lemma sup_state_opt_trans [intro?, trans]:\n  \"\\<lbrakk>P \\<turnstile> a \\<le>' b; P \\<turnstile> b \\<le>' c\\<rbrakk> \\<Longrightarrow> P \\<turnstile> a \\<le>' c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> a \\<le>' b; P \\<turnstile> b \\<le>' c\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> a \\<le>' c", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> a \\<le>' b; P \\<turnstile> b \\<le>' c\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> a \\<le>' c", "apply (unfold sup_state_opt_def Opt.le_def lesub_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case b of None \\<Rightarrow> a = None\n             | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                 case a of None \\<Rightarrow> True\n                 | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                     P \\<turnstile> x \\<le>\\<^sub>i y;\n     case c of None \\<Rightarrow> b = None\n     | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n         case b of None \\<Rightarrow> True\n         | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n             P \\<turnstile> x \\<le>\\<^sub>i y\\<rbrakk>\n    \\<Longrightarrow> case c of None \\<Rightarrow> a = None\n                      | \\<lfloor>y\\<rfloor> \\<Rightarrow>\n                          case a of None \\<Rightarrow> True\n                          | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                              P \\<turnstile> x \\<le>\\<^sub>i y", "apply (simp del: split_paired_All)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x2a x2b.\n       \\<lbrakk>c = \\<lfloor>x2a\\<rfloor>;\n        P \\<turnstile> x2 \\<le>\\<^sub>i x2a; b = \\<lfloor>x2\\<rfloor>;\n        a = \\<lfloor>x2b\\<rfloor>;\n        P \\<turnstile> x2b \\<le>\\<^sub>i x2\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> x2b \\<le>\\<^sub>i x2a", "apply (rule sup_state_trans, assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "end"]]}