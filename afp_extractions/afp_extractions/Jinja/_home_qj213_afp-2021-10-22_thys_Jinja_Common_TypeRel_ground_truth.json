{"file_name": "/home/qj213/afp-2021-10-22/thys/Jinja/Common/TypeRel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jinja", "problem_names": ["lemma subcls1D: \"P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow> C \\<noteq> Object \\<and> (\\<exists>fs ms. class P C = Some (D,fs,ms))\"", "lemma [iff]: \"\\<not> P \\<turnstile> Object \\<prec>\\<^sup>1 C\"", "lemma [iff]: \"(P \\<turnstile> Object \\<preceq>\\<^sup>* C) = (C = Object)\"", "lemma subcls1_def2:\n  \"subcls1 P =\n     (SIGMA C:{C. is_class P C}. {D. C\\<noteq>Object \\<and> fst (the (class P C))=D})\"", "lemma finite_subcls1: \"finite (subcls1 P)\"", "lemma [iff]: \"(P \\<turnstile> T \\<le> Void) = (T = Void)\"", "lemma [iff]: \"(P \\<turnstile> T \\<le> Boolean) = (T = Boolean)\"", "lemma [iff]: \"(P \\<turnstile> T \\<le> Integer) = (T = Integer)\"", "lemma [iff]: \"(P \\<turnstile> Void \\<le> T) = (T = Void)\"", "lemma [iff]: \"(P \\<turnstile> Boolean \\<le> T) = (T = Boolean)\"", "lemma [iff]: \"(P \\<turnstile> Integer \\<le> T) = (T = Integer)\"", "lemma Class_widen: \"P \\<turnstile> Class C \\<le> T  \\<Longrightarrow>  \\<exists>D. T = Class D\"", "lemma [iff]: \"(P \\<turnstile> T \\<le> NT) = (T = NT)\"", "lemma Class_widen_Class [iff]: \"(P \\<turnstile> Class C \\<le> Class D) = (P \\<turnstile> C \\<preceq>\\<^sup>* D)\"", "lemma widen_Class: \"(P \\<turnstile> T \\<le> Class C) = (T = NT \\<or> (\\<exists>D. T = Class D \\<and> P \\<turnstile> D \\<preceq>\\<^sup>* C))\"", "lemma widen_trans[trans]: \"\\<lbrakk>P \\<turnstile> S \\<le> U; P \\<turnstile> U \\<le> T\\<rbrakk> \\<Longrightarrow> P \\<turnstile> S \\<le> T\"", "lemma widens_trans [trans]: \"\\<lbrakk>P \\<turnstile> Ss [\\<le>] Ts; P \\<turnstile> Ts [\\<le>] Us\\<rbrakk> \\<Longrightarrow> P \\<turnstile> Ss [\\<le>] Us\"", "lemmas widens_refl [iff] = list_all2_refl [of \"widen P\", OF widen_refl] for P", "lemmas widens_Cons [iff] = list_all2_Cons1 [of \"widen P\"] for P", "lemma sees_methods_fun:\nassumes 1: \"P \\<turnstile> C sees_methods Mm\"\nshows \"\\<And>Mm'. P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm\"", "lemma visible_methods_exist:\n  \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow> Mm M = Some(m,D) \\<Longrightarrow>\n   (\\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of ms M = Some m)\"", "lemma sees_methods_decl_above:\nassumes Csees: \"P \\<turnstile> C sees_methods Mm\"\nshows \"Mm M = Some(m,D) \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma sees_methods_idemp:\nassumes Cmethods: \"P \\<turnstile> C sees_methods Mm\"\nshows \"\\<And>m D. Mm M = Some(m,D) \\<Longrightarrow>\n              \\<exists>Mm'. (P \\<turnstile> D sees_methods Mm') \\<and> Mm' M = Some(m,D)\"", "lemma sees_methods_decl_mono:\nassumes sub: \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\"\nshows \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n       \\<exists>Mm' Mm\\<^sub>2. P \\<turnstile> C' sees_methods Mm' \\<and> Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                 (\\<forall>M m D. Mm\\<^sub>2 M = Some(m,D) \\<longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* C)\"\n(*<*)\n      (is \"_ \\<Longrightarrow> \\<exists>Mm' Mm2. ?Q C' C Mm' Mm2\")", "lemma sees_method_fun:\n  \"\\<lbrakk>P \\<turnstile> C sees M:TS\\<rightarrow>T = m in D; P \\<turnstile> C sees M:TS'\\<rightarrow>T' = m' in D' \\<rbrakk>\n   \\<Longrightarrow> TS' = TS \\<and> T' = T \\<and> m' = m \\<and> D' = D\"", "lemma sees_method_decl_above:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma visible_method_exists:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  \\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of ms M = Some(Ts,T,m)\"", "lemma sees_method_idemp:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=m in D \\<Longrightarrow> P \\<turnstile> D sees M:Ts\\<rightarrow>T=m in D\"", "lemma sees_method_decl_mono:\n  \"\\<lbrakk> P \\<turnstile> C' \\<preceq>\\<^sup>* C; P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' sees M:Ts'\\<rightarrow>T' = m' in D' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D\"", "lemma sees_method_is_class:\n  \"\\<lbrakk> P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<rbrakk> \\<Longrightarrow> is_class P C\"", "lemma has_fields_fun:\nassumes 1: \"P \\<turnstile> C has_fields FDTs\"\nshows \"\\<And>FDTs'. P \\<turnstile> C has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs\"", "lemma all_fields_in_has_fields:\nassumes sub: \"P \\<turnstile> C has_fields FDTs\"\nshows \"\\<lbrakk> P \\<turnstile> C \\<preceq>\\<^sup>* D; class P D = Some(D',fs,ms); (F,T) \\<in> set fs \\<rbrakk>\n       \\<Longrightarrow> ((F,D),T) \\<in> set FDTs\"", "lemma has_fields_decl_above:\nassumes fields: \"P \\<turnstile> C has_fields FDTs\"\nshows \"((F,D),T) \\<in> set FDTs \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma subcls_notin_has_fields:\nassumes fields: \"P \\<turnstile> C has_fields FDTs\"\nshows \"((F,D),T) \\<in> set FDTs \\<Longrightarrow> (D,C) \\<notin> (subcls1 P)\\<^sup>+\"", "lemma has_fields_mono_lem:\nassumes sub: \"P \\<turnstile> D \\<preceq>\\<^sup>* C\"\nshows \"P \\<turnstile> C has_fields FDTs\n         \\<Longrightarrow> \\<exists>pre. P \\<turnstile> D has_fields pre@FDTs \\<and> dom(map_of pre) \\<inter> dom(map_of FDTs) = {}\"", "lemma has_field_mono:\n  \"\\<lbrakk> P \\<turnstile> C has F:T in D; P \\<turnstile> C' \\<preceq>\\<^sup>* C \\<rbrakk> \\<Longrightarrow> P \\<turnstile> C' has F:T in D\"", "lemma map_of_remap_SomeD:\n  \"map_of (map (\\<lambda>((k,k'),x). (k,(k',x))) t) k = Some (k',x) \\<Longrightarrow> map_of t (k, k') = Some x\"", "lemma has_visible_field:\n  \"P \\<turnstile> C sees F:T in D \\<Longrightarrow> P \\<turnstile> C has F:T in D\"", "lemma sees_field_fun:\n  \"\\<lbrakk>P \\<turnstile> C sees F:T in D; P \\<turnstile> C sees F:T' in D'\\<rbrakk> \\<Longrightarrow> T' = T \\<and> D' = D\"", "lemma sees_field_decl_above:\n  \"P \\<turnstile> C sees F:T in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\"", "lemma sees_field_idemp:\n  \"P \\<turnstile> C sees F:T in D \\<Longrightarrow> P \\<turnstile> D sees F:T in D\"", "lemma fields_def2 [simp]: \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs\"", "lemma field_def2 [simp]: \"P \\<turnstile> C sees F:T in D \\<Longrightarrow> field P C F = (D,T)\"", "lemma method_def2 [simp]: \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow> method P C M = (D,Ts,T,m)\"", "lemma subcls_conv_subcls' [code_unfold]:\n  \"(subcls1 G)^* = {(C, D). subcls' G C D}\"", "lemma has_field_code [code_pred_intro]:\n  \"\\<lbrakk> P \\<turnstile> C has_fields FDTs; map_of FDTs (F, D) = \\<lfloor>T\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C has F:T in D\"", "lemma sees_field_code [code_pred_intro]:\n  \"\\<lbrakk> P \\<turnstile> C has_fields FDTs; map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F = \\<lfloor>(D, T)\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C sees F:T in D\"", "lemma Method_code [code_pred_intro]:\n  \"\\<lbrakk> P \\<turnstile> C sees_methods Mm; Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D\"", "lemma eval_Method_i_i_i_o_o_o_o_conv:\n  \"Predicate.eval (Method_i_i_i_o_o_o_o P C M) = (\\<lambda>(Ts, T, m, D). P \\<turnstile> C sees M:Ts\\<rightarrow>T=m in D)\"", "lemma method_code [code]:\n  \"method P C M = \n  Predicate.the (Predicate.bind (Method_i_i_i_o_o_o_o P C M) (\\<lambda>(Ts, T, m, D). Predicate.single (D, Ts, T, m)))\"", "lemma eval_Fields_conv:\n  \"Predicate.eval (Fields_i_i_o P C) = (\\<lambda>FDTs. P \\<turnstile> C has_fields FDTs)\"", "lemma fields_code [code]:\n  \"fields P C = Predicate.the (Fields_i_i_o P C)\"", "lemma eval_sees_field_i_i_i_o_o_conv:\n  \"Predicate.eval (sees_field_i_i_i_o_o P C F) = (\\<lambda>(T, D). P \\<turnstile> C sees F:T in D)\"", "lemma eval_sees_field_i_i_i_o_i_conv:\n  \"Predicate.eval (sees_field_i_i_i_o_i P C F D) = (\\<lambda>T. P \\<turnstile> C sees F:T in D)\"", "lemma field_code [code]:\n  \"field P C F = Predicate.the (Predicate.bind (sees_field_i_i_i_o_o P C F) (\\<lambda>(T, D). Predicate.single (D, T)))\""], "translations": [["", "lemma subcls1D: \"P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow> C \\<noteq> Object \\<and> (\\<exists>fs ms. class P C = Some (D,fs,ms))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n    C \\<noteq> Object \\<and>\n    (\\<exists>fs ms. class P C = \\<lfloor>(D, fs, ms)\\<rfloor>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow>\n    C \\<noteq> Object \\<and>\n    (\\<exists>fs ms. class P C = \\<lfloor>(D, fs, ms)\\<rfloor>)", "by(erule subcls1.induct)(fastforce simp add:is_class_def)"], ["", "(*>*)"], ["", "lemma [iff]: \"\\<not> P \\<turnstile> Object \\<prec>\\<^sup>1 C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Object, C) \\<notin> subcls1 P", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Object, C) \\<notin> subcls1 P", "by(fastforce dest:subcls1D)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> Object \\<preceq>\\<^sup>* C) = (C = Object)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Object \\<preceq>\\<^sup>* C = (C = Object)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Object \\<preceq>\\<^sup>* C = (C = Object)", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P \\<turnstile> Object \\<preceq>\\<^sup>* C \\<Longrightarrow> C = Object\n 2. C = Object \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* C", "apply(erule converse_rtranclE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Object = C \\<Longrightarrow> C = Object\n 2. \\<And>y.\n       \\<lbrakk>P \\<turnstile> Object \\<prec>\\<^sup>1 y;\n        P \\<turnstile> y \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> C = Object\n 3. C = Object \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* C", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma subcls1_def2:\n  \"subcls1 P =\n     (SIGMA C:{C. is_class P C}. {D. C\\<noteq>Object \\<and> fst (the (class P C))=D})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls1 P =\n    (SIGMA C:{C. is_class P C}.\n        {D. C \\<noteq> Object \\<and> fst (the (class P C)) = D})", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcls1 P =\n    (SIGMA C:{C. is_class P C}.\n        {D. C \\<noteq> Object \\<and> fst (the (class P C)) = D})", "by (fastforce simp:is_class_def dest: subcls1D elim: subcls1I)"], ["", "(*>*)"], ["", "lemma finite_subcls1: \"finite (subcls1 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (subcls1 P)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (subcls1 P)", "apply (simp add: subcls1_def2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (SIGMA C:{C. is_class P C}.\n         {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object})", "apply(rule finite_SigmaI [OF finite_is_class])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> {C. is_class P C} \\<Longrightarrow>\n       finite {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object}", "apply(rule_tac B = \"{fst (the (class P C))}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C.\n       C \\<in> {C. is_class P C} \\<Longrightarrow>\n       {D. fst (the (class P C)) = D \\<and> C \\<noteq> Object}\n       \\<subseteq> {fst (the (class P C))}\n 2. \\<And>C.\n       C \\<in> {C. is_class P C} \\<Longrightarrow>\n       finite {fst (the (class P C))}", "apply  auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n(*\nlemma subcls_is_class: \"(C,D) \\<in> (subcls1 P)\\<^sup>+ \\<Longrightarrow> is_class P C\"\napply (unfold is_class_def)\napply(erule trancl_trans_induct)\napply (auto dest!: subcls1D)\ndone\n\nlemma subcls_is_class: \"P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow> is_class P D \\<longrightarrow> is_class P C\"\napply (unfold is_class_def)\napply (erule rtrancl_induct)\napply  (drule_tac [2] subcls1D)\napply  auto\ndone\n*)"], ["", "subsection\\<open>The subtype relations\\<close>"], ["", "inductive\n  widen   :: \"'m prog \\<Rightarrow> ty \\<Rightarrow> ty \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<le> _\"   [71,71,71] 70)\n  for P :: \"'m prog\"\nwhere\n  widen_refl[iff]: \"P \\<turnstile> T \\<le> T\"\n| widen_subcls: \"P \\<turnstile> C \\<preceq>\\<^sup>* D  \\<Longrightarrow>  P \\<turnstile> Class C \\<le> Class D\"\n| widen_null[iff]: \"P \\<turnstile> NT \\<le> Class C\""], ["", "abbreviation\n  widens :: \"'m prog \\<Rightarrow> ty list \\<Rightarrow> ty list \\<Rightarrow> bool\"\n    (\"_ \\<turnstile> _ [\\<le>] _\" [71,71,71] 70) where\n  \"widens P Ts Ts' \\<equiv> list_all2 (widen P) Ts Ts'\""], ["", "lemma [iff]: \"(P \\<turnstile> T \\<le> Void) = (T = Void)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Void = (T = Void)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Void = (T = Void)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> T \\<le> Boolean) = (T = Boolean)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Boolean = (T = Boolean)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Boolean = (T = Boolean)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> T \\<le> Integer) = (T = Integer)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Integer = (T = Integer)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Integer = (T = Integer)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> Void \\<le> T) = (T = Void)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Void \\<le> T = (T = Void)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Void \\<le> T = (T = Void)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> Boolean \\<le> T) = (T = Boolean)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Boolean \\<le> T = (T = Boolean)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Boolean \\<le> T = (T = Boolean)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> Integer \\<le> T) = (T = Integer)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Integer \\<le> T = (T = Integer)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Integer \\<le> T = (T = Integer)", "by (auto elim: widen.cases)"], ["", "(*>*)"], ["", "lemma Class_widen: \"P \\<turnstile> Class C \\<le> T  \\<Longrightarrow>  \\<exists>D. T = Class D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> T \\<Longrightarrow> \\<exists>D. T = Class D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> T \\<Longrightarrow> \\<exists>D. T = Class D", "apply (ind_cases \"P \\<turnstile> Class C \\<le> T\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. T = Class C \\<Longrightarrow> \\<exists>D. T = Class D\n 2. \\<And>D.\n       \\<lbrakk>T = Class D; P \\<turnstile> C \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D. T = Class D", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma [iff]: \"(P \\<turnstile> T \\<le> NT) = (T = NT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> NT = (T = NT)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> NT = (T = NT)", "apply(cases T)"], ["proof (prove)\ngoal (5 subgoals):\n 1. T = Void \\<Longrightarrow> P \\<turnstile> T \\<le> NT = (T = NT)\n 2. T = Boolean \\<Longrightarrow> P \\<turnstile> T \\<le> NT = (T = NT)\n 3. T = Integer \\<Longrightarrow> P \\<turnstile> T \\<le> NT = (T = NT)\n 4. T = NT \\<Longrightarrow> P \\<turnstile> T \\<le> NT = (T = NT)\n 5. \\<And>x5.\n       T = Class x5 \\<Longrightarrow> P \\<turnstile> T \\<le> NT = (T = NT)", "apply(auto dest:Class_widen)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Class_widen_Class [iff]: \"(P \\<turnstile> Class C \\<le> Class D) = (P \\<turnstile> C \\<preceq>\\<^sup>* D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> Class D =\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> Class D =\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P \\<turnstile> Class C \\<le> Class D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D\n 2. P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n    P \\<turnstile> Class C \\<le> Class D", "apply (ind_cases \"P \\<turnstile> Class C \\<le> Class D\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. D = C \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\n 2. P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D\n 3. P \\<turnstile> C \\<preceq>\\<^sup>* D \\<Longrightarrow>\n    P \\<turnstile> Class C \\<le> Class D", "apply (auto elim: widen_subcls)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma widen_Class: \"(P \\<turnstile> T \\<le> Class C) = (T = NT \\<or> (\\<exists>D. T = Class D \\<and> P \\<turnstile> D \\<preceq>\\<^sup>* C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Class C =\n    (T = NT \\<or>\n     (\\<exists>D. T = Class D \\<and> P \\<turnstile> D \\<preceq>\\<^sup>* C))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> Class C =\n    (T = NT \\<or>\n     (\\<exists>D. T = Class D \\<and> P \\<turnstile> D \\<preceq>\\<^sup>* C))", "by(induct T, auto)"], ["", "(*>*)"], ["", "lemma widen_trans[trans]: \"\\<lbrakk>P \\<turnstile> S \\<le> U; P \\<turnstile> U \\<le> T\\<rbrakk> \\<Longrightarrow> P \\<turnstile> S \\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> S \\<le> U; P \\<turnstile> U \\<le> T\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> S \\<le> T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> S \\<le> U; P \\<turnstile> U \\<le> T\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> S \\<le> T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> S \\<le> U; P \\<turnstile> U \\<le> T\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> S \\<le> T", "assume \"P\\<turnstile>S \\<le> U\""], ["proof (state)\nthis:\n  P \\<turnstile> S \\<le> U\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> S \\<le> U; P \\<turnstile> U \\<le> T\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> S \\<le> T", "thus \"\\<And>T. P \\<turnstile> U \\<le> T \\<Longrightarrow> P \\<turnstile> S \\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> S \\<le> U\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       P \\<turnstile> U \\<le> T \\<Longrightarrow> P \\<turnstile> S \\<le> T", "proof induct"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>T Ta.\n       P \\<turnstile> T \\<le> Ta \\<Longrightarrow> P \\<turnstile> T \\<le> Ta\n 2. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 3. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "case (widen_refl T T')"], ["proof (state)\nthis:\n  P \\<turnstile> T \\<le> T'\n\ngoal (3 subgoals):\n 1. \\<And>T Ta.\n       P \\<turnstile> T \\<le> Ta \\<Longrightarrow> P \\<turnstile> T \\<le> Ta\n 2. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 3. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "thus \"P \\<turnstile> T \\<le> T'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> T \\<le> T'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> T \\<le> T'", "."], ["proof (state)\nthis:\n  P \\<turnstile> T \\<le> T'\n\ngoal (2 subgoals):\n 1. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 2. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 2. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "case (widen_subcls C D T)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 2. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T", "obtain E where \"T = Class E\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T\n\ngoal (1 subgoal):\n 1. (\\<And>E. T = Class E \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (blast dest: Class_widen)"], ["proof (state)\nthis:\n  T = Class E\n\ngoal (2 subgoals):\n 1. \\<And>C D T.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> Class D \\<le> T\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class C \\<le> T\n 2. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "with widen_subcls"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T\n  T = Class E", "show \"P \\<turnstile> Class C \\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> Class D \\<le> T\n  T = Class E\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Class C \\<le> T", "by (auto elim: rtrancl_trans)"], ["proof (state)\nthis:\n  P \\<turnstile> Class C \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "case (widen_null C RT)"], ["proof (state)\nthis:\n  P \\<turnstile> Class C \\<le> RT\n\ngoal (1 subgoal):\n 1. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> Class C \\<le> RT", "obtain D where \"RT = Class D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Class C \\<le> RT\n\ngoal (1 subgoal):\n 1. (\\<And>D. RT = Class D \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: Class_widen)"], ["proof (state)\nthis:\n  RT = Class D\n\ngoal (1 subgoal):\n 1. \\<And>C T.\n       P \\<turnstile> Class C \\<le> T \\<Longrightarrow>\n       P \\<turnstile> NT \\<le> T", "thus \"P \\<turnstile> NT \\<le> RT\""], ["proof (prove)\nusing this:\n  RT = Class D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> NT \\<le> RT", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> NT \\<le> RT\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<turnstile> U \\<le> ?T \\<Longrightarrow> P \\<turnstile> S \\<le> ?T\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma widens_trans [trans]: \"\\<lbrakk>P \\<turnstile> Ss [\\<le>] Ts; P \\<turnstile> Ts [\\<le>] Us\\<rbrakk> \\<Longrightarrow> P \\<turnstile> Ss [\\<le>] Us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Ss [\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Us\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Ss [\\<le>] Us", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Ss [\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Us\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Ss [\\<le>] Us", "by (rule list_all2_trans, rule widen_trans)"], ["", "(*>*)\n\n\n(*<*)"], ["", "lemmas widens_refl [iff] = list_all2_refl [of \"widen P\", OF widen_refl] for P"], ["", "lemmas widens_Cons [iff] = list_all2_Cons1 [of \"widen P\"] for P"], ["", "(*>*)"], ["", "subsection\\<open>Method lookup\\<close>"], ["", "inductive\n  Methods :: \"['m prog, cname, mname \\<rightharpoonup> (ty list \\<times> ty \\<times> 'm) \\<times> cname] \\<Rightarrow> bool\"\n                    (\"_ \\<turnstile> _ sees'_methods _\" [51,51,51] 50)\n  for P :: \"'m prog\"\nwhere\n  sees_methods_Object:\n \"\\<lbrakk> class P Object = Some(D,fs,ms); Mm = map_option (\\<lambda>m. (m,Object)) \\<circ> map_of ms \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> Object sees_methods Mm\"\n| sees_methods_rec:\n \"\\<lbrakk> class P C = Some(D,fs,ms); C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n    Mm' = Mm ++ (map_option (\\<lambda>m. (m,C)) \\<circ> map_of ms) \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C sees_methods Mm'\""], ["", "lemma sees_methods_fun:\nassumes 1: \"P \\<turnstile> C sees_methods Mm\"\nshows \"\\<And>Mm'. P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm'. P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm'. P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm", "using 1"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. \\<And>Mm'. P \\<turnstile> C sees_methods Mm' \\<Longrightarrow> Mm' = Mm", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm\n 2. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "case (sees_methods_rec C D fs ms Dres Cres Cres')"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D sees_methods Dres\n  P \\<turnstile> D sees_methods ?Mm' \\<Longrightarrow> ?Mm' = Dres\n  Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  P \\<turnstile> C sees_methods Cres'\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm\n 2. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "have \"class\": \"class P C = Some (D, fs, ms)\"\n   and notObj: \"C \\<noteq> Object\" and Dmethods: \"P \\<turnstile> D sees_methods Dres\"\n   and IH: \"\\<And>Dres'. P \\<turnstile> D sees_methods Dres' \\<Longrightarrow> Dres' = Dres\"\n   and Cres: \"Cres = Dres ++ (map_option (\\<lambda>m. (m,C)) \\<circ> map_of ms)\"\n   and Cmethods': \"P \\<turnstile> C sees_methods Cres'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (class P C = \\<lfloor>(D, fs, ms)\\<rfloor> &&&\n     C \\<noteq> Object &&& P \\<turnstile> D sees_methods Dres) &&&\n    (\\<And>Dres'.\n        P \\<turnstile> D sees_methods Dres' \\<Longrightarrow>\n        Dres' = Dres) &&&\n    Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms) &&&\n    P \\<turnstile> C sees_methods Cres'", "by fact+"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D sees_methods Dres\n  P \\<turnstile> D sees_methods ?Dres' \\<Longrightarrow> ?Dres' = Dres\n  Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  P \\<turnstile> C sees_methods Cres'\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm\n 2. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "from Cmethods' notObj \"class\""], ["proof (chain)\npicking this:\n  P \\<turnstile> C sees_methods Cres'\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>", "obtain Dres'\n    where Dmethods': \"P \\<turnstile> D sees_methods Dres'\"\n     and Cres': \"Cres' = Dres' ++ (map_option (\\<lambda>m. (m,C)) \\<circ> map_of ms)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Cres'\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>Dres'.\n        \\<lbrakk>P \\<turnstile> D sees_methods Dres';\n         Cres' =\n         Dres' ++\n         (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: Methods.cases)"], ["proof (state)\nthis:\n  P \\<turnstile> D sees_methods Dres'\n  Cres' = Dres' ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm\n 2. \\<And>C D fs ms Mm Mm' Mm'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>Mm'.\n           P \\<turnstile> D sees_methods Mm' \\<Longrightarrow> Mm' = Mm;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        P \\<turnstile> C sees_methods Mm'a\\<rbrakk>\n       \\<Longrightarrow> Mm'a = Mm'", "from Cres Cres' IH[OF Dmethods']"], ["proof (chain)\npicking this:\n  Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  Cres' = Dres' ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  Dres' = Dres", "show \"Cres' = Cres\""], ["proof (prove)\nusing this:\n  Cres = Dres ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  Cres' = Dres' ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms)\n  Dres' = Dres\n\ngoal (1 subgoal):\n 1. Cres' = Cres", "by simp"], ["proof (state)\nthis:\n  Cres' = Cres\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm", "case sees_methods_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  P \\<turnstile> Object sees_methods Mm'\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms Mm Mm'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        P \\<turnstile> Object sees_methods Mm'\\<rbrakk>\n       \\<Longrightarrow> Mm' = Mm", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  P \\<turnstile> Object sees_methods Mm'\n\ngoal (1 subgoal):\n 1. Mm' = Mm_", "by(auto elim: Methods.cases)"], ["proof (state)\nthis:\n  Mm' = Mm_\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma visible_methods_exist:\n  \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow> Mm M = Some(m,D) \\<Longrightarrow>\n   (\\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of ms M = Some m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees_methods Mm;\n     Mm M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>D' fs ms.\n                         class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                         map_of ms M = \\<lfloor>m\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees_methods Mm;\n     Mm M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>D' fs ms.\n                         class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n                         map_of ms M = \\<lfloor>m\\<rfloor>", "by(induct rule:Methods.induct) auto"], ["", "(*>*)"], ["", "lemma sees_methods_decl_above:\nassumes Csees: \"P \\<turnstile> C sees_methods Mm\"\nshows \"Mm M = Some(m,D) \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "using Csees"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        Mm M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D\n 2. \\<And>C Da fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da sees_methods Mm;\n        Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "case sees_methods_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  Mm_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>Da fs ms Mm.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        Mm M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D\n 2. \\<And>C Da fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da sees_methods Mm;\n        Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  Mm_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Object \\<preceq>\\<^sup>* D", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> Object \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da sees_methods Mm;\n        Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da sees_methods Mm;\n        Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "case sees_methods_rec"], ["proof (state)\nthis:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ sees_methods Mm_\n  Mm_ M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> D_ \\<preceq>\\<^sup>* D\n  Mm'_ = Mm_ ++ (map_option (\\<lambda>m. (m, C_)) \\<circ> map_of ms_)\n  Mm'_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms Mm Mm'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da sees_methods Mm;\n        Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "thus ?case"], ["proof (prove)\nusing this:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ sees_methods Mm_\n  Mm_ M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n  P \\<turnstile> D_ \\<preceq>\\<^sup>* D\n  Mm'_ = Mm_ ++ (map_option (\\<lambda>m. (m, C_)) \\<circ> map_of ms_)\n  Mm'_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C_ \\<preceq>\\<^sup>* D", "by(fastforce simp:map_option_case split:option.splits\n                elim:converse_rtrancl_into_rtrancl[OF subcls1I])"], ["proof (state)\nthis:\n  P \\<turnstile> C_ \\<preceq>\\<^sup>* D\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma sees_methods_idemp:\nassumes Cmethods: \"P \\<turnstile> C sees_methods Mm\"\nshows \"\\<And>m D. Mm M = Some(m,D) \\<Longrightarrow>\n              \\<exists>Mm'. (P \\<turnstile> D sees_methods Mm') \\<and> Mm' M = Some(m,D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m D.\n       Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n       \\<exists>Mm'.\n          P \\<turnstile> D sees_methods Mm' \\<and>\n          Mm' M = \\<lfloor>(m, D)\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m D.\n       Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n       \\<exists>Mm'.\n          P \\<turnstile> D sees_methods Mm' \\<and>\n          Mm' M = \\<lfloor>(m, D)\\<rfloor>", "using Cmethods"], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. \\<And>m D.\n       Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n       \\<exists>Mm'.\n          P \\<turnstile> D sees_methods Mm' \\<and>\n          Mm' M = \\<lfloor>(m, D)\\<rfloor>", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm m Da.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        Mm M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>\n 2. \\<And>C D fs ms Mm Mm' m Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>m D.\n           Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm'.\n              P \\<turnstile> D sees_methods Mm' \\<and>\n              Mm' M = \\<lfloor>(m, D)\\<rfloor>;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>", "case sees_methods_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  Mm_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>D fs ms Mm m Da.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        Mm = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms;\n        Mm M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>\n 2. \\<And>C D fs ms Mm Mm' m Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>m D.\n           Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm'.\n              P \\<turnstile> D sees_methods Mm' \\<and>\n              Mm' M = \\<lfloor>(m, D)\\<rfloor>;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  Mm_ = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ms_\n  Mm_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>Mm'.\n       P \\<turnstile> D sees_methods Mm' \\<and>\n       Mm' M = \\<lfloor>(m, D)\\<rfloor>", "by(fastforce dest: Methods.sees_methods_Object)"], ["proof (state)\nthis:\n  \\<exists>Mm'.\n     P \\<turnstile> D sees_methods Mm' \\<and>\n     Mm' M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' m Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>m D.\n           Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm'.\n              P \\<turnstile> D sees_methods Mm' \\<and>\n              Mm' M = \\<lfloor>(m, D)\\<rfloor>;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' m Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>m D.\n           Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm'.\n              P \\<turnstile> D sees_methods Mm' \\<and>\n              Mm' M = \\<lfloor>(m, D)\\<rfloor>;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>", "case sees_methods_rec"], ["proof (state)\nthis:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ sees_methods Mm_\n  Mm_ M = \\<lfloor>(?m, ?D)\\<rfloor> \\<Longrightarrow>\n  \\<exists>Mm'.\n     P \\<turnstile> ?D sees_methods Mm' \\<and>\n     Mm' M = \\<lfloor>(?m, ?D)\\<rfloor>\n  Mm'_ = Mm_ ++ (map_option (\\<lambda>m. (m, C_)) \\<circ> map_of ms_)\n  Mm'_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>C D fs ms Mm Mm' m Da.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D sees_methods Mm;\n        \\<And>m D.\n           Mm M = \\<lfloor>(m, D)\\<rfloor> \\<Longrightarrow>\n           \\<exists>Mm'.\n              P \\<turnstile> D sees_methods Mm' \\<and>\n              Mm' M = \\<lfloor>(m, D)\\<rfloor>;\n        Mm' = Mm ++ (map_option (\\<lambda>m. (m, C)) \\<circ> map_of ms);\n        Mm' M = \\<lfloor>(m, Da)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm'.\n                            P \\<turnstile> Da sees_methods Mm' \\<and>\n                            Mm' M = \\<lfloor>(m, Da)\\<rfloor>", "thus ?case"], ["proof (prove)\nusing this:\n  class P C_ = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  C_ \\<noteq> Object\n  P \\<turnstile> D_ sees_methods Mm_\n  Mm_ M = \\<lfloor>(?m, ?D)\\<rfloor> \\<Longrightarrow>\n  \\<exists>Mm'.\n     P \\<turnstile> ?D sees_methods Mm' \\<and>\n     Mm' M = \\<lfloor>(?m, ?D)\\<rfloor>\n  Mm'_ = Mm_ ++ (map_option (\\<lambda>m. (m, C_)) \\<circ> map_of ms_)\n  Mm'_ M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>Mm'.\n       P \\<turnstile> D sees_methods Mm' \\<and>\n       Mm' M = \\<lfloor>(m, D)\\<rfloor>", "by(fastforce split:option.splits dest: Methods.sees_methods_rec)"], ["proof (state)\nthis:\n  \\<exists>Mm'.\n     P \\<turnstile> D sees_methods Mm' \\<and>\n     Mm' M = \\<lfloor>(m, D)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)\n\n(*FIXME something wrong with induct: need to attache [consumes 1]\ndirectly to proof of thm, declare does not work. *)"], ["", "lemma sees_methods_decl_mono:\nassumes sub: \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\"\nshows \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n       \\<exists>Mm' Mm\\<^sub>2. P \\<turnstile> C' sees_methods Mm' \\<and> Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                 (\\<forall>M m D. Mm\\<^sub>2 M = Some(m,D) \\<longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* C)\"\n(*<*)\n      (is \"_ \\<Longrightarrow> \\<exists>Mm' Mm2. ?Q C' C Mm' Mm2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C' sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)", "using sub"], ["proof (prove)\nusing this:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C' sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)", "proof (induct rule:converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "assume \"P \\<turnstile> C sees_methods Mm\""], ["proof (state)\nthis:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (2 subgoals):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "hence \"?Q C C Mm Map.empty\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees_methods Mm \\<and>\n    Mm = Mm ++ Map.empty \\<and>\n    (\\<forall>M m D.\n        None = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C)", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C sees_methods Mm \\<and>\n  Mm = Mm ++ Map.empty \\<and>\n  (\\<forall>M m D.\n      None = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (2 subgoals):\n 1. P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n    \\<exists>Mm' Mm\\<^sub>2.\n       P \\<turnstile> C sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n       (\\<forall>M m D.\n           Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "thus \"\\<exists>Mm' Mm2. ?Q C C Mm' Mm2\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C sees_methods Mm \\<and>\n  Mm = Mm ++ Map.empty \\<and>\n  (\\<forall>M m D.\n      None = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. \\<exists>Mm' Mm2.\n       P \\<turnstile> C sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm2 \\<and>\n       (\\<forall>M m D.\n           Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Mm' Mm2.\n     P \\<turnstile> C sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm2 \\<and>\n     (\\<forall>M m D.\n         Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "fix C'' C'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "assume sub1: \"P \\<turnstile> C'' \\<prec>\\<^sup>1 C'\" and sub: \"P \\<turnstile> C' \\<preceq>\\<^sup>* C\"\n  and IH: \"P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n           \\<exists>Mm' Mm2. P \\<turnstile> C' sees_methods Mm' \\<and>\n                Mm' = Mm ++ Mm2 \\<and> (\\<forall>M m D. Mm2 M = Some(m,D) \\<longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* C)\"\n  and Csees: \"P \\<turnstile> C sees_methods Mm\""], ["proof (state)\nthis:\n  P \\<turnstile> C'' \\<prec>\\<^sup>1 C'\n  P \\<turnstile> C' \\<preceq>\\<^sup>* C\n  P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n  \\<exists>Mm' Mm2.\n     P \\<turnstile> C' sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm2 \\<and>\n     (\\<forall>M m D.\n         Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n  P \\<turnstile> C sees_methods Mm\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "from IH[OF Csees]"], ["proof (chain)\npicking this:\n  \\<exists>Mm' Mm2.\n     P \\<turnstile> C' sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm2 \\<and>\n     (\\<forall>M m D.\n         Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)", "obtain Mm' Mm2 where C'sees: \"P \\<turnstile> C' sees_methods Mm'\"\n    and Mm': \"Mm' = Mm ++ Mm2\"\n    and subC:\"\\<forall>M m D. Mm2 M = Some(m,D) \\<longrightarrow> P \\<turnstile> D \\<preceq>\\<^sup>* C\""], ["proof (prove)\nusing this:\n  \\<exists>Mm' Mm2.\n     P \\<turnstile> C' sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm2 \\<and>\n     (\\<forall>M m D.\n         Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. (\\<And>Mm' Mm2.\n        \\<lbrakk>P \\<turnstile> C' sees_methods Mm'; Mm' = Mm ++ Mm2;\n         \\<forall>M m D.\n            Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n            P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<turnstile> C' sees_methods Mm'\n  Mm' = Mm ++ Mm2\n  \\<forall>M m D.\n     Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "obtain fs ms where \"class\": \"class P C'' = Some(C',fs,ms)\" \"C'' \\<noteq> Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs ms.\n        \\<lbrakk>class P C'' = \\<lfloor>(C', fs, ms)\\<rfloor>;\n         C'' \\<noteq> Object\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subcls1D[OF sub1]"], ["proof (prove)\nusing this:\n  C'' \\<noteq> Object \\<and>\n  (\\<exists>fs ms. class P C'' = \\<lfloor>(C', fs, ms)\\<rfloor>)\n\ngoal (1 subgoal):\n 1. (\\<And>fs ms.\n        \\<lbrakk>class P C'' = \\<lfloor>(C', fs, ms)\\<rfloor>;\n         C'' \\<noteq> Object\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  class P C'' = \\<lfloor>(C', fs, ms)\\<rfloor>\n  C'' \\<noteq> Object\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "let ?Mm3 = \"map_option (\\<lambda>m. (m,C'')) \\<circ> map_of ms\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "have \"P \\<turnstile> C'' sees_methods (Mm ++ Mm2) ++ ?Mm3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                    (map_option\n(\\<lambda>m. (m, C'')) \\<circ>\n                                     map_of ms)", "using sees_methods_rec[OF \"class\" C'sees refl] Mm'"], ["proof (prove)\nusing this:\n  P \\<turnstile> C'' sees_methods Mm' ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms)\n  Mm' = Mm ++ Mm2\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                    (map_option\n(\\<lambda>m. (m, C'')) \\<circ>\n                                     map_of ms)", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "hence \"?Q C'' C ((Mm ++ Mm2) ++ ?Mm3) (Mm2++?Mm3)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                    (map_option\n(\\<lambda>m. (m, C'')) \\<circ>\n                                     map_of ms) \\<and>\n    Mm ++ Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms) =\n    Mm ++\n    (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) \\<and>\n    (\\<forall>M m D.\n        (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) M =\n        \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C)", "using converse_rtrancl_into_rtrancl[OF sub1 sub]"], ["proof (prove)\nusing this:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms)\n  P \\<turnstile> C'' \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                    (map_option\n(\\<lambda>m. (m, C'')) \\<circ>\n                                     map_of ms) \\<and>\n    Mm ++ Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms) =\n    Mm ++\n    (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) \\<and>\n    (\\<forall>M m D.\n        (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) M =\n        \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n        P \\<turnstile> D \\<preceq>\\<^sup>* C)", "by simp (simp add:map_add_def subC split:option.split)"], ["proof (state)\nthis:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms) \\<and>\n  Mm ++ Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms) =\n  Mm ++\n  (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) \\<and>\n  (\\<forall>M m D.\n      (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) M =\n      \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C sees_methods Mm \\<Longrightarrow>\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> z sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C);\n        P \\<turnstile> C sees_methods Mm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Mm' Mm\\<^sub>2.\n                            P \\<turnstile> y sees_methods Mm' \\<and>\n                            Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n                            (\\<forall>M m D.\n                                Mm\\<^sub>2 M =\n                                \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n                                P \\<turnstile> D \\<preceq>\\<^sup>* C)", "thus \"\\<exists>Mm' Mm2. ?Q C'' C Mm' Mm2\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C'' sees_methods Mm ++ Mm2 ++\n                                  (map_option (\\<lambda>m. (m, C'')) \\<circ>\n                                   map_of ms) \\<and>\n  Mm ++ Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms) =\n  Mm ++\n  (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) \\<and>\n  (\\<forall>M m D.\n      (Mm2 ++ (map_option (\\<lambda>m. (m, C'')) \\<circ> map_of ms)) M =\n      \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n      P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal (1 subgoal):\n 1. \\<exists>Mm' Mm2.\n       P \\<turnstile> C'' sees_methods Mm' \\<and>\n       Mm' = Mm ++ Mm2 \\<and>\n       (\\<forall>M m D.\n           Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Mm' Mm2.\n     P \\<turnstile> C'' sees_methods Mm' \\<and>\n     Mm' = Mm ++ Mm2 \\<and>\n     (\\<forall>M m D.\n         Mm2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n         P \\<turnstile> D \\<preceq>\\<^sup>* C)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "definition Method :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> ty list \\<Rightarrow> ty \\<Rightarrow> 'm \\<Rightarrow> cname \\<Rightarrow> bool\"\n            (\"_ \\<turnstile> _ sees _: _\\<rightarrow>_ = _ in _\" [51,51,51,51,51,51,51] 50)\nwhere\n  \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D  \\<equiv>\n  \\<exists>Mm. P \\<turnstile> C sees_methods Mm \\<and> Mm M = Some((Ts,T,m),D)\""], ["", "definition has_method :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> bool\" (\"_ \\<turnstile> _ has _\" [51,0,51] 50)\nwhere\n  \"P \\<turnstile> C has M \\<equiv> \\<exists>Ts T m D. P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D\""], ["", "lemma sees_method_fun:\n  \"\\<lbrakk>P \\<turnstile> C sees M:TS\\<rightarrow>T = m in D; P \\<turnstile> C sees M:TS'\\<rightarrow>T' = m' in D' \\<rbrakk>\n   \\<Longrightarrow> TS' = TS \\<and> T' = T \\<and> m' = m \\<and> D' = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees M: TS\\<rightarrow>T = m in D;\n     P \\<turnstile> C sees M: TS'\\<rightarrow>T' = m' in D'\\<rbrakk>\n    \\<Longrightarrow> TS' = TS \\<and> T' = T \\<and> m' = m \\<and> D' = D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees M: TS\\<rightarrow>T = m in D;\n     P \\<turnstile> C sees M: TS'\\<rightarrow>T' = m' in D'\\<rbrakk>\n    \\<Longrightarrow> TS' = TS \\<and> T' = T \\<and> m' = m \\<and> D' = D", "by(fastforce dest: sees_methods_fun simp:Method_def)"], ["", "(*>*)"], ["", "lemma sees_method_decl_above:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "by(clarsimp simp:Method_def sees_methods_decl_above)"], ["", "(*>*)"], ["", "lemma visible_method_exists:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n  \\<exists>D' fs ms. class P D = Some(D',fs,ms) \\<and> map_of ms M = Some(Ts,T,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    \\<exists>D' fs ms.\n       class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n       map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    \\<exists>D' fs ms.\n       class P D = \\<lfloor>(D', fs, ms)\\<rfloor> \\<and>\n       map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>", "by(fastforce simp:Method_def dest!: visible_methods_exist)"], ["", "(*>*)"], ["", "lemma sees_method_idemp:\n  \"P \\<turnstile> C sees M:Ts\\<rightarrow>T=m in D \\<Longrightarrow> P \\<turnstile> D sees M:Ts\\<rightarrow>T=m in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> D sees M: Ts\\<rightarrow>T = m in D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    P \\<turnstile> D sees M: Ts\\<rightarrow>T = m in D", "by(fastforce simp: Method_def intro:sees_methods_idemp)"], ["", "(*>*)"], ["", "lemma sees_method_decl_mono:\n  \"\\<lbrakk> P \\<turnstile> C' \\<preceq>\\<^sup>* C; P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' sees M:Ts'\\<rightarrow>T' = m' in D' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply(frule sees_method_decl_above)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C;\n     P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D;\n     P \\<turnstile> C' sees M: Ts'\\<rightarrow>T' = m' in D';\n     P \\<turnstile> C \\<preceq>\\<^sup>* D\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply(unfold Method_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C;\n     \\<exists>Mm.\n        P \\<turnstile> C sees_methods Mm \\<and>\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n     \\<exists>Mm.\n        P \\<turnstile> C' sees_methods Mm \\<and>\n        Mm M = \\<lfloor>((Ts', T', m'), D')\\<rfloor>;\n     P \\<turnstile> C \\<preceq>\\<^sup>* D\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm Mma.\n       \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> C' sees_methods Mma;\n        Mma M = \\<lfloor>((Ts', T', m'), D')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply(drule (1) sees_methods_decl_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm Mma.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> C' sees_methods Mma;\n        Mma M = \\<lfloor>((Ts', T', m'), D')\\<rfloor>;\n        \\<exists>Mm' Mm\\<^sub>2.\n           P \\<turnstile> C' sees_methods Mm' \\<and>\n           Mm' = Mm ++ Mm\\<^sub>2 \\<and>\n           (\\<forall>M m D.\n               Mm\\<^sub>2 M = \\<lfloor>(m, D)\\<rfloor> \\<longrightarrow>\n               P \\<turnstile> D \\<preceq>\\<^sup>* C)\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm Mma Mm\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> C' sees_methods Mma;\n        Mma M = \\<lfloor>((Ts', T', m'), D')\\<rfloor>;\n        P \\<turnstile> C' sees_methods Mm ++ Mm\\<^sub>2;\n        \\<forall>M a aa b D.\n           Mm\\<^sub>2 M =\n           \\<lfloor>((a, aa, b), D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply(drule (1) sees_methods_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm Mma Mm\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        Mma M = \\<lfloor>((Ts', T', m'), D')\\<rfloor>;\n        P \\<turnstile> C' sees_methods Mm ++ Mm\\<^sub>2;\n        \\<forall>M a aa b D.\n           Mm\\<^sub>2 M =\n           \\<lfloor>((a, aa, b), D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        Mm ++ Mm\\<^sub>2 = Mma\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm Mm\\<^sub>2.\n       \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        P \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>;\n        P \\<turnstile> C' sees_methods Mm ++ Mm\\<^sub>2;\n        \\<forall>M a aa b D.\n           Mm\\<^sub>2 M =\n           \\<lfloor>((a, aa, b), D)\\<rfloor> \\<longrightarrow>\n           P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        Mm\\<^sub>2 M = \\<lfloor>((Ts', T', m'), D')\\<rfloor> \\<or>\n        Mm\\<^sub>2 M = None \\<and>\n        Ts = Ts' \\<and> T = T' \\<and> m = m' \\<and> D = D'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' \\<preceq>\\<^sup>* D", "apply(blast intro:rtrancl_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sees_method_is_class:\n  \"\\<lbrakk> P \\<turnstile> C sees M:Ts\\<rightarrow>T = m in D \\<rbrakk> \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    is_class P C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    is_class P C", "by (auto simp add: is_class_def Method_def elim: Methods.induct)"], ["", "(*>*)"], ["", "subsection\\<open>Field lookup\\<close>"], ["", "inductive\n  Fields :: \"['m prog, cname, ((vname \\<times> cname) \\<times> ty) list] \\<Rightarrow> bool\"\n                  (\"_ \\<turnstile> _ has'_fields _\" [51,51,51] 50)\n  for P :: \"'m prog\"\nwhere\n  has_fields_rec:\n  \"\\<lbrakk> class P C = Some(D,fs,ms); C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n     FDTs' = map (\\<lambda>(F,T). ((F,C),T)) fs @ FDTs \\<rbrakk>\n   \\<Longrightarrow> P \\<turnstile> C has_fields FDTs'\"\n| has_fields_Object:\n  \"\\<lbrakk> class P Object = Some(D,fs,ms); FDTs = map (\\<lambda>(F,T). ((F,Object),T)) fs \\<rbrakk>\n   \\<Longrightarrow> P \\<turnstile> Object has_fields FDTs\""], ["", "lemma has_fields_fun:\nassumes 1: \"P \\<turnstile> C has_fields FDTs\"\nshows \"\\<And>FDTs'. P \\<turnstile> C has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs'.\n       P \\<turnstile> C has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs'.\n       P \\<turnstile> C has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs", "using 1"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<And>FDTs'.\n       P \\<turnstile> C has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'\n 2. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "case (has_fields_rec C D fs ms Dres Cres Cres')"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D has_fields Dres\n  P \\<turnstile> D has_fields ?FDTs' \\<Longrightarrow> ?FDTs' = Dres\n  Cres = map (\\<lambda>(F, T). ((F, C), T)) fs @ Dres\n  P \\<turnstile> C has_fields Cres'\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'\n 2. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "have \"class\": \"class P C = Some (D, fs, ms)\"\n   and notObj: \"C \\<noteq> Object\" and DFields: \"P \\<turnstile> D has_fields Dres\"\n   and IH: \"\\<And>Dres'. P \\<turnstile> D has_fields Dres' \\<Longrightarrow> Dres' = Dres\"\n   and Cres: \"Cres = map (\\<lambda>(F,T). ((F,C),T)) fs @ Dres\"\n   and CFields': \"P \\<turnstile> C has_fields Cres'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (class P C = \\<lfloor>(D, fs, ms)\\<rfloor> &&&\n     C \\<noteq> Object &&& P \\<turnstile> D has_fields Dres) &&&\n    (\\<And>Dres'.\n        P \\<turnstile> D has_fields Dres' \\<Longrightarrow>\n        Dres' = Dres) &&&\n    Cres = map (\\<lambda>(F, T). ((F, C), T)) fs @ Dres &&&\n    P \\<turnstile> C has_fields Cres'", "by fact+"], ["proof (state)\nthis:\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n  C \\<noteq> Object\n  P \\<turnstile> D has_fields Dres\n  P \\<turnstile> D has_fields ?Dres' \\<Longrightarrow> ?Dres' = Dres\n  Cres = map (\\<lambda>(F, T). ((F, C), T)) fs @ Dres\n  P \\<turnstile> C has_fields Cres'\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'\n 2. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "from CFields' notObj \"class\""], ["proof (chain)\npicking this:\n  P \\<turnstile> C has_fields Cres'\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>", "obtain Dres'\n    where DFields': \"P \\<turnstile> D has_fields Dres'\"\n     and Cres': \"Cres' = map (\\<lambda>(F,T). ((F,C),T)) fs @ Dres'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields Cres'\n  C \\<noteq> Object\n  class P C = \\<lfloor>(D, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>Dres'.\n        \\<lbrakk>P \\<turnstile> D has_fields Dres';\n         Cres' = map (\\<lambda>(F, T). ((F, C), T)) fs @ Dres'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: Fields.cases)"], ["proof (state)\nthis:\n  P \\<turnstile> D has_fields Dres'\n  Cres' = map (\\<lambda>(F, T). ((F, C), T)) fs @ Dres'\n\ngoal (2 subgoals):\n 1. \\<And>C D fs ms FDTs FDTs' FDTs'a.\n       \\<lbrakk>class P C = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> D has_fields FDTs;\n        \\<And>FDTs'.\n           P \\<turnstile> D has_fields FDTs' \\<Longrightarrow> FDTs' = FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        P \\<turnstile> C has_fields FDTs'a\\<rbrakk>\n       \\<Longrightarrow> FDTs'a = FDTs'\n 2. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "from Cres Cres' IH[OF DFields']"], ["proof (chain)\npicking this:\n  Cres = map (\\<lambda>(F, T). ((F, C), T)) fs @ Dres\n  Cres' = map (\\<lambda>(F, T). ((F, C), T)) fs @ Dres'\n  Dres' = Dres", "show \"Cres' = Cres\""], ["proof (prove)\nusing this:\n  Cres = map (\\<lambda>(F, T). ((F, C), T)) fs @ Dres\n  Cres' = map (\\<lambda>(F, T). ((F, C), T)) fs @ Dres'\n  Dres' = Dres\n\ngoal (1 subgoal):\n 1. Cres' = Cres", "by simp"], ["proof (state)\nthis:\n  Cres' = Cres\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "case has_fields_Object"], ["proof (state)\nthis:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n  P \\<turnstile> Object has_fields FDTs'\n\ngoal (1 subgoal):\n 1. \\<And>D fs ms FDTs FDTs'.\n       \\<lbrakk>class P Object = \\<lfloor>(D, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        P \\<turnstile> Object has_fields FDTs'\\<rbrakk>\n       \\<Longrightarrow> FDTs' = FDTs", "thus ?case"], ["proof (prove)\nusing this:\n  class P Object = \\<lfloor>(D_, fs_, ms_)\\<rfloor>\n  FDTs_ = map (\\<lambda>(F, T). ((F, Object), T)) fs_\n  P \\<turnstile> Object has_fields FDTs'\n\ngoal (1 subgoal):\n 1. FDTs' = FDTs_", "by(auto elim: Fields.cases)"], ["proof (state)\nthis:\n  FDTs' = FDTs_\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma all_fields_in_has_fields:\nassumes sub: \"P \\<turnstile> C has_fields FDTs\"\nshows \"\\<lbrakk> P \\<turnstile> C \\<preceq>\\<^sup>* D; class P D = Some(D',fs,ms); (F,T) \\<in> set fs \\<rbrakk>\n       \\<Longrightarrow> ((F,D),T) \\<in> set FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n     (F, T) \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> ((F, D), T) \\<in> set FDTs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n     (F, T) \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> ((F, D), T) \\<in> set FDTs", "using sub"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n     (F, T) \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> ((F, D), T) \\<in> set FDTs", "apply(induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C Da fsa msa FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        \\<lbrakk>P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n         class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n         (F, T) \\<in> set fs\\<rbrakk>\n        \\<Longrightarrow> ((F, D), T) \\<in> set FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fsa @ FDTs;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), T) \\<in> set FDTs'\n 2. \\<And>Da fsa msa FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fsa;\n        P \\<turnstile> Object \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), T) \\<in> set FDTs", "apply(simp add:image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C Da fsa msa FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D \\<Longrightarrow>\n        ((F, D), T) \\<in> set FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fsa @ FDTs;\n        P \\<turnstile> C \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>set fsa.\n                             ((F, D), T) =\n                             (case x of\n                              (F, x) \\<Rightarrow> ((F, C), x))) \\<or>\n                         ((F, D), T) \\<in> set FDTs\n 2. \\<And>Da fsa msa FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fsa;\n        P \\<turnstile> Object \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), T) \\<in> set FDTs", "apply(erule converse_rtranclE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>C Da fsa msa FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D \\<Longrightarrow>\n        ((F, D), T) \\<in> set FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fsa @ FDTs;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>; (F, T) \\<in> set fs;\n        C = D\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>set fsa.\n                             ((F, D), T) =\n                             (case x of\n                              (F, x) \\<Rightarrow> ((F, C), x))) \\<or>\n                         ((F, D), T) \\<in> set FDTs\n 2. \\<And>C Da fsa msa FDTs FDTs' y.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D \\<Longrightarrow>\n        ((F, D), T) \\<in> set FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fsa @ FDTs;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>; (F, T) \\<in> set fs;\n        P \\<turnstile> C \\<prec>\\<^sup>1 y;\n        P \\<turnstile> y \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>set fsa.\n                             ((F, D), T) =\n                             (case x of\n                              (F, x) \\<Rightarrow> ((F, C), x))) \\<or>\n                         ((F, D), T) \\<in> set FDTs\n 3. \\<And>Da fsa msa FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fsa;\n        P \\<turnstile> Object \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), T) \\<in> set FDTs", "apply(force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C Da fsa msa FDTs FDTs' y.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D \\<Longrightarrow>\n        ((F, D), T) \\<in> set FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fsa @ FDTs;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>; (F, T) \\<in> set fs;\n        P \\<turnstile> C \\<prec>\\<^sup>1 y;\n        P \\<turnstile> y \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>set fsa.\n                             ((F, D), T) =\n                             (case x of\n                              (F, x) \\<Rightarrow> ((F, C), x))) \\<or>\n                         ((F, D), T) \\<in> set FDTs\n 2. \\<And>Da fsa msa FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fsa;\n        P \\<turnstile> Object \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), T) \\<in> set FDTs", "apply(drule subcls1D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C Da fsa msa FDTs FDTs' y.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D \\<Longrightarrow>\n        ((F, D), T) \\<in> set FDTs;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fsa @ FDTs;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>; (F, T) \\<in> set fs;\n        P \\<turnstile> y \\<preceq>\\<^sup>* D;\n        C \\<noteq> Object \\<and>\n        (\\<exists>fs ms. class P C = \\<lfloor>(y, fs, ms)\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>set fsa.\n                             ((F, D), T) =\n                             (case x of\n                              (F, x) \\<Rightarrow> ((F, C), x))) \\<or>\n                         ((F, D), T) \\<in> set FDTs\n 2. \\<And>Da fsa msa FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fsa;\n        P \\<turnstile> Object \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), T) \\<in> set FDTs", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Da fsa msa FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fsa, msa)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fsa;\n        P \\<turnstile> Object \\<preceq>\\<^sup>* D;\n        class P D = \\<lfloor>(D', fs, ms)\\<rfloor>;\n        (F, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> ((F, D), T) \\<in> set FDTs", "apply(force simp:image_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma has_fields_decl_above:\nassumes fields: \"P \\<turnstile> C has_fields FDTs\"\nshows \"((F,D),T) \\<in> set FDTs \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "using fields"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "apply(induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        ((F, D), T) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Object \\<preceq>\\<^sup>* D\n 2. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        ((F, D), T) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        ((F, D), T) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        ((F, D), T)\n        \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n              set fs \\<or>\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        ((F, D), T)\n        \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n              set fs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\n 2. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "apply(clarsimp simp add:image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        P \\<turnstile> Da \\<preceq>\\<^sup>* D;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "apply(blast dest:subcls1I converse_rtrancl_into_rtrancl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma subcls_notin_has_fields:\nassumes fields: \"P \\<turnstile> C has_fields FDTs\"\nshows \"((F,D),T) \\<in> set FDTs \\<Longrightarrow> (D,C) \\<notin> (subcls1 P)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "using fields"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has_fields FDTs\n\ngoal (1 subgoal):\n 1. ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n    (D, C) \\<notin> (subcls1 P)\\<^sup>+", "apply(induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        ((F, D), T) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> (D, C) \\<notin> (subcls1 P)\\<^sup>+\n 2. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> (D, Object) \\<notin> (subcls1 P)\\<^sup>+", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTs = map (\\<lambda>(F, T). ((F, Object), T)) fs;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> (D, Object) \\<notin> (subcls1 P)\\<^sup>+\n 2. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        ((F, D), T) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> (D, C) \\<notin> (subcls1 P)\\<^sup>+", "apply(fastforce dest: tranclD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms FDTs FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTs;\n        ((F, D), T) \\<in> set FDTs'\\<rbrakk>\n       \\<Longrightarrow> (D, C) \\<notin> (subcls1 P)\\<^sup>+", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        ((F, D), T)\n        \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n              set fs \\<or>\n        ((F, D), T) \\<in> set FDTs;\n        (D, C) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        (D, C) \\<in> (subcls1 P)\\<^sup>+;\n        ((F, D), T)\n        \\<in> (\\<lambda>x. case x of (F, x) \\<Rightarrow> ((F, C), x)) `\n              set fs\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        (D, C) \\<in> (subcls1 P)\\<^sup>+;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(clarsimp simp add:image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        (D, D) \\<in> (subcls1 P)\\<^sup>+; (F, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        (D, C) \\<in> (subcls1 P)\\<^sup>+;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule tranclD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTs.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        (F, T) \\<in> set fs;\n        \\<exists>z.\n           P \\<turnstile> D \\<prec>\\<^sup>1 z \\<and>\n           P \\<turnstile> z \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        (D, C) \\<in> (subcls1 P)\\<^sup>+;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTs z.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        (F, T) \\<in> set fs; P \\<turnstile> D \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* D\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        (D, C) \\<in> (subcls1 P)\\<^sup>+;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(frule subcls1D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTs z.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        (F, T) \\<in> set fs; P \\<turnstile> D \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* D;\n        D \\<noteq> Object \\<and>\n        (\\<exists>fs ms. class P D = \\<lfloor>(z, fs, ms)\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        (D, C) \\<in> (subcls1 P)\\<^sup>+;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(fastforce dest:all_fields_in_has_fields)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        ((F, D), T) \\<in> set FDTs \\<Longrightarrow>\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        (D, C) \\<in> (subcls1 P)\\<^sup>+;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C Da fs ms FDTs.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTs;\n        (D, Da) \\<notin> (subcls1 P)\\<^sup>+;\n        (D, C) \\<in> (subcls1 P)\\<^sup>+;\n        ((F, D), T) \\<in> set FDTs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(blast dest:subcls1I trancl_into_trancl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma has_fields_mono_lem:\nassumes sub: \"P \\<turnstile> D \\<preceq>\\<^sup>* C\"\nshows \"P \\<turnstile> C has_fields FDTs\n         \\<Longrightarrow> \\<exists>pre. P \\<turnstile> D has_fields pre@FDTs \\<and> dom(map_of pre) \\<inter> dom(map_of FDTs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    \\<exists>pre.\n       P \\<turnstile> D has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    \\<exists>pre.\n       P \\<turnstile> D has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "using sub"], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    \\<exists>pre.\n       P \\<turnstile> D has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(induct rule:converse_rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    \\<exists>pre.\n       P \\<turnstile> C has_fields pre @ FDTs \\<and>\n       dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(rule_tac x = \"[]\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P \\<turnstile> C has_fields [] @ FDTs \\<and>\n    dom (map_of []) \\<inter> dom (map_of FDTs) = {}\n 2. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n        \\<exists>pre.\n           P \\<turnstile> z has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        P \\<turnstile> C has_fields FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z pre.\n       \\<lbrakk>P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        P \\<turnstile> z \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> z has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> y has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(rename_tac D' D pre)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D' \\<prec>\\<^sup>1 D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(subgoal_tac \"(D',C) : (subcls1 P)^+\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D' \\<prec>\\<^sup>1 D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\n 2. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D' \\<prec>\\<^sup>1 D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\\<rbrakk>\n       \\<Longrightarrow> (D', C) \\<in> (subcls1 P)\\<^sup>+", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D' \\<prec>\\<^sup>1 D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\\<rbrakk>\n       \\<Longrightarrow> (D', C) \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D' \\<prec>\\<^sup>1 D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(erule (1) rtrancl_into_trancl2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D' \\<prec>\\<^sup>1 D;\n        P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(drule subcls1D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+;\n        D' \\<noteq> Object \\<and>\n        (\\<exists>fs ms.\n            class P D' = \\<lfloor>(D, fs, ms)\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs ms.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+; D' \\<noteq> Object;\n        class P D' = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(rename_tac fs ms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs ms.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+; D' \\<noteq> Object;\n        class P D' = \\<lfloor>(D, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(drule (2) has_fields_rec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D' D pre fs ms.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+; D' \\<noteq> Object\\<rbrakk>\n       \\<Longrightarrow> ?FDTs'14 D' D pre fs ms =\n                         map (\\<lambda>(F, T). ((F, D'), T)) fs @ pre @ FDTs\n 2. \\<And>D' D pre fs ms.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+; D' \\<noteq> Object;\n        P \\<turnstile> D' has_fields ?FDTs'14 D' D pre fs ms\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs ms.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+; D' \\<noteq> Object;\n        P \\<turnstile> D' has_fields map (\\<lambda>(F, T). ((F, D'), T))\nfs @\n                                     pre @ FDTs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre.\n                            P \\<turnstile> D' has_fields pre @ FDTs \\<and>\n                            dom (map_of pre) \\<inter> dom (map_of FDTs) = {}", "apply(rule_tac x = \"map (\\<lambda>(F,T). ((F,D'),T)) fs @ pre\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs ms.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+; D' \\<noteq> Object;\n        P \\<turnstile> D' has_fields map (\\<lambda>(F, T). ((F, D'), T))\nfs @\n                                     pre @ FDTs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> D' has_fields (map\n                  (\\<lambda>(F, T). ((F, D'), T)) fs @\n                 pre) @\n                FDTs \\<and>\n                         dom (map_of\n                               (map (\\<lambda>(F, T). ((F, D'), T)) fs @\n                                pre)) \\<inter>\n                         dom (map_of FDTs) =\n                         {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+; D' \\<noteq> Object;\n        P \\<turnstile> D' has_fields map (\\<lambda>(F, y). ((F, D'), y))\nfs @\n                                     pre @ FDTs\\<rbrakk>\n       \\<Longrightarrow> (dom (map_of\n                                (map (\\<lambda>(F, y). ((F, D'), y))\n                                  fs)) \\<union>\n                          dom (map_of pre)) \\<inter>\n                         dom (map_of FDTs) =\n                         {}", "apply(simp add:Int_Un_distrib2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+; D' \\<noteq> Object;\n        P \\<turnstile> D' has_fields map (\\<lambda>(F, y). ((F, D'), y))\nfs @\n                                     pre @ FDTs\\<rbrakk>\n       \\<Longrightarrow> dom (map_of\n                               (map (\\<lambda>(F, y). ((F, D'), y))\n                                 fs)) \\<inter>\n                         dom (map_of FDTs) =\n                         {}", "apply(rule equals0I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' D pre fs y.\n       \\<lbrakk>P \\<turnstile> D \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        P \\<turnstile> D has_fields pre @ FDTs;\n        dom (map_of pre) \\<inter> dom (map_of FDTs) = {};\n        (D', C) \\<in> (subcls1 P)\\<^sup>+; D' \\<noteq> Object;\n        P \\<turnstile> D' has_fields map (\\<lambda>(F, y). ((F, D'), y))\nfs @\n                                     pre @ FDTs;\n        y \\<in> dom (map_of\n                      (map (\\<lambda>(F, y). ((F, D'), y)) fs)) \\<inter>\n                dom (map_of FDTs)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto dest: subcls_notin_has_fields simp:dom_map_of_conv_image_fst image_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(* FIXME why is Field not displayed correctly? TypeRel qualifier seems to confuse printer*)"], ["", "definition has_field :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> vname \\<Rightarrow> ty \\<Rightarrow> cname \\<Rightarrow> bool\"\n                   (\"_ \\<turnstile> _ has _:_ in _\" [51,51,51,51,51] 50)\nwhere\n  \"P \\<turnstile> C has F:T in D  \\<equiv>\n  \\<exists>FDTs. P \\<turnstile> C has_fields FDTs \\<and> map_of FDTs (F,D) = Some T\""], ["", "lemma has_field_mono:\n  \"\\<lbrakk> P \\<turnstile> C has F:T in D; P \\<turnstile> C' \\<preceq>\\<^sup>* C \\<rbrakk> \\<Longrightarrow> P \\<turnstile> C' has F:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has F:T in D;\n     P \\<turnstile> C' \\<preceq>\\<^sup>* C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> C' has F:T in D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has F:T in D;\n     P \\<turnstile> C' \\<preceq>\\<^sup>* C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> C' has F:T in D", "apply(clarsimp simp:has_field_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs.\n       \\<lbrakk>P \\<turnstile> C' \\<preceq>\\<^sup>* C;\n        P \\<turnstile> C has_fields FDTs;\n        map_of FDTs (F, D) = \\<lfloor>T\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>FDTs.\n                            P \\<turnstile> C' has_fields FDTs \\<and>\n                            map_of FDTs (F, D) = \\<lfloor>T\\<rfloor>", "apply(drule (1) has_fields_mono_lem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs.\n       \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n        map_of FDTs (F, D) = \\<lfloor>T\\<rfloor>;\n        \\<exists>pre.\n           P \\<turnstile> C' has_fields pre @ FDTs \\<and>\n           dom (map_of pre) \\<inter> dom (map_of FDTs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>FDTs.\n                            P \\<turnstile> C' has_fields FDTs \\<and>\n                            map_of FDTs (F, D) = \\<lfloor>T\\<rfloor>", "apply(fastforce simp: map_add_def split:option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "definition sees_field :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> vname \\<Rightarrow> ty \\<Rightarrow> cname \\<Rightarrow> bool\"\n                  (\"_ \\<turnstile> _ sees _:_ in _\" [51,51,51,51,51] 50)\nwhere\n  \"P \\<turnstile> C sees F:T in D  \\<equiv>\n  \\<exists>FDTs. P \\<turnstile> C has_fields FDTs \\<and>\n            map_of (map (\\<lambda>((F,D),T). (F,(D,T))) FDTs) F = Some(D,T)\""], ["", "lemma map_of_remap_SomeD:\n  \"map_of (map (\\<lambda>((k,k'),x). (k,(k',x))) t) k = Some (k',x) \\<Longrightarrow> map_of t (k, k') = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((k, k'), x). (k, k', x)) t) k =\n    \\<lfloor>(k', x)\\<rfloor> \\<Longrightarrow>\n    map_of t (k, k') = \\<lfloor>x\\<rfloor>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>((k, k'), x). (k, k', x)) t) k =\n    \\<lfloor>(k', x)\\<rfloor> \\<Longrightarrow>\n    map_of t (k, k') = \\<lfloor>x\\<rfloor>", "by (induct t) (auto simp:fun_upd_apply split: if_split_asm)"], ["", "(*>*)"], ["", "lemma has_visible_field:\n  \"P \\<turnstile> C sees F:T in D \\<Longrightarrow> P \\<turnstile> C has F:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F:T in D \\<Longrightarrow>\n    P \\<turnstile> C has F:T in D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F:T in D \\<Longrightarrow>\n    P \\<turnstile> C has F:T in D", "by(auto simp add:has_field_def sees_field_def map_of_remap_SomeD)"], ["", "(*>*)"], ["", "lemma sees_field_fun:\n  \"\\<lbrakk>P \\<turnstile> C sees F:T in D; P \\<turnstile> C sees F:T' in D'\\<rbrakk> \\<Longrightarrow> T' = T \\<and> D' = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees F:T in D;\n     P \\<turnstile> C sees F:T' in D'\\<rbrakk>\n    \\<Longrightarrow> T' = T \\<and> D' = D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees F:T in D;\n     P \\<turnstile> C sees F:T' in D'\\<rbrakk>\n    \\<Longrightarrow> T' = T \\<and> D' = D", "by(fastforce simp:sees_field_def dest:has_fields_fun)"], ["", "(*>*)"], ["", "lemma sees_field_decl_above:\n  \"P \\<turnstile> C sees F:T in D \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F:T in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F:T in D \\<Longrightarrow>\n    P \\<turnstile> C \\<preceq>\\<^sup>* D", "apply(auto simp:sees_field_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs.\n       \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n        map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n        \\<lfloor>(D, T)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* D", "apply(blast  intro: has_fields_decl_above map_of_SomeD map_of_remap_SomeD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(* FIXME ugly *)"], ["", "lemma sees_field_idemp:\n  \"P \\<turnstile> C sees F:T in D \\<Longrightarrow> P \\<turnstile> D sees F:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F:T in D \\<Longrightarrow>\n    P \\<turnstile> D sees F:T in D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F:T in D \\<Longrightarrow>\n    P \\<turnstile> D sees F:T in D", "apply (unfold sees_field_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>FDTs.\n       P \\<turnstile> C has_fields FDTs \\<and>\n       map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n       \\<lfloor>(D, T)\\<rfloor> \\<Longrightarrow>\n    \\<exists>FDTs.\n       P \\<turnstile> D has_fields FDTs \\<and>\n       map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n       \\<lfloor>(D, T)\\<rfloor>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs.\n       \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n        map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n        \\<lfloor>(D, T)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>FDTs.\n                            P \\<turnstile> D has_fields FDTs \\<and>\n                            map_of\n                             (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                             F =\n                            \\<lfloor>(D, T)\\<rfloor>", "apply (rule_tac P = \"map_of xs F = y\" for xs y in mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>FDTs.\n       \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n        map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n        \\<lfloor>(D, T)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_of (?xs6 FDTs) F = ?y6 FDTs \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                              F =\n                             \\<lfloor>(D, T)\\<rfloor>)\n 2. \\<And>FDTs.\n       \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n        map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n        \\<lfloor>(D, T)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_of (?xs6 FDTs) F = ?y6 FDTs", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>FDTs.\n       \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n        map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n        \\<lfloor>(D, T)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_of (?xs6 FDTs) F = ?y6 FDTs\n 2. \\<And>FDTs.\n       \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n        map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n        \\<lfloor>(D, T)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_of (?xs6 FDTs) F = ?y6 FDTs \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                              F =\n                             \\<lfloor>(D, T)\\<rfloor>)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs.\n       \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n        map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n        \\<lfloor>(D, T)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                          F =\n                         \\<lfloor>(D, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                              F =\n                             \\<lfloor>(D, T)\\<rfloor>)", "apply (thin_tac \"map_of xs F = y\" for xs y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs.\n       P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n       map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n       \\<lfloor>(D, T)\\<rfloor> \\<longrightarrow>\n       (\\<exists>FDTs.\n           P \\<turnstile> D has_fields FDTs \\<and>\n           map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n           \\<lfloor>(D, T)\\<rfloor>)", "apply (erule Fields.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>FDTs C Da fs ms FDTsa FDTs'.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        map_of\n         (map (\\<lambda>a.\n                  case a of\n                  (a, b) \\<Rightarrow>\n                    (case a of (F, D) \\<Rightarrow> \\<lambda>T. (F, D, T))\n                     b)\n           FDTsa)\n         F =\n        \\<lfloor>(D, T)\\<rfloor> \\<longrightarrow>\n        (\\<exists>FDTs.\n            P \\<turnstile> D has_fields FDTs \\<and>\n            map_of\n             (map (\\<lambda>a.\n                      case a of\n                      (a, b) \\<Rightarrow>\n                        (case a of\n                         (F, D) \\<Rightarrow> \\<lambda>T. (F, D, T))\n                         b)\n               FDTs)\n             F =\n            \\<lfloor>(D, T)\\<rfloor>);\n        FDTs' = map (\\<lambda>(F, T). ((F, C), T)) fs @ FDTsa\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow> \\<lambda>T. (F, D, T))\nb)\n                            FDTs')\n                          F =\n                         \\<lfloor>(D, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>T. (F, D, T)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, T)\\<rfloor>)\n 2. \\<And>FDTs Da fs ms FDTsa.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTsa = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow> \\<lambda>T. (F, D, T))\nb)\n                            FDTsa)\n                          F =\n                         \\<lfloor>(D, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>T. (F, D, T)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, T)\\<rfloor>)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTsa.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        map_of\n         (map ((\\<lambda>((F, D), T). (F, D, T)) \\<circ>\n               (\\<lambda>(F, y). ((F, C), y)))\n           fs)\n         F =\n        \\<lfloor>(D, T)\\<rfloor>;\n        map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTsa) F \\<noteq>\n        \\<lfloor>(D, T)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>FDTs.\n                            P \\<turnstile> D has_fields FDTs \\<and>\n                            map_of\n                             (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                             F =\n                            \\<lfloor>(D, T)\\<rfloor>\n 2. \\<And>FDTs Da fs ms FDTsa.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTsa = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow> \\<lambda>T. (F, D, T))\nb)\n                            FDTsa)\n                          F =\n                         \\<lfloor>(D, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>T. (F, D, T)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, T)\\<rfloor>)", "apply (frule map_of_SomeD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C Da fs ms FDTsa.\n       \\<lbrakk>class P C = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        map_of\n         (map ((\\<lambda>((F, D), T). (F, D, T)) \\<circ>\n               (\\<lambda>(F, y). ((F, C), y)))\n           fs)\n         F =\n        \\<lfloor>(D, T)\\<rfloor>;\n        map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTsa) F \\<noteq>\n        \\<lfloor>(D, T)\\<rfloor>;\n        (F, D, T)\n        \\<in> set (map ((\\<lambda>((F, D), T). (F, D, T)) \\<circ>\n                        (\\<lambda>(F, y). ((F, C), y)))\n                    fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>FDTs.\n                            P \\<turnstile> D has_fields FDTs \\<and>\n                            map_of\n                             (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                             F =\n                            \\<lfloor>(D, T)\\<rfloor>\n 2. \\<And>FDTs Da fs ms FDTsa.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTsa = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow> \\<lambda>T. (F, D, T))\nb)\n                            FDTsa)\n                          F =\n                         \\<lfloor>(D, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>T. (F, D, T)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, T)\\<rfloor>)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms FDTsa.\n       \\<lbrakk>class P D = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        D \\<noteq> Object; P \\<turnstile> Da has_fields FDTsa;\n        map_of\n         (map ((\\<lambda>((F, D), T). (F, D, T)) \\<circ>\n               (\\<lambda>(F, y). ((F, D), y)))\n           fs)\n         F =\n        \\<lfloor>(D, T)\\<rfloor>;\n        map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTsa) F \\<noteq>\n        \\<lfloor>(D, T)\\<rfloor>;\n        (F, T) \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>FDTs.\n                            P \\<turnstile> D has_fields FDTs \\<and>\n                            map_of\n                             (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                             F =\n                            \\<lfloor>(D, T)\\<rfloor>\n 2. \\<And>FDTs Da fs ms FDTsa.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTsa = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow> \\<lambda>T. (F, D, T))\nb)\n                            FDTsa)\n                          F =\n                         \\<lfloor>(D, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>T. (F, D, T)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, T)\\<rfloor>)", "apply (fastforce intro: has_fields_rec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs Da fs ms FDTsa.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        FDTsa = map (\\<lambda>(F, T). ((F, Object), T)) fs\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (a, b) \\<Rightarrow>\n                                     (case a of\n(F, D) \\<Rightarrow> \\<lambda>T. (F, D, T))\nb)\n                            FDTsa)\n                          F =\n                         \\<lfloor>(D, T)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>FDTs.\n                             P \\<turnstile> D has_fields FDTs \\<and>\n                             map_of\n                              (map (\\<lambda>a.\n case a of\n (a, b) \\<Rightarrow>\n   (case a of (F, D) \\<Rightarrow> \\<lambda>T. (F, D, T)) b)\n                                FDTs)\n                              F =\n                             \\<lfloor>(D, T)\\<rfloor>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Da fs ms.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        map_of\n         (map ((\\<lambda>((F, D), T). (F, D, T)) \\<circ>\n               (\\<lambda>(F, y). ((F, Object), y)))\n           fs)\n         F =\n        \\<lfloor>(D, T)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>FDTs.\n                            P \\<turnstile> D has_fields FDTs \\<and>\n                            map_of\n                             (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                             F =\n                            \\<lfloor>(D, T)\\<rfloor>", "apply (frule map_of_SomeD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Da fs ms.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        map_of\n         (map ((\\<lambda>((F, D), T). (F, D, T)) \\<circ>\n               (\\<lambda>(F, y). ((F, Object), y)))\n           fs)\n         F =\n        \\<lfloor>(D, T)\\<rfloor>;\n        (F, D, T)\n        \\<in> set (map ((\\<lambda>((F, D), T). (F, D, T)) \\<circ>\n                        (\\<lambda>(F, y). ((F, Object), y)))\n                    fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>FDTs.\n                            P \\<turnstile> D has_fields FDTs \\<and>\n                            map_of\n                             (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                             F =\n                            \\<lfloor>(D, T)\\<rfloor>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Da fs ms.\n       \\<lbrakk>class P Object = \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        map_of\n         (map ((\\<lambda>((F, D), T). (F, D, T)) \\<circ>\n               (\\<lambda>(F, y). ((F, Object), y)))\n           fs)\n         F =\n        \\<lfloor>(Object, T)\\<rfloor>;\n        (F, T) \\<in> set fs; D = Object\\<rbrakk>\n       \\<Longrightarrow> \\<exists>FDTs.\n                            P \\<turnstile> Object has_fields FDTs \\<and>\n                            map_of\n                             (map (\\<lambda>((F, D), T). (F, D, T)) FDTs)\n                             F =\n                            \\<lfloor>(Object, T)\\<rfloor>", "apply (fastforce intro: has_fields_Object)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsection \"Functional lookup\""], ["", "definition \"method\" :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> cname \\<times> ty list \\<times> ty \\<times> 'm\"\nwhere\n  \"method P C M  \\<equiv>  THE (D,Ts,T,m). P \\<turnstile> C sees M:Ts \\<rightarrow> T = m in D\""], ["", "definition field  :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> vname \\<Rightarrow> cname \\<times> ty\"\nwhere\n  \"field P C F  \\<equiv>  THE (D,T). P \\<turnstile> C sees F:T in D\""], ["", "definition fields :: \"'m prog \\<Rightarrow> cname \\<Rightarrow> ((vname \\<times> cname) \\<times> ty) list\" \nwhere\n  \"fields P C  \\<equiv>  THE FDTs. P \\<turnstile> C has_fields FDTs\""], ["", "lemma fields_def2 [simp]: \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow> fields P C = FDTs", "by (unfold fields_def) (auto dest: has_fields_fun)"], ["", "(*>*)"], ["", "lemma field_def2 [simp]: \"P \\<turnstile> C sees F:T in D \\<Longrightarrow> field P C F = (D,T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F:T in D \\<Longrightarrow> field P C F = (D, T)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees F:T in D \\<Longrightarrow> field P C F = (D, T)", "by (unfold field_def) (auto dest: sees_field_fun)"], ["", "(*>*)"], ["", "lemma method_def2 [simp]: \"P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow> method P C M = (D,Ts,T,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    method P C M = (D, Ts, T, m)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D \\<Longrightarrow>\n    method P C M = (D, Ts, T, m)", "by (unfold method_def) (auto dest: sees_method_fun)"], ["", "(*>*)"], ["", "subsection \"Code generator setup\""], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  subcls1p"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare subcls1_def [code_pred_def]"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<times> o \\<Rightarrow> bool, i \\<Rightarrow> i \\<times> i \\<Rightarrow> bool)\n  [inductify]\n  subcls1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition subcls' where \"subcls' G = (subcls1p G)^**\""], ["", "code_pred\n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  [inductify]\n  subcls'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma subcls_conv_subcls' [code_unfold]:\n  \"(subcls1 G)^* = {(C, D). subcls' G C D}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subcls1 G)\\<^sup>* = {(C, D). subcls' G C D}", "by (simp add: subcls'_def subcls1_def rtrancl_def)"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool)\n  widen"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  Fields"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma has_field_code [code_pred_intro]:\n  \"\\<lbrakk> P \\<turnstile> C has_fields FDTs; map_of FDTs (F, D) = \\<lfloor>T\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C has F:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     map_of FDTs (F, D) = \\<lfloor>T\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> C has F:T in D", "by(auto simp add: has_field_def)"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> i \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool)\n  has_field"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<turnstile> xa has xb:xc in xd;\n     \\<And>P C F T D FDTs.\n        \\<lbrakk>x = P; xa = C; xb = F; xc = T; xd = D;\n         P \\<turnstile> C has_fields FDTs;\n         map_of FDTs (F, D) = \\<lfloor>T\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto simp add: has_field_def)"], ["", "lemma sees_field_code [code_pred_intro]:\n  \"\\<lbrakk> P \\<turnstile> C has_fields FDTs; map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F = \\<lfloor>(D, T)\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C sees F:T in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has_fields FDTs;\n     map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n     \\<lfloor>(D, T)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> C sees F:T in D", "by(auto simp add: sees_field_def)"], ["", "code_pred \n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> i \\<Rightarrow> bool, \n          i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool, i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool)\n  sees_field"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<turnstile> xa sees xb:xc in xd;\n     \\<And>P C F T D FDTs.\n        \\<lbrakk>x = P; xa = C; xb = F; xc = T; xd = D;\n         P \\<turnstile> C has_fields FDTs;\n         map_of (map (\\<lambda>((F, D), T). (F, D, T)) FDTs) F =\n         \\<lfloor>(D, T)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto simp add: sees_field_def)"], ["", "code_pred\n  (modes: i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool)\n  Methods"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Method_code [code_pred_intro]:\n  \"\\<lbrakk> P \\<turnstile> C sees_methods Mm; Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor> \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C sees_methods Mm;\n     Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D", "by(auto simp add: Method_def)"], ["", "code_pred\n  (modes: i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> o \\<Rightarrow> bool,\n          i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool)\n  Method"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<turnstile> xa sees xb: xc\\<rightarrow>xd = xe in xf;\n     \\<And>P C M Ts T m D Mm.\n        \\<lbrakk>x = P; xa = C; xb = M; xc = Ts; xd = T; xe = m; xf = D;\n         P \\<turnstile> C sees_methods Mm;\n         Mm M = \\<lfloor>((Ts, T, m), D)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto simp add: Method_def)"], ["", "lemma eval_Method_i_i_i_o_o_o_o_conv:\n  \"Predicate.eval (Method_i_i_i_o_o_o_o P C M) = (\\<lambda>(Ts, T, m, D). P \\<turnstile> C sees M:Ts\\<rightarrow>T=m in D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (Method_i_i_i_o_o_o_o P C M) =\n    (\\<lambda>(Ts, T, m, D).\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D)", "by(auto intro: Method_i_i_i_o_o_o_oI elim: Method_i_i_i_o_o_o_oE intro!: ext)"], ["", "lemma method_code [code]:\n  \"method P C M = \n  Predicate.the (Predicate.bind (Method_i_i_i_o_o_o_o P C M) (\\<lambda>(Ts, T, m, D). Predicate.single (D, Ts, T, m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. method P C M =\n    Predicate.the\n     (Predicate.bind (Method_i_i_i_o_o_o_o P C M)\n       (\\<lambda>(Ts, T, m, D). Predicate.single (D, Ts, T, m)))", "apply (rule sym, rule the_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x.\n        pred.eval\n         (Predicate.bind (Method_i_i_i_o_o_o_o P C M)\n           (\\<lambda>(Ts, T, m, D). Predicate.single (D, Ts, T, m)))\n         x) =\n    method P C M", "apply (simp add: method_def eval_Method_i_i_i_o_o_o_o_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x.\n        \\<exists>a aa ab b.\n           P \\<turnstile> C sees M: a\\<rightarrow>aa = ab in b \\<and>\n           (b, a, aa, ab) = x) =\n    (THE (D, Ts, T, m). P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D)", "apply (rule arg_cong [where f=The])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<exists>a aa ab b.\n           P \\<turnstile> C sees M: a\\<rightarrow>aa = ab in b \\<and>\n           (b, a, aa, ab) = x) =\n    (\\<lambda>(D, Ts, T, m).\n        P \\<turnstile> C sees M: Ts\\<rightarrow>T = m in D)", "apply (auto simp add: Sup_fun_def Sup_bool_def fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eval_Fields_conv:\n  \"Predicate.eval (Fields_i_i_o P C) = (\\<lambda>FDTs. P \\<turnstile> C has_fields FDTs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (Fields_i_i_o P C) = Fields P C", "by(auto intro: Fields_i_i_oI elim: Fields_i_i_oE intro!: ext)"], ["", "lemma fields_code [code]:\n  \"fields P C = Predicate.the (Fields_i_i_o P C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fields P C = Predicate.the (Fields_i_i_o P C)", "by(simp add: fields_def Predicate.the_def eval_Fields_conv)"], ["", "lemma eval_sees_field_i_i_i_o_o_conv:\n  \"Predicate.eval (sees_field_i_i_i_o_o P C F) = (\\<lambda>(T, D). P \\<turnstile> C sees F:T in D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (sees_field_i_i_i_o_o P C F) =\n    (\\<lambda>(T, D). P \\<turnstile> C sees F:T in D)", "by(auto intro!: ext intro: sees_field_i_i_i_o_oI elim: sees_field_i_i_i_o_oE)"], ["", "lemma eval_sees_field_i_i_i_o_i_conv:\n  \"Predicate.eval (sees_field_i_i_i_o_i P C F D) = (\\<lambda>T. P \\<turnstile> C sees F:T in D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred.eval (sees_field_i_i_i_o_i P C F D) =\n    (\\<lambda>T. P \\<turnstile> C sees F:T in D)", "by(auto intro!: ext intro: sees_field_i_i_i_o_iI elim: sees_field_i_i_i_o_iE)"], ["", "lemma field_code [code]:\n  \"field P C F = Predicate.the (Predicate.bind (sees_field_i_i_i_o_o P C F) (\\<lambda>(T, D). Predicate.single (D, T)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. field P C F =\n    Predicate.the\n     (Predicate.bind (sees_field_i_i_i_o_o P C F)\n       (\\<lambda>(T, D). Predicate.single (D, T)))", "apply (rule sym, rule the_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x.\n        pred.eval\n         (Predicate.bind (sees_field_i_i_i_o_o P C F)\n           (\\<lambda>(T, D). Predicate.single (D, T)))\n         x) =\n    field P C F", "apply (simp add: field_def eval_sees_field_i_i_i_o_o_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x.\n        \\<exists>a b. P \\<turnstile> C sees F:a in b \\<and> (b, a) = x) =\n    (THE (D, T). P \\<turnstile> C sees F:T in D)", "apply (rule arg_cong [where f=The])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<exists>a b. P \\<turnstile> C sees F:a in b \\<and> (b, a) = x) =\n    (\\<lambda>(D, T). P \\<turnstile> C sees F:T in D)", "apply (auto simp add: Sup_fun_def Sup_bool_def fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}