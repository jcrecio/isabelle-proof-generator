{"file_name": "/home/qj213/afp-2021-10-22/thys/Jinja/JVM/JVMExec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jinja", "problem_names": ["lemma exec_1_eq:\n  \"exec_1 P = {(\\<sigma>,\\<sigma>'). exec (P,\\<sigma>) = Some \\<sigma>'}\"", "lemma exec_1_iff:\n  \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' = (exec (P,\\<sigma>) = Some \\<sigma>')\"", "lemma exec_all_def:\n  \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' = ((\\<sigma>,\\<sigma>') \\<in> {(\\<sigma>,\\<sigma>'). exec (P,\\<sigma>) = Some \\<sigma>'}\\<^sup>*)\"", "lemma jvm_refl[iff]: \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>\"", "lemma jvm_trans[trans]:\n \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'; P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>'' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\"", "lemma jvm_one_step1[trans]:\n \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'; P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>'' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\"", "lemma jvm_one_step2[trans]:\n \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'; P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\"", "lemma exec_all_conf:\n  \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'; P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'' \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>'' \\<or> P \\<turnstile> \\<sigma>'' -jvm\\<rightarrow> \\<sigma>'\"", "lemma exec_all_finalD: \"P \\<turnstile> (x, h, []) -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow> \\<sigma> = (x, h, [])\"", "lemma exec_all_deterministic:\n  \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> (x,h,[]); P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> (x,h,[])\""], "translations": [["", "lemma exec_1_eq:\n  \"exec_1 P = {(\\<sigma>,\\<sigma>'). exec (P,\\<sigma>) = Some \\<sigma>'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_1 P =\n    {(\\<sigma>, \\<sigma>').\n     exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_1 P =\n    {(\\<sigma>, \\<sigma>').\n     exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}", "by (auto intro: exec_1I elim: exec_1.cases)"], ["", "(*>*)"], ["", "lemma exec_1_iff:\n  \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' = (exec (P,\\<sigma>) = Some \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' =\n    (exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>' =\n    (exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>)", "by (simp add: exec_1_eq)"], ["", "(*>*)"], ["", "lemma exec_all_def:\n  \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' = ((\\<sigma>,\\<sigma>') \\<in> {(\\<sigma>,\\<sigma>'). exec (P,\\<sigma>) = Some \\<sigma>'}\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' =\n    ((\\<sigma>, \\<sigma>')\n     \\<in> {(\\<sigma>, \\<sigma>').\n            exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>*)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' =\n    ((\\<sigma>, \\<sigma>')\n     \\<in> {(\\<sigma>, \\<sigma>').\n            exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>*)", "by (simp add: exec_all_def1 exec_1_eq)"], ["", "(*>*)"], ["", "lemma jvm_refl[iff]: \"P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>", "by(simp add: exec_all_def)"], ["", "(*>*)"], ["", "lemma jvm_trans[trans]:\n \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'; P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>'' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''", "by(simp add: exec_all_def)"], ["", "(*>*)"], ["", "lemma jvm_one_step1[trans]:\n \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'; P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>'' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>';\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow>\\<^sub>1 \\<sigma>';\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''", "by (simp add: exec_all_def1)"], ["", "(*>*)"], ["", "lemma jvm_one_step2[trans]:\n \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'; P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\\<^sub>1 \\<sigma>'' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\\<^sub>1 \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\\<^sub>1 \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''", "by (simp add: exec_all_def1)"], ["", "(*>*)"], ["", "lemma exec_all_conf:\n  \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'; P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'' \\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> \\<sigma>'' \\<or> P \\<turnstile> \\<sigma>'' -jvm\\<rightarrow> \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\n                      \\<sigma>'' \\<or>\n                      P \\<turnstile> \\<sigma>'' -jvm\\<rightarrow> \\<sigma>'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>''\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow>\n                      \\<sigma>'' \\<or>\n                      P \\<turnstile> \\<sigma>'' -jvm\\<rightarrow> \\<sigma>'", "by(simp add: exec_all_def single_valued_def single_valued_confluent)"], ["", "(*>*)"], ["", "lemma exec_all_finalD: \"P \\<turnstile> (x, h, []) -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow> \\<sigma> = (x, h, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (x, h, []) -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow>\n    \\<sigma> = (x, h, [])", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (x, h, []) -jvm\\<rightarrow> \\<sigma> \\<Longrightarrow>\n    \\<sigma> = (x, h, [])", "apply(simp only: exec_all_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, h, []), \\<sigma>)\n    \\<in> {(\\<sigma>, \\<sigma>').\n           exec (P, \\<sigma>) =\n           \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>* \\<Longrightarrow>\n    \\<sigma> = (x, h, [])", "apply(erule converse_rtranclE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x, h, []) = \\<sigma> \\<Longrightarrow> \\<sigma> = (x, h, [])\n 2. \\<And>y.\n       \\<lbrakk>((x, h, []), y)\n                \\<in> {(\\<sigma>, \\<sigma>').\n                       exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>};\n        (y, \\<sigma>)\n        \\<in> {(\\<sigma>, \\<sigma>').\n               exec (P, \\<sigma>) =\n               \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = (x, h, [])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>((x, h, []), y)\n                \\<in> {(\\<sigma>, \\<sigma>').\n                       exec (P, \\<sigma>) = \\<lfloor>\\<sigma>'\\<rfloor>};\n        (y, \\<sigma>)\n        \\<in> {(\\<sigma>, \\<sigma>').\n               exec (P, \\<sigma>) =\n               \\<lfloor>\\<sigma>'\\<rfloor>}\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = (x, h, [])", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma exec_all_deterministic:\n  \"\\<lbrakk> P \\<turnstile> \\<sigma> -jvm\\<rightarrow> (x,h,[]); P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>' \\<rbrakk> \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> (x,h,[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> (x, h, []);\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> (x, h, [])", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> (x, h, []);\n     P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> (x, h, [])", "apply(drule (1) exec_all_conf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> \\<sigma> -jvm\\<rightarrow> \\<sigma>';\n     P \\<turnstile> (x, h, []) -jvm\\<rightarrow> \\<sigma>' \\<or>\n     P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> (x, h, [])\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> \\<sigma>' -jvm\\<rightarrow> (x, h, [])", "apply(blast dest!: exec_all_finalD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text \\<open>\n  The start configuration of the JVM: in the start heap, we call a \n  method \\<open>m\\<close> of class \\<open>C\\<close> in program \\<open>P\\<close>. The \n  \\<open>this\\<close> pointer of the frame is set to \\<open>Null\\<close> to simulate\n  a static method invokation.\n\\<close>"], ["", "definition start_state :: \"jvm_prog \\<Rightarrow> cname \\<Rightarrow> mname \\<Rightarrow> jvm_state\" where\n  \"start_state P C M =\n  (let (D,Ts,T,mxs,mxl\\<^sub>0,b) = method P C M in\n    (None, start_heap P, [([], Null # replicate mxl\\<^sub>0 undefined, C, M, 0)]))\""], ["", "end"]]}