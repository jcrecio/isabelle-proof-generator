{"file_name": "/home/qj213/afp-2021-10-22/thys/Jinja/BV/SemiType.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jinja", "problem_names": ["lemma superI:\n  \"(C,D) \\<in> subcls1 P \\<Longrightarrow> super P C = D\"", "lemma sup_def':\n  \"sup P = (\\<lambda>T\\<^sub>1 T\\<^sub>2.\n  if is_refT T\\<^sub>1 \\<and> is_refT T\\<^sub>2 then \n  OK (if T\\<^sub>1 = NT then T\\<^sub>2 else\n      if T\\<^sub>2 = NT then T\\<^sub>1 else\n      (Class (exec_lub (subcls1 P) (super P) (the_Class T\\<^sub>1) (the_Class T\\<^sub>2))))\n  else \n  (if T\\<^sub>1 = T\\<^sub>2 then OK T\\<^sub>1 else Err))\"", "lemma is_class_is_subcls:\n  \"wf_prog m P \\<Longrightarrow> is_class P C = P \\<turnstile> C \\<preceq>\\<^sup>* Object\"", "lemma subcls_antisym:\n  \"\\<lbrakk>wf_prog m P; P \\<turnstile> C \\<preceq>\\<^sup>* D; P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk> \\<Longrightarrow> C = D\"", "lemma widen_antisym:\n  \"\\<lbrakk> wf_prog m P; P \\<turnstile> T \\<le> U; P \\<turnstile> U \\<le> T \\<rbrakk> \\<Longrightarrow> T = U\"", "lemma order_widen [intro,simp]: \n  \"wf_prog m P \\<Longrightarrow> order (subtype P)\"", "lemma NT_widen:\n  \"P \\<turnstile> NT \\<le> T = (T = NT \\<or> (\\<exists>C. T = Class C))\"", "lemma Class_widen2: \"P \\<turnstile> Class C \\<le> T = (\\<exists>D. T = Class D \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* D)\"", "lemma wf_converse_subcls1_impl_acc_subtype:\n  \"wf ((subcls1 P)^-1) \\<Longrightarrow> acc (subtype P)\"", "lemma wf_subtype_acc [intro, simp]:\n  \"wf_prog wf_mb P \\<Longrightarrow> acc (subtype P)\"", "lemma exec_lub_refl [simp]: \"exec_lub r f T T = T\"", "lemma closed_err_types:\n  \"wf_prog wf_mb P \\<Longrightarrow> closed (err (types P)) (lift2 (sup P))\"", "lemma sup_subtype_greater:\n  \"\\<lbrakk> wf_prog wf_mb P; is_type P t1; is_type P t2; sup P t1 t2 = OK s \\<rbrakk> \n  \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s\"", "lemma sup_subtype_smallest:\n  \"\\<lbrakk> wf_prog wf_mb P; is_type P a; is_type P b; is_type P c; \n      subtype P a c; subtype P b c; sup P a b = OK d \\<rbrakk>\n  \\<Longrightarrow> subtype P d c\"", "lemma sup_exists:\n  \"\\<lbrakk> subtype P a c; subtype P b c \\<rbrakk> \\<Longrightarrow> \\<exists>T. sup P a b = OK T\"", "lemma err_semilat_JType_esl:\n  \"wf_prog wf_mb P \\<Longrightarrow> err_semilat (esl P)\""], "translations": [["", "lemma superI:\n  \"(C,D) \\<in> subcls1 P \\<Longrightarrow> super P C = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<prec>\\<^sup>1 D \\<Longrightarrow> super P C = D", "by (unfold super_def) (auto dest: subcls1D)"], ["", "primrec the_Class :: \"ty \\<Rightarrow> cname\"\nwhere\n  \"the_Class (Class C) = C\""], ["", "definition sup :: \"'c prog \\<Rightarrow> ty \\<Rightarrow> ty \\<Rightarrow> ty err\"\nwhere\n  \"sup P T\\<^sub>1 T\\<^sub>2 \\<equiv>\n  if is_refT T\\<^sub>1 \\<and> is_refT T\\<^sub>2 then \n  OK (if T\\<^sub>1 = NT then T\\<^sub>2 else\n      if T\\<^sub>2 = NT then T\\<^sub>1 else\n      (Class (exec_lub (subcls1 P) (super P) (the_Class T\\<^sub>1) (the_Class T\\<^sub>2))))\n  else \n  (if T\\<^sub>1 = T\\<^sub>2 then OK T\\<^sub>1 else Err)\""], ["", "lemma sup_def':\n  \"sup P = (\\<lambda>T\\<^sub>1 T\\<^sub>2.\n  if is_refT T\\<^sub>1 \\<and> is_refT T\\<^sub>2 then \n  OK (if T\\<^sub>1 = NT then T\\<^sub>2 else\n      if T\\<^sub>2 = NT then T\\<^sub>1 else\n      (Class (exec_lub (subcls1 P) (super P) (the_Class T\\<^sub>1) (the_Class T\\<^sub>2))))\n  else \n  (if T\\<^sub>1 = T\\<^sub>2 then OK T\\<^sub>1 else Err))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SemiType.sup P =\n    (\\<lambda>T\\<^sub>1 T\\<^sub>2.\n        if is_refT T\\<^sub>1 \\<and> is_refT T\\<^sub>2\n        then OK (if T\\<^sub>1 = NT then T\\<^sub>2\n                 else if T\\<^sub>2 = NT then T\\<^sub>1\n                      else Class\n                            (exec_lub (subcls1 P) (super P)\n                              (the_Class T\\<^sub>1) (the_Class T\\<^sub>2)))\n        else if T\\<^sub>1 = T\\<^sub>2 then OK T\\<^sub>1 else Err)", "by (simp add: sup_def fun_eq_iff)"], ["", "abbreviation\n  subtype :: \"'c prog \\<Rightarrow> ty \\<Rightarrow> ty \\<Rightarrow> bool\"\n  where \"subtype P \\<equiv> widen P\""], ["", "definition esl :: \"'c prog \\<Rightarrow> ty esl\"\nwhere\n  \"esl P \\<equiv> (types P, subtype P, sup P)\""], ["", "(* FIXME: move to wellform *)"], ["", "lemma is_class_is_subcls:\n  \"wf_prog m P \\<Longrightarrow> is_class P C = P \\<turnstile> C \\<preceq>\\<^sup>* Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog m P \\<Longrightarrow>\n    is_class P C = P \\<turnstile> C \\<preceq>\\<^sup>* Object", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog m P \\<Longrightarrow>\n    is_class P C = P \\<turnstile> C \\<preceq>\\<^sup>* Object", "by (fastforce simp:is_class_def\n                  elim: subcls_C_Object converse_rtranclE subcls1I\n                  dest: subcls1D)"], ["", "(*>*)\n\n\n(* FIXME: move to wellform *)"], ["", "lemma subcls_antisym:\n  \"\\<lbrakk>wf_prog m P; P \\<turnstile> C \\<preceq>\\<^sup>* D; P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk> \\<Longrightarrow> C = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog m P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n    \\<Longrightarrow> C = D", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog m P; P \\<turnstile> C \\<preceq>\\<^sup>* D;\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n    \\<Longrightarrow> C = D", "by (auto dest: acyclic_subcls1 acyclic_impl_antisym_rtrancl antisymD)"], ["", "(*>*)\n\n(* FIXME: move to wellform *)"], ["", "lemma widen_antisym:\n  \"\\<lbrakk> wf_prog m P; P \\<turnstile> T \\<le> U; P \\<turnstile> U \\<le> T \\<rbrakk> \\<Longrightarrow> T = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T\\<rbrakk>\n    \\<Longrightarrow> T = U", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T\\<rbrakk>\n    \\<Longrightarrow> T = U", "apply (cases T)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T; T = Void\\<rbrakk>\n    \\<Longrightarrow> T = U\n 2. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T; T = Boolean\\<rbrakk>\n    \\<Longrightarrow> T = U\n 3. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T; T = Integer\\<rbrakk>\n    \\<Longrightarrow> T = U\n 4. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T; T = NT\\<rbrakk>\n    \\<Longrightarrow> T = U\n 5. \\<And>x5.\n       \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T;\n        T = Class x5\\<rbrakk>\n       \\<Longrightarrow> T = U", "apply (cases U)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T; T = Void;\n     U = Void\\<rbrakk>\n    \\<Longrightarrow> T = U\n 2. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T; T = Void;\n     U = Boolean\\<rbrakk>\n    \\<Longrightarrow> T = U\n 3. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T; T = Void;\n     U = Integer\\<rbrakk>\n    \\<Longrightarrow> T = U\n 4. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T; T = Void;\n     U = NT\\<rbrakk>\n    \\<Longrightarrow> T = U\n 5. \\<And>x5.\n       \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T; T = Void;\n        U = Class x5\\<rbrakk>\n       \\<Longrightarrow> T = U\n 6. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T; T = Boolean\\<rbrakk>\n    \\<Longrightarrow> T = U\n 7. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T; T = Integer\\<rbrakk>\n    \\<Longrightarrow> T = U\n 8. \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T; T = NT\\<rbrakk>\n    \\<Longrightarrow> T = U\n 9. \\<And>x5.\n       \\<lbrakk>wf_prog m P; subtype P T U; subtype P U T;\n        T = Class x5\\<rbrakk>\n       \\<Longrightarrow> T = U", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x5.\n       \\<lbrakk>wf_prog m P; subtype P (Class x5) U; subtype P U (Class x5);\n        T = Class x5\\<rbrakk>\n       \\<Longrightarrow> Class x5 = U", "apply (cases U)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x5.\n       \\<lbrakk>wf_prog m P; subtype P (Class x5) U; subtype P U (Class x5);\n        T = Class x5; U = Void\\<rbrakk>\n       \\<Longrightarrow> Class x5 = U\n 2. \\<And>x5.\n       \\<lbrakk>wf_prog m P; subtype P (Class x5) U; subtype P U (Class x5);\n        T = Class x5; U = Boolean\\<rbrakk>\n       \\<Longrightarrow> Class x5 = U\n 3. \\<And>x5.\n       \\<lbrakk>wf_prog m P; subtype P (Class x5) U; subtype P U (Class x5);\n        T = Class x5; U = Integer\\<rbrakk>\n       \\<Longrightarrow> Class x5 = U\n 4. \\<And>x5.\n       \\<lbrakk>wf_prog m P; subtype P (Class x5) U; subtype P U (Class x5);\n        T = Class x5; U = NT\\<rbrakk>\n       \\<Longrightarrow> Class x5 = U\n 5. \\<And>x5 x5a.\n       \\<lbrakk>wf_prog m P; subtype P (Class x5) U; subtype P U (Class x5);\n        T = Class x5; U = Class x5a\\<rbrakk>\n       \\<Longrightarrow> Class x5 = U", "apply (auto elim!: subcls_antisym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma order_widen [intro,simp]: \n  \"wf_prog m P \\<Longrightarrow> order (subtype P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog m P \\<Longrightarrow> order (subtype P)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog m P \\<Longrightarrow> order (subtype P)", "apply (unfold Semilat.order_def lesub_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog m P \\<Longrightarrow>\n    (\\<forall>x. subtype P x x) \\<and>\n    (\\<forall>x y.\n        subtype P x y \\<and> subtype P y x \\<longrightarrow> x = y) \\<and>\n    (\\<forall>x y z.\n        subtype P x y \\<and> subtype P y z \\<longrightarrow> subtype P x z)", "apply (auto intro: widen_trans widen_antisym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(* FIXME: move to TypeRel *)"], ["", "lemma NT_widen:\n  \"P \\<turnstile> NT \\<le> T = (T = NT \\<or> (\\<exists>C. T = Class C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtype P NT T = (T = NT \\<or> (\\<exists>C. T = Class C))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subtype P NT T = (T = NT \\<or> (\\<exists>C. T = Class C))", "by (cases T) auto"], ["", "(*>*)\n\n(* FIXME: move to TypeRel *)"], ["", "lemma Class_widen2: \"P \\<turnstile> Class C \\<le> T = (\\<exists>D. T = Class D \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtype P (Class C) T =\n    (\\<exists>D. T = Class D \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* D)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subtype P (Class C) T =\n    (\\<exists>D. T = Class D \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* D)", "by (cases T) auto"], ["", "(*>*)"], ["", "lemma wf_converse_subcls1_impl_acc_subtype:\n  \"wf ((subcls1 P)^-1) \\<Longrightarrow> acc (subtype P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf ((subcls1 P)\\<inverse>) \\<Longrightarrow> acc (subtype P)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf ((subcls1 P)\\<inverse>) \\<Longrightarrow> acc (subtype P)", "apply (unfold Semilat.acc_def lesssub_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf ((subcls1 P)\\<inverse>) \\<Longrightarrow>\n    wf {(y, x).\n        x \\<sqsubseteq>\\<^bsub>subtype P\\<^esub> y \\<and> x \\<noteq> y}", "apply (drule_tac p = \"(subcls1 P)^-1 - Id\" in wf_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (subcls1 P)\\<inverse> - Id \\<subseteq> (subcls1 P)\\<inverse>\n 2. wf ((subcls1 P)\\<inverse> - Id) \\<Longrightarrow>\n    wf {(y, x).\n        x \\<sqsubseteq>\\<^bsub>subtype P\\<^esub> y \\<and> x \\<noteq> y}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf ((subcls1 P)\\<inverse> - Id) \\<Longrightarrow>\n    wf {(y, x).\n        x \\<sqsubseteq>\\<^bsub>subtype P\\<^esub> y \\<and> x \\<noteq> y}", "apply (drule wf_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (((subcls1 P)\\<inverse> - Id)\\<^sup>+) \\<Longrightarrow>\n    wf {(y, x).\n        x \\<sqsubseteq>\\<^bsub>subtype P\\<^esub> y \\<and> x \\<noteq> y}", "apply (simp add: wf_eq_minimal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q.\n       (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n              y \\<notin> Q) \\<Longrightarrow>\n    \\<forall>Q.\n       (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              z \\<sqsubseteq>\\<^bsub>subtype P\\<^esub> y \\<and>\n              z \\<noteq> y \\<longrightarrow>\n              y \\<notin> Q)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               z \\<sqsubseteq>\\<^bsub>subtype\n                 P\\<^esub> y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> Q", "apply (unfold lesub_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>Q.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> Q", "apply (rename_tac M T)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply (case_tac \"\\<exists>C. Class C \\<in> M\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 2. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 2. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply (case_tac T)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Void\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 2. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Boolean\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 3. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Integer\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 4. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = NT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 5. \\<And>M T x5.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Class x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 6. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Boolean\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 2. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Integer\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 3. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = NT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 4. \\<And>M T x5.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Class x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 5. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply fastforce"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Integer\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 2. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = NT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 3. \\<And>M T x5.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Class x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 4. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = NT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 2. \\<And>M T x5.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Class x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 3. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        NT \\<in> M; \\<forall>C. Class C \\<notin> M; T = NT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 2. \\<And>M T x5.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Class x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 3. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply (rule_tac x = NT in bexI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        NT \\<in> M; \\<forall>C. Class C \\<notin> M; T = NT\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y.\n                            subtype P NT y \\<and>\n                            NT \\<noteq> y \\<longrightarrow>\n                            y \\<notin> M\n 2. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        NT \\<in> M; \\<forall>C. Class C \\<notin> M; T = NT\\<rbrakk>\n       \\<Longrightarrow> NT \\<in> M\n 3. \\<And>M T x5.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Class x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 4. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply (rule allI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>M T y.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        NT \\<in> M; \\<forall>C. Class C \\<notin> M; T = NT\\<rbrakk>\n       \\<Longrightarrow> subtype P NT y \\<and>\n                         NT \\<noteq> y \\<longrightarrow>\n                         y \\<notin> M\n 2. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        NT \\<in> M; \\<forall>C. Class C \\<notin> M; T = NT\\<rbrakk>\n       \\<Longrightarrow> NT \\<in> M\n 3. \\<And>M T x5.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Class x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 4. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply (rule impI, erule conjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>M T y.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        NT \\<in> M; \\<forall>C. Class C \\<notin> M; T = NT; subtype P NT y;\n        NT \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> y \\<notin> M\n 2. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        NT \\<in> M; \\<forall>C. Class C \\<notin> M; T = NT\\<rbrakk>\n       \\<Longrightarrow> NT \\<in> M\n 3. \\<And>M T x5.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Class x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 4. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply (clarsimp simp add: NT_widen)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        NT \\<in> M; \\<forall>C. Class C \\<notin> M; T = NT\\<rbrakk>\n       \\<Longrightarrow> NT \\<in> M\n 2. \\<And>M T x5.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Class x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 3. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M T x5.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<nexists>C. Class C \\<in> M; T = Class x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M\n 2. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          (y, z)\n                          \\<in> ((subcls1 P)\\<inverse> -\n                                 Id)\\<^sup>+ \\<longrightarrow>\n                          y \\<notin> Q);\n        T \\<in> M; \\<exists>C. Class C \\<in> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply (erule_tac x = \"{C. Class C : M}\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T.\n       \\<lbrakk>T \\<in> M; \\<exists>C. Class C \\<in> M;\n        (\\<exists>x. x \\<in> {C. Class C \\<in> M}) \\<longrightarrow>\n        (\\<exists>z\\<in>{C. Class C \\<in> M}.\n            \\<forall>y.\n               (y, z)\n               \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n               y \\<notin> {C. Class C \\<in> M})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T C z.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class z \\<in> M;\n        \\<forall>y.\n           (y, z)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply (rename_tac D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T C D.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<in>M.\n                            \\<forall>y.\n                               subtype P z y \\<and>\n                               z \\<noteq> y \\<longrightarrow>\n                               y \\<notin> M", "apply (rule_tac x = \"Class D\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M T C D.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y.\n                            subtype P (Class D) y \\<and>\n                            Class D \\<noteq> y \\<longrightarrow>\n                            y \\<notin> M\n 2. \\<And>M T C D.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M\\<rbrakk>\n       \\<Longrightarrow> Class D \\<in> M", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M T C D.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M\\<rbrakk>\n       \\<Longrightarrow> Class D \\<in> M\n 2. \\<And>M T C D.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y.\n                            subtype P (Class D) y \\<and>\n                            Class D \\<noteq> y \\<longrightarrow>\n                            y \\<notin> M", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T C D.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y.\n                            subtype P (Class D) y \\<and>\n                            Class D \\<noteq> y \\<longrightarrow>\n                            y \\<notin> M", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T C D y.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        subtype P (Class D) y; Class D \\<noteq> y; y \\<in> M\\<rbrakk>\n       \\<Longrightarrow> False", "apply (clarsimp simp: Class_widen2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T C D Da.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; P \\<turnstile> D \\<preceq>\\<^sup>* Da\\<rbrakk>\n       \\<Longrightarrow> D = Da", "apply (insert rtrancl_r_diff_Id [symmetric, of \"subcls1 P\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T C D Da.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; P \\<turnstile> D \\<preceq>\\<^sup>* Da;\n        (subcls1 P)\\<^sup>* = (subcls1 P - Id)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> D = Da", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T C D Da.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; (D, Da) \\<in> (subcls1 P - Id)\\<^sup>*;\n        (subcls1 P)\\<^sup>* = (subcls1 P - Id)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> D = Da", "apply (erule rtranclE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M T C D Da.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; (subcls1 P)\\<^sup>* = (subcls1 P - Id)\\<^sup>*;\n        D = Da\\<rbrakk>\n       \\<Longrightarrow> D = Da\n 2. \\<And>M T C D Da y.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; (subcls1 P)\\<^sup>* = (subcls1 P - Id)\\<^sup>*;\n        (D, y) \\<in> (subcls1 P - Id)\\<^sup>*;\n        (y, Da) \\<in> subcls1 P - Id\\<rbrakk>\n       \\<Longrightarrow> D = Da", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T C D Da y.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; (subcls1 P)\\<^sup>* = (subcls1 P - Id)\\<^sup>*;\n        (D, y) \\<in> (subcls1 P - Id)\\<^sup>*;\n        (y, Da) \\<in> subcls1 P - Id\\<rbrakk>\n       \\<Longrightarrow> D = Da", "apply (drule rtrancl_converseI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T C D Da y.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; (subcls1 P)\\<^sup>* = (subcls1 P - Id)\\<^sup>*;\n        (y, Da) \\<in> subcls1 P - Id;\n        (y, D) \\<in> ((subcls1 P - Id)\\<inverse>)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> D = Da", "apply (subgoal_tac \"((subcls1 P)-Id)^-1 = ((subcls1 P)^-1 - Id)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M T C D Da y.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; (subcls1 P)\\<^sup>* = (subcls1 P - Id)\\<^sup>*;\n        (y, Da) \\<in> subcls1 P - Id;\n        (y, D) \\<in> ((subcls1 P - Id)\\<inverse>)\\<^sup>*;\n        (subcls1 P - Id)\\<inverse> = (subcls1 P)\\<inverse> - Id\\<rbrakk>\n       \\<Longrightarrow> D = Da\n 2. \\<And>M T C D Da y.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; (subcls1 P)\\<^sup>* = (subcls1 P - Id)\\<^sup>*;\n        (y, Da) \\<in> subcls1 P - Id;\n        (y, D) \\<in> ((subcls1 P - Id)\\<inverse>)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (subcls1 P - Id)\\<inverse> =\n                         (subcls1 P)\\<inverse> - Id", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M T C D Da y.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; (subcls1 P)\\<^sup>* = (subcls1 P - Id)\\<^sup>*;\n        (y, Da) \\<in> subcls1 P - Id;\n        (y, D) \\<in> ((subcls1 P - Id)\\<inverse>)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (subcls1 P - Id)\\<inverse> =\n                         (subcls1 P)\\<inverse> - Id\n 2. \\<And>M T C D Da y.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; (subcls1 P)\\<^sup>* = (subcls1 P - Id)\\<^sup>*;\n        (y, Da) \\<in> subcls1 P - Id;\n        (y, D) \\<in> ((subcls1 P - Id)\\<inverse>)\\<^sup>*;\n        (subcls1 P - Id)\\<inverse> = (subcls1 P)\\<inverse> - Id\\<rbrakk>\n       \\<Longrightarrow> D = Da", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T C D Da y.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; (subcls1 P)\\<^sup>* = (subcls1 P - Id)\\<^sup>*;\n        (y, Da) \\<in> subcls1 P - Id;\n        (y, D) \\<in> ((subcls1 P - Id)\\<inverse>)\\<^sup>*;\n        (subcls1 P - Id)\\<inverse> = (subcls1 P)\\<inverse> - Id\\<rbrakk>\n       \\<Longrightarrow> D = Da", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M T C D Da y.\n       \\<lbrakk>T \\<in> M; Class C \\<in> M; Class D \\<in> M;\n        \\<forall>y.\n           (y, D)\n           \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>+ \\<longrightarrow>\n           Class y \\<notin> M;\n        Class Da \\<in> M; (subcls1 P)\\<^sup>* = (subcls1 P - Id)\\<^sup>*;\n        P \\<turnstile> y \\<prec>\\<^sup>1 Da \\<and> y \\<noteq> Da;\n        (y, D) \\<in> ((subcls1 P)\\<inverse> - Id)\\<^sup>*;\n        (subcls1 P - Id)\\<inverse> = (subcls1 P)\\<inverse> - Id\\<rbrakk>\n       \\<Longrightarrow> D = Da", "apply (blast intro: rtrancl_into_trancl2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma wf_subtype_acc [intro, simp]:\n  \"wf_prog wf_mb P \\<Longrightarrow> acc (subtype P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> acc (subtype P)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> acc (subtype P)", "by (rule wf_converse_subcls1_impl_acc_subtype, rule wf_subcls1)"], ["", "(*>*)"], ["", "lemma exec_lub_refl [simp]: \"exec_lub r f T T = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_lub r f T T = T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_lub r f T T = T", "by (simp add: exec_lub_def while_unfold)"], ["", "(*>*)"], ["", "lemma closed_err_types:\n  \"wf_prog wf_mb P \\<Longrightarrow> closed (err (types P)) (lift2 (sup P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow>\n    closed (err (types P)) (lift2 (SemiType.sup P))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow>\n    closed (err (types P)) (lift2 (SemiType.sup P))", "apply (unfold closed_def plussub_def lift2_def sup_def')"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow>\n    \\<forall>x\\<in>err (types P).\n       \\<forall>y\\<in>err (types P).\n          (case x of Err \\<Rightarrow> Err\n           | OK x \\<Rightarrow>\n               case y of Err \\<Rightarrow> Err\n               | OK T\\<^sub>2 \\<Rightarrow>\n                   if is_refT x \\<and> is_refT T\\<^sub>2\n                   then OK (if x = NT then T\\<^sub>2\n                            else if T\\<^sub>2 = NT then x\n                                 else Class\n (exec_lub (subcls1 P) (super P) (the_Class x) (the_Class T\\<^sub>2)))\n                   else if x = T\\<^sub>2 then OK x else Err)\n          \\<in> err (types P)", "apply (frule acyclic_subcls1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; acyclic (subcls1 P)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>err (types P).\n                         \\<forall>y\\<in>err (types P).\n                            (case x of Err \\<Rightarrow> Err\n                             | OK x \\<Rightarrow>\n                                 case y of Err \\<Rightarrow> Err\n                                 | OK T\\<^sub>2 \\<Rightarrow>\n                                     if is_refT x \\<and> is_refT T\\<^sub>2\n                                     then OK\n     (if x = NT then T\\<^sub>2\n      else if T\\<^sub>2 = NT then x\n           else Class\n                 (exec_lub (subcls1 P) (super P) (the_Class x)\n                   (the_Class T\\<^sub>2)))\n                                     else if x = T\\<^sub>2 then OK x\n    else Err)\n                            \\<in> err (types P)", "apply (frule single_valued_subcls1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; acyclic (subcls1 P);\n     single_valued (subcls1 P)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>err (types P).\n                         \\<forall>y\\<in>err (types P).\n                            (case x of Err \\<Rightarrow> Err\n                             | OK x \\<Rightarrow>\n                                 case y of Err \\<Rightarrow> Err\n                                 | OK T\\<^sub>2 \\<Rightarrow>\n                                     if is_refT x \\<and> is_refT T\\<^sub>2\n                                     then OK\n     (if x = NT then T\\<^sub>2\n      else if T\\<^sub>2 = NT then x\n           else Class\n                 (exec_lub (subcls1 P) (super P) (the_Class x)\n                   (the_Class T\\<^sub>2)))\n                                     else if x = T\\<^sub>2 then OK x\n    else Err)\n                            \\<in> err (types P)", "apply (auto simp: is_type_def is_refT_def is_class_is_subcls split: err.split ty.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x5 x5a.\n       \\<lbrakk>wf_prog wf_mb P; acyclic (subcls1 P);\n        single_valued (subcls1 P); x5 \\<noteq> x5a;\n        P \\<turnstile> x5a \\<preceq>\\<^sup>* Object;\n        P \\<turnstile> x5 \\<preceq>\\<^sup>* Object\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> exec_lub (subcls1 P) (super P) x5\n   x5a \\<preceq>\\<^sup>* Object", "apply (blast dest!: is_lub_exec_lub is_lubD is_ubD intro!: is_ubI superI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sup_subtype_greater:\n  \"\\<lbrakk> wf_prog wf_mb P; is_type P t1; is_type P t2; sup P t1 t2 = OK s \\<rbrakk> \n  \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "assume wf_prog: \"wf_prog wf_mb P\""], ["proof (state)\nthis:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "{"], ["proof (state)\nthis:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "fix c1 c2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "assume is_class: \"is_class P c1\" \"is_class P c2\""], ["proof (state)\nthis:\n  is_class P c1\n  is_class P c2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "with wf_prog"], ["proof (chain)\npicking this:\n  wf_prog wf_mb P\n  is_class P c1\n  is_class P c2", "obtain \n      \"P \\<turnstile> c1 \\<preceq>\\<^sup>* Object\"\n      \"P \\<turnstile> c2 \\<preceq>\\<^sup>* Object\""], ["proof (prove)\nusing this:\n  wf_prog wf_mb P\n  is_class P c1\n  is_class P c2\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P \\<turnstile> c1 \\<preceq>\\<^sup>* Object;\n      P \\<turnstile> c2 \\<preceq>\\<^sup>* Object\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast intro: subcls_C_Object)"], ["proof (state)\nthis:\n  P \\<turnstile> c1 \\<preceq>\\<^sup>* Object\n  P \\<turnstile> c2 \\<preceq>\\<^sup>* Object\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "with single_valued_subcls1[OF wf_prog]"], ["proof (chain)\npicking this:\n  single_valued (subcls1 P)\n  P \\<turnstile> c1 \\<preceq>\\<^sup>* Object\n  P \\<turnstile> c2 \\<preceq>\\<^sup>* Object", "obtain u where\n      \"is_lub ((subcls1 P)^* ) c1 c2 u\""], ["proof (prove)\nusing this:\n  single_valued (subcls1 P)\n  P \\<turnstile> c1 \\<preceq>\\<^sup>* Object\n  P \\<turnstile> c2 \\<preceq>\\<^sup>* Object\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        is_lub ((subcls1 P)\\<^sup>*) c1 c2 u \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: single_valued_has_lubs)"], ["proof (state)\nthis:\n  is_lub ((subcls1 P)\\<^sup>*) c1 c2 u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "moreover"], ["proof (state)\nthis:\n  is_lub ((subcls1 P)\\<^sup>*) c1 c2 u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "note acyclic_subcls1[OF wf_prog]"], ["proof (state)\nthis:\n  acyclic (subcls1 P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "moreover"], ["proof (state)\nthis:\n  acyclic (subcls1 P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "have \"\\<forall>x y. (x, y) \\<in> subcls1 P \\<longrightarrow> super P x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       P \\<turnstile> x \\<prec>\\<^sup>1 y \\<longrightarrow> super P x = y", "by (blast intro: superI)"], ["proof (state)\nthis:\n  \\<forall>x y.\n     P \\<turnstile> x \\<prec>\\<^sup>1 y \\<longrightarrow> super P x = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "ultimately"], ["proof (chain)\npicking this:\n  is_lub ((subcls1 P)\\<^sup>*) c1 c2 u\n  acyclic (subcls1 P)\n  \\<forall>x y.\n     P \\<turnstile> x \\<prec>\\<^sup>1 y \\<longrightarrow> super P x = y", "have \"P \\<turnstile> c1 \\<preceq>\\<^sup>* exec_lub (subcls1 P) (super P) c1 c2 \\<and>\n          P \\<turnstile> c2 \\<preceq>\\<^sup>* exec_lub (subcls1 P) (super P) c1 c2\""], ["proof (prove)\nusing this:\n  is_lub ((subcls1 P)\\<^sup>*) c1 c2 u\n  acyclic (subcls1 P)\n  \\<forall>x y.\n     P \\<turnstile> x \\<prec>\\<^sup>1 y \\<longrightarrow> super P x = y\n\ngoal (1 subgoal):\n 1. P \\<turnstile> c1 \\<preceq>\\<^sup>* exec_lub (subcls1 P) (super P) c1\n   c2 \\<and>\n    P \\<turnstile> c2 \\<preceq>\\<^sup>* exec_lub (subcls1 P) (super P) c1 c2", "by (simp add: exec_lub_conv) (blast dest: is_lubD is_ubD)"], ["proof (state)\nthis:\n  P \\<turnstile> c1 \\<preceq>\\<^sup>* exec_lub (subcls1 P) (super P) c1\n c2 \\<and>\n  P \\<turnstile> c2 \\<preceq>\\<^sup>* exec_lub (subcls1 P) (super P) c1 c2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>is_class P ?c1.2; is_class P ?c2.2\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> ?c1.2 \\<preceq>\\<^sup>* exec_lub\n                      (subcls1 P) (super P) ?c1.2 ?c2.2 \\<and>\n                    P \\<turnstile> ?c2.2 \\<preceq>\\<^sup>* exec_lub\n                      (subcls1 P) (super P) ?c1.2 ?c2.2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "note this [simp]"], ["proof (state)\nthis:\n  \\<lbrakk>is_class P ?c1.2; is_class P ?c2.2\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> ?c1.2 \\<preceq>\\<^sup>* exec_lub\n                      (subcls1 P) (super P) ?c1.2 ?c2.2 \\<and>\n                    P \\<turnstile> ?c2.2 \\<preceq>\\<^sup>* exec_lub\n                      (subcls1 P) (super P) ?c1.2 ?c2.2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "assume \"is_type P t1\" \"is_type P t2\" \"sup P t1 t2 = OK s\""], ["proof (state)\nthis:\n  is_type P t1\n  is_type P t2\n  SemiType.sup P t1 t2 = OK s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P t1; is_type P t2;\n     SemiType.sup P t1 t2 = OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_type P t1\n  is_type P t2\n  SemiType.sup P t1 t2 = OK s\n\ngoal (1 subgoal):\n 1. subtype P t1 s \\<and> subtype P t2 s", "apply (unfold sup_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_type P t1; is_type P t2;\n     (if is_refT t1 \\<and> is_refT t2\n      then OK (if t1 = NT then t2\n               else if t2 = NT then t1\n                    else Class\n                          (exec_lub (subcls1 P) (super P) (the_Class t1)\n                            (the_Class t2)))\n      else if t1 = t2 then OK t1 else Err) =\n     OK s\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "apply (cases s)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>is_type P t1; is_type P t2;\n     (if is_refT t1 \\<and> is_refT t2\n      then OK (if t1 = NT then t2\n               else if t2 = NT then t1\n                    else Class\n                          (exec_lub (subcls1 P) (super P) (the_Class t1)\n                            (the_Class t2)))\n      else if t1 = t2 then OK t1 else Err) =\n     OK s;\n     s = Void\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s\n 2. \\<lbrakk>is_type P t1; is_type P t2;\n     (if is_refT t1 \\<and> is_refT t2\n      then OK (if t1 = NT then t2\n               else if t2 = NT then t1\n                    else Class\n                          (exec_lub (subcls1 P) (super P) (the_Class t1)\n                            (the_Class t2)))\n      else if t1 = t2 then OK t1 else Err) =\n     OK s;\n     s = Boolean\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s\n 3. \\<lbrakk>is_type P t1; is_type P t2;\n     (if is_refT t1 \\<and> is_refT t2\n      then OK (if t1 = NT then t2\n               else if t2 = NT then t1\n                    else Class\n                          (exec_lub (subcls1 P) (super P) (the_Class t1)\n                            (the_Class t2)))\n      else if t1 = t2 then OK t1 else Err) =\n     OK s;\n     s = Integer\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s\n 4. \\<lbrakk>is_type P t1; is_type P t2;\n     (if is_refT t1 \\<and> is_refT t2\n      then OK (if t1 = NT then t2\n               else if t2 = NT then t1\n                    else Class\n                          (exec_lub (subcls1 P) (super P) (the_Class t1)\n                            (the_Class t2)))\n      else if t1 = t2 then OK t1 else Err) =\n     OK s;\n     s = NT\\<rbrakk>\n    \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s\n 5. \\<And>x5.\n       \\<lbrakk>is_type P t1; is_type P t2;\n        (if is_refT t1 \\<and> is_refT t2\n         then OK (if t1 = NT then t2\n                  else if t2 = NT then t1\n                       else Class\n                             (exec_lub (subcls1 P) (super P) (the_Class t1)\n                               (the_Class t2)))\n         else if t1 = t2 then OK t1 else Err) =\n        OK s;\n        s = Class x5\\<rbrakk>\n       \\<Longrightarrow> subtype P t1 s \\<and> subtype P t2 s", "apply (auto simp add: is_refT_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subtype P t1 s \\<and> subtype P t2 s\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma sup_subtype_smallest:\n  \"\\<lbrakk> wf_prog wf_mb P; is_type P a; is_type P b; is_type P c; \n      subtype P a c; subtype P b c; sup P a b = OK d \\<rbrakk>\n  \\<Longrightarrow> subtype P d c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "assume wf_prog: \"wf_prog wf_mb P\""], ["proof (state)\nthis:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "{"], ["proof (state)\nthis:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "fix c1 c2 D"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "assume is_class: \"is_class P c1\" \"is_class P c2\""], ["proof (state)\nthis:\n  is_class P c1\n  is_class P c2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "assume le: \"P \\<turnstile> c1 \\<preceq>\\<^sup>* D\" \"P \\<turnstile> c2 \\<preceq>\\<^sup>* D\""], ["proof (state)\nthis:\n  P \\<turnstile> c1 \\<preceq>\\<^sup>* D\n  P \\<turnstile> c2 \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "from wf_prog is_class"], ["proof (chain)\npicking this:\n  wf_prog wf_mb P\n  is_class P c1\n  is_class P c2", "obtain \n      \"P \\<turnstile> c1 \\<preceq>\\<^sup>* Object\"\n      \"P \\<turnstile> c2 \\<preceq>\\<^sup>* Object\""], ["proof (prove)\nusing this:\n  wf_prog wf_mb P\n  is_class P c1\n  is_class P c2\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P \\<turnstile> c1 \\<preceq>\\<^sup>* Object;\n      P \\<turnstile> c2 \\<preceq>\\<^sup>* Object\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast intro: subcls_C_Object)"], ["proof (state)\nthis:\n  P \\<turnstile> c1 \\<preceq>\\<^sup>* Object\n  P \\<turnstile> c2 \\<preceq>\\<^sup>* Object\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "with single_valued_subcls1[OF wf_prog]"], ["proof (chain)\npicking this:\n  single_valued (subcls1 P)\n  P \\<turnstile> c1 \\<preceq>\\<^sup>* Object\n  P \\<turnstile> c2 \\<preceq>\\<^sup>* Object", "obtain u where\n      lub: \"is_lub ((subcls1 P)^* ) c1 c2 u\""], ["proof (prove)\nusing this:\n  single_valued (subcls1 P)\n  P \\<turnstile> c1 \\<preceq>\\<^sup>* Object\n  P \\<turnstile> c2 \\<preceq>\\<^sup>* Object\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        is_lub ((subcls1 P)\\<^sup>*) c1 c2 u \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: single_valued_has_lubs)"], ["proof (state)\nthis:\n  is_lub ((subcls1 P)\\<^sup>*) c1 c2 u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "with acyclic_subcls1[OF wf_prog]"], ["proof (chain)\npicking this:\n  acyclic (subcls1 P)\n  is_lub ((subcls1 P)\\<^sup>*) c1 c2 u", "have \"exec_lub (subcls1 P) (super P) c1 c2 = u\""], ["proof (prove)\nusing this:\n  acyclic (subcls1 P)\n  is_lub ((subcls1 P)\\<^sup>*) c1 c2 u\n\ngoal (1 subgoal):\n 1. exec_lub (subcls1 P) (super P) c1 c2 = u", "by (blast intro: superI exec_lub_conv)"], ["proof (state)\nthis:\n  exec_lub (subcls1 P) (super P) c1 c2 = u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "moreover"], ["proof (state)\nthis:\n  exec_lub (subcls1 P) (super P) c1 c2 = u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "from lub le"], ["proof (chain)\npicking this:\n  is_lub ((subcls1 P)\\<^sup>*) c1 c2 u\n  P \\<turnstile> c1 \\<preceq>\\<^sup>* D\n  P \\<turnstile> c2 \\<preceq>\\<^sup>* D", "have \"P \\<turnstile> u \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  is_lub ((subcls1 P)\\<^sup>*) c1 c2 u\n  P \\<turnstile> c1 \\<preceq>\\<^sup>* D\n  P \\<turnstile> c2 \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> u \\<preceq>\\<^sup>* D", "by (simp add: is_lub_def is_ub_def)"], ["proof (state)\nthis:\n  P \\<turnstile> u \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "ultimately"], ["proof (chain)\npicking this:\n  exec_lub (subcls1 P) (super P) c1 c2 = u\n  P \\<turnstile> u \\<preceq>\\<^sup>* D", "have \"P \\<turnstile> exec_lub (subcls1 P) (super P) c1 c2 \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  exec_lub (subcls1 P) (super P) c1 c2 = u\n  P \\<turnstile> u \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> exec_lub (subcls1 P) (super P) c1 c2 \\<preceq>\\<^sup>* D", "by blast"], ["proof (state)\nthis:\n  P \\<turnstile> exec_lub (subcls1 P) (super P) c1 c2 \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "}"], ["proof (state)\nthis:\n  \\<lbrakk>is_class P ?c1.2; is_class P ?c2.2;\n   P \\<turnstile> ?c1.2 \\<preceq>\\<^sup>* ?D2;\n   P \\<turnstile> ?c2.2 \\<preceq>\\<^sup>* ?D2\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> exec_lub (subcls1 P) (super P) ?c1.2\n                                    ?c2.2 \\<preceq>\\<^sup>* ?D2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "note this [intro]"], ["proof (state)\nthis:\n  \\<lbrakk>is_class P ?c1.2; is_class P ?c2.2;\n   P \\<turnstile> ?c1.2 \\<preceq>\\<^sup>* ?D2;\n   P \\<turnstile> ?c2.2 \\<preceq>\\<^sup>* ?D2\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> exec_lub (subcls1 P) (super P) ?c1.2\n                                    ?c2.2 \\<preceq>\\<^sup>* ?D2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "have [dest!]:\n    \"\\<And>C T. P \\<turnstile> Class C \\<le> T \\<Longrightarrow> \\<exists>D. T=Class D \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C T.\n       subtype P (Class C) T \\<Longrightarrow>\n       \\<exists>D. T = Class D \\<and> P \\<turnstile> C \\<preceq>\\<^sup>* D", "by (frule Class_widen, auto)"], ["proof (state)\nthis:\n  subtype P (Class ?C) ?T \\<Longrightarrow>\n  \\<exists>D. ?T = Class D \\<and> P \\<turnstile> ?C \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "assume \"is_type P a\" \"is_type P b\" \"is_type P c\"\n         \"subtype P a c\" \"subtype P b c\" \"sup P a b = OK d\""], ["proof (state)\nthis:\n  is_type P a\n  is_type P b\n  is_type P c\n  subtype P a c\n  subtype P b c\n  SemiType.sup P a b = OK d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_mb P; is_type P a; is_type P b; is_type P c;\n     subtype P a c; subtype P b c; SemiType.sup P a b = OK d\\<rbrakk>\n    \\<Longrightarrow> subtype P d c", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_type P a\n  is_type P b\n  is_type P c\n  subtype P a c\n  subtype P b c\n  SemiType.sup P a b = OK d\n\ngoal (1 subgoal):\n 1. subtype P d c", "by (auto simp add: sup_def is_refT_def\n             split: if_split_asm)"], ["proof (state)\nthis:\n  subtype P d c\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma sup_exists:\n  \"\\<lbrakk> subtype P a c; subtype P b c \\<rbrakk> \\<Longrightarrow> \\<exists>T. sup P a b = OK T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subtype P a c; subtype P b c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T. SemiType.sup P a b = OK T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subtype P a c; subtype P b c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T. SemiType.sup P a b = OK T", "apply (unfold sup_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subtype P a c; subtype P b c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         (if is_refT a \\<and> is_refT b\n                          then OK (if a = NT then b\n                                   else if b = NT then a\n  else Class (exec_lub (subcls1 P) (super P) (the_Class a) (the_Class b)))\n                          else if a = b then OK a else Err) =\n                         OK T", "apply (cases b)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>subtype P a c; subtype P b c; b = Void\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         (if is_refT a \\<and> is_refT b\n                          then OK (if a = NT then b\n                                   else if b = NT then a\n  else Class (exec_lub (subcls1 P) (super P) (the_Class a) (the_Class b)))\n                          else if a = b then OK a else Err) =\n                         OK T\n 2. \\<lbrakk>subtype P a c; subtype P b c; b = Boolean\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         (if is_refT a \\<and> is_refT b\n                          then OK (if a = NT then b\n                                   else if b = NT then a\n  else Class (exec_lub (subcls1 P) (super P) (the_Class a) (the_Class b)))\n                          else if a = b then OK a else Err) =\n                         OK T\n 3. \\<lbrakk>subtype P a c; subtype P b c; b = Integer\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         (if is_refT a \\<and> is_refT b\n                          then OK (if a = NT then b\n                                   else if b = NT then a\n  else Class (exec_lub (subcls1 P) (super P) (the_Class a) (the_Class b)))\n                          else if a = b then OK a else Err) =\n                         OK T\n 4. \\<lbrakk>subtype P a c; subtype P b c; b = NT\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         (if is_refT a \\<and> is_refT b\n                          then OK (if a = NT then b\n                                   else if b = NT then a\n  else Class (exec_lub (subcls1 P) (super P) (the_Class a) (the_Class b)))\n                          else if a = b then OK a else Err) =\n                         OK T\n 5. \\<And>x5.\n       \\<lbrakk>subtype P a c; subtype P b c; b = Class x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            (if is_refT a \\<and> is_refT b\n                             then OK (if a = NT then b\nelse if b = NT then a\n     else Class\n           (exec_lub (subcls1 P) (super P) (the_Class a) (the_Class b)))\n                             else if a = b then OK a else Err) =\n                            OK T", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>subtype P a c; subtype P NT c; b = NT; a \\<noteq> NT\\<rbrakk>\n    \\<Longrightarrow> is_refT a\n 2. \\<And>x5.\n       \\<lbrakk>subtype P a c; subtype P (Class x5) c; b = Class x5;\n        a \\<noteq> Class x5\\<rbrakk>\n       \\<Longrightarrow> is_refT a", "apply (cases a)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>subtype P a c; subtype P NT c; b = NT; a \\<noteq> NT;\n     a = Void\\<rbrakk>\n    \\<Longrightarrow> is_refT a\n 2. \\<lbrakk>subtype P a c; subtype P NT c; b = NT; a \\<noteq> NT;\n     a = Boolean\\<rbrakk>\n    \\<Longrightarrow> is_refT a\n 3. \\<lbrakk>subtype P a c; subtype P NT c; b = NT; a \\<noteq> NT;\n     a = Integer\\<rbrakk>\n    \\<Longrightarrow> is_refT a\n 4. \\<lbrakk>subtype P a c; subtype P NT c; b = NT; a \\<noteq> NT;\n     a = NT\\<rbrakk>\n    \\<Longrightarrow> is_refT a\n 5. \\<And>x5.\n       \\<lbrakk>subtype P a c; subtype P NT c; b = NT; a \\<noteq> NT;\n        a = Class x5\\<rbrakk>\n       \\<Longrightarrow> is_refT a\n 6. \\<And>x5.\n       \\<lbrakk>subtype P a c; subtype P (Class x5) c; b = Class x5;\n        a \\<noteq> Class x5\\<rbrakk>\n       \\<Longrightarrow> is_refT a", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x5.\n       \\<lbrakk>subtype P a c; subtype P (Class x5) c; b = Class x5;\n        a \\<noteq> Class x5\\<rbrakk>\n       \\<Longrightarrow> is_refT a", "apply (cases a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x5.\n       \\<lbrakk>subtype P a c; subtype P (Class x5) c; b = Class x5;\n        a \\<noteq> Class x5; a = Void\\<rbrakk>\n       \\<Longrightarrow> is_refT a\n 2. \\<And>x5.\n       \\<lbrakk>subtype P a c; subtype P (Class x5) c; b = Class x5;\n        a \\<noteq> Class x5; a = Boolean\\<rbrakk>\n       \\<Longrightarrow> is_refT a\n 3. \\<And>x5.\n       \\<lbrakk>subtype P a c; subtype P (Class x5) c; b = Class x5;\n        a \\<noteq> Class x5; a = Integer\\<rbrakk>\n       \\<Longrightarrow> is_refT a\n 4. \\<And>x5.\n       \\<lbrakk>subtype P a c; subtype P (Class x5) c; b = Class x5;\n        a \\<noteq> Class x5; a = NT\\<rbrakk>\n       \\<Longrightarrow> is_refT a\n 5. \\<And>x5 x5a.\n       \\<lbrakk>subtype P a c; subtype P (Class x5) c; b = Class x5;\n        a \\<noteq> Class x5; a = Class x5a\\<rbrakk>\n       \\<Longrightarrow> is_refT a", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma err_semilat_JType_esl:\n  \"wf_prog wf_mb P \\<Longrightarrow> err_semilat (esl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> err_semilat (SemiType.esl P)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> err_semilat (SemiType.esl P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> err_semilat (SemiType.esl P)", "assume wf_prog: \"wf_prog wf_mb P\""], ["proof (state)\nthis:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> err_semilat (SemiType.esl P)", "hence \"order (subtype P)\""], ["proof (prove)\nusing this:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. order (subtype P)", ".."], ["proof (state)\nthis:\n  order (subtype P)\n\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> err_semilat (SemiType.esl P)", "moreover"], ["proof (state)\nthis:\n  order (subtype P)\n\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> err_semilat (SemiType.esl P)", "from wf_prog"], ["proof (chain)\npicking this:\n  wf_prog wf_mb P", "have \"closed (err (types P)) (lift2 (sup P))\""], ["proof (prove)\nusing this:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. closed (err (types P)) (lift2 (SemiType.sup P))", "by (rule closed_err_types)"], ["proof (state)\nthis:\n  closed (err (types P)) (lift2 (SemiType.sup P))\n\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> err_semilat (SemiType.esl P)", "moreover"], ["proof (state)\nthis:\n  closed (err (types P)) (lift2 (SemiType.sup P))\n\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> err_semilat (SemiType.esl P)", "from wf_prog"], ["proof (chain)\npicking this:\n  wf_prog wf_mb P", "have\n    \"(\\<forall>x\\<in>err (types P). \\<forall>y\\<in>err (types P). x \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> x \\<squnion>\\<^bsub>lift2 (sup P)\\<^esub> y) \\<and> \n     (\\<forall>x\\<in>err (types P). \\<forall>y\\<in>err (types P). y \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> x \\<squnion>\\<^bsub>lift2 (sup P)\\<^esub> y)\""], ["proof (prove)\nusing this:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>err (types P).\n        \\<forall>y\\<in>err (types P).\n           x \\<sqsubseteq>\\<^bsub>Err.le\n                                   (subtype\n                                     P)\\<^esub> x \n          \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y) \\<and>\n    (\\<forall>x\\<in>err (types P).\n        \\<forall>y\\<in>err (types P).\n           y \\<sqsubseteq>\\<^bsub>Err.le\n                                   (subtype\n                                     P)\\<^esub> x \n          \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y)", "by (auto simp add: lesub_def plussub_def Err.le_def lift2_def sup_subtype_greater split: err.split)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         x \\<sqsubseteq>\\<^bsub>Err.le\n                                 (subtype\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y) \\<and>\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         y \\<sqsubseteq>\\<^bsub>Err.le\n                                 (subtype\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y)\n\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> err_semilat (SemiType.esl P)", "moreover"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         x \\<sqsubseteq>\\<^bsub>Err.le\n                                 (subtype\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y) \\<and>\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         y \\<sqsubseteq>\\<^bsub>Err.le\n                                 (subtype\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y)\n\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> err_semilat (SemiType.esl P)", "from wf_prog"], ["proof (chain)\npicking this:\n  wf_prog wf_mb P", "have\n    \"\\<forall>x\\<in>err (types P). \\<forall>y\\<in>err (types P). \\<forall>z\\<in>err (types P). \n    x \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> z \\<and> y \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> z \\<longrightarrow> x \\<squnion>\\<^bsub>lift2 (sup P)\\<^esub> y \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> z\""], ["proof (prove)\nusing this:\n  wf_prog wf_mb P\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>err (types P).\n       \\<forall>y\\<in>err (types P).\n          \\<forall>z\\<in>err (types P).\n             x \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> z \\<and>\n             y \\<sqsubseteq>\\<^bsub>Err.le\n                                     (subtype P)\\<^esub> z \\<longrightarrow>\n             x \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y \n             \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> z", "by (unfold lift2_def plussub_def lesub_def Err.le_def)\n       (auto intro: sup_subtype_smallest dest:sup_exists split: err.split)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>err (types P).\n     \\<forall>y\\<in>err (types P).\n        \\<forall>z\\<in>err (types P).\n           x \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> z \\<and>\n           y \\<sqsubseteq>\\<^bsub>Err.le\n                                   (subtype P)\\<^esub> z \\<longrightarrow>\n           x \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y \n           \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> z\n\ngoal (1 subgoal):\n 1. wf_prog wf_mb P \\<Longrightarrow> err_semilat (SemiType.esl P)", "ultimately"], ["proof (chain)\npicking this:\n  order (subtype P)\n  closed (err (types P)) (lift2 (SemiType.sup P))\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         x \\<sqsubseteq>\\<^bsub>Err.le\n                                 (subtype\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y) \\<and>\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         y \\<sqsubseteq>\\<^bsub>Err.le\n                                 (subtype\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y)\n  \\<forall>x\\<in>err (types P).\n     \\<forall>y\\<in>err (types P).\n        \\<forall>z\\<in>err (types P).\n           x \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> z \\<and>\n           y \\<sqsubseteq>\\<^bsub>Err.le\n                                   (subtype P)\\<^esub> z \\<longrightarrow>\n           x \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y \n           \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> z", "show ?thesis"], ["proof (prove)\nusing this:\n  order (subtype P)\n  closed (err (types P)) (lift2 (SemiType.sup P))\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         x \\<sqsubseteq>\\<^bsub>Err.le\n                                 (subtype\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y) \\<and>\n  (\\<forall>x\\<in>err (types P).\n      \\<forall>y\\<in>err (types P).\n         y \\<sqsubseteq>\\<^bsub>Err.le\n                                 (subtype\n                                   P)\\<^esub> x \n        \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y)\n  \\<forall>x\\<in>err (types P).\n     \\<forall>y\\<in>err (types P).\n        \\<forall>z\\<in>err (types P).\n           x \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> z \\<and>\n           y \\<sqsubseteq>\\<^bsub>Err.le\n                                   (subtype P)\\<^esub> z \\<longrightarrow>\n           x \\<squnion>\\<^bsub>lift2 (SemiType.sup P)\\<^esub> y \n           \\<sqsubseteq>\\<^bsub>Err.le (subtype P)\\<^esub> z\n\ngoal (1 subgoal):\n 1. err_semilat (SemiType.esl P)", "by (simp add: esl_def semilat_def sl_def Err.sl_def)"], ["proof (state)\nthis:\n  err_semilat (SemiType.esl P)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"]]}