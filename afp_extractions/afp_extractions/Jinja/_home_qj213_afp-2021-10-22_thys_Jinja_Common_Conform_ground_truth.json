{"file_name": "/home/qj213/afp-2021-10-22/thys/Jinja/Common/Conform.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jinja", "problem_names": ["lemma conf_Null [simp]: \"P,h \\<turnstile> Null :\\<le> T  =  P \\<turnstile> NT \\<le> T\"", "lemma typeof_conf[simp]: \"typeof\\<^bsub>h\\<^esub> v = Some T \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\"", "lemma typeof_lit_conf[simp]: \"typeof v = Some T \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\"", "lemma defval_conf[simp]: \"P,h \\<turnstile> default_val T :\\<le> T\"", "lemma conf_upd_obj: \"h a = Some(C,fs) \\<Longrightarrow> (P,h(a\\<mapsto>(C,fs')) \\<turnstile> x :\\<le> T) = (P,h \\<turnstile> x :\\<le> T)\"", "lemma conf_widen: \"P,h \\<turnstile> v :\\<le> T \\<Longrightarrow> P \\<turnstile> T \\<le> T' \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\"", "lemma conf_hext: \"h \\<unlhd> h' \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T\"", "lemma conf_ClassD: \"P,h \\<turnstile> v :\\<le> Class C \\<Longrightarrow>\n  v = Null \\<or> (\\<exists>a obj T. v = Addr a \\<and>  h a = Some obj \\<and> obj_ty obj = T \\<and>  P \\<turnstile> T \\<le> Class C)\"", "lemma conf_NT [iff]: \"P,h \\<turnstile> v :\\<le> NT = (v = Null)\"", "lemma non_npD: \"\\<lbrakk> v \\<noteq> Null; P,h \\<turnstile> v :\\<le> Class C \\<rbrakk>\n  \\<Longrightarrow> \\<exists>a C' fs. v = Addr a \\<and> h a = Some(C',fs) \\<and> P \\<turnstile> C' \\<preceq>\\<^sup>* C\"", "lemma confs_widens [trans]: \"\\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts; P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> vs [:\\<le>] Ts'\"", "lemma confs_rev: \"P,h \\<turnstile> rev s [:\\<le>] t = (P,h \\<turnstile> s [:\\<le>] rev t)\"", "lemma confs_conv_map:\n  \"\\<And>Ts'. P,h \\<turnstile> vs [:\\<le>] Ts' = (\\<exists>Ts. map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and> P \\<turnstile> Ts [\\<le>] Ts')\"", "lemma confs_hext: \"P,h \\<turnstile> vs [:\\<le>] Ts \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> vs [:\\<le>] Ts\"", "lemma confs_Cons2: \"P,h \\<turnstile> xs [:\\<le>] y#ys = (\\<exists>z zs. xs = z#zs \\<and> P,h \\<turnstile> z :\\<le> y \\<and> P,h \\<turnstile> zs [:\\<le>] ys)\"", "lemma oconf_hext: \"P,h \\<turnstile> obj \\<surd> \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> obj \\<surd>\"", "lemma oconf_init_fields:\n \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> P,h \\<turnstile> (C, init_fields FDTs) \\<surd>\"", "lemma oconf_fupd [intro?]:\n  \"\\<lbrakk> P \\<turnstile> C has F:T in D; P,h \\<turnstile> v :\\<le> T; P,h \\<turnstile> (C,fs) \\<surd> \\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile> (C, fs((F,D)\\<mapsto>v)) \\<surd>\"", "lemmas oconf_new = oconf_hext [OF _ hext_new]", "lemmas oconf_upd_obj = oconf_hext [OF _ hext_upd_obj]", "lemma hconfD: \"\\<lbrakk> P \\<turnstile> h \\<surd>; h a = Some obj \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> obj \\<surd>\"", "lemma hconf_new: \"\\<lbrakk> P \\<turnstile> h \\<surd>; h a = None; P,h \\<turnstile> obj \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile> h(a\\<mapsto>obj) \\<surd>\"", "lemma hconf_upd_obj: \"\\<lbrakk> P \\<turnstile> h\\<surd>; h a = Some(C,fs); P,h \\<turnstile> (C,fs')\\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile> h(a\\<mapsto>(C,fs'))\\<surd>\"", "lemma lconf_hext: \"\\<lbrakk> P,h \\<turnstile> l (:\\<le>) E; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> l (:\\<le>) E\"", "lemma lconf_upd:\n  \"\\<lbrakk> P,h \\<turnstile> l (:\\<le>) E; P,h \\<turnstile> v :\\<le> T; E V = Some T \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> l(V\\<mapsto>v) (:\\<le>) E\"", "lemma lconf_empty[iff]: \"P,h \\<turnstile> Map.empty (:\\<le>) E\"", "lemma lconf_upd2: \"\\<lbrakk>P,h \\<turnstile> l (:\\<le>) E; P,h \\<turnstile> v :\\<le> T\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> l(V\\<mapsto>v) (:\\<le>) E(V\\<mapsto>T)\""], "translations": [["", "lemma conf_Null [simp]: \"P,h \\<turnstile> Null :\\<le> T  =  P \\<turnstile> NT \\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> Null :\\<le> T) = P \\<turnstile> NT \\<le> T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> Null :\\<le> T) = P \\<turnstile> NT \\<le> T", "apply (unfold conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>T'.\n        typeof\\<^bsub>h\\<^esub> Null = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T) =\n    P \\<turnstile> NT \\<le> T", "apply (simp (no_asm))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma typeof_conf[simp]: \"typeof\\<^bsub>h\\<^esub> v = Some T \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    P,h \\<turnstile> v :\\<le> T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    P,h \\<turnstile> v :\\<le> T", "apply (unfold conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> T", "apply (induct v)"], ["proof (prove)\ngoal (5 subgoals):\n 1. typeof\\<^bsub>h\\<^esub> Unit = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> Unit = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> T\n 2. typeof\\<^bsub>h\\<^esub> Null = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> Null = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> T\n 3. \\<And>x.\n       typeof\\<^bsub>h\\<^esub> (Bool x) =\n       \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       \\<exists>T'.\n          typeof\\<^bsub>h\\<^esub> (Bool x) = \\<lfloor>T'\\<rfloor> \\<and>\n          P \\<turnstile> T' \\<le> T\n 4. \\<And>x.\n       typeof\\<^bsub>h\\<^esub> (Intg x) =\n       \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       \\<exists>T'.\n          typeof\\<^bsub>h\\<^esub> (Intg x) = \\<lfloor>T'\\<rfloor> \\<and>\n          P \\<turnstile> T' \\<le> T\n 5. \\<And>x.\n       typeof\\<^bsub>h\\<^esub> (Addr x) =\n       \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n       \\<exists>T'.\n          typeof\\<^bsub>h\\<^esub> (Addr x) = \\<lfloor>T'\\<rfloor> \\<and>\n          P \\<turnstile> T' \\<le> T", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma typeof_lit_conf[simp]: \"typeof v = Some T \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    P,h \\<turnstile> v :\\<le> T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow>\n    P,h \\<turnstile> v :\\<le> T", "by (rule typeof_conf[OF typeof_lit_typeof])"], ["", "(*>*)"], ["", "lemma defval_conf[simp]: \"P,h \\<turnstile> default_val T :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> default_val T :\\<le> T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> default_val T :\\<le> T", "apply (unfold conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> (default_val T) = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> T", "apply (cases T)"], ["proof (prove)\ngoal (5 subgoals):\n 1. T = Void \\<Longrightarrow>\n    \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> (default_val T) = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> T\n 2. T = Boolean \\<Longrightarrow>\n    \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> (default_val T) = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> T\n 3. T = Integer \\<Longrightarrow>\n    \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> (default_val T) = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> T\n 4. T = NT \\<Longrightarrow>\n    \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> (default_val T) = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> T\n 5. \\<And>x5.\n       T = Class x5 \\<Longrightarrow>\n       \\<exists>T'.\n          typeof\\<^bsub>h\\<^esub> (default_val T) =\n          \\<lfloor>T'\\<rfloor> \\<and>\n          P \\<turnstile> T' \\<le> T", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma conf_upd_obj: \"h a = Some(C,fs) \\<Longrightarrow> (P,h(a\\<mapsto>(C,fs')) \\<turnstile> x :\\<le> T) = (P,h \\<turnstile> x :\\<le> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>(C, fs)\\<rfloor> \\<Longrightarrow>\n    (P,h(a \\<mapsto> (C, fs')) \\<turnstile> x :\\<le> T) =\n    (P,h \\<turnstile> x :\\<le> T)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>(C, fs)\\<rfloor> \\<Longrightarrow>\n    (P,h(a \\<mapsto> (C, fs')) \\<turnstile> x :\\<le> T) =\n    (P,h \\<turnstile> x :\\<le> T)", "apply (unfold conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>(C, fs)\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'.\n        typeof\\<^bsub>h(a \\<mapsto> (C, fs'))\\<^esub> x =\n        \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T) =\n    (\\<exists>T'.\n        typeof\\<^bsub>h\\<^esub> x = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T)", "apply (rule val.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. h a = \\<lfloor>(C, fs)\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'.\n        typeof\\<^bsub>h(a \\<mapsto> (C, fs'))\\<^esub> Unit =\n        \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T) =\n    (\\<exists>T'.\n        typeof\\<^bsub>h\\<^esub> Unit = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T)\n 2. h a = \\<lfloor>(C, fs)\\<rfloor> \\<Longrightarrow>\n    (\\<exists>T'.\n        typeof\\<^bsub>h(a \\<mapsto> (C, fs'))\\<^esub> Null =\n        \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T) =\n    (\\<exists>T'.\n        typeof\\<^bsub>h\\<^esub> Null = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T)\n 3. \\<And>x.\n       h a = \\<lfloor>(C, fs)\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'.\n           typeof\\<^bsub>h(a \\<mapsto> (C, fs'))\\<^esub> (Bool x) =\n           \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T) =\n       (\\<exists>T'.\n           typeof\\<^bsub>h\\<^esub> (Bool x) = \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T)\n 4. \\<And>x.\n       h a = \\<lfloor>(C, fs)\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'.\n           typeof\\<^bsub>h(a \\<mapsto> (C, fs'))\\<^esub> (Intg x) =\n           \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T) =\n       (\\<exists>T'.\n           typeof\\<^bsub>h\\<^esub> (Intg x) = \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T)\n 5. \\<And>x.\n       h a = \\<lfloor>(C, fs)\\<rfloor> \\<Longrightarrow>\n       (\\<exists>T'.\n           typeof\\<^bsub>h(a \\<mapsto> (C, fs'))\\<^esub> (Addr x) =\n           \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T) =\n       (\\<exists>T'.\n           typeof\\<^bsub>h\\<^esub> (Addr x) = \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T)", "apply (auto simp:fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma conf_widen: \"P,h \\<turnstile> v :\\<le> T \\<Longrightarrow> P \\<turnstile> T \\<le> T' \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> v :\\<le> T; P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> v :\\<le> T; P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T'", "apply (unfold conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>T'.\n                typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'\\<rfloor> \\<and>\n                P \\<turnstile> T' \\<le> T;\n     P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T'a.\n                         typeof\\<^bsub>h\\<^esub> v =\n                         \\<lfloor>T'a\\<rfloor> \\<and>\n                         P \\<turnstile> T'a \\<le> T'", "apply (induct v)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<exists>T'.\n                typeof\\<^bsub>h\\<^esub> Unit = \\<lfloor>T'\\<rfloor> \\<and>\n                P \\<turnstile> T' \\<le> T;\n     P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T'a.\n                         typeof\\<^bsub>h\\<^esub> Unit =\n                         \\<lfloor>T'a\\<rfloor> \\<and>\n                         P \\<turnstile> T'a \\<le> T'\n 2. \\<lbrakk>\\<exists>T'.\n                typeof\\<^bsub>h\\<^esub> Null = \\<lfloor>T'\\<rfloor> \\<and>\n                P \\<turnstile> T' \\<le> T;\n     P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T'a.\n                         typeof\\<^bsub>h\\<^esub> Null =\n                         \\<lfloor>T'a\\<rfloor> \\<and>\n                         P \\<turnstile> T'a \\<le> T'\n 3. \\<And>x.\n       \\<lbrakk>\\<exists>T'.\n                   typeof\\<^bsub>h\\<^esub> (Bool x) =\n                   \\<lfloor>T'\\<rfloor> \\<and>\n                   P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'a.\n                            typeof\\<^bsub>h\\<^esub> (Bool x) =\n                            \\<lfloor>T'a\\<rfloor> \\<and>\n                            P \\<turnstile> T'a \\<le> T'\n 4. \\<And>x.\n       \\<lbrakk>\\<exists>T'.\n                   typeof\\<^bsub>h\\<^esub> (Intg x) =\n                   \\<lfloor>T'\\<rfloor> \\<and>\n                   P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'a.\n                            typeof\\<^bsub>h\\<^esub> (Intg x) =\n                            \\<lfloor>T'a\\<rfloor> \\<and>\n                            P \\<turnstile> T'a \\<le> T'\n 5. \\<And>x.\n       \\<lbrakk>\\<exists>T'.\n                   typeof\\<^bsub>h\\<^esub> (Addr x) =\n                   \\<lfloor>T'\\<rfloor> \\<and>\n                   P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'a.\n                            typeof\\<^bsub>h\\<^esub> (Addr x) =\n                            \\<lfloor>T'a\\<rfloor> \\<and>\n                            P \\<turnstile> T'a \\<le> T'", "apply (auto intro: widen_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma conf_hext: \"h \\<unlhd> h' \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; P,h \\<turnstile> v :\\<le> T\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; P,h \\<turnstile> v :\\<le> T\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T", "apply (unfold conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h';\n     \\<exists>T'.\n        typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T'.\n                         typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T'\\<rfloor> \\<and>\n                         P \\<turnstile> T' \\<le> T", "apply (induct v)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>h \\<unlhd> h';\n     \\<exists>T'.\n        typeof\\<^bsub>h\\<^esub> Unit = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T'.\n                         typeof\\<^bsub>h'\\<^esub> Unit =\n                         \\<lfloor>T'\\<rfloor> \\<and>\n                         P \\<turnstile> T' \\<le> T\n 2. \\<lbrakk>h \\<unlhd> h';\n     \\<exists>T'.\n        typeof\\<^bsub>h\\<^esub> Null = \\<lfloor>T'\\<rfloor> \\<and>\n        P \\<turnstile> T' \\<le> T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T'.\n                         typeof\\<^bsub>h'\\<^esub> Null =\n                         \\<lfloor>T'\\<rfloor> \\<and>\n                         P \\<turnstile> T' \\<le> T\n 3. \\<And>x.\n       \\<lbrakk>h \\<unlhd> h';\n        \\<exists>T'.\n           typeof\\<^bsub>h\\<^esub> (Bool x) = \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            typeof\\<^bsub>h'\\<^esub> (Bool x) =\n                            \\<lfloor>T'\\<rfloor> \\<and>\n                            P \\<turnstile> T' \\<le> T\n 4. \\<And>x.\n       \\<lbrakk>h \\<unlhd> h';\n        \\<exists>T'.\n           typeof\\<^bsub>h\\<^esub> (Intg x) = \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            typeof\\<^bsub>h'\\<^esub> (Intg x) =\n                            \\<lfloor>T'\\<rfloor> \\<and>\n                            P \\<turnstile> T' \\<le> T\n 5. \\<And>x.\n       \\<lbrakk>h \\<unlhd> h';\n        \\<exists>T'.\n           typeof\\<^bsub>h\\<^esub> (Addr x) = \\<lfloor>T'\\<rfloor> \\<and>\n           P \\<turnstile> T' \\<le> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T'.\n                            typeof\\<^bsub>h'\\<^esub> (Addr x) =\n                            \\<lfloor>T'\\<rfloor> \\<and>\n                            P \\<turnstile> T' \\<le> T", "apply (auto dest: hext_objD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma conf_ClassD: \"P,h \\<turnstile> v :\\<le> Class C \\<Longrightarrow>\n  v = Null \\<or> (\\<exists>a obj T. v = Addr a \\<and>  h a = Some obj \\<and> obj_ty obj = T \\<and>  P \\<turnstile> T \\<le> Class C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> Class C \\<Longrightarrow>\n    v = Null \\<or>\n    (\\<exists>a obj T.\n        v = Addr a \\<and>\n        h a = \\<lfloor>obj\\<rfloor> \\<and>\n        obj_ty obj = T \\<and> P \\<turnstile> T \\<le> Class C)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> v :\\<le> Class C \\<Longrightarrow>\n    v = Null \\<or>\n    (\\<exists>a obj T.\n        v = Addr a \\<and>\n        h a = \\<lfloor>obj\\<rfloor> \\<and>\n        obj_ty obj = T \\<and> P \\<turnstile> T \\<le> Class C)", "apply (unfold conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> Class C \\<Longrightarrow>\n    v = Null \\<or>\n    (\\<exists>a obj T.\n        v = Addr a \\<and>\n        h a = \\<lfloor>obj\\<rfloor> \\<and>\n        obj_ty obj = T \\<and> P \\<turnstile> T \\<le> Class C)", "apply(induct \"v\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> Unit = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> Class C \\<Longrightarrow>\n    Unit = Null \\<or>\n    (\\<exists>a obj T.\n        Unit = Addr a \\<and>\n        h a = \\<lfloor>obj\\<rfloor> \\<and>\n        obj_ty obj = T \\<and> P \\<turnstile> T \\<le> Class C)\n 2. \\<exists>T'.\n       typeof\\<^bsub>h\\<^esub> Null = \\<lfloor>T'\\<rfloor> \\<and>\n       P \\<turnstile> T' \\<le> Class C \\<Longrightarrow>\n    Null = Null \\<or>\n    (\\<exists>a obj T.\n        Null = Addr a \\<and>\n        h a = \\<lfloor>obj\\<rfloor> \\<and>\n        obj_ty obj = T \\<and> P \\<turnstile> T \\<le> Class C)\n 3. \\<And>x.\n       \\<exists>T'.\n          typeof\\<^bsub>h\\<^esub> (Bool x) = \\<lfloor>T'\\<rfloor> \\<and>\n          P \\<turnstile> T' \\<le> Class C \\<Longrightarrow>\n       Bool x = Null \\<or>\n       (\\<exists>a obj T.\n           Bool x = Addr a \\<and>\n           h a = \\<lfloor>obj\\<rfloor> \\<and>\n           obj_ty obj = T \\<and> P \\<turnstile> T \\<le> Class C)\n 4. \\<And>x.\n       \\<exists>T'.\n          typeof\\<^bsub>h\\<^esub> (Intg x) = \\<lfloor>T'\\<rfloor> \\<and>\n          P \\<turnstile> T' \\<le> Class C \\<Longrightarrow>\n       Intg x = Null \\<or>\n       (\\<exists>a obj T.\n           Intg x = Addr a \\<and>\n           h a = \\<lfloor>obj\\<rfloor> \\<and>\n           obj_ty obj = T \\<and> P \\<turnstile> T \\<le> Class C)\n 5. \\<And>x.\n       \\<exists>T'.\n          typeof\\<^bsub>h\\<^esub> (Addr x) = \\<lfloor>T'\\<rfloor> \\<and>\n          P \\<turnstile> T' \\<le> Class C \\<Longrightarrow>\n       Addr x = Null \\<or>\n       (\\<exists>a obj T.\n           Addr x = Addr a \\<and>\n           h a = \\<lfloor>obj\\<rfloor> \\<and>\n           obj_ty obj = T \\<and> P \\<turnstile> T \\<le> Class C)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma conf_NT [iff]: \"P,h \\<turnstile> v :\\<le> NT = (v = Null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> v :\\<le> NT) = (v = Null)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> v :\\<le> NT) = (v = Null)", "by (auto simp add: conf_def)"], ["", "(*>*)"], ["", "lemma non_npD: \"\\<lbrakk> v \\<noteq> Null; P,h \\<turnstile> v :\\<le> Class C \\<rbrakk>\n  \\<Longrightarrow> \\<exists>a C' fs. v = Addr a \\<and> h a = Some(C',fs) \\<and> P \\<turnstile> C' \\<preceq>\\<^sup>* C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> Null; P,h \\<turnstile> v :\\<le> Class C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a C' fs.\n                         v = Addr a \\<and>\n                         h a = \\<lfloor>(C', fs)\\<rfloor> \\<and>\n                         P \\<turnstile> C' \\<preceq>\\<^sup>* C", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> Null; P,h \\<turnstile> v :\\<le> Class C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a C' fs.\n                         v = Addr a \\<and>\n                         h a = \\<lfloor>(C', fs)\\<rfloor> \\<and>\n                         P \\<turnstile> C' \\<preceq>\\<^sup>* C", "apply (drule conf_ClassD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> Null;\n     v = Null \\<or>\n     (\\<exists>a obj T.\n         v = Addr a \\<and>\n         h a = \\<lfloor>obj\\<rfloor> \\<and>\n         obj_ty obj = T \\<and> P \\<turnstile> T \\<le> Class C)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a C' fs.\n                         v = Addr a \\<and>\n                         h a = \\<lfloor>(C', fs)\\<rfloor> \\<and>\n                         P \\<turnstile> C' \\<preceq>\\<^sup>* C", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsection\\<open>Value list conformance \\<open>[:\\<le>]\\<close>\\<close>"], ["", "lemma confs_widens [trans]: \"\\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts; P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> vs [:\\<le>] Ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> vs [:\\<le>] Ts'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> vs [:\\<le>] Ts'", "apply (rule list_all2_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts;\n        P \\<turnstile> Ts [\\<le>] Ts'; ?P1.0 a b; ?P2.0 b c\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> a :\\<le> c\n 2. \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n    \\<Longrightarrow> list_all2 ?P1.0 vs ?bs\n 3. \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n    \\<Longrightarrow> list_all2 ?P2.0 ?bs Ts'", "apply (rule conf_widen, assumption, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n    \\<Longrightarrow> list_all2\n                       (\\<lambda>a b. P,h \\<turnstile> a :\\<le> ?T8 b) vs\n                       ?bs\n 2. \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n    \\<Longrightarrow> list_all2 (\\<lambda>b. widen P (?T8 b)) ?bs Ts'", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts;\n     P \\<turnstile> Ts [\\<le>] Ts'\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Ts [\\<le>] Ts'", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma confs_rev: \"P,h \\<turnstile> rev s [:\\<le>] t = (P,h \\<turnstile> s [:\\<le>] rev t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> rev s [:\\<le>] t) =\n    (P,h \\<turnstile> s [:\\<le>] rev t)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> rev s [:\\<le>] t) =\n    (P,h \\<turnstile> s [:\\<le>] rev t)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. P,h \\<turnstile> rev s [:\\<le>] t \\<Longrightarrow>\n    P,h \\<turnstile> s [:\\<le>] rev t\n 2. P,h \\<turnstile> s [:\\<le>] rev t \\<Longrightarrow>\n    P,h \\<turnstile> rev s [:\\<le>] t", "apply (rule subst [OF list_all2_rev])"], ["proof (prove)\ngoal (2 subgoals):\n 1. P,h \\<turnstile> rev s [:\\<le>] t \\<Longrightarrow>\n    P,h \\<turnstile> rev s [:\\<le>] rev (rev t)\n 2. P,h \\<turnstile> s [:\\<le>] rev t \\<Longrightarrow>\n    P,h \\<turnstile> rev s [:\\<le>] t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> s [:\\<le>] rev t \\<Longrightarrow>\n    P,h \\<turnstile> rev s [:\\<le>] t", "apply (rule subst [OF list_all2_rev])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> s [:\\<le>] rev t \\<Longrightarrow>\n    P,h \\<turnstile> rev (rev s) [:\\<le>] rev t", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma confs_conv_map:\n  \"\\<And>Ts'. P,h \\<turnstile> vs [:\\<le>] Ts' = (\\<exists>Ts. map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and> P \\<turnstile> Ts [\\<le>] Ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ts'.\n       (P,h \\<turnstile> vs [:\\<le>] Ts') =\n       (\\<exists>Ts.\n           map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n           P \\<turnstile> Ts [\\<le>] Ts')", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ts'.\n       (P,h \\<turnstile> vs [:\\<le>] Ts') =\n       (\\<exists>Ts.\n           map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n           P \\<turnstile> Ts [\\<le>] Ts')", "apply(induct vs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ts'.\n       (P,h \\<turnstile> [] [:\\<le>] Ts') =\n       (\\<exists>Ts.\n           map typeof\\<^bsub>h\\<^esub> [] = map Some Ts \\<and>\n           P \\<turnstile> Ts [\\<le>] Ts')\n 2. \\<And>a vs Ts'.\n       (\\<And>Ts'.\n           (P,h \\<turnstile> vs [:\\<le>] Ts') =\n           (\\<exists>Ts.\n               map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n               P \\<turnstile> Ts [\\<le>] Ts')) \\<Longrightarrow>\n       (P,h \\<turnstile> a # vs [:\\<le>] Ts') =\n       (\\<exists>Ts.\n           map typeof\\<^bsub>h\\<^esub> (a # vs) = map Some Ts \\<and>\n           P \\<turnstile> Ts [\\<le>] Ts')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a vs Ts'.\n       (\\<And>Ts'.\n           (P,h \\<turnstile> vs [:\\<le>] Ts') =\n           (\\<exists>Ts.\n               map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n               P \\<turnstile> Ts [\\<le>] Ts')) \\<Longrightarrow>\n       (P,h \\<turnstile> a # vs [:\\<le>] Ts') =\n       (\\<exists>Ts.\n           map typeof\\<^bsub>h\\<^esub> (a # vs) = map Some Ts \\<and>\n           P \\<turnstile> Ts [\\<le>] Ts')", "apply(case_tac Ts')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a vs Ts'.\n       \\<lbrakk>\\<And>Ts'.\n                   (P,h \\<turnstile> vs [:\\<le>] Ts') =\n                   (\\<exists>Ts.\n                       map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n                       P \\<turnstile> Ts [\\<le>] Ts');\n        Ts' = []\\<rbrakk>\n       \\<Longrightarrow> (P,h \\<turnstile> a # vs [:\\<le>] Ts') =\n                         (\\<exists>Ts.\n                             map typeof\\<^bsub>h\\<^esub> (a # vs) =\n                             map Some Ts \\<and>\n                             P \\<turnstile> Ts [\\<le>] Ts')\n 2. \\<And>a vs Ts' aa list.\n       \\<lbrakk>\\<And>Ts'.\n                   (P,h \\<turnstile> vs [:\\<le>] Ts') =\n                   (\\<exists>Ts.\n                       map typeof\\<^bsub>h\\<^esub> vs = map Some Ts \\<and>\n                       P \\<turnstile> Ts [\\<le>] Ts');\n        Ts' = aa # list\\<rbrakk>\n       \\<Longrightarrow> (P,h \\<turnstile> a # vs [:\\<le>] Ts') =\n                         (\\<exists>Ts.\n                             map typeof\\<^bsub>h\\<^esub> (a # vs) =\n                             map Some Ts \\<and>\n                             P \\<turnstile> Ts [\\<le>] Ts')", "apply(auto simp add:conf_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma confs_hext: \"P,h \\<turnstile> vs [:\\<le>] Ts \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> vs [:\\<le>] Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> vs [:\\<le>] Ts", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> vs [:\\<le>] Ts", "by (erule list_all2_mono, erule conf_hext, assumption)"], ["", "(*>*)"], ["", "lemma confs_Cons2: \"P,h \\<turnstile> xs [:\\<le>] y#ys = (\\<exists>z zs. xs = z#zs \\<and> P,h \\<turnstile> z :\\<le> y \\<and> P,h \\<turnstile> zs [:\\<le>] ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> xs [:\\<le>] y # ys) =\n    (\\<exists>z zs.\n        xs = z # zs \\<and>\n        P,h \\<turnstile> z :\\<le> y \\<and> P,h \\<turnstile> zs [:\\<le>] ys)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,h \\<turnstile> xs [:\\<le>] y # ys) =\n    (\\<exists>z zs.\n        xs = z # zs \\<and>\n        P,h \\<turnstile> z :\\<le> y \\<and> P,h \\<turnstile> zs [:\\<le>] ys)", "by (rule list_all2_Cons2)"], ["", "(*>*)"], ["", "subsection \"Object conformance\""], ["", "lemma oconf_hext: \"P,h \\<turnstile> obj \\<surd> \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> obj \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> obj \\<surd>; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> obj \\<surd>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> obj \\<surd>; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> obj \\<surd>", "apply (unfold oconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>let (C, fs) = obj\n             in \\<forall>F D T.\n                   P \\<turnstile> C has F:T in D \\<longrightarrow>\n                   (\\<exists>v.\n                       fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n                       P,h \\<turnstile> v :\\<le> T);\n     h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> let (C, fs) = obj\n                      in \\<forall>F D T.\n                            P \\<turnstile> C has F:T in D \\<longrightarrow>\n                            (\\<exists>v.\n                                fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n                                P,h' \\<turnstile> v :\\<le> T)", "apply (fastforce elim:conf_hext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma oconf_init_fields:\n \"P \\<turnstile> C has_fields FDTs \\<Longrightarrow> P,h \\<turnstile> (C, init_fields FDTs) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has_fields FDTs \\<Longrightarrow>\n    P,h \\<turnstile> (C, init_fields FDTs) \\<surd>", "by(fastforce simp add: has_field_def oconf_def init_fields_def map_of_map\n            dest: has_fields_fun)"], ["", "lemma oconf_fupd [intro?]:\n  \"\\<lbrakk> P \\<turnstile> C has F:T in D; P,h \\<turnstile> v :\\<le> T; P,h \\<turnstile> (C,fs) \\<surd> \\<rbrakk> \n  \\<Longrightarrow> P,h \\<turnstile> (C, fs((F,D)\\<mapsto>v)) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has F:T in D; P,h \\<turnstile> v :\\<le> T;\n     P,h \\<turnstile> (C, fs) \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> (C, fs((F, D) \\<mapsto> v)) \\<surd>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has F:T in D; P,h \\<turnstile> v :\\<le> T;\n     P,h \\<turnstile> (C, fs) \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> (C, fs((F, D) \\<mapsto> v)) \\<surd>", "apply (unfold oconf_def has_field_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>FDTs.\n                P \\<turnstile> C has_fields FDTs \\<and>\n                map_of FDTs (F, D) = \\<lfloor>T\\<rfloor>;\n     P,h \\<turnstile> v :\\<le> T;\n     let (C, fs) = (C, fs)\n     in \\<forall>F D T.\n           (\\<exists>FDTs.\n               P \\<turnstile> C has_fields FDTs \\<and>\n               map_of FDTs (F, D) = \\<lfloor>T\\<rfloor>) \\<longrightarrow>\n           (\\<exists>v.\n               fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n               P,h \\<turnstile> v :\\<le> T)\\<rbrakk>\n    \\<Longrightarrow> let (C, fs) = (C, fs((F, D) \\<mapsto> v))\n                      in \\<forall>F D T.\n                            (\\<exists>FDTs.\n                                P \\<turnstile> C has_fields FDTs \\<and>\n                                map_of FDTs (F, D) =\n                                \\<lfloor>T\\<rfloor>) \\<longrightarrow>\n                            (\\<exists>v.\n                                fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n                                P,h \\<turnstile> v :\\<le> T)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs Ta FDTsa.\n       \\<lbrakk>P,h \\<turnstile> v :\\<le> T;\n        \\<forall>F D T.\n           (\\<exists>FDTs.\n               P \\<turnstile> C has_fields FDTs \\<and>\n               map_of FDTs (F, D) = \\<lfloor>T\\<rfloor>) \\<longrightarrow>\n           (\\<exists>v.\n               fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n               P,h \\<turnstile> v :\\<le> T);\n        P \\<turnstile> C has_fields FDTs;\n        map_of FDTs (F, D) = \\<lfloor>T\\<rfloor>;\n        P \\<turnstile> C has_fields FDTsa;\n        map_of FDTsa (F, D) = \\<lfloor>Ta\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> Ta", "apply (drule (1) has_fields_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>FDTs Ta FDTsa.\n       \\<lbrakk>P,h \\<turnstile> v :\\<le> T;\n        \\<forall>F D T.\n           (\\<exists>FDTs.\n               P \\<turnstile> C has_fields FDTs \\<and>\n               map_of FDTs (F, D) = \\<lfloor>T\\<rfloor>) \\<longrightarrow>\n           (\\<exists>v.\n               fs (F, D) = \\<lfloor>v\\<rfloor> \\<and>\n               P,h \\<turnstile> v :\\<le> T);\n        map_of FDTs (F, D) = \\<lfloor>T\\<rfloor>;\n        P \\<turnstile> C has_fields FDTsa;\n        map_of FDTsa (F, D) = \\<lfloor>Ta\\<rfloor>; FDTsa = FDTs\\<rbrakk>\n       \\<Longrightarrow> P,h \\<turnstile> v :\\<le> Ta", "apply (auto simp add: fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(*<*)"], ["", "lemmas oconf_new = oconf_hext [OF _ hext_new]"], ["", "lemmas oconf_upd_obj = oconf_hext [OF _ hext_upd_obj]"], ["", "(*>*)"], ["", "subsection \"Heap conformance\""], ["", "lemma hconfD: \"\\<lbrakk> P \\<turnstile> h \\<surd>; h a = Some obj \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> obj \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> h \\<surd>; h a = \\<lfloor>obj\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> obj \\<surd>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> h \\<surd>; h a = \\<lfloor>obj\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> obj \\<surd>", "apply (unfold hconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>a obj.\n                 h a = \\<lfloor>obj\\<rfloor> \\<longrightarrow>\n                 P,h \\<turnstile> obj \\<surd>) \\<and>\n             preallocated h;\n     h a = \\<lfloor>obj\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> obj \\<surd>", "apply (fast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma hconf_new: \"\\<lbrakk> P \\<turnstile> h \\<surd>; h a = None; P,h \\<turnstile> obj \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile> h(a\\<mapsto>obj) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> h \\<surd>; h a = None;\n     P,h \\<turnstile> obj \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> h(a \\<mapsto> obj) \\<surd>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> h \\<surd>; h a = None;\n     P,h \\<turnstile> obj \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> h(a \\<mapsto> obj) \\<surd>", "by (unfold hconf_def) (auto intro: oconf_new preallocated_new)"], ["", "(*>*)"], ["", "lemma hconf_upd_obj: \"\\<lbrakk> P \\<turnstile> h\\<surd>; h a = Some(C,fs); P,h \\<turnstile> (C,fs')\\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile> h(a\\<mapsto>(C,fs'))\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> h \\<surd>; h a = \\<lfloor>(C, fs)\\<rfloor>;\n     P,h \\<turnstile> (C, fs') \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> h(a \\<mapsto> (C, fs')) \\<surd>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> h \\<surd>; h a = \\<lfloor>(C, fs)\\<rfloor>;\n     P,h \\<turnstile> (C, fs') \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> h(a \\<mapsto> (C, fs')) \\<surd>", "by (unfold hconf_def) (auto intro: oconf_upd_obj preallocated_upd_obj)"], ["", "(*>*)"], ["", "subsection \"Local variable conformance\""], ["", "lemma lconf_hext: \"\\<lbrakk> P,h \\<turnstile> l (:\\<le>) E; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> l (:\\<le>) E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> l (:\\<le>) E; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> l (:\\<le>) E", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> l (:\\<le>) E; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> l (:\\<le>) E", "apply (unfold lconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>V v.\n                l V = \\<lfloor>v\\<rfloor> \\<longrightarrow>\n                (\\<exists>T.\n                    E V = \\<lfloor>T\\<rfloor> \\<and>\n                    P,h \\<turnstile> v :\\<le> T);\n     h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V v.\n                         l V = \\<lfloor>v\\<rfloor> \\<longrightarrow>\n                         (\\<exists>T.\n                             E V = \\<lfloor>T\\<rfloor> \\<and>\n                             P,h' \\<turnstile> v :\\<le> T)", "apply  (fast elim: conf_hext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma lconf_upd:\n  \"\\<lbrakk> P,h \\<turnstile> l (:\\<le>) E; P,h \\<turnstile> v :\\<le> T; E V = Some T \\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> l(V\\<mapsto>v) (:\\<le>) E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> l (:\\<le>) E; P,h \\<turnstile> v :\\<le> T;\n     E V = \\<lfloor>T\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> l(V \\<mapsto> v) (:\\<le>) E", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> l (:\\<le>) E; P,h \\<turnstile> v :\\<le> T;\n     E V = \\<lfloor>T\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> l(V \\<mapsto> v) (:\\<le>) E", "apply (unfold lconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>V v.\n                l V = \\<lfloor>v\\<rfloor> \\<longrightarrow>\n                (\\<exists>T.\n                    E V = \\<lfloor>T\\<rfloor> \\<and>\n                    P,h \\<turnstile> v :\\<le> T);\n     P,h \\<turnstile> v :\\<le> T; E V = \\<lfloor>T\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>Va va.\n                         (l(V \\<mapsto> v)) Va =\n                         \\<lfloor>va\\<rfloor> \\<longrightarrow>\n                         (\\<exists>T.\n                             E Va = \\<lfloor>T\\<rfloor> \\<and>\n                             P,h \\<turnstile> va :\\<le> T)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma lconf_empty[iff]: \"P,h \\<turnstile> Map.empty (:\\<le>) E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Map.empty (:\\<le>) E", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,h \\<turnstile> Map.empty (:\\<le>) E", "by(simp add:lconf_def)"], ["", "(*>*)"], ["", "lemma lconf_upd2: \"\\<lbrakk>P,h \\<turnstile> l (:\\<le>) E; P,h \\<turnstile> v :\\<le> T\\<rbrakk> \\<Longrightarrow> P,h \\<turnstile> l(V\\<mapsto>v) (:\\<le>) E(V\\<mapsto>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> l (:\\<le>) E;\n     P,h \\<turnstile> v :\\<le> T\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> l(V \\<mapsto> v) (:\\<le>) E(V \n                      \\<mapsto> T)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> l (:\\<le>) E;\n     P,h \\<turnstile> v :\\<le> T\\<rbrakk>\n    \\<Longrightarrow> P,h \\<turnstile> l(V \\<mapsto> v) (:\\<le>) E(V \n                      \\<mapsto> T)", "by(simp add:lconf_def)"], ["", "(*>*)"], ["", "end"]]}