{"file_name": "/home/qj213/afp-2021-10-22/thys/KAT_and_DRA/SingleSorted/DRA_Models.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KAT_and_DRA", "problem_names": ["lemma top_max: \"f \\<le> top\"", "lemma bot_min: \"bot \\<le> f\"", "lemma oder_def: \"f \\<sqinter> g = f \\<Longrightarrow> f \\<le> g\"", "lemma order_def_var: \"f \\<le> g \\<Longrightarrow> f \\<sqinter> g = f\"", "lemma adjoint_idem [simp]: \"adjoint (adjoint f) = f\"", "lemma adjoint_prop1[simp]: \"(f o top) \\<sqinter> (adjoint f o bot) = bot\"", "lemma adjoint_prop2[simp]: \"(f o top) + (adjoint f o bot) = top\"", "lemma adjoint_mult: \"adjoint (f o g) = adjoint f o adjoint g\"", "lemma adjoint_top[simp]: \"adjoint top = bot\"", "lemma N_comp1: \"(N (N f)) + N f = id\"", "lemma N_comp2: \"(N (N f)) o N f = bot\"", "lemma N_comp3: \"N f o (N (N f)) = bot\"", "lemma N_de_morgan: \"N (N f) o N (N g) = N (N f) \\<sqinter> N (N g)\"", "lemma conj_pred_aux [simp]: \"(\\<lambda>p. x p \\<union> y p) = y \\<Longrightarrow> \\<forall>p. x p \\<subseteq> y p\""], "translations": [["", "lemma top_max: \"f \\<le> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<le> DRA_Models.top", "by (auto simp: top_def fun_order_def)"], ["", "lemma bot_min: \"bot \\<le> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DRA_Models.bot \\<le> f", "by (auto simp: bot_def fun_order_def)"], ["", "lemma oder_def: \"f \\<sqinter> g = f \\<Longrightarrow> f \\<le> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sqinter> g = f \\<Longrightarrow> f \\<le> g", "by (metis fun_inter_def fun_order_def le_iff_inf)"], ["", "lemma order_def_var: \"f \\<le> g \\<Longrightarrow> f \\<sqinter> g = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<le> g \\<Longrightarrow> f \\<sqinter> g = f", "by (auto simp: fun_inter_def fun_order_def)"], ["", "lemma adjoint_idem [simp]: \"adjoint (adjoint f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (adjoint f) = f", "by (auto simp: adjoint_def)"], ["", "lemma adjoint_prop1[simp]: \"(f o top) \\<sqinter> (adjoint f o bot) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> DRA_Models.top \\<sqinter> adjoint f \\<cdot> DRA_Models.bot =\n    DRA_Models.bot", "by (auto simp: fun_inter_def adjoint_def bot_def top_def)"], ["", "lemma adjoint_prop2[simp]: \"(f o top) + (adjoint f o bot) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> DRA_Models.top + adjoint f \\<cdot> DRA_Models.bot =\n    DRA_Models.top", "by (auto simp: fun_union_def adjoint_def bot_def top_def)"], ["", "lemma adjoint_mult: \"adjoint (f o g) = adjoint f o adjoint g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (f \\<cdot> g) = adjoint f \\<cdot> adjoint g", "by (auto simp: adjoint_def)"], ["", "lemma adjoint_top[simp]: \"adjoint top = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint DRA_Models.top = DRA_Models.bot", "by (auto simp: adjoint_def bot_def top_def)"], ["", "lemma N_comp1: \"(N (N f)) + N f = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (N f) + N f = id", "by (auto simp: fun_union_def N_def fun_inter_def adjoint_def bot_def)"], ["", "lemma N_comp2: \"(N (N f)) o N f = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (N f) \\<cdot> N f = DRA_Models.bot", "by (auto simp: N_def fun_inter_def adjoint_def bot_def)"], ["", "lemma N_comp3: \"N f o (N (N f)) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N f \\<cdot> N (N f) = DRA_Models.bot", "by (auto simp: N_def fun_inter_def adjoint_def bot_def)"], ["", "lemma N_de_morgan: \"N (N f) o N (N g) = N (N f) \\<sqinter> N (N g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (N f) \\<cdot> N (N g) = N (N f) \\<sqinter> N (N g)", "by (auto simp: fun_union_def N_def fun_inter_def adjoint_def bot_def)"], ["", "lemma conj_pred_aux [simp]: \"(\\<lambda>p. x p \\<union> y p) = y \\<Longrightarrow> \\<forall>p. x p \\<subseteq> y p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p. x p \\<union> y p) = y \\<Longrightarrow>\n    \\<forall>p. x p \\<subseteq> y p", "by (metis Un_upper1)"], ["", "text \\<open>\n  Next, we define a type for conjuctive or multiplicative predicate transformers.\n\\<close>"], ["", "typedef 'a bool_op = \"{f::'a bfun. (\\<forall>g h. mono f \\<and> f \\<circ> g + f \\<circ> h = f \\<circ> (g + h) \\<and> bot o f = bot)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {f. \\<forall>g h.\n                      mono f \\<and>\n                      f \\<cdot> g + f \\<cdot> h = f \\<cdot> (g + h) \\<and>\n                      DRA_Models.bot \\<cdot> f = DRA_Models.bot}", "apply (rule_tac x=\"\\<lambda>x. x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x)\n    \\<in> {f. \\<forall>g h.\n                 mono f \\<and>\n                 f \\<cdot> g + f \\<cdot> h = f \\<cdot> (g + h) \\<and>\n                 DRA_Models.bot \\<cdot> f = DRA_Models.bot}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono (\\<lambda>x. x)\n 2. \\<And>g h.\n       (\\<lambda>x. x) \\<cdot> g + (\\<lambda>x. x) \\<cdot> h =\n       (\\<lambda>x. x) \\<cdot> (g + h)", "apply (metis monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g h.\n       (\\<lambda>x. x) \\<cdot> g + (\\<lambda>x. x) \\<cdot> h =\n       (\\<lambda>x. x) \\<cdot> (g + h)", "by (auto simp: fun_order_def fun_union_def)"], ["", "setup_lifting type_definition_bool_op"], ["", "text \\<open>\n  Conjuctive predicate transformers form a dioid with tests without right annihilator.\n\\<close>"], ["", "instantiation bool_op :: (type) dioid_one_zerol \nbegin"], ["", "lift_definition less_eq_bool_op :: \"'a bool_op \\<Rightarrow> 'a bool_op \\<Rightarrow> bool\" is fun_order"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_bool_op :: \"'a bool_op \\<Rightarrow> 'a bool_op \\<Rightarrow> bool\" is \"(<.)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition zero_bool_op :: \"'a bool_op\" is \"bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       mono DRA_Models.bot \\<and>\n       DRA_Models.bot \\<cdot> fun1 + DRA_Models.bot \\<cdot> fun2 =\n       DRA_Models.bot \\<cdot> (fun1 + fun2) \\<and>\n       DRA_Models.bot \\<cdot> DRA_Models.bot = DRA_Models.bot", "by (auto simp: bot_def fun_union_def fun_order_def mono_def)"], ["", "lift_definition one_bool_op :: \"'a bool_op\" is \"id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       mono id \\<and>\n       id \\<cdot> fun1 + id \\<cdot> fun2 = id \\<cdot> (fun1 + fun2) \\<and>\n       DRA_Models.bot \\<cdot> id = DRA_Models.bot", "by (auto simp: fun_union_def fun_order_def mono_def)"], ["", "lift_definition times_bool_op :: \"'a bool_op \\<Rightarrow> 'a bool_op \\<Rightarrow> 'a bool_op\" is \"(o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>\\<And>g h.\n                   mono fun1 \\<and>\n                   fun1 \\<cdot> g + fun1 \\<cdot> h =\n                   fun1 \\<cdot> (g + h) \\<and>\n                   DRA_Models.bot \\<cdot> fun1 = DRA_Models.bot;\n        \\<And>g h.\n           mono fun2 \\<and>\n           fun2 \\<cdot> g + fun2 \\<cdot> h = fun2 \\<cdot> (g + h) \\<and>\n           DRA_Models.bot \\<cdot> fun2 = DRA_Models.bot\\<rbrakk>\n       \\<Longrightarrow> mono (fun1 \\<cdot> fun2) \\<and>\n                         fun1 \\<cdot> fun2 \\<cdot> fun3 +\n                         fun1 \\<cdot> fun2 \\<cdot> fun4 =\n                         fun1 \\<cdot> fun2 \\<cdot> (fun3 + fun4) \\<and>\n                         DRA_Models.bot \\<cdot> (fun1 \\<cdot> fun2) =\n                         DRA_Models.bot", "by (auto simp: o_def fun_union_def fun_order_def bot_def mono_def) metis"], ["", "lift_definition plus_bool_op :: \"'a bool_op \\<Rightarrow> 'a bool_op \\<Rightarrow> 'a bool_op\" is \"(+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>\\<And>g h.\n                   mono fun1 \\<and>\n                   fun1 \\<cdot> g + fun1 \\<cdot> h =\n                   fun1 \\<cdot> (g + h) \\<and>\n                   DRA_Models.bot \\<cdot> fun1 = DRA_Models.bot;\n        \\<And>g h.\n           mono fun2 \\<and>\n           fun2 \\<cdot> g + fun2 \\<cdot> h = fun2 \\<cdot> (g + h) \\<and>\n           DRA_Models.bot \\<cdot> fun2 = DRA_Models.bot\\<rbrakk>\n       \\<Longrightarrow> mono (fun1 + fun2) \\<and>\n                         (fun1 + fun2) \\<cdot> fun3 +\n                         (fun1 + fun2) \\<cdot> fun4 =\n                         (fun1 + fun2) \\<cdot> (fun3 + fun4) \\<and>\n                         DRA_Models.bot \\<cdot> (fun1 + fun2) =\n                         DRA_Models.bot", "apply (auto simp: o_def fun_union_def fun_order_def bot_def mono_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 x y xa.\n       \\<lbrakk>\\<And>g h.\n                   (\\<forall>x y.\n                       x \\<subseteq> y \\<longrightarrow>\n                       fun1 x \\<subseteq> fun1 y) \\<and>\n                   (\\<lambda>p. fun1 (g p) \\<union> fun1 (h p)) =\n                   (\\<lambda>x. fun1 (g x \\<union> h x));\n        \\<And>g h.\n           (\\<forall>x y.\n               x \\<subseteq> y \\<longrightarrow>\n               fun2 x \\<subseteq> fun2 y) \\<and>\n           (\\<lambda>p. fun2 (g p) \\<union> fun2 (h p)) =\n           (\\<lambda>x. fun2 (g x \\<union> h x));\n        x \\<subseteq> y; xa \\<in> fun1 x; xa \\<notin> fun2 y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> fun1 y\n 2. \\<And>fun1 fun2 x y xa.\n       \\<lbrakk>\\<And>g h.\n                   (\\<forall>x y.\n                       x \\<subseteq> y \\<longrightarrow>\n                       fun1 x \\<subseteq> fun1 y) \\<and>\n                   (\\<lambda>p. fun1 (g p) \\<union> fun1 (h p)) =\n                   (\\<lambda>x. fun1 (g x \\<union> h x));\n        \\<And>g h.\n           (\\<forall>x y.\n               x \\<subseteq> y \\<longrightarrow>\n               fun2 x \\<subseteq> fun2 y) \\<and>\n           (\\<lambda>p. fun2 (g p) \\<union> fun2 (h p)) =\n           (\\<lambda>x. fun2 (g x \\<union> h x));\n        x \\<subseteq> y; xa \\<in> fun2 x; xa \\<notin> fun2 y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> fun1 y\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>\\<And>g h.\n                   (\\<forall>x y.\n                       x \\<subseteq> y \\<longrightarrow>\n                       fun1 x \\<subseteq> fun1 y) \\<and>\n                   (\\<lambda>p. fun1 (g p) \\<union> fun1 (h p)) =\n                   (\\<lambda>x. fun1 (g x \\<union> h x));\n        \\<And>g h.\n           (\\<forall>x y.\n               x \\<subseteq> y \\<longrightarrow>\n               fun2 x \\<subseteq> fun2 y) \\<and>\n           (\\<lambda>p. fun2 (g p) \\<union> fun2 (h p)) =\n           (\\<lambda>x. fun2 (g x \\<union> h x))\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>p.\n                             fun1 (fun3 p) \\<union> fun2 (fun3 p) \\<union>\n                             (fun1 (fun4 p) \\<union> fun2 (fun4 p))) =\n                         (\\<lambda>x.\n                             fun1 (fun3 x \\<union> fun4 x) \\<union>\n                             fun2 (fun3 x \\<union> fun4 x))", "apply (metis subsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 x y xa.\n       \\<lbrakk>\\<And>g h.\n                   (\\<forall>x y.\n                       x \\<subseteq> y \\<longrightarrow>\n                       fun1 x \\<subseteq> fun1 y) \\<and>\n                   (\\<lambda>p. fun1 (g p) \\<union> fun1 (h p)) =\n                   (\\<lambda>x. fun1 (g x \\<union> h x));\n        \\<And>g h.\n           (\\<forall>x y.\n               x \\<subseteq> y \\<longrightarrow>\n               fun2 x \\<subseteq> fun2 y) \\<and>\n           (\\<lambda>p. fun2 (g p) \\<union> fun2 (h p)) =\n           (\\<lambda>x. fun2 (g x \\<union> h x));\n        x \\<subseteq> y; xa \\<in> fun2 x; xa \\<notin> fun2 y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> fun1 y\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>\\<And>g h.\n                   (\\<forall>x y.\n                       x \\<subseteq> y \\<longrightarrow>\n                       fun1 x \\<subseteq> fun1 y) \\<and>\n                   (\\<lambda>p. fun1 (g p) \\<union> fun1 (h p)) =\n                   (\\<lambda>x. fun1 (g x \\<union> h x));\n        \\<And>g h.\n           (\\<forall>x y.\n               x \\<subseteq> y \\<longrightarrow>\n               fun2 x \\<subseteq> fun2 y) \\<and>\n           (\\<lambda>p. fun2 (g p) \\<union> fun2 (h p)) =\n           (\\<lambda>x. fun2 (g x \\<union> h x))\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>p.\n                             fun1 (fun3 p) \\<union> fun2 (fun3 p) \\<union>\n                             (fun1 (fun4 p) \\<union> fun2 (fun4 p))) =\n                         (\\<lambda>x.\n                             fun1 (fun3 x \\<union> fun4 x) \\<union>\n                             fun2 (fun3 x \\<union> fun4 x))", "apply (metis subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>\\<And>g h.\n                   (\\<forall>x y.\n                       x \\<subseteq> y \\<longrightarrow>\n                       fun1 x \\<subseteq> fun1 y) \\<and>\n                   (\\<lambda>p. fun1 (g p) \\<union> fun1 (h p)) =\n                   (\\<lambda>x. fun1 (g x \\<union> h x));\n        \\<And>g h.\n           (\\<forall>x y.\n               x \\<subseteq> y \\<longrightarrow>\n               fun2 x \\<subseteq> fun2 y) \\<and>\n           (\\<lambda>p. fun2 (g p) \\<union> fun2 (h p)) =\n           (\\<lambda>x. fun2 (g x \\<union> h x))\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>p.\n                             fun1 (fun3 p) \\<union> fun2 (fun3 p) \\<union>\n                             (fun1 (fun4 p) \\<union> fun2 (fun4 p))) =\n                         (\\<lambda>x.\n                             fun1 (fun3 x \\<union> fun4 x) \\<union>\n                             fun2 (fun3 x \\<union> fun4 x))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4 p.\n       \\<lbrakk>\\<And>g h.\n                   (\\<forall>x y.\n                       x \\<subseteq> y \\<longrightarrow>\n                       fun1 x \\<subseteq> fun1 y) \\<and>\n                   (\\<lambda>p. fun1 (g p) \\<union> fun1 (h p)) =\n                   (\\<lambda>x. fun1 (g x \\<union> h x));\n        \\<And>g h.\n           (\\<forall>x y.\n               x \\<subseteq> y \\<longrightarrow>\n               fun2 x \\<subseteq> fun2 y) \\<and>\n           (\\<lambda>p. fun2 (g p) \\<union> fun2 (h p)) =\n           (\\<lambda>x. fun2 (g x \\<union> h x))\\<rbrakk>\n       \\<Longrightarrow> fun1 (fun3 p) \\<union> fun2 (fun3 p) \\<union>\n                         (fun1 (fun4 p) \\<union> fun2 (fun4 p)) =\n                         fun1 (fun3 p \\<union> fun4 p) \\<union>\n                         fun2 (fun3 p \\<union> fun4 p)", "by (metis (no_types, lifting) semilattice_sup_class.sup.assoc semilattice_sup_class.sup.left_commute)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a bool_op, dioid_one_zerol_class)", "by standard (transfer, auto simp: fun_order_def fun_strict_order_def fun_union_def bot_def)+"], ["", "end"], ["", "instantiation bool_op :: (type) test_semiring_zerol \nbegin"], ["", "lift_definition n_op_bool_op :: \"'a bool_op \\<Rightarrow> 'a bool_op\" is \"N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3.\n       (\\<And>g h.\n           mono fun1 \\<and>\n           fun1 \\<cdot> g + fun1 \\<cdot> h = fun1 \\<cdot> (g + h) \\<and>\n           DRA_Models.bot \\<cdot> fun1 = DRA_Models.bot) \\<Longrightarrow>\n       mono (N fun1) \\<and>\n       N fun1 \\<cdot> fun2 + N fun1 \\<cdot> fun3 =\n       N fun1 \\<cdot> (fun2 + fun3) \\<and>\n       DRA_Models.bot \\<cdot> N fun1 = DRA_Models.bot", "by (auto simp: N_def fun_inter_def adjoint_def bot_def fun_union_def mono_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a bool_op, test_semiring_zerol_class)", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. !(!1) = 1\n 2. \\<And>x y. !(!(!x \\<cdot> !y)) = !x \\<cdot> !y\n 3. \\<And>x. !x \\<cdot> !(!x) = 0\n 4. \\<And>x y. !(!(!x) \\<cdot> !(!y)) = plus (!x) (!y)", "apply (transfer, clarsimp simp add: N_def adjoint_def bot_def id_def comp_def fun_inter_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. !(!(!x \\<cdot> !y)) = !x \\<cdot> !y\n 2. \\<And>x. !x \\<cdot> !(!x) = 0\n 3. \\<And>x y. !(!(!x) \\<cdot> !(!y)) = plus (!x) (!y)", "apply (transfer, clarsimp simp add: N_def adjoint_def bot_def id_def comp_def fun_inter_def fun_union_def mono_def, blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. !x \\<cdot> !(!x) = 0\n 2. \\<And>x y. !(!(!x) \\<cdot> !(!y)) = plus (!x) (!y)", "apply (transfer, clarsimp simp add: N_def adjoint_def bot_def comp_def mono_def fun_union_def fun_inter_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. !(!(!x) \\<cdot> !(!y)) = plus (!x) (!y)", "by (transfer, clarsimp simp add: N_def adjoint_def bot_def comp_def mono_def fun_union_def fun_inter_def, blast)"], ["", "end"], ["", "definition fun_star :: \"'a bfun \\<Rightarrow> 'a bfun\" where\n  \"fun_star f = lfp (\\<lambda>r. f o r + id)\""], ["", "definition fun_iteration :: \"'a bfun \\<Rightarrow> 'a bfun\" where\n  \"fun_iteration f = gfp (\\<lambda>g. f o g + id)\""], ["", "text \\<open>\n  Verifying the iteration laws is left for future work. This could be obtained by integrating\n  Preoteasa's approach~\\cite{Preoteasa11}.\n\\<close>"], ["", "end"]]}