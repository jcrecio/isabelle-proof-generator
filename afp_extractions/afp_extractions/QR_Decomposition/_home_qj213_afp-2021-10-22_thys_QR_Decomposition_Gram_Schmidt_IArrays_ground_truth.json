{"file_name": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition/Gram_Schmidt_IArrays.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition", "problem_names": ["lemma plus_iarray_component:\n  assumes iA: \"i<IArray.length A\"\n  and iB: \"i<IArray.length B\"\n  shows \"(A+B) !! i = A!!i + B!!i\"", "lemma minus_iarray_component:\n  assumes iA: \"i<IArray.length A\"\n  and iB: \"i<IArray.length B\"\n  shows \"(A-B) !! i = A!!i - B!!i\"", "lemma length_plus_iarray:\n  \"IArray.length (A+B)=max (IArray.length A) (IArray.length B)\"", "lemma length_sum_iarray:\n  assumes \"finite S\" and \"S\\<noteq>{}\"\n  shows \"IArray.length (sum f S) = Max {IArray.length (f x)| x. x \\<in> S}\"", "lemma sum_component_iarray:\n  assumes a: \"\\<forall>x\\<in>S. i<IArray.length (f x)\"\n  and f: \"finite S\"\n  and S: \"S\\<noteq>{}\" \\<comment> \\<open>If S is empty, then the sum will return the empty \n  iarray and it makes no sense to access the component i\\<close>\n  shows \"sum f S !! i = (\\<Sum>x\\<in>S. f x !! i)\"", "lemma length_zero_iarray: \"IArray.length 0 = 0\"", "lemma minus_zero_iarray:\n  fixes A::\"'a::{group_add} iarray\"\n  shows \"A - 0 = A\"", "lemma vec_to_iarray_inner:\n  \"a \\<bullet> b = vec_to_iarray a \\<bullet>i vec_to_iarray b\"", "lemma vec_to_iarray_scaleR: \n  \"vec_to_iarray (a *\\<^sub>R x) = a *\\<^sub>R (vec_to_iarray x)\"", "lemma matrix_to_iarray_Gram_Schmidt_column_k:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  shows \"matrix_to_iarray (Gram_Schmidt_column_k A k) = Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k\"", "lemma matrix_to_iarray_Gram_Schmidt_upt_k:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  shows \"matrix_to_iarray (Gram_Schmidt_upt_k A k) = Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k\"", "lemma matrix_to_iarray_Gram_Schmidt_matrix[code_unfold]:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (Gram_Schmidt_matrix A) = Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)\""], "translations": [["", "lemma plus_iarray_component:\n  assumes iA: \"i<IArray.length A\"\n  and iB: \"i<IArray.length B\"\n  shows \"(A+B) !! i = A!!i + B!!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A + B) !! i = A !! i + B !! i", "proof (unfold plus_iarray_def Let_def )"], ["proof (state)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a +\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i + B !! i", "have \"IArray.of_fun\n    (\\<lambda>a. IArray.of_fun (\\<lambda>a. if a < IArray.length A then A !! a else 0) (max (IArray.length A) (IArray.length B)) !! a +\n    IArray.of_fun (\\<lambda>a. if a < IArray.length B then B !! a else 0) (max (IArray.length A) (IArray.length B)) !! a)\n    (max (IArray.length A) (IArray.length B)) !!\n    i = IArray.of_fun (\\<lambda>a. if a < IArray.length A then A !! a else 0) (max (IArray.length A) (IArray.length B)) !! i +\n    IArray.of_fun (\\<lambda>a. if a < IArray.length B then B !! a else 0) (max (IArray.length A) (IArray.length B)) !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a +\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    IArray.of_fun\n     (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i +\n    IArray.of_fun\n     (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i", "by (rule of_fun_nth, metis iB less_max_iff_disj)"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a +\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a)\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i +\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a +\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i + B !! i", "also"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a +\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a)\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i +\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a +\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i + B !! i", "have \"...= (\\<lambda>a. if a < IArray.length A then A !! a else 0) i + \n    (\\<lambda>a. if a < IArray.length B then B !! a else 0) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i +\n    IArray.of_fun\n     (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    (if i < IArray.length A then A !! i else (0::'a)) +\n    (if i < IArray.length B then B !! i else (0::'a))", "using of_fun_nth[of i \"(max (IArray.length A) (IArray.length B))\"]"], ["proof (prove)\nusing this:\n  i < max (IArray.length A) (IArray.length B) \\<Longrightarrow>\n  IArray.of_fun ?f (max (IArray.length A) (IArray.length B)) !! i = ?f i\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i +\n    IArray.of_fun\n     (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    (if i < IArray.length A then A !! i else (0::'a)) +\n    (if i < IArray.length B then B !! i else (0::'a))", "using iB"], ["proof (prove)\nusing this:\n  i < max (IArray.length A) (IArray.length B) \\<Longrightarrow>\n  IArray.of_fun ?f (max (IArray.length A) (IArray.length B)) !! i = ?f i\n  i < IArray.length B\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i +\n    IArray.of_fun\n     (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    (if i < IArray.length A then A !! i else (0::'a)) +\n    (if i < IArray.length B then B !! i else (0::'a))", "by simp"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i +\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  (if i < IArray.length A then A !! i else (0::'a)) +\n  (if i < IArray.length B then B !! i else (0::'a))\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a +\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i + B !! i", "also"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i +\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  (if i < IArray.length A then A !! i else (0::'a)) +\n  (if i < IArray.length B then B !! i else (0::'a))\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a +\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i + B !! i", "have \"...= A!!i + B !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < IArray.length A then A !! i else (0::'a)) +\n    (if i < IArray.length B then B !! i else (0::'a)) =\n    A !! i + B !! i", "using iA iB"], ["proof (prove)\nusing this:\n  i < IArray.length A\n  i < IArray.length B\n\ngoal (1 subgoal):\n 1. (if i < IArray.length A then A !! i else (0::'a)) +\n    (if i < IArray.length B then B !! i else (0::'a)) =\n    A !! i + B !! i", "by simp"], ["proof (state)\nthis:\n  (if i < IArray.length A then A !! i else (0::'a)) +\n  (if i < IArray.length B then B !! i else (0::'a)) =\n  A !! i + B !! i\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a +\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i + B !! i", "finally"], ["proof (chain)\npicking this:\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a +\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a)\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  A !! i + B !! i", "show \"IArray.of_fun\n    (\\<lambda>a. IArray.of_fun (\\<lambda>a. if a < IArray.length A then A !! a else 0) (max (IArray.length A) (IArray.length B)) !! a +\n    IArray.of_fun (\\<lambda>a. if a < IArray.length B then B !! a else 0) (max (IArray.length A) (IArray.length B)) !! a)\n    (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i + B !! i\""], ["proof (prove)\nusing this:\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a +\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a)\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  A !! i + B !! i\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a +\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i + B !! i", "."], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a +\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a)\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  A !! i + B !! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minus_iarray_component:\n  assumes iA: \"i<IArray.length A\"\n  and iB: \"i<IArray.length B\"\n  shows \"(A-B) !! i = A!!i - B!!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - B) !! i = A !! i - B !! i", "proof (unfold minus_iarray_def Let_def )"], ["proof (state)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i - B !! i", "have \"IArray.of_fun\n    (\\<lambda>a. IArray.of_fun (\\<lambda>a. if a < IArray.length A then A !! a else 0) (max (IArray.length A) (IArray.length B)) !! a -\n    IArray.of_fun (\\<lambda>a. if a < IArray.length B then B !! a else 0) (max (IArray.length A) (IArray.length B)) !! a)\n    (max (IArray.length A) (IArray.length B)) !!\n    i = IArray.of_fun (\\<lambda>a. if a < IArray.length A then A !! a else 0) (max (IArray.length A) (IArray.length B)) !! i -\n    IArray.of_fun (\\<lambda>a. if a < IArray.length B then B !! a else 0) (max (IArray.length A) (IArray.length B)) !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    IArray.of_fun\n     (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i -\n    IArray.of_fun\n     (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i", "by (rule of_fun_nth, metis iB less_max_iff_disj)"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a -\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a)\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i -\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i - B !! i", "also"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a -\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a)\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i -\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i - B !! i", "have \"...= (\\<lambda>a. if a < IArray.length A then A !! a else 0) i - \n    (\\<lambda>a. if a < IArray.length B then B !! a else 0) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i -\n    IArray.of_fun\n     (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    (if i < IArray.length A then A !! i else (0::'a)) -\n    (if i < IArray.length B then B !! i else (0::'a))", "using of_fun_nth[of i \"(max (IArray.length A) (IArray.length B))\"]"], ["proof (prove)\nusing this:\n  i < max (IArray.length A) (IArray.length B) \\<Longrightarrow>\n  IArray.of_fun ?f (max (IArray.length A) (IArray.length B)) !! i = ?f i\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i -\n    IArray.of_fun\n     (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    (if i < IArray.length A then A !! i else (0::'a)) -\n    (if i < IArray.length B then B !! i else (0::'a))", "using iB"], ["proof (prove)\nusing this:\n  i < max (IArray.length A) (IArray.length B) \\<Longrightarrow>\n  IArray.of_fun ?f (max (IArray.length A) (IArray.length B)) !! i = ?f i\n  i < IArray.length B\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i -\n    IArray.of_fun\n     (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    (if i < IArray.length A then A !! i else (0::'a)) -\n    (if i < IArray.length B then B !! i else (0::'a))", "by simp"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i -\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  (if i < IArray.length A then A !! i else (0::'a)) -\n  (if i < IArray.length B then B !! i else (0::'a))\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i - B !! i", "also"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i -\n  IArray.of_fun\n   (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  (if i < IArray.length A then A !! i else (0::'a)) -\n  (if i < IArray.length B then B !! i else (0::'a))\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i - B !! i", "have \"...= A!!i - B !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < IArray.length A then A !! i else (0::'a)) -\n    (if i < IArray.length B then B !! i else (0::'a)) =\n    A !! i - B !! i", "using iA iB"], ["proof (prove)\nusing this:\n  i < IArray.length A\n  i < IArray.length B\n\ngoal (1 subgoal):\n 1. (if i < IArray.length A then A !! i else (0::'a)) -\n    (if i < IArray.length B then B !! i else (0::'a)) =\n    A !! i - B !! i", "by simp"], ["proof (state)\nthis:\n  (if i < IArray.length A then A !! i else (0::'a)) -\n  (if i < IArray.length B then B !! i else (0::'a)) =\n  A !! i - B !! i\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i - B !! i", "finally"], ["proof (chain)\npicking this:\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a -\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a)\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  A !! i - B !! i", "show \"IArray.of_fun\n    (\\<lambda>a. IArray.of_fun (\\<lambda>a. if a < IArray.length A then A !! a else 0) (max (IArray.length A) (IArray.length B)) !! a -\n    IArray.of_fun (\\<lambda>a. if a < IArray.length B then B !! a else 0) (max (IArray.length A) (IArray.length B)) !! a)\n    (max (IArray.length A) (IArray.length B)) !! i = A !! i - B !! i\""], ["proof (prove)\nusing this:\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a -\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a)\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  A !! i - B !! i\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n          (max (IArray.length A) (IArray.length B)) !!\n         a)\n     (max (IArray.length A) (IArray.length B)) !!\n    i =\n    A !! i - B !! i", "."], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a -\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n        (max (IArray.length A) (IArray.length B)) !!\n       a)\n   (max (IArray.length A) (IArray.length B)) !!\n  i =\n  A !! i - B !! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_plus_iarray:\n  \"IArray.length (A+B)=max (IArray.length A) (IArray.length B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (A + B) = max (IArray.length A) (IArray.length B)", "unfolding plus_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray.of_fun\n       (\\<lambda>a.\n           IArray.of_fun\n            (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n            (max (IArray.length A) (IArray.length B)) !!\n           a +\n           IArray.of_fun\n            (\\<lambda>a. if a < IArray.length B then B !! a else (0::'a))\n            (max (IArray.length A) (IArray.length B)) !!\n           a)\n       (max (IArray.length A) (IArray.length B))) =\n    max (IArray.length A) (IArray.length B)", "by auto"], ["", "lemma length_sum_iarray:\n  assumes \"finite S\" and \"S\\<noteq>{}\"\n  shows \"IArray.length (sum f S) = Max {IArray.length (f x)| x. x \\<in> S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (sum f S) = Max {IArray.length (f x) |x. x \\<in> S}", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. IArray.length (sum f S) = Max {IArray.length (f x) |x. x \\<in> S}", "proof (induct S,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow>\n        IArray.length (sum f F) = Max {IArray.length (f x) |x. x \\<in> F};\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> IArray.length (sum f (insert x F)) =\n                         Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  F \\<noteq> {} \\<Longrightarrow>\n  IArray.length (sum f F) = Max {IArray.length (f x) |x. x \\<in> F}\n  insert x F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow>\n        IArray.length (sum f F) = Max {IArray.length (f x) |x. x \\<in> F};\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> IArray.length (sum f (insert x F)) =\n                         Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "show?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "proof (cases \"F={}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. F = {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}\n 2. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "case True"], ["proof (state)\nthis:\n  F = {}\n\ngoal (2 subgoals):\n 1. F = {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}\n 2. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (sum f {x}) = Max {IArray.length (f xa) |xa. xa \\<in> {x}}", "by auto"], ["proof (state)\nthis:\n  IArray.length (sum f (insert x F)) =\n  Max {IArray.length (f xa) |xa. xa \\<in> insert x F}\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "case False"], ["proof (state)\nthis:\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "have rw: \"IArray.length (sum f F) = Max {IArray.length (f x) |x. x \\<in> F}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (sum f F) = Max {IArray.length (f x) |x. x \\<in> F}", "by (rule insert.hyps, simp add: False)"], ["proof (state)\nthis:\n  IArray.length (sum f F) = Max {IArray.length (f x) |x. x \\<in> F}\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "have set_rw: \"(insert (IArray.length (f x)) {IArray.length (f x) |x. x \\<in> F}) = {IArray.length (f a) |a. a \\<in> insert x F}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (IArray.length (f x)) {IArray.length (f x) |x. x \\<in> F} =\n    {IArray.length (f a) |a. a \\<in> insert x F}", "by auto"], ["proof (state)\nthis:\n  insert (IArray.length (f x)) {IArray.length (f x) |x. x \\<in> F} =\n  {IArray.length (f a) |a. a \\<in> insert x F}\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "have \"IArray.length (sum f (insert x F)) = IArray.length (f x + sum f F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (sum f (insert x F)) = IArray.length (f x + sum f F)", "by (metis insert.hyps(1) insert.hyps(2) sum_clauses(2))"], ["proof (state)\nthis:\n  IArray.length (sum f (insert x F)) = IArray.length (f x + sum f F)\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "also"], ["proof (state)\nthis:\n  IArray.length (sum f (insert x F)) = IArray.length (f x + sum f F)\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "have \"... = max (IArray.length (f x)) (IArray.length (sum f F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (f x + sum f F) =\n    max (IArray.length (f x)) (IArray.length (sum f F))", "unfolding length_plus_iarray"], ["proof (prove)\ngoal (1 subgoal):\n 1. max (IArray.length (f x)) (IArray.length (sum f F)) =\n    max (IArray.length (f x)) (IArray.length (sum f F))", ".."], ["proof (state)\nthis:\n  IArray.length (f x + sum f F) =\n  max (IArray.length (f x)) (IArray.length (sum f F))\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "also"], ["proof (state)\nthis:\n  IArray.length (f x + sum f F) =\n  max (IArray.length (f x)) (IArray.length (sum f F))\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "have \"... = max (IArray.length (f x)) (Max {IArray.length (f a) |a. a \\<in> F})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (IArray.length (f x)) (IArray.length (sum f F)) =\n    max (IArray.length (f x)) (Max {IArray.length (f a) |a. a \\<in> F})", "unfolding rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. max (IArray.length (f x)) (Max {IArray.length (f x) |x. x \\<in> F}) =\n    max (IArray.length (f x)) (Max {IArray.length (f a) |a. a \\<in> F})", "by simp"], ["proof (state)\nthis:\n  max (IArray.length (f x)) (IArray.length (sum f F)) =\n  max (IArray.length (f x)) (Max {IArray.length (f a) |a. a \\<in> F})\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "also"], ["proof (state)\nthis:\n  max (IArray.length (f x)) (IArray.length (sum f F)) =\n  max (IArray.length (f x)) (Max {IArray.length (f a) |a. a \\<in> F})\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "have \"... =  Max (insert (IArray.length (f x)) {IArray.length (f a) |a. a \\<in> F})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (IArray.length (f x)) (Max {IArray.length (f a) |a. a \\<in> F}) =\n    Max (insert (IArray.length (f x)) {IArray.length (f a) |a. a \\<in> F})", "proof(rule Max_insert[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {IArray.length (f a) |a. a \\<in> F}\n 2. {IArray.length (f a) |a. a \\<in> F} \\<noteq> {}", "show \"finite {IArray.length (f x) |x. x \\<in> F}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {IArray.length (f x) |x. x \\<in> F}", "using insert.hyps(1)"], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. finite {IArray.length (f x) |x. x \\<in> F}", "by auto"], ["proof (state)\nthis:\n  finite {IArray.length (f x) |x. x \\<in> F}\n\ngoal (1 subgoal):\n 1. {IArray.length (f a) |a. a \\<in> F} \\<noteq> {}", "show \"{IArray.length (f x) |x. x \\<in> F} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {IArray.length (f x) |x. x \\<in> F} \\<noteq> {}", "by (metis (lifting, mono_tags) False empty_Collect_eq ex_in_conv)"], ["proof (state)\nthis:\n  {IArray.length (f x) |x. x \\<in> F} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max (IArray.length (f x)) (Max {IArray.length (f a) |a. a \\<in> F}) =\n  Max (insert (IArray.length (f x)) {IArray.length (f a) |a. a \\<in> F})\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "also"], ["proof (state)\nthis:\n  max (IArray.length (f x)) (Max {IArray.length (f a) |a. a \\<in> F}) =\n  Max (insert (IArray.length (f x)) {IArray.length (f a) |a. a \\<in> F})\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "have \"...=  Max {IArray.length (f a) |a. a \\<in> insert x F}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (insert (IArray.length (f x)) {IArray.length (f a) |a. a \\<in> F}) =\n    Max {IArray.length (f a) |a. a \\<in> insert x F}", "unfolding set_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {IArray.length (f a) |a. a \\<in> insert x F} =\n    Max {IArray.length (f a) |a. a \\<in> insert x F}", ".."], ["proof (state)\nthis:\n  Max (insert (IArray.length (f x)) {IArray.length (f a) |a. a \\<in> F}) =\n  Max {IArray.length (f a) |a. a \\<in> insert x F}\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "finally"], ["proof (chain)\npicking this:\n  IArray.length (sum f (insert x F)) =\n  Max {IArray.length (f a) |a. a \\<in> insert x F}", "show ?thesis"], ["proof (prove)\nusing this:\n  IArray.length (sum f (insert x F)) =\n  Max {IArray.length (f a) |a. a \\<in> insert x F}\n\ngoal (1 subgoal):\n 1. IArray.length (sum f (insert x F)) =\n    Max {IArray.length (f xa) |xa. xa \\<in> insert x F}", "."], ["proof (state)\nthis:\n  IArray.length (sum f (insert x F)) =\n  Max {IArray.length (f xa) |xa. xa \\<in> insert x F}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IArray.length (sum f (insert x F)) =\n  Max {IArray.length (f xa) |xa. xa \\<in> insert x F}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_component_iarray:\n  assumes a: \"\\<forall>x\\<in>S. i<IArray.length (f x)\"\n  and f: \"finite S\"\n  and S: \"S\\<noteq>{}\" \\<comment> \\<open>If S is empty, then the sum will return the empty \n  iarray and it makes no sense to access the component i\\<close>\n  shows \"sum f S !! i = (\\<Sum>x\\<in>S. f x !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f S !! i = (\\<Sum>x\\<in>S. f x !! i)", "using f a S"], ["proof (prove)\nusing this:\n  finite S\n  \\<forall>x\\<in>S. i < IArray.length (f x)\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sum f S !! i = (\\<Sum>x\\<in>S. f x !! i)", "proof (induct S, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>x\\<in>F. i < IArray.length (f x);\n         F \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> sum f F !! i = (\\<Sum>x\\<in>F. f x !! i);\n        \\<forall>x\\<in>insert x F. i < IArray.length (f x);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) !! i =\n                         (\\<Sum>x\\<in>insert x F. f x !! i)", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<forall>x\\<in>F. i < IArray.length (f x); F \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> sum f F !! i = (\\<Sum>x\\<in>F. f x !! i)\n  \\<forall>x\\<in>insert x F. i < IArray.length (f x)\n  insert x F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>x\\<in>F. i < IArray.length (f x);\n         F \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> sum f F !! i = (\\<Sum>x\\<in>F. f x !! i);\n        \\<forall>x\\<in>insert x F. i < IArray.length (f x);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) !! i =\n                         (\\<Sum>x\\<in>insert x F. f x !! i)", "have finite_F: \"finite F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite F", "by (metis insert.hyps(1))"], ["proof (state)\nthis:\n  finite F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>x\\<in>F. i < IArray.length (f x);\n         F \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> sum f F !! i = (\\<Sum>x\\<in>F. f x !! i);\n        \\<forall>x\\<in>insert x F. i < IArray.length (f x);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) !! i =\n                         (\\<Sum>x\\<in>insert x F. f x !! i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "proof (cases \"F={}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. F = {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)\n 2. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "case True"], ["proof (state)\nthis:\n  F = {}\n\ngoal (2 subgoals):\n 1. F = {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)\n 2. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "have \"sum f (insert x F) !! i = f x !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (insert x F) !! i = f x !! i", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {x} !! i = f x !! i", "by auto"], ["proof (state)\nthis:\n  sum f (insert x F) !! i = f x !! i\n\ngoal (2 subgoals):\n 1. F = {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)\n 2. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "also"], ["proof (state)\nthis:\n  sum f (insert x F) !! i = f x !! i\n\ngoal (2 subgoals):\n 1. F = {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)\n 2. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "have \"... = (\\<Sum>x\\<in>insert x F. f x !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x !! i = (\\<Sum>x\\<in>{x}. f x !! i)", "by auto"], ["proof (state)\nthis:\n  f x !! i = (\\<Sum>x\\<in>insert x F. f x !! i)\n\ngoal (2 subgoals):\n 1. F = {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)\n 2. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "finally"], ["proof (chain)\npicking this:\n  sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)\n\ngoal (1 subgoal):\n 1. sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "."], ["proof (state)\nthis:\n  sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "case False"], ["proof (state)\nthis:\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "have hyp: \"(sum f F !! i)=(\\<Sum>x\\<in>F. f x !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f F !! i = (\\<Sum>x\\<in>F. f x !! i)", "proof  (rule insert.hyps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>F. i < IArray.length (f x)\n 2. F \\<noteq> {}", "show \"\\<forall>x\\<in>F. i < IArray.length (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>F. i < IArray.length (f x)", "by (metis insert.prems(1) insertCI)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>F. i < IArray.length (f x)\n\ngoal (1 subgoal):\n 1. F \\<noteq> {}", "show \"F \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<noteq> {}", "using False"], ["proof (prove)\nusing this:\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. F \\<noteq> {}", "."], ["proof (state)\nthis:\n  F \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum f F !! i = (\\<Sum>x\\<in>F. f x !! i)\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "have \"sum f (insert x F) !! i = (f x + sum f F) !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (insert x F) !! i = (f x + sum f F) !! i", "by (metis insert.hyps(1) insert.hyps(2) sum_clauses(2))"], ["proof (state)\nthis:\n  sum f (insert x F) !! i = (f x + sum f F) !! i\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "also"], ["proof (state)\nthis:\n  sum f (insert x F) !! i = (f x + sum f F) !! i\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "have \"... = (f x) !! i + (sum f F !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x + sum f F) !! i = f x !! i + sum f F !! i", "proof (rule plus_iarray_component)"], ["proof (state)\ngoal (2 subgoals):\n 1. i < IArray.length (f x)\n 2. i < IArray.length (sum f F)", "obtain a where a: \"a\\<in>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> F \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using False"], ["proof (prove)\nusing this:\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> F \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> F\n\ngoal (2 subgoals):\n 1. i < IArray.length (f x)\n 2. i < IArray.length (sum f F)", "have finite_C: \"finite {IArray.length (f x) |x. x \\<in> F}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {IArray.length (f x) |x. x \\<in> F}", "using finite_F"], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. finite {IArray.length (f x) |x. x \\<in> F}", "by auto"], ["proof (state)\nthis:\n  finite {IArray.length (f x) |x. x \\<in> F}\n\ngoal (2 subgoals):\n 1. i < IArray.length (f x)\n 2. i < IArray.length (sum f F)", "have not_empty_C: \"{IArray.length (f x) |x. x \\<in> F} \\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {IArray.length (f x) |x. x \\<in> F} \\<noteq> {}", "using False"], ["proof (prove)\nusing this:\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {IArray.length (f x) |x. x \\<in> F} \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  {IArray.length (f x) |x. x \\<in> F} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. i < IArray.length (f x)\n 2. i < IArray.length (sum f F)", "show \"i < IArray.length (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length (f x)", "by (metis insert.prems(1) insertI1)"], ["proof (state)\nthis:\n  i < IArray.length (f x)\n\ngoal (1 subgoal):\n 1. i < IArray.length (sum f F)", "show \"i < IArray.length (sum f F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length (sum f F)", "unfolding length_sum_iarray[OF finite_F False]"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < Max {IArray.length (f x) |x. x \\<in> F}", "unfolding Max_gr_iff[OF finite_C not_empty_C]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex {IArray.length (f x) |x. x \\<in> F} ((<) i)", "proof (rule bexI[of _ \"IArray.length (f a)\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. i < IArray.length (f a)\n 2. IArray.length (f a) \\<in> {IArray.length (f x) |x. x \\<in> F}", "show \"i < IArray.length (f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length (f a)", "using insert.prems(1) a"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>insert x F. i < IArray.length (f x)\n  a \\<in> F\n\ngoal (1 subgoal):\n 1. i < IArray.length (f a)", "by auto"], ["proof (state)\nthis:\n  i < IArray.length (f a)\n\ngoal (1 subgoal):\n 1. IArray.length (f a) \\<in> {IArray.length (f x) |x. x \\<in> F}", "show \"IArray.length (f a) \\<in> {IArray.length (f x) |x. x \\<in> F}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (f a) \\<in> {IArray.length (f x) |x. x \\<in> F}", "using a"], ["proof (prove)\nusing this:\n  a \\<in> F\n\ngoal (1 subgoal):\n 1. IArray.length (f a) \\<in> {IArray.length (f x) |x. x \\<in> F}", "by auto"], ["proof (state)\nthis:\n  IArray.length (f a) \\<in> {IArray.length (f x) |x. x \\<in> F}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < IArray.length (sum f F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f x + sum f F) !! i = f x !! i + sum f F !! i\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "also"], ["proof (state)\nthis:\n  (f x + sum f F) !! i = f x !! i + sum f F !! i\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "have \"...= (f x) !! i + (\\<Sum>x\\<in>F. f x !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x !! i + sum f F !! i = f x !! i + (\\<Sum>x\\<in>F. f x !! i)", "unfolding hyp"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x !! i + (\\<Sum>x\\<in>F. f x !! i) =\n    f x !! i + (\\<Sum>x\\<in>F. f x !! i)", ".."], ["proof (state)\nthis:\n  f x !! i + sum f F !! i = f x !! i + (\\<Sum>x\\<in>F. f x !! i)\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "also"], ["proof (state)\nthis:\n  f x !! i + sum f F !! i = f x !! i + (\\<Sum>x\\<in>F. f x !! i)\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "have \"...= (\\<Sum>x\\<in>insert x F. f x !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x !! i + (\\<Sum>x\\<in>F. f x !! i) =\n    (\\<Sum>x\\<in>insert x F. f x !! i)", "by (metis (mono_tags) insert.hyps(1) insert.hyps(2) sum_clauses(2))"], ["proof (state)\nthis:\n  f x !! i + (\\<Sum>x\\<in>F. f x !! i) = (\\<Sum>x\\<in>insert x F. f x !! i)\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow>\n    sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "finally"], ["proof (chain)\npicking this:\n  sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "show \"sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)\""], ["proof (prove)\nusing this:\n  sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)\n\ngoal (1 subgoal):\n 1. sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)", "."], ["proof (state)\nthis:\n  sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum f (insert x F) !! i = (\\<Sum>x\\<in>insert x F. f x !! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_zero_iarray: \"IArray.length 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length 0 = 0", "unfolding zero_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (IArray []) = 0", "by simp"], ["", "lemma minus_zero_iarray:\n  fixes A::\"'a::{group_add} iarray\"\n  shows \"A - 0 = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - 0 = A", "proof (unfold iarray_exhaust2 list_eq_iff_nth_eq, auto, unfold IArray.length_def[symmetric] IArray.sub_def[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. IArray.length (A - 0) = IArray.length A\n 2. \\<And>i.\n       i < IArray.length (A - 0) \\<Longrightarrow> (A - 0) !! i = A !! i", "have max_eq: \"(max (IArray.length A) (IArray.length 0))= IArray.length A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (IArray.length A) (IArray.length 0) = IArray.length A", "unfolding zero_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max (IArray.length A) (IArray.length (IArray [])) = IArray.length A", "by auto"], ["proof (state)\nthis:\n  max (IArray.length A) (IArray.length 0) = IArray.length A\n\ngoal (2 subgoals):\n 1. IArray.length (A - 0) = IArray.length A\n 2. \\<And>i.\n       i < IArray.length (A - 0) \\<Longrightarrow> (A - 0) !! i = A !! i", "show length_eq: \"IArray.length (A - 0) = IArray.length A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (A - 0) = IArray.length A", "unfolding minus_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray.of_fun\n       (\\<lambda>a.\n           IArray.of_fun\n            (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n            (max (IArray.length A) (IArray.length 0)) !!\n           a -\n           IArray.of_fun\n            (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n            (max (IArray.length A) (IArray.length 0)) !!\n           a)\n       (max (IArray.length A) (IArray.length 0))) =\n    IArray.length A", "unfolding max_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray.of_fun\n       (\\<lambda>a.\n           IArray.of_fun\n            (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n            (IArray.length A) !!\n           a -\n           IArray.of_fun\n            (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n            (IArray.length A) !!\n           a)\n       (IArray.length A)) =\n    IArray.length A", "by auto"], ["proof (state)\nthis:\n  IArray.length (A - 0) = IArray.length A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (A - 0) \\<Longrightarrow> (A - 0) !! i = A !! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (A - 0) \\<Longrightarrow> (A - 0) !! i = A !! i", "assume i: \"i < IArray.length (A - 0)\""], ["proof (state)\nthis:\n  i < IArray.length (A - 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (A - 0) \\<Longrightarrow> (A - 0) !! i = A !! i", "hence i2: \"i< (IArray.length A)\""], ["proof (prove)\nusing this:\n  i < IArray.length (A - 0)\n\ngoal (1 subgoal):\n 1. i < IArray.length A", "unfolding length_eq"], ["proof (prove)\nusing this:\n  i < IArray.length A\n\ngoal (1 subgoal):\n 1. i < IArray.length A", "."], ["proof (state)\nthis:\n  i < IArray.length A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (A - 0) \\<Longrightarrow> (A - 0) !! i = A !! i", "have \"A - 0 = IArray.of_fun\n    (\\<lambda>a. IArray.of_fun (\\<lambda>a. if a < IArray.length A then A !! a else 0) (IArray.length A) !! a -\n    IArray.of_fun (\\<lambda>a. if a < IArray.length (0::'a iarray) then 0 !! a else 0) (IArray.length A) !! a) \n    (IArray.length A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - 0 =\n    IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (IArray.length A) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n          (IArray.length A) !!\n         a)\n     (IArray.length A)", "unfolding minus_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (max (IArray.length A) (IArray.length 0)) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n          (max (IArray.length A) (IArray.length 0)) !!\n         a)\n     (max (IArray.length A) (IArray.length 0)) =\n    IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (IArray.length A) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n          (IArray.length A) !!\n         a)\n     (IArray.length A)", "unfolding max_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (IArray.length A) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n          (IArray.length A) !!\n         a)\n     (IArray.length A) =\n    IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (IArray.length A) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n          (IArray.length A) !!\n         a)\n     (IArray.length A)", ".."], ["proof (state)\nthis:\n  A - 0 =\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (IArray.length A) !!\n       a -\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n        (IArray.length A) !!\n       a)\n   (IArray.length A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (A - 0) \\<Longrightarrow> (A - 0) !! i = A !! i", "also"], ["proof (state)\nthis:\n  A - 0 =\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (IArray.length A) !!\n       a -\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n        (IArray.length A) !!\n       a)\n   (IArray.length A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (A - 0) \\<Longrightarrow> (A - 0) !! i = A !! i", "have \"... !! i = A !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n          (IArray.length A) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n          (IArray.length A) !!\n         a)\n     (IArray.length A) !!\n    i =\n    A !! i", "unfolding of_fun_nth[OF i2] length_zero_iarray"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < IArray.length A then A !! i else (0::'a)) -\n    (if i < 0 then 0 !! i else (0::'a)) =\n    A !! i", "using i2"], ["proof (prove)\nusing this:\n  i < IArray.length A\n\ngoal (1 subgoal):\n 1. (if i < IArray.length A then A !! i else (0::'a)) -\n    (if i < 0 then 0 !! i else (0::'a)) =\n    A !! i", "by auto"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>a.\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length A then A !! a else (0::'a))\n        (IArray.length A) !!\n       a -\n       IArray.of_fun\n        (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n        (IArray.length A) !!\n       a)\n   (IArray.length A) !!\n  i =\n  A !! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (A - 0) \\<Longrightarrow> (A - 0) !! i = A !! i", "finally"], ["proof (chain)\npicking this:\n  (A - 0) !! i = A !! i", "show \"(A - 0) !! i = A !! i\""], ["proof (prove)\nusing this:\n  (A - 0) !! i = A !! i\n\ngoal (1 subgoal):\n 1. (A - 0) !! i = A !! i", "."], ["proof (state)\nthis:\n  (A - 0) !! i = A !! i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Inner mult over real iarrays\\<close>"], ["", "definition inner_iarray :: \"real iarray => real iarray => real\"  (infixl \"\\<bullet>i\" 70)\n  where \"inner_iarray A B = sum (\\<lambda>n. A !! n * B !! n) {0..<IArray.length A}\""], ["", "lemma vec_to_iarray_inner:\n  \"a \\<bullet> b = vec_to_iarray a \\<bullet>i vec_to_iarray b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<bullet> b = vec_to_iarray a \\<bullet>i vec_to_iarray b", "proof (unfold inner_iarray_def inner_vec_def, auto, unfold IArray.sub_def[symmetric] IArray.length_def[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. a $ i * b $ i) =\n    (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n        vec_to_iarray a !! n * vec_to_iarray b !! n)", "have set_rw: \"{0..<IArray.length (vec_to_iarray a)}  = (to_nat)`(UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<IArray.length (vec_to_iarray a)} = range mod_type_class.to_nat", "unfolding vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<IArray.length\n          (IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i)\n            CARD('a))} =\n    range mod_type_class.to_nat", "using to_nat_less_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?j < CARD(?'a)\n\ngoal (1 subgoal):\n 1. {0..<IArray.length\n          (IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i)\n            CARD('a))} =\n    range mod_type_class.to_nat", "using bij_to_nat[where ?'a='a]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?j < CARD(?'a)\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. {0..<IArray.length\n          (IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i)\n            CARD('a))} =\n    range mod_type_class.to_nat", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?j < CARD(?'a)\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('a)}\n\ngoal (1 subgoal):\n 1. {0..<IArray.length\n          (IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i)\n            CARD('a))} =\n    range mod_type_class.to_nat", "by auto"], ["proof (state)\nthis:\n  {0..<IArray.length (vec_to_iarray a)} = range mod_type_class.to_nat\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. a $ i * b $ i) =\n    (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n        vec_to_iarray a !! n * vec_to_iarray b !! n)", "have inj: \"inj_on (to_nat::'a=>nat) (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj mod_type_class.to_nat", "by (metis strict_mono_imp_inj_on strict_mono_to_nat)"], ["proof (state)\nthis:\n  inj mod_type_class.to_nat\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. a $ i * b $ i) =\n    (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n        vec_to_iarray a !! n * vec_to_iarray b !! n)", "have \"(\\<Sum>n = 0..<IArray.length (vec_to_iarray a). vec_to_iarray a !! n * vec_to_iarray b !! n) \n    = (\\<Sum>n\\<in>range (to_nat::'a=>nat). vec_to_iarray a !! n * vec_to_iarray b !! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n        vec_to_iarray a !! n * vec_to_iarray b !! n) =\n    (\\<Sum>n\\<in>range mod_type_class.to_nat.\n       vec_to_iarray a !! n * vec_to_iarray b !! n)", "unfolding set_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<in>range mod_type_class.to_nat.\n       vec_to_iarray a !! n * vec_to_iarray b !! n) =\n    (\\<Sum>n\\<in>range mod_type_class.to_nat.\n       vec_to_iarray a !! n * vec_to_iarray b !! n)", ".."], ["proof (state)\nthis:\n  (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n      vec_to_iarray a !! n * vec_to_iarray b !! n) =\n  (\\<Sum>n\\<in>range mod_type_class.to_nat.\n     vec_to_iarray a !! n * vec_to_iarray b !! n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. a $ i * b $ i) =\n    (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n        vec_to_iarray a !! n * vec_to_iarray b !! n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n      vec_to_iarray a !! n * vec_to_iarray b !! n) =\n  (\\<Sum>n\\<in>range mod_type_class.to_nat.\n     vec_to_iarray a !! n * vec_to_iarray b !! n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. a $ i * b $ i) =\n    (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n        vec_to_iarray a !! n * vec_to_iarray b !! n)", "have \"... = (\\<Sum>x\\<in>(UNIV::'a set). vec_to_iarray a !! to_nat x * vec_to_iarray b !! to_nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<in>range mod_type_class.to_nat.\n       vec_to_iarray a !! n * vec_to_iarray b !! n) =\n    (\\<Sum>x\\<in>UNIV.\n       vec_to_iarray a !! mod_type_class.to_nat x *\n       vec_to_iarray b !! mod_type_class.to_nat x)", "unfolding sum.reindex[OF inj] o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>UNIV.\n       vec_to_iarray a !! mod_type_class.to_nat x *\n       vec_to_iarray b !! mod_type_class.to_nat x) =\n    (\\<Sum>x\\<in>UNIV.\n       vec_to_iarray a !! mod_type_class.to_nat x *\n       vec_to_iarray b !! mod_type_class.to_nat x)", ".."], ["proof (state)\nthis:\n  (\\<Sum>n\\<in>range mod_type_class.to_nat.\n     vec_to_iarray a !! n * vec_to_iarray b !! n) =\n  (\\<Sum>x\\<in>UNIV.\n     vec_to_iarray a !! mod_type_class.to_nat x *\n     vec_to_iarray b !! mod_type_class.to_nat x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. a $ i * b $ i) =\n    (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n        vec_to_iarray a !! n * vec_to_iarray b !! n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n\\<in>range mod_type_class.to_nat.\n     vec_to_iarray a !! n * vec_to_iarray b !! n) =\n  (\\<Sum>x\\<in>UNIV.\n     vec_to_iarray a !! mod_type_class.to_nat x *\n     vec_to_iarray b !! mod_type_class.to_nat x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. a $ i * b $ i) =\n    (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n        vec_to_iarray a !! n * vec_to_iarray b !! n)", "have \"...= (\\<Sum>x\\<in>UNIV. a $ x * b $ x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>UNIV.\n       vec_to_iarray a !! mod_type_class.to_nat x *\n       vec_to_iarray b !! mod_type_class.to_nat x) =\n    (\\<Sum>x\\<in>UNIV. a $ x * b $ x)", "unfolding vec_to_iarray_nth'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>UNIV. a $ x * b $ x) = (\\<Sum>x\\<in>UNIV. a $ x * b $ x)", ".."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>UNIV.\n     vec_to_iarray a !! mod_type_class.to_nat x *\n     vec_to_iarray b !! mod_type_class.to_nat x) =\n  (\\<Sum>x\\<in>UNIV. a $ x * b $ x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. a $ i * b $ i) =\n    (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n        vec_to_iarray a !! n * vec_to_iarray b !! n)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n      vec_to_iarray a !! n * vec_to_iarray b !! n) =\n  (\\<Sum>x\\<in>UNIV. a $ x * b $ x)", "show \"(\\<Sum>i\\<in>UNIV. a $ i * b $ i) \n    = (\\<Sum>n = 0..<IArray.length (vec_to_iarray a). vec_to_iarray a !! n * vec_to_iarray b !! n)\""], ["proof (prove)\nusing this:\n  (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n      vec_to_iarray a !! n * vec_to_iarray b !! n) =\n  (\\<Sum>x\\<in>UNIV. a $ x * b $ x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. a $ i * b $ i) =\n    (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n        vec_to_iarray a !! n * vec_to_iarray b !! n)", ".."], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. a $ i * b $ i) =\n  (\\<Sum>n = 0..<IArray.length (vec_to_iarray a).\n      vec_to_iarray a !! n * vec_to_iarray b !! n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_to_iarray_scaleR: \n  \"vec_to_iarray (a *\\<^sub>R x) = a *\\<^sub>R (vec_to_iarray x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (a *\\<^sub>R x) = a *\\<^sub>R vec_to_iarray x", "unfolding scaleR_vec_def scaleR_iarray_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i. (\\<chi>i. a *\\<^sub>R x $ i) $ mod_type_class.from_nat i)\n     CARD('b) =\n    IArray.of_fun\n     (\\<lambda>i.\n         a *\\<^sub>R\n         IArray.of_fun (\\<lambda>i. x $ mod_type_class.from_nat i)\n          CARD('b) !!\n         i)\n     (IArray.length\n       (IArray.of_fun (\\<lambda>i. x $ mod_type_class.from_nat i) CARD('b)))", "by auto"], ["", "subsection\\<open>Gram Schmidt over IArrays\\<close>"], ["", "definition \"Gram_Schmidt_column_k_iarrays A k\n  = tabulate2 (nrows_iarray A) (ncols_iarray A) (\\<lambda>a b. (if b = k\n  then (column_iarray b A - sum (\\<lambda>x. (((column_iarray b A) \\<bullet>i x) / (x \\<bullet>i x)) *\\<^sub>R x) \n  (set (List.map (\\<lambda>n. column_iarray n A) [0..<b])))\n  else (column_iarray b A)) !! a)\""], ["", "definition \"Gram_Schmidt_upt_k_iarrays A k = List.foldl Gram_Schmidt_column_k_iarrays A [0..<(Suc k)]\""], ["", "definition \"Gram_Schmidt_matrix_iarrays A = Gram_Schmidt_upt_k_iarrays A (ncols_iarray A - 1)\""], ["", "lemma matrix_to_iarray_Gram_Schmidt_column_k:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  shows \"matrix_to_iarray (Gram_Schmidt_column_k A k) = Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k A k) =\n    Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k", "proof (unfold iarray_exhaust2 list_eq_iff_nth_eq, rule conjI, auto, unfold IArray.sub_def[symmetric] IArray.length_def[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k)) =\n    IArray.length (Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k)\n 2. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray (Gram_Schmidt_column_k A k)) \\<Longrightarrow>\n       IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i) =\n       IArray.length\n        (Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k !! i)\n 3. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (Gram_Schmidt_column_k A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_column_k A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n                          k !!\n                         i !!\n                         ia", "show \"IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k)) = IArray.length (Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k)) =\n    IArray.length (Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k)", "unfolding matrix_to_iarray_def Gram_Schmidt_column_k_iarrays_def tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (vec_to_iarray \\<circ> ($) (Gram_Schmidt_column_k A k) \\<circ>\n             mod_type_class.from_nat)\n         [0..<CARD('rows)])) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                (if b = k\n                 then column_iarray b\n                       (IArray\n                         (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                               mod_type_class.from_nat)\n                           [0..<CARD('rows)])) -\n                      (\\<Sum>x\\<in>set (map\n   (\\<lambda>n.\n       column_iarray n\n        (IArray\n          (map (vec_to_iarray \\<circ> ($) A \\<circ> mod_type_class.from_nat)\n            [0..<CARD('rows)])))\n   [0..<b]).\n                         (column_iarray b\n                           (IArray\n                             (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                                   mod_type_class.from_nat)\n                               [0..<CARD('rows)])) \\<bullet>i\n                          x /\n                          (x \\<bullet>i x)) *\\<^sub>R\n                         x)\n                 else column_iarray b\n                       (IArray\n                         (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                               mod_type_class.from_nat)\n                           [0..<CARD('rows)]))) !!\n                i)\n            (ncols_iarray\n              (IArray\n                (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                      mod_type_class.from_nat)\n                  [0..<CARD('rows)]))))\n       (nrows_iarray\n         (IArray\n           (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                 mod_type_class.from_nat)\n             [0..<CARD('rows)]))))", "unfolding nrows_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (vec_to_iarray \\<circ> ($) (Gram_Schmidt_column_k A k) \\<circ>\n             mod_type_class.from_nat)\n         [0..<CARD('rows)])) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                (if b = k\n                 then column_iarray b\n                       (IArray\n                         (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                               mod_type_class.from_nat)\n                           [0..<CARD('rows)])) -\n                      (\\<Sum>x\\<in>set (map\n   (\\<lambda>n.\n       column_iarray n\n        (IArray\n          (map (vec_to_iarray \\<circ> ($) A \\<circ> mod_type_class.from_nat)\n            [0..<CARD('rows)])))\n   [0..<b]).\n                         (column_iarray b\n                           (IArray\n                             (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                                   mod_type_class.from_nat)\n                               [0..<CARD('rows)])) \\<bullet>i\n                          x /\n                          (x \\<bullet>i x)) *\\<^sub>R\n                         x)\n                 else column_iarray b\n                       (IArray\n                         (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                               mod_type_class.from_nat)\n                           [0..<CARD('rows)]))) !!\n                i)\n            (ncols_iarray\n              (IArray\n                (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                      mod_type_class.from_nat)\n                  [0..<CARD('rows)]))))\n       (IArray.length\n         (IArray\n           (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                 mod_type_class.from_nat)\n             [0..<CARD('rows)]))))", "by auto"], ["proof (state)\nthis:\n  IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k)) =\n  IArray.length (Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray (Gram_Schmidt_column_k A k)) \\<Longrightarrow>\n       IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i) =\n       IArray.length\n        (Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k !! i)\n 2. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (Gram_Schmidt_column_k A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_column_k A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n                          k !!\n                         i !!\n                         ia", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray (Gram_Schmidt_column_k A k)) \\<Longrightarrow>\n       IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i) =\n       IArray.length\n        (Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k !! i)\n 2. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (Gram_Schmidt_column_k A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_column_k A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n                          k !!\n                         i !!\n                         ia", "assume i: \"i < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k))\""], ["proof (state)\nthis:\n  i < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray (Gram_Schmidt_column_k A k)) \\<Longrightarrow>\n       IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i) =\n       IArray.length\n        (Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k !! i)\n 2. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (Gram_Schmidt_column_k A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_column_k A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n                          k !!\n                         i !!\n                         ia", "show \"IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i) \n    = IArray.length (Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i) =\n    IArray.length\n     (Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k !! i)", "unfolding matrix_to_iarray_def Gram_Schmidt_column_k_iarrays_def tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (vec_to_iarray \\<circ> ($) (Gram_Schmidt_column_k A k) \\<circ>\n             mod_type_class.from_nat)\n         [0..<CARD('rows)]) !!\n      i) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                (if b = k\n                 then column_iarray b\n                       (IArray\n                         (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                               mod_type_class.from_nat)\n                           [0..<CARD('rows)])) -\n                      (\\<Sum>x\\<in>set (map\n   (\\<lambda>n.\n       column_iarray n\n        (IArray\n          (map (vec_to_iarray \\<circ> ($) A \\<circ> mod_type_class.from_nat)\n            [0..<CARD('rows)])))\n   [0..<b]).\n                         (column_iarray b\n                           (IArray\n                             (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                                   mod_type_class.from_nat)\n                               [0..<CARD('rows)])) \\<bullet>i\n                          x /\n                          (x \\<bullet>i x)) *\\<^sub>R\n                         x)\n                 else column_iarray b\n                       (IArray\n                         (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                               mod_type_class.from_nat)\n                           [0..<CARD('rows)]))) !!\n                i)\n            (ncols_iarray\n              (IArray\n                (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                      mod_type_class.from_nat)\n                  [0..<CARD('rows)]))))\n       (nrows_iarray\n         (IArray\n           (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                 mod_type_class.from_nat)\n             [0..<CARD('rows)]))) !!\n      i)", "unfolding nrows_iarray_def ncols_iarray_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                vec_to_iarray\n                 (Gram_Schmidt_column_k A k $ mod_type_class.from_nat x))\n         [0..<CARD('rows)]) !!\n      i) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                (if b = k\n                 then column_iarray b\n                       (IArray\n                         (map (\\<lambda>x.\n                                  vec_to_iarray\n                                   (A $ mod_type_class.from_nat x))\n                           [0..<CARD('rows)])) -\n                      (\\<Sum>x\\<in>set (map\n   (\\<lambda>n.\n       column_iarray n\n        (IArray\n          (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n            [0..<CARD('rows)])))\n   [0..<b]).\n                         (column_iarray b\n                           (IArray\n                             (map (\\<lambda>x.\nvec_to_iarray (A $ mod_type_class.from_nat x))\n                               [0..<CARD('rows)])) \\<bullet>i\n                          x /\n                          (x \\<bullet>i x)) *\\<^sub>R\n                         x)\n                 else column_iarray b\n                       (IArray\n                         (map (\\<lambda>x.\n                                  vec_to_iarray\n                                   (A $ mod_type_class.from_nat x))\n                           [0..<CARD('rows)]))) !!\n                i)\n            (IArray.length\n              (IArray\n                (map (\\<lambda>x.\n                         vec_to_iarray (A $ mod_type_class.from_nat x))\n                  [0..<CARD('rows)]) !!\n               0)))\n       (IArray.length\n         (IArray\n           (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n             [0..<CARD('rows)]))) !!\n      i)", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (IArray.list_of\n       (map (\\<lambda>x.\n                vec_to_iarray\n                 (Gram_Schmidt_column_k A k $ mod_type_class.from_nat x))\n         [0..<CARD('rows)] !\n        i)) =\n    length\n     (IArray.list_of\n       (map (\\<lambda>i.\n                IArray\n                 (map (\\<lambda>b.\n                          IArray.list_of\n                           (if b = k\n                            then column_iarray b\n                                  (IArray\n                                    (map\n(\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n[0..<CARD('rows)])) -\n                                 (\\<Sum>x\n  \\<in>set (map (\\<lambda>n.\n                    column_iarray n\n                     (IArray\n                       (map (\\<lambda>x.\n                                vec_to_iarray\n                                 (A $ mod_type_class.from_nat x))\n                         [0..<CARD('rows)])))\n             [0..<b]).\n                                    (column_iarray b\n(IArray\n  (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n    [0..<CARD('rows)])) \\<bullet>i\n                                     x /\n                                     (x \\<bullet>i x)) *\\<^sub>R\n                                    x)\n                            else column_iarray b\n                                  (IArray\n                                    (map\n(\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n[0..<CARD('rows)]))) !\n                          i)\n                   [0..<\n                    length\n                     (IArray.list_of\n                       (vec_to_iarray (A $ mod_type_class.from_nat 0)))]))\n         [0..<CARD('rows)] !\n        i))", "have f1: \"i < card (UNIV::'rows set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < CARD('rows)", "by (metis i length_eq_card_rows)"], ["proof (state)\nthis:\n  i < CARD('rows)\n\ngoal (1 subgoal):\n 1. length\n     (IArray.list_of\n       (map (\\<lambda>x.\n                vec_to_iarray\n                 (Gram_Schmidt_column_k A k $ mod_type_class.from_nat x))\n         [0..<CARD('rows)] !\n        i)) =\n    length\n     (IArray.list_of\n       (map (\\<lambda>i.\n                IArray\n                 (map (\\<lambda>b.\n                          IArray.list_of\n                           (if b = k\n                            then column_iarray b\n                                  (IArray\n                                    (map\n(\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n[0..<CARD('rows)])) -\n                                 (\\<Sum>x\n  \\<in>set (map (\\<lambda>n.\n                    column_iarray n\n                     (IArray\n                       (map (\\<lambda>x.\n                                vec_to_iarray\n                                 (A $ mod_type_class.from_nat x))\n                         [0..<CARD('rows)])))\n             [0..<b]).\n                                    (column_iarray b\n(IArray\n  (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n    [0..<CARD('rows)])) \\<bullet>i\n                                     x /\n                                     (x \\<bullet>i x)) *\\<^sub>R\n                                    x)\n                            else column_iarray b\n                                  (IArray\n                                    (map\n(\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n[0..<CARD('rows)]))) !\n                          i)\n                   [0..<\n                    length\n                     (IArray.list_of\n                       (vec_to_iarray (A $ mod_type_class.from_nat 0)))]))\n         [0..<CARD('rows)] !\n        i))", "have f2: \"\\<And>x\\<^sub>5. IArray.list_of (vec_to_iarray x\\<^sub>5) \n      = List.map (\\<lambda>uua. x\\<^sub>5 $ (from_nat uua::'cols)::real) [0..<card (UNIV::'cols set)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>5.\n       IArray.list_of (vec_to_iarray x\\<^sub>5) =\n       map (\\<lambda>uua. x\\<^sub>5 $ mod_type_class.from_nat uua)\n        [0..<CARD('cols)]", "by (metis list_of.simps IArray.of_fun_def vec_to_iarray_def)"], ["proof (state)\nthis:\n  IArray.list_of (vec_to_iarray ?x\\<^sub>5) =\n  map (\\<lambda>uua. ?x\\<^sub>5 $ mod_type_class.from_nat uua)\n   [0..<CARD('cols)]\n\ngoal (1 subgoal):\n 1. length\n     (IArray.list_of\n       (map (\\<lambda>x.\n                vec_to_iarray\n                 (Gram_Schmidt_column_k A k $ mod_type_class.from_nat x))\n         [0..<CARD('rows)] !\n        i)) =\n    length\n     (IArray.list_of\n       (map (\\<lambda>i.\n                IArray\n                 (map (\\<lambda>b.\n                          IArray.list_of\n                           (if b = k\n                            then column_iarray b\n                                  (IArray\n                                    (map\n(\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n[0..<CARD('rows)])) -\n                                 (\\<Sum>x\n  \\<in>set (map (\\<lambda>n.\n                    column_iarray n\n                     (IArray\n                       (map (\\<lambda>x.\n                                vec_to_iarray\n                                 (A $ mod_type_class.from_nat x))\n                         [0..<CARD('rows)])))\n             [0..<b]).\n                                    (column_iarray b\n(IArray\n  (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n    [0..<CARD('rows)])) \\<bullet>i\n                                     x /\n                                     (x \\<bullet>i x)) *\\<^sub>R\n                                    x)\n                            else column_iarray b\n                                  (IArray\n                                    (map\n(\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n[0..<CARD('rows)]))) !\n                          i)\n                   [0..<\n                    length\n                     (IArray.list_of\n                       (vec_to_iarray (A $ mod_type_class.from_nat 0)))]))\n         [0..<CARD('rows)] !\n        i))", "thus \"length (IArray.list_of (List.map (\\<lambda>x. vec_to_iarray (Gram_Schmidt_column_k A k $ from_nat x)) [0..<card (UNIV::'rows set)] ! i)) \n    = length (IArray.list_of (List.map (\\<lambda>i. IArray (List.map (\\<lambda>b. IArray.list_of (if b = k then column_iarray b (IArray (List.map (\\<lambda>x. vec_to_iarray (A $ from_nat x)) [0..<card (UNIV::'rows set)])) \n    - (\\<Sum>x\\<in>set (List.map (\\<lambda>n. column_iarray n (IArray (List.map (\\<lambda>x. vec_to_iarray (A $ from_nat x)) [0..<card (UNIV::'rows set)]))) [0..< b]). (column_iarray b (IArray (List.map (\\<lambda>x. vec_to_iarray (A $ from_nat x)) [0..<card (UNIV::'rows set)])) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x) else column_iarray b (IArray (List.map (\\<lambda>x. vec_to_iarray (A $ from_nat x)) [0..<card (UNIV::'rows set)]))) ! i) [0..< length (IArray.list_of (vec_to_iarray (A $ from_nat 0)))])) [0..<card (UNIV::'rows set)] ! i))\""], ["proof (prove)\nusing this:\n  IArray.list_of (vec_to_iarray ?x\\<^sub>5) =\n  map (\\<lambda>uua. ?x\\<^sub>5 $ mod_type_class.from_nat uua)\n   [0..<CARD('cols)]\n\ngoal (1 subgoal):\n 1. length\n     (IArray.list_of\n       (map (\\<lambda>x.\n                vec_to_iarray\n                 (Gram_Schmidt_column_k A k $ mod_type_class.from_nat x))\n         [0..<CARD('rows)] !\n        i)) =\n    length\n     (IArray.list_of\n       (map (\\<lambda>i.\n                IArray\n                 (map (\\<lambda>b.\n                          IArray.list_of\n                           (if b = k\n                            then column_iarray b\n                                  (IArray\n                                    (map\n(\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n[0..<CARD('rows)])) -\n                                 (\\<Sum>x\n  \\<in>set (map (\\<lambda>n.\n                    column_iarray n\n                     (IArray\n                       (map (\\<lambda>x.\n                                vec_to_iarray\n                                 (A $ mod_type_class.from_nat x))\n                         [0..<CARD('rows)])))\n             [0..<b]).\n                                    (column_iarray b\n(IArray\n  (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n    [0..<CARD('rows)])) \\<bullet>i\n                                     x /\n                                     (x \\<bullet>i x)) *\\<^sub>R\n                                    x)\n                            else column_iarray b\n                                  (IArray\n                                    (map\n(\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n[0..<CARD('rows)]))) !\n                          i)\n                   [0..<\n                    length\n                     (IArray.list_of\n                       (vec_to_iarray (A $ mod_type_class.from_nat 0)))]))\n         [0..<CARD('rows)] !\n        i))", "using f1"], ["proof (prove)\nusing this:\n  IArray.list_of (vec_to_iarray ?x\\<^sub>5) =\n  map (\\<lambda>uua. ?x\\<^sub>5 $ mod_type_class.from_nat uua)\n   [0..<CARD('cols)]\n  i < CARD('rows)\n\ngoal (1 subgoal):\n 1. length\n     (IArray.list_of\n       (map (\\<lambda>x.\n                vec_to_iarray\n                 (Gram_Schmidt_column_k A k $ mod_type_class.from_nat x))\n         [0..<CARD('rows)] !\n        i)) =\n    length\n     (IArray.list_of\n       (map (\\<lambda>i.\n                IArray\n                 (map (\\<lambda>b.\n                          IArray.list_of\n                           (if b = k\n                            then column_iarray b\n                                  (IArray\n                                    (map\n(\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n[0..<CARD('rows)])) -\n                                 (\\<Sum>x\n  \\<in>set (map (\\<lambda>n.\n                    column_iarray n\n                     (IArray\n                       (map (\\<lambda>x.\n                                vec_to_iarray\n                                 (A $ mod_type_class.from_nat x))\n                         [0..<CARD('rows)])))\n             [0..<b]).\n                                    (column_iarray b\n(IArray\n  (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n    [0..<CARD('rows)])) \\<bullet>i\n                                     x /\n                                     (x \\<bullet>i x)) *\\<^sub>R\n                                    x)\n                            else column_iarray b\n                                  (IArray\n                                    (map\n(\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n[0..<CARD('rows)]))) !\n                          i)\n                   [0..<\n                    length\n                     (IArray.list_of\n                       (vec_to_iarray (A $ mod_type_class.from_nat 0)))]))\n         [0..<CARD('rows)] !\n        i))", "by auto"], ["proof (state)\nthis:\n  length\n   (IArray.list_of\n     (map (\\<lambda>x.\n              vec_to_iarray\n               (Gram_Schmidt_column_k A k $ mod_type_class.from_nat x))\n       [0..<CARD('rows)] !\n      i)) =\n  length\n   (IArray.list_of\n     (map (\\<lambda>i.\n              IArray\n               (map (\\<lambda>b.\n                        IArray.list_of\n                         (if b = k\n                          then column_iarray b\n                                (IArray\n                                  (map (\\<lambda>x.\n     vec_to_iarray (A $ mod_type_class.from_nat x))\n                                    [0..<CARD('rows)])) -\n                               (\\<Sum>x\n\\<in>set (map (\\<lambda>n.\n                  column_iarray n\n                   (IArray\n                     (map (\\<lambda>x.\n                              vec_to_iarray (A $ mod_type_class.from_nat x))\n                       [0..<CARD('rows)])))\n           [0..<b]).\n                                  (column_iarray b\n                                    (IArray\n(map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n  [0..<CARD('rows)])) \\<bullet>i\n                                   x /\n                                   (x \\<bullet>i x)) *\\<^sub>R\n                                  x)\n                          else column_iarray b\n                                (IArray\n                                  (map (\\<lambda>x.\n     vec_to_iarray (A $ mod_type_class.from_nat x))\n                                    [0..<CARD('rows)]))) !\n                        i)\n                 [0..<\n                  length\n                   (IArray.list_of\n                     (vec_to_iarray (A $ mod_type_class.from_nat 0)))]))\n       [0..<CARD('rows)] !\n      i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i) =\n  IArray.length (Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k !! i)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (Gram_Schmidt_column_k A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_column_k A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n                          k !!\n                         i !!\n                         ia", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (Gram_Schmidt_column_k A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_column_k A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n                          k !!\n                         i !!\n                         ia", "fix i ia"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (Gram_Schmidt_column_k A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_column_k A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n                          k !!\n                         i !!\n                         ia", "assume i: \"i < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k))\"\n    and ia: \"ia < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\""], ["proof (state)\nthis:\n  i < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k))\n  ia < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (Gram_Schmidt_column_k A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_column_k A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n                          k !!\n                         i !!\n                         ia", "have i_nrows: \"i<nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < nrows A", "using i"], ["proof (prove)\nusing this:\n  i < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k))\n\ngoal (1 subgoal):\n 1. i < nrows A", "unfolding matrix_to_iarray_def nrows_def"], ["proof (prove)\nusing this:\n  i < IArray.length\n       (IArray\n         (map (vec_to_iarray \\<circ> ($) (Gram_Schmidt_column_k A k) \\<circ>\n               mod_type_class.from_nat)\n           [0..<CARD('rows)]))\n\ngoal (1 subgoal):\n 1. i < CARD('rows)", "by auto"], ["proof (state)\nthis:\n  i < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (Gram_Schmidt_column_k A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_column_k A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n                          k !!\n                         i !!\n                         ia", "have ia_ncols: \"ia<ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia < ncols A", "using ia"], ["proof (prove)\nusing this:\n  ia < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\n\ngoal (1 subgoal):\n 1. ia < ncols A", "unfolding matrix_to_iarray_def o_def vec_to_iarray_def ncols_def"], ["proof (prove)\nusing this:\n  ia < IArray.length\n        (IArray\n          (map (\\<lambda>x.\n                   IArray.of_fun\n                    (\\<lambda>i.\n                        Gram_Schmidt_column_k A k $\n                        mod_type_class.from_nat x $\n                        mod_type_class.from_nat i)\n                    CARD('cols))\n            [0..<CARD('rows)]) !!\n         i)\n\ngoal (1 subgoal):\n 1. ia < CARD('cols)", "by (auto, metis (no_types) Ex_list_of_length i_nrows length_map list_of.simps map_nth nrows_def nth_map)"], ["proof (state)\nthis:\n  ia < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (Gram_Schmidt_column_k A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_column_k A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n                          k !!\n                         i !!\n                         ia", "have i_nrows_iarray: \"i<nrows_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < nrows_iarray (matrix_to_iarray A)", "using i_nrows"], ["proof (prove)\nusing this:\n  i < nrows A\n\ngoal (1 subgoal):\n 1. i < nrows_iarray (matrix_to_iarray A)", "by (metis matrix_to_iarray_nrows)"], ["proof (state)\nthis:\n  i < nrows_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (Gram_Schmidt_column_k A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_column_k A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n                          k !!\n                         i !!\n                         ia", "have ia_ncols_iarray: \"ia<ncols_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia < ncols_iarray (matrix_to_iarray A)", "using ia_ncols"], ["proof (prove)\nusing this:\n  ia < ncols A\n\ngoal (1 subgoal):\n 1. ia < ncols_iarray (matrix_to_iarray A)", "by (metis matrix_to_iarray_ncols)"], ["proof (state)\nthis:\n  ia < ncols_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (Gram_Schmidt_column_k A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k A k) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_column_k A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n                          k !!\n                         i !!\n                         ia", "show \"matrix_to_iarray (Gram_Schmidt_column_k A k) !! i !! ia = Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k !! i !! ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k A k) !! i !! ia =\n    Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k !! i !! ia", "unfolding Gram_Schmidt_column_k_def Gram_Schmidt_column_k_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (\\<chi>a b.\n         (if b = mod_type_class.from_nat k\n          then column b A - proj_onto (column b A) {column i A |i. i < b}\n          else column b A) $\n         a) !!\n    i !!\n    ia =\n    tabulate2 (nrows_iarray (matrix_to_iarray A))\n     (ncols_iarray (matrix_to_iarray A))\n     (\\<lambda>a b.\n         (if b = k\n          then column_iarray b (matrix_to_iarray A) -\n               (\\<Sum>x\\<in>set (map (\\<lambda>n.\n   column_iarray n (matrix_to_iarray A))\n                                  [0..<b]).\n                  (column_iarray b (matrix_to_iarray A) \\<bullet>i x /\n                   (x \\<bullet>i x)) *\\<^sub>R\n                  x)\n          else column_iarray b (matrix_to_iarray A)) !!\n         a) !!\n    i !!\n    ia", "unfolding matrix_to_iarray_nth[of _ \"from_nat i::'rows\" \"from_nat ia::'cols\",\n      unfolded to_nat_from_nat_id[OF i_nrows[unfolded nrows_def]]\n      to_nat_from_nat_id[OF ia_ncols[unfolded ncols_def]]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b.\n        (if b = mod_type_class.from_nat k\n         then column b A - proj_onto (column b A) {column i A |i. i < b}\n         else column b A) $\n        a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    tabulate2 (nrows_iarray (matrix_to_iarray A))\n     (ncols_iarray (matrix_to_iarray A))\n     (\\<lambda>a b.\n         (if b = k\n          then column_iarray b (matrix_to_iarray A) -\n               (\\<Sum>x\\<in>set (map (\\<lambda>n.\n   column_iarray n (matrix_to_iarray A))\n                                  [0..<b]).\n                  (column_iarray b (matrix_to_iarray A) \\<bullet>i x /\n                   (x \\<bullet>i x)) *\\<^sub>R\n                  x)\n          else column_iarray b (matrix_to_iarray A)) !!\n         a) !!\n    i !!\n    ia", "unfolding tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b.\n        (if b = mod_type_class.from_nat k\n         then column b A - proj_onto (column b A) {column i A |i. i < b}\n         else column b A) $\n        a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>b.\n              (if b = k\n               then column_iarray b (matrix_to_iarray A) -\n                    (\\<Sum>x\\<in>set (map\n (\\<lambda>n. column_iarray n (matrix_to_iarray A)) [0..<b]).\n                       (column_iarray b (matrix_to_iarray A) \\<bullet>i x /\n                        (x \\<bullet>i x)) *\\<^sub>R\n                       x)\n               else column_iarray b (matrix_to_iarray A)) !!\n              i)\n          (ncols_iarray (matrix_to_iarray A)))\n     (nrows_iarray (matrix_to_iarray A)) !!\n    i !!\n    ia", "unfolding of_fun_nth[OF i_nrows_iarray]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b.\n        (if b = mod_type_class.from_nat k\n         then column b A - proj_onto (column b A) {column i A |i. i < b}\n         else column b A) $\n        a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    IArray.of_fun\n     (\\<lambda>b.\n         (if b = k\n          then column_iarray b (matrix_to_iarray A) -\n               (\\<Sum>x\\<in>set (map (\\<lambda>n.\n   column_iarray n (matrix_to_iarray A))\n                                  [0..<b]).\n                  (column_iarray b (matrix_to_iarray A) \\<bullet>i x /\n                   (x \\<bullet>i x)) *\\<^sub>R\n                  x)\n          else column_iarray b (matrix_to_iarray A)) !!\n         i)\n     (ncols_iarray (matrix_to_iarray A)) !!\n    ia", "unfolding of_fun_nth[OF ia_ncols_iarray]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b.\n        (if b = mod_type_class.from_nat k\n         then column b A - proj_onto (column b A) {column i A |i. i < b}\n         else column b A) $\n        a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    (if ia = k\n     then column_iarray ia (matrix_to_iarray A) -\n          (\\<Sum>x\\<in>set (map (\\<lambda>n.\n                                    column_iarray n (matrix_to_iarray A))\n                             [0..<ia]).\n             (column_iarray ia (matrix_to_iarray A) \\<bullet>i x /\n              (x \\<bullet>i x)) *\\<^sub>R\n             x)\n     else column_iarray ia (matrix_to_iarray A)) !!\n    i", "proof (unfold proj_onto_def proj_def[abs_def], auto, unfold IArray.sub_def[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. ia = k \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>x. column_iarray x (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia = mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat k) A $\n                      mod_type_class.from_nat i -\n                      (\\<Sum>x\\<in>{column i A |i.\n                                    i < mod_type_class.from_nat k}.\n                         column (mod_type_class.from_nat k) A \\<bullet> x *\n                         x $ mod_type_class.from_nat i /\n                         (x \\<bullet> x)) =\n                      column_iarray ia (matrix_to_iarray A) !! i\n 3. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia \\<noteq> mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat ia) A $\n                      mod_type_class.from_nat i =\n                      column_iarray ia (matrix_to_iarray A) !! i", "have inj: \"inj_on vec_to_iarray {column i A |i. i < from_nat k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on vec_to_iarray {column i A |i. i < mod_type_class.from_nat k}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       \\<forall>y\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n          vec_to_iarray x = vec_to_iarray y \\<longrightarrow> x = y", "by (auto, metis vec_to_iarray_morph)"], ["proof (state)\nthis:\n  inj_on vec_to_iarray {column i A |i. i < mod_type_class.from_nat k}\n\ngoal (3 subgoals):\n 1. ia = k \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>x. column_iarray x (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia = mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat k) A $\n                      mod_type_class.from_nat i -\n                      (\\<Sum>x\\<in>{column i A |i.\n                                    i < mod_type_class.from_nat k}.\n                         column (mod_type_class.from_nat k) A \\<bullet> x *\n                         x $ mod_type_class.from_nat i /\n                         (x \\<bullet> x)) =\n                      column_iarray ia (matrix_to_iarray A) !! i\n 3. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia \\<noteq> mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat ia) A $\n                      mod_type_class.from_nat i =\n                      column_iarray ia (matrix_to_iarray A) !! i", "have set_rw: \"{column i A |i. i < from_nat k} = (\\<lambda>n. column n A)` {0..<from_nat k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i A |i. i < mod_type_class.from_nat k} =\n    (\\<lambda>n. column n A) ` {0::'cols..<mod_type_class.from_nat k}", "proof (unfold image_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>x\\<in>{0::'cols..<mod_type_class.from_nat k}.\n          column i A = column x A", "fix a::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>x\\<in>{0::'cols..<mod_type_class.from_nat k}.\n          column i A = column x A", "assume a: \"a < from_nat k\""], ["proof (state)\nthis:\n  a < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>x\\<in>{0::'cols..<mod_type_class.from_nat k}.\n          column i A = column x A", "show \"\\<exists>x\\<in>{0..<from_nat k}. column a A = column x A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{0::'cols..<mod_type_class.from_nat k}.\n       column a A = column x A", "by (rule bexI[of _ a], auto simp add: a least_mod_type)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{0::'cols..<mod_type_class.from_nat k}.\n     column a A = column x A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {column i A |i. i < mod_type_class.from_nat k} =\n  (\\<lambda>n. column n A) ` {0::'cols..<mod_type_class.from_nat k}\n\ngoal (3 subgoals):\n 1. ia = k \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>x. column_iarray x (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia = mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat k) A $\n                      mod_type_class.from_nat i -\n                      (\\<Sum>x\\<in>{column i A |i.\n                                    i < mod_type_class.from_nat k}.\n                         column (mod_type_class.from_nat k) A \\<bullet> x *\n                         x $ mod_type_class.from_nat i /\n                         (x \\<bullet> x)) =\n                      column_iarray ia (matrix_to_iarray A) !! i\n 3. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia \\<noteq> mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat ia) A $\n                      mod_type_class.from_nat i =\n                      column_iarray ia (matrix_to_iarray A) !! i", "have set_rw2: \"vec_to_iarray` {column i A |i. i < from_nat k} \n      = (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray ` {column i A |i. i < mod_type_class.from_nat k} =\n    (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}", "proof (unfold image_def, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>x\\<in>{0..<k}.\n          vec_to_iarray (column i A) = column_iarray x (matrix_to_iarray A)\n 2. \\<And>xa.\n       xa < k \\<Longrightarrow>\n       \\<exists>x.\n          (\\<exists>i.\n              x = column i A \\<and> i < mod_type_class.from_nat k) \\<and>\n          column_iarray xa (matrix_to_iarray A) = vec_to_iarray x", "fix a::'cols"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>x\\<in>{0..<k}.\n          vec_to_iarray (column i A) = column_iarray x (matrix_to_iarray A)\n 2. \\<And>xa.\n       xa < k \\<Longrightarrow>\n       \\<exists>x.\n          (\\<exists>i.\n              x = column i A \\<and> i < mod_type_class.from_nat k) \\<and>\n          column_iarray xa (matrix_to_iarray A) = vec_to_iarray x", "assume a: \"a < from_nat k\""], ["proof (state)\nthis:\n  a < mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>x\\<in>{0..<k}.\n          vec_to_iarray (column i A) = column_iarray x (matrix_to_iarray A)\n 2. \\<And>xa.\n       xa < k \\<Longrightarrow>\n       \\<exists>x.\n          (\\<exists>i.\n              x = column i A \\<and> i < mod_type_class.from_nat k) \\<and>\n          column_iarray xa (matrix_to_iarray A) = vec_to_iarray x", "show \"\\<exists>x\\<in>{0..<k}. vec_to_iarray (column a A) = column_iarray x (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{0..<k}.\n       vec_to_iarray (column a A) = column_iarray x (matrix_to_iarray A)", "by (rule bexI[of _ \"to_nat a\"], auto simp add:  a to_nat_le vec_to_iarray_column)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{0..<k}.\n     vec_to_iarray (column a A) = column_iarray x (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa < k \\<Longrightarrow>\n       \\<exists>x.\n          (\\<exists>i.\n              x = column i A \\<and> i < mod_type_class.from_nat k) \\<and>\n          column_iarray xa (matrix_to_iarray A) = vec_to_iarray x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa < k \\<Longrightarrow>\n       \\<exists>x.\n          (\\<exists>i.\n              x = column i A \\<and> i < mod_type_class.from_nat k) \\<and>\n          column_iarray xa (matrix_to_iarray A) = vec_to_iarray x", "fix xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa < k \\<Longrightarrow>\n       \\<exists>x.\n          (\\<exists>i.\n              x = column i A \\<and> i < mod_type_class.from_nat k) \\<and>\n          column_iarray xa (matrix_to_iarray A) = vec_to_iarray x", "assume xa: \"xa < k\""], ["proof (state)\nthis:\n  xa < k\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa < k \\<Longrightarrow>\n       \\<exists>x.\n          (\\<exists>i.\n              x = column i A \\<and> i < mod_type_class.from_nat k) \\<and>\n          column_iarray xa (matrix_to_iarray A) = vec_to_iarray x", "have xa': \"(from_nat xa::'cols) < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat xa < mod_type_class.from_nat k", "by (rule from_nat_mono[OF xa k[unfolded ncols_def]])"], ["proof (state)\nthis:\n  mod_type_class.from_nat xa < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa < k \\<Longrightarrow>\n       \\<exists>x.\n          (\\<exists>i.\n              x = column i A \\<and> i < mod_type_class.from_nat k) \\<and>\n          column_iarray xa (matrix_to_iarray A) = vec_to_iarray x", "show \"\\<exists>x. (\\<exists>i. x = column i A \\<and> i < from_nat k) \\<and> column_iarray xa (matrix_to_iarray A) =  vec_to_iarray x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       (\\<exists>i.\n           x = column i A \\<and> i < mod_type_class.from_nat k) \\<and>\n       column_iarray xa (matrix_to_iarray A) = vec_to_iarray x", "apply (rule exI[of _ \"column (from_nat xa) A\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i.\n        column (mod_type_class.from_nat xa) A = column i A \\<and>\n        i < mod_type_class.from_nat k) \\<and>\n    column_iarray xa (matrix_to_iarray A) =\n    vec_to_iarray (column (mod_type_class.from_nat xa) A)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>i.\n       column (mod_type_class.from_nat xa) A = column i A \\<and>\n       i < mod_type_class.from_nat k\n 2. column_iarray xa (matrix_to_iarray A) =\n    vec_to_iarray (column (mod_type_class.from_nat xa) A)", "apply (rule exI[of _ \"from_nat xa\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. column (mod_type_class.from_nat xa) A =\n    column (mod_type_class.from_nat xa) A \\<and>\n    mod_type_class.from_nat xa < mod_type_class.from_nat k\n 2. column_iarray xa (matrix_to_iarray A) =\n    vec_to_iarray (column (mod_type_class.from_nat xa) A)", "apply (auto simp add: xa' vec_to_iarray_column)"], ["proof (prove)\ngoal (1 subgoal):\n 1. column_iarray xa (matrix_to_iarray A) =\n    column_iarray (mod_type_class.to_nat (mod_type_class.from_nat xa))\n     (matrix_to_iarray A)", "by (metis k order.strict_trans vec_to_iarray_column vec_to_iarray_column' xa)"], ["proof (state)\nthis:\n  \\<exists>x.\n     (\\<exists>i.\n         x = column i A \\<and> i < mod_type_class.from_nat k) \\<and>\n     column_iarray xa (matrix_to_iarray A) = vec_to_iarray x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_to_iarray ` {column i A |i. i < mod_type_class.from_nat k} =\n  (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}\n\ngoal (3 subgoals):\n 1. ia = k \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>x. column_iarray x (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia = mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat k) A $\n                      mod_type_class.from_nat i -\n                      (\\<Sum>x\\<in>{column i A |i.\n                                    i < mod_type_class.from_nat k}.\n                         column (mod_type_class.from_nat k) A \\<bullet> x *\n                         x $ mod_type_class.from_nat i /\n                         (x \\<bullet> x)) =\n                      column_iarray ia (matrix_to_iarray A) !! i\n 3. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia \\<noteq> mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat ia) A $\n                      mod_type_class.from_nat i =\n                      column_iarray ia (matrix_to_iarray A) !! i", "show \"column (from_nat k) A $ from_nat i -\n      (\\<Sum>x\\<in>{column i A |i. i < from_nat k}. column (from_nat k) A \\<bullet> x * x $ from_nat i / (x \\<bullet> x)) =\n      (column_iarray k (matrix_to_iarray A) -\n      (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}. (column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x)) !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "proof (cases \"k=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have set_rw_empty: \"{column i A |i. i < from_nat k}={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i A |i. i < mod_type_class.from_nat k} = {}", "unfolding True from_nat_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i A |i. i < (0::'cols)} = {}", "using least_mod_type not_le"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> ?n\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. {column i A |i. i < (0::'cols)} = {}", "by auto"], ["proof (state)\nthis:\n  {column i A |i. i < mod_type_class.from_nat k} = {}\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have \"column (from_nat k) A $ from_nat i -\n        (\\<Sum>x\\<in>{column i A |i. i < from_nat k}. column (from_nat k) A \\<bullet> x\n        * x $ from_nat i / (x \\<bullet> x)) =\n        column (from_nat k) A $ from_nat i - 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i - 0", "unfolding set_rw_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i - 0", "by simp"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x)) =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i - 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "also"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x)) =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i - 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have \"...= column (from_nat k) A $ from_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i - 0 =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i", "by simp"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i - 0 =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "also"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i - 0 =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have \"...= (column_iarray k (matrix_to_iarray A) - 0) !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i =\n    (column_iarray k (matrix_to_iarray A) - 0) !! i", "unfolding minus_zero_iarray"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i =\n    column_iarray k (matrix_to_iarray A) !! i", "unfolding vec_to_iarray_column'[OF k, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i =\n    vec_to_iarray (column (mod_type_class.from_nat k) A) !! i", "unfolding vec_to_iarray_nth[OF i_nrows[unfolded nrows_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i", ".."], ["proof (state)\nthis:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i =\n  (column_iarray k (matrix_to_iarray A) - 0) !! i\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "also"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i =\n  (column_iarray k (matrix_to_iarray A) - 0) !! i\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have \"...= (column_iarray k (matrix_to_iarray A) - \n        (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}. (column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x))\n        !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (column_iarray k (matrix_to_iarray A) - 0) !! i =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (column_iarray 0 (matrix_to_iarray A) - 0) !! i =\n    (column_iarray 0 (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<0}.\n        (column_iarray 0 (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "by auto"], ["proof (state)\nthis:\n  (column_iarray k (matrix_to_iarray A) - 0) !! i =\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                {0..<k}.\n      (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x)) !!\n  i\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "finally"], ["proof (chain)\npicking this:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x)) =\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                {0..<k}.\n      (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x)) !!\n  i", "show ?thesis"], ["proof (prove)\nusing this:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x)) =\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                {0..<k}.\n      (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x)) !!\n  i\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "."], ["proof (state)\nthis:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x)) =\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                {0..<k}.\n      (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x)) !!\n  i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have \"(\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}. (column_iarray k (matrix_to_iarray A) \\<bullet>i x/ (x \\<bullet>i x)) *\\<^sub>R x) !! i = \n        (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}. \n        (( column_iarray k (matrix_to_iarray A) \\<bullet>i x/ (x \\<bullet>i x)) *\\<^sub>R x) !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                 {0..<k}.\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x) !!\n    i =\n    (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                 {0..<k}.\n       ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x) !!\n       i)", "proof (rule sum_component_iarray)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                   {0..<k}.\n       i < IArray.length\n            ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n              (x \\<bullet>i x)) *\\<^sub>R\n             x)\n 2. finite ((\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k})\n 3. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} \\<noteq> {}", "show \"\\<forall>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}. i < IArray.length ((column_iarray k (matrix_to_iarray A) \\<bullet>i x/ (x \\<bullet>i x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                   {0..<k}.\n       i < IArray.length\n            ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n              (x \\<bullet>i x)) *\\<^sub>R\n             x)", "proof (unfold column_iarray_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < k \\<Longrightarrow>\n       i < length\n            (IArray.list_of\n              ((IArray\n                 (map (\\<lambda>m.\n                          IArray.list_of\n                           (IArray.list_of (matrix_to_iarray A) ! m) !\n                          k)\n                   [0..<\n                    length\n                     (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n                IArray\n                 (map (\\<lambda>m.\n                          IArray.list_of\n                           (IArray.list_of (matrix_to_iarray A) ! m) !\n                          x)\n                   [0..<length (IArray.list_of (matrix_to_iarray A))]) /\n                (IArray\n                  (map (\\<lambda>m.\n                           IArray.list_of\n                            (IArray.list_of (matrix_to_iarray A) ! m) !\n                           x)\n                    [0..<\n                     length\n                      (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n                 IArray\n                  (map (\\<lambda>m.\n                           IArray.list_of\n                            (IArray.list_of (matrix_to_iarray A) ! m) !\n                           x)\n                    [0..<\n                     length\n                      (IArray.list_of (matrix_to_iarray A))]))) *\\<^sub>R\n               IArray\n                (map (\\<lambda>m.\n                         IArray.list_of\n                          (IArray.list_of (matrix_to_iarray A) ! m) !\n                         x)\n                  [0..<length (IArray.list_of (matrix_to_iarray A))])))", "fix x :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < k \\<Longrightarrow>\n       i < length\n            (IArray.list_of\n              ((IArray\n                 (map (\\<lambda>m.\n                          IArray.list_of\n                           (IArray.list_of (matrix_to_iarray A) ! m) !\n                          k)\n                   [0..<\n                    length\n                     (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n                IArray\n                 (map (\\<lambda>m.\n                          IArray.list_of\n                           (IArray.list_of (matrix_to_iarray A) ! m) !\n                          x)\n                   [0..<length (IArray.list_of (matrix_to_iarray A))]) /\n                (IArray\n                  (map (\\<lambda>m.\n                           IArray.list_of\n                            (IArray.list_of (matrix_to_iarray A) ! m) !\n                           x)\n                    [0..<\n                     length\n                      (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n                 IArray\n                  (map (\\<lambda>m.\n                           IArray.list_of\n                            (IArray.list_of (matrix_to_iarray A) ! m) !\n                           x)\n                    [0..<\n                     length\n                      (IArray.list_of (matrix_to_iarray A))]))) *\\<^sub>R\n               IArray\n                (map (\\<lambda>m.\n                         IArray.list_of\n                          (IArray.list_of (matrix_to_iarray A) ! m) !\n                         x)\n                  [0..<length (IArray.list_of (matrix_to_iarray A))])))", "have \"i < length (IArray.list_of (IArray (map (vec_to_iarray \\<circ> ($) A \\<circ> mod_type_class.from_nat) [0..<card (UNIV::'rows set)])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length\n         (IArray.list_of\n           (IArray\n             (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                   mod_type_class.from_nat)\n               [0..<CARD('rows)])))", "by (metis i_nrows_iarray IArray.length_def matrix_to_iarray_def nrows_iarray_def)"], ["proof (state)\nthis:\n  i < length\n       (IArray.list_of\n         (IArray\n           (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                 mod_type_class.from_nat)\n             [0..<CARD('rows)])))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < k \\<Longrightarrow>\n       i < length\n            (IArray.list_of\n              ((IArray\n                 (map (\\<lambda>m.\n                          IArray.list_of\n                           (IArray.list_of (matrix_to_iarray A) ! m) !\n                          k)\n                   [0..<\n                    length\n                     (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n                IArray\n                 (map (\\<lambda>m.\n                          IArray.list_of\n                           (IArray.list_of (matrix_to_iarray A) ! m) !\n                          x)\n                   [0..<length (IArray.list_of (matrix_to_iarray A))]) /\n                (IArray\n                  (map (\\<lambda>m.\n                           IArray.list_of\n                            (IArray.list_of (matrix_to_iarray A) ! m) !\n                           x)\n                    [0..<\n                     length\n                      (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n                 IArray\n                  (map (\\<lambda>m.\n                           IArray.list_of\n                            (IArray.list_of (matrix_to_iarray A) ! m) !\n                           x)\n                    [0..<\n                     length\n                      (IArray.list_of (matrix_to_iarray A))]))) *\\<^sub>R\n               IArray\n                (map (\\<lambda>m.\n                         IArray.list_of\n                          (IArray.list_of (matrix_to_iarray A) ! m) !\n                         x)\n                  [0..<length (IArray.list_of (matrix_to_iarray A))])))", "thus \"i < length (IArray.list_of ((IArray (map (\\<lambda>n. IArray.list_of (IArray.list_of (matrix_to_iarray A) ! n) ! k) [0..<length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i IArray (map (\\<lambda>n. IArray.list_of (IArray.list_of (matrix_to_iarray A) ! n) ! x) [0..<length (IArray.list_of (matrix_to_iarray A))]) / (IArray (map (\\<lambda>n. IArray.list_of (IArray.list_of (matrix_to_iarray A) ! n) ! x) [0..<length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i IArray (map (\\<lambda>n. IArray.list_of (IArray.list_of (matrix_to_iarray A) ! n) ! x) [0..<length (IArray.list_of (matrix_to_iarray A))]))) *\\<^sub>R IArray (map (\\<lambda>n. IArray.list_of (IArray.list_of (matrix_to_iarray A) ! n) ! x) [0..<length (IArray.list_of (matrix_to_iarray A))])))\""], ["proof (prove)\nusing this:\n  i < length\n       (IArray.list_of\n         (IArray\n           (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                 mod_type_class.from_nat)\n             [0..<CARD('rows)])))\n\ngoal (1 subgoal):\n 1. i < length\n         (IArray.list_of\n           ((IArray\n              (map (\\<lambda>n.\n                       IArray.list_of\n                        (IArray.list_of (matrix_to_iarray A) ! n) !\n                       k)\n                [0..<\n                 length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n             IArray\n              (map (\\<lambda>n.\n                       IArray.list_of\n                        (IArray.list_of (matrix_to_iarray A) ! n) !\n                       x)\n                [0..<length (IArray.list_of (matrix_to_iarray A))]) /\n             (IArray\n               (map (\\<lambda>n.\n                        IArray.list_of\n                         (IArray.list_of (matrix_to_iarray A) ! n) !\n                        x)\n                 [0..<\n                  length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n              IArray\n               (map (\\<lambda>n.\n                        IArray.list_of\n                         (IArray.list_of (matrix_to_iarray A) ! n) !\n                        x)\n                 [0..<\n                  length (IArray.list_of (matrix_to_iarray A))]))) *\\<^sub>R\n            IArray\n             (map (\\<lambda>n.\n                      IArray.list_of\n                       (IArray.list_of (matrix_to_iarray A) ! n) !\n                      x)\n               [0..<length (IArray.list_of (matrix_to_iarray A))])))", "by (simp add: matrix_to_iarray_def scaleR_iarray_def)"], ["proof (state)\nthis:\n  i < length\n       (IArray.list_of\n         ((IArray\n            (map (\\<lambda>n.\n                     IArray.list_of\n                      (IArray.list_of (matrix_to_iarray A) ! n) !\n                     k)\n              [0..<length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n           IArray\n            (map (\\<lambda>n.\n                     IArray.list_of\n                      (IArray.list_of (matrix_to_iarray A) ! n) !\n                     x)\n              [0..<length (IArray.list_of (matrix_to_iarray A))]) /\n           (IArray\n             (map (\\<lambda>n.\n                      IArray.list_of\n                       (IArray.list_of (matrix_to_iarray A) ! n) !\n                      x)\n               [0..<\n                length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n            IArray\n             (map (\\<lambda>n.\n                      IArray.list_of\n                       (IArray.list_of (matrix_to_iarray A) ! n) !\n                      x)\n               [0..<\n                length (IArray.list_of (matrix_to_iarray A))]))) *\\<^sub>R\n          IArray\n           (map (\\<lambda>n.\n                    IArray.list_of\n                     (IArray.list_of (matrix_to_iarray A) ! n) !\n                    x)\n             [0..<length (IArray.list_of (matrix_to_iarray A))])))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                 {0..<k}.\n     i < IArray.length\n          ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n            (x \\<bullet>i x)) *\\<^sub>R\n           x)\n\ngoal (2 subgoals):\n 1. finite ((\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k})\n 2. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} \\<noteq> {}", "show \"finite ((\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k})", "by auto"], ["proof (state)\nthis:\n  finite ((\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k})\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} \\<noteq> {}", "show \"(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} \\<noteq> {}", "using False"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x) !!\n  i =\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x) !!\n     i)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x) !!\n  i =\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x) !!\n     i)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have \"... = (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}. \n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                 {0..<k}.\n       ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x) !!\n       i) =\n    (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                 {0..<k}.\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x !! i)", "proof (rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} =\n    (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n               {0..<k} \\<Longrightarrow>\n       ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x) !!\n       i =\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x !! i", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} =\n    (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n               {0..<k} \\<Longrightarrow>\n       ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x) !!\n       i =\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x !! i", "assume \"x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}\""], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} =\n    (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n               {0..<k} \\<Longrightarrow>\n       ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x) !!\n       i =\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x !! i", "from this"], ["proof (chain)\npicking this:\n  x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}", "obtain n where x: \"x = column_iarray n (matrix_to_iarray A)\" and n: \"n<k\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>x = column_iarray n (matrix_to_iarray A); n < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = column_iarray n (matrix_to_iarray A)\n  n < k\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} =\n    (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n               {0..<k} \\<Longrightarrow>\n       ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x) !!\n       i =\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x !! i", "have n_ncols: \"n<ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < ncols A", "by (metis k n order.strict_trans)"], ["proof (state)\nthis:\n  n < ncols A\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} =\n    (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n               {0..<k} \\<Longrightarrow>\n       ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x) !!\n       i =\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x !! i", "have c_eq: \"column_iarray k (matrix_to_iarray A) = vec_to_iarray (column (from_nat k::'cols) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column_iarray k (matrix_to_iarray A) =\n    vec_to_iarray (column (mod_type_class.from_nat k) A)", "by (metis k vec_to_iarray_column')"], ["proof (state)\nthis:\n  column_iarray k (matrix_to_iarray A) =\n  vec_to_iarray (column (mod_type_class.from_nat k) A)\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} =\n    (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n               {0..<k} \\<Longrightarrow>\n       ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x) !!\n       i =\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x !! i", "show \"((column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x) !! i \n          = (column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x) !!\n    i =\n    (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n     (x \\<bullet>i x)) *\\<^sub>R\n    x !! i", "unfolding x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((column_iarray k (matrix_to_iarray A) \\<bullet>i\n      column_iarray n (matrix_to_iarray A) /\n      (column_iarray n (matrix_to_iarray A) \\<bullet>i\n       column_iarray n (matrix_to_iarray A))) *\\<^sub>R\n     column_iarray n (matrix_to_iarray A)) !!\n    i =\n    (column_iarray k (matrix_to_iarray A) \\<bullet>i\n     column_iarray n (matrix_to_iarray A) /\n     (column_iarray n (matrix_to_iarray A) \\<bullet>i\n      column_iarray n (matrix_to_iarray A))) *\\<^sub>R\n    column_iarray n (matrix_to_iarray A) !! i", "unfolding vec_to_iarray_column[symmetric, of \"from_nat n::'cols\", \n            unfolded to_nat_from_nat_id[OF n_ncols[unfolded ncols_def]]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((column_iarray k (matrix_to_iarray A) \\<bullet>i\n      vec_to_iarray (column (mod_type_class.from_nat n) A) /\n      (vec_to_iarray (column (mod_type_class.from_nat n) A) \\<bullet>i\n       vec_to_iarray (column (mod_type_class.from_nat n) A))) *\\<^sub>R\n     vec_to_iarray (column (mod_type_class.from_nat n) A)) !!\n    i =\n    (column_iarray k (matrix_to_iarray A) \\<bullet>i\n     vec_to_iarray (column (mod_type_class.from_nat n) A) /\n     (vec_to_iarray (column (mod_type_class.from_nat n) A) \\<bullet>i\n      vec_to_iarray (column (mod_type_class.from_nat n) A))) *\\<^sub>R\n    vec_to_iarray (column (mod_type_class.from_nat n) A) !! i", "unfolding c_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((vec_to_iarray (column (mod_type_class.from_nat k) A) \\<bullet>i\n      vec_to_iarray (column (mod_type_class.from_nat n) A) /\n      (vec_to_iarray (column (mod_type_class.from_nat n) A) \\<bullet>i\n       vec_to_iarray (column (mod_type_class.from_nat n) A))) *\\<^sub>R\n     vec_to_iarray (column (mod_type_class.from_nat n) A)) !!\n    i =\n    (vec_to_iarray (column (mod_type_class.from_nat k) A) \\<bullet>i\n     vec_to_iarray (column (mod_type_class.from_nat n) A) /\n     (vec_to_iarray (column (mod_type_class.from_nat n) A) \\<bullet>i\n      vec_to_iarray (column (mod_type_class.from_nat n) A))) *\\<^sub>R\n    vec_to_iarray (column (mod_type_class.from_nat n) A) !! i", "unfolding vec_to_iarray_inner[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((column (mod_type_class.from_nat k) A \\<bullet>\n      column (mod_type_class.from_nat n) A /\n      (column (mod_type_class.from_nat n) A \\<bullet>\n       column (mod_type_class.from_nat n) A)) *\\<^sub>R\n     vec_to_iarray (column (mod_type_class.from_nat n) A)) !!\n    i =\n    (column (mod_type_class.from_nat k) A \\<bullet>\n     column (mod_type_class.from_nat n) A /\n     (column (mod_type_class.from_nat n) A \\<bullet>\n      column (mod_type_class.from_nat n) A)) *\\<^sub>R\n    vec_to_iarray (column (mod_type_class.from_nat n) A) !! i", "unfolding vec_to_iarray_nth[OF i_nrows[unfolded nrows_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((column (mod_type_class.from_nat k) A \\<bullet>\n      column (mod_type_class.from_nat n) A /\n      (column (mod_type_class.from_nat n) A \\<bullet>\n       column (mod_type_class.from_nat n) A)) *\\<^sub>R\n     vec_to_iarray (column (mod_type_class.from_nat n) A)) !!\n    i =\n    (column (mod_type_class.from_nat k) A \\<bullet>\n     column (mod_type_class.from_nat n) A /\n     (column (mod_type_class.from_nat n) A \\<bullet>\n      column (mod_type_class.from_nat n) A)) *\\<^sub>R\n    column (mod_type_class.from_nat n) A $ mod_type_class.from_nat i", "unfolding vector_scaleR_component[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((column (mod_type_class.from_nat k) A \\<bullet>\n      column (mod_type_class.from_nat n) A /\n      (column (mod_type_class.from_nat n) A \\<bullet>\n       column (mod_type_class.from_nat n) A)) *\\<^sub>R\n     vec_to_iarray (column (mod_type_class.from_nat n) A)) !!\n    i =\n    ((column (mod_type_class.from_nat k) A \\<bullet>\n      column (mod_type_class.from_nat n) A /\n      (column (mod_type_class.from_nat n) A \\<bullet>\n       column (mod_type_class.from_nat n) A)) *\\<^sub>R\n     column (mod_type_class.from_nat n) A) $\n    mod_type_class.from_nat i", "unfolding vec_to_iarray_nth'[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((column (mod_type_class.from_nat k) A \\<bullet>\n      column (mod_type_class.from_nat n) A /\n      (column (mod_type_class.from_nat n) A \\<bullet>\n       column (mod_type_class.from_nat n) A)) *\\<^sub>R\n     vec_to_iarray (column (mod_type_class.from_nat n) A)) !!\n    i =\n    vec_to_iarray\n     ((column (mod_type_class.from_nat k) A \\<bullet>\n       column (mod_type_class.from_nat n) A /\n       (column (mod_type_class.from_nat n) A \\<bullet>\n        column (mod_type_class.from_nat n) A)) *\\<^sub>R\n      column (mod_type_class.from_nat n) A) !!\n    mod_type_class.to_nat (mod_type_class.from_nat i)", "unfolding to_nat_from_nat_id[OF i_nrows[unfolded nrows_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((column (mod_type_class.from_nat k) A \\<bullet>\n      column (mod_type_class.from_nat n) A /\n      (column (mod_type_class.from_nat n) A \\<bullet>\n       column (mod_type_class.from_nat n) A)) *\\<^sub>R\n     vec_to_iarray (column (mod_type_class.from_nat n) A)) !!\n    i =\n    vec_to_iarray\n     ((column (mod_type_class.from_nat k) A \\<bullet>\n       column (mod_type_class.from_nat n) A /\n       (column (mod_type_class.from_nat n) A \\<bullet>\n        column (mod_type_class.from_nat n) A)) *\\<^sub>R\n      column (mod_type_class.from_nat n) A) !!\n    i", "unfolding vec_to_iarray_scaleR"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((column (mod_type_class.from_nat k) A \\<bullet>\n      column (mod_type_class.from_nat n) A /\n      (column (mod_type_class.from_nat n) A \\<bullet>\n       column (mod_type_class.from_nat n) A)) *\\<^sub>R\n     vec_to_iarray (column (mod_type_class.from_nat n) A)) !!\n    i =\n    ((column (mod_type_class.from_nat k) A \\<bullet>\n      column (mod_type_class.from_nat n) A /\n      (column (mod_type_class.from_nat n) A \\<bullet>\n       column (mod_type_class.from_nat n) A)) *\\<^sub>R\n     vec_to_iarray (column (mod_type_class.from_nat n) A)) !!\n    i", ".."], ["proof (state)\nthis:\n  ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n    (x \\<bullet>i x)) *\\<^sub>R\n   x) !!\n  i =\n  (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n   (x \\<bullet>i x)) *\\<^sub>R\n  x !! i\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} =\n    (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}", "qed (simp)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x) !!\n     i) =\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x !! i)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x) !!\n     i) =\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x !! i)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have \"... =  (\\<Sum>x\\<in>vec_to_iarray ` {column i A |i. i < from_nat k}. (column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                 {0..<k}.\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x !! i) =\n    (\\<Sum>x\\<in>vec_to_iarray `\n                 {column i A |i. i < mod_type_class.from_nat k}.\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x !! i)", "unfolding set_rw2[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>vec_to_iarray `\n                 {column i A |i. i < mod_type_class.from_nat k}.\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x !! i) =\n    (\\<Sum>x\\<in>vec_to_iarray `\n                 {column i A |i. i < mod_type_class.from_nat k}.\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x !! i)", ".."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x !! i) =\n  (\\<Sum>x\\<in>vec_to_iarray `\n               {column i A |i. i < mod_type_class.from_nat k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x !! i)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x !! i) =\n  (\\<Sum>x\\<in>vec_to_iarray `\n               {column i A |i. i < mod_type_class.from_nat k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x !! i)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have \"...= \n        (\\<Sum>x\\<in>{column i A |i. i < from_nat k}. (column (from_nat k) A \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R vec_to_iarray x !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>vec_to_iarray `\n                 {column i A |i. i < mod_type_class.from_nat k}.\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x !! i) =\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       (column (mod_type_class.from_nat k) A \\<bullet> x /\n        (x \\<bullet> x)) *\\<^sub>R\n       vec_to_iarray x !! i)", "unfolding sum.reindex[OF inj] o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i vec_to_iarray x /\n        (vec_to_iarray x \\<bullet>i vec_to_iarray x)) *\\<^sub>R\n       vec_to_iarray x !! i) =\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       (column (mod_type_class.from_nat k) A \\<bullet> x /\n        (x \\<bullet> x)) *\\<^sub>R\n       vec_to_iarray x !! i)", "unfolding vec_to_iarray_column[of \"from_nat k::'cols\",symmetric,unfolded to_nat_from_nat_id[OF k[unfolded ncols_def]]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       (vec_to_iarray (column (mod_type_class.from_nat k) A) \\<bullet>i\n        vec_to_iarray x /\n        (vec_to_iarray x \\<bullet>i vec_to_iarray x)) *\\<^sub>R\n       vec_to_iarray x !! i) =\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       (column (mod_type_class.from_nat k) A \\<bullet> x /\n        (x \\<bullet> x)) *\\<^sub>R\n       vec_to_iarray x !! i)", "unfolding vec_to_iarray_inner[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       (column (mod_type_class.from_nat k) A \\<bullet> x /\n        (x \\<bullet> x)) *\\<^sub>R\n       vec_to_iarray x !! i) =\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       (column (mod_type_class.from_nat k) A \\<bullet> x /\n        (x \\<bullet> x)) *\\<^sub>R\n       vec_to_iarray x !! i)", ".."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>vec_to_iarray `\n               {column i A |i. i < mod_type_class.from_nat k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x !! i) =\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     (column (mod_type_class.from_nat k) A \\<bullet> x /\n      (x \\<bullet> x)) *\\<^sub>R\n     vec_to_iarray x !! i)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>vec_to_iarray `\n               {column i A |i. i < mod_type_class.from_nat k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x !! i) =\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     (column (mod_type_class.from_nat k) A \\<bullet> x /\n      (x \\<bullet> x)) *\\<^sub>R\n     vec_to_iarray x !! i)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have \"... \n        = (\\<Sum>x\\<in>{column i A |i. i < from_nat k}. column (from_nat k) A \\<bullet> x * x $ from_nat i / (x \\<bullet> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       (column (mod_type_class.from_nat k) A \\<bullet> x /\n        (x \\<bullet> x)) *\\<^sub>R\n       vec_to_iarray x !! i) =\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x))", "unfolding vec_to_iarray_nth[OF i_nrows[unfolded nrows_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       (column (mod_type_class.from_nat k) A \\<bullet> x /\n        (x \\<bullet> x)) *\\<^sub>R\n       x $ mod_type_class.from_nat i) =\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     (column (mod_type_class.from_nat k) A \\<bullet> x /\n      (x \\<bullet> x)) *\\<^sub>R\n     vec_to_iarray x !! i) =\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x) !!\n  i =\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x))", "have *: \"(\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}. (column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x) !! i \n        = (\\<Sum>x\\<in>{column i A |i. i < from_nat k}. column (from_nat k) A \\<bullet> x * x $ from_nat i / (x \\<bullet> x))\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x) !!\n  i =\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                 {0..<k}.\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x) !!\n    i =\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x))", "."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x) !!\n  i =\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have \"(column_iarray k (matrix_to_iarray A) -\n        (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}. (column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x)) !! i =\n        (column_iarray k (matrix_to_iarray A) !! i -\n        (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}. (column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x) !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i =\n    column_iarray k (matrix_to_iarray A) !! i -\n    (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                 {0..<k}.\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x) !!\n    i", "proof (rule minus_iarray_component)"], ["proof (state)\ngoal (2 subgoals):\n 1. i < IArray.length (column_iarray k (matrix_to_iarray A))\n 2. i < IArray.length\n         (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}.\n            (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n             (x \\<bullet>i x)) *\\<^sub>R\n            x)", "have finite: \"finite ((\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k})", "using False"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k})", "by auto"], ["proof (state)\nthis:\n  finite ((\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k})\n\ngoal (2 subgoals):\n 1. i < IArray.length (column_iarray k (matrix_to_iarray A))\n 2. i < IArray.length\n         (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}.\n            (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n             (x \\<bullet>i x)) *\\<^sub>R\n            x)", "have not_empty: \"(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} \\<noteq> {}", "by (metis False atLeastLessThan_empty_iff2 empty_is_image neq0_conv)"], ["proof (state)\nthis:\n  (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. i < IArray.length (column_iarray k (matrix_to_iarray A))\n 2. i < IArray.length\n         (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}.\n            (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n             (x \\<bullet>i x)) *\\<^sub>R\n            x)", "let ?C=\"{IArray.length ((column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x) |x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}}\""], ["proof (state)\ngoal (2 subgoals):\n 1. i < IArray.length (column_iarray k (matrix_to_iarray A))\n 2. i < IArray.length\n         (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}.\n            (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n             (x \\<bullet>i x)) *\\<^sub>R\n            x)", "have finite_C: \"finite ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {IArray.length\n       ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x) |\n      x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                 {0..<k}}", "by auto"], ["proof (state)\nthis:\n  finite\n   {IArray.length\n     ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x) |\n    x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}}\n\ngoal (2 subgoals):\n 1. i < IArray.length (column_iarray k (matrix_to_iarray A))\n 2. i < IArray.length\n         (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}.\n            (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n             (x \\<bullet>i x)) *\\<^sub>R\n            x)", "have not_empty_C: \"?C \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {IArray.length\n      ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x) |\n     x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                {0..<k}} \\<noteq>\n    {}", "using False"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {IArray.length\n      ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x) |\n     x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                {0..<k}} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  {IArray.length\n    ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x) |\n   x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n              {0..<k}} \\<noteq>\n  {}\n\ngoal (2 subgoals):\n 1. i < IArray.length (column_iarray k (matrix_to_iarray A))\n 2. i < IArray.length\n         (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}.\n            (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n             (x \\<bullet>i x)) *\\<^sub>R\n            x)", "let ?x=\"(column_iarray 0 (matrix_to_iarray A))\""], ["proof (state)\ngoal (2 subgoals):\n 1. i < IArray.length (column_iarray k (matrix_to_iarray A))\n 2. i < IArray.length\n         (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}.\n            (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n             (x \\<bullet>i x)) *\\<^sub>R\n            x)", "let ?c=\"IArray.length ((column_iarray k (matrix_to_iarray A) \\<bullet>i ?x / (?x \\<bullet>i ?x)) *\\<^sub>R ?x)\""], ["proof (state)\ngoal (2 subgoals):\n 1. i < IArray.length (column_iarray k (matrix_to_iarray A))\n 2. i < IArray.length\n         (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}.\n            (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n             (x \\<bullet>i x)) *\\<^sub>R\n            x)", "show \"i < IArray.length (column_iarray k (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length (column_iarray k (matrix_to_iarray A))", "unfolding column_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length\n         (IArray.of_fun (\\<lambda>m. matrix_to_iarray A !! m !! k)\n           (IArray.length (matrix_to_iarray A)))", "by (auto, metis i_nrows_iarray IArray.length_def nrows_iarray_def)"], ["proof (state)\nthis:\n  i < IArray.length (column_iarray k (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. i < IArray.length\n         (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}.\n            (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n             (x \\<bullet>i x)) *\\<^sub>R\n            x)", "show \"i < IArray.length (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}. (column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length\n         (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}.\n            (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n             (x \\<bullet>i x)) *\\<^sub>R\n            x)", "unfolding length_sum_iarray[OF finite not_empty]"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < Max {IArray.length\n              ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                (x \\<bullet>i x)) *\\<^sub>R\n               x) |\n             x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                        {0..<k}}", "unfolding Max_gr_iff[OF finite_C not_empty_C]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex {IArray.length\n          ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n            (x \\<bullet>i x)) *\\<^sub>R\n           x) |\n         x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                    {0..<k}}\n     ((<) i)", "proof (rule bexI[of _ \"?c\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. i < IArray.length\n         ((column_iarray k (matrix_to_iarray A) \\<bullet>i\n           column_iarray 0 (matrix_to_iarray A) /\n           (column_iarray 0 (matrix_to_iarray A) \\<bullet>i\n            column_iarray 0 (matrix_to_iarray A))) *\\<^sub>R\n          column_iarray 0 (matrix_to_iarray A))\n 2. IArray.length\n     ((column_iarray k (matrix_to_iarray A) \\<bullet>i\n       column_iarray 0 (matrix_to_iarray A) /\n       (column_iarray 0 (matrix_to_iarray A) \\<bullet>i\n        column_iarray 0 (matrix_to_iarray A))) *\\<^sub>R\n      column_iarray 0 (matrix_to_iarray A))\n    \\<in> {IArray.length\n            ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n              (x \\<bullet>i x)) *\\<^sub>R\n             x) |\n           x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}}", "show \"i < ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length\n         ((column_iarray k (matrix_to_iarray A) \\<bullet>i\n           column_iarray 0 (matrix_to_iarray A) /\n           (column_iarray 0 (matrix_to_iarray A) \\<bullet>i\n            column_iarray 0 (matrix_to_iarray A))) *\\<^sub>R\n          column_iarray 0 (matrix_to_iarray A))", "proof (unfold column_iarray_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length\n         (IArray.list_of\n           ((IArray\n              (map (\\<lambda>m.\n                       IArray.list_of\n                        (IArray.list_of (matrix_to_iarray A) ! m) !\n                       k)\n                [0..<\n                 length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n             IArray\n              (map (\\<lambda>m.\n                       IArray.list_of\n                        (IArray.list_of (matrix_to_iarray A) ! m) !\n                       0)\n                [0..<length (IArray.list_of (matrix_to_iarray A))]) /\n             (IArray\n               (map (\\<lambda>m.\n                        IArray.list_of\n                         (IArray.list_of (matrix_to_iarray A) ! m) !\n                        0)\n                 [0..<\n                  length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n              IArray\n               (map (\\<lambda>m.\n                        IArray.list_of\n                         (IArray.list_of (matrix_to_iarray A) ! m) !\n                        0)\n                 [0..<\n                  length (IArray.list_of (matrix_to_iarray A))]))) *\\<^sub>R\n            IArray\n             (map (\\<lambda>m.\n                      IArray.list_of\n                       (IArray.list_of (matrix_to_iarray A) ! m) !\n                      0)\n               [0..<length (IArray.list_of (matrix_to_iarray A))])))", "have \"i < card (UNIV::'rows set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < CARD('rows)", "by (metis (no_types) i_nrows nrows_def)"], ["proof (state)\nthis:\n  i < CARD('rows)\n\ngoal (1 subgoal):\n 1. i < length\n         (IArray.list_of\n           ((IArray\n              (map (\\<lambda>m.\n                       IArray.list_of\n                        (IArray.list_of (matrix_to_iarray A) ! m) !\n                       k)\n                [0..<\n                 length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n             IArray\n              (map (\\<lambda>m.\n                       IArray.list_of\n                        (IArray.list_of (matrix_to_iarray A) ! m) !\n                       0)\n                [0..<length (IArray.list_of (matrix_to_iarray A))]) /\n             (IArray\n               (map (\\<lambda>m.\n                        IArray.list_of\n                         (IArray.list_of (matrix_to_iarray A) ! m) !\n                        0)\n                 [0..<\n                  length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n              IArray\n               (map (\\<lambda>m.\n                        IArray.list_of\n                         (IArray.list_of (matrix_to_iarray A) ! m) !\n                        0)\n                 [0..<\n                  length (IArray.list_of (matrix_to_iarray A))]))) *\\<^sub>R\n            IArray\n             (map (\\<lambda>m.\n                      IArray.list_of\n                       (IArray.list_of (matrix_to_iarray A) ! m) !\n                      0)\n               [0..<length (IArray.list_of (matrix_to_iarray A))])))", "thus \"i < length (IArray.list_of ((IArray (map (\\<lambda>n. IArray.list_of (IArray.list_of (matrix_to_iarray A) ! n) ! k) [0..<length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i IArray (map (\\<lambda>n. IArray.list_of (IArray.list_of (matrix_to_iarray A) ! n) ! 0) [0..<length (IArray.list_of (matrix_to_iarray A))]) / (IArray (map (\\<lambda>n. IArray.list_of (IArray.list_of (matrix_to_iarray A) ! n) ! 0) [0..<length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i IArray (map (\\<lambda>n. IArray.list_of (IArray.list_of (matrix_to_iarray A) ! n) ! 0) [0..<length (IArray.list_of (matrix_to_iarray A))]))) *\\<^sub>R IArray (map (\\<lambda>n. IArray.list_of (IArray.list_of (matrix_to_iarray A) ! n) ! 0) [0..<length (IArray.list_of (matrix_to_iarray A))])))\""], ["proof (prove)\nusing this:\n  i < CARD('rows)\n\ngoal (1 subgoal):\n 1. i < length\n         (IArray.list_of\n           ((IArray\n              (map (\\<lambda>n.\n                       IArray.list_of\n                        (IArray.list_of (matrix_to_iarray A) ! n) !\n                       k)\n                [0..<\n                 length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n             IArray\n              (map (\\<lambda>n.\n                       IArray.list_of\n                        (IArray.list_of (matrix_to_iarray A) ! n) !\n                       0)\n                [0..<length (IArray.list_of (matrix_to_iarray A))]) /\n             (IArray\n               (map (\\<lambda>n.\n                        IArray.list_of\n                         (IArray.list_of (matrix_to_iarray A) ! n) !\n                        0)\n                 [0..<\n                  length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n              IArray\n               (map (\\<lambda>n.\n                        IArray.list_of\n                         (IArray.list_of (matrix_to_iarray A) ! n) !\n                        0)\n                 [0..<\n                  length (IArray.list_of (matrix_to_iarray A))]))) *\\<^sub>R\n            IArray\n             (map (\\<lambda>n.\n                      IArray.list_of\n                       (IArray.list_of (matrix_to_iarray A) ! n) !\n                      0)\n               [0..<length (IArray.list_of (matrix_to_iarray A))])))", "by (simp add: matrix_to_iarray_def scaleR_iarray_def)"], ["proof (state)\nthis:\n  i < length\n       (IArray.list_of\n         ((IArray\n            (map (\\<lambda>n.\n                     IArray.list_of\n                      (IArray.list_of (matrix_to_iarray A) ! n) !\n                     k)\n              [0..<length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n           IArray\n            (map (\\<lambda>n.\n                     IArray.list_of\n                      (IArray.list_of (matrix_to_iarray A) ! n) !\n                     0)\n              [0..<length (IArray.list_of (matrix_to_iarray A))]) /\n           (IArray\n             (map (\\<lambda>n.\n                      IArray.list_of\n                       (IArray.list_of (matrix_to_iarray A) ! n) !\n                      0)\n               [0..<\n                length (IArray.list_of (matrix_to_iarray A))]) \\<bullet>i\n            IArray\n             (map (\\<lambda>n.\n                      IArray.list_of\n                       (IArray.list_of (matrix_to_iarray A) ! n) !\n                      0)\n               [0..<\n                length (IArray.list_of (matrix_to_iarray A))]))) *\\<^sub>R\n          IArray\n           (map (\\<lambda>n.\n                    IArray.list_of\n                     (IArray.list_of (matrix_to_iarray A) ! n) !\n                    0)\n             [0..<length (IArray.list_of (matrix_to_iarray A))])))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < IArray.length\n       ((column_iarray k (matrix_to_iarray A) \\<bullet>i\n         column_iarray 0 (matrix_to_iarray A) /\n         (column_iarray 0 (matrix_to_iarray A) \\<bullet>i\n          column_iarray 0 (matrix_to_iarray A))) *\\<^sub>R\n        column_iarray 0 (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. IArray.length\n     ((column_iarray k (matrix_to_iarray A) \\<bullet>i\n       column_iarray 0 (matrix_to_iarray A) /\n       (column_iarray 0 (matrix_to_iarray A) \\<bullet>i\n        column_iarray 0 (matrix_to_iarray A))) *\\<^sub>R\n      column_iarray 0 (matrix_to_iarray A))\n    \\<in> {IArray.length\n            ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n              (x \\<bullet>i x)) *\\<^sub>R\n             x) |\n           x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}}", "show \"?c \\<in> {IArray.length ((column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x) \n            |x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     ((column_iarray k (matrix_to_iarray A) \\<bullet>i\n       column_iarray 0 (matrix_to_iarray A) /\n       (column_iarray 0 (matrix_to_iarray A) \\<bullet>i\n        column_iarray 0 (matrix_to_iarray A))) *\\<^sub>R\n      column_iarray 0 (matrix_to_iarray A))\n    \\<in> {IArray.length\n            ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n              (x \\<bullet>i x)) *\\<^sub>R\n             x) |\n           x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}}", "using False"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. IArray.length\n     ((column_iarray k (matrix_to_iarray A) \\<bullet>i\n       column_iarray 0 (matrix_to_iarray A) /\n       (column_iarray 0 (matrix_to_iarray A) \\<bullet>i\n        column_iarray 0 (matrix_to_iarray A))) *\\<^sub>R\n      column_iarray 0 (matrix_to_iarray A))\n    \\<in> {IArray.length\n            ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n              (x \\<bullet>i x)) *\\<^sub>R\n             x) |\n           x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                      {0..<k}}", "by auto"], ["proof (state)\nthis:\n  IArray.length\n   ((column_iarray k (matrix_to_iarray A) \\<bullet>i\n     column_iarray 0 (matrix_to_iarray A) /\n     (column_iarray 0 (matrix_to_iarray A) \\<bullet>i\n      column_iarray 0 (matrix_to_iarray A))) *\\<^sub>R\n    column_iarray 0 (matrix_to_iarray A))\n  \\<in> {IArray.length\n          ((column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n            (x \\<bullet>i x)) *\\<^sub>R\n           x) |\n         x. x \\<in> (\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                    {0..<k}}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < IArray.length\n       (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                    {0..<k}.\n          (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n           (x \\<bullet>i x)) *\\<^sub>R\n          x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                {0..<k}.\n      (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x)) !!\n  i =\n  column_iarray k (matrix_to_iarray A) !! i -\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x) !!\n  i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "also"], ["proof (state)\nthis:\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                {0..<k}.\n      (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x)) !!\n  i =\n  column_iarray k (matrix_to_iarray A) !! i -\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x) !!\n  i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have \"... = column_iarray k (matrix_to_iarray A) !! i -\n        (\\<Sum>x\\<in>{column i A |i. i < from_nat k}. column (from_nat k) A \\<bullet> x * x $ from_nat i / (x \\<bullet> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column_iarray k (matrix_to_iarray A) !! i -\n    (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                 {0..<k}.\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n        (x \\<bullet>i x)) *\\<^sub>R\n       x) !!\n    i =\n    column_iarray k (matrix_to_iarray A) !! i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x))", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. column_iarray k (matrix_to_iarray A) !! i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    column_iarray k (matrix_to_iarray A) !! i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x))", ".."], ["proof (state)\nthis:\n  column_iarray k (matrix_to_iarray A) !! i -\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x) !!\n  i =\n  column_iarray k (matrix_to_iarray A) !! i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "also"], ["proof (state)\nthis:\n  column_iarray k (matrix_to_iarray A) !! i -\n  (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}.\n     (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n      (x \\<bullet>i x)) *\\<^sub>R\n     x) !!\n  i =\n  column_iarray k (matrix_to_iarray A) !! i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "have \"... = column (from_nat k) A $ from_nat i -\n        (\\<Sum>x\\<in>{column i A |i. i < from_nat k}. column (from_nat k) A \\<bullet> x * x $ from_nat i / (x \\<bullet> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column_iarray k (matrix_to_iarray A) !! i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x))", "unfolding vec_to_iarray_column[of \"from_nat k::'cols\",symmetric,unfolded to_nat_from_nat_id[OF k[unfolded ncols_def]]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (column (mod_type_class.from_nat k) A) !! i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x))", "unfolding vec_to_iarray_nth[OF i_nrows[unfolded nrows_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x))", ".."], ["proof (state)\nthis:\n  column_iarray k (matrix_to_iarray A) !! i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x)) =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", "finally"], ["proof (chain)\npicking this:\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                {0..<k}.\n      (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x)) !!\n  i =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x))", "show \"column (from_nat k) A $ from_nat i -\n        (\\<Sum>x\\<in>{column i A |i. i < from_nat k}. column (from_nat k) A \\<bullet> x * x $ from_nat i / (x \\<bullet> x)) =\n        (column_iarray k (matrix_to_iarray A) -\n        (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) ` {0..<k}. (column_iarray k (matrix_to_iarray A) \\<bullet>i  x/ (x \\<bullet>i x)) *\\<^sub>R x)) !! i\""], ["proof (prove)\nusing this:\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                {0..<k}.\n      (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x)) !!\n  i =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x))\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                  {0..<k}.\n        (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n         (x \\<bullet>i x)) *\\<^sub>R\n        x)) !!\n    i", ".."], ["proof (state)\nthis:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x)) =\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                {0..<k}.\n      (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x)) !!\n  i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x)) =\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<in>(\\<lambda>n. column_iarray n (matrix_to_iarray A)) `\n                {0..<k}.\n      (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n       (x \\<bullet>i x)) *\\<^sub>R\n      x)) !!\n  i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia = mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat k) A $\n                      mod_type_class.from_nat i -\n                      (\\<Sum>x\\<in>{column i A |i.\n                                    i < mod_type_class.from_nat k}.\n                         column (mod_type_class.from_nat k) A \\<bullet> x *\n                         x $ mod_type_class.from_nat i /\n                         (x \\<bullet> x)) =\n                      column_iarray ia (matrix_to_iarray A) !! i\n 2. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia \\<noteq> mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat ia) A $\n                      mod_type_class.from_nat i =\n                      column_iarray ia (matrix_to_iarray A) !! i", "show \"column (from_nat ia) A $ from_nat i = column_iarray ia (matrix_to_iarray A) !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat ia) A $ mod_type_class.from_nat i =\n    column_iarray ia (matrix_to_iarray A) !! i", "unfolding vec_to_iarray_nth[symmetric, OF i_nrows[unfolded nrows_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (column (mod_type_class.from_nat ia) A) !! i =\n    column_iarray ia (matrix_to_iarray A) !! i", "unfolding vec_to_iarray_column'[symmetric, OF ia_ncols]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (column (mod_type_class.from_nat ia) A) !! i =\n    vec_to_iarray (column (mod_type_class.from_nat ia) A) !! i", ".."], ["proof (state)\nthis:\n  column (mod_type_class.from_nat ia) A $ mod_type_class.from_nat i =\n  column_iarray ia (matrix_to_iarray A) !! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia = mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat k) A $\n                      mod_type_class.from_nat i -\n                      (\\<Sum>x\\<in>{column i A |i.\n                                    i < mod_type_class.from_nat k}.\n                         column (mod_type_class.from_nat k) A \\<bullet> x *\n                         x $ mod_type_class.from_nat i /\n                         (x \\<bullet> x)) =\n                      column_iarray ia (matrix_to_iarray A) !! i", "assume ia_not_k: \"ia \\<noteq> k\"\n      and eq: \"from_nat ia = (from_nat k::'cols)\""], ["proof (state)\nthis:\n  ia \\<noteq> k\n  mod_type_class.from_nat ia = mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia = mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat k) A $\n                      mod_type_class.from_nat i -\n                      (\\<Sum>x\\<in>{column i A |i.\n                                    i < mod_type_class.from_nat k}.\n                         column (mod_type_class.from_nat k) A \\<bullet> x *\n                         x $ mod_type_class.from_nat i /\n                         (x \\<bullet> x)) =\n                      column_iarray ia (matrix_to_iarray A) !! i", "have \"ia=k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia = k", "by (rule from_nat_eq_imp_eq[OF eq ia_ncols[unfolded ncols_def] k[unfolded ncols_def]])"], ["proof (state)\nthis:\n  ia = k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia = mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> column (mod_type_class.from_nat k) A $\n                      mod_type_class.from_nat i -\n                      (\\<Sum>x\\<in>{column i A |i.\n                                    i < mod_type_class.from_nat k}.\n                         column (mod_type_class.from_nat k) A \\<bullet> x *\n                         x $ mod_type_class.from_nat i /\n                         (x \\<bullet> x)) =\n                      column_iarray ia (matrix_to_iarray A) !! i", "thus \"column (from_nat k) A $ from_nat i \n      - (\\<Sum>x\\<in>{column i A |i. i < from_nat k}. \n      column (from_nat k) A \\<bullet> x * x $ from_nat i / (x \\<bullet> x)) \n      = column_iarray ia (matrix_to_iarray A) !! i\""], ["proof (prove)\nusing this:\n  ia = k\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    column_iarray ia (matrix_to_iarray A) !! i", "using ia_not_k"], ["proof (prove)\nusing this:\n  ia = k\n  ia \\<noteq> k\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n       column (mod_type_class.from_nat k) A \\<bullet> x *\n       x $ mod_type_class.from_nat i /\n       (x \\<bullet> x)) =\n    column_iarray ia (matrix_to_iarray A) !! i", "by contradiction"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat k}.\n     column (mod_type_class.from_nat k) A \\<bullet> x *\n     x $ mod_type_class.from_nat i /\n     (x \\<bullet> x)) =\n  column_iarray ia (matrix_to_iarray A) !! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_to_iarray (Gram_Schmidt_column_k A k) !! i !! ia =\n  Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) k !! i !! ia\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_Gram_Schmidt_upt_k:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  shows \"matrix_to_iarray (Gram_Schmidt_upt_k A k) = Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n    Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k", "using k"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n    Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    matrix_to_iarray (Gram_Schmidt_upt_k A 0) =\n    Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) 0\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)", "case 0"], ["proof (state)\nthis:\n  0 < ncols A\n\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    matrix_to_iarray (Gram_Schmidt_upt_k A 0) =\n    Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) 0\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A 0) =\n    Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) 0", "unfolding Gram_Schmidt_upt_k_def Gram_Schmidt_upt_k_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (foldl Gram_Schmidt_column_k A [0..<Suc 0]) =\n    foldl Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) [0..<Suc 0]", "by (simp add: matrix_to_iarray_Gram_Schmidt_column_k[OF \"0.prems\"])"], ["proof (state)\nthis:\n  matrix_to_iarray (Gram_Schmidt_upt_k A 0) =\n  Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  k < ncols A \\<Longrightarrow>\n  matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n  Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)", "have k: \"k<ncols (Gram_Schmidt_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols (Gram_Schmidt_upt_k A k)", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. k < ncols (Gram_Schmidt_upt_k A k)", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('cols)\n\ngoal (1 subgoal):\n 1. k < CARD('cols)", "by simp"], ["proof (state)\nthis:\n  k < ncols (Gram_Schmidt_upt_k A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)", "have k2: \"Suc k < ncols (Gram_Schmidt_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k < ncols (Gram_Schmidt_upt_k A k)", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. Suc k < ncols (Gram_Schmidt_upt_k A k)", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('cols)\n\ngoal (1 subgoal):\n 1. Suc k < CARD('cols)", "."], ["proof (state)\nthis:\n  Suc k < ncols (Gram_Schmidt_upt_k A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)", "have list_rw: \"[0..<Suc (Suc k)] = [0..<Suc k] @ [(Suc k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)", "have hyp: \"matrix_to_iarray (Gram_Schmidt_upt_k A k) = Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n    Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k", "by (metis Suc.hyps Suc.prems Suc_lessD)"], ["proof (state)\nthis:\n  matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n  Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)", "show \"matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) = Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n    Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) (Suc k)", "unfolding Gram_Schmidt_upt_k_def Gram_Schmidt_upt_k_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (foldl Gram_Schmidt_column_k A [0..<Suc (Suc k)]) =\n    foldl Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n     [0..<Suc (Suc k)]", "unfolding list_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (foldl Gram_Schmidt_column_k A ([0..<Suc k] @ [Suc k])) =\n    foldl Gram_Schmidt_column_k_iarrays (matrix_to_iarray A)\n     ([0..<Suc k] @ [Suc k])", "unfolding foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (foldl Gram_Schmidt_column_k\n       (foldl Gram_Schmidt_column_k A [0..<Suc k]) [Suc k]) =\n    foldl Gram_Schmidt_column_k_iarrays\n     (foldl Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) [0..<Suc k])\n     [Suc k]", "unfolding foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n       (Suc k)) =\n    Gram_Schmidt_column_k_iarrays\n     (foldl Gram_Schmidt_column_k_iarrays (matrix_to_iarray A) [0..<Suc k])\n     (Suc k)", "unfolding Gram_Schmidt_upt_k_def[symmetric] Gram_Schmidt_upt_k_iarrays_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    Gram_Schmidt_column_k_iarrays\n     (Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) k) (Suc k)", "unfolding hyp[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    Gram_Schmidt_column_k_iarrays\n     (matrix_to_iarray (Gram_Schmidt_upt_k A k)) (Suc k)", "by (rule matrix_to_iarray_Gram_Schmidt_column_k[OF k2])"], ["proof (state)\nthis:\n  matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n  Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_Gram_Schmidt_matrix[code_unfold]:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (Gram_Schmidt_matrix A) = Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_matrix A) =\n    Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)", "unfolding Gram_Schmidt_matrix_def Gram_Schmidt_matrix_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A (ncols A - 1)) =\n    Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A)\n     (ncols_iarray (matrix_to_iarray A) - 1)", "unfolding matrix_to_iarray_ncols[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A (ncols A - 1)) =\n    Gram_Schmidt_upt_k_iarrays (matrix_to_iarray A) (ncols A - 1)", "by (rule matrix_to_iarray_Gram_Schmidt_upt_k, simp add: ncols_def)"], ["", "text\\<open>Examples:\\<close>"], ["", "value\"let A = list_of_list_to_matrix [[4,5],[8,1],[-1,5]]::real^2^3\n  in iarray_of_iarray_to_list_of_list (matrix_to_iarray (Gram_Schmidt_matrix A))\""], ["", "value \"let A = IArray[IArray[4,5],IArray[8,1],IArray[-1,5]]\n  in iarray_of_iarray_to_list_of_list (Gram_Schmidt_matrix_iarrays A)\""], ["", "end"]]}