{"file_name": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition/Miscellaneous_QR.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition", "problem_names": ["lemma [code abstract]: \"vec_nth (a - b) =  (%i. a$i - b$i)\"", "lemma [code abstract]: \"vec_nth (c *\\<^sub>R x) = (\\<lambda>i. c *\\<^sub>R (x$i))\"", "lemma from_nat_le:\n  fixes i::\"'a::{mod_type}\"\n  assumes i: \"to_nat i< k\"\n  and k: \"k<CARD('a)\"\n  shows \"i < from_nat k\"", "lemma orthogonal_mult:\n  assumes \"orthogonal a b\"\n  shows \"orthogonal (x *\\<^sub>R a) (y *\\<^sub>R b)\"", "lemma orthogonal_matrix_is_orthogonal:\n  fixes A::\"real^'n^'n\"\n  assumes o: \"orthogonal_matrix A\" \n  shows \"(pairwise orthogonal (columns A))\"", "lemma orthogonal_matrix_norm:\n  fixes A::\"real^'n^'n\"\n  assumes o: \"orthogonal_matrix A\" \n  shows \"norm (column i A) = 1\"", "lemma orthogonal_matrix_card:\n  fixes A::\"real^'n^'n\"\n  assumes o: \"orthogonal_matrix A\" \n  shows \"card (columns A) = ncols A\"", "lemma orthogonal_matrix_intro:        \n  fixes A::\"real^'n^'n\"\n  assumes p: \"(pairwise orthogonal (columns A))\"\n  and n: \"\\<forall>i. norm (column i A) = 1\"\n  and c: \"card (columns A) = ncols A\" (*We need that premise to avoid the case that column i A = column j A when i \\<noteq> j*)\n  shows \"orthogonal_matrix A\"", "lemma orthogonal_matrix2:\n  fixes A::\"real^'n^'n\"\n  shows \"orthogonal_matrix A = ((pairwise orthogonal (columns A)) \\<and> (\\<forall>i. norm (column i A) = 1) \\<and>\n  (card (columns A) = ncols A))\"", "lemma orthogonal_matrix': \"orthogonal_matrix (Q:: real ^'n^'n) \\<longleftrightarrow>  Q ** transpose Q= mat 1\"", "lemma orthogonal_matrix_intro2:        \n  fixes A::\"real^'n^'n\"\n  assumes p: \"(pairwise orthogonal (rows A))\"\n  and n: \"\\<forall>i. norm (row i A) = 1\"\n  and c: \"card (rows A) = nrows A\" (*We need that premise to avoid the case that row i A = row j A when i \\<noteq> j*)\n  shows \"orthogonal_matrix A\"", "lemma is_basis_imp_full_rank:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes b: \"is_basis (columns A)\"\n  and c: \"card (columns A) = ncols A\"\n  shows \"rank A = ncols A\"", "lemma card_columns_le_ncols:\n  \"card (columns A) \\<le> ncols A\"", "lemma full_rank_imp_is_basis:\n  fixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"is_basis (columns A) \\<and> card (columns A) = ncols A\"", "lemma full_rank_imp_is_basis2:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"vec.independent (columns A) \\<and> vec.span (columns A) = col_space A \n        \\<and> card (columns A) = ncols A\"", "lemma full_col_rank_imp_independent_columns:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"rank A = ncols A\"\n  shows \"vec.independent (columns A)\"", "lemma matrix_vector_right_distrib_minus:\n  fixes A::\"'a::{ring_1}^'n^'m\"\n  shows \"A *v (b - c) = (A *v b) - (A *v c)\"", "lemma inv_matrix_vector_mul_left:\n  assumes i: \"invertible A\"\n  shows \"(A *v x = A *v y) = (x=y)\"", "lemma norm_mult_vec:\n  fixes a::\"(real,'b::finite) vec\"\n  shows \"norm (x \\<bullet> x) = norm x * norm x\"", "lemma norm_equivalence: \n  fixes A::\"real^'n^'m\"\n  shows \"((transpose A) *v (A *v x) = 0) \\<longleftrightarrow> (A *v x = 0)\"", "lemma invertible_transpose_mult:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"invertible (transpose A ** A)\"", "lemma matrix_inv_mult:\n  fixes A::\"'a::{semiring_1}^'n^'n\"\n  and B::\"'a::{semiring_1}^'n^'n\"\n  assumes \"invertible A\" and \"invertible B\"\n  shows \"matrix_inv (A ** B) = matrix_inv B ** matrix_inv A\"", "lemma invertible_transpose:\n  fixes A::\"'a::{field}^'n^'n\"\n  assumes \"invertible A\"\n  shows \"invertible (transpose A)\"", "lemma span_eq: \"(span S = span T) = (S \\<subseteq> span T \\<and> T \\<subseteq> span S)\"", "lemma basis_orthogonal:\n  fixes B :: \"'a::real_inner set\"\n  assumes fB: \"finite B\"\n  shows \"\\<exists>C. finite C \\<and> card C \\<le> card B \\<and> span C\n        = span B \\<and> pairwise orthogonal C\"\n  (is \" \\<exists>C. ?P B C\")", "lemma op_vec_scaleR: \"(*s) = (*\\<^sub>R)\""], "translations": [["", "lemma [code abstract]: \"vec_nth (a - b) =  (%i. a$i - b$i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (a - b) = (\\<lambda>i. a $ i - b $ i)", "by (metis vector_minus_component)"], ["", "lemma [code abstract]: \"vec_nth (c *\\<^sub>R x) = (\\<lambda>i. c *\\<^sub>R (x$i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (c *\\<^sub>R x) = (\\<lambda>i. c *\\<^sub>R x $ i)", "by auto"], ["", "text\\<open>This lemma maybe should be in the file \\<open>Mod_Type.thy\\<close> of the Gauss-Jordan\n  development.\\<close>"], ["", "lemma from_nat_le:\n  fixes i::\"'a::{mod_type}\"\n  assumes i: \"to_nat i< k\"\n  and k: \"k<CARD('a)\"\n  shows \"i < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat k", "by (metis (full_types) from_nat_mono from_nat_to_nat_id i k)"], ["", "text\\<open>Some properties about orthogonal matrices.\\<close>"], ["", "lemma orthogonal_mult:\n  assumes \"orthogonal a b\"\n  shows \"orthogonal (x *\\<^sub>R a) (y *\\<^sub>R b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal (x *\\<^sub>R a) (y *\\<^sub>R b)", "using assms"], ["proof (prove)\nusing this:\n  orthogonal a b\n\ngoal (1 subgoal):\n 1. orthogonal (x *\\<^sub>R a) (y *\\<^sub>R b)", "unfolding orthogonal_def"], ["proof (prove)\nusing this:\n  a \\<bullet> b = 0\n\ngoal (1 subgoal):\n 1. x *\\<^sub>R a \\<bullet> y *\\<^sub>R b = 0", "by simp"], ["", "lemma orthogonal_matrix_is_orthogonal:\n  fixes A::\"real^'n^'n\"\n  assumes o: \"orthogonal_matrix A\" \n  shows \"(pairwise orthogonal (columns A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal (columns A)", "proof (unfold pairwise_def columns_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       column i A \\<noteq> column ia A \\<Longrightarrow>\n       orthogonal (column i A) (column ia A)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       column i A \\<noteq> column ia A \\<Longrightarrow>\n       orthogonal (column i A) (column ia A)", "assume column_i_not_j: \"column i A \\<noteq> column j A\""], ["proof (state)\nthis:\n  column i A \\<noteq> column j A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       column i A \\<noteq> column ia A \\<Longrightarrow>\n       orthogonal (column i A) (column ia A)", "hence i_not_j: \"i \\<noteq> j\""], ["proof (prove)\nusing this:\n  column i A \\<noteq> column j A\n\ngoal (1 subgoal):\n 1. i \\<noteq> j", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       column i A \\<noteq> column ia A \\<Longrightarrow>\n       orthogonal (column i A) (column ia A)", "have \"0 = (mat 1) $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) = mat (1::'a) $ i $ j", "by (metis i_not_j mat_1_fun)"], ["proof (state)\nthis:\n  (0::?'a1) = mat (1::?'a1) $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       column i A \\<noteq> column ia A \\<Longrightarrow>\n       orthogonal (column i A) (column ia A)", "also"], ["proof (state)\nthis:\n  (0::?'a1) = mat (1::?'a1) $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       column i A \\<noteq> column ia A \\<Longrightarrow>\n       orthogonal (column i A) (column ia A)", "have \"... = (transpose A ** A) $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 $ i $ j = (Finite_Cartesian_Product.transpose A ** A) $ i $ j", "using o"], ["proof (prove)\nusing this:\n  orthogonal_matrix A\n\ngoal (1 subgoal):\n 1. mat 1 $ i $ j = (Finite_Cartesian_Product.transpose A ** A) $ i $ j", "unfolding orthogonal_matrix"], ["proof (prove)\nusing this:\n  Finite_Cartesian_Product.transpose A ** A = mat 1\n\ngoal (1 subgoal):\n 1. mat 1 $ i $ j = (Finite_Cartesian_Product.transpose A ** A) $ i $ j", "by simp"], ["proof (state)\nthis:\n  mat 1 $ i $ j = (Finite_Cartesian_Product.transpose A ** A) $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       column i A \\<noteq> column ia A \\<Longrightarrow>\n       orthogonal (column i A) (column ia A)", "also"], ["proof (state)\nthis:\n  mat 1 $ i $ j = (Finite_Cartesian_Product.transpose A ** A) $ i $ j\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       column i A \\<noteq> column ia A \\<Longrightarrow>\n       orthogonal (column i A) (column ia A)", "have \"... = row i (transpose A) \\<bullet> column j A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A ** A) $ i $ j =\n    row i (Finite_Cartesian_Product.transpose A) \\<bullet> column j A", "unfolding matrix_matrix_mult_inner_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. row i (Finite_Cartesian_Product.transpose A) \\<bullet> column j A =\n    row i (Finite_Cartesian_Product.transpose A) \\<bullet> column j A", "by simp"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A ** A) $ i $ j =\n  row i (Finite_Cartesian_Product.transpose A) \\<bullet> column j A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       column i A \\<noteq> column ia A \\<Longrightarrow>\n       orthogonal (column i A) (column ia A)", "also"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A ** A) $ i $ j =\n  row i (Finite_Cartesian_Product.transpose A) \\<bullet> column j A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       column i A \\<noteq> column ia A \\<Longrightarrow>\n       orthogonal (column i A) (column ia A)", "have \"... = column i A \\<bullet> column j A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row i (Finite_Cartesian_Product.transpose A) \\<bullet> column j A =\n    column i A \\<bullet> column j A", "unfolding row_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. column i A \\<bullet> column j A = column i A \\<bullet> column j A", ".."], ["proof (state)\nthis:\n  row i (Finite_Cartesian_Product.transpose A) \\<bullet> column j A =\n  column i A \\<bullet> column j A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       column i A \\<noteq> column ia A \\<Longrightarrow>\n       orthogonal (column i A) (column ia A)", "finally"], ["proof (chain)\npicking this:\n  0 = column i A \\<bullet> column j A", "show \"orthogonal (column i A) (column j A)\""], ["proof (prove)\nusing this:\n  0 = column i A \\<bullet> column j A\n\ngoal (1 subgoal):\n 1. orthogonal (column i A) (column j A)", "unfolding orthogonal_def"], ["proof (prove)\nusing this:\n  0 = column i A \\<bullet> column j A\n\ngoal (1 subgoal):\n 1. column i A \\<bullet> column j A = 0", ".."], ["proof (state)\nthis:\n  orthogonal (column i A) (column j A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_matrix_norm:\n  fixes A::\"real^'n^'n\"\n  assumes o: \"orthogonal_matrix A\" \n  shows \"norm (column i A) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (column i A) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (column i A) = 1", "have \"1 = (transpose A ** A) $ i $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = (Finite_Cartesian_Product.transpose A ** A) $ i $ i", "using o"], ["proof (prove)\nusing this:\n  orthogonal_matrix A\n\ngoal (1 subgoal):\n 1. 1 = (Finite_Cartesian_Product.transpose A ** A) $ i $ i", "unfolding orthogonal_matrix"], ["proof (prove)\nusing this:\n  Finite_Cartesian_Product.transpose A ** A = mat 1\n\ngoal (1 subgoal):\n 1. 1 = (Finite_Cartesian_Product.transpose A ** A) $ i $ i", "by (simp add: mat_1_fun)"], ["proof (state)\nthis:\n  1 = (Finite_Cartesian_Product.transpose A ** A) $ i $ i\n\ngoal (1 subgoal):\n 1. norm (column i A) = 1", "also"], ["proof (state)\nthis:\n  1 = (Finite_Cartesian_Product.transpose A ** A) $ i $ i\n\ngoal (1 subgoal):\n 1. norm (column i A) = 1", "have \"... = (column i A) \\<bullet> (column i A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A ** A) $ i $ i =\n    column i A \\<bullet> column i A", "unfolding matrix_matrix_mult_inner_mult row_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. column i A \\<bullet> column i A = column i A \\<bullet> column i A", ".."], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A ** A) $ i $ i =\n  column i A \\<bullet> column i A\n\ngoal (1 subgoal):\n 1. norm (column i A) = 1", "finally"], ["proof (chain)\npicking this:\n  1 = column i A \\<bullet> column i A", "show \"norm (column i A) = 1\""], ["proof (prove)\nusing this:\n  1 = column i A \\<bullet> column i A\n\ngoal (1 subgoal):\n 1. norm (column i A) = 1", "using norm_eq_1"], ["proof (prove)\nusing this:\n  1 = column i A \\<bullet> column i A\n  (norm ?x = 1) = (?x \\<bullet> ?x = 1)\n\ngoal (1 subgoal):\n 1. norm (column i A) = 1", "by auto"], ["proof (state)\nthis:\n  norm (column i A) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_matrix_card:\n  fixes A::\"real^'n^'n\"\n  assumes o: \"orthogonal_matrix A\" \n  shows \"card (columns A) = ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (columns A) = ncols A", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. card (columns A) \\<noteq> ncols A \\<Longrightarrow> False", "assume card_not_ncols: \"card (columns A) \\<noteq> ncols A\""], ["proof (state)\nthis:\n  card (columns A) \\<noteq> ncols A\n\ngoal (1 subgoal):\n 1. card (columns A) \\<noteq> ncols A \\<Longrightarrow> False", "have \"\\<exists>i j. column i A = column j A \\<and> i\\<noteq>j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i j. column i A = column j A \\<and> i \\<noteq> j", "proof (rule ccontr, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       column i A = column j A \\<longrightarrow> i = j \\<Longrightarrow>\n    False", "assume col_eq: \"\\<forall>i j. column i A = column j A \\<longrightarrow> i = j\""], ["proof (state)\nthis:\n  \\<forall>i j. column i A = column j A \\<longrightarrow> i = j\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       column i A = column j A \\<longrightarrow> i = j \\<Longrightarrow>\n    False", "have \"card (columns A) = card {i. i \\<in> (UNIV::'n set)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (columns A) = card {i. i \\<in> UNIV}", "by (rule bij_betw_same_card[symmetric, of \"\\<lambda>i. column i A\"], \n        auto simp add: bij_betw_def columns_def inj_on_def col_eq)"], ["proof (state)\nthis:\n  card (columns A) = card {i. i \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       column i A = column j A \\<longrightarrow> i = j \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  card (columns A) = card {i. i \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       column i A = column j A \\<longrightarrow> i = j \\<Longrightarrow>\n    False", "have \"... = ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {i. i \\<in> UNIV} = ncols A", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {i. i \\<in> UNIV} = CARD('n)", "by simp"], ["proof (state)\nthis:\n  card {i. i \\<in> UNIV} = ncols A\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       column i A = column j A \\<longrightarrow> i = j \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  card (columns A) = ncols A", "show False"], ["proof (prove)\nusing this:\n  card (columns A) = ncols A\n\ngoal (1 subgoal):\n 1. False", "using card_not_ncols"], ["proof (prove)\nusing this:\n  card (columns A) = ncols A\n  card (columns A) \\<noteq> ncols A\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i j. column i A = column j A \\<and> i \\<noteq> j\n\ngoal (1 subgoal):\n 1. card (columns A) \\<noteq> ncols A \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>i j. column i A = column j A \\<and> i \\<noteq> j", "obtain i j where col_eq: \"column i A = column j A\" and i_not_j: \"i \\<noteq> j\""], ["proof (prove)\nusing this:\n  \\<exists>i j. column i A = column j A \\<and> i \\<noteq> j\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>column i A = column j A; i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  column i A = column j A\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. card (columns A) \\<noteq> ncols A \\<Longrightarrow> False", "have \"0 = (mat 1) $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) = mat (1::'a) $ i $ j", "using mat_1_fun i_not_j"], ["proof (prove)\nusing this:\n  mat (1::?'a) $ ?a $ ?b = (if ?a = ?b then 1::?'a else (0::?'a))\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. (0::'a) = mat (1::'a) $ i $ j", "by metis"], ["proof (state)\nthis:\n  (0::?'a1) = mat (1::?'a1) $ i $ j\n\ngoal (1 subgoal):\n 1. card (columns A) \\<noteq> ncols A \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (0::?'a1) = mat (1::?'a1) $ i $ j\n\ngoal (1 subgoal):\n 1. card (columns A) \\<noteq> ncols A \\<Longrightarrow> False", "have \"... = (transpose A ** A) $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 $ i $ j = (Finite_Cartesian_Product.transpose A ** A) $ i $ j", "using o"], ["proof (prove)\nusing this:\n  orthogonal_matrix A\n\ngoal (1 subgoal):\n 1. mat 1 $ i $ j = (Finite_Cartesian_Product.transpose A ** A) $ i $ j", "unfolding orthogonal_matrix"], ["proof (prove)\nusing this:\n  Finite_Cartesian_Product.transpose A ** A = mat 1\n\ngoal (1 subgoal):\n 1. mat 1 $ i $ j = (Finite_Cartesian_Product.transpose A ** A) $ i $ j", "by simp"], ["proof (state)\nthis:\n  mat 1 $ i $ j = (Finite_Cartesian_Product.transpose A ** A) $ i $ j\n\ngoal (1 subgoal):\n 1. card (columns A) \\<noteq> ncols A \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  mat 1 $ i $ j = (Finite_Cartesian_Product.transpose A ** A) $ i $ j\n\ngoal (1 subgoal):\n 1. card (columns A) \\<noteq> ncols A \\<Longrightarrow> False", "have \"... = column i A \\<bullet> column j A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A ** A) $ i $ j =\n    column i A \\<bullet> column j A", "unfolding matrix_matrix_mult_inner_mult row_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. column i A \\<bullet> column j A = column i A \\<bullet> column j A", ".."], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A ** A) $ i $ j =\n  column i A \\<bullet> column j A\n\ngoal (1 subgoal):\n 1. card (columns A) \\<noteq> ncols A \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "by (metis calculation col_eq mat_1_fun matrix_matrix_mult_inner_mult \n      o orthogonal_matrix zero_neq_one)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_matrix_intro:        \n  fixes A::\"real^'n^'n\"\n  assumes p: \"(pairwise orthogonal (columns A))\"\n  and n: \"\\<forall>i. norm (column i A) = 1\"\n  and c: \"card (columns A) = ncols A\" (*We need that premise to avoid the case that column i A = column j A when i \\<noteq> j*)\n  shows \"orthogonal_matrix A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_matrix A", "proof (unfold orthogonal_matrix vec_eq_iff, clarify, unfold mat_1_fun, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia. (Finite_Cartesian_Product.transpose A ** A) $ ia $ ia = 1\n 2. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "fix ia"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia. (Finite_Cartesian_Product.transpose A ** A) $ ia $ ia = 1\n 2. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "have \"(transpose A ** A) $ ia $ ia = column ia A \\<bullet> column ia A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A ** A) $ ia $ ia =\n    column ia A \\<bullet> column ia A", "unfolding matrix_matrix_mult_inner_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. row ia (Finite_Cartesian_Product.transpose A) \\<bullet> column ia A =\n    column ia A \\<bullet> column ia A", "unfolding row_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. column ia A \\<bullet> column ia A = column ia A \\<bullet> column ia A", ".."], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A ** A) $ ia $ ia =\n  column ia A \\<bullet> column ia A\n\ngoal (2 subgoals):\n 1. \\<And>ia. (Finite_Cartesian_Product.transpose A ** A) $ ia $ ia = 1\n 2. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "also"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A ** A) $ ia $ ia =\n  column ia A \\<bullet> column ia A\n\ngoal (2 subgoals):\n 1. \\<And>ia. (Finite_Cartesian_Product.transpose A ** A) $ ia $ ia = 1\n 2. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "have \"... = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column ia A \\<bullet> column ia A = 1", "using n norm_eq_1"], ["proof (prove)\nusing this:\n  \\<forall>i. norm (column i A) = 1\n  (norm ?x = 1) = (?x \\<bullet> ?x = 1)\n\ngoal (1 subgoal):\n 1. column ia A \\<bullet> column ia A = 1", "by blast"], ["proof (state)\nthis:\n  column ia A \\<bullet> column ia A = 1\n\ngoal (2 subgoals):\n 1. \\<And>ia. (Finite_Cartesian_Product.transpose A ** A) $ ia $ ia = 1\n 2. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "finally"], ["proof (chain)\npicking this:\n  (Finite_Cartesian_Product.transpose A ** A) $ ia $ ia = 1", "show \"(transpose A ** A) $ ia $ ia = 1\""], ["proof (prove)\nusing this:\n  (Finite_Cartesian_Product.transpose A ** A) $ ia $ ia = 1\n\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A ** A) $ ia $ ia = 1", "."], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A ** A) $ ia $ ia = 1\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "assume i_not_ia: \"i \\<noteq> ia\""], ["proof (state)\nthis:\n  i \\<noteq> ia\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "have column_i_not_ia: \"column i A \\<noteq> column ia A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i A \\<noteq> column ia A", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. column i A = column ia A \\<Longrightarrow> False", "assume col_i_ia: \"column i A = column ia A\""], ["proof (state)\nthis:\n  column i A = column ia A\n\ngoal (1 subgoal):\n 1. column i A = column ia A \\<Longrightarrow> False", "have rw: \"(\\<lambda>i. column i A)` (UNIV-{ia}) = {column i A|i. i\\<noteq>ia}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. column i A) ` (UNIV - {ia}) =\n    {column i A |i. i \\<noteq> ia}", "unfolding columns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. column i A) ` (UNIV - {ia}) =\n    {column i A |i. i \\<noteq> ia}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>i. column i A) ` (UNIV - {ia}) = {column i A |i. i \\<noteq> ia}\n\ngoal (1 subgoal):\n 1. column i A = column ia A \\<Longrightarrow> False", "have \"card (columns A) = card ({column i A|i. i\\<noteq>ia})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (columns A) = card {column i A |i. i \\<noteq> ia}", "by (rule bij_betw_same_card[of id], unfold bij_betw_def columns_def)\n         (auto, metis col_i_ia i_not_ia)"], ["proof (state)\nthis:\n  card (columns A) = card {column i A |i. i \\<noteq> ia}\n\ngoal (1 subgoal):\n 1. column i A = column ia A \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card (columns A) = card {column i A |i. i \\<noteq> ia}\n\ngoal (1 subgoal):\n 1. column i A = column ia A \\<Longrightarrow> False", "have \"... = card ((\\<lambda>i. column i A)` (UNIV-{ia}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {column i A |i. i \\<noteq> ia} =\n    card ((\\<lambda>i. column i A) ` (UNIV - {ia}))", "unfolding rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {column i A |i. i \\<noteq> ia} =\n    card {column i A |i. i \\<noteq> ia}", ".."], ["proof (state)\nthis:\n  card {column i A |i. i \\<noteq> ia} =\n  card ((\\<lambda>i. column i A) ` (UNIV - {ia}))\n\ngoal (1 subgoal):\n 1. column i A = column ia A \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card {column i A |i. i \\<noteq> ia} =\n  card ((\\<lambda>i. column i A) ` (UNIV - {ia}))\n\ngoal (1 subgoal):\n 1. column i A = column ia A \\<Longrightarrow> False", "have \"... \\<le> card (UNIV - {ia})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>i. column i A) ` (UNIV - {ia})) \\<le> card (UNIV - {ia})", "by (metis card_image_le finite_code)"], ["proof (state)\nthis:\n  card ((\\<lambda>i. column i A) ` (UNIV - {ia})) \\<le> card (UNIV - {ia})\n\ngoal (1 subgoal):\n 1. column i A = column ia A \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card ((\\<lambda>i. column i A) ` (UNIV - {ia})) \\<le> card (UNIV - {ia})\n\ngoal (1 subgoal):\n 1. column i A = column ia A \\<Longrightarrow> False", "have \"... < CARD ('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (UNIV - {ia}) < CARD('n)", "by simp"], ["proof (state)\nthis:\n  card (UNIV - {ia}) < CARD('n)\n\ngoal (1 subgoal):\n 1. column i A = column ia A \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  card (columns A) < CARD('n)", "show False"], ["proof (prove)\nusing this:\n  card (columns A) < CARD('n)\n\ngoal (1 subgoal):\n 1. False", "using c"], ["proof (prove)\nusing this:\n  card (columns A) < CARD('n)\n  card (columns A) = ncols A\n\ngoal (1 subgoal):\n 1. False", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  card (columns A) < CARD('n)\n  card (columns A) = CARD('n)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  column i A \\<noteq> column ia A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "hence oia: \"orthogonal (column i A) (column ia A)\""], ["proof (prove)\nusing this:\n  column i A \\<noteq> column ia A\n\ngoal (1 subgoal):\n 1. orthogonal (column i A) (column ia A)", "using p"], ["proof (prove)\nusing this:\n  column i A \\<noteq> column ia A\n  pairwise orthogonal (columns A)\n\ngoal (1 subgoal):\n 1. orthogonal (column i A) (column ia A)", "unfolding pairwise_def"], ["proof (prove)\nusing this:\n  column i A \\<noteq> column ia A\n  \\<forall>x\\<in>columns A.\n     \\<forall>y\\<in>columns A. x \\<noteq> y \\<longrightarrow> orthogonal x y\n\ngoal (1 subgoal):\n 1. orthogonal (column i A) (column ia A)", "unfolding columns_def"], ["proof (prove)\nusing this:\n  column i A \\<noteq> column ia A\n  \\<forall>x\\<in>{column i A |i. i \\<in> UNIV}.\n     \\<forall>y\\<in>{column i A |i. i \\<in> UNIV}.\n        x \\<noteq> y \\<longrightarrow> orthogonal x y\n\ngoal (1 subgoal):\n 1. orthogonal (column i A) (column ia A)", "by auto"], ["proof (state)\nthis:\n  orthogonal (column i A) (column ia A)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "have \"(transpose A ** A) $ i $ ia = column i A \\<bullet> column ia A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A ** A) $ i $ ia =\n    column i A \\<bullet> column ia A", "unfolding matrix_matrix_mult_inner_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. row i (Finite_Cartesian_Product.transpose A) \\<bullet> column ia A =\n    column i A \\<bullet> column ia A", "unfolding row_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. column i A \\<bullet> column ia A = column i A \\<bullet> column ia A", ".."], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A ** A) $ i $ ia =\n  column i A \\<bullet> column ia A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "also"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A ** A) $ i $ ia =\n  column i A \\<bullet> column ia A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i A \\<bullet> column ia A = 0", "using oia"], ["proof (prove)\nusing this:\n  orthogonal (column i A) (column ia A)\n\ngoal (1 subgoal):\n 1. column i A \\<bullet> column ia A = 0", "unfolding orthogonal_def"], ["proof (prove)\nusing this:\n  column i A \\<bullet> column ia A = 0\n\ngoal (1 subgoal):\n 1. column i A \\<bullet> column ia A = 0", "."], ["proof (state)\nthis:\n  column i A \\<bullet> column ia A = 0\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "finally"], ["proof (chain)\npicking this:\n  (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "show \"(transpose A ** A) $ i $ ia = 0\""], ["proof (prove)\nusing this:\n  (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0\n\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0", "."], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A ** A) $ i $ ia = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_matrix2:\n  fixes A::\"real^'n^'n\"\n  shows \"orthogonal_matrix A = ((pairwise orthogonal (columns A)) \\<and> (\\<forall>i. norm (column i A) = 1) \\<and>\n  (card (columns A) = ncols A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_matrix A =\n    (pairwise orthogonal (columns A) \\<and>\n     (\\<forall>i. norm (column i A) = 1) \\<and> card (columns A) = ncols A)", "using orthogonal_matrix_intro[of A] \n    orthogonal_matrix_is_orthogonal[of A]\n    orthogonal_matrix_norm[of A]\n    orthogonal_matrix_card[of A]"], ["proof (prove)\nusing this:\n  \\<lbrakk>pairwise orthogonal (columns A);\n   \\<forall>i. norm (column i A) = 1; card (columns A) = ncols A\\<rbrakk>\n  \\<Longrightarrow> orthogonal_matrix A\n  orthogonal_matrix A \\<Longrightarrow> pairwise orthogonal (columns A)\n  orthogonal_matrix A \\<Longrightarrow> norm (column ?i A) = 1\n  orthogonal_matrix A \\<Longrightarrow> card (columns A) = ncols A\n\ngoal (1 subgoal):\n 1. orthogonal_matrix A =\n    (pairwise orthogonal (columns A) \\<and>\n     (\\<forall>i. norm (column i A) = 1) \\<and> card (columns A) = ncols A)", "by auto"], ["", "lemma orthogonal_matrix': \"orthogonal_matrix (Q:: real ^'n^'n) \\<longleftrightarrow>  Q ** transpose Q= mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_matrix Q =\n    (Q ** Finite_Cartesian_Product.transpose Q = mat 1)", "by (metis matrix_left_right_inverse orthogonal_matrix_def)"], ["", "lemma orthogonal_matrix_intro2:        \n  fixes A::\"real^'n^'n\"\n  assumes p: \"(pairwise orthogonal (rows A))\"\n  and n: \"\\<forall>i. norm (row i A) = 1\"\n  and c: \"card (rows A) = nrows A\" (*We need that premise to avoid the case that row i A = row j A when i \\<noteq> j*)\n  shows \"orthogonal_matrix A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_matrix A", "proof (unfold orthogonal_matrix' vec_eq_iff, clarify, unfold mat_1_fun, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia. (A ** Finite_Cartesian_Product.transpose A) $ ia $ ia = 1\n 2. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "fix ia"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia. (A ** Finite_Cartesian_Product.transpose A) $ ia $ ia = 1\n 2. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "have \"(A ** transpose A) $ ia $ ia = row ia A \\<bullet> row ia A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ** Finite_Cartesian_Product.transpose A) $ ia $ ia =\n    row ia A \\<bullet> row ia A", "unfolding matrix_matrix_mult_inner_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. row ia A \\<bullet> column ia (Finite_Cartesian_Product.transpose A) =\n    row ia A \\<bullet> row ia A", "unfolding column_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. row ia A \\<bullet> row ia A = row ia A \\<bullet> row ia A", ".."], ["proof (state)\nthis:\n  (A ** Finite_Cartesian_Product.transpose A) $ ia $ ia =\n  row ia A \\<bullet> row ia A\n\ngoal (2 subgoals):\n 1. \\<And>ia. (A ** Finite_Cartesian_Product.transpose A) $ ia $ ia = 1\n 2. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "also"], ["proof (state)\nthis:\n  (A ** Finite_Cartesian_Product.transpose A) $ ia $ ia =\n  row ia A \\<bullet> row ia A\n\ngoal (2 subgoals):\n 1. \\<And>ia. (A ** Finite_Cartesian_Product.transpose A) $ ia $ ia = 1\n 2. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "have \"... = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row ia A \\<bullet> row ia A = 1", "using n norm_eq_1"], ["proof (prove)\nusing this:\n  \\<forall>i. norm (row i A) = 1\n  (norm ?x = 1) = (?x \\<bullet> ?x = 1)\n\ngoal (1 subgoal):\n 1. row ia A \\<bullet> row ia A = 1", "by blast"], ["proof (state)\nthis:\n  row ia A \\<bullet> row ia A = 1\n\ngoal (2 subgoals):\n 1. \\<And>ia. (A ** Finite_Cartesian_Product.transpose A) $ ia $ ia = 1\n 2. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "finally"], ["proof (chain)\npicking this:\n  (A ** Finite_Cartesian_Product.transpose A) $ ia $ ia = 1", "show \"(A ** transpose A) $ ia $ ia = 1\""], ["proof (prove)\nusing this:\n  (A ** Finite_Cartesian_Product.transpose A) $ ia $ ia = 1\n\ngoal (1 subgoal):\n 1. (A ** Finite_Cartesian_Product.transpose A) $ ia $ ia = 1", "."], ["proof (state)\nthis:\n  (A ** Finite_Cartesian_Product.transpose A) $ ia $ ia = 1\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "assume i_not_ia: \"i \\<noteq> ia\""], ["proof (state)\nthis:\n  i \\<noteq> ia\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "have row_i_not_ia: \"row i A \\<noteq> row ia A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row i A \\<noteq> row ia A", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. row i A = row ia A \\<Longrightarrow> False", "assume row_i_ia:\"row i A = row ia A\""], ["proof (state)\nthis:\n  row i A = row ia A\n\ngoal (1 subgoal):\n 1. row i A = row ia A \\<Longrightarrow> False", "have rw: \"(\\<lambda>i. row i A)` (UNIV-{ia}) = {row i A|i. i\\<noteq>ia}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. row i A) ` (UNIV - {ia}) = {row i A |i. i \\<noteq> ia}", "unfolding rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. row i A) ` (UNIV - {ia}) = {row i A |i. i \\<noteq> ia}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>i. row i A) ` (UNIV - {ia}) = {row i A |i. i \\<noteq> ia}\n\ngoal (1 subgoal):\n 1. row i A = row ia A \\<Longrightarrow> False", "have \"card (rows A) = card ({row i A|i. i\\<noteq>ia})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (rows A) = card {row i A |i. i \\<noteq> ia}", "by (rule bij_betw_same_card[of id], unfold bij_betw_def rows_def)\n         (auto, metis row_i_ia i_not_ia)"], ["proof (state)\nthis:\n  card (rows A) = card {row i A |i. i \\<noteq> ia}\n\ngoal (1 subgoal):\n 1. row i A = row ia A \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card (rows A) = card {row i A |i. i \\<noteq> ia}\n\ngoal (1 subgoal):\n 1. row i A = row ia A \\<Longrightarrow> False", "have \"... = card ((\\<lambda>i. row i A)` (UNIV-{ia}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {row i A |i. i \\<noteq> ia} =\n    card ((\\<lambda>i. row i A) ` (UNIV - {ia}))", "unfolding rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {row i A |i. i \\<noteq> ia} = card {row i A |i. i \\<noteq> ia}", ".."], ["proof (state)\nthis:\n  card {row i A |i. i \\<noteq> ia} =\n  card ((\\<lambda>i. row i A) ` (UNIV - {ia}))\n\ngoal (1 subgoal):\n 1. row i A = row ia A \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card {row i A |i. i \\<noteq> ia} =\n  card ((\\<lambda>i. row i A) ` (UNIV - {ia}))\n\ngoal (1 subgoal):\n 1. row i A = row ia A \\<Longrightarrow> False", "have \"... \\<le> card (UNIV - {ia})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>i. row i A) ` (UNIV - {ia})) \\<le> card (UNIV - {ia})", "by (metis card_image_le finite_code)"], ["proof (state)\nthis:\n  card ((\\<lambda>i. row i A) ` (UNIV - {ia})) \\<le> card (UNIV - {ia})\n\ngoal (1 subgoal):\n 1. row i A = row ia A \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card ((\\<lambda>i. row i A) ` (UNIV - {ia})) \\<le> card (UNIV - {ia})\n\ngoal (1 subgoal):\n 1. row i A = row ia A \\<Longrightarrow> False", "have \"... < CARD ('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (UNIV - {ia}) < CARD('n)", "by simp"], ["proof (state)\nthis:\n  card (UNIV - {ia}) < CARD('n)\n\ngoal (1 subgoal):\n 1. row i A = row ia A \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  card (rows A) < CARD('n)", "show False"], ["proof (prove)\nusing this:\n  card (rows A) < CARD('n)\n\ngoal (1 subgoal):\n 1. False", "using c"], ["proof (prove)\nusing this:\n  card (rows A) < CARD('n)\n  card (rows A) = nrows A\n\ngoal (1 subgoal):\n 1. False", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  card (rows A) < CARD('n)\n  card (rows A) = CARD('n)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row i A \\<noteq> row ia A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "hence oia: \"orthogonal (row i A) (row ia A)\""], ["proof (prove)\nusing this:\n  row i A \\<noteq> row ia A\n\ngoal (1 subgoal):\n 1. orthogonal (row i A) (row ia A)", "using p"], ["proof (prove)\nusing this:\n  row i A \\<noteq> row ia A\n  pairwise orthogonal (rows A)\n\ngoal (1 subgoal):\n 1. orthogonal (row i A) (row ia A)", "unfolding pairwise_def"], ["proof (prove)\nusing this:\n  row i A \\<noteq> row ia A\n  \\<forall>x\\<in>rows A.\n     \\<forall>y\\<in>rows A. x \\<noteq> y \\<longrightarrow> orthogonal x y\n\ngoal (1 subgoal):\n 1. orthogonal (row i A) (row ia A)", "unfolding rows_def"], ["proof (prove)\nusing this:\n  row i A \\<noteq> row ia A\n  \\<forall>x\\<in>{row i A |i. i \\<in> UNIV}.\n     \\<forall>y\\<in>{row i A |i. i \\<in> UNIV}.\n        x \\<noteq> y \\<longrightarrow> orthogonal x y\n\ngoal (1 subgoal):\n 1. orthogonal (row i A) (row ia A)", "by auto"], ["proof (state)\nthis:\n  orthogonal (row i A) (row ia A)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "have \"(A ** transpose A) $ i $ ia = row i A \\<bullet> row ia A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ** Finite_Cartesian_Product.transpose A) $ i $ ia =\n    row i A \\<bullet> row ia A", "unfolding matrix_matrix_mult_inner_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. row i A \\<bullet> column ia (Finite_Cartesian_Product.transpose A) =\n    row i A \\<bullet> row ia A", "unfolding column_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. row i A \\<bullet> row ia A = row i A \\<bullet> row ia A", ".."], ["proof (state)\nthis:\n  (A ** Finite_Cartesian_Product.transpose A) $ i $ ia =\n  row i A \\<bullet> row ia A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "also"], ["proof (state)\nthis:\n  (A ** Finite_Cartesian_Product.transpose A) $ i $ ia =\n  row i A \\<bullet> row ia A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row i A \\<bullet> row ia A = 0", "using oia"], ["proof (prove)\nusing this:\n  orthogonal (row i A) (row ia A)\n\ngoal (1 subgoal):\n 1. row i A \\<bullet> row ia A = 0", "unfolding orthogonal_def"], ["proof (prove)\nusing this:\n  row i A \\<bullet> row ia A = 0\n\ngoal (1 subgoal):\n 1. row i A \\<bullet> row ia A = 0", "."], ["proof (state)\nthis:\n  row i A \\<bullet> row ia A = 0\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       i \\<noteq> ia \\<Longrightarrow>\n       (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "finally"], ["proof (chain)\npicking this:\n  (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "show \"(A ** transpose A) $ i $ ia = 0\""], ["proof (prove)\nusing this:\n  (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0\n\ngoal (1 subgoal):\n 1. (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0", "."], ["proof (state)\nthis:\n  (A ** Finite_Cartesian_Product.transpose A) $ i $ ia = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_basis_imp_full_rank:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes b: \"is_basis (columns A)\"\n  and c: \"card (columns A) = ncols A\"\n  shows \"rank A = ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = ncols A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rank A = ncols A", "have \"rank A = col_rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = col_rank A", "unfolding rank_col_rank"], ["proof (prove)\ngoal (1 subgoal):\n 1. col_rank A = col_rank A", ".."], ["proof (state)\nthis:\n  rank A = col_rank A\n\ngoal (1 subgoal):\n 1. rank A = ncols A", "also"], ["proof (state)\nthis:\n  rank A = col_rank A\n\ngoal (1 subgoal):\n 1. rank A = ncols A", "have \"... = vec.dim (col_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col_rank A = vec.dim (col_space A)", "unfolding col_rank_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (col_space A) = vec.dim (col_space A)", ".."], ["proof (state)\nthis:\n  col_rank A = vec.dim (col_space A)\n\ngoal (1 subgoal):\n 1. rank A = ncols A", "also"], ["proof (state)\nthis:\n  col_rank A = vec.dim (col_space A)\n\ngoal (1 subgoal):\n 1. rank A = ncols A", "have \"... = card (columns A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (col_space A) = card (columns A)", "by (metis b col_space_def independent_is_basis vec.dim_eq_card_independent vec.dim_span)"], ["proof (state)\nthis:\n  vec.dim (col_space A) = card (columns A)\n\ngoal (1 subgoal):\n 1. rank A = ncols A", "also"], ["proof (state)\nthis:\n  vec.dim (col_space A) = card (columns A)\n\ngoal (1 subgoal):\n 1. rank A = ncols A", "have \"... = ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (columns A) = ncols A", "using c"], ["proof (prove)\nusing this:\n  card (columns A) = ncols A\n\ngoal (1 subgoal):\n 1. card (columns A) = ncols A", "."], ["proof (state)\nthis:\n  card (columns A) = ncols A\n\ngoal (1 subgoal):\n 1. rank A = ncols A", "finally"], ["proof (chain)\npicking this:\n  rank A = ncols A", "show ?thesis"], ["proof (prove)\nusing this:\n  rank A = ncols A\n\ngoal (1 subgoal):\n 1. rank A = ncols A", "."], ["proof (state)\nthis:\n  rank A = ncols A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_columns_le_ncols:\n  \"card (columns A) \\<le> ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (columns A) \\<le> ncols A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (columns A) \\<le> ncols A", "have columns_rw: \"columns A = (\\<lambda>i. column i A)` UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. columns A = range (\\<lambda>i. column i A)", "unfolding columns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i A |i. i \\<in> UNIV} = range (\\<lambda>i. column i A)", "by auto"], ["proof (state)\nthis:\n  columns A = range (\\<lambda>i. column i A)\n\ngoal (1 subgoal):\n 1. card (columns A) \\<le> ncols A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (columns A) \\<le> ncols A", "unfolding columns_rw ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (range (\\<lambda>i. column i A)) \\<le> CARD('c)", "by (rule card_image_le, auto)"], ["proof (state)\nthis:\n  card (columns A) \\<le> ncols A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma full_rank_imp_is_basis:\n  fixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"is_basis (columns A) \\<and> card (columns A) = ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_basis (columns A) \\<and> card (columns A) = ncols A", "proof (rule conjI, unfold is_basis_def, rule conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. vec.independent (columns A)\n 2. vec.span (columns A) = UNIV\n 3. card (columns A) = ncols A", "have \"rank A = col_rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = col_rank A", "unfolding rank_col_rank"], ["proof (prove)\ngoal (1 subgoal):\n 1. col_rank A = col_rank A", ".."], ["proof (state)\nthis:\n  rank A = col_rank A\n\ngoal (3 subgoals):\n 1. vec.independent (columns A)\n 2. vec.span (columns A) = UNIV\n 3. card (columns A) = ncols A", "also"], ["proof (state)\nthis:\n  rank A = col_rank A\n\ngoal (3 subgoals):\n 1. vec.independent (columns A)\n 2. vec.span (columns A) = UNIV\n 3. card (columns A) = ncols A", "have \"... = vec.dim (col_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col_rank A = vec.dim (col_space A)", "unfolding col_rank_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (col_space A) = vec.dim (col_space A)", ".."], ["proof (state)\nthis:\n  col_rank A = vec.dim (col_space A)\n\ngoal (3 subgoals):\n 1. vec.independent (columns A)\n 2. vec.span (columns A) = UNIV\n 3. card (columns A) = ncols A", "also"], ["proof (state)\nthis:\n  col_rank A = vec.dim (col_space A)\n\ngoal (3 subgoals):\n 1. vec.independent (columns A)\n 2. vec.span (columns A) = UNIV\n 3. card (columns A) = ncols A", "have \"... = card (columns A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (col_space A) = card (columns A)", "by (metis (full_types) antisym_conv calculation card_columns_le_ncols col_space_def\n        finite_columns r vec.dim_le_card vec.dim_span vec.span_superset)"], ["proof (state)\nthis:\n  vec.dim (col_space A) = card (columns A)\n\ngoal (3 subgoals):\n 1. vec.independent (columns A)\n 2. vec.span (columns A) = UNIV\n 3. card (columns A) = ncols A", "finally"], ["proof (chain)\npicking this:\n  rank A = card (columns A)", "have *: \"rank A = card (columns A)\""], ["proof (prove)\nusing this:\n  rank A = card (columns A)\n\ngoal (1 subgoal):\n 1. rank A = card (columns A)", "."], ["proof (state)\nthis:\n  rank A = card (columns A)\n\ngoal (3 subgoals):\n 1. vec.independent (columns A)\n 2. vec.span (columns A) = UNIV\n 3. card (columns A) = ncols A", "then"], ["proof (chain)\npicking this:\n  rank A = card (columns A)", "show c_eq: \"card (columns A) = ncols A\""], ["proof (prove)\nusing this:\n  rank A = card (columns A)\n\ngoal (1 subgoal):\n 1. card (columns A) = ncols A", "unfolding r"], ["proof (prove)\nusing this:\n  ncols A = card (columns A)\n\ngoal (1 subgoal):\n 1. card (columns A) = ncols A", ".."], ["proof (state)\nthis:\n  card (columns A) = ncols A\n\ngoal (2 subgoals):\n 1. vec.independent (columns A)\n 2. vec.span (columns A) = UNIV", "show \"vec.independent (columns A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (columns A)", "by (metis * vec.card_eq_dim_span_indep col_rank_def \n      col_space_def finite_columns rank_col_rank)"], ["proof (state)\nthis:\n  vec.independent (columns A)\n\ngoal (1 subgoal):\n 1. vec.span (columns A) = UNIV", "thus \"vec.span (columns A) = (UNIV::('a^'n::{mod_type}) set)\""], ["proof (prove)\nusing this:\n  vec.independent (columns A)\n\ngoal (1 subgoal):\n 1. vec.span (columns A) = UNIV", "using independent_is_basis[of \"columns A\"] c_eq"], ["proof (prove)\nusing this:\n  vec.independent (columns A)\n  (vec.independent (columns A) \\<and> card (columns A) = CARD('n)) =\n  is_basis (columns A)\n  card (columns A) = ncols A\n\ngoal (1 subgoal):\n 1. vec.span (columns A) = UNIV", "unfolding is_basis_def ncols_def"], ["proof (prove)\nusing this:\n  vec.independent (columns A)\n  (vec.independent (columns A) \\<and> card (columns A) = CARD('n)) =\n  (vec.independent (columns A) \\<and> vec.span (columns A) = UNIV)\n  card (columns A) = CARD('n)\n\ngoal (1 subgoal):\n 1. vec.span (columns A) = UNIV", "by simp"], ["proof (state)\nthis:\n  vec.span (columns A) = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma full_rank_imp_is_basis2:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"vec.independent (columns A) \\<and> vec.span (columns A) = col_space A \n        \\<and> card (columns A) = ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "have \"rank A = col_rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = col_rank A", "unfolding rank_col_rank"], ["proof (prove)\ngoal (1 subgoal):\n 1. col_rank A = col_rank A", ".."], ["proof (state)\nthis:\n  rank A = col_rank A\n\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "also"], ["proof (state)\nthis:\n  rank A = col_rank A\n\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "have \"... = vec.dim (col_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col_rank A = vec.dim (col_space A)", "unfolding col_rank_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (col_space A) = vec.dim (col_space A)", ".."], ["proof (state)\nthis:\n  col_rank A = vec.dim (col_space A)\n\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "also"], ["proof (state)\nthis:\n  col_rank A = vec.dim (col_space A)\n\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "have \"... = card (columns A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (col_space A) = card (columns A)", "by (metis (full_types) antisym_conv calculation card_columns_le_ncols col_space_def\n        finite_columns r vec.dim_le_card vec.dim_span vec.span_superset)"], ["proof (state)\nthis:\n  vec.dim (col_space A) = card (columns A)\n\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "finally"], ["proof (chain)\npicking this:\n  rank A = card (columns A)", "have *: \"rank A = card (columns A)\""], ["proof (prove)\nusing this:\n  rank A = card (columns A)\n\ngoal (1 subgoal):\n 1. rank A = card (columns A)", "."], ["proof (state)\nthis:\n  rank A = card (columns A)\n\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "then"], ["proof (chain)\npicking this:\n  rank A = card (columns A)", "have c_eq: \"card (columns A) = ncols A\""], ["proof (prove)\nusing this:\n  rank A = card (columns A)\n\ngoal (1 subgoal):\n 1. card (columns A) = ncols A", "unfolding r"], ["proof (prove)\nusing this:\n  ncols A = card (columns A)\n\ngoal (1 subgoal):\n 1. card (columns A) = ncols A", ".."], ["proof (state)\nthis:\n  card (columns A) = ncols A\n\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "moreover"], ["proof (state)\nthis:\n  card (columns A) = ncols A\n\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "have \"vec.independent (columns A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (columns A)", "by (metis * vec.card_eq_dim_span_indep\n      col_rank_def col_space_def finite_columns rank_col_rank)"], ["proof (state)\nthis:\n  vec.independent (columns A)\n\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "moreover"], ["proof (state)\nthis:\n  vec.independent (columns A)\n\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "have \"vec.span (columns A) = col_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.span (columns A) = col_space A", "by (metis col_space_def)"], ["proof (state)\nthis:\n  vec.span (columns A) = col_space A\n\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "ultimately"], ["proof (chain)\npicking this:\n  card (columns A) = ncols A\n  vec.independent (columns A)\n  vec.span (columns A) = col_space A", "show ?thesis"], ["proof (prove)\nusing this:\n  card (columns A) = ncols A\n  vec.independent (columns A)\n  vec.span (columns A) = col_space A\n\ngoal (1 subgoal):\n 1. vec.independent (columns A) \\<and>\n    vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A", "by simp"], ["proof (state)\nthis:\n  vec.independent (columns A) \\<and>\n  vec.span (columns A) = col_space A \\<and> card (columns A) = ncols A\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary full_rank_eq_is_basis:\n  fixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\n  shows \"(is_basis (columns A) \\<and> (card (columns A) = ncols A)) = (rank A = ncols A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_basis (columns A) \\<and> card (columns A) = ncols A) =\n    (rank A = ncols A)", "using full_rank_imp_is_basis is_basis_imp_full_rank"], ["proof (prove)\nusing this:\n  rank ?A = ncols ?A \\<Longrightarrow>\n  is_basis (columns ?A) \\<and> card (columns ?A) = ncols ?A\n  \\<lbrakk>is_basis (columns ?A); card (columns ?A) = ncols ?A\\<rbrakk>\n  \\<Longrightarrow> rank ?A = ncols ?A\n\ngoal (1 subgoal):\n 1. (is_basis (columns A) \\<and> card (columns A) = ncols A) =\n    (rank A = ncols A)", "by blast"], ["", "lemma full_col_rank_imp_independent_columns:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"rank A = ncols A\"\n  shows \"vec.independent (columns A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (columns A)", "by (metis assms full_rank_imp_is_basis2)"], ["", "lemma matrix_vector_right_distrib_minus:\n  fixes A::\"'a::{ring_1}^'n^'m\"\n  shows \"A *v (b - c) = (A *v b) - (A *v c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v (b - c) = A *v b - A *v c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A *v (b - c) = A *v b - A *v c", "have \"A *v (b - c) = A *v (b + - c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v (b - c) = A *v (b + - c)", "by (metis diff_minus_eq_add minus_minus)"], ["proof (state)\nthis:\n  A *v (b - c) = A *v (b + - c)\n\ngoal (1 subgoal):\n 1. A *v (b - c) = A *v b - A *v c", "also"], ["proof (state)\nthis:\n  A *v (b - c) = A *v (b + - c)\n\ngoal (1 subgoal):\n 1. A *v (b - c) = A *v b - A *v c", "have \"... = (A *v b) + (A *v (- c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v (b + - c) = A *v b + A *v - c", "unfolding matrix_vector_right_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v b + A *v - c = A *v b + A *v - c", ".."], ["proof (state)\nthis:\n  A *v (b + - c) = A *v b + A *v - c\n\ngoal (1 subgoal):\n 1. A *v (b - c) = A *v b - A *v c", "also"], ["proof (state)\nthis:\n  A *v (b + - c) = A *v b + A *v - c\n\ngoal (1 subgoal):\n 1. A *v (b - c) = A *v b - A *v c", "have \"... = (A *v b) - (A *v c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v b + A *v - c = A *v b - A *v c", "by (metis (no_types, hide_lams) add.commute add_minus_cancel\n        matrix_vector_right_distrib uminus_add_conv_diff)"], ["proof (state)\nthis:\n  A *v b + A *v - c = A *v b - A *v c\n\ngoal (1 subgoal):\n 1. A *v (b - c) = A *v b - A *v c", "finally"], ["proof (chain)\npicking this:\n  A *v (b - c) = A *v b - A *v c", "show ?thesis"], ["proof (prove)\nusing this:\n  A *v (b - c) = A *v b - A *v c\n\ngoal (1 subgoal):\n 1. A *v (b - c) = A *v b - A *v c", "."], ["proof (state)\nthis:\n  A *v (b - c) = A *v b - A *v c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inv_matrix_vector_mul_left:\n  assumes i: \"invertible A\"\n  shows \"(A *v x = A *v y) = (x=y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *v x = A *v y) = (x = y)", "by (metis i invertible_def matrix_vector_mul_assoc matrix_vector_mul_lid)"], ["", "lemma norm_mult_vec:\n  fixes a::\"(real,'b::finite) vec\"\n  shows \"norm (x \\<bullet> x) = norm x * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (x \\<bullet> x) = norm x * norm x", "by (metis inner_real_def norm_cauchy_schwarz_eq norm_mult)"], ["", "lemma norm_equivalence: \n  fixes A::\"real^'n^'m\"\n  shows \"((transpose A) *v (A *v x) = 0) \\<longleftrightarrow> (A *v x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A *v (A *v x) = 0) = (A *v x = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A *v (A *v x) = 0) = (A *v x = 0)", "have \"A *v x = 0\" if \"transpose A *v (A *v x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A *v x = 0", "have eq: \"(x v* (transpose A)) = (A *v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x v* Finite_Cartesian_Product.transpose A = A *v x", "by (metis transpose_transpose transpose_vector)"], ["proof (state)\nthis:\n  x v* Finite_Cartesian_Product.transpose A = A *v x\n\ngoal (1 subgoal):\n 1. A *v x = 0", "have eq_0: \"0 = (x v* (transpose A)) * (A *v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = x v* Finite_Cartesian_Product.transpose A * (A *v x)", "by auto (metis that dot_lmul_matrix inner_eq_zero_iff inner_zero_left mult_not_zero transpose_vector)"], ["proof (state)\nthis:\n  0 = x v* Finite_Cartesian_Product.transpose A * (A *v x)\n\ngoal (1 subgoal):\n 1. A *v x = 0", "hence \"0 = norm ((x v* (transpose A)) * (A *v x))\""], ["proof (prove)\nusing this:\n  0 = x v* Finite_Cartesian_Product.transpose A * (A *v x)\n\ngoal (1 subgoal):\n 1. 0 = norm (x v* Finite_Cartesian_Product.transpose A * (A *v x))", "by auto"], ["proof (state)\nthis:\n  0 = norm (x v* Finite_Cartesian_Product.transpose A * (A *v x))\n\ngoal (1 subgoal):\n 1. A *v x = 0", "also"], ["proof (state)\nthis:\n  0 = norm (x v* Finite_Cartesian_Product.transpose A * (A *v x))\n\ngoal (1 subgoal):\n 1. A *v x = 0", "have \"... = norm ((A *v x)*(A *v x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (x v* Finite_Cartesian_Product.transpose A * (A *v x)) =\n    norm (A *v x * (A *v x))", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A *v x * (A *v x)) = norm (A *v x * (A *v x))", ".."], ["proof (state)\nthis:\n  norm (x v* Finite_Cartesian_Product.transpose A * (A *v x)) =\n  norm (A *v x * (A *v x))\n\ngoal (1 subgoal):\n 1. A *v x = 0", "also"], ["proof (state)\nthis:\n  norm (x v* Finite_Cartesian_Product.transpose A * (A *v x)) =\n  norm (A *v x * (A *v x))\n\ngoal (1 subgoal):\n 1. A *v x = 0", "have \"... = norm ((A *v x) \\<bullet> (A *v x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A *v x * (A *v x)) = norm ((A *v x) \\<bullet> (A *v x))", "by (metis eq_0 that dot_lmul_matrix eq inner_zero_right norm_zero)"], ["proof (state)\nthis:\n  norm (A *v x * (A *v x)) = norm ((A *v x) \\<bullet> (A *v x))\n\ngoal (1 subgoal):\n 1. A *v x = 0", "also"], ["proof (state)\nthis:\n  norm (A *v x * (A *v x)) = norm ((A *v x) \\<bullet> (A *v x))\n\ngoal (1 subgoal):\n 1. A *v x = 0", "have \"... = norm (A *v x)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm ((A *v x) \\<bullet> (A *v x)) = (norm (A *v x))\\<^sup>2", "unfolding norm_mult_vec[of \"(A *v x)\"] power2_eq_square"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A *v x) * norm (A *v x) = norm (A *v x) * norm (A *v x)", ".."], ["proof (state)\nthis:\n  norm ((A *v x) \\<bullet> (A *v x)) = (norm (A *v x))\\<^sup>2\n\ngoal (1 subgoal):\n 1. A *v x = 0", "finally"], ["proof (chain)\npicking this:\n  0 = (norm (A *v x))\\<^sup>2", "show \"A *v x = 0\""], ["proof (prove)\nusing this:\n  0 = (norm (A *v x))\\<^sup>2\n\ngoal (1 subgoal):\n 1. A *v x = 0", "by simp"], ["proof (state)\nthis:\n  A *v x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose A *v (A *v x) = 0 \\<Longrightarrow>\n  A *v x = 0\n\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A *v (A *v x) = 0) = (A *v x = 0)", "then"], ["proof (chain)\npicking this:\n  Finite_Cartesian_Product.transpose A *v (A *v x) = 0 \\<Longrightarrow>\n  A *v x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  Finite_Cartesian_Product.transpose A *v (A *v x) = 0 \\<Longrightarrow>\n  A *v x = 0\n\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A *v (A *v x) = 0) = (A *v x = 0)", "by auto"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A *v (A *v x) = 0) = (A *v x = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_transpose_mult:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"invertible (transpose A ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "have null_eq: \"null_space A = null_space (transpose A ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null_space A = null_space (Finite_Cartesian_Product.transpose A ** A)", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> null_space A \\<Longrightarrow>\n       x \\<in> null_space (Finite_Cartesian_Product.transpose A ** A)\n 2. \\<And>x.\n       x \\<in> null_space\n                (Finite_Cartesian_Product.transpose A **\n                 A) \\<Longrightarrow>\n       x \\<in> null_space A", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> null_space A \\<Longrightarrow>\n       x \\<in> null_space (Finite_Cartesian_Product.transpose A ** A)\n 2. \\<And>x.\n       x \\<in> null_space\n                (Finite_Cartesian_Product.transpose A **\n                 A) \\<Longrightarrow>\n       x \\<in> null_space A", "assume x: \"x \\<in> null_space A\""], ["proof (state)\nthis:\n  x \\<in> null_space A\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> null_space A \\<Longrightarrow>\n       x \\<in> null_space (Finite_Cartesian_Product.transpose A ** A)\n 2. \\<And>x.\n       x \\<in> null_space\n                (Finite_Cartesian_Product.transpose A **\n                 A) \\<Longrightarrow>\n       x \\<in> null_space A", "show \"x \\<in> null_space (transpose A ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> null_space (Finite_Cartesian_Product.transpose A ** A)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> null_space A\n\ngoal (1 subgoal):\n 1. x \\<in> null_space (Finite_Cartesian_Product.transpose A ** A)", "unfolding null_space_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. A *v x = 0}\n\ngoal (1 subgoal):\n 1. x \\<in> {x. Finite_Cartesian_Product.transpose A ** A *v x = 0}", "by (metis (lifting, full_types) matrix_vector_mul_assoc matrix_vector_mult_0_right mem_Collect_eq)"], ["proof (state)\nthis:\n  x \\<in> null_space (Finite_Cartesian_Product.transpose A ** A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> null_space\n                (Finite_Cartesian_Product.transpose A **\n                 A) \\<Longrightarrow>\n       x \\<in> null_space A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> null_space\n                (Finite_Cartesian_Product.transpose A **\n                 A) \\<Longrightarrow>\n       x \\<in> null_space A", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> null_space\n                (Finite_Cartesian_Product.transpose A **\n                 A) \\<Longrightarrow>\n       x \\<in> null_space A", "assume x: \"x \\<in> null_space (transpose A ** A)\""], ["proof (state)\nthis:\n  x \\<in> null_space (Finite_Cartesian_Product.transpose A ** A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> null_space\n                (Finite_Cartesian_Product.transpose A **\n                 A) \\<Longrightarrow>\n       x \\<in> null_space A", "show \"x \\<in> null_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> null_space A", "by (metis is_solution_def matrix_vector_mul_assoc mem_Collect_eq \n        norm_equivalence null_space_eq_solution_set solution_set_def x)"], ["proof (state)\nthis:\n  x \\<in> null_space A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  null_space A = null_space (Finite_Cartesian_Product.transpose A ** A)\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "have \"rank A = vec.dim (UNIV::(real^'cols::{mod_type}) set) - vec.dim (null_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = vec.dim UNIV - vec.dim (null_space A)", "using rank_nullity_theorem_matrices[of A]"], ["proof (prove)\nusing this:\n  ncols A = vec.dim (null_space A) + vec.dim (col_space A)\n\ngoal (1 subgoal):\n 1. rank A = vec.dim UNIV - vec.dim (null_space A)", "unfolding rank_eq_dim_col_space'[of A, symmetric]"], ["proof (prove)\nusing this:\n  ncols A = vec.dim (null_space A) + vec.dim (col_space A)\n\ngoal (1 subgoal):\n 1. vec.dim (col_space A) = vec.dim UNIV - vec.dim (null_space A)", "by (simp only: add.commute diff_add_inverse2 ncols_def vec_dim_card)"], ["proof (state)\nthis:\n  rank A = vec.dim UNIV - vec.dim (null_space A)\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "also"], ["proof (state)\nthis:\n  rank A = vec.dim UNIV - vec.dim (null_space A)\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "have \"... = vec.dim (UNIV::(real^'cols::{mod_type}) set) - vec.dim (null_space (transpose A ** A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim UNIV - vec.dim (null_space A) =\n    vec.dim UNIV -\n    vec.dim (null_space (Finite_Cartesian_Product.transpose A ** A))", "unfolding null_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim UNIV -\n    vec.dim (null_space (Finite_Cartesian_Product.transpose A ** A)) =\n    vec.dim UNIV -\n    vec.dim (null_space (Finite_Cartesian_Product.transpose A ** A))", ".."], ["proof (state)\nthis:\n  vec.dim UNIV - vec.dim (null_space A) =\n  vec.dim UNIV -\n  vec.dim (null_space (Finite_Cartesian_Product.transpose A ** A))\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "also"], ["proof (state)\nthis:\n  vec.dim UNIV - vec.dim (null_space A) =\n  vec.dim UNIV -\n  vec.dim (null_space (Finite_Cartesian_Product.transpose A ** A))\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "have \"... = rank (transpose A ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim UNIV -\n    vec.dim (null_space (Finite_Cartesian_Product.transpose A ** A)) =\n    rank (Finite_Cartesian_Product.transpose A ** A)", "by (metis add.commute diff_add_inverse2 ncols_def rank_eq_dim_col_space\n        rank_nullity_theorem_matrices vec_dim_card)"], ["proof (state)\nthis:\n  vec.dim UNIV -\n  vec.dim (null_space (Finite_Cartesian_Product.transpose A ** A)) =\n  rank (Finite_Cartesian_Product.transpose A ** A)\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "finally"], ["proof (chain)\npicking this:\n  rank A = rank (Finite_Cartesian_Product.transpose A ** A)", "have r_A: \"rank A = rank (transpose A ** A)\""], ["proof (prove)\nusing this:\n  rank A = rank (Finite_Cartesian_Product.transpose A ** A)\n\ngoal (1 subgoal):\n 1. rank A = rank (Finite_Cartesian_Product.transpose A ** A)", "."], ["proof (state)\nthis:\n  rank A = rank (Finite_Cartesian_Product.transpose A ** A)\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "using full_rank_implies_invertible r"], ["proof (prove)\nusing this:\n  rank ?A = nrows ?A \\<Longrightarrow> invertible ?A\n  rank A = ncols A\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "unfolding ncols_def nrows_def r_A"], ["proof (prove)\nusing this:\n  rank ?A = CARD(?'n) \\<Longrightarrow> invertible ?A\n  rank (Finite_Cartesian_Product.transpose A ** A) = CARD('cols)\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "."], ["proof (state)\nthis:\n  invertible (Finite_Cartesian_Product.transpose A ** A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_inv_mult:\n  fixes A::\"'a::{semiring_1}^'n^'n\"\n  and B::\"'a::{semiring_1}^'n^'n\"\n  assumes \"invertible A\" and \"invertible B\"\n  shows \"matrix_inv (A ** B) = matrix_inv B ** matrix_inv A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv (A ** B) = matrix_inv B ** matrix_inv A", "proof (rule matrix_inv_unique[of \"A**B\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. A ** B ** (matrix_inv B ** matrix_inv A) = mat (1::'a)\n 2. matrix_inv B ** matrix_inv A ** (A ** B) = mat (1::'a)", "show \"A ** B ** (matrix_inv B ** matrix_inv A) = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ** B ** (matrix_inv B ** matrix_inv A) = mat (1::'a)", "by (metis assms(1) assms(2) matrix_inv_right matrix_mul_assoc matrix_mul_lid)"], ["proof (state)\nthis:\n  A ** B ** (matrix_inv B ** matrix_inv A) = mat (1::'a)\n\ngoal (1 subgoal):\n 1. matrix_inv B ** matrix_inv A ** (A ** B) = mat (1::'a)", "show \" matrix_inv B ** matrix_inv A ** (A ** B) = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_inv B ** matrix_inv A ** (A ** B) = mat (1::'a)", "by (metis assms(1) assms(2) matrix_inv_left matrix_mul_assoc matrix_mul_lid)"], ["proof (state)\nthis:\n  matrix_inv B ** matrix_inv A ** (A ** B) = mat (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_transpose:\n  fixes A::\"'a::{field}^'n^'n\"\n  assumes \"invertible A\"\n  shows \"invertible (transpose A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A)", "by (metis invertible_det_nz assms det_transpose)"], ["", "text\\<open>The following lemmas are generalizations of some parts of the library. They should be \n  in the file \\<open>Generalizations.thy\\<close> of the Gauss-Jordan AFP entry.\\<close>"], ["", "context vector_space\nbegin"], ["", "lemma span_eq: \"(span S = span T) = (S \\<subseteq> span T \\<and> T \\<subseteq> span S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.span S = local.span T) =\n    (S \\<subseteq> local.span T \\<and> T \\<subseteq> local.span S)", "using span_superset[unfolded subset_eq]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>?S. x \\<in> local.span ?S\n\ngoal (1 subgoal):\n 1. (local.span S = local.span T) =\n    (S \\<subseteq> local.span T \\<and> T \\<subseteq> local.span S)", "using span_mono[of T \"span S\"] span_mono[of S \"span T\"]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>?S. x \\<in> local.span ?S\n  T \\<subseteq> local.span S \\<Longrightarrow>\n  local.span T \\<subseteq> local.span (local.span S)\n  S \\<subseteq> local.span T \\<Longrightarrow>\n  local.span S \\<subseteq> local.span (local.span T)\n\ngoal (1 subgoal):\n 1. (local.span S = local.span T) =\n    (S \\<subseteq> local.span T \\<and> T \\<subseteq> local.span S)", "by (auto simp add: span_span)"], ["", "end"], ["", "lemma basis_orthogonal:\n  fixes B :: \"'a::real_inner set\"\n  assumes fB: \"finite B\"\n  shows \"\\<exists>C. finite C \\<and> card C \\<le> card B \\<and> span C\n        = span B \\<and> pairwise orthogonal C\"\n  (is \" \\<exists>C. ?P B C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       finite C \\<and>\n       card C \\<le> card B \\<and>\n       span C = span B \\<and> pairwise orthogonal C", "using fB"], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       finite C \\<and>\n       card C \\<le> card B \\<and>\n       span C = span B \\<and> pairwise orthogonal C", "proof (induct rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>C.\n       finite C \\<and>\n       card C \\<le> card {} \\<and>\n       span C = span {} \\<and> pairwise orthogonal C\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>C.\n       finite C \\<and>\n       card C \\<le> card {} \\<and>\n       span C = span {} \\<and> pairwise orthogonal C\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       finite C \\<and>\n       card C \\<le> card {} \\<and>\n       span C = span {} \\<and> pairwise orthogonal C", "apply (rule exI[where x=\"{}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {} \\<and>\n    card {} \\<le> card {} \\<and>\n    span {} = span {} \\<and> pairwise orthogonal {}", "apply (auto simp add: pairwise_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>C.\n     finite C \\<and>\n     card C \\<le> card {} \\<and>\n     span C = span {} \\<and> pairwise orthogonal C\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "case (insert a B)"], ["proof (state)\nthis:\n  finite B\n  a \\<notin> B\n  \\<exists>C.\n     finite C \\<and>\n     card C \\<le> card B \\<and> span C = span B \\<and> pairwise orthogonal C\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "note fB = \\<open>finite B\\<close> and aB = \\<open>a \\<notin> B\\<close>"], ["proof (state)\nthis:\n  finite B\n  a \\<notin> B\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "from \\<open>\\<exists>C. finite C \\<and> card C \\<le> card B \\<and> span C = span B \\<and> pairwise orthogonal C\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     finite C \\<and>\n     card C \\<le> card B \\<and> span C = span B \\<and> pairwise orthogonal C", "obtain C where C: \"finite C\" \"card C \\<le> card B\"\n    \"span C = span B\" \"pairwise orthogonal C\""], ["proof (prove)\nusing this:\n  \\<exists>C.\n     finite C \\<and>\n     card C \\<le> card B \\<and> span C = span B \\<and> pairwise orthogonal C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>finite C; card C \\<le> card B; span C = span B;\n         pairwise orthogonal C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite C\n  card C \\<le> card B\n  span C = span B\n  pairwise orthogonal C\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "let ?a = \"a - sum (\\<lambda>x. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x) C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "let ?C = \"insert ?a C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "from C(1)"], ["proof (chain)\npicking this:\n  finite C", "have fC: \"finite ?C\""], ["proof (prove)\nusing this:\n  finite C\n\ngoal (1 subgoal):\n 1. finite\n     (insert\n       (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n       C)", "by simp"], ["proof (state)\nthis:\n  finite\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "from fB aB C(1,2)"], ["proof (chain)\npicking this:\n  finite B\n  a \\<notin> B\n  finite C\n  card C \\<le> card B", "have cC: \"card ?C \\<le> card (insert a B)\""], ["proof (prove)\nusing this:\n  finite B\n  a \\<notin> B\n  finite C\n  card C \\<le> card B\n\ngoal (1 subgoal):\n 1. card\n     (insert\n       (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n       C)\n    \\<le> card (insert a B)", "by (simp add: card_insert_if)"], ["proof (state)\nthis:\n  card\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n  \\<le> card (insert a B)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "{"], ["proof (state)\nthis:\n  card\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n  \\<le> card (insert a B)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "fix x k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "have th0: \"\\<And>(a::'a) b c. a - (b - c) = c + (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. a - (b - c) = c + (a - b)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  ?a - (?b - ?c) = ?c + (?a - ?b)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "have \"x - k *\\<^sub>R (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) \\<in> span C\n      \\<longleftrightarrow> x - k *\\<^sub>R a \\<in> span C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x -\n     k *\\<^sub>R\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n     \\<in> span C) =\n    (x - k *\\<^sub>R a \\<in> span C)", "apply (simp only: scaleR_right_diff_distrib th0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k *\\<^sub>R\n     (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x) +\n     (x - k *\\<^sub>R a)\n     \\<in> span C) =\n    (x - k *\\<^sub>R a \\<in> span C)", "apply (rule span_add_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k *\\<^sub>R\n    (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)\n    \\<in> span C", "apply (rule span_mul)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)\n    \\<in> span C", "apply (rule span_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x \\<in> span C", "apply (rule span_mul)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<in> span C", "apply (rule span_base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<in> C", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (x -\n   k *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (x - k *\\<^sub>R a \\<in> span C)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "}"], ["proof (state)\nthis:\n  (?x2 -\n   ?k2 *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (?x2 - ?k2 *\\<^sub>R a \\<in> span C)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "then"], ["proof (chain)\npicking this:\n  (?x2 -\n   ?k2 *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (?x2 - ?k2 *\\<^sub>R a \\<in> span C)", "have SC: \"span ?C = span (insert a B)\""], ["proof (prove)\nusing this:\n  (?x2 -\n   ?k2 *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (?x2 - ?k2 *\\<^sub>R a \\<in> span C)\n\ngoal (1 subgoal):\n 1. span\n     (insert\n       (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n       C) =\n    span (insert a B)", "unfolding set_eq_iff span_breakdown_eq C(3)[symmetric]"], ["proof (prove)\nusing this:\n  (?x2 -\n   ?k2 *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (?x2 - ?k2 *\\<^sub>R a \\<in> span C)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>k.\n           x -\n           k *\\<^sub>R\n           (a -\n            (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n           \\<in> span C) =\n       (\\<exists>k. x - k *\\<^sub>R a \\<in> span C)", "by auto"], ["proof (state)\nthis:\n  span\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n     C) =\n  span (insert a B)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "{"], ["proof (state)\nthis:\n  span\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n     C) =\n  span (insert a B)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "assume yC: \"y \\<in> C\""], ["proof (state)\nthis:\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "then"], ["proof (chain)\npicking this:\n  y \\<in> C", "have Cy: \"C = insert y (C - {y})\""], ["proof (prove)\nusing this:\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. C = insert y (C - {y})", "by blast"], ["proof (state)\nthis:\n  C = insert y (C - {y})\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "have fth: \"finite (C - {y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (C - {y})", "using C"], ["proof (prove)\nusing this:\n  finite C\n  card C \\<le> card B\n  span C = span B\n  pairwise orthogonal C\n\ngoal (1 subgoal):\n 1. finite (C - {y})", "by simp"], ["proof (state)\nthis:\n  finite (C - {y})\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "have \"orthogonal ?a y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) y", "unfolding orthogonal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a -\n     (\\<Sum>x\\<in>C.\n        (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) \\<bullet>\n    y =\n    0", "unfolding inner_diff inner_sum_left right_minus_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<bullet> y =\n    (\\<Sum>x\\<in>C.\n       (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x \\<bullet> y)", "unfolding sum.remove [OF \\<open>finite C\\<close> \\<open>y \\<in> C\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<bullet> y =\n    (y \\<bullet> a / (y \\<bullet> y)) *\\<^sub>R y \\<bullet> y +\n    (\\<Sum>x\\<in>C - {y}.\n       (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x \\<bullet> y)", "apply (clarsimp simp add: inner_commute[of y a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    (\\<Sum>x\\<in>C - {y}.\n       x \\<bullet> a * (x \\<bullet> y) / (x \\<bullet> x)) =\n    0", "apply (rule sum.neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<forall>x\\<in>C - {y}.\n       x \\<bullet> a * (x \\<bullet> y) / (x \\<bullet> x) = 0", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>y \\<noteq> (0::'a); x \\<in> C; x \\<noteq> y;\n        x \\<bullet> a \\<noteq> 0; x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<bullet> y = 0", "apply (rule C(4)[unfolded pairwise_def orthogonal_def, rule_format])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>y \\<noteq> (0::'a); x \\<in> C; x \\<noteq> y;\n        x \\<bullet> a \\<noteq> 0; x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> C\n 2. \\<And>x.\n       \\<lbrakk>y \\<noteq> (0::'a); x \\<in> C; x \\<noteq> y;\n        x \\<bullet> a \\<noteq> 0; x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> y \\<in> C\n 3. \\<And>x.\n       \\<lbrakk>y \\<noteq> (0::'a); x \\<in> C; x \\<noteq> y;\n        x \\<bullet> a \\<noteq> 0; x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "using \\<open>y \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> C\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>y \\<noteq> (0::'a); x \\<in> C; x \\<noteq> y;\n        x \\<bullet> a \\<noteq> 0; x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> C\n 2. \\<And>x.\n       \\<lbrakk>y \\<noteq> (0::'a); x \\<in> C; x \\<noteq> y;\n        x \\<bullet> a \\<noteq> 0; x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> y \\<in> C\n 3. \\<And>x.\n       \\<lbrakk>y \\<noteq> (0::'a); x \\<in> C; x \\<noteq> y;\n        x \\<bullet> a \\<noteq> 0; x \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  orthogonal\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) y\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "}"], ["proof (state)\nthis:\n  ?y2 \\<in> C \\<Longrightarrow>\n  orthogonal\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) ?y2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "with \\<open>pairwise orthogonal C\\<close>"], ["proof (chain)\npicking this:\n  pairwise orthogonal C\n  ?y2 \\<in> C \\<Longrightarrow>\n  orthogonal\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) ?y2", "have CPO: \"pairwise orthogonal ?C\""], ["proof (prove)\nusing this:\n  pairwise orthogonal C\n  ?y2 \\<in> C \\<Longrightarrow>\n  orthogonal\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) ?y2\n\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     (insert\n       (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n       C)", "by (rule pairwise_orthogonal_insert)"], ["proof (state)\nthis:\n  pairwise orthogonal\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "from fC cC SC CPO"], ["proof (chain)\npicking this:\n  finite\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n  card\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n  \\<le> card (insert a B)\n  span\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n     C) =\n  span (insert a B)\n  pairwise orthogonal\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)", "have \"?P (insert a B) ?C\""], ["proof (prove)\nusing this:\n  finite\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n  card\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n  \\<le> card (insert a B)\n  span\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n     C) =\n  span (insert a B)\n  pairwise orthogonal\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n\ngoal (1 subgoal):\n 1. finite\n     (insert\n       (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n       C) \\<and>\n    card\n     (insert\n       (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n       C)\n    \\<le> card (insert a B) \\<and>\n    span\n     (insert\n       (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n       C) =\n    span (insert a B) \\<and>\n    pairwise orthogonal\n     (insert\n       (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n       C)", "by blast"], ["proof (state)\nthis:\n  finite\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n     C) \\<and>\n  card\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n  \\<le> card (insert a B) \\<and>\n  span\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n     C) =\n  span (insert a B) \\<and>\n  pairwise orthogonal\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>C.\n           finite C \\<and>\n           card C \\<le> card F \\<and>\n           span C = span F \\<and> pairwise orthogonal C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            finite C \\<and>\n                            card C \\<le> card (insert x F) \\<and>\n                            span C = span (insert x F) \\<and>\n                            pairwise orthogonal C", "then"], ["proof (chain)\npicking this:\n  finite\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n     C) \\<and>\n  card\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n  \\<le> card (insert a B) \\<and>\n  span\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n     C) =\n  span (insert a B) \\<and>\n  pairwise orthogonal\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)", "show ?case"], ["proof (prove)\nusing this:\n  finite\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n     C) \\<and>\n  card\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n  \\<le> card (insert a B) \\<and>\n  span\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n     C) =\n  span (insert a B) \\<and>\n  pairwise orthogonal\n   (insert\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)) C)\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       finite C \\<and>\n       card C \\<le> card (insert a B) \\<and>\n       span C = span (insert a B) \\<and> pairwise orthogonal C", "by blast"], ["proof (state)\nthis:\n  \\<exists>C.\n     finite C \\<and>\n     card C \\<le> card (insert a B) \\<and>\n     span C = span (insert a B) \\<and> pairwise orthogonal C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma op_vec_scaleR: \"(*s) = (*\\<^sub>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (*s) = (*\\<^sub>R)", "by (force simp: scalar_mult_eq_scaleR)"], ["", "end"]]}