{"file_name": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition/QR_Efficient.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition", "problem_names": ["lemma sum_list_remdups:\n  assumes \"!!i j. i<length xs \\<and> j<length xs \\<and> i \\<noteq> j \n  \\<and> xs ! i = xs ! j \\<longrightarrow> xs ! i = 0 \\<and> xs ! j = 0\"\n  shows \"sum_list (remdups xs) = sum_list xs\"", "lemma sum_list_remdups_2:\n  fixes f:: \"'a::{zero, monoid_add}\\<Rightarrow>'a\"\n  assumes \"!!i j. i<length xs \\<and> j<length xs \\<and> i \\<noteq> j \\<and> (xs ! i) = (xs ! j) \n    \\<longrightarrow> f (xs ! i) = 0 \\<and> f (xs ! j) = 0\"\n  shows \"sum_list (map f (remdups xs)) = sum_list (map f xs)\"", "lemma set_map_column:\n  \"set (map (\\<lambda>n. column (from_nat n) G) [0..<to_nat b]) =  {column i G|i. i<b}\"", "lemma column_Gram_Schmidt_column_k_repeated_0:\n  fixes A::\"'a::{real_inner}^'n::{mod_type}^'m::{mod_type}\"\n  assumes i_not_k: \"i\\<noteq>k\" and ik: \"i<k\"\n  and c_eq: \"column k (Gram_Schmidt_column_k A (to_nat k)) \n  = column i (Gram_Schmidt_column_k A (to_nat k))\"\n  and o: \"pairwise orthogonal {column i A|i. i<k}\"\n  shows \"column k (Gram_Schmidt_column_k A (to_nat k)) = 0\" \n  and \"column i (Gram_Schmidt_column_k A (to_nat k)) = 0\"", "lemma column_Gram_Schmidt_upt_k_repeated_0':\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes i_not_k: \"i\\<noteq>j\" and ij: \"i<j\" and j: \"j\\<le>from_nat k\"\n  and c_eq: \"column j (Gram_Schmidt_upt_k A k) \n  = column i (Gram_Schmidt_upt_k A k)\"\n  and k: \"k<ncols A\"\n  shows \"column j (Gram_Schmidt_upt_k A k) = 0\"", "lemma column_Gram_Schmidt_upt_k_repeated_0:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes i_not_k: \"i\\<noteq>j\" and ij: \"i<j\" and j: \"j\\<le>k\"\n  and c_eq: \"column j (Gram_Schmidt_upt_k A (to_nat k)) \n  = column i (Gram_Schmidt_upt_k A (to_nat k))\"\n  shows \"column j (Gram_Schmidt_upt_k A (to_nat k)) = 0\"", "lemma column_Gram_Schmidt_column_k_eq_efficient:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"Gram_Schmidt_upt_k A k = foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]\"\n  and suc_k: \"Suc k < ncols A\"\n  shows \"column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n  = column b (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))\"", "lemma Gram_Schmidt_upt_k_efficient_induction:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"Gram_Schmidt_upt_k A k = foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]\"\n  and suc_k: \"Suc k < ncols A\"\n  shows \"Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k) \n  = Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k)\"", "lemma Gram_Schmidt_upt_k_efficient:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\" \n  assumes k: \"k<ncols A\"\n  shows \"Gram_Schmidt_upt_k A k = foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]\"", "lemma Gram_Schmidt_matrix_efficient[code_unfold]:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\" \n  shows \"Gram_Schmidt_matrix A = foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]\"", "lemma tabulate2_nth:\n  assumes i: \"i<nr\" and j: \"j<nc\"\n  shows \"(tabulate2 nr nc f) !! i !! j = f i j\"", "lemma vec_to_iarray_minus[code_unfold]: \n  \"vec_to_iarray (a - b) =  (vec_to_iarray a) - (vec_to_iarray b)\"", "lemma vec_to_iarray_minus_nth:\n  assumes A: \"i<IArray.length (vec_to_iarray A)\" \n  and B: \"i<IArray.length (vec_to_iarray B)\"\n  shows \"(vec_to_iarray A - vec_to_iarray B) !! i \n  = vec_to_iarray A !! i - vec_to_iarray B !! i\"", "lemma sum_list_map_vec_to_iarray:\n  assumes \"xs \\<noteq> []\" (*If I remove this assumption, I have to prove \n  vec_to_iarray 0 = IArray [] which is false.*)\n  shows \"sum_list (map (vec_to_iarray \\<circ> f) xs) = vec_to_iarray (sum_list (map f xs))\"", "lemma matrix_to_iarray_Gram_Schmidt_column_k_efficient:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\" \n  assumes k: \"k<ncols A\"\n  shows \"matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) \n  = Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k\"", "lemma matrix_to_iarray_Gram_Schmidt_upt_k_efficient:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\" \n  assumes k: \"k<ncols A\"\n  shows \"matrix_to_iarray (Gram_Schmidt_upt_k A k) \n  = foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) [0..<Suc k]\"", "lemma matrix_to_iarray_Gram_Schmidt_matrix_efficient[code_unfold]:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\" \n  shows \"matrix_to_iarray (Gram_Schmidt_matrix A) \n  = Gram_Schmidt_matrix_iarrays_efficient (matrix_to_iarray A)\"", "lemma QR_decomposition_iarrays_efficient[code]: \n  \"QR_decomposition_iarrays (matrix_to_iarray A) \n  = QR_decomposition_iarrays_efficient (matrix_to_iarray A)\"", "lemma inner_iarray_code[code]:\n  \"inner_iarray A B = sum_list (map (\\<lambda>n. A !! n * B !! n) [0..<IArray.length A])\"", "lemma Gram_Schmidt_column_k_iarrays_efficient_eq[code]: \"Gram_Schmidt_column_k_iarrays_efficient A k \n  = Gram_Schmidt_column_k_iarrays_efficient2 A k\""], "translations": [["", "lemma sum_list_remdups:\n  assumes \"!!i j. i<length xs \\<and> j<length xs \\<and> i \\<noteq> j \n  \\<and> xs ! i = xs ! j \\<longrightarrow> xs ! i = 0 \\<and> xs ! j = 0\"\n  shows \"sum_list (remdups xs) = sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (remdups xs) = sum_list xs", "using assms"], ["proof (prove)\nusing this:\n  ?i < length xs \\<and>\n  ?j < length xs \\<and>\n  ?i \\<noteq> ?j \\<and> xs ! ?i = xs ! ?j \\<longrightarrow>\n  xs ! ?i = (0::'a) \\<and> xs ! ?j = (0::'a)\n\ngoal (1 subgoal):\n 1. sum_list (remdups xs) = sum_list xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>i j.\n        i < length [] \\<and>\n        j < length [] \\<and>\n        i \\<noteq> j \\<and> [] ! i = [] ! j \\<longrightarrow>\n        [] ! i = (0::'a) \\<and> [] ! j = (0::'a)) \\<Longrightarrow>\n    sum_list (remdups []) = sum_list []\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    i < length xs \\<and>\n                    j < length xs \\<and>\n                    i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n                    xs ! i = (0::'a) \\<and>\n                    xs ! j = (0::'a)) \\<Longrightarrow>\n                sum_list (remdups xs) = sum_list xs;\n        \\<And>i j.\n           i < length (a # xs) \\<and>\n           j < length (a # xs) \\<and>\n           i \\<noteq> j \\<and> (a # xs) ! i = (a # xs) ! j \\<longrightarrow>\n           (a # xs) ! i = (0::'a) \\<and> (a # xs) ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (remdups (a # xs)) = sum_list (a # xs)", "case Nil"], ["proof (state)\nthis:\n  ?i < length [] \\<and>\n  ?j < length [] \\<and>\n  ?i \\<noteq> ?j \\<and> [] ! ?i = [] ! ?j \\<longrightarrow>\n  [] ! ?i = (0::'a) \\<and> [] ! ?j = (0::'a)\n\ngoal (2 subgoals):\n 1. (\\<And>i j.\n        i < length [] \\<and>\n        j < length [] \\<and>\n        i \\<noteq> j \\<and> [] ! i = [] ! j \\<longrightarrow>\n        [] ! i = (0::'a) \\<and> [] ! j = (0::'a)) \\<Longrightarrow>\n    sum_list (remdups []) = sum_list []\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    i < length xs \\<and>\n                    j < length xs \\<and>\n                    i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n                    xs ! i = (0::'a) \\<and>\n                    xs ! j = (0::'a)) \\<Longrightarrow>\n                sum_list (remdups xs) = sum_list xs;\n        \\<And>i j.\n           i < length (a # xs) \\<and>\n           j < length (a # xs) \\<and>\n           i \\<noteq> j \\<and> (a # xs) ! i = (a # xs) ! j \\<longrightarrow>\n           (a # xs) ! i = (0::'a) \\<and> (a # xs) ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (remdups (a # xs)) = sum_list (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  ?i < length [] \\<and>\n  ?j < length [] \\<and>\n  ?i \\<noteq> ?j \\<and> [] ! ?i = [] ! ?j \\<longrightarrow>\n  [] ! ?i = (0::'a) \\<and> [] ! ?j = (0::'a)\n\ngoal (1 subgoal):\n 1. sum_list (remdups []) = sum_list []", "by auto"], ["proof (state)\nthis:\n  sum_list (remdups []) = sum_list []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    i < length xs \\<and>\n                    j < length xs \\<and>\n                    i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n                    xs ! i = (0::'a) \\<and>\n                    xs ! j = (0::'a)) \\<Longrightarrow>\n                sum_list (remdups xs) = sum_list xs;\n        \\<And>i j.\n           i < length (a # xs) \\<and>\n           j < length (a # xs) \\<and>\n           i \\<noteq> j \\<and> (a # xs) ! i = (a # xs) ! j \\<longrightarrow>\n           (a # xs) ! i = (0::'a) \\<and> (a # xs) ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (remdups (a # xs)) = sum_list (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    i < length xs \\<and>\n                    j < length xs \\<and>\n                    i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n                    xs ! i = (0::'a) \\<and>\n                    xs ! j = (0::'a)) \\<Longrightarrow>\n                sum_list (remdups xs) = sum_list xs;\n        \\<And>i j.\n           i < length (a # xs) \\<and>\n           j < length (a # xs) \\<and>\n           i \\<noteq> j \\<and> (a # xs) ! i = (a # xs) ! j \\<longrightarrow>\n           (a # xs) ! i = (0::'a) \\<and> (a # xs) ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (remdups (a # xs)) = sum_list (a # xs)", "case (Cons a xs)"], ["proof (state)\nthis:\n  (\\<And>i j.\n      i < length xs \\<and>\n      j < length xs \\<and>\n      i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n      xs ! i = (0::'a) \\<and> xs ! j = (0::'a)) \\<Longrightarrow>\n  sum_list (remdups xs) = sum_list xs\n  ?i < length (a # xs) \\<and>\n  ?j < length (a # xs) \\<and>\n  ?i \\<noteq> ?j \\<and> (a # xs) ! ?i = (a # xs) ! ?j \\<longrightarrow>\n  (a # xs) ! ?i = (0::'a) \\<and> (a # xs) ! ?j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    i < length xs \\<and>\n                    j < length xs \\<and>\n                    i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n                    xs ! i = (0::'a) \\<and>\n                    xs ! j = (0::'a)) \\<Longrightarrow>\n                sum_list (remdups xs) = sum_list xs;\n        \\<And>i j.\n           i < length (a # xs) \\<and>\n           j < length (a # xs) \\<and>\n           i \\<noteq> j \\<and> (a # xs) ! i = (a # xs) ! j \\<longrightarrow>\n           (a # xs) ! i = (0::'a) \\<and> (a # xs) ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (remdups (a # xs)) = sum_list (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (remdups (a # xs)) = sum_list (a # xs)", "proof (cases \"a \\<in> set (xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "case False"], ["proof (state)\nthis:\n  a \\<notin> set xs\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "have \"sum_list (remdups (a # xs)) = sum_list (a # (remdups xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (remdups (a # xs)) = sum_list (a # remdups xs)", "by (simp add: False)"], ["proof (state)\nthis:\n  sum_list (remdups (a # xs)) = sum_list (a # remdups xs)\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "also"], ["proof (state)\nthis:\n  sum_list (remdups (a # xs)) = sum_list (a # remdups xs)\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "have \"... = a + sum_list (remdups xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (a # remdups xs) = a + sum_list (remdups xs)", "by auto"], ["proof (state)\nthis:\n  sum_list (a # remdups xs) = a + sum_list (remdups xs)\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "also"], ["proof (state)\nthis:\n  sum_list (a # remdups xs) = a + sum_list (remdups xs)\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "have \"... = a + sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + sum_list (remdups xs) = a + sum_list xs", "using Cons.hyps Cons.prems False"], ["proof (prove)\nusing this:\n  (\\<And>i j.\n      i < length xs \\<and>\n      j < length xs \\<and>\n      i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n      xs ! i = (0::'a) \\<and> xs ! j = (0::'a)) \\<Longrightarrow>\n  sum_list (remdups xs) = sum_list xs\n  ?i < length (a # xs) \\<and>\n  ?j < length (a # xs) \\<and>\n  ?i \\<noteq> ?j \\<and> (a # xs) ! ?i = (a # xs) ! ?j \\<longrightarrow>\n  (a # xs) ! ?i = (0::'a) \\<and> (a # xs) ! ?j = (0::'a)\n  a \\<notin> set xs\n\ngoal (1 subgoal):\n 1. a + sum_list (remdups xs) = a + sum_list xs", "by fastforce"], ["proof (state)\nthis:\n  a + sum_list (remdups xs) = a + sum_list xs\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "also"], ["proof (state)\nthis:\n  a + sum_list (remdups xs) = a + sum_list xs\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "have \"... = sum_list (a # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + sum_list xs = sum_list (a # xs)", "by simp"], ["proof (state)\nthis:\n  a + sum_list xs = sum_list (a # xs)\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "finally"], ["proof (chain)\npicking this:\n  sum_list (remdups (a # xs)) = sum_list (a # xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (remdups (a # xs)) = sum_list (a # xs)\n\ngoal (1 subgoal):\n 1. sum_list (remdups (a # xs)) = sum_list (a # xs)", "."], ["proof (state)\nthis:\n  sum_list (remdups (a # xs)) = sum_list (a # xs)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "case True"], ["proof (state)\nthis:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "have a: \"a=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = (0::'a)", "using Cons.hyps Cons.prems True"], ["proof (prove)\nusing this:\n  (\\<And>i j.\n      i < length xs \\<and>\n      j < length xs \\<and>\n      i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n      xs ! i = (0::'a) \\<and> xs ! j = (0::'a)) \\<Longrightarrow>\n  sum_list (remdups xs) = sum_list xs\n  ?i < length (a # xs) \\<and>\n  ?j < length (a # xs) \\<and>\n  ?i \\<noteq> ?j \\<and> (a # xs) ! ?i = (a # xs) ! ?j \\<longrightarrow>\n  (a # xs) ! ?i = (0::'a) \\<and> (a # xs) ! ?j = (0::'a)\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a = (0::'a)", "by (metis Suc_less_eq add.right_neutral add_Suc_right add_gr_0 \n        in_set_conv_nth lessI list.size(4) nat.simps(3) nth_Cons_0 nth_Cons_Suc)"], ["proof (state)\nthis:\n  a = (0::'a)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "have \"sum_list (remdups (a # xs)) = sum_list (remdups xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (remdups (a # xs)) = sum_list (remdups xs)", "using True"], ["proof (prove)\nusing this:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. sum_list (remdups (a # xs)) = sum_list (remdups xs)", "by auto"], ["proof (state)\nthis:\n  sum_list (remdups (a # xs)) = sum_list (remdups xs)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "also"], ["proof (state)\nthis:\n  sum_list (remdups (a # xs)) = sum_list (remdups xs)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "have \"... = sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (remdups xs) = sum_list xs", "using Cons.hyps Cons.prems True"], ["proof (prove)\nusing this:\n  (\\<And>i j.\n      i < length xs \\<and>\n      j < length xs \\<and>\n      i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n      xs ! i = (0::'a) \\<and> xs ! j = (0::'a)) \\<Longrightarrow>\n  sum_list (remdups xs) = sum_list xs\n  ?i < length (a # xs) \\<and>\n  ?j < length (a # xs) \\<and>\n  ?i \\<noteq> ?j \\<and> (a # xs) ! ?i = (a # xs) ! ?j \\<longrightarrow>\n  (a # xs) ! ?i = (0::'a) \\<and> (a # xs) ! ?j = (0::'a)\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. sum_list (remdups xs) = sum_list xs", "by fastforce"], ["proof (state)\nthis:\n  sum_list (remdups xs) = sum_list xs\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "also"], ["proof (state)\nthis:\n  sum_list (remdups xs) = sum_list xs\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "have \"... = a + sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs = a + sum_list xs", "using a"], ["proof (prove)\nusing this:\n  a = (0::'a)\n\ngoal (1 subgoal):\n 1. sum_list xs = a + sum_list xs", "by simp"], ["proof (state)\nthis:\n  sum_list xs = a + sum_list xs\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "also"], ["proof (state)\nthis:\n  sum_list xs = a + sum_list xs\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "have \"... = sum_list (a # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + sum_list xs = sum_list (a # xs)", "by simp"], ["proof (state)\nthis:\n  a + sum_list xs = sum_list (a # xs)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (remdups (a # xs)) = sum_list (a # xs)", "finally"], ["proof (chain)\npicking this:\n  sum_list (remdups (a # xs)) = sum_list (a # xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (remdups (a # xs)) = sum_list (a # xs)\n\ngoal (1 subgoal):\n 1. sum_list (remdups (a # xs)) = sum_list (a # xs)", "."], ["proof (state)\nthis:\n  sum_list (remdups (a # xs)) = sum_list (a # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (remdups (a # xs)) = sum_list (a # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_remdups_2:\n  fixes f:: \"'a::{zero, monoid_add}\\<Rightarrow>'a\"\n  assumes \"!!i j. i<length xs \\<and> j<length xs \\<and> i \\<noteq> j \\<and> (xs ! i) = (xs ! j) \n    \\<longrightarrow> f (xs ! i) = 0 \\<and> f (xs ! j) = 0\"\n  shows \"sum_list (map f (remdups xs)) = sum_list (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (remdups xs)) = sum_list (map f xs)", "using assms"], ["proof (prove)\nusing this:\n  ?i < length xs \\<and>\n  ?j < length xs \\<and>\n  ?i \\<noteq> ?j \\<and> xs ! ?i = xs ! ?j \\<longrightarrow>\n  f (xs ! ?i) = (0::'a) \\<and> f (xs ! ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. sum_list (map f (remdups xs)) = sum_list (map f xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>i j.\n        i < length [] \\<and>\n        j < length [] \\<and>\n        i \\<noteq> j \\<and> [] ! i = [] ! j \\<longrightarrow>\n        f ([] ! i) = (0::'a) \\<and> f ([] ! j) = (0::'a)) \\<Longrightarrow>\n    sum_list (map f (remdups [])) = sum_list (map f [])\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    i < length xs \\<and>\n                    j < length xs \\<and>\n                    i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n                    f (xs ! i) = (0::'a) \\<and>\n                    f (xs ! j) = (0::'a)) \\<Longrightarrow>\n                sum_list (map f (remdups xs)) = sum_list (map f xs);\n        \\<And>i j.\n           i < length (a # xs) \\<and>\n           j < length (a # xs) \\<and>\n           i \\<noteq> j \\<and> (a # xs) ! i = (a # xs) ! j \\<longrightarrow>\n           f ((a # xs) ! i) = (0::'a) \\<and>\n           f ((a # xs) ! j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (remdups (a # xs))) =\n                         sum_list (map f (a # xs))", "case Nil"], ["proof (state)\nthis:\n  ?i < length [] \\<and>\n  ?j < length [] \\<and>\n  ?i \\<noteq> ?j \\<and> [] ! ?i = [] ! ?j \\<longrightarrow>\n  f ([] ! ?i) = (0::'a) \\<and> f ([] ! ?j) = (0::'a)\n\ngoal (2 subgoals):\n 1. (\\<And>i j.\n        i < length [] \\<and>\n        j < length [] \\<and>\n        i \\<noteq> j \\<and> [] ! i = [] ! j \\<longrightarrow>\n        f ([] ! i) = (0::'a) \\<and> f ([] ! j) = (0::'a)) \\<Longrightarrow>\n    sum_list (map f (remdups [])) = sum_list (map f [])\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    i < length xs \\<and>\n                    j < length xs \\<and>\n                    i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n                    f (xs ! i) = (0::'a) \\<and>\n                    f (xs ! j) = (0::'a)) \\<Longrightarrow>\n                sum_list (map f (remdups xs)) = sum_list (map f xs);\n        \\<And>i j.\n           i < length (a # xs) \\<and>\n           j < length (a # xs) \\<and>\n           i \\<noteq> j \\<and> (a # xs) ! i = (a # xs) ! j \\<longrightarrow>\n           f ((a # xs) ! i) = (0::'a) \\<and>\n           f ((a # xs) ! j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (remdups (a # xs))) =\n                         sum_list (map f (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (remdups [])) = sum_list (map f [])", "by auto"], ["proof (state)\nthis:\n  sum_list (map f (remdups [])) = sum_list (map f [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    i < length xs \\<and>\n                    j < length xs \\<and>\n                    i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n                    f (xs ! i) = (0::'a) \\<and>\n                    f (xs ! j) = (0::'a)) \\<Longrightarrow>\n                sum_list (map f (remdups xs)) = sum_list (map f xs);\n        \\<And>i j.\n           i < length (a # xs) \\<and>\n           j < length (a # xs) \\<and>\n           i \\<noteq> j \\<and> (a # xs) ! i = (a # xs) ! j \\<longrightarrow>\n           f ((a # xs) ! i) = (0::'a) \\<and>\n           f ((a # xs) ! j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (remdups (a # xs))) =\n                         sum_list (map f (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    i < length xs \\<and>\n                    j < length xs \\<and>\n                    i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n                    f (xs ! i) = (0::'a) \\<and>\n                    f (xs ! j) = (0::'a)) \\<Longrightarrow>\n                sum_list (map f (remdups xs)) = sum_list (map f xs);\n        \\<And>i j.\n           i < length (a # xs) \\<and>\n           j < length (a # xs) \\<and>\n           i \\<noteq> j \\<and> (a # xs) ! i = (a # xs) ! j \\<longrightarrow>\n           f ((a # xs) ! i) = (0::'a) \\<and>\n           f ((a # xs) ! j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (remdups (a # xs))) =\n                         sum_list (map f (a # xs))", "case (Cons a xs)"], ["proof (state)\nthis:\n  (\\<And>i j.\n      i < length xs \\<and>\n      j < length xs \\<and>\n      i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n      f (xs ! i) = (0::'a) \\<and> f (xs ! j) = (0::'a)) \\<Longrightarrow>\n  sum_list (map f (remdups xs)) = sum_list (map f xs)\n  ?i < length (a # xs) \\<and>\n  ?j < length (a # xs) \\<and>\n  ?i \\<noteq> ?j \\<and> (a # xs) ! ?i = (a # xs) ! ?j \\<longrightarrow>\n  f ((a # xs) ! ?i) = (0::'a) \\<and> f ((a # xs) ! ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    i < length xs \\<and>\n                    j < length xs \\<and>\n                    i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n                    f (xs ! i) = (0::'a) \\<and>\n                    f (xs ! j) = (0::'a)) \\<Longrightarrow>\n                sum_list (map f (remdups xs)) = sum_list (map f xs);\n        \\<And>i j.\n           i < length (a # xs) \\<and>\n           j < length (a # xs) \\<and>\n           i \\<noteq> j \\<and> (a # xs) ! i = (a # xs) ! j \\<longrightarrow>\n           f ((a # xs) ! i) = (0::'a) \\<and>\n           f ((a # xs) ! j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (map f (remdups (a # xs))) =\n                         sum_list (map f (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "proof (cases \"a \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "case False"], ["proof (state)\nthis:\n  a \\<notin> set xs\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "hence \"sum_list (map f (remdups (a # xs))) =  sum_list (map f (a # (remdups xs)))\""], ["proof (prove)\nusing this:\n  a \\<notin> set xs\n\ngoal (1 subgoal):\n 1. sum_list (map f (remdups (a # xs))) = sum_list (map f (a # remdups xs))", "by simp"], ["proof (state)\nthis:\n  sum_list (map f (remdups (a # xs))) = sum_list (map f (a # remdups xs))\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "also"], ["proof (state)\nthis:\n  sum_list (map f (remdups (a # xs))) = sum_list (map f (a # remdups xs))\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "have \"... = sum_list (f a # (map f (remdups xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (a # remdups xs)) = sum_list (f a # map f (remdups xs))", "by auto"], ["proof (state)\nthis:\n  sum_list (map f (a # remdups xs)) = sum_list (f a # map f (remdups xs))\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "also"], ["proof (state)\nthis:\n  sum_list (map f (a # remdups xs)) = sum_list (f a # map f (remdups xs))\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "have \"... = f a + sum_list (map f (remdups xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (f a # map f (remdups xs)) =\n    f a + sum_list (map f (remdups xs))", "by auto"], ["proof (state)\nthis:\n  sum_list (f a # map f (remdups xs)) = f a + sum_list (map f (remdups xs))\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "also"], ["proof (state)\nthis:\n  sum_list (f a # map f (remdups xs)) = f a + sum_list (map f (remdups xs))\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "have \"... = f a + sum_list (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a + sum_list (map f (remdups xs)) = f a + sum_list (map f xs)", "using Cons.prems Cons.hyps"], ["proof (prove)\nusing this:\n  ?i < length (a # xs) \\<and>\n  ?j < length (a # xs) \\<and>\n  ?i \\<noteq> ?j \\<and> (a # xs) ! ?i = (a # xs) ! ?j \\<longrightarrow>\n  f ((a # xs) ! ?i) = (0::'a) \\<and> f ((a # xs) ! ?j) = (0::'a)\n  (\\<And>i j.\n      i < length xs \\<and>\n      j < length xs \\<and>\n      i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n      f (xs ! i) = (0::'a) \\<and> f (xs ! j) = (0::'a)) \\<Longrightarrow>\n  sum_list (map f (remdups xs)) = sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. f a + sum_list (map f (remdups xs)) = f a + sum_list (map f xs)", "using id_apply"], ["proof (prove)\nusing this:\n  ?i < length (a # xs) \\<and>\n  ?j < length (a # xs) \\<and>\n  ?i \\<noteq> ?j \\<and> (a # xs) ! ?i = (a # xs) ! ?j \\<longrightarrow>\n  f ((a # xs) ! ?i) = (0::'a) \\<and> f ((a # xs) ! ?j) = (0::'a)\n  (\\<And>i j.\n      i < length xs \\<and>\n      j < length xs \\<and>\n      i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n      f (xs ! i) = (0::'a) \\<and> f (xs ! j) = (0::'a)) \\<Longrightarrow>\n  sum_list (map f (remdups xs)) = sum_list (map f xs)\n  id ?x = ?x\n\ngoal (1 subgoal):\n 1. f a + sum_list (map f (remdups xs)) = f a + sum_list (map f xs)", "by fastforce"], ["proof (state)\nthis:\n  f a + sum_list (map f (remdups xs)) = f a + sum_list (map f xs)\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "also"], ["proof (state)\nthis:\n  f a + sum_list (map f (remdups xs)) = f a + sum_list (map f xs)\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "have \"... =  sum_list (map f (a # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a + sum_list (map f xs) = sum_list (map f (a # xs))", "by auto"], ["proof (state)\nthis:\n  f a + sum_list (map f xs) = sum_list (map f (a # xs))\n\ngoal (2 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n 2. a \\<notin> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "finally"], ["proof (chain)\npicking this:\n  sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n\ngoal (1 subgoal):\n 1. sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "."], ["proof (state)\nthis:\n  sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "case True"], ["proof (state)\nthis:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "have fa_0: \"f a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a = (0::'a)", "using Cons.hyps Cons.prems True"], ["proof (prove)\nusing this:\n  (\\<And>i j.\n      i < length xs \\<and>\n      j < length xs \\<and>\n      i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n      f (xs ! i) = (0::'a) \\<and> f (xs ! j) = (0::'a)) \\<Longrightarrow>\n  sum_list (map f (remdups xs)) = sum_list (map f xs)\n  ?i < length (a # xs) \\<and>\n  ?j < length (a # xs) \\<and>\n  ?i \\<noteq> ?j \\<and> (a # xs) ! ?i = (a # xs) ! ?j \\<longrightarrow>\n  f ((a # xs) ! ?i) = (0::'a) \\<and> f ((a # xs) ! ?j) = (0::'a)\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. f a = (0::'a)", "by (metis Suc_less_eq add.right_neutral add_Suc_right add_gr_0 \n        in_set_conv_nth lessI list.size(4) nth_Cons_0 nth_Cons_Suc)"], ["proof (state)\nthis:\n  f a = (0::'a)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "have \"sum_list (map f (remdups (a # xs))) =  sum_list (map f (remdups xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (remdups (a # xs))) = sum_list (map f (remdups xs))", "using True"], ["proof (prove)\nusing this:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. sum_list (map f (remdups (a # xs))) = sum_list (map f (remdups xs))", "by simp"], ["proof (state)\nthis:\n  sum_list (map f (remdups (a # xs))) = sum_list (map f (remdups xs))\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "also"], ["proof (state)\nthis:\n  sum_list (map f (remdups (a # xs))) = sum_list (map f (remdups xs))\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "have \"... = sum_list (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (remdups xs)) = sum_list (map f xs)", "using Cons.prems Cons.hyps"], ["proof (prove)\nusing this:\n  ?i < length (a # xs) \\<and>\n  ?j < length (a # xs) \\<and>\n  ?i \\<noteq> ?j \\<and> (a # xs) ! ?i = (a # xs) ! ?j \\<longrightarrow>\n  f ((a # xs) ! ?i) = (0::'a) \\<and> f ((a # xs) ! ?j) = (0::'a)\n  (\\<And>i j.\n      i < length xs \\<and>\n      j < length xs \\<and>\n      i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n      f (xs ! i) = (0::'a) \\<and> f (xs ! j) = (0::'a)) \\<Longrightarrow>\n  sum_list (map f (remdups xs)) = sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. sum_list (map f (remdups xs)) = sum_list (map f xs)", "using id_apply"], ["proof (prove)\nusing this:\n  ?i < length (a # xs) \\<and>\n  ?j < length (a # xs) \\<and>\n  ?i \\<noteq> ?j \\<and> (a # xs) ! ?i = (a # xs) ! ?j \\<longrightarrow>\n  f ((a # xs) ! ?i) = (0::'a) \\<and> f ((a # xs) ! ?j) = (0::'a)\n  (\\<And>i j.\n      i < length xs \\<and>\n      j < length xs \\<and>\n      i \\<noteq> j \\<and> xs ! i = xs ! j \\<longrightarrow>\n      f (xs ! i) = (0::'a) \\<and> f (xs ! j) = (0::'a)) \\<Longrightarrow>\n  sum_list (map f (remdups xs)) = sum_list (map f xs)\n  id ?x = ?x\n\ngoal (1 subgoal):\n 1. sum_list (map f (remdups xs)) = sum_list (map f xs)", "by fastforce"], ["proof (state)\nthis:\n  sum_list (map f (remdups xs)) = sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "also"], ["proof (state)\nthis:\n  sum_list (map f (remdups xs)) = sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "have \"... = f a + sum_list (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f xs) = f a + sum_list (map f xs)", "using fa_0"], ["proof (prove)\nusing this:\n  f a = (0::'a)\n\ngoal (1 subgoal):\n 1. sum_list (map f xs) = f a + sum_list (map f xs)", "by simp"], ["proof (state)\nthis:\n  sum_list (map f xs) = f a + sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "also"], ["proof (state)\nthis:\n  sum_list (map f xs) = f a + sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "have \"... = sum_list (map f (a # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a + sum_list (map f xs) = sum_list (map f (a # xs))", "by auto"], ["proof (state)\nthis:\n  f a + sum_list (map f xs) = sum_list (map f (a # xs))\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "finally"], ["proof (chain)\npicking this:\n  sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n\ngoal (1 subgoal):\n 1. sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))", "."], ["proof (state)\nthis:\n  sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (map f (remdups (a # xs))) = sum_list (map f (a # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Proving a code equation to improve the performance\\<close>"], ["", "lemma set_map_column:\n  \"set (map (\\<lambda>n. column (from_nat n) G) [0..<to_nat b]) =  {column i G|i. i<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n          [0..<mod_type_class.to_nat b]) =\n    {column i G |i. i < b}", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa < mod_type_class.to_nat b \\<Longrightarrow>\n       \\<exists>i.\n          column (mod_type_class.from_nat xa) G = column i G \\<and> i < b\n 2. \\<And>i.\n       i < b \\<Longrightarrow>\n       column i G\n       \\<in> (\\<lambda>x. column (mod_type_class.from_nat x) G) `\n             {0..<mod_type_class.to_nat b}", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa < mod_type_class.to_nat b \\<Longrightarrow>\n       \\<exists>i.\n          column (mod_type_class.from_nat xa) G = column i G \\<and> i < b\n 2. \\<And>i.\n       i < b \\<Longrightarrow>\n       column i G\n       \\<in> (\\<lambda>x. column (mod_type_class.from_nat x) G) `\n             {0..<mod_type_class.to_nat b}", "assume \"n < to_nat b\""], ["proof (state)\nthis:\n  n < mod_type_class.to_nat b\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa < mod_type_class.to_nat b \\<Longrightarrow>\n       \\<exists>i.\n          column (mod_type_class.from_nat xa) G = column i G \\<and> i < b\n 2. \\<And>i.\n       i < b \\<Longrightarrow>\n       column i G\n       \\<in> (\\<lambda>x. column (mod_type_class.from_nat x) G) `\n             {0..<mod_type_class.to_nat b}", "hence \"from_nat n < b\""], ["proof (prove)\nusing this:\n  n < mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat n < b", "using from_nat_mono to_nat_less_card"], ["proof (prove)\nusing this:\n  n < mod_type_class.to_nat b\n  \\<lbrakk>?i < ?j; ?j < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat ?i < mod_type_class.from_nat ?j\n  mod_type_class.to_nat ?j < CARD(?'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat n < b", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.from_nat n < b\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa < mod_type_class.to_nat b \\<Longrightarrow>\n       \\<exists>i.\n          column (mod_type_class.from_nat xa) G = column i G \\<and> i < b\n 2. \\<And>i.\n       i < b \\<Longrightarrow>\n       column i G\n       \\<in> (\\<lambda>x. column (mod_type_class.from_nat x) G) `\n             {0..<mod_type_class.to_nat b}", "thus \"\\<exists>i. column (from_nat n) G = column i G\\<and> i < b\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat n < b\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       column (mod_type_class.from_nat n) G = column i G \\<and> i < b", "by auto"], ["proof (state)\nthis:\n  \\<exists>i. column (mod_type_class.from_nat n) G = column i G \\<and> i < b\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < b \\<Longrightarrow>\n       column i G\n       \\<in> (\\<lambda>x. column (mod_type_class.from_nat x) G) `\n             {0..<mod_type_class.to_nat b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < b \\<Longrightarrow>\n       column i G\n       \\<in> (\\<lambda>x. column (mod_type_class.from_nat x) G) `\n             {0..<mod_type_class.to_nat b}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < b \\<Longrightarrow>\n       column i G\n       \\<in> (\\<lambda>x. column (mod_type_class.from_nat x) G) `\n             {0..<mod_type_class.to_nat b}", "assume \"i < b\""], ["proof (state)\nthis:\n  i < b\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < b \\<Longrightarrow>\n       column i G\n       \\<in> (\\<lambda>x. column (mod_type_class.from_nat x) G) `\n             {0..<mod_type_class.to_nat b}", "hence ib: \"to_nat i < to_nat b\""], ["proof (prove)\nusing this:\n  i < b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < mod_type_class.to_nat b", "by (simp add: to_nat_le)"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < b \\<Longrightarrow>\n       column i G\n       \\<in> (\\<lambda>x. column (mod_type_class.from_nat x) G) `\n             {0..<mod_type_class.to_nat b}", "show \"column i G \\<in> (\\<lambda>n. column (from_nat n) G) ` {0..<to_nat b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i G\n    \\<in> (\\<lambda>n. column (mod_type_class.from_nat n) G) `\n          {0..<mod_type_class.to_nat b}", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. column i G\n    \\<in> {y. \\<exists>x\\<in>{0..<mod_type_class.to_nat b}.\n                 y = column (mod_type_class.from_nat x) G}", "by (auto, rule bexI[of _ \"to_nat i\"], auto simp add: ib)"], ["proof (state)\nthis:\n  column i G\n  \\<in> (\\<lambda>n. column (mod_type_class.from_nat n) G) `\n        {0..<mod_type_class.to_nat b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma column_Gram_Schmidt_column_k_repeated_0:\n  fixes A::\"'a::{real_inner}^'n::{mod_type}^'m::{mod_type}\"\n  assumes i_not_k: \"i\\<noteq>k\" and ik: \"i<k\"\n  and c_eq: \"column k (Gram_Schmidt_column_k A (to_nat k)) \n  = column i (Gram_Schmidt_column_k A (to_nat k))\"\n  and o: \"pairwise orthogonal {column i A|i. i<k}\"\n  shows \"column k (Gram_Schmidt_column_k A (to_nat k)) = 0\" \n  and \"column i (Gram_Schmidt_column_k A (to_nat k)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0 &&&\n    column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0\n 2. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0", "have \"column k (Gram_Schmidt_column_k A (to_nat k)) \n    = column k A - (\\<Sum>x\\<in>{column i A |i. i < k}. (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) =\n    column k A -\n    (\\<Sum>x\\<in>{column i A |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "by (rule column_Gram_Schmidt_column_k)"], ["proof (state)\nthis:\n  column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) =\n  column k A -\n  (\\<Sum>x\\<in>{column i A |i. i < k}.\n     (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (2 subgoals):\n 1. column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0\n 2. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0", "also"], ["proof (state)\nthis:\n  column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) =\n  column k A -\n  (\\<Sum>x\\<in>{column i A |i. i < k}.\n     (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (2 subgoals):\n 1. column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0\n 2. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0", "have \"... = column k A - proj_onto (column k A) {column i A |i. i < k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column k A -\n    (\\<Sum>x\\<in>{column i A |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x) =\n    column k A - proj_onto (column k A) {column i A |i. i < k}", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. column k A -\n    (\\<Sum>x\\<in>{column i A |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x) =\n    column k A -\n    (\\<Sum>u\\<in>{column i A |i. i < k}.\n       (column k A \\<bullet> u / (u \\<bullet> u)) *\\<^sub>R u)", "by (metis (no_types, lifting) inner_commute)"], ["proof (state)\nthis:\n  column k A -\n  (\\<Sum>x\\<in>{column i A |i. i < k}.\n     (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x) =\n  column k A - proj_onto (column k A) {column i A |i. i < k}\n\ngoal (2 subgoals):\n 1. column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0\n 2. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0", "finally"], ["proof (chain)\npicking this:\n  column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) =\n  column k A - proj_onto (column k A) {column i A |i. i < k}", "have col_k_rw: \"column k (Gram_Schmidt_column_k A (to_nat k)) \n    = column k A - proj_onto (column k A) {column i A |i. i < k}\""], ["proof (prove)\nusing this:\n  column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) =\n  column k A - proj_onto (column k A) {column i A |i. i < k}\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) =\n    column k A - proj_onto (column k A) {column i A |i. i < k}", "."], ["proof (state)\nthis:\n  column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) =\n  column k A - proj_onto (column k A) {column i A |i. i < k}\n\ngoal (2 subgoals):\n 1. column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0\n 2. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0", "have \"orthogonal (column k (Gram_Schmidt_column_k A (to_nat k))) \n    (column i (Gram_Schmidt_column_k A (to_nat k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal\n     (column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)))\n     (column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)))", "unfolding col_k_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal (column k A - proj_onto (column k A) {column i A |i. i < k})\n     (column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)))", "proof (rule orthogonal_proj_set[OF _ _ o])"], ["proof (state)\ngoal (2 subgoals):\n 1. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k))\n    \\<in> {column i A |i. i < k}\n 2. finite {column i A |i. i < k}", "have \"column i (Gram_Schmidt_column_k A (to_nat k)) = column i A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) =\n    column i A", "using column_Gram_Schmidt_column_k'[OF i_not_k]"], ["proof (prove)\nusing this:\n  column i (Gram_Schmidt_column_k ?A (mod_type_class.to_nat k)) =\n  column i ?A\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) =\n    column i A", "."], ["proof (state)\nthis:\n  column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = column i A\n\ngoal (2 subgoals):\n 1. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k))\n    \\<in> {column i A |i. i < k}\n 2. finite {column i A |i. i < k}", "also"], ["proof (state)\nthis:\n  column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = column i A\n\ngoal (2 subgoals):\n 1. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k))\n    \\<in> {column i A |i. i < k}\n 2. finite {column i A |i. i < k}", "have \"...  \\<in> {column i A |i. i < k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i A \\<in> {column i A |i. i < k}", "using assms(2)"], ["proof (prove)\nusing this:\n  i < k\n\ngoal (1 subgoal):\n 1. column i A \\<in> {column i A |i. i < k}", "by blast"], ["proof (state)\nthis:\n  column i A \\<in> {column i A |i. i < k}\n\ngoal (2 subgoals):\n 1. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k))\n    \\<in> {column i A |i. i < k}\n 2. finite {column i A |i. i < k}", "finally"], ["proof (chain)\npicking this:\n  column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k))\n  \\<in> {column i A |i. i < k}", "show \"column i (Gram_Schmidt_column_k A (to_nat k)) \\<in> {column i A |i. i < k}\""], ["proof (prove)\nusing this:\n  column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k))\n  \\<in> {column i A |i. i < k}\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k))\n    \\<in> {column i A |i. i < k}", "."], ["proof (state)\nthis:\n  column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k))\n  \\<in> {column i A |i. i < k}\n\ngoal (1 subgoal):\n 1. finite {column i A |i. i < k}", "show \"finite {column i A |i. i < k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {column i A |i. i < k}", "by auto"], ["proof (state)\nthis:\n  finite {column i A |i. i < k}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  orthogonal (column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)))\n   (column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)))\n\ngoal (2 subgoals):\n 1. column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0\n 2. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0", "thus \"column k (Gram_Schmidt_column_k A (to_nat k)) = 0\"\n    and \"column i (Gram_Schmidt_column_k A (to_nat k)) = 0\""], ["proof (prove)\nusing this:\n  orthogonal (column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)))\n   (column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)))\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0 &&&\n    column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0", "unfolding orthogonal_def c_eq inner_eq_zero_iff"], ["proof (prove)\nusing this:\n  column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0 &&&\n    column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0", "by auto"], ["proof (state)\nthis:\n  column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0\n  column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma column_Gram_Schmidt_upt_k_repeated_0':\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes i_not_k: \"i\\<noteq>j\" and ij: \"i<j\" and j: \"j\\<le>from_nat k\"\n  and c_eq: \"column j (Gram_Schmidt_upt_k A k) \n  = column i (Gram_Schmidt_upt_k A k)\"\n  and k: \"k<ncols A\"\n  shows \"column j (Gram_Schmidt_upt_k A k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A k) = 0", "using j c_eq k"], ["proof (prove)\nusing this:\n  j \\<le> mod_type_class.from_nat k\n  column j (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_upt_k A k)\n  k < ncols A\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A k) = 0", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j \\<le> mod_type_class.from_nat 0;\n     column j (Gram_Schmidt_upt_k A 0) = column i (Gram_Schmidt_upt_k A 0);\n     0 < ncols A\\<rbrakk>\n    \\<Longrightarrow> column j (Gram_Schmidt_upt_k A 0) = 0\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>j \\<le> mod_type_class.from_nat k;\n                 column j (Gram_Schmidt_upt_k A k) =\n                 column i (Gram_Schmidt_upt_k A k);\n                 k < ncols A\\<rbrakk>\n                \\<Longrightarrow> column j (Gram_Schmidt_upt_k A k) = 0;\n        j \\<le> mod_type_class.from_nat (Suc k);\n        column j (Gram_Schmidt_upt_k A (Suc k)) =\n        column i (Gram_Schmidt_upt_k A (Suc k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "case 0"], ["proof (state)\nthis:\n  j \\<le> mod_type_class.from_nat 0\n  column j (Gram_Schmidt_upt_k A 0) = column i (Gram_Schmidt_upt_k A 0)\n  0 < ncols A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j \\<le> mod_type_class.from_nat 0;\n     column j (Gram_Schmidt_upt_k A 0) = column i (Gram_Schmidt_upt_k A 0);\n     0 < ncols A\\<rbrakk>\n    \\<Longrightarrow> column j (Gram_Schmidt_upt_k A 0) = 0\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>j \\<le> mod_type_class.from_nat k;\n                 column j (Gram_Schmidt_upt_k A k) =\n                 column i (Gram_Schmidt_upt_k A k);\n                 k < ncols A\\<rbrakk>\n                \\<Longrightarrow> column j (Gram_Schmidt_upt_k A k) = 0;\n        j \\<le> mod_type_class.from_nat (Suc k);\n        column j (Gram_Schmidt_upt_k A (Suc k)) =\n        column i (Gram_Schmidt_upt_k A (Suc k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "thus ?case"], ["proof (prove)\nusing this:\n  j \\<le> mod_type_class.from_nat 0\n  column j (Gram_Schmidt_upt_k A 0) = column i (Gram_Schmidt_upt_k A 0)\n  0 < ncols A\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A 0) = 0", "using ij least_mod_type"], ["proof (prove)\nusing this:\n  j \\<le> mod_type_class.from_nat 0\n  column j (Gram_Schmidt_upt_k A 0) = column i (Gram_Schmidt_upt_k A 0)\n  0 < ncols A\n  i < j\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A 0) = 0", "unfolding from_nat_0"], ["proof (prove)\nusing this:\n  j \\<le> (0::'n)\n  column j (Gram_Schmidt_upt_k A 0) = column i (Gram_Schmidt_upt_k A 0)\n  0 < ncols A\n  i < j\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A 0) = 0", "by (metis (no_types) dual_order.strict_trans1 ij least_mod_type not_less)"], ["proof (state)\nthis:\n  column j (Gram_Schmidt_upt_k A 0) = 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>j \\<le> mod_type_class.from_nat k;\n                 column j (Gram_Schmidt_upt_k A k) =\n                 column i (Gram_Schmidt_upt_k A k);\n                 k < ncols A\\<rbrakk>\n                \\<Longrightarrow> column j (Gram_Schmidt_upt_k A k) = 0;\n        j \\<le> mod_type_class.from_nat (Suc k);\n        column j (Gram_Schmidt_upt_k A (Suc k)) =\n        column i (Gram_Schmidt_upt_k A (Suc k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>j \\<le> mod_type_class.from_nat k;\n                 column j (Gram_Schmidt_upt_k A k) =\n                 column i (Gram_Schmidt_upt_k A k);\n                 k < ncols A\\<rbrakk>\n                \\<Longrightarrow> column j (Gram_Schmidt_upt_k A k) = 0;\n        j \\<le> mod_type_class.from_nat (Suc k);\n        column j (Gram_Schmidt_upt_k A (Suc k)) =\n        column i (Gram_Schmidt_upt_k A (Suc k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>j \\<le> mod_type_class.from_nat k;\n   column j (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_upt_k A k);\n   k < ncols A\\<rbrakk>\n  \\<Longrightarrow> column j (Gram_Schmidt_upt_k A k) = 0\n  j \\<le> mod_type_class.from_nat (Suc k)\n  column j (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A (Suc k))\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>j \\<le> mod_type_class.from_nat k;\n                 column j (Gram_Schmidt_upt_k A k) =\n                 column i (Gram_Schmidt_upt_k A k);\n                 k < ncols A\\<rbrakk>\n                \\<Longrightarrow> column j (Gram_Schmidt_upt_k A k) = 0;\n        j \\<le> mod_type_class.from_nat (Suc k);\n        column j (Gram_Schmidt_upt_k A (Suc k)) =\n        column i (Gram_Schmidt_upt_k A (Suc k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "have k: \"k<ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols A", "using Suc.prems"], ["proof (prove)\nusing this:\n  j \\<le> mod_type_class.from_nat (Suc k)\n  column j (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A (Suc k))\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. k < ncols A", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  j \\<le> mod_type_class.from_nat (Suc k)\n  column j (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A (Suc k))\n  Suc k < CARD('n)\n\ngoal (1 subgoal):\n 1. k < CARD('n)", "by auto"], ["proof (state)\nthis:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>j \\<le> mod_type_class.from_nat k;\n                 column j (Gram_Schmidt_upt_k A k) =\n                 column i (Gram_Schmidt_upt_k A k);\n                 k < ncols A\\<rbrakk>\n                \\<Longrightarrow> column j (Gram_Schmidt_upt_k A k) = 0;\n        j \\<le> mod_type_class.from_nat (Suc k);\n        column j (Gram_Schmidt_upt_k A (Suc k)) =\n        column i (Gram_Schmidt_upt_k A (Suc k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "have i_not_k: \"i\\<noteq>from_nat (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc k)", "using ij Suc.prems"], ["proof (prove)\nusing this:\n  i < j\n  j \\<le> mod_type_class.from_nat (Suc k)\n  column j (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A (Suc k))\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc k)", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>j \\<le> mod_type_class.from_nat k;\n                 column j (Gram_Schmidt_upt_k A k) =\n                 column i (Gram_Schmidt_upt_k A k);\n                 k < ncols A\\<rbrakk>\n                \\<Longrightarrow> column j (Gram_Schmidt_upt_k A k) = 0;\n        j \\<le> mod_type_class.from_nat (Suc k);\n        column j (Gram_Schmidt_upt_k A (Suc k)) =\n        column i (Gram_Schmidt_upt_k A (Suc k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "have col_i_rw: \"column i (Gram_Schmidt_upt_k A (Suc k)) = column i (Gram_Schmidt_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (Suc k)) =\n    column i (Gram_Schmidt_upt_k A k)", "by (simp add: i_not_k Gram_Schmidt_column_k_def Gram_Schmidt_upt_k_suc column_def)"], ["proof (state)\nthis:\n  column i (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>j \\<le> mod_type_class.from_nat k;\n                 column j (Gram_Schmidt_upt_k A k) =\n                 column i (Gram_Schmidt_upt_k A k);\n                 k < ncols A\\<rbrakk>\n                \\<Longrightarrow> column j (Gram_Schmidt_upt_k A k) = 0;\n        j \\<le> mod_type_class.from_nat (Suc k);\n        column j (Gram_Schmidt_upt_k A (Suc k)) =\n        column i (Gram_Schmidt_upt_k A (Suc k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "have tn_fn_suc: \"to_nat (from_nat (Suc k)::'n) = Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "using to_nat_from_nat_id Suc.prems"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  j \\<le> mod_type_class.from_nat (Suc k)\n  column j (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A (Suc k))\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  j \\<le> mod_type_class.from_nat (Suc k)\n  column j (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A (Suc k))\n  Suc k < CARD('n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "by blast"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>j \\<le> mod_type_class.from_nat k;\n                 column j (Gram_Schmidt_upt_k A k) =\n                 column i (Gram_Schmidt_upt_k A k);\n                 k < ncols A\\<rbrakk>\n                \\<Longrightarrow> column j (Gram_Schmidt_upt_k A k) = 0;\n        j \\<le> mod_type_class.from_nat (Suc k);\n        column j (Gram_Schmidt_upt_k A (Suc k)) =\n        column i (Gram_Schmidt_upt_k A (Suc k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "proof (cases \"j=from_nat (Suc k)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0\n 2. j \\<noteq> mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "case False"], ["proof (state)\nthis:\n  j \\<noteq> mod_type_class.from_nat (Suc k)\n\ngoal (2 subgoals):\n 1. j = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0\n 2. j \\<noteq> mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "have jk: \"j \\<le> from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> mod_type_class.from_nat k", "by (metis False One_nat_def Suc.prems(1) add.right_neutral add_Suc_right\n        from_nat_suc le_Suc less_le linorder_not_le)"], ["proof (state)\nthis:\n  j \\<le> mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. j = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0\n 2. j \\<noteq> mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "have col_j_rw: \"column j (Gram_Schmidt_upt_k A (Suc k)) = column j (Gram_Schmidt_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (Suc k)) =\n    column j (Gram_Schmidt_upt_k A k)", "by (simp add: False Gram_Schmidt_column_k_def Gram_Schmidt_upt_k_suc column_def)"], ["proof (state)\nthis:\n  column j (Gram_Schmidt_upt_k A (Suc k)) =\n  column j (Gram_Schmidt_upt_k A k)\n\ngoal (2 subgoals):\n 1. j = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0\n 2. j \\<noteq> mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "have col_j_eq_col_i_k: \"column j (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_upt_k A k)", "using Suc.prems"], ["proof (prove)\nusing this:\n  j \\<le> mod_type_class.from_nat (Suc k)\n  column j (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A (Suc k))\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_upt_k A k)", "unfolding col_j_rw col_i_rw"], ["proof (prove)\nusing this:\n  j \\<le> mod_type_class.from_nat (Suc k)\n  column j (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_upt_k A k)\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_upt_k A k)", "by simp"], ["proof (state)\nthis:\n  column j (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_upt_k A k)\n\ngoal (2 subgoals):\n 1. j = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0\n 2. j \\<noteq> mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "using Suc.hyps col_j_eq_col_i_k k jk"], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<le> mod_type_class.from_nat k;\n   column j (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_upt_k A k);\n   k < ncols A\\<rbrakk>\n  \\<Longrightarrow> column j (Gram_Schmidt_upt_k A k) = 0\n  column j (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_upt_k A k)\n  k < ncols A\n  j \\<le> mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "unfolding col_j_rw"], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<le> mod_type_class.from_nat k;\n   column j (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_upt_k A k);\n   k < ncols A\\<rbrakk>\n  \\<Longrightarrow> column j (Gram_Schmidt_upt_k A k) = 0\n  column j (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_upt_k A k)\n  k < ncols A\n  j \\<le> mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A k) = 0", "by blast"], ["proof (state)\nthis:\n  column j (Gram_Schmidt_upt_k A (Suc k)) = 0\n\ngoal (1 subgoal):\n 1. j = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "case True"], ["proof (state)\nthis:\n  j = mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. j = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (Suc k)) = 0", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_upt_k A (Suc k)) =\n    0", "unfolding Gram_Schmidt_upt_k_suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    0", "proof (rule column_Gram_Schmidt_column_k_repeated_0(1)\n        [of i \"from_nat (Suc k)\" \"Gram_Schmidt_upt_k A k\", unfolded tn_fn_suc])"], ["proof (state)\ngoal (4 subgoals):\n 1. i \\<noteq> mod_type_class.from_nat (Suc k)\n 2. i < mod_type_class.from_nat (Suc k)\n 3. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n 4. pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A k) |i.\n      i < mod_type_class.from_nat (Suc k)}", "have set_rw: \"{column i (Gram_Schmidt_upt_k A k) |i. i < from_nat (Suc k)} \n        = {column i (Gram_Schmidt_upt_k A k) |i. to_nat i \\<le> k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A k) |i.\n     i < mod_type_class.from_nat (Suc k)} =\n    {column i (Gram_Schmidt_upt_k A k) |i. mod_type_class.to_nat i \\<le> k}", "by (metis (mono_tags, hide_lams) less_Suc_eq_le less_le not_less tn_fn_suc to_nat_mono)"], ["proof (state)\nthis:\n  {column i (Gram_Schmidt_upt_k A k) |i.\n   i < mod_type_class.from_nat (Suc k)} =\n  {column i (Gram_Schmidt_upt_k A k) |i. mod_type_class.to_nat i \\<le> k}\n\ngoal (4 subgoals):\n 1. i \\<noteq> mod_type_class.from_nat (Suc k)\n 2. i < mod_type_class.from_nat (Suc k)\n 3. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n 4. pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A k) |i.\n      i < mod_type_class.from_nat (Suc k)}", "show \"i \\<noteq> from_nat (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc k)", "using i_not_k"], ["proof (prove)\nusing this:\n  i \\<noteq> mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc k)", "."], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.from_nat (Suc k)\n\ngoal (3 subgoals):\n 1. i < mod_type_class.from_nat (Suc k)\n 2. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n 3. pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A k) |i.\n      i < mod_type_class.from_nat (Suc k)}", "show \"i < from_nat (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc k)", "using True ij"], ["proof (prove)\nusing this:\n  j = mod_type_class.from_nat (Suc k)\n  i < j\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc k)", "by blast"], ["proof (state)\nthis:\n  i < mod_type_class.from_nat (Suc k)\n\ngoal (2 subgoals):\n 1. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n 2. pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A k) |i.\n      i < mod_type_class.from_nat (Suc k)}", "show \"column (from_nat (Suc k)) (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n        column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))", "using Suc.prems True"], ["proof (prove)\nusing this:\n  j \\<le> mod_type_class.from_nat (Suc k)\n  column j (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A (Suc k))\n  Suc k < ncols A\n  j = mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))", "by (simp add: Gram_Schmidt_upt_k_suc)"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat (Suc k))\n   (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n  column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A k) |i.\n      i < mod_type_class.from_nat (Suc k)}", "show \"pairwise orthogonal {column i (Gram_Schmidt_upt_k A k) |i. i < from_nat (Suc k)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A k) |i.\n      i < mod_type_class.from_nat (Suc k)}", "unfolding set_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A k) |i. mod_type_class.to_nat i \\<le> k}", "by (rule orthogonal_Gram_Schmidt_upt_k[OF k])"], ["proof (state)\nthis:\n  pairwise orthogonal\n   {column i (Gram_Schmidt_upt_k A k) |i.\n    i < mod_type_class.from_nat (Suc k)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  column j (Gram_Schmidt_upt_k A (Suc k)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  column j (Gram_Schmidt_upt_k A (Suc k)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma column_Gram_Schmidt_upt_k_repeated_0:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes i_not_k: \"i\\<noteq>j\" and ij: \"i<j\" and j: \"j\\<le>k\"\n  and c_eq: \"column j (Gram_Schmidt_upt_k A (to_nat k)) \n  = column i (Gram_Schmidt_upt_k A (to_nat k))\"\n  shows \"column j (Gram_Schmidt_upt_k A (to_nat k)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "using assms column_Gram_Schmidt_upt_k_repeated_0' to_nat_less_card ncols_def"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i < j\n  j \\<le> k\n  column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n  column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k))\n  \\<lbrakk>?i \\<noteq> ?j; ?i < ?j; ?j \\<le> mod_type_class.from_nat ?k;\n   column ?j (Gram_Schmidt_upt_k ?A ?k) =\n   column ?i (Gram_Schmidt_upt_k ?A ?k);\n   ?k < ncols ?A\\<rbrakk>\n  \\<Longrightarrow> column ?j (Gram_Schmidt_upt_k ?A ?k) = 0\n  mod_type_class.to_nat ?j < CARD(?'a)\n  ncols ?A = CARD(?'columns)\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "by (metis c_eq column_Gram_Schmidt_upt_k_repeated_0' \n     from_nat_to_nat_id i_not_k ij j ncols_def to_nat_less_card)"], ["", "corollary column_Gram_Schmidt_upt_k_repeated:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes i_not_k: \"i\\<noteq>j\" and ij: \"i\\<le>k\" and \"j\\<le>k\"\n  and c_eq: \"column j (Gram_Schmidt_upt_k A (to_nat k)) \n    = column i (Gram_Schmidt_upt_k A (to_nat k))\"\n  shows \"column j (Gram_Schmidt_upt_k A (to_nat k)) = 0\" \n  and \"column i (Gram_Schmidt_upt_k A (to_nat k)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0 &&&\n    column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0\n 2. column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "show \"column j (Gram_Schmidt_upt_k A (to_nat k)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "proof (cases \"i<j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0\n 2. \\<not> i < j \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "case True"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0\n 2. \\<not> i < j \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "using assms column_Gram_Schmidt_upt_k_repeated_0"], ["proof (prove)\nusing this:\n  i < j\n  i \\<noteq> j\n  i \\<le> k\n  j \\<le> k\n  column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n  column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k))\n  \\<lbrakk>?i \\<noteq> ?j; ?i < ?j; ?j \\<le> ?k;\n   column ?j (Gram_Schmidt_upt_k ?A (mod_type_class.to_nat ?k)) =\n   column ?i (Gram_Schmidt_upt_k ?A (mod_type_class.to_nat ?k))\\<rbrakk>\n  \\<Longrightarrow> column ?j\n                     (Gram_Schmidt_upt_k ?A (mod_type_class.to_nat ?k)) =\n                    0\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "by metis"], ["proof (state)\nthis:\n  column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "case False"], ["proof (state)\nthis:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "hence ji: \"j<i\""], ["proof (prove)\nusing this:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. j < i", "using i_not_k"], ["proof (prove)\nusing this:\n  \\<not> i < j\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. j < i", "by auto"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "using assms column_Gram_Schmidt_upt_k_repeated_0"], ["proof (prove)\nusing this:\n  j < i\n  i \\<noteq> j\n  i \\<le> k\n  j \\<le> k\n  column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n  column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k))\n  \\<lbrakk>?i \\<noteq> ?j; ?i < ?j; ?j \\<le> ?k;\n   column ?j (Gram_Schmidt_upt_k ?A (mod_type_class.to_nat ?k)) =\n   column ?i (Gram_Schmidt_upt_k ?A (mod_type_class.to_nat ?k))\\<rbrakk>\n  \\<Longrightarrow> column ?j\n                     (Gram_Schmidt_upt_k ?A (mod_type_class.to_nat ?k)) =\n                    0\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "by metis"], ["proof (state)\nthis:\n  column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "show \"column i (Gram_Schmidt_upt_k A (to_nat k)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "proof (cases \"i<j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0\n 2. \\<not> i < j \\<Longrightarrow>\n    column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "case True"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0\n 2. \\<not> i < j \\<Longrightarrow>\n    column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "using assms column_Gram_Schmidt_upt_k_repeated_0"], ["proof (prove)\nusing this:\n  i < j\n  i \\<noteq> j\n  i \\<le> k\n  j \\<le> k\n  column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n  column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k))\n  \\<lbrakk>?i \\<noteq> ?j; ?i < ?j; ?j \\<le> ?k;\n   column ?j (Gram_Schmidt_upt_k ?A (mod_type_class.to_nat ?k)) =\n   column ?i (Gram_Schmidt_upt_k ?A (mod_type_class.to_nat ?k))\\<rbrakk>\n  \\<Longrightarrow> column ?j\n                     (Gram_Schmidt_upt_k ?A (mod_type_class.to_nat ?k)) =\n                    0\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "by metis"], ["proof (state)\nthis:\n  column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "case False"], ["proof (state)\nthis:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "hence ji: \"j<i\""], ["proof (prove)\nusing this:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. j < i", "using i_not_k"], ["proof (prove)\nusing this:\n  \\<not> i < j\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. j < i", "by auto"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "using assms column_Gram_Schmidt_upt_k_repeated_0"], ["proof (prove)\nusing this:\n  j < i\n  i \\<noteq> j\n  i \\<le> k\n  j \\<le> k\n  column j (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n  column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k))\n  \\<lbrakk>?i \\<noteq> ?j; ?i < ?j; ?j \\<le> ?k;\n   column ?j (Gram_Schmidt_upt_k ?A (mod_type_class.to_nat ?k)) =\n   column ?i (Gram_Schmidt_upt_k ?A (mod_type_class.to_nat ?k))\\<rbrakk>\n  \\<Longrightarrow> column ?j\n                     (Gram_Schmidt_upt_k ?A (mod_type_class.to_nat ?k)) =\n                    0\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0", "by metis"], ["proof (state)\nthis:\n  column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma column_Gram_Schmidt_column_k_eq_efficient:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"Gram_Schmidt_upt_k A k = foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]\"\n  and suc_k: \"Suc k < ncols A\"\n  shows \"column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n  = column b (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "proof (cases \"b = from_nat (Suc k)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))\n 2. b \\<noteq> mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "case False"], ["proof (state)\nthis:\n  b \\<noteq> mod_type_class.from_nat (Suc k)\n\ngoal (2 subgoals):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))\n 2. b \\<noteq> mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<noteq> mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "unfolding Gram_Schmidt_column_k_efficient_def Gram_Schmidt_column_k_def column_def"], ["proof (prove)\nusing this:\n  b \\<noteq> mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat (Suc k)\n             then (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) -\n                  proj_onto (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b)\n                   {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i. i < b}\n             else \\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) $\n            a) $\n        i $\n        b) =\n    (\\<chi>i.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat (Suc k)\n             then (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) -\n                  (\\<Sum>x\\<leftarrow>map\n (\\<lambda>n.\n     \\<chi>i. Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat n)\n [0..<\n  mod_type_class.to_nat\n   b]. ((\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) \\<bullet> x /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)\n             else \\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) $\n            a) $\n        i $\n        b)", "by auto"], ["proof (state)\nthis:\n  column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n  column b\n   (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))\n\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "case True"], ["proof (state)\nthis:\n  b = mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "have tn_fn_suc: \"to_nat (from_nat (Suc k)::'n) = Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "using suc_k to_nat_from_nat_id"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('n)\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k\n\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "define G where\"G = Gram_Schmidt_upt_k A k\""], ["proof (state)\nthis:\n  G = Gram_Schmidt_upt_k A k\n\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "let ?f=\"(\\<lambda>x. (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "let ?g=\"(\\<lambda>n. column (from_nat n) G) \""], ["proof (state)\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "have proj_eq: \"proj_onto (column b G) {column i G |i. i < b} \n    = sum_list (map ?f (map ?g [0..<to_nat b]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_onto (column b G) {column i G |i. i < b} =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_onto (column b G) {column i G |i. i < b} =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", "have \"proj_onto (column b G) {column i G |i. i < b} = sum ?f {column i G |i. i < b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_onto (column b G) {column i G |i. i < b} =\n    (\\<Sum>x\\<in>{column i G |i. i < b}.\n       (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>{column i G |i. i < b}.\n       (column b G \\<bullet> u / (u \\<bullet> u)) *\\<^sub>R u) =\n    (\\<Sum>x\\<in>{column i G |i. i < b}.\n       (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)", "by simp"], ["proof (state)\nthis:\n  proj_onto (column b G) {column i G |i. i < b} =\n  (\\<Sum>x\\<in>{column i G |i. i < b}.\n     (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. proj_onto (column b G) {column i G |i. i < b} =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", "also"], ["proof (state)\nthis:\n  proj_onto (column b G) {column i G |i. i < b} =\n  (\\<Sum>x\\<in>{column i G |i. i < b}.\n     (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. proj_onto (column b G) {column i G |i. i < b} =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", "have \"... = sum ?f (set (map ?g [0..<to_nat b]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{column i G |i. i < b}.\n       (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x) =\n    (\\<Sum>x\\<in>set (map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                       [0..<mod_type_class.to_nat b]).\n       (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)", "by (rule sum.cong, auto simp add: set_map_column[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{column i G |i. i < b}.\n     (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x) =\n  (\\<Sum>x\\<in>set (map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                     [0..<mod_type_class.to_nat b]).\n     (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. proj_onto (column b G) {column i G |i. i < b} =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{column i G |i. i < b}.\n     (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x) =\n  (\\<Sum>x\\<in>set (map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                     [0..<mod_type_class.to_nat b]).\n     (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. proj_onto (column b G) {column i G |i. i < b} =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", "have \"... = sum_list (map ?f (remdups (map ?g [0..<to_nat b])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                       [0..<mod_type_class.to_nat b]).\n       (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x) =\n    (\\<Sum>x\\<leftarrow>remdups\n                         (map (\\<lambda>n.\n                                  column (mod_type_class.from_nat n) G)\n                           [0..<\n                            mod_type_class.to_nat\n                             b]). (column b G \\<bullet> x /\n                                   (x \\<bullet> x)) *\\<^sub>R\n                                  x)", "unfolding sum_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>remdups\n                         (map (\\<lambda>n.\n                                  column (mod_type_class.from_nat n) G)\n                           [0..<\n                            mod_type_class.to_nat\n                             b]). (column b G \\<bullet> x /\n                                   (x \\<bullet> x)) *\\<^sub>R\n                                  x) =\n    (\\<Sum>x\\<leftarrow>remdups\n                         (map (\\<lambda>n.\n                                  column (mod_type_class.from_nat n) G)\n                           [0..<\n                            mod_type_class.to_nat\n                             b]). (column b G \\<bullet> x /\n                                   (x \\<bullet> x)) *\\<^sub>R\n                                  x)", ".."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                     [0..<mod_type_class.to_nat b]).\n     (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x) =\n  (\\<Sum>x\\<leftarrow>remdups\n                       (map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]). (column b G \\<bullet> x /\n                                 (x \\<bullet> x)) *\\<^sub>R\n                                x)\n\ngoal (1 subgoal):\n 1. proj_onto (column b G) {column i G |i. i < b} =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                     [0..<mod_type_class.to_nat b]).\n     (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x) =\n  (\\<Sum>x\\<leftarrow>remdups\n                       (map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]). (column b G \\<bullet> x /\n                                 (x \\<bullet> x)) *\\<^sub>R\n                                x)\n\ngoal (1 subgoal):\n 1. proj_onto (column b G) {column i G |i. i < b} =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", "have \"... = sum_list ((map ?f ((map ?g [0..<to_nat b]))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>remdups\n                         (map (\\<lambda>n.\n                                  column (mod_type_class.from_nat n) G)\n                           [0..<\n                            mod_type_class.to_nat\n                             b]). (column b G \\<bullet> x /\n                                   (x \\<bullet> x)) *\\<^sub>R\n                                  x) =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", "proof (rule sum_list_remdups_2, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < mod_type_class.to_nat b; j < mod_type_class.to_nat b;\n        i \\<noteq> j;\n        column (mod_type_class.from_nat i) G =\n        column (mod_type_class.from_nat j) G;\n        column (mod_type_class.from_nat j) G \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> column b G \\<bullet>\n                         column (mod_type_class.from_nat j) G =\n                         0", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < mod_type_class.to_nat b; j < mod_type_class.to_nat b;\n        i \\<noteq> j;\n        column (mod_type_class.from_nat i) G =\n        column (mod_type_class.from_nat j) G;\n        column (mod_type_class.from_nat j) G \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> column b G \\<bullet>\n                         column (mod_type_class.from_nat j) G =\n                         0", "assume i: \"i < to_nat b\"\n        and j: \"j < to_nat b\" and ij: \"i \\<noteq> j\"\n        and col_eq: \"column (from_nat i) G = column (from_nat j) G\"\n        and col_0: \"column (from_nat j) G \\<noteq> 0\""], ["proof (state)\nthis:\n  i < mod_type_class.to_nat b\n  j < mod_type_class.to_nat b\n  i \\<noteq> j\n  column (mod_type_class.from_nat i) G =\n  column (mod_type_class.from_nat j) G\n  column (mod_type_class.from_nat j) G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < mod_type_class.to_nat b; j < mod_type_class.to_nat b;\n        i \\<noteq> j;\n        column (mod_type_class.from_nat i) G =\n        column (mod_type_class.from_nat j) G;\n        column (mod_type_class.from_nat j) G \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> column b G \\<bullet>\n                         column (mod_type_class.from_nat j) G =\n                         0", "have k: \"to_nat (from_nat k::'n) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat k) = k", "by (metis Suc_lessD ncols_def suc_k to_nat_from_nat_id)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat k) = k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < mod_type_class.to_nat b; j < mod_type_class.to_nat b;\n        i \\<noteq> j;\n        column (mod_type_class.from_nat i) G =\n        column (mod_type_class.from_nat j) G;\n        column (mod_type_class.from_nat j) G \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> column b G \\<bullet>\n                         column (mod_type_class.from_nat j) G =\n                         0", "have \"column (from_nat j) G = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat j) G = 0", "proof (unfold G_def, rule column_Gram_Schmidt_upt_k_repeated(1)\n          [of \"(from_nat i)::'n\" \"from_nat j\" \"from_nat k\" A, unfolded k])"], ["proof (state)\ngoal (4 subgoals):\n 1. mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat j\n 2. mod_type_class.from_nat i \\<le> mod_type_class.from_nat k\n 3. mod_type_class.from_nat j \\<le> mod_type_class.from_nat k\n 4. column (mod_type_class.from_nat j) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)", "have \"from_nat i < (from_nat (Suc k)::'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat (Suc k)", "using from_nat_mono[of i \"Suc k\"] suc_k i"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < Suc k; Suc k < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat i\n                    < mod_type_class.from_nat (Suc k)\n  Suc k < ncols A\n  i < mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat (Suc k)", "unfolding True tn_fn_suc ncols_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < Suc k; Suc k < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat i\n                    < mod_type_class.from_nat (Suc k)\n  Suc k < CARD('n)\n  i < Suc k\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i < mod_type_class.from_nat (Suc k)", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat i < mod_type_class.from_nat (Suc k)\n\ngoal (4 subgoals):\n 1. mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat j\n 2. mod_type_class.from_nat i \\<le> mod_type_class.from_nat k\n 3. mod_type_class.from_nat j \\<le> mod_type_class.from_nat k\n 4. column (mod_type_class.from_nat j) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)", "thus \"from_nat i \\<le> (from_nat k::'n)\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> mod_type_class.from_nat k", "by (metis Suc_lessD True from_nat_mono' i less_Suc_eq_le ncols_def suc_k tn_fn_suc)"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> mod_type_class.from_nat k\n\ngoal (3 subgoals):\n 1. mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat j\n 2. mod_type_class.from_nat j \\<le> mod_type_class.from_nat k\n 3. column (mod_type_class.from_nat j) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)", "have \"from_nat j < (from_nat (Suc k)::'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat j < mod_type_class.from_nat (Suc k)", "using from_nat_mono[of j \"Suc k\"] suc_k j"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < Suc k; Suc k < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat j\n                    < mod_type_class.from_nat (Suc k)\n  Suc k < ncols A\n  j < mod_type_class.to_nat b\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat j < mod_type_class.from_nat (Suc k)", "unfolding True tn_fn_suc ncols_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < Suc k; Suc k < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat j\n                    < mod_type_class.from_nat (Suc k)\n  Suc k < CARD('n)\n  j < Suc k\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat j < mod_type_class.from_nat (Suc k)", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat j < mod_type_class.from_nat (Suc k)\n\ngoal (3 subgoals):\n 1. mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat j\n 2. mod_type_class.from_nat j \\<le> mod_type_class.from_nat k\n 3. column (mod_type_class.from_nat j) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)", "thus \"from_nat j \\<le> (from_nat k::'n)\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat j < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat j \\<le> mod_type_class.from_nat k", "by (metis Suc_lessD True from_nat_mono' j less_Suc_eq_le ncols_def suc_k tn_fn_suc)"], ["proof (state)\nthis:\n  mod_type_class.from_nat j \\<le> mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat j\n 2. column (mod_type_class.from_nat j) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)", "show \"from_nat i \\<noteq> (from_nat j::'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat j", "using ij i j True suc_k"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i < mod_type_class.to_nat b\n  j < mod_type_class.to_nat b\n  b = mod_type_class.from_nat (Suc k)\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat j", "by (metis (no_types, lifting) dual_order.strict_trans from_nat_eq_imp_eq ncols_def tn_fn_suc)"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat j\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat j) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)", "show \"column (from_nat j) (Gram_Schmidt_upt_k A k) \n          = column (from_nat i) (Gram_Schmidt_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat j) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)", "using G_def col_eq"], ["proof (prove)\nusing this:\n  G = Gram_Schmidt_upt_k A k\n  column (mod_type_class.from_nat i) G =\n  column (mod_type_class.from_nat j) G\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat j) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)", "by auto"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat j) (Gram_Schmidt_upt_k A k) =\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat j) G = 0\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < mod_type_class.to_nat b; j < mod_type_class.to_nat b;\n        i \\<noteq> j;\n        column (mod_type_class.from_nat i) G =\n        column (mod_type_class.from_nat j) G;\n        column (mod_type_class.from_nat j) G \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> column b G \\<bullet>\n                         column (mod_type_class.from_nat j) G =\n                         0", "thus \"column b G \\<bullet> column (from_nat j) G = 0\""], ["proof (prove)\nusing this:\n  column (mod_type_class.from_nat j) G = 0\n\ngoal (1 subgoal):\n 1. column b G \\<bullet> column (mod_type_class.from_nat j) G = 0", "using col_0"], ["proof (prove)\nusing this:\n  column (mod_type_class.from_nat j) G = 0\n  column (mod_type_class.from_nat j) G \\<noteq> 0\n\ngoal (1 subgoal):\n 1. column b G \\<bullet> column (mod_type_class.from_nat j) G = 0", "by contradiction"], ["proof (state)\nthis:\n  column b G \\<bullet> column (mod_type_class.from_nat j) G = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>remdups\n                       (map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]). (column b G \\<bullet> x /\n                                 (x \\<bullet> x)) *\\<^sub>R\n                                x) =\n  (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                       [0..<\n                        mod_type_class.to_nat\n                         b]. (column b G \\<bullet> x /\n                              (x \\<bullet> x)) *\\<^sub>R\n                             x)\n\ngoal (1 subgoal):\n 1. proj_onto (column b G) {column i G |i. i < b} =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", "finally"], ["proof (chain)\npicking this:\n  proj_onto (column b G) {column i G |i. i < b} =\n  (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                       [0..<\n                        mod_type_class.to_nat\n                         b]. (column b G \\<bullet> x /\n                              (x \\<bullet> x)) *\\<^sub>R\n                             x)", "show ?thesis"], ["proof (prove)\nusing this:\n  proj_onto (column b G) {column i G |i. i < b} =\n  (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                       [0..<\n                        mod_type_class.to_nat\n                         b]. (column b G \\<bullet> x /\n                              (x \\<bullet> x)) *\\<^sub>R\n                             x)\n\ngoal (1 subgoal):\n 1. proj_onto (column b G) {column i G |i. i < b} =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", "."], ["proof (state)\nthis:\n  proj_onto (column b G) {column i G |i. i < b} =\n  (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                       [0..<\n                        mod_type_class.to_nat\n                         b]. (column b G \\<bullet> x /\n                              (x \\<bullet> x)) *\\<^sub>R\n                             x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj_onto (column b G) {column i G |i. i < b} =\n  (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                       [0..<\n                        mod_type_class.to_nat\n                         b]. (column b G \\<bullet> x /\n                              (x \\<bullet> x)) *\\<^sub>R\n                             x)\n\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "have \"column b (Gram_Schmidt_column_k G (Suc k)) \n    = column b G - proj_onto (column b G) {column i G |i. i < b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column b (Gram_Schmidt_column_k G (Suc k)) =\n    column b G - proj_onto (column b G) {column i G |i. i < b}", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k G (Suc k)) =\n    column (mod_type_class.from_nat (Suc k)) G -\n    proj_onto (column (mod_type_class.from_nat (Suc k)) G)\n     {column i G |i. i < mod_type_class.from_nat (Suc k)}", "unfolding Gram_Schmidt_column_k_def G_def column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat (Suc k)\n             then (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) -\n                  proj_onto (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b)\n                   {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i. i < b}\n             else \\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) $\n            a) $\n        i $\n        mod_type_class.from_nat (Suc k)) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    proj_onto\n     (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k))\n     {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n      i < mod_type_class.from_nat (Suc k)}", "by vector"], ["proof (state)\nthis:\n  column b (Gram_Schmidt_column_k G (Suc k)) =\n  column b G - proj_onto (column b G) {column i G |i. i < b}\n\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "also"], ["proof (state)\nthis:\n  column b (Gram_Schmidt_column_k G (Suc k)) =\n  column b G - proj_onto (column b G) {column i G |i. i < b}\n\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "have \"... = column b G \n    - (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column (from_nat n) G) [0..<to_nat b]. (column b G \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column b G - proj_onto (column b G) {column i G |i. i < b} =\n    column b G -\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", "unfolding proj_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. column b G -\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x) =\n    column b G -\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x)", ".."], ["proof (state)\nthis:\n  column b G - proj_onto (column b G) {column i G |i. i < b} =\n  column b G -\n  (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                       [0..<\n                        mod_type_class.to_nat\n                         b]. (column b G \\<bullet> x /\n                              (x \\<bullet> x)) *\\<^sub>R\n                             x)\n\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "also"], ["proof (state)\nthis:\n  column b G - proj_onto (column b G) {column i G |i. i < b} =\n  column b G -\n  (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                       [0..<\n                        mod_type_class.to_nat\n                         b]. (column b G \\<bullet> x /\n                              (x \\<bullet> x)) *\\<^sub>R\n                             x)\n\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "have \"... = column b (Gram_Schmidt_column_k_efficient G (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column b G -\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                column (mod_type_class.from_nat n) G)\n                         [0..<\n                          mod_type_class.to_nat\n                           b]. (column b G \\<bullet> x /\n                                (x \\<bullet> x)) *\\<^sub>R\n                               x) =\n    column b (Gram_Schmidt_column_k_efficient G (Suc k))", "unfolding True Gram_Schmidt_column_k_efficient_def G_def column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n                                \\<chi>i.\n                                   Gram_Schmidt_upt_k A k $ i $\n                                   mod_type_class.from_nat n)\n                         [0..<\n                          mod_type_class.to_nat\n                           (mod_type_class.from_nat\n                             (Suc k))]. ((\\<chi>i.\n       Gram_Schmidt_upt_k A k $ i $\n       mod_type_class.from_nat (Suc k)) \\<bullet>\n   x /\n   (x \\<bullet> x)) *\\<^sub>R\n  x) =\n    (\\<chi>i.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat (Suc k)\n             then (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) -\n                  (\\<Sum>x\\<leftarrow>map\n (\\<lambda>n.\n     \\<chi>i. Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat n)\n [0..<\n  mod_type_class.to_nat\n   b]. ((\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) \\<bullet> x /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)\n             else \\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) $\n            a) $\n        i $\n        mod_type_class.from_nat (Suc k))", "by vector"], ["proof (state)\nthis:\n  column b G -\n  (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column (mod_type_class.from_nat n) G)\n                       [0..<\n                        mod_type_class.to_nat\n                         b]. (column b G \\<bullet> x /\n                              (x \\<bullet> x)) *\\<^sub>R\n                             x) =\n  column b (Gram_Schmidt_column_k_efficient G (Suc k))\n\ngoal (1 subgoal):\n 1. b = mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n    column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "finally"], ["proof (chain)\npicking this:\n  column b (Gram_Schmidt_column_k G (Suc k)) =\n  column b (Gram_Schmidt_column_k_efficient G (Suc k))", "show ?thesis"], ["proof (prove)\nusing this:\n  column b (Gram_Schmidt_column_k G (Suc k)) =\n  column b (Gram_Schmidt_column_k_efficient G (Suc k))\n\ngoal (1 subgoal):\n 1. column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "unfolding G_def"], ["proof (prove)\nusing this:\n  column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n  column b\n   (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))\n\ngoal (1 subgoal):\n 1. column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column b\n     (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))", "."], ["proof (state)\nthis:\n  column b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n  column b\n   (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gram_Schmidt_upt_k_efficient_induction:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"Gram_Schmidt_upt_k A k = foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]\"\n  and suc_k: \"Suc k < ncols A\"\n  shows \"Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k) \n  = Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k) =\n    Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k)", "using column_Gram_Schmidt_column_k_eq_efficient[OF assms]"], ["proof (prove)\nusing this:\n  column ?b (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n  column ?b\n   (Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k))\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k) =\n    Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k)", "unfolding column_def vec_eq_iff"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (\\<chi>i.\n         Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k) $ i $ ?b) $\n     i =\n     (\\<chi>i.\n         Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k) $\n         i $\n         ?b) $\n     i\n\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k) $ i $ ia =\n       Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k) $\n       i $\n       ia", "by vector"], ["", "lemma Gram_Schmidt_upt_k_efficient:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\" \n  assumes k: \"k<ncols A\"\n  shows \"Gram_Schmidt_upt_k A k = foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A k =\n    foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]", "using k"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A k =\n    foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    Gram_Schmidt_upt_k A 0 =\n    foldl Gram_Schmidt_column_k_efficient A [0..<Suc 0]\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "case 0"], ["proof (state)\nthis:\n  0 < ncols A\n\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    Gram_Schmidt_upt_k A 0 =\n    foldl Gram_Schmidt_column_k_efficient A [0..<Suc 0]\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "have \" {column i A |i. i < 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i A |i. i < (0::'n)} = {}", "using least_mod_type"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. {column i A |i. i < (0::'n)} = {}", "using leD"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> ?n\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n\ngoal (1 subgoal):\n 1. {column i A |i. i < (0::'n)} = {}", "by auto"], ["proof (state)\nthis:\n  {column i A |i. i < (0::'n)} = {}\n\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    Gram_Schmidt_upt_k A 0 =\n    foldl Gram_Schmidt_column_k_efficient A [0..<Suc 0]\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "thus ?case"], ["proof (prove)\nusing this:\n  {column i A |i. i < (0::'n)} = {}\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A 0 =\n    foldl Gram_Schmidt_column_k_efficient A [0..<Suc 0]", "by (simp, auto simp add: Gram_Schmidt_column_k_efficient_def \n      Gram_Schmidt_upt_k_def Gram_Schmidt_column_k_def \n      proj_onto_def proj_def vec_eq_iff from_nat_0 to_nat_0)"], ["proof (state)\nthis:\n  Gram_Schmidt_upt_k A 0 =\n  foldl Gram_Schmidt_column_k_efficient A [0..<Suc 0]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "case (Suc k)"], ["proof (state)\nthis:\n  k < ncols A \\<Longrightarrow>\n  Gram_Schmidt_upt_k A k =\n  foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "have \"Gram_Schmidt_upt_k A (Suc k) = Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A (Suc k) =\n    Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)", "by (rule Gram_Schmidt_upt_k_suc)"], ["proof (state)\nthis:\n  Gram_Schmidt_upt_k A (Suc k) =\n  Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "also"], ["proof (state)\nthis:\n  Gram_Schmidt_upt_k A (Suc k) =\n  Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "have \"... = Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k) =\n    Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k)", "proof (rule Gram_Schmidt_upt_k_efficient_induction)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gram_Schmidt_upt_k A k =\n    foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]\n 2. Suc k < ncols A", "show \"Gram_Schmidt_upt_k A k = foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A k =\n    foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]", "using Suc.hyps Suc.prems"], ["proof (prove)\nusing this:\n  k < ncols A \\<Longrightarrow>\n  Gram_Schmidt_upt_k A k =\n  foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A k =\n    foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]", "by auto"], ["proof (state)\nthis:\n  Gram_Schmidt_upt_k A k =\n  foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]\n\ngoal (1 subgoal):\n 1. Suc k < ncols A", "show \"Suc k < ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k < ncols A", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. Suc k < ncols A", "by auto"], ["proof (state)\nthis:\n  Suc k < ncols A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k) =\n  Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "also"], ["proof (state)\nthis:\n  Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k) =\n  Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "have \"... = Gram_Schmidt_column_k_efficient\n    (foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]) (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k) =\n    Gram_Schmidt_column_k_efficient\n     (foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]) (Suc k)", "using Suc.hyps Suc.prems"], ["proof (prove)\nusing this:\n  k < ncols A \\<Longrightarrow>\n  Gram_Schmidt_upt_k A k =\n  foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k) =\n    Gram_Schmidt_column_k_efficient\n     (foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]) (Suc k)", "by auto"], ["proof (state)\nthis:\n  Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k) =\n  Gram_Schmidt_column_k_efficient\n   (foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]) (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "also"], ["proof (state)\nthis:\n  Gram_Schmidt_column_k_efficient (Gram_Schmidt_upt_k A k) (Suc k) =\n  Gram_Schmidt_column_k_efficient\n   (foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]) (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "have \"... = (foldl Gram_Schmidt_column_k_efficient A [0..<Suc (Suc k)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k_efficient\n     (foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]) (Suc k) =\n    foldl Gram_Schmidt_column_k_efficient A [0..<Suc (Suc k)]", "by auto"], ["proof (state)\nthis:\n  Gram_Schmidt_column_k_efficient\n   (foldl Gram_Schmidt_column_k_efficient A [0..<Suc k]) (Suc k) =\n  foldl Gram_Schmidt_column_k_efficient A [0..<Suc (Suc k)]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                Gram_Schmidt_upt_k A k =\n                foldl Gram_Schmidt_column_k_efficient A [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> Gram_Schmidt_upt_k A (Suc k) =\n                         foldl Gram_Schmidt_column_k_efficient A\n                          [0..<Suc (Suc k)]", "finally"], ["proof (chain)\npicking this:\n  Gram_Schmidt_upt_k A (Suc k) =\n  foldl Gram_Schmidt_column_k_efficient A [0..<Suc (Suc k)]", "show ?case"], ["proof (prove)\nusing this:\n  Gram_Schmidt_upt_k A (Suc k) =\n  foldl Gram_Schmidt_column_k_efficient A [0..<Suc (Suc k)]\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A (Suc k) =\n    foldl Gram_Schmidt_column_k_efficient A [0..<Suc (Suc k)]", "."], ["proof (state)\nthis:\n  Gram_Schmidt_upt_k A (Suc k) =\n  foldl Gram_Schmidt_column_k_efficient A [0..<Suc (Suc k)]\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>This equation is now more efficient than the original definition of the algoritm, since it is not\n  removing duplicates in each iteration, which is more expensive in time than adding zeros (if there appear \n  duplicates while applying the algorithm, they are zeros and then the @{const sum_list} is the same in each step).\\<close>"], ["", "lemma Gram_Schmidt_matrix_efficient[code_unfold]:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\" \n  shows \"Gram_Schmidt_matrix A = foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_matrix A =\n    foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gram_Schmidt_matrix A =\n    foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]", "have n: \"(ncols A - 1) < ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols A - 1 < ncols A", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('n) - 1 < CARD('n)", "by auto"], ["proof (state)\nthis:\n  ncols A - 1 < ncols A\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_matrix A =\n    foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]", "have \"Gram_Schmidt_matrix A = Gram_Schmidt_upt_k A (ncols A - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_matrix A = Gram_Schmidt_upt_k A (ncols A - 1)", "unfolding Gram_Schmidt_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A (ncols A - 1) = Gram_Schmidt_upt_k A (ncols A - 1)", ".."], ["proof (state)\nthis:\n  Gram_Schmidt_matrix A = Gram_Schmidt_upt_k A (ncols A - 1)\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_matrix A =\n    foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]", "also"], ["proof (state)\nthis:\n  Gram_Schmidt_matrix A = Gram_Schmidt_upt_k A (ncols A - 1)\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_matrix A =\n    foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]", "have \"... = foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A (ncols A - 1) =\n    foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]", "using Gram_Schmidt_upt_k_efficient[OF n]"], ["proof (prove)\nusing this:\n  Gram_Schmidt_upt_k A (ncols A - 1) =\n  foldl Gram_Schmidt_column_k_efficient A [0..<Suc (ncols A - 1)]\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A (ncols A - 1) =\n    foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Gram_Schmidt_upt_k A (CARD('n) - 1) =\n  foldl Gram_Schmidt_column_k_efficient A [0..<Suc (CARD('n) - 1)]\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A (CARD('n) - 1) =\n    foldl Gram_Schmidt_column_k_efficient A [0..<CARD('n)]", "by auto"], ["proof (state)\nthis:\n  Gram_Schmidt_upt_k A (ncols A - 1) =\n  foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_matrix A =\n    foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]", "finally"], ["proof (chain)\npicking this:\n  Gram_Schmidt_matrix A =\n  foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]", "show ?thesis"], ["proof (prove)\nusing this:\n  Gram_Schmidt_matrix A =\n  foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_matrix A =\n    foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]", "."], ["proof (state)\nthis:\n  Gram_Schmidt_matrix A =\n  foldl Gram_Schmidt_column_k_efficient A [0..<ncols A]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Improvements for computing the Gram Schmidt algorithm and QR decomposition \n  using immutable arrays\\<close>"], ["", "subsubsection\\<open>New definitions\\<close>"], ["", "definition \"Gram_Schmidt_column_k_iarrays_efficient A k = \n  tabulate2 (nrows_iarray A) (ncols_iarray A) (\\<lambda>a b. let column_b_A = column_iarray b A in \n  (if b = k then (column_b_A - sum_list (map (\\<lambda>x. ((column_b_A \\<bullet>i x) / (x \\<bullet>i x)) *\\<^sub>R x) \n  ((List.map (\\<lambda>n. column_iarray n A) [0..<b]))))\n  else column_b_A) !! a)\""], ["", "definition \"Gram_Schmidt_matrix_iarrays_efficient A \n  = foldl Gram_Schmidt_column_k_iarrays_efficient A [0..<ncols_iarray A]\""], ["", "definition \"QR_decomposition_iarrays_efficient A = \n  (let Q = divide_by_norm_iarray (Gram_Schmidt_matrix_iarrays_efficient A) \n  in (Q, transpose_iarray Q **i A))\""], ["", "subsubsection\\<open>General properties\\<close>"], ["", "lemma tabulate2_nth:\n  assumes i: \"i<nr\" and j: \"j<nc\"\n  shows \"(tabulate2 nr nc f) !! i !! j = f i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tabulate2 nr nc f !! i !! j = f i j", "unfolding tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. IArray.of_fun (f i) nc) nr !! i !! j = f i j", "using i j nth_map"], ["proof (prove)\nusing this:\n  i < nr\n  j < nc\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. IArray.of_fun (f i) nc) nr !! i !! j = f i j", "by auto"], ["", "lemma vec_to_iarray_minus[code_unfold]: \n  \"vec_to_iarray (a - b) =  (vec_to_iarray a) - (vec_to_iarray b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (a - b) = vec_to_iarray a - vec_to_iarray b", "unfolding vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. (a - b) $ mod_type_class.from_nat i)\n     CARD('b) =\n    IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i) CARD('b) -\n    IArray.of_fun (\\<lambda>i. b $ mod_type_class.from_nat i) CARD('b)", "unfolding minus_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. (a - b) $ mod_type_class.from_nat i)\n     CARD('b) =\n    IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>aa.\n              if aa < IArray.length\n                       (IArray.of_fun\n                         (\\<lambda>i. a $ mod_type_class.from_nat i)\n                         CARD('b))\n              then IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i)\n                    CARD('b) !!\n                   aa\n              else (0::'a))\n          (max (IArray.length\n                 (IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i)\n                   CARD('b)))\n            (IArray.length\n              (IArray.of_fun (\\<lambda>i. b $ mod_type_class.from_nat i)\n                CARD('b)))) !!\n         aa -\n         IArray.of_fun\n          (\\<lambda>a.\n              if a < IArray.length\n                      (IArray.of_fun\n                        (\\<lambda>i. b $ mod_type_class.from_nat i)\n                        CARD('b))\n              then IArray.of_fun (\\<lambda>i. b $ mod_type_class.from_nat i)\n                    CARD('b) !!\n                   a\n              else (0::'a))\n          (max (IArray.length\n                 (IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i)\n                   CARD('b)))\n            (IArray.length\n              (IArray.of_fun (\\<lambda>i. b $ mod_type_class.from_nat i)\n                CARD('b)))) !!\n         aa)\n     (max (IArray.length\n            (IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i)\n              CARD('b)))\n       (IArray.length\n         (IArray.of_fun (\\<lambda>i. b $ mod_type_class.from_nat i)\n           CARD('b))))", "by auto"], ["", "lemma vec_to_iarray_minus_nth:\n  assumes A: \"i<IArray.length (vec_to_iarray A)\" \n  and B: \"i<IArray.length (vec_to_iarray B)\"\n  shows \"(vec_to_iarray A - vec_to_iarray B) !! i \n  = vec_to_iarray A !! i - vec_to_iarray B !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "have i: \"i<CARD('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < CARD('b)", "using A"], ["proof (prove)\nusing this:\n  i < IArray.length (vec_to_iarray A)\n\ngoal (1 subgoal):\n 1. i < CARD('b)", "unfolding vec_to_iarray_def"], ["proof (prove)\nusing this:\n  i < IArray.length\n       (IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i) CARD('b))\n\ngoal (1 subgoal):\n 1. i < CARD('b)", "by auto"], ["proof (state)\nthis:\n  i < CARD('b)\n\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "have i2: \"i<CARD('c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < CARD('c)", "using B"], ["proof (prove)\nusing this:\n  i < IArray.length (vec_to_iarray B)\n\ngoal (1 subgoal):\n 1. i < CARD('c)", "unfolding vec_to_iarray_def"], ["proof (prove)\nusing this:\n  i < IArray.length\n       (IArray.of_fun (\\<lambda>i. B $ mod_type_class.from_nat i) CARD('c))\n\ngoal (1 subgoal):\n 1. i < CARD('c)", "by auto"], ["proof (state)\nthis:\n  i < CARD('c)\n\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "have i_length: \"i < length [0..<max CARD('b) CARD('c)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length [0..<max CARD('b) CARD('c)]", "using i i2"], ["proof (prove)\nusing this:\n  i < CARD('b)\n  i < CARD('c)\n\ngoal (1 subgoal):\n 1. i < length [0..<max CARD('b) CARD('c)]", "by auto"], ["proof (state)\nthis:\n  i < length [0..<max CARD('b) CARD('c)]\n\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "have i_nth: \"[0..<max CARD('b) CARD('c)] ! i = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<max CARD('b) CARD('c)] ! i = i", "using i_length"], ["proof (prove)\nusing this:\n  i < length [0..<max CARD('b) CARD('c)]\n\ngoal (1 subgoal):\n 1. [0..<max CARD('b) CARD('c)] ! i = i", "by auto"], ["proof (state)\nthis:\n  [0..<max CARD('b) CARD('c)] ! i = i\n\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "let ?f=\"(\\<lambda>a. map (\\<lambda>a. if a < CARD('b) then IArray \n    (map (\\<lambda>i. A $ from_nat i) [0..<CARD('b)]) !! a else 0) [0..<max CARD('b) CARD('c)] !\n    a - map (\\<lambda>a. if a < CARD('c) then \n    IArray (map (\\<lambda>i. B $ from_nat i) [0..<CARD('c)]) !! a else 0) [0..<max CARD('b) CARD('c)] ! a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "have \"(vec_to_iarray A - vec_to_iarray B) = (IArray (map (\\<lambda>i. A $ from_nat i) [0..<CARD('b)]) \n    - IArray (map (\\<lambda>i. B $ from_nat i) [0..<CARD('c)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray A - vec_to_iarray B =\n    IArray\n     (map (\\<lambda>i. A $ mod_type_class.from_nat i) [0..<CARD('b)]) -\n    IArray (map (\\<lambda>i. B $ mod_type_class.from_nat i) [0..<CARD('c)])", "unfolding vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i) CARD('b) -\n    IArray.of_fun (\\<lambda>i. B $ mod_type_class.from_nat i) CARD('c) =\n    IArray\n     (map (\\<lambda>i. A $ mod_type_class.from_nat i) [0..<CARD('b)]) -\n    IArray (map (\\<lambda>i. B $ mod_type_class.from_nat i) [0..<CARD('c)])", "by auto"], ["proof (state)\nthis:\n  vec_to_iarray A - vec_to_iarray B =\n  IArray (map (\\<lambda>i. A $ mod_type_class.from_nat i) [0..<CARD('b)]) -\n  IArray (map (\\<lambda>i. B $ mod_type_class.from_nat i) [0..<CARD('c)])\n\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "also"], ["proof (state)\nthis:\n  vec_to_iarray A - vec_to_iarray B =\n  IArray (map (\\<lambda>i. A $ mod_type_class.from_nat i) [0..<CARD('b)]) -\n  IArray (map (\\<lambda>i. B $ mod_type_class.from_nat i) [0..<CARD('c)])\n\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "have \"... = IArray (map ?f [0..<max CARD('b) CARD('c)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>i. A $ mod_type_class.from_nat i) [0..<CARD('b)]) -\n    IArray\n     (map (\\<lambda>i. B $ mod_type_class.from_nat i) [0..<CARD('c)]) =\n    IArray\n     (map (\\<lambda>a.\n              map (\\<lambda>a.\n                      if a < CARD('b)\n                      then IArray\n                            (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                              [0..<CARD('b)]) !!\n                           a\n                      else (0::'a))\n               [0..<max CARD('b) CARD('c)] !\n              a -\n              map (\\<lambda>a.\n                      if a < CARD('c)\n                      then IArray\n                            (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                              [0..<CARD('c)]) !!\n                           a\n                      else (0::'a))\n               [0..<max CARD('b) CARD('c)] !\n              a)\n       [0..<max CARD('b) CARD('c)])", "unfolding minus_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a.\n              if a < IArray.length\n                      (IArray\n                        (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                          [0..<CARD('b)]))\n              then IArray\n                    (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                      [0..<CARD('b)]) !!\n                   a\n              else (0::'a))\n          (max (IArray.length\n                 (IArray\n                   (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                     [0..<CARD('b)])))\n            (IArray.length\n              (IArray\n                (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                  [0..<CARD('c)])))) !!\n         a -\n         IArray.of_fun\n          (\\<lambda>a.\n              if a < IArray.length\n                      (IArray\n                        (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                          [0..<CARD('c)]))\n              then IArray\n                    (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                      [0..<CARD('c)]) !!\n                   a\n              else (0::'a))\n          (max (IArray.length\n                 (IArray\n                   (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                     [0..<CARD('b)])))\n            (IArray.length\n              (IArray\n                (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                  [0..<CARD('c)])))) !!\n         a)\n     (max (IArray.length\n            (IArray\n              (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                [0..<CARD('b)])))\n       (IArray.length\n         (IArray\n           (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n             [0..<CARD('c)])))) =\n    IArray\n     (map (\\<lambda>a.\n              map (\\<lambda>a.\n                      if a < CARD('b)\n                      then IArray\n                            (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                              [0..<CARD('b)]) !!\n                           a\n                      else (0::'a))\n               [0..<max CARD('b) CARD('c)] !\n              a -\n              map (\\<lambda>a.\n                      if a < CARD('c)\n                      then IArray\n                            (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                              [0..<CARD('c)]) !!\n                           a\n                      else (0::'a))\n               [0..<max CARD('b) CARD('c)] !\n              a)\n       [0..<max CARD('b) CARD('c)])", "by simp"], ["proof (state)\nthis:\n  IArray (map (\\<lambda>i. A $ mod_type_class.from_nat i) [0..<CARD('b)]) -\n  IArray (map (\\<lambda>i. B $ mod_type_class.from_nat i) [0..<CARD('c)]) =\n  IArray\n   (map (\\<lambda>a.\n            map (\\<lambda>a.\n                    if a < CARD('b)\n                    then IArray\n                          (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                            [0..<CARD('b)]) !!\n                         a\n                    else (0::'a))\n             [0..<max CARD('b) CARD('c)] !\n            a -\n            map (\\<lambda>a.\n                    if a < CARD('c)\n                    then IArray\n                          (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                            [0..<CARD('c)]) !!\n                         a\n                    else (0::'a))\n             [0..<max CARD('b) CARD('c)] !\n            a)\n     [0..<max CARD('b) CARD('c)])\n\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "also"], ["proof (state)\nthis:\n  IArray (map (\\<lambda>i. A $ mod_type_class.from_nat i) [0..<CARD('b)]) -\n  IArray (map (\\<lambda>i. B $ mod_type_class.from_nat i) [0..<CARD('c)]) =\n  IArray\n   (map (\\<lambda>a.\n            map (\\<lambda>a.\n                    if a < CARD('b)\n                    then IArray\n                          (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                            [0..<CARD('b)]) !!\n                         a\n                    else (0::'a))\n             [0..<max CARD('b) CARD('c)] !\n            a -\n            map (\\<lambda>a.\n                    if a < CARD('c)\n                    then IArray\n                          (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                            [0..<CARD('c)]) !!\n                         a\n                    else (0::'a))\n             [0..<max CARD('b) CARD('c)] !\n            a)\n     [0..<max CARD('b) CARD('c)])\n\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "have \"... !! i =  A $ from_nat i - B $ from_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>a.\n              map (\\<lambda>a.\n                      if a < CARD('b)\n                      then IArray\n                            (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                              [0..<CARD('b)]) !!\n                           a\n                      else (0::'a))\n               [0..<max CARD('b) CARD('c)] !\n              a -\n              map (\\<lambda>a.\n                      if a < CARD('c)\n                      then IArray\n                            (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                              [0..<CARD('c)]) !!\n                           a\n                      else (0::'a))\n               [0..<max CARD('b) CARD('c)] !\n              a)\n       [0..<max CARD('b) CARD('c)]) !!\n    i =\n    A $ mod_type_class.from_nat i - B $ mod_type_class.from_nat i", "using i_length"], ["proof (prove)\nusing this:\n  i < length [0..<max CARD('b) CARD('c)]\n\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>a.\n              map (\\<lambda>a.\n                      if a < CARD('b)\n                      then IArray\n                            (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                              [0..<CARD('b)]) !!\n                           a\n                      else (0::'a))\n               [0..<max CARD('b) CARD('c)] !\n              a -\n              map (\\<lambda>a.\n                      if a < CARD('c)\n                      then IArray\n                            (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                              [0..<CARD('c)]) !!\n                           a\n                      else (0::'a))\n               [0..<max CARD('b) CARD('c)] !\n              a)\n       [0..<max CARD('b) CARD('c)]) !!\n    i =\n    A $ mod_type_class.from_nat i - B $ mod_type_class.from_nat i", "using nth_map i i2"], ["proof (prove)\nusing this:\n  i < length [0..<max CARD('b) CARD('c)]\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n  i < CARD('b)\n  i < CARD('c)\n\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>a.\n              map (\\<lambda>a.\n                      if a < CARD('b)\n                      then IArray\n                            (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                              [0..<CARD('b)]) !!\n                           a\n                      else (0::'a))\n               [0..<max CARD('b) CARD('c)] !\n              a -\n              map (\\<lambda>a.\n                      if a < CARD('c)\n                      then IArray\n                            (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                              [0..<CARD('c)]) !!\n                           a\n                      else (0::'a))\n               [0..<max CARD('b) CARD('c)] !\n              a)\n       [0..<max CARD('b) CARD('c)]) !!\n    i =\n    A $ mod_type_class.from_nat i - B $ mod_type_class.from_nat i", "by auto"], ["proof (state)\nthis:\n  IArray\n   (map (\\<lambda>a.\n            map (\\<lambda>a.\n                    if a < CARD('b)\n                    then IArray\n                          (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                            [0..<CARD('b)]) !!\n                         a\n                    else (0::'a))\n             [0..<max CARD('b) CARD('c)] !\n            a -\n            map (\\<lambda>a.\n                    if a < CARD('c)\n                    then IArray\n                          (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                            [0..<CARD('c)]) !!\n                         a\n                    else (0::'a))\n             [0..<max CARD('b) CARD('c)] !\n            a)\n     [0..<max CARD('b) CARD('c)]) !!\n  i =\n  A $ mod_type_class.from_nat i - B $ mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "also"], ["proof (state)\nthis:\n  IArray\n   (map (\\<lambda>a.\n            map (\\<lambda>a.\n                    if a < CARD('b)\n                    then IArray\n                          (map (\\<lambda>i. A $ mod_type_class.from_nat i)\n                            [0..<CARD('b)]) !!\n                         a\n                    else (0::'a))\n             [0..<max CARD('b) CARD('c)] !\n            a -\n            map (\\<lambda>a.\n                    if a < CARD('c)\n                    then IArray\n                          (map (\\<lambda>i. B $ mod_type_class.from_nat i)\n                            [0..<CARD('c)]) !!\n                         a\n                    else (0::'a))\n             [0..<max CARD('b) CARD('c)] !\n            a)\n     [0..<max CARD('b) CARD('c)]) !!\n  i =\n  A $ mod_type_class.from_nat i - B $ mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "have \"... = vec_to_iarray A !! i - vec_to_iarray B !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat i - B $ mod_type_class.from_nat i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "by (metis i i2 vec_to_iarray_nth)"], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat i - B $ mod_type_class.from_nat i =\n  vec_to_iarray A !! i - vec_to_iarray B !! i\n\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "finally"], ["proof (chain)\npicking this:\n  (vec_to_iarray A - vec_to_iarray B) !! i =\n  vec_to_iarray A !! i - vec_to_iarray B !! i", "show ?thesis"], ["proof (prove)\nusing this:\n  (vec_to_iarray A - vec_to_iarray B) !! i =\n  vec_to_iarray A !! i - vec_to_iarray B !! i\n\ngoal (1 subgoal):\n 1. (vec_to_iarray A - vec_to_iarray B) !! i =\n    vec_to_iarray A !! i - vec_to_iarray B !! i", "."], ["proof (state)\nthis:\n  (vec_to_iarray A - vec_to_iarray B) !! i =\n  vec_to_iarray A !! i - vec_to_iarray B !! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_map_vec_to_iarray:\n  assumes \"xs \\<noteq> []\" (*If I remove this assumption, I have to prove \n  vec_to_iarray 0 = IArray [] which is false.*)\n  shows \"sum_list (map (vec_to_iarray \\<circ> f) xs) = vec_to_iarray (sum_list (map f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map (vec_to_iarray \\<circ> f) xs) =\n    vec_to_iarray (sum_list (map f xs))", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. sum_list (map (vec_to_iarray \\<circ> f) xs) =\n    vec_to_iarray (sum_list (map f xs))", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) []) =\n    vec_to_iarray (sum_list (map f []))\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                sum_list (map (vec_to_iarray \\<circ> f) xs) =\n                vec_to_iarray (sum_list (map f xs));\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n                         vec_to_iarray (sum_list (map f (a # xs)))", "case Nil"], ["proof (state)\nthis:\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) []) =\n    vec_to_iarray (sum_list (map f []))\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                sum_list (map (vec_to_iarray \\<circ> f) xs) =\n                vec_to_iarray (sum_list (map f xs));\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n                         vec_to_iarray (sum_list (map f (a # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. sum_list (map (vec_to_iarray \\<circ> f) []) =\n    vec_to_iarray (sum_list (map f []))", "unfolding o_def"], ["proof (prove)\nusing this:\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<leftarrow>[]. vec_to_iarray (f a)) =\n    vec_to_iarray (sum_list (map f []))", "by auto"], ["proof (state)\nthis:\n  sum_list (map (vec_to_iarray \\<circ> f) []) =\n  vec_to_iarray (sum_list (map f []))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                sum_list (map (vec_to_iarray \\<circ> f) xs) =\n                vec_to_iarray (sum_list (map f xs));\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n                         vec_to_iarray (sum_list (map f (a # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                sum_list (map (vec_to_iarray \\<circ> f) xs) =\n                vec_to_iarray (sum_list (map f xs));\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n                         vec_to_iarray (sum_list (map f (a # xs)))", "case (Cons a xs)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<Longrightarrow>\n  sum_list (map (vec_to_iarray \\<circ> f) xs) =\n  vec_to_iarray (sum_list (map f xs))\n  a # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                sum_list (map (vec_to_iarray \\<circ> f) xs) =\n                vec_to_iarray (sum_list (map f xs));\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n                         vec_to_iarray (sum_list (map f (a # xs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "proof (cases \"xs=[]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "have l_rw: \"sum_list (map (vec_to_iarray \\<circ> f) xs) = IArray[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map (vec_to_iarray \\<circ> f) xs) = IArray []", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map (vec_to_iarray \\<circ> f) []) = IArray []", "by (simp add: zero_iarray_def)"], ["proof (state)\nthis:\n  sum_list (map (vec_to_iarray \\<circ> f) xs) = IArray []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "have \"sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) \n      = sum_list ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    sum_list\n     ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs)", "by simp"], ["proof (state)\nthis:\n  sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n  sum_list ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "also"], ["proof (state)\nthis:\n  sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n  sum_list ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "have \"... = (vec_to_iarray \\<circ> f) a + sum_list (map (vec_to_iarray \\<circ> f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs) =\n    (vec_to_iarray \\<circ> f) a +\n    sum_list (map (vec_to_iarray \\<circ> f) xs)", "by simp"], ["proof (state)\nthis:\n  sum_list\n   ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs) =\n  (vec_to_iarray \\<circ> f) a + sum_list (map (vec_to_iarray \\<circ> f) xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "also"], ["proof (state)\nthis:\n  sum_list\n   ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs) =\n  (vec_to_iarray \\<circ> f) a + sum_list (map (vec_to_iarray \\<circ> f) xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "have \"... = vec_to_iarray (f a) + IArray[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_to_iarray \\<circ> f) a +\n    sum_list (map (vec_to_iarray \\<circ> f) xs) =\n    vec_to_iarray (f a) + IArray []", "unfolding l_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_to_iarray \\<circ> f) a + IArray [] =\n    vec_to_iarray (f a) + IArray []", "by auto"], ["proof (state)\nthis:\n  (vec_to_iarray \\<circ> f) a +\n  sum_list (map (vec_to_iarray \\<circ> f) xs) =\n  vec_to_iarray (f a) + IArray []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "also"], ["proof (state)\nthis:\n  (vec_to_iarray \\<circ> f) a +\n  sum_list (map (vec_to_iarray \\<circ> f) xs) =\n  vec_to_iarray (f a) + IArray []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "have \"... = vec_to_iarray (f a) + vec_to_iarray (0::('b,'c) vec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (f a) + IArray [] = vec_to_iarray (f a) + vec_to_iarray 0", "unfolding plus_iarray_def Let_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>aa.\n              if aa < IArray.length\n                       (IArray.of_fun\n                         (\\<lambda>i. f a $ mod_type_class.from_nat i)\n                         CARD('c))\n              then IArray.of_fun\n                    (\\<lambda>i. f a $ mod_type_class.from_nat i)\n                    CARD('c) !!\n                   aa\n              else (0::'b))\n          (max (IArray.length\n                 (IArray.of_fun\n                   (\\<lambda>i. f a $ mod_type_class.from_nat i) CARD('c)))\n            (IArray.length (IArray []))) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>a.\n              if a < IArray.length (IArray []) then IArray [] !! a\n              else (0::'b))\n          (max (IArray.length\n                 (IArray.of_fun\n                   (\\<lambda>i. f a $ mod_type_class.from_nat i) CARD('c)))\n            (IArray.length (IArray []))) !!\n         aa)\n     (max (IArray.length\n            (IArray.of_fun (\\<lambda>i. f a $ mod_type_class.from_nat i)\n              CARD('c)))\n       (IArray.length (IArray []))) =\n    IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>aa.\n              if aa < IArray.length\n                       (IArray.of_fun\n                         (\\<lambda>i. f a $ mod_type_class.from_nat i)\n                         CARD('c))\n              then IArray.of_fun\n                    (\\<lambda>i. f a $ mod_type_class.from_nat i)\n                    CARD('c) !!\n                   aa\n              else (0::'b))\n          (max (IArray.length\n                 (IArray.of_fun\n                   (\\<lambda>i. f a $ mod_type_class.from_nat i) CARD('c)))\n            (IArray.length\n              (IArray.of_fun (\\<lambda>i. 0 $ mod_type_class.from_nat i)\n                CARD('c)))) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>a.\n              if a < IArray.length\n                      (IArray.of_fun\n                        (\\<lambda>i. 0 $ mod_type_class.from_nat i)\n                        CARD('c))\n              then IArray.of_fun (\\<lambda>i. 0 $ mod_type_class.from_nat i)\n                    CARD('c) !!\n                   a\n              else (0::'b))\n          (max (IArray.length\n                 (IArray.of_fun\n                   (\\<lambda>i. f a $ mod_type_class.from_nat i) CARD('c)))\n            (IArray.length\n              (IArray.of_fun (\\<lambda>i. 0 $ mod_type_class.from_nat i)\n                CARD('c)))) !!\n         aa)\n     (max (IArray.length\n            (IArray.of_fun (\\<lambda>i. f a $ mod_type_class.from_nat i)\n              CARD('c)))\n       (IArray.length\n         (IArray.of_fun (\\<lambda>i. 0 $ mod_type_class.from_nat i)\n           CARD('c))))", "by auto"], ["proof (state)\nthis:\n  vec_to_iarray (f a) + IArray [] = vec_to_iarray (f a) + vec_to_iarray 0\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "also"], ["proof (state)\nthis:\n  vec_to_iarray (f a) + IArray [] = vec_to_iarray (f a) + vec_to_iarray 0\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "have \"... = vec_to_iarray (sum_list (map (f) (a # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (f a) + vec_to_iarray 0 =\n    vec_to_iarray (sum_list (map f (a # xs)))", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (f a) + vec_to_iarray 0 =\n    vec_to_iarray (sum_list (map f [a]))", "unfolding plus_iarray_def Let_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>aa.\n              if aa < IArray.length\n                       (IArray.of_fun\n                         (\\<lambda>i. f a $ mod_type_class.from_nat i)\n                         CARD('c))\n              then IArray.of_fun\n                    (\\<lambda>i. f a $ mod_type_class.from_nat i)\n                    CARD('c) !!\n                   aa\n              else (0::'b))\n          (max (IArray.length\n                 (IArray.of_fun\n                   (\\<lambda>i. f a $ mod_type_class.from_nat i) CARD('c)))\n            (IArray.length\n              (IArray.of_fun (\\<lambda>i. 0 $ mod_type_class.from_nat i)\n                CARD('c)))) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>a.\n              if a < IArray.length\n                      (IArray.of_fun\n                        (\\<lambda>i. 0 $ mod_type_class.from_nat i)\n                        CARD('c))\n              then IArray.of_fun (\\<lambda>i. 0 $ mod_type_class.from_nat i)\n                    CARD('c) !!\n                   a\n              else (0::'b))\n          (max (IArray.length\n                 (IArray.of_fun\n                   (\\<lambda>i. f a $ mod_type_class.from_nat i) CARD('c)))\n            (IArray.length\n              (IArray.of_fun (\\<lambda>i. 0 $ mod_type_class.from_nat i)\n                CARD('c)))) !!\n         aa)\n     (max (IArray.length\n            (IArray.of_fun (\\<lambda>i. f a $ mod_type_class.from_nat i)\n              CARD('c)))\n       (IArray.length\n         (IArray.of_fun (\\<lambda>i. 0 $ mod_type_class.from_nat i)\n           CARD('c)))) =\n    IArray.of_fun\n     (\\<lambda>i. sum_list (map f [a]) $ mod_type_class.from_nat i) CARD('c)", "by auto"], ["proof (state)\nthis:\n  vec_to_iarray (f a) + vec_to_iarray 0 =\n  vec_to_iarray (sum_list (map f (a # xs)))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "finally"], ["proof (chain)\npicking this:\n  sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n  vec_to_iarray (sum_list (map f (a # xs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n  vec_to_iarray (sum_list (map f (a # xs)))\n\ngoal (1 subgoal):\n 1. sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "."], ["proof (state)\nthis:\n  sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n  vec_to_iarray (sum_list (map f (a # xs)))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "have \"sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) \n      = sum_list ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    sum_list\n     ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs)", "by simp"], ["proof (state)\nthis:\n  sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n  sum_list ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "also"], ["proof (state)\nthis:\n  sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n  sum_list ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "have \"... = (vec_to_iarray \\<circ> f) a + sum_list (map (vec_to_iarray \\<circ> f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs) =\n    (vec_to_iarray \\<circ> f) a +\n    sum_list (map (vec_to_iarray \\<circ> f) xs)", "by simp"], ["proof (state)\nthis:\n  sum_list\n   ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs) =\n  (vec_to_iarray \\<circ> f) a + sum_list (map (vec_to_iarray \\<circ> f) xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "also"], ["proof (state)\nthis:\n  sum_list\n   ((vec_to_iarray \\<circ> f) a # map (vec_to_iarray \\<circ> f) xs) =\n  (vec_to_iarray \\<circ> f) a + sum_list (map (vec_to_iarray \\<circ> f) xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "have \"... = (vec_to_iarray \\<circ> f) a + vec_to_iarray (sum_list (map f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_to_iarray \\<circ> f) a +\n    sum_list (map (vec_to_iarray \\<circ> f) xs) =\n    (vec_to_iarray \\<circ> f) a + vec_to_iarray (sum_list (map f xs))", "using Cons.prems Cons.hyps False"], ["proof (prove)\nusing this:\n  a # xs \\<noteq> []\n  xs \\<noteq> [] \\<Longrightarrow>\n  sum_list (map (vec_to_iarray \\<circ> f) xs) =\n  vec_to_iarray (sum_list (map f xs))\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (vec_to_iarray \\<circ> f) a +\n    sum_list (map (vec_to_iarray \\<circ> f) xs) =\n    (vec_to_iarray \\<circ> f) a + vec_to_iarray (sum_list (map f xs))", "by presburger"], ["proof (state)\nthis:\n  (vec_to_iarray \\<circ> f) a +\n  sum_list (map (vec_to_iarray \\<circ> f) xs) =\n  (vec_to_iarray \\<circ> f) a + vec_to_iarray (sum_list (map f xs))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "also"], ["proof (state)\nthis:\n  (vec_to_iarray \\<circ> f) a +\n  sum_list (map (vec_to_iarray \\<circ> f) xs) =\n  (vec_to_iarray \\<circ> f) a + vec_to_iarray (sum_list (map f xs))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "have \"... = vec_to_iarray (f a) + vec_to_iarray (sum_list (map f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_to_iarray \\<circ> f) a + vec_to_iarray (sum_list (map f xs)) =\n    vec_to_iarray (f a) + vec_to_iarray (sum_list (map f xs))", "by auto"], ["proof (state)\nthis:\n  (vec_to_iarray \\<circ> f) a + vec_to_iarray (sum_list (map f xs)) =\n  vec_to_iarray (f a) + vec_to_iarray (sum_list (map f xs))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "also"], ["proof (state)\nthis:\n  (vec_to_iarray \\<circ> f) a + vec_to_iarray (sum_list (map f xs)) =\n  vec_to_iarray (f a) + vec_to_iarray (sum_list (map f xs))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "have \"... = vec_to_iarray (f a + (sum_list (map f xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (f a) + vec_to_iarray (sum_list (map f xs)) =\n    vec_to_iarray (f a + sum_list (map f xs))", "by (simp add: vec_to_iarray_plus)"], ["proof (state)\nthis:\n  vec_to_iarray (f a) + vec_to_iarray (sum_list (map f xs)) =\n  vec_to_iarray (f a + sum_list (map f xs))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "also"], ["proof (state)\nthis:\n  vec_to_iarray (f a) + vec_to_iarray (sum_list (map f xs)) =\n  vec_to_iarray (f a + sum_list (map f xs))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "have \"... = vec_to_iarray (sum_list (map (f) (a # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (f a + sum_list (map f xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "by simp"], ["proof (state)\nthis:\n  vec_to_iarray (f a + sum_list (map f xs)) =\n  vec_to_iarray (sum_list (map f (a # xs)))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "finally"], ["proof (chain)\npicking this:\n  sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n  vec_to_iarray (sum_list (map f (a # xs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n  vec_to_iarray (sum_list (map f (a # xs)))\n\ngoal (1 subgoal):\n 1. sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n    vec_to_iarray (sum_list (map f (a # xs)))", "."], ["proof (state)\nthis:\n  sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n  vec_to_iarray (sum_list (map f (a # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (map (vec_to_iarray \\<circ> f) (a # xs)) =\n  vec_to_iarray (sum_list (map f (a # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Proving the equivalence\\<close>"], ["", "lemma matrix_to_iarray_Gram_Schmidt_column_k_efficient:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\" \n  assumes k: \"k<ncols A\"\n  shows \"matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) \n  = Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) =\n    Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k", "proof (unfold iarray_exhaust2 list_eq_iff_nth_eq, rule conjI, auto, \n    unfold IArray.sub_def[symmetric] IArray.length_def[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. IArray.length (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k)) =\n    IArray.length\n     (Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k)\n 2. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray\n              (Gram_Schmidt_column_k_efficient A k)) \\<Longrightarrow>\n       IArray.length\n        (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i) =\n       IArray.length\n        (Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !!\n         i)\n 3. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray\n                       (Gram_Schmidt_column_k_efficient A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !!\n               i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (Gram_Schmidt_column_k_efficient A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) k !!\n                         i !!\n                         ia", "show \"IArray.length (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k)) \n    = IArray.length (Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k)) =\n    IArray.length\n     (Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k)", "unfolding matrix_to_iarray_def Gram_Schmidt_column_k_iarrays_efficient_def tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (vec_to_iarray \\<circ>\n             ($) (Gram_Schmidt_column_k_efficient A k) \\<circ>\n             mod_type_class.from_nat)\n         [0..<CARD('m)])) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                let column_b_A =\n                      column_iarray b\n                       (IArray\n                         (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                               mod_type_class.from_nat)\n                           [0..<CARD('m)]))\n                in (if b = k\n                    then column_b_A -\n                         (\\<Sum>x\\<leftarrow>map\n        (\\<lambda>n.\n            column_iarray n\n             (IArray\n               (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                     mod_type_class.from_nat)\n                 [0..<CARD('m)])))\n        [0..<b]. (column_b_A \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x)\n                    else column_b_A) !!\n                   i)\n            (ncols_iarray\n              (IArray\n                (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                      mod_type_class.from_nat)\n                  [0..<CARD('m)]))))\n       (nrows_iarray\n         (IArray\n           (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                 mod_type_class.from_nat)\n             [0..<CARD('m)]))))", "unfolding nrows_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (vec_to_iarray \\<circ>\n             ($) (Gram_Schmidt_column_k_efficient A k) \\<circ>\n             mod_type_class.from_nat)\n         [0..<CARD('m)])) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                let column_b_A =\n                      column_iarray b\n                       (IArray\n                         (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                               mod_type_class.from_nat)\n                           [0..<CARD('m)]))\n                in (if b = k\n                    then column_b_A -\n                         (\\<Sum>x\\<leftarrow>map\n        (\\<lambda>n.\n            column_iarray n\n             (IArray\n               (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                     mod_type_class.from_nat)\n                 [0..<CARD('m)])))\n        [0..<b]. (column_b_A \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x)\n                    else column_b_A) !!\n                   i)\n            (ncols_iarray\n              (IArray\n                (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                      mod_type_class.from_nat)\n                  [0..<CARD('m)]))))\n       (IArray.length\n         (IArray\n           (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                 mod_type_class.from_nat)\n             [0..<CARD('m)]))))", "by auto"], ["proof (state)\nthis:\n  IArray.length (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k)) =\n  IArray.length\n   (Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray\n              (Gram_Schmidt_column_k_efficient A k)) \\<Longrightarrow>\n       IArray.length\n        (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i) =\n       IArray.length\n        (Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !!\n         i)\n 2. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray\n                       (Gram_Schmidt_column_k_efficient A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !!\n               i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (Gram_Schmidt_column_k_efficient A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) k !!\n                         i !!\n                         ia", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray\n              (Gram_Schmidt_column_k_efficient A k)) \\<Longrightarrow>\n       IArray.length\n        (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i) =\n       IArray.length\n        (Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !!\n         i)\n 2. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray\n                       (Gram_Schmidt_column_k_efficient A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !!\n               i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (Gram_Schmidt_column_k_efficient A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) k !!\n                         i !!\n                         ia", "show \"i < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k)) \\<Longrightarrow>\n    IArray.length (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i) =\n    IArray.length (Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length\n         (matrix_to_iarray\n           (Gram_Schmidt_column_k_efficient A k)) \\<Longrightarrow>\n    IArray.length\n     (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i) =\n    IArray.length\n     (Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i)", "by (simp add: matrix_to_iarray_def Gram_Schmidt_column_k_iarrays_efficient_def \n      Gram_Schmidt_column_k_efficient_def tabulate2_def ncols_iarray_def \n      nrows_iarray_def vec_to_iarray_def)"], ["proof (state)\nthis:\n  i < IArray.length\n       (matrix_to_iarray\n         (Gram_Schmidt_column_k_efficient A k)) \\<Longrightarrow>\n  IArray.length\n   (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i) =\n  IArray.length\n   (Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray\n                       (Gram_Schmidt_column_k_efficient A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !!\n               i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (Gram_Schmidt_column_k_efficient A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) k !!\n                         i !!\n                         ia", "fix i ia"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray\n                       (Gram_Schmidt_column_k_efficient A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !!\n               i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (Gram_Schmidt_column_k_efficient A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) k !!\n                         i !!\n                         ia", "assume i:\"i < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k))\"\n    and ia: \"ia < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i)\""], ["proof (state)\nthis:\n  i < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k))\n  ia < IArray.length\n        (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray\n                       (Gram_Schmidt_column_k_efficient A k));\n        ia < IArray.length\n              (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !!\n               i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray\n                          (Gram_Schmidt_column_k_efficient A k) !!\n                         i !!\n                         ia =\n                         Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) k !!\n                         i !!\n                         ia", "show \"matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia \n    = Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !! ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n    Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n    ia", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n    Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n    ia", "let ?f=\"(\\<lambda>a b. let column_b_A = column_iarray b (matrix_to_iarray A)\n      in (if b = k then column_b_A \n      - (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column_iarray n (matrix_to_iarray A)) [0..<b]. \n      (column_b_A \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x) else column_b_A) !! a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n    Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n    ia", "have i2: \"i<nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < nrows A", "using i"], ["proof (prove)\nusing this:\n  i < IArray.length (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k))\n\ngoal (1 subgoal):\n 1. i < nrows A", "unfolding nrows_def matrix_to_iarray_def"], ["proof (prove)\nusing this:\n  i < IArray.length\n       (IArray\n         (map (vec_to_iarray \\<circ>\n               ($) (Gram_Schmidt_column_k_efficient A k) \\<circ>\n               mod_type_class.from_nat)\n           [0..<CARD('m)]))\n\ngoal (1 subgoal):\n 1. i < CARD('m)", "by auto"], ["proof (state)\nthis:\n  i < nrows A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n    Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n    ia", "have ia2: \"ia<ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia < ncols A", "using ia"], ["proof (prove)\nusing this:\n  ia < IArray.length\n        (matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i)\n\ngoal (1 subgoal):\n 1. ia < ncols A", "unfolding ncols_def matrix_to_iarray_def o_def vec_to_iarray_def"], ["proof (prove)\nusing this:\n  ia < IArray.length\n        (IArray\n          (map (\\<lambda>x.\n                   IArray.of_fun\n                    (\\<lambda>i.\n                        Gram_Schmidt_column_k_efficient A k $\n                        mod_type_class.from_nat x $\n                        mod_type_class.from_nat i)\n                    CARD('n))\n            [0..<CARD('m)]) !!\n         i)\n\ngoal (1 subgoal):\n 1. ia < CARD('n)", "by (metis i2 ia length_vec_to_iarray nrows_def to_nat_from_nat_id vec_matrix)"], ["proof (state)\nthis:\n  ia < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n    Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n    ia", "have \"Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !! ia = ?f i ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n    ia =\n    (let column_b_A = column_iarray ia (matrix_to_iarray A)\n     in (if ia = k\n         then column_b_A -\n              (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n    column_iarray n (matrix_to_iarray A))\n                                   [0..<\n                                    ia]. (column_b_A \\<bullet>i x /\n    (x \\<bullet>i x)) *\\<^sub>R\n   x)\n         else column_b_A) !!\n        i)", "unfolding Gram_Schmidt_column_k_iarrays_efficient_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tabulate2 (nrows_iarray (matrix_to_iarray A))\n     (ncols_iarray (matrix_to_iarray A))\n     (\\<lambda>a b.\n         let column_b_A = column_iarray b (matrix_to_iarray A)\n         in (if b = k\n             then column_b_A -\n                  (\\<Sum>x\\<leftarrow>map\n (\\<lambda>n. column_iarray n (matrix_to_iarray A))\n [0..<b]. (column_b_A \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x)\n             else column_b_A) !!\n            a) !!\n    i !!\n    ia =\n    (let column_b_A = column_iarray ia (matrix_to_iarray A)\n     in (if ia = k\n         then column_b_A -\n              (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n    column_iarray n (matrix_to_iarray A))\n                                   [0..<\n                                    ia]. (column_b_A \\<bullet>i x /\n    (x \\<bullet>i x)) *\\<^sub>R\n   x)\n         else column_b_A) !!\n        i)", "proof (rule tabulate2_nth)"], ["proof (state)\ngoal (2 subgoals):\n 1. i < nrows_iarray (matrix_to_iarray A)\n 2. ia < ncols_iarray (matrix_to_iarray A)", "show \"i < nrows_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < nrows_iarray (matrix_to_iarray A)", "using i2"], ["proof (prove)\nusing this:\n  i < nrows A\n\ngoal (1 subgoal):\n 1. i < nrows_iarray (matrix_to_iarray A)", "unfolding matrix_to_iarray_nrows"], ["proof (prove)\nusing this:\n  i < nrows_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. i < nrows_iarray (matrix_to_iarray A)", "."], ["proof (state)\nthis:\n  i < nrows_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. ia < ncols_iarray (matrix_to_iarray A)", "show \"ia < ncols_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia < ncols_iarray (matrix_to_iarray A)", "using ia2"], ["proof (prove)\nusing this:\n  ia < ncols A\n\ngoal (1 subgoal):\n 1. ia < ncols_iarray (matrix_to_iarray A)", "unfolding matrix_to_iarray_ncols"], ["proof (prove)\nusing this:\n  ia < ncols_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. ia < ncols_iarray (matrix_to_iarray A)", "."], ["proof (state)\nthis:\n  ia < ncols_iarray (matrix_to_iarray A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n  ia =\n  (let column_b_A = column_iarray ia (matrix_to_iarray A)\n   in (if ia = k\n       then column_b_A -\n            (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n  column_iarray n (matrix_to_iarray A))\n                                 [0..<\n                                  ia]. (column_b_A \\<bullet>i x /\n  (x \\<bullet>i x)) *\\<^sub>R\n x)\n       else column_b_A) !!\n      i)\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n    Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n    ia", "also"], ["proof (state)\nthis:\n  Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n  ia =\n  (let column_b_A = column_iarray ia (matrix_to_iarray A)\n   in (if ia = k\n       then column_b_A -\n            (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n  column_iarray n (matrix_to_iarray A))\n                                 [0..<\n                                  ia]. (column_b_A \\<bullet>i x /\n  (x \\<bullet>i x)) *\\<^sub>R\n x)\n       else column_b_A) !!\n      i)\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n    Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n    ia", "have \"... = (Gram_Schmidt_column_k_efficient A k) $ (from_nat i) $ (from_nat ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let column_b_A = column_iarray ia (matrix_to_iarray A)\n     in (if ia = k\n         then column_b_A -\n              (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n    column_iarray n (matrix_to_iarray A))\n                                   [0..<\n                                    ia]. (column_b_A \\<bullet>i x /\n    (x \\<bullet>i x)) *\\<^sub>R\n   x)\n         else column_b_A) !!\n        i) =\n    Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n    mod_type_class.from_nat ia", "unfolding Gram_Schmidt_column_k_efficient_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ia = k\n     then column_iarray ia (matrix_to_iarray A) -\n          (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\ncolumn_iarray n (matrix_to_iarray A))\n                               [0..<\n                                ia]. (column_iarray ia\n (matrix_to_iarray A) \\<bullet>i\nx /\n(x \\<bullet>i x)) *\\<^sub>R\n                                     x)\n     else column_iarray ia (matrix_to_iarray A)) !!\n    i =\n    (\\<chi>a b.\n        (if b = mod_type_class.from_nat k\n         then column b A -\n              (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n    column (mod_type_class.from_nat n) A)\n                                   [0..<\n                                    mod_type_class.to_nat\n                                     b]. (column b A \\<bullet> x /\n    (x \\<bullet> x)) *\\<^sub>R\n   x)\n         else column b A) $\n        a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia", "proof (auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. ia = k \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i\n 2. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia = mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> IArray.list_of\n                       (column_iarray ia (matrix_to_iarray A)) !\n                      i =\n                      column (mod_type_class.from_nat k) A $\n                      mod_type_class.from_nat i -\n                      sum_list\n                       (map ((\\<lambda>x.\n                                 (column (mod_type_class.from_nat k)\n                                   A \\<bullet>\n                                  x /\n                                  (x \\<bullet> x)) *\\<^sub>R\n                                 x) \\<circ>\n                             (\\<lambda>n.\n                                 column (mod_type_class.from_nat n) A))\n                         [0..<\n                          mod_type_class.to_nat\n                           (mod_type_class.from_nat k)]) $\n                      mod_type_class.from_nat i\n 3. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia \\<noteq> mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> IArray.list_of\n                       (column_iarray ia (matrix_to_iarray A)) !\n                      i =\n                      column (mod_type_class.from_nat ia) A $\n                      mod_type_class.from_nat i", "assume ia_neq_k: \"ia \\<noteq> k\" and f_eq: \"(from_nat ia::'n) = from_nat k \""], ["proof (state)\nthis:\n  ia \\<noteq> k\n  mod_type_class.from_nat ia = mod_type_class.from_nat k\n\ngoal (3 subgoals):\n 1. ia = k \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i\n 2. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia = mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> IArray.list_of\n                       (column_iarray ia (matrix_to_iarray A)) !\n                      i =\n                      column (mod_type_class.from_nat k) A $\n                      mod_type_class.from_nat i -\n                      sum_list\n                       (map ((\\<lambda>x.\n                                 (column (mod_type_class.from_nat k)\n                                   A \\<bullet>\n                                  x /\n                                  (x \\<bullet> x)) *\\<^sub>R\n                                 x) \\<circ>\n                             (\\<lambda>n.\n                                 column (mod_type_class.from_nat n) A))\n                         [0..<\n                          mod_type_class.to_nat\n                           (mod_type_class.from_nat k)]) $\n                      mod_type_class.from_nat i\n 3. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia \\<noteq> mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> IArray.list_of\n                       (column_iarray ia (matrix_to_iarray A)) !\n                      i =\n                      column (mod_type_class.from_nat ia) A $\n                      mod_type_class.from_nat i", "have \"ia = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia = k", "using f_eq"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat ia = mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. ia = k", "by (metis assms from_nat_eq_imp_eq ia2 ncols_def)"], ["proof (state)\nthis:\n  ia = k\n\ngoal (3 subgoals):\n 1. ia = k \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i\n 2. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia = mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> IArray.list_of\n                       (column_iarray ia (matrix_to_iarray A)) !\n                      i =\n                      column (mod_type_class.from_nat k) A $\n                      mod_type_class.from_nat i -\n                      sum_list\n                       (map ((\\<lambda>x.\n                                 (column (mod_type_class.from_nat k)\n                                   A \\<bullet>\n                                  x /\n                                  (x \\<bullet> x)) *\\<^sub>R\n                                 x) \\<circ>\n                             (\\<lambda>n.\n                                 column (mod_type_class.from_nat n) A))\n                         [0..<\n                          mod_type_class.to_nat\n                           (mod_type_class.from_nat k)]) $\n                      mod_type_class.from_nat i\n 3. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia \\<noteq> mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> IArray.list_of\n                       (column_iarray ia (matrix_to_iarray A)) !\n                      i =\n                      column (mod_type_class.from_nat ia) A $\n                      mod_type_class.from_nat i", "thus \"IArray.list_of (column_iarray ia (matrix_to_iarray A)) ! i =\n        column (from_nat k) A $ from_nat i -\n        sum_list (map ((\\<lambda>x. (column (from_nat k) A \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x) \n        \\<circ> (\\<lambda>n. column (from_nat n) A)) [0..<to_nat (from_nat k)]) $ from_nat i\""], ["proof (prove)\nusing this:\n  ia = k\n\ngoal (1 subgoal):\n 1. IArray.list_of (column_iarray ia (matrix_to_iarray A)) ! i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "using ia_neq_k"], ["proof (prove)\nusing this:\n  ia = k\n  ia \\<noteq> k\n\ngoal (1 subgoal):\n 1. IArray.list_of (column_iarray ia (matrix_to_iarray A)) ! i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "by contradiction"], ["proof (state)\nthis:\n  IArray.list_of (column_iarray ia (matrix_to_iarray A)) ! i =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  sum_list\n   (map ((\\<lambda>x.\n             (column (mod_type_class.from_nat k) A \\<bullet> x /\n              (x \\<bullet> x)) *\\<^sub>R\n             x) \\<circ>\n         (\\<lambda>n. column (mod_type_class.from_nat n) A))\n     [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n  mod_type_class.from_nat i\n\ngoal (2 subgoals):\n 1. ia = k \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i\n 2. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia \\<noteq> mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> IArray.list_of\n                       (column_iarray ia (matrix_to_iarray A)) !\n                      i =\n                      column (mod_type_class.from_nat ia) A $\n                      mod_type_class.from_nat i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ia = k \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i\n 2. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia \\<noteq> mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> IArray.list_of\n                       (column_iarray ia (matrix_to_iarray A)) !\n                      i =\n                      column (mod_type_class.from_nat ia) A $\n                      mod_type_class.from_nat i", "assume \"ia \\<noteq> k\""], ["proof (state)\nthis:\n  ia \\<noteq> k\n\ngoal (2 subgoals):\n 1. ia = k \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i\n 2. \\<lbrakk>ia \\<noteq> k;\n     mod_type_class.from_nat ia \\<noteq> mod_type_class.from_nat k\\<rbrakk>\n    \\<Longrightarrow> IArray.list_of\n                       (column_iarray ia (matrix_to_iarray A)) !\n                      i =\n                      column (mod_type_class.from_nat ia) A $\n                      mod_type_class.from_nat i", "thus \"IArray.list_of (column_iarray ia (matrix_to_iarray A)) ! i \n        = column (from_nat ia) A $ from_nat i\""], ["proof (prove)\nusing this:\n  ia \\<noteq> k\n\ngoal (1 subgoal):\n 1. IArray.list_of (column_iarray ia (matrix_to_iarray A)) ! i =\n    column (mod_type_class.from_nat ia) A $ mod_type_class.from_nat i", "by (metis IArray.sub_def i ia2 length_eq_card_rows to_nat_from_nat_id \n          vec_to_iarray_column' vec_to_iarray_nth')"], ["proof (state)\nthis:\n  IArray.list_of (column_iarray ia (matrix_to_iarray A)) ! i =\n  column (mod_type_class.from_nat ia) A $ mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. ia = k \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ia = k \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "assume \"ia = k\""], ["proof (state)\nthis:\n  ia = k\n\ngoal (1 subgoal):\n 1. ia = k \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "let ?f=\"\\<lambda>x. ((column (from_nat k) A) \\<bullet> (column (from_nat x) A) /\n        ((column (from_nat x) A) \\<bullet> (column (from_nat x) A))) *\\<^sub>R (column (from_nat x) A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ia = k \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "let ?l=\"sum_list (map ?f [0..<k])\""], ["proof (state)\ngoal (1 subgoal):\n 1. ia = k \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "show \"IArray.list_of\n        (column_iarray k (matrix_to_iarray A) -\n        sum_list (map ((\\<lambda>x. (column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x) \n        \\<circ> (\\<lambda>n. column_iarray n (matrix_to_iarray A))) [0..<k])) ! i =\n        column (from_nat k) A $ from_nat i - \n        sum_list (map ((\\<lambda>x. (column (from_nat k) A \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x) \n        \\<circ> (\\<lambda>n. column (from_nat n) A)) [0..<to_nat (from_nat k::'n)]) $ from_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "proof (cases \"k=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "unfolding vec_to_iarray_column'[OF k, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.list_of\n     (vec_to_iarray (column (mod_type_class.from_nat k) A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (vec_to_iarray\n                   (column (mod_type_class.from_nat k) A) \\<bullet>i\n                  x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "unfolding True from_nat_0 to_nat_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.list_of\n     (vec_to_iarray (column (0::'n) A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (vec_to_iarray (column (0::'n) A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<0])) !\n    i =\n    column (0::'n) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (0::'n) A \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<0]) $\n    mod_type_class.from_nat i", "by (auto, metis IArray.sub_def i2 minus_zero_iarray nrows_def vec_to_iarray_nth)"], ["proof (state)\nthis:\n  IArray.list_of\n   (column_iarray k (matrix_to_iarray A) -\n    sum_list\n     (map ((\\<lambda>x.\n               (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                (x \\<bullet>i x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n       [0..<k])) !\n  i =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  sum_list\n   (map ((\\<lambda>x.\n             (column (mod_type_class.from_nat k) A \\<bullet> x /\n              (x \\<bullet> x)) *\\<^sub>R\n             x) \\<circ>\n         (\\<lambda>n. column (mod_type_class.from_nat n) A))\n     [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n  mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "have tn_fn_k: \"to_nat (from_nat k::'n) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat k) = k", "by (metis assms from_nat_to_nat ncols_def)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat k) = k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "have column_rw: \"column_iarray k (matrix_to_iarray A) \n          = vec_to_iarray (column (from_nat k) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column_iarray k (matrix_to_iarray A) =\n    vec_to_iarray (column (mod_type_class.from_nat k) A)", "by (rule vec_to_iarray_column'[symmetric, OF k])"], ["proof (state)\nthis:\n  column_iarray k (matrix_to_iarray A) =\n  vec_to_iarray (column (mod_type_class.from_nat k) A)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "have sum_list_rw: \"(\\<Sum>x\\<leftarrow>[0..<k]. (column_iarray k (matrix_to_iarray A) \n        \\<bullet>i column_iarray x (matrix_to_iarray A) / (column_iarray x (matrix_to_iarray A) \n        \\<bullet>i column_iarray x (matrix_to_iarray A))) *\\<^sub>R column_iarray x (matrix_to_iarray A)) \n        = vec_to_iarray ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column_iarray k\n                               (matrix_to_iarray A) \\<bullet>i\n                              column_iarray x (matrix_to_iarray A) /\n                              (column_iarray x\n                                (matrix_to_iarray A) \\<bullet>i\n                               column_iarray x\n                                (matrix_to_iarray A))) *\\<^sub>R\n                             column_iarray x (matrix_to_iarray A)) =\n    vec_to_iarray\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column (mod_type_class.from_nat k)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x) A /\n                               (column (mod_type_class.from_nat x)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x)\n                                 A)) *\\<^sub>R\n                              column (mod_type_class.from_nat x) A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column_iarray k\n                               (matrix_to_iarray A) \\<bullet>i\n                              column_iarray x (matrix_to_iarray A) /\n                              (column_iarray x\n                                (matrix_to_iarray A) \\<bullet>i\n                               column_iarray x\n                                (matrix_to_iarray A))) *\\<^sub>R\n                             column_iarray x (matrix_to_iarray A)) =\n    vec_to_iarray\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column (mod_type_class.from_nat k)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x) A /\n                               (column (mod_type_class.from_nat x)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x)\n                                 A)) *\\<^sub>R\n                              column (mod_type_class.from_nat x) A)", "have \"(\\<Sum>x\\<leftarrow>[0..<k]. (column_iarray k (matrix_to_iarray A) \n          \\<bullet>i column_iarray x (matrix_to_iarray A) / (column_iarray x (matrix_to_iarray A) \n          \\<bullet>i column_iarray x (matrix_to_iarray A))) *\\<^sub>R column_iarray x (matrix_to_iarray A)) \n          = sum_list (map (vec_to_iarray \\<circ> ?f) [0..<k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column_iarray k\n                               (matrix_to_iarray A) \\<bullet>i\n                              column_iarray x (matrix_to_iarray A) /\n                              (column_iarray x\n                                (matrix_to_iarray A) \\<bullet>i\n                               column_iarray x\n                                (matrix_to_iarray A))) *\\<^sub>R\n                             column_iarray x (matrix_to_iarray A)) =\n    sum_list\n     (map (vec_to_iarray \\<circ>\n           (\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet>\n                column (mod_type_class.from_nat x) A /\n                (column (mod_type_class.from_nat x) A \\<bullet>\n                 column (mod_type_class.from_nat x) A)) *\\<^sub>R\n               column (mod_type_class.from_nat x) A))\n       [0..<k])", "proof (unfold interv_sum_list_conv_sum_set_nat, rule sum.cong, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < k \\<Longrightarrow>\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i\n        column_iarray x (matrix_to_iarray A) /\n        (column_iarray x (matrix_to_iarray A) \\<bullet>i\n         column_iarray x (matrix_to_iarray A))) *\\<^sub>R\n       column_iarray x (matrix_to_iarray A) =\n       vec_to_iarray\n        ((column (mod_type_class.from_nat k) A \\<bullet>\n          column (mod_type_class.from_nat x) A /\n          (column (mod_type_class.from_nat x) A \\<bullet>\n           column (mod_type_class.from_nat x) A)) *\\<^sub>R\n         column (mod_type_class.from_nat x) A)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < k \\<Longrightarrow>\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i\n        column_iarray x (matrix_to_iarray A) /\n        (column_iarray x (matrix_to_iarray A) \\<bullet>i\n         column_iarray x (matrix_to_iarray A))) *\\<^sub>R\n       column_iarray x (matrix_to_iarray A) =\n       vec_to_iarray\n        ((column (mod_type_class.from_nat k) A \\<bullet>\n          column (mod_type_class.from_nat x) A /\n          (column (mod_type_class.from_nat x) A \\<bullet>\n           column (mod_type_class.from_nat x) A)) *\\<^sub>R\n         column (mod_type_class.from_nat x) A)", "assume \"x<k\""], ["proof (state)\nthis:\n  x < k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < k \\<Longrightarrow>\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i\n        column_iarray x (matrix_to_iarray A) /\n        (column_iarray x (matrix_to_iarray A) \\<bullet>i\n         column_iarray x (matrix_to_iarray A))) *\\<^sub>R\n       column_iarray x (matrix_to_iarray A) =\n       vec_to_iarray\n        ((column (mod_type_class.from_nat k) A \\<bullet>\n          column (mod_type_class.from_nat x) A /\n          (column (mod_type_class.from_nat x) A \\<bullet>\n           column (mod_type_class.from_nat x) A)) *\\<^sub>R\n         column (mod_type_class.from_nat x) A)", "hence x: \"x<ncols A\""], ["proof (prove)\nusing this:\n  x < k\n\ngoal (1 subgoal):\n 1. x < ncols A", "using k"], ["proof (prove)\nusing this:\n  x < k\n  k < ncols A\n\ngoal (1 subgoal):\n 1. x < ncols A", "by auto"], ["proof (state)\nthis:\n  x < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < k \\<Longrightarrow>\n       (column_iarray k (matrix_to_iarray A) \\<bullet>i\n        column_iarray x (matrix_to_iarray A) /\n        (column_iarray x (matrix_to_iarray A) \\<bullet>i\n         column_iarray x (matrix_to_iarray A))) *\\<^sub>R\n       column_iarray x (matrix_to_iarray A) =\n       vec_to_iarray\n        ((column (mod_type_class.from_nat k) A \\<bullet>\n          column (mod_type_class.from_nat x) A /\n          (column (mod_type_class.from_nat x) A \\<bullet>\n           column (mod_type_class.from_nat x) A)) *\\<^sub>R\n         column (mod_type_class.from_nat x) A)", "show \"(column_iarray k (matrix_to_iarray A) \\<bullet>i column_iarray x (matrix_to_iarray A) /\n              (column_iarray x (matrix_to_iarray A) \\<bullet>i column_iarray x (matrix_to_iarray A))) *\\<^sub>R\n              column_iarray x (matrix_to_iarray A) =\n              vec_to_iarray ((column (from_nat k) A \\<bullet> column (from_nat x) A /\n              (column (from_nat x) A \\<bullet> column (from_nat x) A)) *\\<^sub>R column (from_nat x) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (column_iarray k (matrix_to_iarray A) \\<bullet>i\n     column_iarray x (matrix_to_iarray A) /\n     (column_iarray x (matrix_to_iarray A) \\<bullet>i\n      column_iarray x (matrix_to_iarray A))) *\\<^sub>R\n    column_iarray x (matrix_to_iarray A) =\n    vec_to_iarray\n     ((column (mod_type_class.from_nat k) A \\<bullet>\n       column (mod_type_class.from_nat x) A /\n       (column (mod_type_class.from_nat x) A \\<bullet>\n        column (mod_type_class.from_nat x) A)) *\\<^sub>R\n      column (mod_type_class.from_nat x) A)", "unfolding vec_to_iarray_scaleR vec_to_iarray_inner"], ["proof (prove)\ngoal (1 subgoal):\n 1. (column_iarray k (matrix_to_iarray A) \\<bullet>i\n     column_iarray x (matrix_to_iarray A) /\n     (column_iarray x (matrix_to_iarray A) \\<bullet>i\n      column_iarray x (matrix_to_iarray A))) *\\<^sub>R\n    column_iarray x (matrix_to_iarray A) =\n    (vec_to_iarray (column (mod_type_class.from_nat k) A) \\<bullet>i\n     vec_to_iarray (column (mod_type_class.from_nat x) A) /\n     (vec_to_iarray (column (mod_type_class.from_nat x) A) \\<bullet>i\n      vec_to_iarray (column (mod_type_class.from_nat x) A))) *\\<^sub>R\n    vec_to_iarray (column (mod_type_class.from_nat x) A)", "unfolding column_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_to_iarray (column (mod_type_class.from_nat k) A) \\<bullet>i\n     column_iarray x (matrix_to_iarray A) /\n     (column_iarray x (matrix_to_iarray A) \\<bullet>i\n      column_iarray x (matrix_to_iarray A))) *\\<^sub>R\n    column_iarray x (matrix_to_iarray A) =\n    (vec_to_iarray (column (mod_type_class.from_nat k) A) \\<bullet>i\n     vec_to_iarray (column (mod_type_class.from_nat x) A) /\n     (vec_to_iarray (column (mod_type_class.from_nat x) A) \\<bullet>i\n      vec_to_iarray (column (mod_type_class.from_nat x) A))) *\\<^sub>R\n    vec_to_iarray (column (mod_type_class.from_nat x) A)", "unfolding vec_to_iarray_column'[OF x, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_to_iarray (column (mod_type_class.from_nat k) A) \\<bullet>i\n     vec_to_iarray (column (mod_type_class.from_nat x) A) /\n     (vec_to_iarray (column (mod_type_class.from_nat x) A) \\<bullet>i\n      vec_to_iarray (column (mod_type_class.from_nat x) A))) *\\<^sub>R\n    vec_to_iarray (column (mod_type_class.from_nat x) A) =\n    (vec_to_iarray (column (mod_type_class.from_nat k) A) \\<bullet>i\n     vec_to_iarray (column (mod_type_class.from_nat x) A) /\n     (vec_to_iarray (column (mod_type_class.from_nat x) A) \\<bullet>i\n      vec_to_iarray (column (mod_type_class.from_nat x) A))) *\\<^sub>R\n    vec_to_iarray (column (mod_type_class.from_nat x) A)", ".."], ["proof (state)\nthis:\n  (column_iarray k (matrix_to_iarray A) \\<bullet>i\n   column_iarray x (matrix_to_iarray A) /\n   (column_iarray x (matrix_to_iarray A) \\<bullet>i\n    column_iarray x (matrix_to_iarray A))) *\\<^sub>R\n  column_iarray x (matrix_to_iarray A) =\n  vec_to_iarray\n   ((column (mod_type_class.from_nat k) A \\<bullet>\n     column (mod_type_class.from_nat x) A /\n     (column (mod_type_class.from_nat x) A \\<bullet>\n      column (mod_type_class.from_nat x) A)) *\\<^sub>R\n    column (mod_type_class.from_nat x) A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>[0..<\n                       k]. (column_iarray k (matrix_to_iarray A) \\<bullet>i\n                            column_iarray x (matrix_to_iarray A) /\n                            (column_iarray x (matrix_to_iarray A) \\<bullet>i\n                             column_iarray x\n                              (matrix_to_iarray A))) *\\<^sub>R\n                           column_iarray x (matrix_to_iarray A)) =\n  sum_list\n   (map (vec_to_iarray \\<circ>\n         (\\<lambda>x.\n             (column (mod_type_class.from_nat k) A \\<bullet>\n              column (mod_type_class.from_nat x) A /\n              (column (mod_type_class.from_nat x) A \\<bullet>\n               column (mod_type_class.from_nat x) A)) *\\<^sub>R\n             column (mod_type_class.from_nat x) A))\n     [0..<k])\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column_iarray k\n                               (matrix_to_iarray A) \\<bullet>i\n                              column_iarray x (matrix_to_iarray A) /\n                              (column_iarray x\n                                (matrix_to_iarray A) \\<bullet>i\n                               column_iarray x\n                                (matrix_to_iarray A))) *\\<^sub>R\n                             column_iarray x (matrix_to_iarray A)) =\n    vec_to_iarray\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column (mod_type_class.from_nat k)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x) A /\n                               (column (mod_type_class.from_nat x)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x)\n                                 A)) *\\<^sub>R\n                              column (mod_type_class.from_nat x) A)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>[0..<\n                       k]. (column_iarray k (matrix_to_iarray A) \\<bullet>i\n                            column_iarray x (matrix_to_iarray A) /\n                            (column_iarray x (matrix_to_iarray A) \\<bullet>i\n                             column_iarray x\n                              (matrix_to_iarray A))) *\\<^sub>R\n                           column_iarray x (matrix_to_iarray A)) =\n  sum_list\n   (map (vec_to_iarray \\<circ>\n         (\\<lambda>x.\n             (column (mod_type_class.from_nat k) A \\<bullet>\n              column (mod_type_class.from_nat x) A /\n              (column (mod_type_class.from_nat x) A \\<bullet>\n               column (mod_type_class.from_nat x) A)) *\\<^sub>R\n             column (mod_type_class.from_nat x) A))\n     [0..<k])\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column_iarray k\n                               (matrix_to_iarray A) \\<bullet>i\n                              column_iarray x (matrix_to_iarray A) /\n                              (column_iarray x\n                                (matrix_to_iarray A) \\<bullet>i\n                               column_iarray x\n                                (matrix_to_iarray A))) *\\<^sub>R\n                             column_iarray x (matrix_to_iarray A)) =\n    vec_to_iarray\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column (mod_type_class.from_nat k)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x) A /\n                               (column (mod_type_class.from_nat x)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x)\n                                 A)) *\\<^sub>R\n                              column (mod_type_class.from_nat x) A)", "have \"... = vec_to_iarray (sum_list (map ?f [0..<k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map (vec_to_iarray \\<circ>\n           (\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet>\n                column (mod_type_class.from_nat x) A /\n                (column (mod_type_class.from_nat x) A \\<bullet>\n                 column (mod_type_class.from_nat x) A)) *\\<^sub>R\n               column (mod_type_class.from_nat x) A))\n       [0..<k]) =\n    vec_to_iarray\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column (mod_type_class.from_nat k)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x) A /\n                               (column (mod_type_class.from_nat x)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x)\n                                 A)) *\\<^sub>R\n                              column (mod_type_class.from_nat x) A)", "by (rule sum_list_map_vec_to_iarray, auto simp add: False)"], ["proof (state)\nthis:\n  sum_list\n   (map (vec_to_iarray \\<circ>\n         (\\<lambda>x.\n             (column (mod_type_class.from_nat k) A \\<bullet>\n              column (mod_type_class.from_nat x) A /\n              (column (mod_type_class.from_nat x) A \\<bullet>\n               column (mod_type_class.from_nat x) A)) *\\<^sub>R\n             column (mod_type_class.from_nat x) A))\n     [0..<k]) =\n  vec_to_iarray\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                             column (mod_type_class.from_nat x) A /\n                             (column (mod_type_class.from_nat x) A \\<bullet>\n                              column (mod_type_class.from_nat x)\n                               A)) *\\<^sub>R\n                            column (mod_type_class.from_nat x) A)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column_iarray k\n                               (matrix_to_iarray A) \\<bullet>i\n                              column_iarray x (matrix_to_iarray A) /\n                              (column_iarray x\n                                (matrix_to_iarray A) \\<bullet>i\n                               column_iarray x\n                                (matrix_to_iarray A))) *\\<^sub>R\n                             column_iarray x (matrix_to_iarray A)) =\n    vec_to_iarray\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column (mod_type_class.from_nat k)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x) A /\n                               (column (mod_type_class.from_nat x)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x)\n                                 A)) *\\<^sub>R\n                              column (mod_type_class.from_nat x) A)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<leftarrow>[0..<\n                       k]. (column_iarray k (matrix_to_iarray A) \\<bullet>i\n                            column_iarray x (matrix_to_iarray A) /\n                            (column_iarray x (matrix_to_iarray A) \\<bullet>i\n                             column_iarray x\n                              (matrix_to_iarray A))) *\\<^sub>R\n                           column_iarray x (matrix_to_iarray A)) =\n  vec_to_iarray\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                             column (mod_type_class.from_nat x) A /\n                             (column (mod_type_class.from_nat x) A \\<bullet>\n                              column (mod_type_class.from_nat x)\n                               A)) *\\<^sub>R\n                            column (mod_type_class.from_nat x) A)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<leftarrow>[0..<\n                       k]. (column_iarray k (matrix_to_iarray A) \\<bullet>i\n                            column_iarray x (matrix_to_iarray A) /\n                            (column_iarray x (matrix_to_iarray A) \\<bullet>i\n                             column_iarray x\n                              (matrix_to_iarray A))) *\\<^sub>R\n                           column_iarray x (matrix_to_iarray A)) =\n  vec_to_iarray\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                             column (mod_type_class.from_nat x) A /\n                             (column (mod_type_class.from_nat x) A \\<bullet>\n                              column (mod_type_class.from_nat x)\n                               A)) *\\<^sub>R\n                            column (mod_type_class.from_nat x) A)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column_iarray k\n                               (matrix_to_iarray A) \\<bullet>i\n                              column_iarray x (matrix_to_iarray A) /\n                              (column_iarray x\n                                (matrix_to_iarray A) \\<bullet>i\n                               column_iarray x\n                                (matrix_to_iarray A))) *\\<^sub>R\n                             column_iarray x (matrix_to_iarray A)) =\n    vec_to_iarray\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column (mod_type_class.from_nat k)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x) A /\n                               (column (mod_type_class.from_nat x)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x)\n                                 A)) *\\<^sub>R\n                              column (mod_type_class.from_nat x) A)", "."], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>[0..<\n                       k]. (column_iarray k (matrix_to_iarray A) \\<bullet>i\n                            column_iarray x (matrix_to_iarray A) /\n                            (column_iarray x (matrix_to_iarray A) \\<bullet>i\n                             column_iarray x\n                              (matrix_to_iarray A))) *\\<^sub>R\n                           column_iarray x (matrix_to_iarray A)) =\n  vec_to_iarray\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                             column (mod_type_class.from_nat x) A /\n                             (column (mod_type_class.from_nat x) A \\<bullet>\n                              column (mod_type_class.from_nat x)\n                               A)) *\\<^sub>R\n                            column (mod_type_class.from_nat x) A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>[0..<\n                       k]. (column_iarray k (matrix_to_iarray A) \\<bullet>i\n                            column_iarray x (matrix_to_iarray A) /\n                            (column_iarray x (matrix_to_iarray A) \\<bullet>i\n                             column_iarray x\n                              (matrix_to_iarray A))) *\\<^sub>R\n                           column_iarray x (matrix_to_iarray A)) =\n  vec_to_iarray\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                             column (mod_type_class.from_nat x) A /\n                             (column (mod_type_class.from_nat x) A \\<bullet>\n                              column (mod_type_class.from_nat x)\n                               A)) *\\<^sub>R\n                            column (mod_type_class.from_nat x) A)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "have \"IArray.list_of\n          (column_iarray k (matrix_to_iarray A) -\n          sum_list (map ((\\<lambda>x. (column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x) \n          \\<circ> (\\<lambda>n. column_iarray n (matrix_to_iarray A))) [0..<k])) ! i = \n          (column_iarray k (matrix_to_iarray A) -\n          (\\<Sum>x\\<leftarrow>[0..<k]. (column_iarray k (matrix_to_iarray A) \\<bullet>i column_iarray x (matrix_to_iarray A) /\n          (column_iarray x (matrix_to_iarray A) \\<bullet>i column_iarray x (matrix_to_iarray A))) *\\<^sub>R\n          column_iarray x (matrix_to_iarray A))) !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column_iarray k\n                                (matrix_to_iarray A) \\<bullet>i\n                               column_iarray x (matrix_to_iarray A) /\n                               (column_iarray x\n                                 (matrix_to_iarray A) \\<bullet>i\n                                column_iarray x\n                                 (matrix_to_iarray A))) *\\<^sub>R\n                              column_iarray x (matrix_to_iarray A))) !!\n    i", "unfolding vec_to_iarray_inner tn_fn_k o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      (\\<Sum>x\\<leftarrow>[0..<\n                           k]. (column_iarray k\n                                 (matrix_to_iarray A) \\<bullet>i\n                                column_iarray x (matrix_to_iarray A) /\n                                (column_iarray x\n                                  (matrix_to_iarray A) \\<bullet>i\n                                 column_iarray x\n                                  (matrix_to_iarray A))) *\\<^sub>R\n                               column_iarray x (matrix_to_iarray A))) !\n    i =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column_iarray k\n                                (matrix_to_iarray A) \\<bullet>i\n                               column_iarray x (matrix_to_iarray A) /\n                               (column_iarray x\n                                 (matrix_to_iarray A) \\<bullet>i\n                                column_iarray x\n                                 (matrix_to_iarray A))) *\\<^sub>R\n                              column_iarray x (matrix_to_iarray A))) !!\n    i", "unfolding IArray.sub_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column_iarray k\n                                (matrix_to_iarray A) \\<bullet>i\n                               column_iarray x (matrix_to_iarray A) /\n                               (column_iarray x\n                                 (matrix_to_iarray A) \\<bullet>i\n                                column_iarray x\n                                 (matrix_to_iarray A))) *\\<^sub>R\n                              column_iarray x (matrix_to_iarray A))) !!\n    i =\n    (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column_iarray k\n                                (matrix_to_iarray A) \\<bullet>i\n                               column_iarray x (matrix_to_iarray A) /\n                               (column_iarray x\n                                 (matrix_to_iarray A) \\<bullet>i\n                                column_iarray x\n                                 (matrix_to_iarray A))) *\\<^sub>R\n                              column_iarray x (matrix_to_iarray A))) !!\n    i", ".."], ["proof (state)\nthis:\n  IArray.list_of\n   (column_iarray k (matrix_to_iarray A) -\n    sum_list\n     (map ((\\<lambda>x.\n               (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                (x \\<bullet>i x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n       [0..<k])) !\n  i =\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column_iarray k (matrix_to_iarray A) \\<bullet>i\n                             column_iarray x (matrix_to_iarray A) /\n                             (column_iarray x\n                               (matrix_to_iarray A) \\<bullet>i\n                              column_iarray x\n                               (matrix_to_iarray A))) *\\<^sub>R\n                            column_iarray x (matrix_to_iarray A))) !!\n  i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "also"], ["proof (state)\nthis:\n  IArray.list_of\n   (column_iarray k (matrix_to_iarray A) -\n    sum_list\n     (map ((\\<lambda>x.\n               (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                (x \\<bullet>i x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n       [0..<k])) !\n  i =\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column_iarray k (matrix_to_iarray A) \\<bullet>i\n                             column_iarray x (matrix_to_iarray A) /\n                             (column_iarray x\n                               (matrix_to_iarray A) \\<bullet>i\n                              column_iarray x\n                               (matrix_to_iarray A))) *\\<^sub>R\n                            column_iarray x (matrix_to_iarray A))) !!\n  i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "have \"... = (vec_to_iarray (column (from_nat k) A) - vec_to_iarray ?l) !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (column_iarray k (matrix_to_iarray A) -\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column_iarray k\n                                (matrix_to_iarray A) \\<bullet>i\n                               column_iarray x (matrix_to_iarray A) /\n                               (column_iarray x\n                                 (matrix_to_iarray A) \\<bullet>i\n                                column_iarray x\n                                 (matrix_to_iarray A))) *\\<^sub>R\n                              column_iarray x (matrix_to_iarray A))) !!\n    i =\n    (vec_to_iarray (column (mod_type_class.from_nat k) A) -\n     vec_to_iarray\n      (\\<Sum>x\\<leftarrow>[0..<\n                           k]. (column (mod_type_class.from_nat k)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x) A /\n                                (column (mod_type_class.from_nat x)\n                                  A \\<bullet>\n                                 column (mod_type_class.from_nat x)\n                                  A)) *\\<^sub>R\n                               column (mod_type_class.from_nat x) A)) !!\n    i", "unfolding sum_list_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (column_iarray k (matrix_to_iarray A) -\n     vec_to_iarray\n      (\\<Sum>x\\<leftarrow>[0..<\n                           k]. (column (mod_type_class.from_nat k)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x) A /\n                                (column (mod_type_class.from_nat x)\n                                  A \\<bullet>\n                                 column (mod_type_class.from_nat x)\n                                  A)) *\\<^sub>R\n                               column (mod_type_class.from_nat x) A)) !!\n    i =\n    (vec_to_iarray (column (mod_type_class.from_nat k) A) -\n     vec_to_iarray\n      (\\<Sum>x\\<leftarrow>[0..<\n                           k]. (column (mod_type_class.from_nat k)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x) A /\n                                (column (mod_type_class.from_nat x)\n                                  A \\<bullet>\n                                 column (mod_type_class.from_nat x)\n                                  A)) *\\<^sub>R\n                               column (mod_type_class.from_nat x) A)) !!\n    i", "unfolding column_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_to_iarray (column (mod_type_class.from_nat k) A) -\n     vec_to_iarray\n      (\\<Sum>x\\<leftarrow>[0..<\n                           k]. (column (mod_type_class.from_nat k)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x) A /\n                                (column (mod_type_class.from_nat x)\n                                  A \\<bullet>\n                                 column (mod_type_class.from_nat x)\n                                  A)) *\\<^sub>R\n                               column (mod_type_class.from_nat x) A)) !!\n    i =\n    (vec_to_iarray (column (mod_type_class.from_nat k) A) -\n     vec_to_iarray\n      (\\<Sum>x\\<leftarrow>[0..<\n                           k]. (column (mod_type_class.from_nat k)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x) A /\n                                (column (mod_type_class.from_nat x)\n                                  A \\<bullet>\n                                 column (mod_type_class.from_nat x)\n                                  A)) *\\<^sub>R\n                               column (mod_type_class.from_nat x) A)) !!\n    i", ".."], ["proof (state)\nthis:\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column_iarray k (matrix_to_iarray A) \\<bullet>i\n                             column_iarray x (matrix_to_iarray A) /\n                             (column_iarray x\n                               (matrix_to_iarray A) \\<bullet>i\n                              column_iarray x\n                               (matrix_to_iarray A))) *\\<^sub>R\n                            column_iarray x (matrix_to_iarray A))) !!\n  i =\n  (vec_to_iarray (column (mod_type_class.from_nat k) A) -\n   vec_to_iarray\n    (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                              column (mod_type_class.from_nat x) A /\n                              (column (mod_type_class.from_nat x)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x)\n                                A)) *\\<^sub>R\n                             column (mod_type_class.from_nat x) A)) !!\n  i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "also"], ["proof (state)\nthis:\n  (column_iarray k (matrix_to_iarray A) -\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column_iarray k (matrix_to_iarray A) \\<bullet>i\n                             column_iarray x (matrix_to_iarray A) /\n                             (column_iarray x\n                               (matrix_to_iarray A) \\<bullet>i\n                              column_iarray x\n                               (matrix_to_iarray A))) *\\<^sub>R\n                            column_iarray x (matrix_to_iarray A))) !!\n  i =\n  (vec_to_iarray (column (mod_type_class.from_nat k) A) -\n   vec_to_iarray\n    (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                              column (mod_type_class.from_nat x) A /\n                              (column (mod_type_class.from_nat x)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x)\n                                A)) *\\<^sub>R\n                             column (mod_type_class.from_nat x) A)) !!\n  i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "have \"... = ((vec_to_iarray (column (from_nat k) A)) !! i) - (vec_to_iarray ?l !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_to_iarray (column (mod_type_class.from_nat k) A) -\n     vec_to_iarray\n      (\\<Sum>x\\<leftarrow>[0..<\n                           k]. (column (mod_type_class.from_nat k)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x) A /\n                                (column (mod_type_class.from_nat x)\n                                  A \\<bullet>\n                                 column (mod_type_class.from_nat x)\n                                  A)) *\\<^sub>R\n                               column (mod_type_class.from_nat x) A)) !!\n    i =\n    vec_to_iarray (column (mod_type_class.from_nat k) A) !! i -\n    vec_to_iarray\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column (mod_type_class.from_nat k)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x) A /\n                               (column (mod_type_class.from_nat x)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x)\n                                 A)) *\\<^sub>R\n                              column (mod_type_class.from_nat x) A) !!\n    i", "proof (rule vec_to_iarray_minus_nth)"], ["proof (state)\ngoal (2 subgoals):\n 1. i < IArray.length (vec_to_iarray (column (mod_type_class.from_nat k) A))\n 2. i < IArray.length\n         (vec_to_iarray\n           (\\<Sum>x\\<leftarrow>[0..<\n                                k]. (column (mod_type_class.from_nat k)\nA \\<bullet>\n                                     column (mod_type_class.from_nat x) A /\n                                     (column (mod_type_class.from_nat x)\n A \\<bullet>\ncolumn (mod_type_class.from_nat x) A)) *\\<^sub>R\n                                    column (mod_type_class.from_nat x) A))", "show \" i < IArray.length (vec_to_iarray (column (from_nat k) A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length (vec_to_iarray (column (mod_type_class.from_nat k) A))", "by (metis i2 length_vec_to_iarray nrows_def)"], ["proof (state)\nthis:\n  i < IArray.length (vec_to_iarray (column (mod_type_class.from_nat k) A))\n\ngoal (1 subgoal):\n 1. i < IArray.length\n         (vec_to_iarray\n           (\\<Sum>x\\<leftarrow>[0..<\n                                k]. (column (mod_type_class.from_nat k)\nA \\<bullet>\n                                     column (mod_type_class.from_nat x) A /\n                                     (column (mod_type_class.from_nat x)\n A \\<bullet>\ncolumn (mod_type_class.from_nat x) A)) *\\<^sub>R\n                                    column (mod_type_class.from_nat x) A))", "show \"i < IArray.length (vec_to_iarray ?l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length\n         (vec_to_iarray\n           (\\<Sum>x\\<leftarrow>[0..<\n                                k]. (column (mod_type_class.from_nat k)\nA \\<bullet>\n                                     column (mod_type_class.from_nat x) A /\n                                     (column (mod_type_class.from_nat x)\n A \\<bullet>\ncolumn (mod_type_class.from_nat x) A)) *\\<^sub>R\n                                    column (mod_type_class.from_nat x) A))", "by (metis (no_types, lifting) i2 length_vec_to_iarray nrows_def)"], ["proof (state)\nthis:\n  i < IArray.length\n       (vec_to_iarray\n         (\\<Sum>x\\<leftarrow>[0..<\n                              k]. (column (mod_type_class.from_nat k)\n                                    A \\<bullet>\n                                   column (mod_type_class.from_nat x) A /\n                                   (column (mod_type_class.from_nat x)\n                                     A \\<bullet>\n                                    column (mod_type_class.from_nat x)\n                                     A)) *\\<^sub>R\n                                  column (mod_type_class.from_nat x) A))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (vec_to_iarray (column (mod_type_class.from_nat k) A) -\n   vec_to_iarray\n    (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                              column (mod_type_class.from_nat x) A /\n                              (column (mod_type_class.from_nat x)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x)\n                                A)) *\\<^sub>R\n                             column (mod_type_class.from_nat x) A)) !!\n  i =\n  vec_to_iarray (column (mod_type_class.from_nat k) A) !! i -\n  vec_to_iarray\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                             column (mod_type_class.from_nat x) A /\n                             (column (mod_type_class.from_nat x) A \\<bullet>\n                              column (mod_type_class.from_nat x)\n                               A)) *\\<^sub>R\n                            column (mod_type_class.from_nat x) A) !!\n  i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "also"], ["proof (state)\nthis:\n  (vec_to_iarray (column (mod_type_class.from_nat k) A) -\n   vec_to_iarray\n    (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                              column (mod_type_class.from_nat x) A /\n                              (column (mod_type_class.from_nat x)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x)\n                                A)) *\\<^sub>R\n                             column (mod_type_class.from_nat x) A)) !!\n  i =\n  vec_to_iarray (column (mod_type_class.from_nat k) A) !! i -\n  vec_to_iarray\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                             column (mod_type_class.from_nat x) A /\n                             (column (mod_type_class.from_nat x) A \\<bullet>\n                              column (mod_type_class.from_nat x)\n                               A)) *\\<^sub>R\n                            column (mod_type_class.from_nat x) A) !!\n  i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "have \"... = column (from_nat k) A $ from_nat i - ?l $ from_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (column (mod_type_class.from_nat k) A) !! i -\n    vec_to_iarray\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column (mod_type_class.from_nat k)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x) A /\n                               (column (mod_type_class.from_nat x)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x)\n                                 A)) *\\<^sub>R\n                              column (mod_type_class.from_nat x) A) !!\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                              column (mod_type_class.from_nat x) A /\n                              (column (mod_type_class.from_nat x)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x)\n                                A)) *\\<^sub>R\n                             column (mod_type_class.from_nat x) A) $\n    mod_type_class.from_nat i", "unfolding column_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (column (mod_type_class.from_nat k) A) !! i -\n    vec_to_iarray\n     (\\<Sum>x\\<leftarrow>[0..<\n                          k]. (column (mod_type_class.from_nat k)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x) A /\n                               (column (mod_type_class.from_nat x)\n                                 A \\<bullet>\n                                column (mod_type_class.from_nat x)\n                                 A)) *\\<^sub>R\n                              column (mod_type_class.from_nat x) A) !!\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                              column (mod_type_class.from_nat x) A /\n                              (column (mod_type_class.from_nat x)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x)\n                                A)) *\\<^sub>R\n                             column (mod_type_class.from_nat x) A) $\n    mod_type_class.from_nat i", "by (metis (no_types, lifting) i2 nrows_def vec_to_iarray_nth)"], ["proof (state)\nthis:\n  vec_to_iarray (column (mod_type_class.from_nat k) A) !! i -\n  vec_to_iarray\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                             column (mod_type_class.from_nat x) A /\n                             (column (mod_type_class.from_nat x) A \\<bullet>\n                              column (mod_type_class.from_nat x)\n                               A)) *\\<^sub>R\n                            column (mod_type_class.from_nat x) A) !!\n  i =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<leftarrow>[0..<\n                       k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                            column (mod_type_class.from_nat x) A /\n                            (column (mod_type_class.from_nat x) A \\<bullet>\n                             column (mod_type_class.from_nat x)\n                              A)) *\\<^sub>R\n                           column (mod_type_class.from_nat x) A) $\n  mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "also"], ["proof (state)\nthis:\n  vec_to_iarray (column (mod_type_class.from_nat k) A) !! i -\n  vec_to_iarray\n   (\\<Sum>x\\<leftarrow>[0..<\n                        k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                             column (mod_type_class.from_nat x) A /\n                             (column (mod_type_class.from_nat x) A \\<bullet>\n                              column (mod_type_class.from_nat x)\n                               A)) *\\<^sub>R\n                            column (mod_type_class.from_nat x) A) !!\n  i =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<leftarrow>[0..<\n                       k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                            column (mod_type_class.from_nat x) A /\n                            (column (mod_type_class.from_nat x) A \\<bullet>\n                             column (mod_type_class.from_nat x)\n                              A)) *\\<^sub>R\n                           column (mod_type_class.from_nat x) A) $\n  mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "have \"... = column (from_nat k) A $ from_nat i -\n          sum_list (map ((\\<lambda>x. (column (from_nat k) A \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x) \n          \\<circ> (\\<lambda>n. column (from_nat n) A)) [0..<to_nat (from_nat k::'n)]) $ from_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                              column (mod_type_class.from_nat x) A /\n                              (column (mod_type_class.from_nat x)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x)\n                                A)) *\\<^sub>R\n                             column (mod_type_class.from_nat x) A) $\n    mod_type_class.from_nat i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "unfolding o_def tn_fn_k"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                              column (mod_type_class.from_nat x) A /\n                              (column (mod_type_class.from_nat x)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x)\n                                A)) *\\<^sub>R\n                             column (mod_type_class.from_nat x) A) $\n    mod_type_class.from_nat i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    (\\<Sum>x\\<leftarrow>[0..<\n                         k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                              column (mod_type_class.from_nat x) A /\n                              (column (mod_type_class.from_nat x)\n                                A \\<bullet>\n                               column (mod_type_class.from_nat x)\n                                A)) *\\<^sub>R\n                             column (mod_type_class.from_nat x) A) $\n    mod_type_class.from_nat i", ".."], ["proof (state)\nthis:\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  (\\<Sum>x\\<leftarrow>[0..<\n                       k]. (column (mod_type_class.from_nat k) A \\<bullet>\n                            column (mod_type_class.from_nat x) A /\n                            (column (mod_type_class.from_nat x) A \\<bullet>\n                             column (mod_type_class.from_nat x)\n                              A)) *\\<^sub>R\n                           column (mod_type_class.from_nat x) A) $\n  mod_type_class.from_nat i =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  sum_list\n   (map ((\\<lambda>x.\n             (column (mod_type_class.from_nat k) A \\<bullet> x /\n              (x \\<bullet> x)) *\\<^sub>R\n             x) \\<circ>\n         (\\<lambda>n. column (mod_type_class.from_nat n) A))\n     [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n  mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "finally"], ["proof (chain)\npicking this:\n  IArray.list_of\n   (column_iarray k (matrix_to_iarray A) -\n    sum_list\n     (map ((\\<lambda>x.\n               (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                (x \\<bullet>i x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n       [0..<k])) !\n  i =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  sum_list\n   (map ((\\<lambda>x.\n             (column (mod_type_class.from_nat k) A \\<bullet> x /\n              (x \\<bullet> x)) *\\<^sub>R\n             x) \\<circ>\n         (\\<lambda>n. column (mod_type_class.from_nat n) A))\n     [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n  mod_type_class.from_nat i", "show \"IArray.list_of\n          (column_iarray k (matrix_to_iarray A) -\n          sum_list (map ((\\<lambda>x. (column_iarray k (matrix_to_iarray A) \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x) \n          \\<circ> (\\<lambda>n. column_iarray n (matrix_to_iarray A))) [0..<k])) ! i =\n          column (from_nat k) A $ from_nat i -\n          sum_list (map ((\\<lambda>x. (column (from_nat k) A \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x) \n          \\<circ> (\\<lambda>n. column (from_nat n) A)) [0..<to_nat (from_nat k::'n)]) $ from_nat i\""], ["proof (prove)\nusing this:\n  IArray.list_of\n   (column_iarray k (matrix_to_iarray A) -\n    sum_list\n     (map ((\\<lambda>x.\n               (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                (x \\<bullet>i x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n       [0..<k])) !\n  i =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  sum_list\n   (map ((\\<lambda>x.\n             (column (mod_type_class.from_nat k) A \\<bullet> x /\n              (x \\<bullet> x)) *\\<^sub>R\n             x) \\<circ>\n         (\\<lambda>n. column (mod_type_class.from_nat n) A))\n     [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n  mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. IArray.list_of\n     (column_iarray k (matrix_to_iarray A) -\n      sum_list\n       (map ((\\<lambda>x.\n                 (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                  (x \\<bullet>i x)) *\\<^sub>R\n                 x) \\<circ>\n             (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n         [0..<k])) !\n    i =\n    column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n    sum_list\n     (map ((\\<lambda>x.\n               (column (mod_type_class.from_nat k) A \\<bullet> x /\n                (x \\<bullet> x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column (mod_type_class.from_nat n) A))\n       [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n    mod_type_class.from_nat i", "."], ["proof (state)\nthis:\n  IArray.list_of\n   (column_iarray k (matrix_to_iarray A) -\n    sum_list\n     (map ((\\<lambda>x.\n               (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                (x \\<bullet>i x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n       [0..<k])) !\n  i =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  sum_list\n   (map ((\\<lambda>x.\n             (column (mod_type_class.from_nat k) A \\<bullet> x /\n              (x \\<bullet> x)) *\\<^sub>R\n             x) \\<circ>\n         (\\<lambda>n. column (mod_type_class.from_nat n) A))\n     [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n  mod_type_class.from_nat i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IArray.list_of\n   (column_iarray k (matrix_to_iarray A) -\n    sum_list\n     (map ((\\<lambda>x.\n               (column_iarray k (matrix_to_iarray A) \\<bullet>i x /\n                (x \\<bullet>i x)) *\\<^sub>R\n               x) \\<circ>\n           (\\<lambda>n. column_iarray n (matrix_to_iarray A)))\n       [0..<k])) !\n  i =\n  column (mod_type_class.from_nat k) A $ mod_type_class.from_nat i -\n  sum_list\n   (map ((\\<lambda>x.\n             (column (mod_type_class.from_nat k) A \\<bullet> x /\n              (x \\<bullet> x)) *\\<^sub>R\n             x) \\<circ>\n         (\\<lambda>n. column (mod_type_class.from_nat n) A))\n     [0..<mod_type_class.to_nat (mod_type_class.from_nat k)]) $\n  mod_type_class.from_nat i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (let column_b_A = column_iarray ia (matrix_to_iarray A)\n   in (if ia = k\n       then column_b_A -\n            (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n  column_iarray n (matrix_to_iarray A))\n                                 [0..<\n                                  ia]. (column_b_A \\<bullet>i x /\n  (x \\<bullet>i x)) *\\<^sub>R\n x)\n       else column_b_A) !!\n      i) =\n  Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n  mod_type_class.from_nat ia\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n    Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n    ia", "also"], ["proof (state)\nthis:\n  (let column_b_A = column_iarray ia (matrix_to_iarray A)\n   in (if ia = k\n       then column_b_A -\n            (\\<Sum>x\\<leftarrow>map (\\<lambda>n.\n  column_iarray n (matrix_to_iarray A))\n                                 [0..<\n                                  ia]. (column_b_A \\<bullet>i x /\n  (x \\<bullet>i x)) *\\<^sub>R\n x)\n       else column_b_A) !!\n      i) =\n  Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n  mod_type_class.from_nat ia\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n    Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n    ia", "have \"... = matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia", "using matrix_to_iarray_nth[of \"(Gram_Schmidt_column_k_efficient A k)\" \"from_nat i\" \"from_nat ia\"]"], ["proof (prove)\nusing this:\n  matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !!\n  mod_type_class.to_nat (mod_type_class.from_nat i) !!\n  mod_type_class.to_nat (mod_type_class.from_nat ia) =\n  Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n  mod_type_class.from_nat ia\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia", "using ia2 i2"], ["proof (prove)\nusing this:\n  matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !!\n  mod_type_class.to_nat (mod_type_class.from_nat i) !!\n  mod_type_class.to_nat (mod_type_class.from_nat ia) =\n  Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n  mod_type_class.from_nat ia\n  ia < ncols A\n  i < nrows A\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia", "unfolding to_nat_from_nat_id[OF i2[unfolded nrows_def]]"], ["proof (prove)\nusing this:\n  matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !!\n  mod_type_class.to_nat (mod_type_class.from_nat ia) =\n  Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n  mod_type_class.from_nat ia\n  ia < ncols A\n  i < nrows A\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia", "unfolding to_nat_from_nat_id[OF ia2[unfolded ncols_def]]"], ["proof (prove)\nusing this:\n  matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n  Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n  mod_type_class.from_nat ia\n  ia < ncols A\n  i < nrows A\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia", "by simp"], ["proof (state)\nthis:\n  Gram_Schmidt_column_k_efficient A k $ mod_type_class.from_nat i $\n  mod_type_class.from_nat ia =\n  matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n    Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n    ia", "finally"], ["proof (chain)\npicking this:\n  Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n  ia =\n  matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia", "show ?thesis"], ["proof (prove)\nusing this:\n  Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n  ia =\n  matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n    Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !!\n    ia", ".."], ["proof (state)\nthis:\n  matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n  Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !! ia\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_to_iarray (Gram_Schmidt_column_k_efficient A k) !! i !! ia =\n  Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) k !! i !! ia\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_Gram_Schmidt_upt_k_efficient:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\" \n  assumes k: \"k<ncols A\"\n  shows \"matrix_to_iarray (Gram_Schmidt_upt_k A k) \n  = foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A) [0..<Suc k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<Suc k]", "using assms"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<Suc k]", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    matrix_to_iarray (Gram_Schmidt_upt_k A 0) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<Suc 0]\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                foldl Gram_Schmidt_column_k_iarrays_efficient\n                 (matrix_to_iarray A) [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         foldl Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) [0..<Suc (Suc k)]", "case 0"], ["proof (state)\nthis:\n  0 < ncols A\n\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    matrix_to_iarray (Gram_Schmidt_upt_k A 0) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<Suc 0]\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                foldl Gram_Schmidt_column_k_iarrays_efficient\n                 (matrix_to_iarray A) [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         foldl Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) [0..<Suc (Suc k)]", "have zero_le: \"0<ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ncols A", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < CARD('n)", "by simp"], ["proof (state)\nthis:\n  0 < ncols A\n\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    matrix_to_iarray (Gram_Schmidt_upt_k A 0) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<Suc 0]\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                foldl Gram_Schmidt_column_k_iarrays_efficient\n                 (matrix_to_iarray A) [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         foldl Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) [0..<Suc (Suc k)]", "thus ?case"], ["proof (prove)\nusing this:\n  0 < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A 0) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<Suc 0]", "unfolding Gram_Schmidt_upt_k_efficient[OF zero_le]"], ["proof (prove)\nusing this:\n  0 < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (foldl Gram_Schmidt_column_k_efficient A [0..<Suc 0]) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<Suc 0]", "unfolding Gram_Schmidt_upt_k_efficient"], ["proof (prove)\nusing this:\n  0 < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (foldl Gram_Schmidt_column_k_efficient A [0..<Suc 0]) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<Suc 0]", "by (simp add: matrix_to_iarray_Gram_Schmidt_column_k_efficient[OF \"0.prems\"])"], ["proof (state)\nthis:\n  matrix_to_iarray (Gram_Schmidt_upt_k A 0) =\n  foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n   [0..<Suc 0]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                foldl Gram_Schmidt_column_k_iarrays_efficient\n                 (matrix_to_iarray A) [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         foldl Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) [0..<Suc (Suc k)]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                foldl Gram_Schmidt_column_k_iarrays_efficient\n                 (matrix_to_iarray A) [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         foldl Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) [0..<Suc (Suc k)]", "case (Suc k)"], ["proof (state)\nthis:\n  k < ncols A \\<Longrightarrow>\n  matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n  foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n   [0..<Suc k]\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                foldl Gram_Schmidt_column_k_iarrays_efficient\n                 (matrix_to_iarray A) [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         foldl Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) [0..<Suc (Suc k)]", "let ?G=\"foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                foldl Gram_Schmidt_column_k_iarrays_efficient\n                 (matrix_to_iarray A) [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         foldl Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) [0..<Suc (Suc k)]", "have k: \"k<ncols (Gram_Schmidt_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ncols (Gram_Schmidt_upt_k A k)", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. k < ncols (Gram_Schmidt_upt_k A k)", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('n)\n\ngoal (1 subgoal):\n 1. k < CARD('n)", "by simp"], ["proof (state)\nthis:\n  k < ncols (Gram_Schmidt_upt_k A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                foldl Gram_Schmidt_column_k_iarrays_efficient\n                 (matrix_to_iarray A) [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         foldl Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) [0..<Suc (Suc k)]", "have k2: \"Suc k < ncols (Gram_Schmidt_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k < ncols (Gram_Schmidt_upt_k A k)", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. Suc k < ncols (Gram_Schmidt_upt_k A k)", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('n)\n\ngoal (1 subgoal):\n 1. Suc k < CARD('n)", "."], ["proof (state)\nthis:\n  Suc k < ncols (Gram_Schmidt_upt_k A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                foldl Gram_Schmidt_column_k_iarrays_efficient\n                 (matrix_to_iarray A) [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         foldl Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) [0..<Suc (Suc k)]", "have list_rw: \"[0..<Suc (Suc k)] = [0..<Suc k] @ [(Suc k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                foldl Gram_Schmidt_column_k_iarrays_efficient\n                 (matrix_to_iarray A) [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         foldl Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) [0..<Suc (Suc k)]", "have hyp: \"matrix_to_iarray (Gram_Schmidt_upt_k A k) = ?G [0..<Suc k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<Suc k]", "by (metis Suc.hyps Suc.prems Suc_lessD)"], ["proof (state)\nthis:\n  matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n  foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n   [0..<Suc k]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gram_Schmidt_upt_k A k) =\n                foldl Gram_Schmidt_column_k_iarrays_efficient\n                 (matrix_to_iarray A) [0..<Suc k];\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n                         foldl Gram_Schmidt_column_k_iarrays_efficient\n                          (matrix_to_iarray A) [0..<Suc (Suc k)]", "show \"matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) = ?G [0..<Suc (Suc k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<Suc (Suc k)]", "unfolding Gram_Schmidt_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (foldl Gram_Schmidt_column_k A [0..<Suc (Suc k)]) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<Suc (Suc k)]", "unfolding list_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (foldl Gram_Schmidt_column_k A ([0..<Suc k] @ [Suc k])) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     ([0..<Suc k] @ [Suc k])", "unfolding foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (foldl Gram_Schmidt_column_k\n       (foldl Gram_Schmidt_column_k A [0..<Suc k]) [Suc k]) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient\n     (foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n       [0..<Suc k])\n     [Suc k]", "unfolding foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n       (Suc k)) =\n    Gram_Schmidt_column_k_iarrays_efficient\n     (foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n       [0..<Suc k])\n     (Suc k)", "unfolding Gram_Schmidt_upt_k_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    Gram_Schmidt_column_k_iarrays_efficient\n     (foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n       [0..<Suc k])\n     (Suc k)", "unfolding hyp[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    Gram_Schmidt_column_k_iarrays_efficient\n     (matrix_to_iarray (Gram_Schmidt_upt_k A k)) (Suc k)", "using matrix_to_iarray_Gram_Schmidt_column_k_efficient"], ["proof (prove)\nusing this:\n  ?k < ncols ?A \\<Longrightarrow>\n  matrix_to_iarray (Gram_Schmidt_column_k_efficient ?A ?k) =\n  Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray ?A) ?k\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    Gram_Schmidt_column_k_iarrays_efficient\n     (matrix_to_iarray (Gram_Schmidt_upt_k A k)) (Suc k)", "by (metis (no_types) Gram_Schmidt_upt_k_efficient Gram_Schmidt_upt_k_efficient_induction \n      Suc.prems k matrix_to_iarray_Gram_Schmidt_column_k_efficient ncols_def)"], ["proof (state)\nthis:\n  matrix_to_iarray (Gram_Schmidt_upt_k A (Suc k)) =\n  foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n   [0..<Suc (Suc k)]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_Gram_Schmidt_matrix_efficient[code_unfold]:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\" \n  shows \"matrix_to_iarray (Gram_Schmidt_matrix A) \n  = Gram_Schmidt_matrix_iarrays_efficient (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_matrix A) =\n    Gram_Schmidt_matrix_iarrays_efficient (matrix_to_iarray A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_matrix A) =\n    Gram_Schmidt_matrix_iarrays_efficient (matrix_to_iarray A)", "have n: \"ncols A - 1 < ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols A - 1 < ncols A", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('n) - 1 < CARD('n)", "by auto"], ["proof (state)\nthis:\n  ncols A - 1 < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_matrix A) =\n    Gram_Schmidt_matrix_iarrays_efficient (matrix_to_iarray A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ncols A - 1 < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_matrix A) =\n    Gram_Schmidt_matrix_iarrays_efficient (matrix_to_iarray A)", "unfolding Gram_Schmidt_matrix_iarrays_efficient_def Gram_Schmidt_matrix_def"], ["proof (prove)\nusing this:\n  ncols A - 1 < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A (ncols A - 1)) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<ncols_iarray (matrix_to_iarray A)]", "using matrix_to_iarray_Gram_Schmidt_upt_k_efficient[OF n]"], ["proof (prove)\nusing this:\n  ncols A - 1 < ncols A\n  matrix_to_iarray (Gram_Schmidt_upt_k A (ncols A - 1)) =\n  foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n   [0..<Suc (ncols A - 1)]\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gram_Schmidt_upt_k A (ncols A - 1)) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<ncols_iarray (matrix_to_iarray A)]", "unfolding matrix_to_iarray_ncols"], ["proof (prove)\nusing this:\n  ncols_iarray (matrix_to_iarray A) - 1 < ncols_iarray (matrix_to_iarray A)\n  matrix_to_iarray\n   (Gram_Schmidt_upt_k A (ncols_iarray (matrix_to_iarray A) - 1)) =\n  foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n   [0..<Suc (ncols_iarray (matrix_to_iarray A) - 1)]\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (Gram_Schmidt_upt_k A (ncols_iarray (matrix_to_iarray A) - 1)) =\n    foldl Gram_Schmidt_column_k_iarrays_efficient (matrix_to_iarray A)\n     [0..<ncols_iarray (matrix_to_iarray A)]", "by auto"], ["proof (state)\nthis:\n  matrix_to_iarray (Gram_Schmidt_matrix A) =\n  Gram_Schmidt_matrix_iarrays_efficient (matrix_to_iarray A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma QR_decomposition_iarrays_efficient[code]: \n  \"QR_decomposition_iarrays (matrix_to_iarray A) \n  = QR_decomposition_iarrays_efficient (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QR_decomposition_iarrays (matrix_to_iarray A) =\n    QR_decomposition_iarrays_efficient (matrix_to_iarray A)", "unfolding QR_decomposition_iarrays_def QR_decomposition_iarrays_efficient_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (divide_by_norm_iarray\n      (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)),\n     transpose_iarray\n      (divide_by_norm_iarray\n        (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n     matrix_to_iarray A) =\n    (divide_by_norm_iarray\n      (Gram_Schmidt_matrix_iarrays_efficient (matrix_to_iarray A)),\n     transpose_iarray\n      (divide_by_norm_iarray\n        (Gram_Schmidt_matrix_iarrays_efficient (matrix_to_iarray A))) **i\n     matrix_to_iarray A)", "unfolding matrix_to_iarray_Gram_Schmidt_matrix_efficient[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (divide_by_norm_iarray\n      (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)),\n     transpose_iarray\n      (divide_by_norm_iarray\n        (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n     matrix_to_iarray A) =\n    (divide_by_norm_iarray (matrix_to_iarray (Gram_Schmidt_matrix A)),\n     transpose_iarray\n      (divide_by_norm_iarray (matrix_to_iarray (Gram_Schmidt_matrix A))) **i\n     matrix_to_iarray A)", "unfolding matrix_to_iarray_Gram_Schmidt_matrix"], ["proof (prove)\ngoal (1 subgoal):\n 1. (divide_by_norm_iarray\n      (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)),\n     transpose_iarray\n      (divide_by_norm_iarray\n        (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n     matrix_to_iarray A) =\n    (divide_by_norm_iarray\n      (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)),\n     transpose_iarray\n      (divide_by_norm_iarray\n        (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n     matrix_to_iarray A)", ".."], ["", "subsection\\<open>Other code equations that improve the performance\\<close>"], ["", "lemma inner_iarray_code[code]:\n  \"inner_iarray A B = sum_list (map (\\<lambda>n. A !! n * B !! n) [0..<IArray.length A])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bullet>i B =\n    (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<bullet>i B =\n    (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)", "have set_Eq: \"{0..<IArray.length A} = set ([0..<IArray.length A])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<IArray.length A} = set [0..<IArray.length A]", "using atLeastLessThan_upt"], ["proof (prove)\nusing this:\n  {?i..<?j} = set [?i..<?j]\n\ngoal (1 subgoal):\n 1. {0..<IArray.length A} = set [0..<IArray.length A]", "by blast"], ["proof (state)\nthis:\n  {0..<IArray.length A} = set [0..<IArray.length A]\n\ngoal (1 subgoal):\n 1. A \\<bullet>i B =\n    (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)", "have \"inner_iarray A B = sum (\\<lambda>n. A !! n * B !! n) {0..<IArray.length A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bullet>i B = (\\<Sum>n = 0..<IArray.length A. A !! n * B !! n)", "unfolding inner_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n = 0..<IArray.length A. A !! n * B !! n) =\n    (\\<Sum>n = 0..<IArray.length A. A !! n * B !! n)", ".."], ["proof (state)\nthis:\n  A \\<bullet>i B = (\\<Sum>n = 0..<IArray.length A. A !! n * B !! n)\n\ngoal (1 subgoal):\n 1. A \\<bullet>i B =\n    (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)", "also"], ["proof (state)\nthis:\n  A \\<bullet>i B = (\\<Sum>n = 0..<IArray.length A. A !! n * B !! n)\n\ngoal (1 subgoal):\n 1. A \\<bullet>i B =\n    (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)", "have \"... = sum (\\<lambda>n. A !! n * B !! n) (set [0..<IArray.length A])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n = 0..<IArray.length A. A !! n * B !! n) =\n    (\\<Sum>n\\<in>set [0..<IArray.length A]. A !! n * B !! n)", "unfolding set_Eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<in>set [0..<IArray.length A]. A !! n * B !! n) =\n    (\\<Sum>n\\<in>set [0..<IArray.length A]. A !! n * B !! n)", ".."], ["proof (state)\nthis:\n  (\\<Sum>n = 0..<IArray.length A. A !! n * B !! n) =\n  (\\<Sum>n\\<in>set [0..<IArray.length A]. A !! n * B !! n)\n\ngoal (1 subgoal):\n 1. A \\<bullet>i B =\n    (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n = 0..<IArray.length A. A !! n * B !! n) =\n  (\\<Sum>n\\<in>set [0..<IArray.length A]. A !! n * B !! n)\n\ngoal (1 subgoal):\n 1. A \\<bullet>i B =\n    (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)", "have \"... = sum_list (map (\\<lambda>n. A !! n * B !! n) [0..<IArray.length A])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<in>set [0..<IArray.length A]. A !! n * B !! n) =\n    (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)", "unfolding sum_set_upt_conv_sum_list_nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n) =\n    (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)", ".."], ["proof (state)\nthis:\n  (\\<Sum>n\\<in>set [0..<IArray.length A]. A !! n * B !! n) =\n  (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)\n\ngoal (1 subgoal):\n 1. A \\<bullet>i B =\n    (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)", "finally"], ["proof (chain)\npicking this:\n  A \\<bullet>i B =\n  (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<bullet>i B =\n  (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)\n\ngoal (1 subgoal):\n 1. A \\<bullet>i B =\n    (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)", "."], ["proof (state)\nthis:\n  A \\<bullet>i B =\n  (\\<Sum>n\\<leftarrow>[0..<IArray.length A]. A !! n * B !! n)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"Gram_Schmidt_column_k_iarrays_efficient2 A k = \n  tabulate2 (nrows_iarray A) (ncols_iarray A) \n  (let col_k = column_iarray k A;\n       col = (col_k - sum_list (map (\\<lambda>x. ((col_k \\<bullet>i x) / (x \\<bullet>i x)) *\\<^sub>R x) \n              ((List.map (\\<lambda>n. column_iarray n A) [0..<k]))))\n  in (\\<lambda>a b. (if b = k then col else column_iarray b A) !! a))\""], ["", "lemma Gram_Schmidt_column_k_iarrays_efficient_eq[code]: \"Gram_Schmidt_column_k_iarrays_efficient A k \n  = Gram_Schmidt_column_k_iarrays_efficient2 A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k_iarrays_efficient A k =\n    Gram_Schmidt_column_k_iarrays_efficient2 A k", "unfolding Gram_Schmidt_column_k_iarrays_efficient_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tabulate2 (nrows_iarray A) (ncols_iarray A)\n     (\\<lambda>a b.\n         let column_b_A = column_iarray b A\n         in (if b = k\n             then column_b_A -\n                  (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column_iarray n A)\n [0..<b]. (column_b_A \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x)\n             else column_b_A) !!\n            a) =\n    Gram_Schmidt_column_k_iarrays_efficient2 A k", "unfolding Gram_Schmidt_column_k_iarrays_efficient2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tabulate2 (nrows_iarray A) (ncols_iarray A)\n     (\\<lambda>a b.\n         let column_b_A = column_iarray b A\n         in (if b = k\n             then column_b_A -\n                  (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column_iarray n A)\n [0..<b]. (column_b_A \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x)\n             else column_b_A) !!\n            a) =\n    tabulate2 (nrows_iarray A) (ncols_iarray A)\n     (let col_k = column_iarray k A;\n          col =\n            col_k -\n            (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column_iarray n A)\n                                 [0..<\n                                  k]. (col_k \\<bullet>i x /\n (x \\<bullet>i x)) *\\<^sub>R\nx)\n      in (\\<lambda>a b. (if b = k then col else column_iarray b A) !! a))", "unfolding Let_def tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>b.\n              (if b = k\n               then column_iarray b A -\n                    (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column_iarray n A)\n   [0..<b]. (column_iarray b A \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x)\n               else column_iarray b A) !!\n              i)\n          (ncols_iarray A))\n     (nrows_iarray A) =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>b.\n              (if b = k\n               then column_iarray k A -\n                    (\\<Sum>x\\<leftarrow>map (\\<lambda>n. column_iarray n A)\n   [0..<k]. (column_iarray k A \\<bullet>i x / (x \\<bullet>i x)) *\\<^sub>R x)\n               else column_iarray b A) !!\n              i)\n          (ncols_iarray A))\n     (nrows_iarray A)", "by simp"], ["", "end"]]}