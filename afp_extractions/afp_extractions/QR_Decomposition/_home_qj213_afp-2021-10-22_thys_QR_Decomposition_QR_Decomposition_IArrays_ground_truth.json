{"file_name": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition/QR_Decomposition_IArrays.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition", "problem_names": ["lemma vec_to_iarray_norm[code_unfold]:\n  shows \"(norm A) = norm_iarray (vec_to_iarray A)\"", "lemma matrix_to_iarray_divide_by_norm[code_unfold]:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (divide_by_norm A) = divide_by_norm_iarray (matrix_to_iarray A)\"", "lemma matrix_to_iarray_fst_QR_decomposition[code_unfold]:\n  shows \"matrix_to_iarray (fst (QR_decomposition A)) = fst (QR_decomposition_iarrays (matrix_to_iarray A))\"", "lemma matrix_to_iarray_snd_QR_decomposition[code_unfold]:\n  shows \"matrix_to_iarray (snd (QR_decomposition A)) = snd (QR_decomposition_iarrays (matrix_to_iarray A))\"", "lemma matrix_to_iarray_QR_decomposition[code_unfold]:\n  shows \"matrix_to_iarray_pair (QR_decomposition A) =  QR_decomposition_iarrays (matrix_to_iarray A)\""], "translations": [["", "lemma vec_to_iarray_norm[code_unfold]:\n  shows \"(norm A) = norm_iarray (vec_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm A = norm_iarray (vec_to_iarray A)", "unfolding norm_eq_sqrt_inner norm_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (A \\<bullet> A) = sqrt (vec_to_iarray A \\<bullet>i vec_to_iarray A)", "unfolding vec_to_iarray_inner"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (vec_to_iarray A \\<bullet>i vec_to_iarray A) =\n    sqrt (vec_to_iarray A \\<bullet>i vec_to_iarray A)", ".."], ["", "lemma matrix_to_iarray_divide_by_norm[code_unfold]:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (divide_by_norm A) = divide_by_norm_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (divide_by_norm A) =\n    divide_by_norm_iarray (matrix_to_iarray A)", "proof (unfold iarray_exhaust2 list_eq_iff_nth_eq, rule conjI, auto, unfold IArray.sub_def[symmetric] IArray.length_def[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. IArray.length (matrix_to_iarray (divide_by_norm A)) =\n    IArray.length (divide_by_norm_iarray (matrix_to_iarray A))\n 2. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray (divide_by_norm A)) \\<Longrightarrow>\n       IArray.length (matrix_to_iarray (divide_by_norm A) !! i) =\n       IArray.length (divide_by_norm_iarray (matrix_to_iarray A) !! i)\n 3. \\<And>i ia.\n       \\<lbrakk>i < IArray.length (matrix_to_iarray (divide_by_norm A));\n        ia < IArray.length\n              (matrix_to_iarray (divide_by_norm A) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (divide_by_norm A) !! i !! ia =\n                         divide_by_norm_iarray (matrix_to_iarray A) !! i !!\n                         ia", "show\"IArray.length (matrix_to_iarray (divide_by_norm A)) = IArray.length (divide_by_norm_iarray (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (matrix_to_iarray (divide_by_norm A)) =\n    IArray.length (divide_by_norm_iarray (matrix_to_iarray A))", "unfolding matrix_to_iarray_def divide_by_norm_iarray_def tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (vec_to_iarray \\<circ> ($) (divide_by_norm A) \\<circ>\n             mod_type_class.from_nat)\n         [0..<CARD('rows)])) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                ((1 /\n                  norm_iarray\n                   (column_iarray b\n                     (IArray\n                       (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                             mod_type_class.from_nat)\n                         [0..<CARD('rows)])))) *\\<^sub>R\n                 column_iarray b\n                  (IArray\n                    (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                          mod_type_class.from_nat)\n                      [0..<CARD('rows)]))) !!\n                i)\n            (ncols_iarray\n              (IArray\n                (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                      mod_type_class.from_nat)\n                  [0..<CARD('rows)]))))\n       (nrows_iarray\n         (IArray\n           (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                 mod_type_class.from_nat)\n             [0..<CARD('rows)]))))", "unfolding nrows_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (vec_to_iarray \\<circ> ($) (divide_by_norm A) \\<circ>\n             mod_type_class.from_nat)\n         [0..<CARD('rows)])) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                ((1 /\n                  norm_iarray\n                   (column_iarray b\n                     (IArray\n                       (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                             mod_type_class.from_nat)\n                         [0..<CARD('rows)])))) *\\<^sub>R\n                 column_iarray b\n                  (IArray\n                    (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                          mod_type_class.from_nat)\n                      [0..<CARD('rows)]))) !!\n                i)\n            (ncols_iarray\n              (IArray\n                (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                      mod_type_class.from_nat)\n                  [0..<CARD('rows)]))))\n       (IArray.length\n         (IArray\n           (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                 mod_type_class.from_nat)\n             [0..<CARD('rows)]))))", "by auto"], ["proof (state)\nthis:\n  IArray.length (matrix_to_iarray (divide_by_norm A)) =\n  IArray.length (divide_by_norm_iarray (matrix_to_iarray A))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray (divide_by_norm A)) \\<Longrightarrow>\n       IArray.length (matrix_to_iarray (divide_by_norm A) !! i) =\n       IArray.length (divide_by_norm_iarray (matrix_to_iarray A) !! i)\n 2. \\<And>i ia.\n       \\<lbrakk>i < IArray.length (matrix_to_iarray (divide_by_norm A));\n        ia < IArray.length\n              (matrix_to_iarray (divide_by_norm A) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (divide_by_norm A) !! i !! ia =\n                         divide_by_norm_iarray (matrix_to_iarray A) !! i !!\n                         ia", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray (divide_by_norm A)) \\<Longrightarrow>\n       IArray.length (matrix_to_iarray (divide_by_norm A) !! i) =\n       IArray.length (divide_by_norm_iarray (matrix_to_iarray A) !! i)\n 2. \\<And>i ia.\n       \\<lbrakk>i < IArray.length (matrix_to_iarray (divide_by_norm A));\n        ia < IArray.length\n              (matrix_to_iarray (divide_by_norm A) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (divide_by_norm A) !! i !! ia =\n                         divide_by_norm_iarray (matrix_to_iarray A) !! i !!\n                         ia", "assume i:\"i < IArray.length (matrix_to_iarray (divide_by_norm A))\""], ["proof (state)\nthis:\n  i < IArray.length (matrix_to_iarray (divide_by_norm A))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray (divide_by_norm A)) \\<Longrightarrow>\n       IArray.length (matrix_to_iarray (divide_by_norm A) !! i) =\n       IArray.length (divide_by_norm_iarray (matrix_to_iarray A) !! i)\n 2. \\<And>i ia.\n       \\<lbrakk>i < IArray.length (matrix_to_iarray (divide_by_norm A));\n        ia < IArray.length\n              (matrix_to_iarray (divide_by_norm A) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (divide_by_norm A) !! i !! ia =\n                         divide_by_norm_iarray (matrix_to_iarray A) !! i !!\n                         ia", "show \"IArray.length (matrix_to_iarray (divide_by_norm A) !! i) = IArray.length (divide_by_norm_iarray (matrix_to_iarray A) !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (matrix_to_iarray (divide_by_norm A) !! i) =\n    IArray.length (divide_by_norm_iarray (matrix_to_iarray A) !! i)", "unfolding matrix_to_iarray_def divide_by_norm_iarray_def tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (vec_to_iarray \\<circ> ($) (divide_by_norm A) \\<circ>\n             mod_type_class.from_nat)\n         [0..<CARD('rows)]) !!\n      i) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                ((1 /\n                  norm_iarray\n                   (column_iarray b\n                     (IArray\n                       (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                             mod_type_class.from_nat)\n                         [0..<CARD('rows)])))) *\\<^sub>R\n                 column_iarray b\n                  (IArray\n                    (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                          mod_type_class.from_nat)\n                      [0..<CARD('rows)]))) !!\n                i)\n            (ncols_iarray\n              (IArray\n                (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                      mod_type_class.from_nat)\n                  [0..<CARD('rows)]))))\n       (nrows_iarray\n         (IArray\n           (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                 mod_type_class.from_nat)\n             [0..<CARD('rows)]))) !!\n      i)", "unfolding nrows_iarray_def ncols_iarray_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                vec_to_iarray\n                 (divide_by_norm A $ mod_type_class.from_nat x))\n         [0..<CARD('rows)]) !!\n      i) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                ((1 /\n                  norm_iarray\n                   (column_iarray b\n                     (IArray\n                       (map (\\<lambda>x.\n                                vec_to_iarray\n                                 (A $ mod_type_class.from_nat x))\n                         [0..<CARD('rows)])))) *\\<^sub>R\n                 column_iarray b\n                  (IArray\n                    (map (\\<lambda>x.\n                             vec_to_iarray (A $ mod_type_class.from_nat x))\n                      [0..<CARD('rows)]))) !!\n                i)\n            (IArray.length\n              (IArray\n                (map (\\<lambda>x.\n                         vec_to_iarray (A $ mod_type_class.from_nat x))\n                  [0..<CARD('rows)]) !!\n               0)))\n       (IArray.length\n         (IArray\n           (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n             [0..<CARD('rows)]))) !!\n      i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                vec_to_iarray\n                 (divide_by_norm A $ mod_type_class.from_nat x))\n         [0..<CARD('rows)]) !!\n      i) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                ((1 /\n                  norm_iarray\n                   (column_iarray b\n                     (IArray\n                       (map (\\<lambda>x.\n                                vec_to_iarray\n                                 (A $ mod_type_class.from_nat x))\n                         [0..<CARD('rows)])))) *\\<^sub>R\n                 column_iarray b\n                  (IArray\n                    (map (\\<lambda>x.\n                             vec_to_iarray (A $ mod_type_class.from_nat x))\n                      [0..<CARD('rows)]))) !!\n                i)\n            (IArray.length\n              (IArray\n                (map (\\<lambda>x.\n                         vec_to_iarray (A $ mod_type_class.from_nat x))\n                  [0..<CARD('rows)]) !!\n               0)))\n       (IArray.length\n         (IArray\n           (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n             [0..<CARD('rows)]))) !!\n      i)", "have f1: \"i < card (UNIV::'rows set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < CARD('rows)", "by (metis i length_eq_card_rows)"], ["proof (state)\nthis:\n  i < CARD('rows)\n\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                vec_to_iarray\n                 (divide_by_norm A $ mod_type_class.from_nat x))\n         [0..<CARD('rows)]) !!\n      i) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                ((1 /\n                  norm_iarray\n                   (column_iarray b\n                     (IArray\n                       (map (\\<lambda>x.\n                                vec_to_iarray\n                                 (A $ mod_type_class.from_nat x))\n                         [0..<CARD('rows)])))) *\\<^sub>R\n                 column_iarray b\n                  (IArray\n                    (map (\\<lambda>x.\n                             vec_to_iarray (A $ mod_type_class.from_nat x))\n                      [0..<CARD('rows)]))) !!\n                i)\n            (IArray.length\n              (IArray\n                (map (\\<lambda>x.\n                         vec_to_iarray (A $ mod_type_class.from_nat x))\n                  [0..<CARD('rows)]) !!\n               0)))\n       (IArray.length\n         (IArray\n           (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n             [0..<CARD('rows)]))) !!\n      i)", "have \"\\<And>x\\<^sub>4. vec_to_iarray x\\<^sub>4 = IArray (map (\\<lambda>uua. x\\<^sub>4 $ (from_nat uua::'cols)::real) [0..<card (UNIV::'cols set)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>4.\n       vec_to_iarray x\\<^sub>4 =\n       IArray\n        (map (\\<lambda>uua. x\\<^sub>4 $ mod_type_class.from_nat uua)\n          [0..<CARD('cols)])", "by (simp add: vec_to_iarray_def)"], ["proof (state)\nthis:\n  vec_to_iarray ?x\\<^sub>4 =\n  IArray\n   (map (\\<lambda>uua. ?x\\<^sub>4 $ mod_type_class.from_nat uua)\n     [0..<CARD('cols)])\n\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                vec_to_iarray\n                 (divide_by_norm A $ mod_type_class.from_nat x))\n         [0..<CARD('rows)]) !!\n      i) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                ((1 /\n                  norm_iarray\n                   (column_iarray b\n                     (IArray\n                       (map (\\<lambda>x.\n                                vec_to_iarray\n                                 (A $ mod_type_class.from_nat x))\n                         [0..<CARD('rows)])))) *\\<^sub>R\n                 column_iarray b\n                  (IArray\n                    (map (\\<lambda>x.\n                             vec_to_iarray (A $ mod_type_class.from_nat x))\n                      [0..<CARD('rows)]))) !!\n                i)\n            (IArray.length\n              (IArray\n                (map (\\<lambda>x.\n                         vec_to_iarray (A $ mod_type_class.from_nat x))\n                  [0..<CARD('rows)]) !!\n               0)))\n       (IArray.length\n         (IArray\n           (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n             [0..<CARD('rows)]))) !!\n      i)", "hence \"0 < card (UNIV::'rows set) \\<and> length (IArray.list_of (IArray (map (\\<lambda>R. IArray.of_fun (\\<lambda>Ra. ((1 / norm_iarray (column_iarray Ra (IArray (map (\\<lambda>R. vec_to_iarray (A $ from_nat R)) [0..<card (UNIV::'rows set)])))) *\\<^sub>R column_iarray Ra (IArray (map (\\<lambda>R. vec_to_iarray (A $ from_nat R)) [0..<card (UNIV::'rows set)]))) !! R) (card (UNIV::'cols set))) [0..<card (UNIV::'rows set)]) !! i)) = length (IArray.list_of (IArray (map (\\<lambda>R. vec_to_iarray (divide_by_norm A $ from_nat R)) [0..<card (UNIV::'rows set)]) !! i))\""], ["proof (prove)\nusing this:\n  vec_to_iarray ?x\\<^sub>4 =\n  IArray\n   (map (\\<lambda>uua. ?x\\<^sub>4 $ mod_type_class.from_nat uua)\n     [0..<CARD('cols)])\n\ngoal (1 subgoal):\n 1. 0 < CARD('rows) \\<and>\n    length\n     (IArray.list_of\n       (IArray\n         (map (\\<lambda>R.\n                  IArray.of_fun\n                   (\\<lambda>Ra.\n                       ((1 /\n                         norm_iarray\n                          (column_iarray Ra\n                            (IArray\n                              (map (\\<lambda>R.\n vec_to_iarray (A $ mod_type_class.from_nat R))\n                                [0..<CARD('rows)])))) *\\<^sub>R\n                        column_iarray Ra\n                         (IArray\n                           (map (\\<lambda>R.\n                                    vec_to_iarray\n                                     (A $ mod_type_class.from_nat R))\n                             [0..<CARD('rows)]))) !!\n                       R)\n                   CARD('cols))\n           [0..<CARD('rows)]) !!\n        i)) =\n    length\n     (IArray.list_of\n       (IArray\n         (map (\\<lambda>R.\n                  vec_to_iarray\n                   (divide_by_norm A $ mod_type_class.from_nat R))\n           [0..<CARD('rows)]) !!\n        i))", "using f1"], ["proof (prove)\nusing this:\n  vec_to_iarray ?x\\<^sub>4 =\n  IArray\n   (map (\\<lambda>uua. ?x\\<^sub>4 $ mod_type_class.from_nat uua)\n     [0..<CARD('cols)])\n  i < CARD('rows)\n\ngoal (1 subgoal):\n 1. 0 < CARD('rows) \\<and>\n    length\n     (IArray.list_of\n       (IArray\n         (map (\\<lambda>R.\n                  IArray.of_fun\n                   (\\<lambda>Ra.\n                       ((1 /\n                         norm_iarray\n                          (column_iarray Ra\n                            (IArray\n                              (map (\\<lambda>R.\n vec_to_iarray (A $ mod_type_class.from_nat R))\n                                [0..<CARD('rows)])))) *\\<^sub>R\n                        column_iarray Ra\n                         (IArray\n                           (map (\\<lambda>R.\n                                    vec_to_iarray\n                                     (A $ mod_type_class.from_nat R))\n                             [0..<CARD('rows)]))) !!\n                       R)\n                   CARD('cols))\n           [0..<CARD('rows)]) !!\n        i)) =\n    length\n     (IArray.list_of\n       (IArray\n         (map (\\<lambda>R.\n                  vec_to_iarray\n                   (divide_by_norm A $ mod_type_class.from_nat R))\n           [0..<CARD('rows)]) !!\n        i))", "by auto"], ["proof (state)\nthis:\n  0 < CARD('rows) \\<and>\n  length\n   (IArray.list_of\n     (IArray\n       (map (\\<lambda>R.\n                IArray.of_fun\n                 (\\<lambda>Ra.\n                     ((1 /\n                       norm_iarray\n                        (column_iarray Ra\n                          (IArray\n                            (map (\\<lambda>R.\n                                     vec_to_iarray\n(A $ mod_type_class.from_nat R))\n                              [0..<CARD('rows)])))) *\\<^sub>R\n                      column_iarray Ra\n                       (IArray\n                         (map (\\<lambda>R.\n                                  vec_to_iarray\n                                   (A $ mod_type_class.from_nat R))\n                           [0..<CARD('rows)]))) !!\n                     R)\n                 CARD('cols))\n         [0..<CARD('rows)]) !!\n      i)) =\n  length\n   (IArray.list_of\n     (IArray\n       (map (\\<lambda>R.\n                vec_to_iarray\n                 (divide_by_norm A $ mod_type_class.from_nat R))\n         [0..<CARD('rows)]) !!\n      i))\n\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                vec_to_iarray\n                 (divide_by_norm A $ mod_type_class.from_nat x))\n         [0..<CARD('rows)]) !!\n      i) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                ((1 /\n                  norm_iarray\n                   (column_iarray b\n                     (IArray\n                       (map (\\<lambda>x.\n                                vec_to_iarray\n                                 (A $ mod_type_class.from_nat x))\n                         [0..<CARD('rows)])))) *\\<^sub>R\n                 column_iarray b\n                  (IArray\n                    (map (\\<lambda>x.\n                             vec_to_iarray (A $ mod_type_class.from_nat x))\n                      [0..<CARD('rows)]))) !!\n                i)\n            (IArray.length\n              (IArray\n                (map (\\<lambda>x.\n                         vec_to_iarray (A $ mod_type_class.from_nat x))\n                  [0..<CARD('rows)]) !!\n               0)))\n       (IArray.length\n         (IArray\n           (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n             [0..<CARD('rows)]))) !!\n      i)", "thus \"IArray.length (IArray (map (\\<lambda>x. vec_to_iarray (divide_by_norm A $ from_nat x)) [0..<card (UNIV::'rows set)]) !! i) = IArray.length (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<lambda>b. ((1 / norm_iarray (column_iarray b (IArray (map (\\<lambda>x. vec_to_iarray (A $ from_nat x)) [0..<card (UNIV::'rows set)])))) *\\<^sub>R column_iarray b (IArray (map (\\<lambda>x. vec_to_iarray (A $ from_nat x)) [0..<card (UNIV::'rows set)]))) !! i) (IArray.length (IArray (map (\\<lambda>x. vec_to_iarray (A $ from_nat x)) [0..<card (UNIV::'rows set)]) !! 0))) (IArray.length (IArray (map (\\<lambda>x. vec_to_iarray (A $ from_nat x)) [0..<card (UNIV::'rows set)]))) !! i)\""], ["proof (prove)\nusing this:\n  0 < CARD('rows) \\<and>\n  length\n   (IArray.list_of\n     (IArray\n       (map (\\<lambda>R.\n                IArray.of_fun\n                 (\\<lambda>Ra.\n                     ((1 /\n                       norm_iarray\n                        (column_iarray Ra\n                          (IArray\n                            (map (\\<lambda>R.\n                                     vec_to_iarray\n(A $ mod_type_class.from_nat R))\n                              [0..<CARD('rows)])))) *\\<^sub>R\n                      column_iarray Ra\n                       (IArray\n                         (map (\\<lambda>R.\n                                  vec_to_iarray\n                                   (A $ mod_type_class.from_nat R))\n                           [0..<CARD('rows)]))) !!\n                     R)\n                 CARD('cols))\n         [0..<CARD('rows)]) !!\n      i)) =\n  length\n   (IArray.list_of\n     (IArray\n       (map (\\<lambda>R.\n                vec_to_iarray\n                 (divide_by_norm A $ mod_type_class.from_nat R))\n         [0..<CARD('rows)]) !!\n      i))\n\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                vec_to_iarray\n                 (divide_by_norm A $ mod_type_class.from_nat x))\n         [0..<CARD('rows)]) !!\n      i) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun\n            (\\<lambda>b.\n                ((1 /\n                  norm_iarray\n                   (column_iarray b\n                     (IArray\n                       (map (\\<lambda>x.\n                                vec_to_iarray\n                                 (A $ mod_type_class.from_nat x))\n                         [0..<CARD('rows)])))) *\\<^sub>R\n                 column_iarray b\n                  (IArray\n                    (map (\\<lambda>x.\n                             vec_to_iarray (A $ mod_type_class.from_nat x))\n                      [0..<CARD('rows)]))) !!\n                i)\n            (IArray.length\n              (IArray\n                (map (\\<lambda>x.\n                         vec_to_iarray (A $ mod_type_class.from_nat x))\n                  [0..<CARD('rows)]) !!\n               0)))\n       (IArray.length\n         (IArray\n           (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n             [0..<CARD('rows)]))) !!\n      i)", "by (simp add: vec_to_iarray_def)"], ["proof (state)\nthis:\n  IArray.length\n   (IArray\n     (map (\\<lambda>x.\n              vec_to_iarray (divide_by_norm A $ mod_type_class.from_nat x))\n       [0..<CARD('rows)]) !!\n    i) =\n  IArray.length\n   (IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>b.\n              ((1 /\n                norm_iarray\n                 (column_iarray b\n                   (IArray\n                     (map (\\<lambda>x.\n                              vec_to_iarray (A $ mod_type_class.from_nat x))\n                       [0..<CARD('rows)])))) *\\<^sub>R\n               column_iarray b\n                (IArray\n                  (map (\\<lambda>x.\n                           vec_to_iarray (A $ mod_type_class.from_nat x))\n                    [0..<CARD('rows)]))) !!\n              i)\n          (IArray.length\n            (IArray\n              (map (\\<lambda>x.\n                       vec_to_iarray (A $ mod_type_class.from_nat x))\n                [0..<CARD('rows)]) !!\n             0)))\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n           [0..<CARD('rows)]))) !!\n    i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IArray.length (matrix_to_iarray (divide_by_norm A) !! i) =\n  IArray.length (divide_by_norm_iarray (matrix_to_iarray A) !! i)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length (matrix_to_iarray (divide_by_norm A));\n        ia < IArray.length\n              (matrix_to_iarray (divide_by_norm A) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (divide_by_norm A) !! i !! ia =\n                         divide_by_norm_iarray (matrix_to_iarray A) !! i !!\n                         ia", "fix ia"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length (matrix_to_iarray (divide_by_norm A));\n        ia < IArray.length\n              (matrix_to_iarray (divide_by_norm A) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (divide_by_norm A) !! i !! ia =\n                         divide_by_norm_iarray (matrix_to_iarray A) !! i !!\n                         ia", "assume ia: \"ia < IArray.length (matrix_to_iarray (divide_by_norm A) !! i)\""], ["proof (state)\nthis:\n  ia < IArray.length (matrix_to_iarray (divide_by_norm A) !! i)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length (matrix_to_iarray (divide_by_norm A));\n        ia < IArray.length\n              (matrix_to_iarray (divide_by_norm A) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (divide_by_norm A) !! i !! ia =\n                         divide_by_norm_iarray (matrix_to_iarray A) !! i !!\n                         ia", "have i_nrows: \"i<nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < nrows A", "using i"], ["proof (prove)\nusing this:\n  i < IArray.length (matrix_to_iarray (divide_by_norm A))\n\ngoal (1 subgoal):\n 1. i < nrows A", "unfolding matrix_to_iarray_def nrows_def"], ["proof (prove)\nusing this:\n  i < IArray.length\n       (IArray\n         (map (vec_to_iarray \\<circ> ($) (divide_by_norm A) \\<circ>\n               mod_type_class.from_nat)\n           [0..<CARD('rows)]))\n\ngoal (1 subgoal):\n 1. i < CARD('rows)", "by auto"], ["proof (state)\nthis:\n  i < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length (matrix_to_iarray (divide_by_norm A));\n        ia < IArray.length\n              (matrix_to_iarray (divide_by_norm A) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (divide_by_norm A) !! i !! ia =\n                         divide_by_norm_iarray (matrix_to_iarray A) !! i !!\n                         ia", "have ia_ncols: \"ia<ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia < ncols A", "using ia"], ["proof (prove)\nusing this:\n  ia < IArray.length (matrix_to_iarray (divide_by_norm A) !! i)\n\ngoal (1 subgoal):\n 1. ia < ncols A", "unfolding matrix_to_iarray_def o_def vec_to_iarray_def ncols_def"], ["proof (prove)\nusing this:\n  ia < IArray.length\n        (IArray\n          (map (\\<lambda>x.\n                   IArray.of_fun\n                    (\\<lambda>i.\n                        divide_by_norm A $ mod_type_class.from_nat x $\n                        mod_type_class.from_nat i)\n                    CARD('cols))\n            [0..<CARD('rows)]) !!\n         i)\n\ngoal (1 subgoal):\n 1. ia < CARD('cols)", "by (auto, metis (no_types) Ex_list_of_length i_nrows length_map list_of.simps map_nth nrows_def nth_map)"], ["proof (state)\nthis:\n  ia < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length (matrix_to_iarray (divide_by_norm A));\n        ia < IArray.length\n              (matrix_to_iarray (divide_by_norm A) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (divide_by_norm A) !! i !! ia =\n                         divide_by_norm_iarray (matrix_to_iarray A) !! i !!\n                         ia", "have i_nrows_iarray: \"i<nrows_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < nrows_iarray (matrix_to_iarray A)", "using i_nrows"], ["proof (prove)\nusing this:\n  i < nrows A\n\ngoal (1 subgoal):\n 1. i < nrows_iarray (matrix_to_iarray A)", "by (metis matrix_to_iarray_nrows)"], ["proof (state)\nthis:\n  i < nrows_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length (matrix_to_iarray (divide_by_norm A));\n        ia < IArray.length\n              (matrix_to_iarray (divide_by_norm A) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (divide_by_norm A) !! i !! ia =\n                         divide_by_norm_iarray (matrix_to_iarray A) !! i !!\n                         ia", "have ia_ncols_iarray: \"ia<ncols_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia < ncols_iarray (matrix_to_iarray A)", "using ia_ncols"], ["proof (prove)\nusing this:\n  ia < ncols A\n\ngoal (1 subgoal):\n 1. ia < ncols_iarray (matrix_to_iarray A)", "by (metis matrix_to_iarray_ncols)"], ["proof (state)\nthis:\n  ia < ncols_iarray (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>i < IArray.length (matrix_to_iarray (divide_by_norm A));\n        ia < IArray.length\n              (matrix_to_iarray (divide_by_norm A) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (divide_by_norm A) !! i !! ia =\n                         divide_by_norm_iarray (matrix_to_iarray A) !! i !!\n                         ia", "show \"matrix_to_iarray (divide_by_norm A) !! i !! ia \n    = divide_by_norm_iarray (matrix_to_iarray A) !! i !! ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (divide_by_norm A) !! i !! ia =\n    divide_by_norm_iarray (matrix_to_iarray A) !! i !! ia", "unfolding divide_by_norm_def divide_by_norm_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (\\<chi>a b. Projections.normalize (column b A) $ a) !!\n    i !!\n    ia =\n    tabulate2 (nrows_iarray (matrix_to_iarray A))\n     (ncols_iarray (matrix_to_iarray A))\n     (\\<lambda>a b.\n         ((1 / norm_iarray (column_iarray b (matrix_to_iarray A))) *\\<^sub>R\n          column_iarray b (matrix_to_iarray A)) !!\n         a) !!\n    i !!\n    ia", "unfolding matrix_to_iarray_nth[of _ \"from_nat i::'rows\" \"from_nat ia::'cols\",\n      unfolded to_nat_from_nat_id[OF i_nrows[unfolded nrows_def]]\n      to_nat_from_nat_id[OF ia_ncols[unfolded ncols_def]]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b. Projections.normalize (column b A) $ a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    tabulate2 (nrows_iarray (matrix_to_iarray A))\n     (ncols_iarray (matrix_to_iarray A))\n     (\\<lambda>a b.\n         ((1 / norm_iarray (column_iarray b (matrix_to_iarray A))) *\\<^sub>R\n          column_iarray b (matrix_to_iarray A)) !!\n         a) !!\n    i !!\n    ia", "unfolding tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b. Projections.normalize (column b A) $ a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>b.\n              ((1 /\n                norm_iarray\n                 (column_iarray b (matrix_to_iarray A))) *\\<^sub>R\n               column_iarray b (matrix_to_iarray A)) !!\n              i)\n          (ncols_iarray (matrix_to_iarray A)))\n     (nrows_iarray (matrix_to_iarray A)) !!\n    i !!\n    ia", "unfolding of_fun_nth[OF i_nrows_iarray]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b. Projections.normalize (column b A) $ a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    IArray.of_fun\n     (\\<lambda>b.\n         ((1 / norm_iarray (column_iarray b (matrix_to_iarray A))) *\\<^sub>R\n          column_iarray b (matrix_to_iarray A)) !!\n         i)\n     (ncols_iarray (matrix_to_iarray A)) !!\n    ia", "unfolding of_fun_nth[OF ia_ncols_iarray]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b. Projections.normalize (column b A) $ a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    ((1 / norm_iarray (column_iarray ia (matrix_to_iarray A))) *\\<^sub>R\n     column_iarray ia (matrix_to_iarray A)) !!\n    i", "unfolding vec_to_iarray_column'[OF ia_ncols, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b. Projections.normalize (column b A) $ a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    ((1 /\n      norm_iarray\n       (vec_to_iarray (column (mod_type_class.from_nat ia) A))) *\\<^sub>R\n     vec_to_iarray (column (mod_type_class.from_nat ia) A)) !!\n    i", "unfolding vec_to_iarray_norm[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b. Projections.normalize (column b A) $ a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    ((1 / norm (column (mod_type_class.from_nat ia) A)) *\\<^sub>R\n     vec_to_iarray (column (mod_type_class.from_nat ia) A)) !!\n    i", "unfolding vector_scaleR_component"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b. Projections.normalize (column b A) $ a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    ((1 / norm (column (mod_type_class.from_nat ia) A)) *\\<^sub>R\n     vec_to_iarray (column (mod_type_class.from_nat ia) A)) !!\n    i", "unfolding vec_to_iarray_scaleR[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b. Projections.normalize (column b A) $ a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    vec_to_iarray\n     ((1 / norm (column (mod_type_class.from_nat ia) A)) *\\<^sub>R\n      column (mod_type_class.from_nat ia) A) !!\n    i", "unfolding vec_to_iarray_nth[OF i_nrows[unfolded nrows_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b. Projections.normalize (column b A) $ a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    ((1 / norm (column (mod_type_class.from_nat ia) A)) *\\<^sub>R\n     column (mod_type_class.from_nat ia) A) $\n    mod_type_class.from_nat i", "unfolding normalize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>a b. ((1 / norm (column b A)) *\\<^sub>R column b A) $ a) $\n    mod_type_class.from_nat i $\n    mod_type_class.from_nat ia =\n    ((1 / norm (column (mod_type_class.from_nat ia) A)) *\\<^sub>R\n     column (mod_type_class.from_nat ia) A) $\n    mod_type_class.from_nat i", "by auto"], ["proof (state)\nthis:\n  matrix_to_iarray (divide_by_norm A) !! i !! ia =\n  divide_by_norm_iarray (matrix_to_iarray A) !! i !! ia\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_fst_QR_decomposition[code_unfold]:\n  shows \"matrix_to_iarray (fst (QR_decomposition A)) = fst (QR_decomposition_iarrays (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (fst (QR_decomposition A)) =\n    fst (QR_decomposition_iarrays (matrix_to_iarray A))", "proof (unfold iarray_exhaust2 list_eq_iff_nth_eq, rule conjI, auto, unfold IArray.sub_def[symmetric] IArray.length_def[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. IArray.length (matrix_to_iarray (fst (QR_decomposition A))) =\n    IArray.length (fst (QR_decomposition_iarrays (matrix_to_iarray A)))\n 2. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray (fst (QR_decomposition A))) \\<Longrightarrow>\n       IArray.length (matrix_to_iarray (fst (QR_decomposition A)) !! i) =\n       IArray.length\n        (fst (QR_decomposition_iarrays (matrix_to_iarray A)) !! i)\n 3. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (fst (QR_decomposition A)));\n        ia < IArray.length\n              (matrix_to_iarray (fst (QR_decomposition A)) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (fst (QR_decomposition A)) !! i !!\n                         ia =\n                         fst (QR_decomposition_iarrays\n                               (matrix_to_iarray A)) !!\n                         i !!\n                         ia", "fix i ia"], ["proof (state)\ngoal (3 subgoals):\n 1. IArray.length (matrix_to_iarray (fst (QR_decomposition A))) =\n    IArray.length (fst (QR_decomposition_iarrays (matrix_to_iarray A)))\n 2. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray (fst (QR_decomposition A))) \\<Longrightarrow>\n       IArray.length (matrix_to_iarray (fst (QR_decomposition A)) !! i) =\n       IArray.length\n        (fst (QR_decomposition_iarrays (matrix_to_iarray A)) !! i)\n 3. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (fst (QR_decomposition A)));\n        ia < IArray.length\n              (matrix_to_iarray (fst (QR_decomposition A)) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (fst (QR_decomposition A)) !! i !!\n                         ia =\n                         fst (QR_decomposition_iarrays\n                               (matrix_to_iarray A)) !!\n                         i !!\n                         ia", "show \"IArray.length (matrix_to_iarray (fst (QR_decomposition A))) \n    = IArray.length (fst (QR_decomposition_iarrays (matrix_to_iarray A)))\"\n    and \"IArray.length (matrix_to_iarray (fst (QR_decomposition A)) !! i) \n    = IArray.length (fst (QR_decomposition_iarrays (matrix_to_iarray A)) !! i)\"\n    and \"matrix_to_iarray (fst (QR_decomposition A)) !! i !! ia \n    = fst (QR_decomposition_iarrays (matrix_to_iarray A)) !! i !! ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (matrix_to_iarray (fst (QR_decomposition A))) =\n    IArray.length (fst (QR_decomposition_iarrays (matrix_to_iarray A))) &&&\n    IArray.length (matrix_to_iarray (fst (QR_decomposition A)) !! i) =\n    IArray.length\n     (fst (QR_decomposition_iarrays (matrix_to_iarray A)) !! i) &&&\n    matrix_to_iarray (fst (QR_decomposition A)) !! i !! ia =\n    fst (QR_decomposition_iarrays (matrix_to_iarray A)) !! i !! ia", "unfolding QR_decomposition_def QR_decomposition_iarrays_def Let_def fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (matrix_to_iarray (divide_by_norm (Gram_Schmidt_matrix A))) =\n    IArray.length\n     (divide_by_norm_iarray\n       (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) &&&\n    IArray.length\n     (matrix_to_iarray (divide_by_norm (Gram_Schmidt_matrix A)) !! i) =\n    IArray.length\n     (divide_by_norm_iarray\n       (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)) !!\n      i) &&&\n    matrix_to_iarray (divide_by_norm (Gram_Schmidt_matrix A)) !! i !! ia =\n    divide_by_norm_iarray\n     (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)) !!\n    i !!\n    ia", "unfolding matrix_to_iarray_divide_by_norm"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (divide_by_norm_iarray (matrix_to_iarray (Gram_Schmidt_matrix A))) =\n    IArray.length\n     (divide_by_norm_iarray\n       (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) &&&\n    IArray.length\n     (divide_by_norm_iarray (matrix_to_iarray (Gram_Schmidt_matrix A)) !!\n      i) =\n    IArray.length\n     (divide_by_norm_iarray\n       (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)) !!\n      i) &&&\n    divide_by_norm_iarray (matrix_to_iarray (Gram_Schmidt_matrix A)) !! i !!\n    ia =\n    divide_by_norm_iarray\n     (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)) !!\n    i !!\n    ia", "unfolding matrix_to_iarray_Gram_Schmidt_matrix"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (divide_by_norm_iarray\n       (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) =\n    IArray.length\n     (divide_by_norm_iarray\n       (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) &&&\n    IArray.length\n     (divide_by_norm_iarray\n       (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)) !!\n      i) =\n    IArray.length\n     (divide_by_norm_iarray\n       (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)) !!\n      i) &&&\n    divide_by_norm_iarray\n     (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)) !!\n    i !!\n    ia =\n    divide_by_norm_iarray\n     (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A)) !!\n    i !!\n    ia", "by rule+"], ["proof (state)\nthis:\n  IArray.length (matrix_to_iarray (fst (QR_decomposition A))) =\n  IArray.length (fst (QR_decomposition_iarrays (matrix_to_iarray A)))\n  IArray.length (matrix_to_iarray (fst (QR_decomposition A)) !! i) =\n  IArray.length (fst (QR_decomposition_iarrays (matrix_to_iarray A)) !! i)\n  matrix_to_iarray (fst (QR_decomposition A)) !! i !! ia =\n  fst (QR_decomposition_iarrays (matrix_to_iarray A)) !! i !! ia\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_snd_QR_decomposition[code_unfold]:\n  shows \"matrix_to_iarray (snd (QR_decomposition A)) = snd (QR_decomposition_iarrays (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (snd (QR_decomposition A)) =\n    snd (QR_decomposition_iarrays (matrix_to_iarray A))", "proof (unfold iarray_exhaust2 list_eq_iff_nth_eq, rule conjI, auto, unfold IArray.sub_def[symmetric] IArray.length_def[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. IArray.length (matrix_to_iarray (snd (QR_decomposition A))) =\n    IArray.length (snd (QR_decomposition_iarrays (matrix_to_iarray A)))\n 2. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray (snd (QR_decomposition A))) \\<Longrightarrow>\n       IArray.length (matrix_to_iarray (snd (QR_decomposition A)) !! i) =\n       IArray.length\n        (snd (QR_decomposition_iarrays (matrix_to_iarray A)) !! i)\n 3. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (snd (QR_decomposition A)));\n        ia < IArray.length\n              (matrix_to_iarray (snd (QR_decomposition A)) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (snd (QR_decomposition A)) !! i !!\n                         ia =\n                         snd (QR_decomposition_iarrays\n                               (matrix_to_iarray A)) !!\n                         i !!\n                         ia", "fix i ia"], ["proof (state)\ngoal (3 subgoals):\n 1. IArray.length (matrix_to_iarray (snd (QR_decomposition A))) =\n    IArray.length (snd (QR_decomposition_iarrays (matrix_to_iarray A)))\n 2. \\<And>i.\n       i < IArray.length\n            (matrix_to_iarray (snd (QR_decomposition A))) \\<Longrightarrow>\n       IArray.length (matrix_to_iarray (snd (QR_decomposition A)) !! i) =\n       IArray.length\n        (snd (QR_decomposition_iarrays (matrix_to_iarray A)) !! i)\n 3. \\<And>i ia.\n       \\<lbrakk>i < IArray.length\n                     (matrix_to_iarray (snd (QR_decomposition A)));\n        ia < IArray.length\n              (matrix_to_iarray (snd (QR_decomposition A)) !! i)\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (snd (QR_decomposition A)) !! i !!\n                         ia =\n                         snd (QR_decomposition_iarrays\n                               (matrix_to_iarray A)) !!\n                         i !!\n                         ia", "show \"IArray.length (matrix_to_iarray (snd (QR_decomposition A)))\n    = IArray.length (snd (QR_decomposition_iarrays (matrix_to_iarray A)))\"\n    and \"IArray.length (matrix_to_iarray (snd (QR_decomposition A)) !! i) \n    = IArray.length (snd (QR_decomposition_iarrays (matrix_to_iarray A)) !! i)\" \n    and \"matrix_to_iarray (snd (QR_decomposition A)) !! i !! ia \n    = snd (QR_decomposition_iarrays (matrix_to_iarray A)) !! i !! ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (matrix_to_iarray (snd (QR_decomposition A))) =\n    IArray.length (snd (QR_decomposition_iarrays (matrix_to_iarray A))) &&&\n    IArray.length (matrix_to_iarray (snd (QR_decomposition A)) !! i) =\n    IArray.length\n     (snd (QR_decomposition_iarrays (matrix_to_iarray A)) !! i) &&&\n    matrix_to_iarray (snd (QR_decomposition A)) !! i !! ia =\n    snd (QR_decomposition_iarrays (matrix_to_iarray A)) !! i !! ia", "unfolding QR_decomposition_iarrays_def QR_decomposition_def Let_def snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (matrix_to_iarray\n       (Finite_Cartesian_Product.transpose\n         (divide_by_norm (Gram_Schmidt_matrix A)) **\n        A)) =\n    IArray.length\n     (transpose_iarray\n       (divide_by_norm_iarray\n         (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n      matrix_to_iarray A) &&&\n    IArray.length\n     (matrix_to_iarray\n       (Finite_Cartesian_Product.transpose\n         (divide_by_norm (Gram_Schmidt_matrix A)) **\n        A) !!\n      i) =\n    IArray.length\n     ((transpose_iarray\n        (divide_by_norm_iarray\n          (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n       matrix_to_iarray A) !!\n      i) &&&\n    matrix_to_iarray\n     (Finite_Cartesian_Product.transpose\n       (divide_by_norm (Gram_Schmidt_matrix A)) **\n      A) !!\n    i !!\n    ia =\n    (transpose_iarray\n      (divide_by_norm_iarray\n        (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n     matrix_to_iarray A) !!\n    i !!\n    ia", "unfolding matrix_to_iarray_matrix_matrix_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (matrix_to_iarray\n       (Finite_Cartesian_Product.transpose\n         (divide_by_norm (Gram_Schmidt_matrix A))) **i\n      matrix_to_iarray A) =\n    IArray.length\n     (transpose_iarray\n       (divide_by_norm_iarray\n         (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n      matrix_to_iarray A) &&&\n    IArray.length\n     ((matrix_to_iarray\n        (Finite_Cartesian_Product.transpose\n          (divide_by_norm (Gram_Schmidt_matrix A))) **i\n       matrix_to_iarray A) !!\n      i) =\n    IArray.length\n     ((transpose_iarray\n        (divide_by_norm_iarray\n          (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n       matrix_to_iarray A) !!\n      i) &&&\n    (matrix_to_iarray\n      (Finite_Cartesian_Product.transpose\n        (divide_by_norm (Gram_Schmidt_matrix A))) **i\n     matrix_to_iarray A) !!\n    i !!\n    ia =\n    (transpose_iarray\n      (divide_by_norm_iarray\n        (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n     matrix_to_iarray A) !!\n    i !!\n    ia", "unfolding matrix_to_iarray_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (transpose_iarray\n       (matrix_to_iarray (divide_by_norm (Gram_Schmidt_matrix A))) **i\n      matrix_to_iarray A) =\n    IArray.length\n     (transpose_iarray\n       (divide_by_norm_iarray\n         (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n      matrix_to_iarray A) &&&\n    IArray.length\n     ((transpose_iarray\n        (matrix_to_iarray (divide_by_norm (Gram_Schmidt_matrix A))) **i\n       matrix_to_iarray A) !!\n      i) =\n    IArray.length\n     ((transpose_iarray\n        (divide_by_norm_iarray\n          (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n       matrix_to_iarray A) !!\n      i) &&&\n    (transpose_iarray\n      (matrix_to_iarray (divide_by_norm (Gram_Schmidt_matrix A))) **i\n     matrix_to_iarray A) !!\n    i !!\n    ia =\n    (transpose_iarray\n      (divide_by_norm_iarray\n        (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n     matrix_to_iarray A) !!\n    i !!\n    ia", "unfolding matrix_to_iarray_divide_by_norm"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (transpose_iarray\n       (divide_by_norm_iarray\n         (matrix_to_iarray (Gram_Schmidt_matrix A))) **i\n      matrix_to_iarray A) =\n    IArray.length\n     (transpose_iarray\n       (divide_by_norm_iarray\n         (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n      matrix_to_iarray A) &&&\n    IArray.length\n     ((transpose_iarray\n        (divide_by_norm_iarray\n          (matrix_to_iarray (Gram_Schmidt_matrix A))) **i\n       matrix_to_iarray A) !!\n      i) =\n    IArray.length\n     ((transpose_iarray\n        (divide_by_norm_iarray\n          (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n       matrix_to_iarray A) !!\n      i) &&&\n    (transpose_iarray\n      (divide_by_norm_iarray (matrix_to_iarray (Gram_Schmidt_matrix A))) **i\n     matrix_to_iarray A) !!\n    i !!\n    ia =\n    (transpose_iarray\n      (divide_by_norm_iarray\n        (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n     matrix_to_iarray A) !!\n    i !!\n    ia", "unfolding matrix_to_iarray_Gram_Schmidt_matrix"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (transpose_iarray\n       (divide_by_norm_iarray\n         (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n      matrix_to_iarray A) =\n    IArray.length\n     (transpose_iarray\n       (divide_by_norm_iarray\n         (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n      matrix_to_iarray A) &&&\n    IArray.length\n     ((transpose_iarray\n        (divide_by_norm_iarray\n          (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n       matrix_to_iarray A) !!\n      i) =\n    IArray.length\n     ((transpose_iarray\n        (divide_by_norm_iarray\n          (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n       matrix_to_iarray A) !!\n      i) &&&\n    (transpose_iarray\n      (divide_by_norm_iarray\n        (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n     matrix_to_iarray A) !!\n    i !!\n    ia =\n    (transpose_iarray\n      (divide_by_norm_iarray\n        (Gram_Schmidt_matrix_iarrays (matrix_to_iarray A))) **i\n     matrix_to_iarray A) !!\n    i !!\n    ia", "by rule+"], ["proof (state)\nthis:\n  IArray.length (matrix_to_iarray (snd (QR_decomposition A))) =\n  IArray.length (snd (QR_decomposition_iarrays (matrix_to_iarray A)))\n  IArray.length (matrix_to_iarray (snd (QR_decomposition A)) !! i) =\n  IArray.length (snd (QR_decomposition_iarrays (matrix_to_iarray A)) !! i)\n  matrix_to_iarray (snd (QR_decomposition A)) !! i !! ia =\n  snd (QR_decomposition_iarrays (matrix_to_iarray A)) !! i !! ia\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"matrix_to_iarray_pair X = (matrix_to_iarray (fst X), matrix_to_iarray (snd X))\""], ["", "lemma matrix_to_iarray_QR_decomposition[code_unfold]:\n  shows \"matrix_to_iarray_pair (QR_decomposition A) =  QR_decomposition_iarrays (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray_pair (QR_decomposition A) =\n    QR_decomposition_iarrays (matrix_to_iarray A)", "unfolding matrix_to_iarray_pair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (matrix_to_iarray (fst (QR_decomposition A)),\n     matrix_to_iarray (snd (QR_decomposition A))) =\n    QR_decomposition_iarrays (matrix_to_iarray A)", "unfolding matrix_to_iarray_fst_QR_decomposition"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (QR_decomposition_iarrays (matrix_to_iarray A)),\n     matrix_to_iarray (snd (QR_decomposition A))) =\n    QR_decomposition_iarrays (matrix_to_iarray A)", "unfolding matrix_to_iarray_snd_QR_decomposition"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (QR_decomposition_iarrays (matrix_to_iarray A)),\n     snd (QR_decomposition_iarrays (matrix_to_iarray A))) =\n    QR_decomposition_iarrays (matrix_to_iarray A)", "by simp"], ["", "end"]]}