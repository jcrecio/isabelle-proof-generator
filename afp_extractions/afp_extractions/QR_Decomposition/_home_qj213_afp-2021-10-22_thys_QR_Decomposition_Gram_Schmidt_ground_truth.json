{"file_name": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition/Gram_Schmidt.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition", "problem_names": ["lemma Gram_Schmidt_cons:\n  \"Gram_Schmidt (a#xs) = Gram_Schmidt_step a (Gram_Schmidt xs)\"", "lemma basis_orthogonal':\n  fixes xs::\"('a::{real_inner}^'b) list\"\n  shows \"length (Gram_Schmidt xs) = length (xs) \\<and>\n        span (set (Gram_Schmidt xs)) = span (set xs) \\<and>\n        pairwise orthogonal (set (Gram_Schmidt xs))\"", "lemma card_Gram_Schmidt:\n  fixes xs::\"('a::{real_inner}^'b) list\"\n  assumes \"distinct xs\"\n  shows \"card(set (Gram_Schmidt xs)) \\<le> card (set (xs))\"", "lemma orthogonal_basis_exists:\n  fixes V :: \"(real^'b) list\"\n  assumes B: \"is_basis (set V)\"\n  and d: \"distinct V\"\n  shows \"vec.independent (set (Gram_Schmidt V)) \\<and> (set V) \\<subseteq> vec.span (set (Gram_Schmidt V)) \n  \\<and> (card (set (Gram_Schmidt V)) = vec.dim (set V)) \\<and> pairwise orthogonal (set (Gram_Schmidt V))\"", "lemma basis_orthogonal2:\n  fixes xs::\"('a::{real_inner}^'b) list\"\n  shows \"length (Gram_Schmidt2 xs) = length (xs)\n  \\<and> span (set (Gram_Schmidt2 xs)) = span (set xs)\n  \\<and> pairwise orthogonal (set (Gram_Schmidt2 xs))\"", "lemma card_Gram_Schmidt2:\n  fixes xs::\"('a::{real_inner}^'b) list\"\n  assumes \"distinct xs\"\n  shows \"card(set (Gram_Schmidt2 xs)) \\<le> card (set (xs))\"", "lemma orthogonal_basis_exists2:\n  fixes V :: \"(real^'b) list\"\n  assumes B: \"is_basis (set V)\"\n  and d: \"distinct V\"\n  shows \"vec.independent (set (Gram_Schmidt2 V)) \\<and> (set V) \\<subseteq> vec.span (set (Gram_Schmidt2 V)) \n  \\<and> (card (set (Gram_Schmidt2 V)) = vec.dim (set V)) \\<and> pairwise orthogonal (set (Gram_Schmidt2 V))\"", "lemma Gram_Schmidt_column_k_row_code[code abstract]:\n  \"vec_nth (Gram_Schmidt_column_k_row A k a) \n  = (%b. (if b = from_nat k \n  then (column b A - (\\<Sum>x\\<in>{column i A|i. i < b}. ((column b A) \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)) \n  else (column b A)) $ a)\"", "lemma Gram_Schmidt_column_k_code[code abstract]:\n  \"vec_nth (Gram_Schmidt_column_k A k) = Gram_Schmidt_column_k_row A k\"", "lemma Gram_Schmidt_upt_k_suc: \n  \"Gram_Schmidt_upt_k A (Suc k) = (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\"", "lemma column_Gram_Schmidt_upt_k_preserves:\n  fixes A::\"'a::{real_inner}^'cols::{mod_type}^'rows\"\n  assumes i_less_suc: \"to_nat i<(Suc k)\"\n  and suc_less_card: \"Suc k < CARD ('cols)\"\n  shows \"column i (Gram_Schmidt_upt_k A (Suc k)) = column i (Gram_Schmidt_upt_k A k)\"", "lemma column_set_Gram_Schmidt_upt_k:\n  fixes A::\"'a::{real_inner}^'cols::{mod_type}^'rows\"\n  assumes k: \"Suc k < CARD ('cols)\"\n  shows \"{column i (Gram_Schmidt_upt_k A (Suc k)) |i. to_nat i\\<le>(Suc k)} =\n  {column i (Gram_Schmidt_upt_k A k) |i. to_nat i\\<le>k} \\<union> {column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k)\n  - (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i. to_nat i\\<le>k}. (x \\<bullet> (column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k)) / (x \\<bullet> x)) *\\<^sub>R x)}\"", "lemma orthogonal_Gram_Schmidt_upt_k:\n  assumes s: \"k < ncols A\"\n  shows \"pairwise orthogonal ({column i (Gram_Schmidt_upt_k A k) |i. to_nat i\\<le>k})\"", "lemma columns_Gram_Schmidt_matrix_rw: \n  \"{column i (Gram_Schmidt_matrix A) |i. i \\<in> UNIV} \n  = {column i (Gram_Schmidt_upt_k A (ncols A - 1)) |i. to_nat i\\<le> (ncols A - 1)}\"", "lemma column_Gram_Schmidt_column_k:\n  fixes A::\"'a::{real_inner}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"column k (Gram_Schmidt_column_k A (to_nat k)) = \n  (column k A) - (\\<Sum>x\\<in>{column i A|i. i < k}. (x \\<bullet> (column k A) / (x \\<bullet> x)) *\\<^sub>R x)\"", "lemma column_Gram_Schmidt_column_k':\n  fixes A::\"'a::{real_inner}^'n::{mod_type}^'m::{mod_type}\"\n  assumes i_not_k: \"i\\<noteq>k\"\n  shows \"column i (Gram_Schmidt_column_k A (to_nat k)) = (column i A)\"", "lemma cols_upt_k_insert:\n  fixes A::\"'a^'n::{mod_type}^'m::{mod_type}\"\n  assumes k: \"(Suc k)<ncols A\"\n  shows \"cols_upt_k A (Suc k) = (insert (column (from_nat (Suc k)) A) (cols_upt_k A k))\"", "lemma columns_eq_cols_upt_k:\n  fixes A::\"'a^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"cols_upt_k A (ncols A - 1) = columns A\"", "lemma span_cols_upt_k_Gram_Schmidt_column_k:\n  fixes A::\"'a::{real_inner}^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"k < ncols A\"\n  and \"j < ncols A\"\n  shows \"span (cols_upt_k A k) = span (cols_upt_k (Gram_Schmidt_column_k A j) k)\"", "lemma is_basis_columns_Gram_Schmidt_matrix:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes b: \"is_basis (columns A)\"\n  and c: \"card (columns A) = ncols A\"\n  shows \"is_basis (columns (Gram_Schmidt_matrix A)) \n  \\<and> card (columns (Gram_Schmidt_matrix A)) = ncols A\"", "lemma column_gr_k_Gram_Schmidt_upt:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"i>k\"\n  and i: \"i<ncols A\"\n  shows \"column (from_nat i) (Gram_Schmidt_upt_k A k) = column (from_nat i) A\"", "lemma columns_Gram_Schmidt_upt_k_rw:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes k: \"Suc k < ncols A\"\n  shows \"{column i (Gram_Schmidt_upt_k A (Suc k)) |i. i < from_nat (Suc k)} \n  = {column i (Gram_Schmidt_upt_k A k) |i. i < from_nat (Suc k)}\"", "lemma column_Gram_Schmidt_upt_k:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"k<ncols A\"\n  shows \"column (from_nat k) (Gram_Schmidt_upt_k A k) = \n  (column (from_nat k) A) - (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k)|i. i < (from_nat k)}. (x \\<bullet> (column (from_nat k) A) / (x \\<bullet> x)) *\\<^sub>R x)\"", "lemma column_Gram_Schmidt_upt_k_preserves2:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"a\\<le>(from_nat i)\"\n  and \"i \\<le> j\"\n  and \"j<ncols A\"\n  shows \"column a (Gram_Schmidt_upt_k A i) = column a (Gram_Schmidt_upt_k A j)\"", "lemma set_columns_Gram_Schmidt_matrix: \n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  shows \"{column i (Gram_Schmidt_matrix A)|i. i < k} = {column i (Gram_Schmidt_upt_k A (to_nat k))|i. i < k}\"", "lemma column_Gram_Schmidt_matrix:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  shows \"column k (Gram_Schmidt_matrix A) \n  = (column k A) - (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A)|i. i < k}. (x \\<bullet> (column k A) / (x \\<bullet> x)) *\\<^sub>R x)\"", "lemma independent_columns_Gram_Schmidt_matrix:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes b: \"vec.independent (columns A)\"\n  and c: \"card (columns A) = ncols A\"\n  shows \"vec.independent (columns (Gram_Schmidt_matrix A)) \\<and> card (columns (Gram_Schmidt_matrix A)) = ncols A\"", "lemma column_eq_Gram_Schmidt_matrix:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  and c: \"column i (Gram_Schmidt_matrix A) = column ia (Gram_Schmidt_matrix A)\"\n  shows \"i = ia\"", "lemma scaleR_columns_Gram_Schmidt_matrix:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"i \\<noteq> j\"\n  and \"rank A = ncols A\"\n  shows \"column j (Gram_Schmidt_matrix A) \\<bullet> column i (Gram_Schmidt_matrix A) = 0\"", "lemmas Gram_Schmidt_step_def[unfolded proj_onto_def proj_def[abs_def],code]"], "translations": [["", "lemma Gram_Schmidt_cons:\n  \"Gram_Schmidt (a#xs) = Gram_Schmidt_step a (Gram_Schmidt xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt (a # xs) = Gram_Schmidt_step a (Gram_Schmidt xs)", "unfolding Gram_Schmidt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr Gram_Schmidt_step (a # xs) [] =\n    Gram_Schmidt_step a (foldr Gram_Schmidt_step xs [])", "by auto"], ["", "lemma basis_orthogonal':\n  fixes xs::\"('a::{real_inner}^'b) list\"\n  shows \"length (Gram_Schmidt xs) = length (xs) \\<and>\n        span (set (Gram_Schmidt xs)) = span (set xs) \\<and>\n        pairwise orthogonal (set (Gram_Schmidt xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Gram_Schmidt xs) = length xs \\<and>\n    span (set (Gram_Schmidt xs)) = span (set xs) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt xs))", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (Gram_Schmidt []) = length [] \\<and>\n    span (set (Gram_Schmidt [])) = span (set []) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt []))\n 2. \\<And>a xs.\n       length (Gram_Schmidt xs) = length xs \\<and>\n       span (set (Gram_Schmidt xs)) = span (set xs) \\<and>\n       pairwise orthogonal (set (Gram_Schmidt xs)) \\<Longrightarrow>\n       length (Gram_Schmidt (a # xs)) = length (a # xs) \\<and>\n       span (set (Gram_Schmidt (a # xs))) = span (set (a # xs)) \\<and>\n       pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. length (Gram_Schmidt []) = length [] \\<and>\n    span (set (Gram_Schmidt [])) = span (set []) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt []))\n 2. \\<And>a xs.\n       length (Gram_Schmidt xs) = length xs \\<and>\n       span (set (Gram_Schmidt xs)) = span (set xs) \\<and>\n       pairwise orthogonal (set (Gram_Schmidt xs)) \\<Longrightarrow>\n       length (Gram_Schmidt (a # xs)) = length (a # xs) \\<and>\n       span (set (Gram_Schmidt (a # xs))) = span (set (a # xs)) \\<and>\n       pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Gram_Schmidt []) = length [] \\<and>\n    span (set (Gram_Schmidt [])) = span (set []) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt []))", "unfolding Gram_Schmidt_def pairwise_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (foldr Gram_Schmidt_step [] []) = length [] \\<and>\n    span (set (foldr Gram_Schmidt_step [] [])) = span (set []) \\<and>\n    (\\<forall>x\\<in>set (foldr Gram_Schmidt_step [] []).\n        \\<forall>y\\<in>set (foldr Gram_Schmidt_step [] []).\n           x \\<noteq> y \\<longrightarrow> orthogonal x y)", "by fastforce"], ["proof (state)\nthis:\n  length (Gram_Schmidt []) = length [] \\<and>\n  span (set (Gram_Schmidt [])) = span (set []) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt []))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       length (Gram_Schmidt xs) = length xs \\<and>\n       span (set (Gram_Schmidt xs)) = span (set xs) \\<and>\n       pairwise orthogonal (set (Gram_Schmidt xs)) \\<Longrightarrow>\n       length (Gram_Schmidt (a # xs)) = length (a # xs) \\<and>\n       span (set (Gram_Schmidt (a # xs))) = span (set (a # xs)) \\<and>\n       pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       length (Gram_Schmidt xs) = length xs \\<and>\n       span (set (Gram_Schmidt xs)) = span (set xs) \\<and>\n       pairwise orthogonal (set (Gram_Schmidt xs)) \\<Longrightarrow>\n       length (Gram_Schmidt (a # xs)) = length (a # xs) \\<and>\n       span (set (Gram_Schmidt (a # xs))) = span (set (a # xs)) \\<and>\n       pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "case (Cons a xs)"], ["proof (state)\nthis:\n  length (Gram_Schmidt xs) = length xs \\<and>\n  span (set (Gram_Schmidt xs)) = span (set xs) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       length (Gram_Schmidt xs) = length xs \\<and>\n       span (set (Gram_Schmidt xs)) = span (set xs) \\<and>\n       pairwise orthogonal (set (Gram_Schmidt xs)) \\<Longrightarrow>\n       length (Gram_Schmidt (a # xs)) = length (a # xs) \\<and>\n       span (set (Gram_Schmidt (a # xs))) = span (set (a # xs)) \\<and>\n       pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "have l: \"length (Gram_Schmidt xs) = length xs\"\n    and s: \"span (set (Gram_Schmidt xs)) = span (set xs)\"\n    and p: \"pairwise orthogonal (set (Gram_Schmidt xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Gram_Schmidt xs) = length xs &&&\n    span (set (Gram_Schmidt xs)) = span (set xs) &&&\n    pairwise orthogonal (set (Gram_Schmidt xs))", "using Cons.hyps"], ["proof (prove)\nusing this:\n  length (Gram_Schmidt xs) = length xs \\<and>\n  span (set (Gram_Schmidt xs)) = span (set xs) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt xs))\n\ngoal (1 subgoal):\n 1. length (Gram_Schmidt xs) = length xs &&&\n    span (set (Gram_Schmidt xs)) = span (set xs) &&&\n    pairwise orthogonal (set (Gram_Schmidt xs))", "by auto"], ["proof (state)\nthis:\n  length (Gram_Schmidt xs) = length xs\n  span (set (Gram_Schmidt xs)) = span (set xs)\n  pairwise orthogonal (set (Gram_Schmidt xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       length (Gram_Schmidt xs) = length xs \\<and>\n       span (set (Gram_Schmidt xs)) = span (set xs) \\<and>\n       pairwise orthogonal (set (Gram_Schmidt xs)) \\<Longrightarrow>\n       length (Gram_Schmidt (a # xs)) = length (a # xs) \\<and>\n       span (set (Gram_Schmidt (a # xs))) = span (set (a # xs)) \\<and>\n       pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "show \"length (Gram_Schmidt (a # xs)) = length (a # xs) \\<and>\n    span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n    \\<and> pairwise orthogonal (set (Gram_Schmidt (a # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Gram_Schmidt (a # xs)) = length (a # xs) \\<and>\n    span (set (Gram_Schmidt (a # xs))) = span (set (a # xs)) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. length (Gram_Schmidt (a # xs)) = length (a # xs)\n 2. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs)) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "show \"length (Gram_Schmidt (a # xs)) = length (a # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Gram_Schmidt (a # xs)) = length (a # xs)", "unfolding Gram_Schmidt_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Gram_Schmidt_step a (Gram_Schmidt xs)) = length (a # xs)", "unfolding Gram_Schmidt_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Gram_Schmidt xs @ [a - proj_onto a (set (Gram_Schmidt xs))]) =\n    length (a # xs)", "using l"], ["proof (prove)\nusing this:\n  length (Gram_Schmidt xs) = length xs\n\ngoal (1 subgoal):\n 1. length (Gram_Schmidt xs @ [a - proj_onto a (set (Gram_Schmidt xs))]) =\n    length (a # xs)", "by auto"], ["proof (state)\nthis:\n  length (Gram_Schmidt (a # xs)) = length (a # xs)\n\ngoal (1 subgoal):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs)) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "show \"span (set (Gram_Schmidt (a # xs))) \n      = span (set (a # xs)) \\<and> pairwise orthogonal (set (Gram_Schmidt (a # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs)) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n 2. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "have set_rw1: \"set (a # xs) = insert a (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (a # xs) = insert a (set xs)", "by simp"], ["proof (state)\nthis:\n  set (a # xs) = insert a (set xs)\n\ngoal (2 subgoals):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n 2. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "have set_rw2: \"set (Gram_Schmidt (a # xs)) \n        = (insert (a - (\\<Sum>x\\<in>set (Gram_Schmidt xs). (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)) (set (Gram_Schmidt xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Gram_Schmidt (a # xs)) =\n    insert\n     (a -\n      (\\<Sum>x\\<in>set (Gram_Schmidt xs).\n         (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x))\n     (set (Gram_Schmidt xs))", "unfolding Gram_Schmidt_cons Gram_Schmidt_step_def proj_onto_def proj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Gram_Schmidt xs @\n         [a -\n          (\\<Sum>u\\<in>set (Gram_Schmidt xs).\n             (a \\<bullet> u / (u \\<bullet> u)) *\\<^sub>R u)]) =\n    insert\n     (a -\n      (\\<Sum>x\\<in>set (Gram_Schmidt xs).\n         (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x))\n     (set (Gram_Schmidt xs))", "by auto"], ["proof (state)\nthis:\n  set (Gram_Schmidt (a # xs)) =\n  insert\n   (a -\n    (\\<Sum>x\\<in>set (Gram_Schmidt xs).\n       (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x))\n   (set (Gram_Schmidt xs))\n\ngoal (2 subgoals):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n 2. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "define C where \"C = set (Gram_Schmidt xs)\""], ["proof (state)\nthis:\n  C = set (Gram_Schmidt xs)\n\ngoal (2 subgoals):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n 2. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "have finite_C: \"finite C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite C", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (Gram_Schmidt xs))", "by auto"], ["proof (state)\nthis:\n  finite C\n\ngoal (2 subgoals):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n 2. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "{"], ["proof (state)\nthis:\n  finite C\n\ngoal (2 subgoals):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n 2. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "fix x k"], ["proof (state)\ngoal (2 subgoals):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n 2. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "have th0: \"!!(a::'a^'b) b c. a - (b - c) = c + (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. a - (b - c) = c + (a - b)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  ?a - (?b - ?c) = ?c + (?a - ?b)\n\ngoal (2 subgoals):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n 2. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "have \"x - k *\\<^sub>R (a - (\\<Sum>x\\<in>C. (a \\<bullet> x / (x \\<bullet>  x)) *\\<^sub>R x)) \\<in> span C \n          \\<longleftrightarrow> x - k *\\<^sub>R a \\<in> span C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x -\n     k *\\<^sub>R\n     (a - (\\<Sum>x\\<in>C. (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x))\n     \\<in> span C) =\n    (x - k *\\<^sub>R a \\<in> span C)", "apply (simp only: scaleR_right_diff_distrib th0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k *\\<^sub>R\n     (\\<Sum>x\\<in>C. (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x) +\n     (x - k *\\<^sub>R a)\n     \\<in> span C) =\n    (x - k *\\<^sub>R a \\<in> span C)", "apply (rule span_add_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k *\\<^sub>R\n    (\\<Sum>x\\<in>C. (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\n    \\<in> span C", "apply (rule span_mul)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>C. (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\n    \\<in> span C", "apply (rule span_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x \\<in> span C", "apply (rule span_mul)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<in> span C", "apply (rule span_base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<in> C", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (x -\n   k *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (x - k *\\<^sub>R a \\<in> span C)\n\ngoal (2 subgoals):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n 2. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "}"], ["proof (state)\nthis:\n  (?x2 -\n   ?k2 *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (?x2 - ?k2 *\\<^sub>R a \\<in> span C)\n\ngoal (2 subgoals):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n 2. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "then"], ["proof (chain)\npicking this:\n  (?x2 -\n   ?k2 *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (?x2 - ?k2 *\\<^sub>R a \\<in> span C)", "show \"span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\""], ["proof (prove)\nusing this:\n  (?x2 -\n   ?k2 *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (?x2 - ?k2 *\\<^sub>R a \\<in> span C)\n\ngoal (1 subgoal):\n 1. span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))", "unfolding set_eq_iff set_rw2 set_rw1 span_breakdown_eq C_def s[symmetric]"], ["proof (prove)\nusing this:\n  (?x2 -\n   ?k2 *\\<^sub>R\n   (a -\n    (\\<Sum>x\\<in>set (Gram_Schmidt xs).\n       (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span (set (Gram_Schmidt xs))) =\n  (?x2 - ?k2 *\\<^sub>R a \\<in> span (set (Gram_Schmidt xs)))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>k.\n           x -\n           k *\\<^sub>R\n           (a -\n            (\\<Sum>x\\<in>set (Gram_Schmidt xs).\n               (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x))\n           \\<in> span (set (Gram_Schmidt xs))) =\n       (\\<exists>k. x - k *\\<^sub>R a \\<in> span (set (Gram_Schmidt xs)))", "by auto"], ["proof (state)\nthis:\n  span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n\ngoal (1 subgoal):\n 1. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "with p"], ["proof (chain)\npicking this:\n  pairwise orthogonal (set (Gram_Schmidt xs))\n  span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))", "show \"pairwise orthogonal (set (Gram_Schmidt (a # xs)))\""], ["proof (prove)\nusing this:\n  pairwise orthogonal (set (Gram_Schmidt xs))\n  span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n\ngoal (1 subgoal):\n 1. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "using pairwise_orthogonal_proj_set[OF finite_C]"], ["proof (prove)\nusing this:\n  pairwise orthogonal (set (Gram_Schmidt xs))\n  span (set (Gram_Schmidt (a # xs))) = span (set (a # xs))\n  pairwise orthogonal C \\<Longrightarrow>\n  pairwise orthogonal (insert (?a - proj_onto ?a C) C)\n\ngoal (1 subgoal):\n 1. pairwise orthogonal (set (Gram_Schmidt (a # xs)))", "unfolding set_rw2"], ["proof (prove)\nusing this:\n  pairwise orthogonal (set (Gram_Schmidt xs))\n  span\n   (insert\n     (a -\n      (\\<Sum>x\\<in>set (Gram_Schmidt xs).\n         (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x))\n     (set (Gram_Schmidt xs))) =\n  span (set (a # xs))\n  pairwise orthogonal C \\<Longrightarrow>\n  pairwise orthogonal (insert (?a - proj_onto ?a C) C)\n\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     (insert\n       (a -\n        (\\<Sum>x\\<in>set (Gram_Schmidt xs).\n           (a \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x))\n       (set (Gram_Schmidt xs)))", "unfolding C_def proj_def[symmetric] proj_onto_def[symmetric]"], ["proof (prove)\nusing this:\n  pairwise orthogonal (set (Gram_Schmidt xs))\n  span\n   (insert (a - proj_onto a (set (Gram_Schmidt xs)))\n     (set (Gram_Schmidt xs))) =\n  span (set (a # xs))\n  pairwise orthogonal (set (Gram_Schmidt xs)) \\<Longrightarrow>\n  pairwise orthogonal\n   (insert (?a - proj_onto ?a (set (Gram_Schmidt xs)))\n     (set (Gram_Schmidt xs)))\n\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     (insert (a - proj_onto a (set (Gram_Schmidt xs)))\n       (set (Gram_Schmidt xs)))", "by simp"], ["proof (state)\nthis:\n  pairwise orthogonal (set (Gram_Schmidt (a # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  span (set (Gram_Schmidt (a # xs))) = span (set (a # xs)) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt (a # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (Gram_Schmidt (a # xs)) = length (a # xs) \\<and>\n  span (set (Gram_Schmidt (a # xs))) = span (set (a # xs)) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt (a # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_Gram_Schmidt:\n  fixes xs::\"('a::{real_inner}^'b) list\"\n  assumes \"distinct xs\"\n  shows \"card(set (Gram_Schmidt xs)) \\<le> card (set (xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt xs)) \\<le> card (set xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt xs)) \\<le> card (set xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    card (set (Gram_Schmidt [])) \\<le> card (set [])\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                card (set (Gram_Schmidt xs)) \\<le> card (set xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> card (set (Gram_Schmidt (a # xs)))\n                         \\<le> card (set (a # xs))", "case Nil"], ["proof (state)\nthis:\n  distinct []\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    card (set (Gram_Schmidt [])) \\<le> card (set [])\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                card (set (Gram_Schmidt xs)) \\<le> card (set xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> card (set (Gram_Schmidt (a # xs)))\n                         \\<le> card (set (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt [])) \\<le> card (set [])", "unfolding Gram_Schmidt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (foldr Gram_Schmidt_step [] [])) \\<le> card (set [])", "by simp"], ["proof (state)\nthis:\n  card (set (Gram_Schmidt [])) \\<le> card (set [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                card (set (Gram_Schmidt xs)) \\<le> card (set xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> card (set (Gram_Schmidt (a # xs)))\n                         \\<le> card (set (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                card (set (Gram_Schmidt xs)) \\<le> card (set xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> card (set (Gram_Schmidt (a # xs)))\n                         \\<le> card (set (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct xs \\<Longrightarrow>\n  card (set (Gram_Schmidt xs)) \\<le> card (set xs)\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                card (set (Gram_Schmidt xs)) \\<le> card (set xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> card (set (Gram_Schmidt (a # xs)))\n                         \\<le> card (set (a # xs))", "define b where \"b = (\\<Sum>xa\\<in>set (Gram_Schmidt xs). (x \\<bullet> xa / (xa \\<bullet> xa)) *\\<^sub>R xa)\""], ["proof (state)\nthis:\n  b =\n  (\\<Sum>xa\\<in>set (Gram_Schmidt xs).\n     (x \\<bullet> xa / (xa \\<bullet> xa)) *\\<^sub>R xa)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                card (set (Gram_Schmidt xs)) \\<le> card (set xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> card (set (Gram_Schmidt (a # xs)))\n                         \\<le> card (set (a # xs))", "have distinct_xs: \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs", "using Cons.prems"], ["proof (prove)\nusing this:\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. distinct xs", "by auto"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                card (set (Gram_Schmidt xs)) \\<le> card (set xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> card (set (Gram_Schmidt (a # xs)))\n                         \\<le> card (set (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "proof (cases \"x - b \\<notin> set (Gram_Schmidt xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "case True"], ["proof (state)\nthis:\n  x - b \\<notin> set (Gram_Schmidt xs)\n\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "have \"card (set (Gram_Schmidt (x # xs))) = card (insert (x - b) (set (Gram_Schmidt xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt (x # xs))) =\n    card (insert (x - b) (set (Gram_Schmidt xs)))", "unfolding Gram_Schmidt_cons Gram_Schmidt_step_def b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (set (Gram_Schmidt xs @ [x - proj_onto x (set (Gram_Schmidt xs))])) =\n    card\n     (insert\n       (x -\n        (\\<Sum>xa\\<in>set (Gram_Schmidt xs).\n           (x \\<bullet> xa / (xa \\<bullet> xa)) *\\<^sub>R xa))\n       (set (Gram_Schmidt xs)))", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (set (Gram_Schmidt xs @\n           [x -\n            (\\<Sum>u\\<in>set (Gram_Schmidt xs).\n               (x \\<bullet> u / (u \\<bullet> u)) *\\<^sub>R u)])) =\n    card\n     (insert\n       (x -\n        (\\<Sum>xa\\<in>set (Gram_Schmidt xs).\n           (x \\<bullet> xa / (xa \\<bullet> xa)) *\\<^sub>R xa))\n       (set (Gram_Schmidt xs)))", "by simp"], ["proof (state)\nthis:\n  card (set (Gram_Schmidt (x # xs))) =\n  card (insert (x - b) (set (Gram_Schmidt xs)))\n\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "also"], ["proof (state)\nthis:\n  card (set (Gram_Schmidt (x # xs))) =\n  card (insert (x - b) (set (Gram_Schmidt xs)))\n\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "have \"... = Suc (card (set (Gram_Schmidt xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert (x - b) (set (Gram_Schmidt xs))) =\n    Suc (card (set (Gram_Schmidt xs)))", "proof (rule card_insert_disjoint)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (set (Gram_Schmidt xs))\n 2. x - b \\<notin> set (Gram_Schmidt xs)", "show \"finite (set (Gram_Schmidt xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (Gram_Schmidt xs))", "by simp"], ["proof (state)\nthis:\n  finite (set (Gram_Schmidt xs))\n\ngoal (1 subgoal):\n 1. x - b \\<notin> set (Gram_Schmidt xs)", "show \"x - b \\<notin> set (Gram_Schmidt xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - b \\<notin> set (Gram_Schmidt xs)", "using True"], ["proof (prove)\nusing this:\n  x - b \\<notin> set (Gram_Schmidt xs)\n\ngoal (1 subgoal):\n 1. x - b \\<notin> set (Gram_Schmidt xs)", "."], ["proof (state)\nthis:\n  x - b \\<notin> set (Gram_Schmidt xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (insert (x - b) (set (Gram_Schmidt xs))) =\n  Suc (card (set (Gram_Schmidt xs)))\n\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "also"], ["proof (state)\nthis:\n  card (insert (x - b) (set (Gram_Schmidt xs))) =\n  Suc (card (set (Gram_Schmidt xs)))\n\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "have \"... \\<le> Suc (card (set xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card (set (Gram_Schmidt xs))) \\<le> Suc (card (set xs))", "using Cons.hyps[OF distinct_xs]"], ["proof (prove)\nusing this:\n  card (set (Gram_Schmidt xs)) \\<le> card (set xs)\n\ngoal (1 subgoal):\n 1. Suc (card (set (Gram_Schmidt xs))) \\<le> Suc (card (set xs))", "by simp"], ["proof (state)\nthis:\n  Suc (card (set (Gram_Schmidt xs))) \\<le> Suc (card (set xs))\n\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "also"], ["proof (state)\nthis:\n  Suc (card (set (Gram_Schmidt xs))) \\<le> Suc (card (set xs))\n\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "have \"... = Suc (length (remdups xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card (set xs)) = Suc (length (remdups xs))", "unfolding List.card_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (length (remdups xs)) = Suc (length (remdups xs))", ".."], ["proof (state)\nthis:\n  Suc (card (set xs)) = Suc (length (remdups xs))\n\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "also"], ["proof (state)\nthis:\n  Suc (card (set xs)) = Suc (length (remdups xs))\n\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "have \"... \\<le> (length (remdups (x # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (length (remdups xs)) \\<le> length (remdups (x # xs))", "by (metis Cons.prems distinct_xs impossible_Cons not_less_eq_eq remdups_id_iff_distinct)"], ["proof (state)\nthis:\n  Suc (length (remdups xs)) \\<le> length (remdups (x # xs))\n\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "also"], ["proof (state)\nthis:\n  Suc (length (remdups xs)) \\<le> length (remdups (x # xs))\n\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "have \"... \\<le> (card (set (x # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (remdups (x # xs)) \\<le> card (set (x # xs))", "by (metis dual_order.refl length_remdups_card_conv)"], ["proof (state)\nthis:\n  length (remdups (x # xs)) \\<le> card (set (x # xs))\n\ngoal (2 subgoals):\n 1. x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n 2. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "finally"], ["proof (chain)\npicking this:\n  card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "."], ["proof (state)\nthis:\n  card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n\ngoal (1 subgoal):\n 1. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "case False"], ["proof (state)\nthis:\n  \\<not> x - b \\<notin> set (Gram_Schmidt xs)\n\ngoal (1 subgoal):\n 1. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "have x_b_in: \"x - b \\<in> set (Gram_Schmidt xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - b \\<in> set (Gram_Schmidt xs)", "using False"], ["proof (prove)\nusing this:\n  \\<not> x - b \\<notin> set (Gram_Schmidt xs)\n\ngoal (1 subgoal):\n 1. x - b \\<in> set (Gram_Schmidt xs)", "by simp"], ["proof (state)\nthis:\n  x - b \\<in> set (Gram_Schmidt xs)\n\ngoal (1 subgoal):\n 1. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "have \"card (set (Gram_Schmidt (x # xs))) = card (insert (x - b) (set (Gram_Schmidt xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt (x # xs))) =\n    card (insert (x - b) (set (Gram_Schmidt xs)))", "unfolding Gram_Schmidt_cons Gram_Schmidt_step_def b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (set (Gram_Schmidt xs @ [x - proj_onto x (set (Gram_Schmidt xs))])) =\n    card\n     (insert\n       (x -\n        (\\<Sum>xa\\<in>set (Gram_Schmidt xs).\n           (x \\<bullet> xa / (xa \\<bullet> xa)) *\\<^sub>R xa))\n       (set (Gram_Schmidt xs)))", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (set (Gram_Schmidt xs @\n           [x -\n            (\\<Sum>u\\<in>set (Gram_Schmidt xs).\n               (x \\<bullet> u / (u \\<bullet> u)) *\\<^sub>R u)])) =\n    card\n     (insert\n       (x -\n        (\\<Sum>xa\\<in>set (Gram_Schmidt xs).\n           (x \\<bullet> xa / (xa \\<bullet> xa)) *\\<^sub>R xa))\n       (set (Gram_Schmidt xs)))", "by simp"], ["proof (state)\nthis:\n  card (set (Gram_Schmidt (x # xs))) =\n  card (insert (x - b) (set (Gram_Schmidt xs)))\n\ngoal (1 subgoal):\n 1. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "also"], ["proof (state)\nthis:\n  card (set (Gram_Schmidt (x # xs))) =\n  card (insert (x - b) (set (Gram_Schmidt xs)))\n\ngoal (1 subgoal):\n 1. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "have \"... = (card (set (Gram_Schmidt xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert (x - b) (set (Gram_Schmidt xs))) =\n    card (set (Gram_Schmidt xs))", "by (metis False insert_absorb)"], ["proof (state)\nthis:\n  card (insert (x - b) (set (Gram_Schmidt xs))) =\n  card (set (Gram_Schmidt xs))\n\ngoal (1 subgoal):\n 1. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "also"], ["proof (state)\nthis:\n  card (insert (x - b) (set (Gram_Schmidt xs))) =\n  card (set (Gram_Schmidt xs))\n\ngoal (1 subgoal):\n 1. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "have \"... \\<le> (card (set xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt xs)) \\<le> card (set xs)", "using Cons.hyps[OF distinct_xs]"], ["proof (prove)\nusing this:\n  card (set (Gram_Schmidt xs)) \\<le> card (set xs)\n\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt xs)) \\<le> card (set xs)", "."], ["proof (state)\nthis:\n  card (set (Gram_Schmidt xs)) \\<le> card (set xs)\n\ngoal (1 subgoal):\n 1. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "also"], ["proof (state)\nthis:\n  card (set (Gram_Schmidt xs)) \\<le> card (set xs)\n\ngoal (1 subgoal):\n 1. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "have \"... \\<le> (card (set (x # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set xs) \\<le> card (set (x # xs))", "unfolding List.card_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (remdups xs) \\<le> length (remdups (x # xs))", "by simp"], ["proof (state)\nthis:\n  card (set xs) \\<le> card (set (x # xs))\n\ngoal (1 subgoal):\n 1. \\<not> x - b \\<notin> set (Gram_Schmidt xs) \\<Longrightarrow>\n    card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "finally"], ["proof (chain)\npicking this:\n  card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))", "."], ["proof (state)\nthis:\n  card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (set (Gram_Schmidt (x # xs))) \\<le> card (set (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_basis_exists:\n  fixes V :: \"(real^'b) list\"\n  assumes B: \"is_basis (set V)\"\n  and d: \"distinct V\"\n  shows \"vec.independent (set (Gram_Schmidt V)) \\<and> (set V) \\<subseteq> vec.span (set (Gram_Schmidt V)) \n  \\<and> (card (set (Gram_Schmidt V)) = vec.dim (set V)) \\<and> pairwise orthogonal (set (Gram_Schmidt V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (set (Gram_Schmidt V)) \\<and>\n    set V \\<subseteq> vec.span (set (Gram_Schmidt V)) \\<and>\n    card (set (Gram_Schmidt V)) = vec.dim (set V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt V))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec.independent (set (Gram_Schmidt V)) \\<and>\n    set V \\<subseteq> vec.span (set (Gram_Schmidt V)) \\<and>\n    card (set (Gram_Schmidt V)) = vec.dim (set V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt V))", "have \"(set V) \\<subseteq> vec.span (set (Gram_Schmidt V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set V \\<subseteq> vec.span (set (Gram_Schmidt V))", "using basis_orthogonal'[of V]"], ["proof (prove)\nusing this:\n  length (Gram_Schmidt V) = length V \\<and>\n  span (set (Gram_Schmidt V)) = span (set V) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. set V \\<subseteq> vec.span (set (Gram_Schmidt V))", "using vec.span_superset[where ?'a=real, where ?'b='b]"], ["proof (prove)\nusing this:\n  length (Gram_Schmidt V) = length V \\<and>\n  span (set (Gram_Schmidt V)) = span (set V) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt V))\n  ?S \\<subseteq> vec.span ?S\n\ngoal (1 subgoal):\n 1. set V \\<subseteq> vec.span (set (Gram_Schmidt V))", "by (auto simp: span_vec_eq)"], ["proof (state)\nthis:\n  set V \\<subseteq> vec.span (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. vec.independent (set (Gram_Schmidt V)) \\<and>\n    set V \\<subseteq> vec.span (set (Gram_Schmidt V)) \\<and>\n    card (set (Gram_Schmidt V)) = vec.dim (set V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt V))", "moreover"], ["proof (state)\nthis:\n  set V \\<subseteq> vec.span (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. vec.independent (set (Gram_Schmidt V)) \\<and>\n    set V \\<subseteq> vec.span (set (Gram_Schmidt V)) \\<and>\n    card (set (Gram_Schmidt V)) = vec.dim (set V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt V))", "have \"pairwise orthogonal (set (Gram_Schmidt V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal (set (Gram_Schmidt V))", "using basis_orthogonal'[of V]"], ["proof (prove)\nusing this:\n  length (Gram_Schmidt V) = length V \\<and>\n  span (set (Gram_Schmidt V)) = span (set V) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. pairwise orthogonal (set (Gram_Schmidt V))", "by blast"], ["proof (state)\nthis:\n  pairwise orthogonal (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. vec.independent (set (Gram_Schmidt V)) \\<and>\n    set V \\<subseteq> vec.span (set (Gram_Schmidt V)) \\<and>\n    card (set (Gram_Schmidt V)) = vec.dim (set V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt V))", "moreover"], ["proof (state)\nthis:\n  pairwise orthogonal (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. vec.independent (set (Gram_Schmidt V)) \\<and>\n    set V \\<subseteq> vec.span (set (Gram_Schmidt V)) \\<and>\n    card (set (Gram_Schmidt V)) = vec.dim (set V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt V))", "have c: \"(card (set (Gram_Schmidt V)) = vec.dim (set V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt V)) = vec.dim (set V)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt V)) = vec.dim (set V)", "have card_eq_dim: \"card (set V) = vec.dim (set V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set V) = vec.dim (set V)", "by (metis B independent_is_basis vec.dim_span vec.indep_card_eq_dim_span)"], ["proof (state)\nthis:\n  card (set V) = vec.dim (set V)\n\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt V)) = vec.dim (set V)", "have \"vec.dim (set V) \\<le> (card (set (Gram_Schmidt V)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (set V) \\<le> card (set (Gram_Schmidt V))", "using B"], ["proof (prove)\nusing this:\n  is_basis (set V)\n\ngoal (1 subgoal):\n 1. vec.dim (set V) \\<le> card (set (Gram_Schmidt V))", "unfolding is_basis_def"], ["proof (prove)\nusing this:\n  vec.independent (set V) \\<and> vec.span (set V) = UNIV\n\ngoal (1 subgoal):\n 1. vec.dim (set V) \\<le> card (set (Gram_Schmidt V))", "using vec.independent_span_bound[of \"(set (Gram_Schmidt V))\" \"set V\"]"], ["proof (prove)\nusing this:\n  vec.independent (set V) \\<and> vec.span (set V) = UNIV\n  \\<lbrakk>finite (set (Gram_Schmidt V)); vec.independent (set V);\n   set V \\<subseteq> vec.span (set (Gram_Schmidt V))\\<rbrakk>\n  \\<Longrightarrow> finite (set V) \\<and>\n                    card (set V) \\<le> card (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. vec.dim (set V) \\<le> card (set (Gram_Schmidt V))", "using basis_orthogonal'[of V]"], ["proof (prove)\nusing this:\n  vec.independent (set V) \\<and> vec.span (set V) = UNIV\n  \\<lbrakk>finite (set (Gram_Schmidt V)); vec.independent (set V);\n   set V \\<subseteq> vec.span (set (Gram_Schmidt V))\\<rbrakk>\n  \\<Longrightarrow> finite (set V) \\<and>\n                    card (set V) \\<le> card (set (Gram_Schmidt V))\n  length (Gram_Schmidt V) = length V \\<and>\n  span (set (Gram_Schmidt V)) = span (set V) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. vec.dim (set V) \\<le> card (set (Gram_Schmidt V))", "by (simp add: calculation(1) local.card_eq_dim)"], ["proof (state)\nthis:\n  vec.dim (set V) \\<le> card (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt V)) = vec.dim (set V)", "moreover"], ["proof (state)\nthis:\n  vec.dim (set V) \\<le> card (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt V)) = vec.dim (set V)", "have \"(card (set (Gram_Schmidt V))) \\<le> vec.dim (set V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt V)) \\<le> vec.dim (set V)", "using card_Gram_Schmidt[OF d] card_eq_dim"], ["proof (prove)\nusing this:\n  card (set (Gram_Schmidt V)) \\<le> card (set V)\n  card (set V) = vec.dim (set V)\n\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt V)) \\<le> vec.dim (set V)", "by auto"], ["proof (state)\nthis:\n  card (set (Gram_Schmidt V)) \\<le> vec.dim (set V)\n\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt V)) = vec.dim (set V)", "ultimately"], ["proof (chain)\npicking this:\n  vec.dim (set V) \\<le> card (set (Gram_Schmidt V))\n  card (set (Gram_Schmidt V)) \\<le> vec.dim (set V)", "show ?thesis"], ["proof (prove)\nusing this:\n  vec.dim (set V) \\<le> card (set (Gram_Schmidt V))\n  card (set (Gram_Schmidt V)) \\<le> vec.dim (set V)\n\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt V)) = vec.dim (set V)", "by auto"], ["proof (state)\nthis:\n  card (set (Gram_Schmidt V)) = vec.dim (set V)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (set (Gram_Schmidt V)) = vec.dim (set V)\n\ngoal (1 subgoal):\n 1. vec.independent (set (Gram_Schmidt V)) \\<and>\n    set V \\<subseteq> vec.span (set (Gram_Schmidt V)) \\<and>\n    card (set (Gram_Schmidt V)) = vec.dim (set V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt V))", "moreover"], ["proof (state)\nthis:\n  card (set (Gram_Schmidt V)) = vec.dim (set V)\n\ngoal (1 subgoal):\n 1. vec.independent (set (Gram_Schmidt V)) \\<and>\n    set V \\<subseteq> vec.span (set (Gram_Schmidt V)) \\<and>\n    card (set (Gram_Schmidt V)) = vec.dim (set V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt V))", "have \"vec.independent (set (Gram_Schmidt V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (set (Gram_Schmidt V))", "proof (rule vec.card_le_dim_spanning[of _ \"UNIV::(real^'b) set\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. set (Gram_Schmidt V) \\<subseteq> UNIV\n 2. UNIV \\<subseteq> vec.span (set (Gram_Schmidt V))\n 3. finite (set (Gram_Schmidt V))\n 4. card (set (Gram_Schmidt V)) \\<le> vec.dim UNIV", "show \"set (Gram_Schmidt V) \\<subseteq> (UNIV::(real^'b) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Gram_Schmidt V) \\<subseteq> UNIV", "by simp"], ["proof (state)\nthis:\n  set (Gram_Schmidt V) \\<subseteq> UNIV\n\ngoal (3 subgoals):\n 1. UNIV \\<subseteq> vec.span (set (Gram_Schmidt V))\n 2. finite (set (Gram_Schmidt V))\n 3. card (set (Gram_Schmidt V)) \\<le> vec.dim UNIV", "show \"UNIV \\<subseteq> vec.span (set (Gram_Schmidt V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> vec.span (set (Gram_Schmidt V))", "using basis_orthogonal'[of V]"], ["proof (prove)\nusing this:\n  length (Gram_Schmidt V) = length V \\<and>\n  span (set (Gram_Schmidt V)) = span (set V) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> vec.span (set (Gram_Schmidt V))", "using B"], ["proof (prove)\nusing this:\n  length (Gram_Schmidt V) = length V \\<and>\n  span (set (Gram_Schmidt V)) = span (set V) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt V))\n  is_basis (set V)\n\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> vec.span (set (Gram_Schmidt V))", "unfolding is_basis_def"], ["proof (prove)\nusing this:\n  length (Gram_Schmidt V) = length V \\<and>\n  span (set (Gram_Schmidt V)) = span (set V) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt V))\n  vec.independent (set V) \\<and> vec.span (set V) = UNIV\n\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> vec.span (set (Gram_Schmidt V))", "by (simp add: span_vec_eq)"], ["proof (state)\nthis:\n  UNIV \\<subseteq> vec.span (set (Gram_Schmidt V))\n\ngoal (2 subgoals):\n 1. finite (set (Gram_Schmidt V))\n 2. card (set (Gram_Schmidt V)) \\<le> vec.dim UNIV", "show \"finite (set (Gram_Schmidt V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (Gram_Schmidt V))", "by simp"], ["proof (state)\nthis:\n  finite (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt V)) \\<le> vec.dim UNIV", "show \"card (set (Gram_Schmidt V)) \\<le> vec.dim (UNIV::(real^'b) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt V)) \\<le> vec.dim UNIV", "by (metis c top_greatest vec.dim_subset)"], ["proof (state)\nthis:\n  card (set (Gram_Schmidt V)) \\<le> vec.dim UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec.independent (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. vec.independent (set (Gram_Schmidt V)) \\<and>\n    set V \\<subseteq> vec.span (set (Gram_Schmidt V)) \\<and>\n    card (set (Gram_Schmidt V)) = vec.dim (set V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt V))", "ultimately"], ["proof (chain)\npicking this:\n  set V \\<subseteq> vec.span (set (Gram_Schmidt V))\n  pairwise orthogonal (set (Gram_Schmidt V))\n  card (set (Gram_Schmidt V)) = vec.dim (set V)\n  vec.independent (set (Gram_Schmidt V))", "show ?thesis"], ["proof (prove)\nusing this:\n  set V \\<subseteq> vec.span (set (Gram_Schmidt V))\n  pairwise orthogonal (set (Gram_Schmidt V))\n  card (set (Gram_Schmidt V)) = vec.dim (set V)\n  vec.independent (set (Gram_Schmidt V))\n\ngoal (1 subgoal):\n 1. vec.independent (set (Gram_Schmidt V)) \\<and>\n    set V \\<subseteq> vec.span (set (Gram_Schmidt V)) \\<and>\n    card (set (Gram_Schmidt V)) = vec.dim (set V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt V))", "by simp"], ["proof (state)\nthis:\n  vec.independent (set (Gram_Schmidt V)) \\<and>\n  set V \\<subseteq> vec.span (set (Gram_Schmidt V)) \\<and>\n  card (set (Gram_Schmidt V)) = vec.dim (set V) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt V))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary orthogonal_basis_exists':\n  fixes V :: \"(real^'b) list\"\n  assumes B: \"is_basis (set V)\"\n  and d: \"distinct V\"\n  shows \"is_basis (set (Gram_Schmidt V)) \n  \\<and> distinct (Gram_Schmidt V) \\<and> pairwise orthogonal (set (Gram_Schmidt V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_basis (set (Gram_Schmidt V)) \\<and>\n    distinct (Gram_Schmidt V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt V))", "using B orthogonal_basis_exists basis_orthogonal' card_distinct d \n    vec.dim_unique distinct_card is_basis_def subset_refl"], ["proof (prove)\nusing this:\n  is_basis (set V)\n  \\<lbrakk>is_basis (set ?V); distinct ?V\\<rbrakk>\n  \\<Longrightarrow> vec.independent (set (Gram_Schmidt ?V)) \\<and>\n                    set ?V\n                    \\<subseteq> vec.span (set (Gram_Schmidt ?V)) \\<and>\n                    card (set (Gram_Schmidt ?V)) = vec.dim (set ?V) \\<and>\n                    pairwise orthogonal (set (Gram_Schmidt ?V))\n  length (Gram_Schmidt ?xs) = length ?xs \\<and>\n  span (set (Gram_Schmidt ?xs)) = span (set ?xs) \\<and>\n  pairwise orthogonal (set (Gram_Schmidt ?xs))\n  card (set ?xs) = length ?xs \\<Longrightarrow> distinct ?xs\n  distinct V\n  \\<lbrakk>?B \\<subseteq> ?V; ?V \\<subseteq> vec.span ?B;\n   vec.independent ?B; card ?B = ?n\\<rbrakk>\n  \\<Longrightarrow> vec.dim ?V = ?n\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n  is_basis ?S \\<equiv> vec.independent ?S \\<and> vec.span ?S = UNIV\n  ?A \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. is_basis (set (Gram_Schmidt V)) \\<and>\n    distinct (Gram_Schmidt V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt V))", "by (metis span_vec_eq)"], ["", "subsubsection\\<open>Second way\\<close>"], ["", "text\\<open>This definition applies the Gram Schmidt process starting from the first element of the list.\\<close>"], ["", "definition \"Gram_Schmidt2 xs = Gram_Schmidt (rev xs)\""], ["", "lemma basis_orthogonal2:\n  fixes xs::\"('a::{real_inner}^'b) list\"\n  shows \"length (Gram_Schmidt2 xs) = length (xs)\n  \\<and> span (set (Gram_Schmidt2 xs)) = span (set xs)\n  \\<and> pairwise orthogonal (set (Gram_Schmidt2 xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Gram_Schmidt2 xs) = length xs \\<and>\n    span (set (Gram_Schmidt2 xs)) = span (set xs) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt2 xs))", "by (metis Gram_Schmidt2_def basis_orthogonal' length_rev set_rev)"], ["", "lemma card_Gram_Schmidt2:\n  fixes xs::\"('a::{real_inner}^'b) list\"\n  assumes \"distinct xs\"\n  shows \"card(set (Gram_Schmidt2 xs)) \\<le> card (set (xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (Gram_Schmidt2 xs)) \\<le> card (set xs)", "by (metis Gram_Schmidt2_def assms card_Gram_Schmidt distinct_rev set_rev)"], ["", "lemma orthogonal_basis_exists2:\n  fixes V :: \"(real^'b) list\"\n  assumes B: \"is_basis (set V)\"\n  and d: \"distinct V\"\n  shows \"vec.independent (set (Gram_Schmidt2 V)) \\<and> (set V) \\<subseteq> vec.span (set (Gram_Schmidt2 V)) \n  \\<and> (card (set (Gram_Schmidt2 V)) = vec.dim (set V)) \\<and> pairwise orthogonal (set (Gram_Schmidt2 V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (set (Gram_Schmidt2 V)) \\<and>\n    set V \\<subseteq> vec.span (set (Gram_Schmidt2 V)) \\<and>\n    card (set (Gram_Schmidt2 V)) = vec.dim (set V) \\<and>\n    pairwise orthogonal (set (Gram_Schmidt2 V))", "by (metis Gram_Schmidt.orthogonal_basis_exists Gram_Schmidt2_def distinct_rev set_rev\n      B basis_orthogonal2 d)"], ["", "subsubsection\\<open>Third way\\<close>"], ["", "text\\<open>The following definitions applies the Gram Schmidt process in the columns of a given matrix.\n  It is previous step to the computation of the QR decomposition.\\<close>"], ["", "definition Gram_Schmidt_column_k :: \"'a::{real_inner}^'cols::{mod_type}^'rows \\<Rightarrow> nat \n  \\<Rightarrow> 'a^'cols::{mod_type}^'rows\" \n  where \"Gram_Schmidt_column_k A k \n  = (\\<chi> a. (\\<chi> b. (if b = from_nat k \n  then (column b A - (proj_onto (column b A) {column i A|i. i < b})) \n  else (column b A)) $ a))\""], ["", "definition \"Gram_Schmidt_upt_k A k = foldl Gram_Schmidt_column_k A [0..<(Suc k)]\""], ["", "definition \"Gram_Schmidt_matrix A = Gram_Schmidt_upt_k A (ncols A - 1)\""], ["", "text\\<open>Some definitions and lemmas in order to get execution.\\<close>"], ["", "definition \"Gram_Schmidt_column_k_row A k a = \n  vec_lambda(\\<lambda>b. (if b = from_nat k then \n  (column b A - (\\<Sum>x\\<in>{column i A|i. i < b}. ((column b A) \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)) \n  else (column b A)) $ a)\""], ["", "lemma Gram_Schmidt_column_k_row_code[code abstract]:\n  \"vec_nth (Gram_Schmidt_column_k_row A k a) \n  = (%b. (if b = from_nat k \n  then (column b A - (\\<Sum>x\\<in>{column i A|i. i < b}. ((column b A) \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)) \n  else (column b A)) $ a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (Gram_Schmidt_column_k_row A k a) =\n    (\\<lambda>b.\n        (if b = mod_type_class.from_nat k\n         then column b A -\n              (\\<Sum>x\\<in>{column i A |i. i < b}.\n                 (column b A \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\n         else column b A) $\n        a)", "unfolding Gram_Schmidt_column_k_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>b.\n            (if b = mod_type_class.from_nat k\n             then column b A -\n                  (\\<Sum>x\\<in>{column i A |i. i < b}.\n                     (column b A \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\n             else column b A) $\n            a) =\n    (\\<lambda>b.\n        (if b = mod_type_class.from_nat k\n         then column b A -\n              (\\<Sum>x\\<in>{column i A |i. i < b}.\n                 (column b A \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\n         else column b A) $\n        a)", "by (metis (lifting) vec_lambda_beta)"], ["", "lemma Gram_Schmidt_column_k_code[code abstract]:\n  \"vec_nth (Gram_Schmidt_column_k A k) = Gram_Schmidt_column_k_row A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (Gram_Schmidt_column_k A k) = Gram_Schmidt_column_k_row A k", "unfolding Gram_Schmidt_column_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>a b.\n            (if b = mod_type_class.from_nat k\n             then column b A - proj_onto (column b A) {column i A |i. i < b}\n             else column b A) $\n            a) =\n    Gram_Schmidt_column_k_row A k", "unfolding Gram_Schmidt_column_k_row_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>a b.\n            (if b = mod_type_class.from_nat k\n             then column b A - proj_onto (column b A) {column i A |i. i < b}\n             else column b A) $\n            a) =\n    (\\<lambda>a.\n        \\<chi>b.\n           (if b = mod_type_class.from_nat k\n            then column b A -\n                 (\\<Sum>x\\<in>{column i A |i. i < b}.\n                    (column b A \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\n            else column b A) $\n           a)", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>a b.\n            (if b = mod_type_class.from_nat k\n             then column b A -\n                  (\\<Sum>u\\<in>{column i A |i. i < b}.\n                     (column b A \\<bullet> u / (u \\<bullet> u)) *\\<^sub>R u)\n             else column b A) $\n            a) =\n    (\\<lambda>a.\n        \\<chi>b.\n           (if b = mod_type_class.from_nat k\n            then column b A -\n                 (\\<Sum>x\\<in>{column i A |i. i < b}.\n                    (column b A \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)\n            else column b A) $\n           a)", "by fastforce"], ["", "text\\<open>Proofs\\<close>"], ["", "lemma Gram_Schmidt_upt_k_suc: \n  \"Gram_Schmidt_upt_k A (Suc k) = (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A (Suc k) =\n    Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A (Suc k) =\n    Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)", "have rw: \"[0..<Suc (Suc k)] = [0..<Suc k] @ [(Suc k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A (Suc k) =\n    Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_upt_k A (Suc k) =\n    Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)", "unfolding Gram_Schmidt_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl Gram_Schmidt_column_k A [0..<Suc (Suc k)] =\n    Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n     (Suc k)", "unfolding rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl Gram_Schmidt_column_k A ([0..<Suc k] @ [Suc k]) =\n    Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n     (Suc k)", "unfolding foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n     [Suc k] =\n    Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n     (Suc k)", "unfolding foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n     (Suc k) =\n    Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n     (Suc k)", ".."], ["proof (state)\nthis:\n  Gram_Schmidt_upt_k A (Suc k) =\n  Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma column_Gram_Schmidt_upt_k_preserves:\n  fixes A::\"'a::{real_inner}^'cols::{mod_type}^'rows\"\n  assumes i_less_suc: \"to_nat i<(Suc k)\"\n  and suc_less_card: \"Suc k < CARD ('cols)\"\n  shows \"column i (Gram_Schmidt_upt_k A (Suc k)) = column i (Gram_Schmidt_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (Suc k)) =\n    column i (Gram_Schmidt_upt_k A k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (Suc k)) =\n    column i (Gram_Schmidt_upt_k A k)", "have \"column i (Gram_Schmidt_upt_k A (Suc k)) \n    = column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (Suc k)) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))", "unfolding Gram_Schmidt_upt_k_suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))", ".."], ["proof (state)\nthis:\n  column i (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (Suc k)) =\n    column i (Gram_Schmidt_upt_k A k)", "also"], ["proof (state)\nthis:\n  column i (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (Suc k)) =\n    column i (Gram_Schmidt_upt_k A k)", "have \"... = column i (Gram_Schmidt_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column i (Gram_Schmidt_upt_k A k)", "unfolding Gram_Schmidt_column_k_def\n    column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat (Suc k)\n             then (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) -\n                  proj_onto (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b)\n                   {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i. i < b}\n             else \\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) $\n            a) $\n        ia $\n        i) =\n    (\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i)", "using i_less_suc"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n\ngoal (1 subgoal):\n 1. (\\<chi>ia.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat (Suc k)\n             then (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) -\n                  proj_onto (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b)\n                   {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i. i < b}\n             else \\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) $\n            a) $\n        ia $\n        i) =\n    (\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i)", "by (auto simp add: to_nat_from_nat_id[OF suc_less_card])"], ["proof (state)\nthis:\n  column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n  column i (Gram_Schmidt_upt_k A k)\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (Suc k)) =\n    column i (Gram_Schmidt_upt_k A k)", "finally"], ["proof (chain)\npicking this:\n  column i (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A k)", "show ?thesis"], ["proof (prove)\nusing this:\n  column i (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A k)\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (Suc k)) =\n    column i (Gram_Schmidt_upt_k A k)", "."], ["proof (state)\nthis:\n  column i (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma column_set_Gram_Schmidt_upt_k:\n  fixes A::\"'a::{real_inner}^'cols::{mod_type}^'rows\"\n  assumes k: \"Suc k < CARD ('cols)\"\n  shows \"{column i (Gram_Schmidt_upt_k A (Suc k)) |i. to_nat i\\<le>(Suc k)} =\n  {column i (Gram_Schmidt_upt_k A k) |i. to_nat i\\<le>k} \\<union> {column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k)\n  - (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i. to_nat i\\<le>k}. (x \\<bullet> (column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k)) / (x \\<bullet> x)) *\\<^sub>R x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n     mod_type_class.to_nat i \\<le> Suc k} =\n    {column i (Gram_Schmidt_upt_k A k) |i.\n     mod_type_class.to_nat i \\<le> k} \\<union>\n    {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n     (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                   mod_type_class.to_nat i \\<le> k}.\n        (x \\<bullet>\n         column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n         (x \\<bullet> x)) *\\<^sub>R\n        x)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n     mod_type_class.to_nat i \\<le> Suc k} =\n    {column i (Gram_Schmidt_upt_k A k) |i.\n     mod_type_class.to_nat i \\<le> k} \\<union>\n    {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n     (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                   mod_type_class.to_nat i \\<le> k}.\n        (x \\<bullet>\n         column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n         (x \\<bullet> x)) *\\<^sub>R\n        x)}", "have set_rw: \"{\\<chi> ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n    i < from_nat (Suc k)} = {\\<chi> ia. Gram_Schmidt_upt_k A k $ ia $ i |i. to_nat i \\<le> k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n     i < mod_type_class.from_nat (Suc k)} =\n    {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n     mod_type_class.to_nat i \\<le> k}", "proof (auto, vector, metis less_Suc_eq_le to_nat_le)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       mod_type_class.to_nat i \\<le> k \\<Longrightarrow>\n       \\<exists>ia.\n          (\\<lambda>ia. Gram_Schmidt_upt_k A k $ ia $ i) =\n          (\\<lambda>iaa. Gram_Schmidt_upt_k A k $ iaa $ ia) \\<and>\n          ia < mod_type_class.from_nat (Suc k)", "fix i::'cols"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       mod_type_class.to_nat i \\<le> k \\<Longrightarrow>\n       \\<exists>ia.\n          (\\<lambda>ia. Gram_Schmidt_upt_k A k $ ia $ i) =\n          (\\<lambda>iaa. Gram_Schmidt_upt_k A k $ iaa $ ia) \\<and>\n          ia < mod_type_class.from_nat (Suc k)", "assume \"to_nat i \\<le> k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       mod_type_class.to_nat i \\<le> k \\<Longrightarrow>\n       \\<exists>ia.\n          (\\<lambda>ia. Gram_Schmidt_upt_k A k $ ia $ i) =\n          (\\<lambda>iaa. Gram_Schmidt_upt_k A k $ iaa $ ia) \\<and>\n          ia < mod_type_class.from_nat (Suc k)", "hence \"to_nat i < Suc k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<le> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       mod_type_class.to_nat i \\<le> k \\<Longrightarrow>\n       \\<exists>ia.\n          (\\<lambda>ia. Gram_Schmidt_upt_k A k $ ia $ i) =\n          (\\<lambda>iaa. Gram_Schmidt_upt_k A k $ iaa $ ia) \\<and>\n          ia < mod_type_class.from_nat (Suc k)", "hence i_less_suc: \"i < from_nat (Suc k)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc k)", "using from_nat_le[OF _ k]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  mod_type_class.to_nat ?i < Suc k \\<Longrightarrow>\n  ?i < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc k)", "by simp"], ["proof (state)\nthis:\n  i < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       mod_type_class.to_nat i \\<le> k \\<Longrightarrow>\n       \\<exists>ia.\n          (\\<lambda>ia. Gram_Schmidt_upt_k A k $ ia $ i) =\n          (\\<lambda>iaa. Gram_Schmidt_upt_k A k $ iaa $ ia) \\<and>\n          ia < mod_type_class.from_nat (Suc k)", "show \"\\<exists>l. (\\<lambda>j. Gram_Schmidt_upt_k A k $ j $ i) = (\\<lambda>j'. Gram_Schmidt_upt_k A k $ j' $ l) \\<and>  l < mod_type_class.from_nat (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       (\\<lambda>j. Gram_Schmidt_upt_k A k $ j $ i) =\n       (\\<lambda>j'. Gram_Schmidt_upt_k A k $ j' $ l) \\<and>\n       l < mod_type_class.from_nat (Suc k)", "by (rule exI[of _ i], simp add: i_less_suc)"], ["proof (state)\nthis:\n  \\<exists>l.\n     (\\<lambda>j. Gram_Schmidt_upt_k A k $ j $ i) =\n     (\\<lambda>j'. Gram_Schmidt_upt_k A k $ j' $ l) \\<and>\n     l < mod_type_class.from_nat (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n   i < mod_type_class.from_nat (Suc k)} =\n  {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n   mod_type_class.to_nat i \\<le> k}\n\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n     mod_type_class.to_nat i \\<le> Suc k} =\n    {column i (Gram_Schmidt_upt_k A k) |i.\n     mod_type_class.to_nat i \\<le> k} \\<union>\n    {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n     (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                   mod_type_class.to_nat i \\<le> k}.\n        (x \\<bullet>\n         column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n         (x \\<bullet> x)) *\\<^sub>R\n        x)}", "have rw: \"[0..<Suc (Suc k)] = [0..<Suc k] @ [(Suc k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n     mod_type_class.to_nat i \\<le> Suc k} =\n    {column i (Gram_Schmidt_upt_k A k) |i.\n     mod_type_class.to_nat i \\<le> k} \\<union>\n    {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n     (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                   mod_type_class.to_nat i \\<le> k}.\n        (x \\<bullet>\n         column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n         (x \\<bullet> x)) *\\<^sub>R\n        x)}", "have \"{column i (Gram_Schmidt_upt_k A (Suc k)) |i. to_nat i\\<le>(Suc k)} \n    = {column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) |i. to_nat i \\<le> Suc k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n     mod_type_class.to_nat i \\<le> Suc k} =\n    {column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) |i.\n     mod_type_class.to_nat i \\<le> Suc k}", "unfolding Gram_Schmidt_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (foldl Gram_Schmidt_column_k A [0..<Suc (Suc k)]) |i.\n     mod_type_class.to_nat i \\<le> Suc k} =\n    {column i\n      (Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n        (Suc k)) |\n     i. mod_type_class.to_nat i \\<le> Suc k}", "unfolding rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (foldl Gram_Schmidt_column_k A ([0..<Suc k] @ [Suc k])) |i.\n     mod_type_class.to_nat i \\<le> Suc k} =\n    {column i\n      (Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n        (Suc k)) |\n     i. mod_type_class.to_nat i \\<le> Suc k}", "unfolding foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i\n      (foldl Gram_Schmidt_column_k\n        (foldl Gram_Schmidt_column_k A [0..<Suc k]) [Suc k]) |\n     i. mod_type_class.to_nat i \\<le> Suc k} =\n    {column i\n      (Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n        (Suc k)) |\n     i. mod_type_class.to_nat i \\<le> Suc k}", "unfolding foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i\n      (Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n        (Suc k)) |\n     i. mod_type_class.to_nat i \\<le> Suc k} =\n    {column i\n      (Gram_Schmidt_column_k (foldl Gram_Schmidt_column_k A [0..<Suc k])\n        (Suc k)) |\n     i. mod_type_class.to_nat i \\<le> Suc k}", ".."], ["proof (state)\nthis:\n  {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n   mod_type_class.to_nat i \\<le> Suc k} =\n  {column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) |i.\n   mod_type_class.to_nat i \\<le> Suc k}\n\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n     mod_type_class.to_nat i \\<le> Suc k} =\n    {column i (Gram_Schmidt_upt_k A k) |i.\n     mod_type_class.to_nat i \\<le> k} \\<union>\n    {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n     (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                   mod_type_class.to_nat i \\<le> k}.\n        (x \\<bullet>\n         column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n         (x \\<bullet> x)) *\\<^sub>R\n        x)}", "also"], ["proof (state)\nthis:\n  {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n   mod_type_class.to_nat i \\<le> Suc k} =\n  {column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) |i.\n   mod_type_class.to_nat i \\<le> Suc k}\n\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n     mod_type_class.to_nat i \\<le> Suc k} =\n    {column i (Gram_Schmidt_upt_k A k) |i.\n     mod_type_class.to_nat i \\<le> k} \\<union>\n    {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n     (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                   mod_type_class.to_nat i \\<le> k}.\n        (x \\<bullet>\n         column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n         (x \\<bullet> x)) *\\<^sub>R\n        x)}", "have \"... = {column i (Gram_Schmidt_upt_k A k) |i. to_nat i\\<le>k} \\<union> {column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k)\n    - (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i. to_nat i\\<le>k}. (x \\<bullet> (column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k)) / (x \\<bullet> x)) *\\<^sub>R x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) |i.\n     mod_type_class.to_nat i \\<le> Suc k} =\n    {column i (Gram_Schmidt_upt_k A k) |i.\n     mod_type_class.to_nat i \\<le> k} \\<union>\n    {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n     (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                   mod_type_class.to_nat i \\<le> k}.\n        (x \\<bullet>\n         column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n         (x \\<bullet> x)) *\\<^sub>R\n        x)}", "proof (auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>column i\n                 (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                   (Suc k)) \\<noteq>\n                column (mod_type_class.from_nat (Suc k))\n                 (Gram_Schmidt_upt_k A k) -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                              mod_type_class.to_nat i \\<le> k}.\n                   (x \\<bullet>\n                    column (mod_type_class.from_nat (Suc k))\n                     (Gram_Schmidt_upt_k A k) /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        mod_type_class.to_nat i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i\n                             (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                               (Suc k)) =\n                            column ia (Gram_Schmidt_upt_k A k) \\<and>\n                            mod_type_class.to_nat ia \\<le> k\n 2. \\<exists>i.\n       column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n       (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                     mod_type_class.to_nat i \\<le> k}.\n          (x \\<bullet>\n           column (mod_type_class.from_nat (Suc k))\n            (Gram_Schmidt_upt_k A k) /\n           (x \\<bullet> x)) *\\<^sub>R\n          x) =\n       column i\n        (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n       mod_type_class.to_nat i \\<le> Suc k\n 3. \\<And>i.\n       mod_type_class.to_nat i \\<le> k \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A k) =\n          column ia\n           (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n          mod_type_class.to_nat ia \\<le> Suc k", "fix i::'cols"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>column i\n                 (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                   (Suc k)) \\<noteq>\n                column (mod_type_class.from_nat (Suc k))\n                 (Gram_Schmidt_upt_k A k) -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                              mod_type_class.to_nat i \\<le> k}.\n                   (x \\<bullet>\n                    column (mod_type_class.from_nat (Suc k))\n                     (Gram_Schmidt_upt_k A k) /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        mod_type_class.to_nat i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i\n                             (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                               (Suc k)) =\n                            column ia (Gram_Schmidt_upt_k A k) \\<and>\n                            mod_type_class.to_nat ia \\<le> k\n 2. \\<exists>i.\n       column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n       (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                     mod_type_class.to_nat i \\<le> k}.\n          (x \\<bullet>\n           column (mod_type_class.from_nat (Suc k))\n            (Gram_Schmidt_upt_k A k) /\n           (x \\<bullet> x)) *\\<^sub>R\n          x) =\n       column i\n        (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n       mod_type_class.to_nat i \\<le> Suc k\n 3. \\<And>i.\n       mod_type_class.to_nat i \\<le> k \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A k) =\n          column ia\n           (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n          mod_type_class.to_nat ia \\<le> Suc k", "assume ik: \"to_nat i \\<le> k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> k\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>column i\n                 (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                   (Suc k)) \\<noteq>\n                column (mod_type_class.from_nat (Suc k))\n                 (Gram_Schmidt_upt_k A k) -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                              mod_type_class.to_nat i \\<le> k}.\n                   (x \\<bullet>\n                    column (mod_type_class.from_nat (Suc k))\n                     (Gram_Schmidt_upt_k A k) /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        mod_type_class.to_nat i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i\n                             (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                               (Suc k)) =\n                            column ia (Gram_Schmidt_upt_k A k) \\<and>\n                            mod_type_class.to_nat ia \\<le> k\n 2. \\<exists>i.\n       column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n       (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                     mod_type_class.to_nat i \\<le> k}.\n          (x \\<bullet>\n           column (mod_type_class.from_nat (Suc k))\n            (Gram_Schmidt_upt_k A k) /\n           (x \\<bullet> x)) *\\<^sub>R\n          x) =\n       column i\n        (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n       mod_type_class.to_nat i \\<le> Suc k\n 3. \\<And>i.\n       mod_type_class.to_nat i \\<le> k \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A k) =\n          column ia\n           (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n          mod_type_class.to_nat ia \\<le> Suc k", "show \"\\<exists>ia. column i (Gram_Schmidt_upt_k A k) \n      = column ia (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and> to_nat ia \\<le> Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i (Gram_Schmidt_upt_k A k) =\n       column ia\n        (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n       mod_type_class.to_nat ia \\<le> Suc k", "proof (rule exI[of _ i], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. column i (Gram_Schmidt_upt_k A k) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n 2. mod_type_class.to_nat i \\<le> Suc k", "have i_less_suc: \"to_nat i < Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc k", "using ik"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<le> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc k", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < Suc k\n\ngoal (2 subgoals):\n 1. column i (Gram_Schmidt_upt_k A k) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n 2. mod_type_class.to_nat i \\<le> Suc k", "thus \"to_nat i \\<le> Suc k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> Suc k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A k) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))", "show  \"column i (Gram_Schmidt_upt_k A k) = column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A k) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))", "using column_Gram_Schmidt_upt_k_preserves[OF i_less_suc k, of A]"], ["proof (prove)\nusing this:\n  column i (Gram_Schmidt_upt_k A (Suc k)) =\n  column i (Gram_Schmidt_upt_k A k)\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A k) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))", "unfolding Gram_Schmidt_upt_k_suc"], ["proof (prove)\nusing this:\n  column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n  column i (Gram_Schmidt_upt_k A k)\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A k) =\n    column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))", ".."], ["proof (state)\nthis:\n  column i (Gram_Schmidt_upt_k A k) =\n  column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i (Gram_Schmidt_upt_k A k) =\n     column ia\n      (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n     mod_type_class.to_nat ia \\<le> Suc k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>column i\n                 (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                   (Suc k)) \\<noteq>\n                column (mod_type_class.from_nat (Suc k))\n                 (Gram_Schmidt_upt_k A k) -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                              mod_type_class.to_nat i \\<le> k}.\n                   (x \\<bullet>\n                    column (mod_type_class.from_nat (Suc k))\n                     (Gram_Schmidt_upt_k A k) /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        mod_type_class.to_nat i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i\n                             (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                               (Suc k)) =\n                            column ia (Gram_Schmidt_upt_k A k) \\<and>\n                            mod_type_class.to_nat ia \\<le> k\n 2. \\<exists>i.\n       column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n       (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                     mod_type_class.to_nat i \\<le> k}.\n          (x \\<bullet>\n           column (mod_type_class.from_nat (Suc k))\n            (Gram_Schmidt_upt_k A k) /\n           (x \\<bullet> x)) *\\<^sub>R\n          x) =\n       column i\n        (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n       mod_type_class.to_nat i \\<le> Suc k", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>column i\n                 (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                   (Suc k)) \\<noteq>\n                column (mod_type_class.from_nat (Suc k))\n                 (Gram_Schmidt_upt_k A k) -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                              mod_type_class.to_nat i \\<le> k}.\n                   (x \\<bullet>\n                    column (mod_type_class.from_nat (Suc k))\n                     (Gram_Schmidt_upt_k A k) /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        mod_type_class.to_nat i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i\n                             (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                               (Suc k)) =\n                            column ia (Gram_Schmidt_upt_k A k) \\<and>\n                            mod_type_class.to_nat ia \\<le> k\n 2. \\<exists>i.\n       column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n       (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                     mod_type_class.to_nat i \\<le> k}.\n          (x \\<bullet>\n           column (mod_type_class.from_nat (Suc k))\n            (Gram_Schmidt_upt_k A k) /\n           (x \\<bullet> x)) *\\<^sub>R\n          x) =\n       column i\n        (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n       mod_type_class.to_nat i \\<le> Suc k", "show \"\\<exists>a. column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n      (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n      to_nat i \\<le> k}. (x \\<bullet> column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k) / (x \\<bullet> x)) *\\<^sub>R x) =\n      column a (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n      to_nat a \\<le> Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n       (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                     mod_type_class.to_nat i \\<le> k}.\n          (x \\<bullet>\n           column (mod_type_class.from_nat (Suc k))\n            (Gram_Schmidt_upt_k A k) /\n           (x \\<bullet> x)) *\\<^sub>R\n          x) =\n       column a\n        (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n       mod_type_class.to_nat a \\<le> Suc k", "proof (rule exI[of _ \"from_nat (Suc k)::'cols\"], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x) =\n    column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n 2. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) \\<le> Suc k", "show \"to_nat (from_nat (Suc k)::'cols) \\<le> Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) \\<le> Suc k", "unfolding to_nat_from_nat_id[OF k]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k \\<le> Suc k", ".."], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) \\<le> Suc k\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x) =\n    column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))", "show \"column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n        (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n        to_nat i \\<le> k}. (x \\<bullet> column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k) / (x \\<bullet> x)) *\\<^sub>R x) =\n        column (from_nat (Suc k)) (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x) =\n    column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))", "unfolding Gram_Schmidt_column_k_def column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        (\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x) =\n    (\\<chi>i.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat (Suc k)\n             then (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) -\n                  proj_onto (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b)\n                   {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i. i < b}\n             else \\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) $\n            a) $\n        i $\n        mod_type_class.from_nat (Suc k))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        (\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k) -\n        proj_onto\n         (\\<chi>i.\n             Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k))\n         {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n          i < mod_type_class.from_nat (Suc k)} $\n        i)", "unfolding set_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        (\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k) -\n        proj_onto\n         (\\<chi>i.\n             Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k))\n         {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n          mod_type_class.to_nat i \\<le> k} $\n        i)", "unfolding vector_scaleR_component[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        (\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k) -\n        proj_onto\n         (\\<chi>i.\n             Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k))\n         {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n          mod_type_class.to_nat i \\<le> k} $\n        i)", "unfolding sum_component[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        (\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k) -\n        proj_onto\n         (\\<chi>i.\n             Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k))\n         {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n          mod_type_class.to_nat i \\<le> k} $\n        i)", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        (\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k) -\n        (\\<Sum>u\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                      mod_type_class.to_nat i \\<le> k}.\n           ((\\<chi>i.\n                Gram_Schmidt_upt_k A k $ i $\n                mod_type_class.from_nat (Suc k)) \\<bullet>\n            u /\n            (u \\<bullet> u)) *\\<^sub>R\n           u) $\n        i)", "unfolding proj_onto_sum_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       ((\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $\n            mod_type_class.from_nat (Suc k)) \\<bullet>\n        x /\n        (x \\<bullet> x)) *\\<^sub>R\n       x) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k) -\n        (\\<Sum>u\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                      mod_type_class.to_nat i \\<le> k}.\n           ((\\<chi>i.\n                Gram_Schmidt_upt_k A k $ i $\n                mod_type_class.from_nat (Suc k)) \\<bullet>\n            u /\n            (u \\<bullet> u)) *\\<^sub>R\n           u) $\n        i)", "by vector"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                mod_type_class.to_nat i \\<le> k}.\n     (x \\<bullet>\n      column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n      (x \\<bullet> x)) *\\<^sub>R\n     x) =\n  column (mod_type_class.from_nat (Suc k))\n   (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a.\n     column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n     (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                   mod_type_class.to_nat i \\<le> k}.\n        (x \\<bullet>\n         column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n         (x \\<bullet> x)) *\\<^sub>R\n        x) =\n     column a\n      (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<and>\n     mod_type_class.to_nat a \\<le> Suc k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>column i\n                 (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                   (Suc k)) \\<noteq>\n                column (mod_type_class.from_nat (Suc k))\n                 (Gram_Schmidt_upt_k A k) -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                              mod_type_class.to_nat i \\<le> k}.\n                   (x \\<bullet>\n                    column (mod_type_class.from_nat (Suc k))\n                     (Gram_Schmidt_upt_k A k) /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        mod_type_class.to_nat i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i\n                             (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                               (Suc k)) =\n                            column ia (Gram_Schmidt_upt_k A k) \\<and>\n                            mod_type_class.to_nat ia \\<le> k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>column i\n                 (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                   (Suc k)) \\<noteq>\n                column (mod_type_class.from_nat (Suc k))\n                 (Gram_Schmidt_upt_k A k) -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                              mod_type_class.to_nat i \\<le> k}.\n                   (x \\<bullet>\n                    column (mod_type_class.from_nat (Suc k))\n                     (Gram_Schmidt_upt_k A k) /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        mod_type_class.to_nat i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i\n                             (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                               (Suc k)) =\n                            column ia (Gram_Schmidt_upt_k A k) \\<and>\n                            mod_type_class.to_nat ia \\<le> k", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>column i\n                 (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                   (Suc k)) \\<noteq>\n                column (mod_type_class.from_nat (Suc k))\n                 (Gram_Schmidt_upt_k A k) -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                              mod_type_class.to_nat i \\<le> k}.\n                   (x \\<bullet>\n                    column (mod_type_class.from_nat (Suc k))\n                     (Gram_Schmidt_upt_k A k) /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        mod_type_class.to_nat i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i\n                             (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                               (Suc k)) =\n                            column ia (Gram_Schmidt_upt_k A k) \\<and>\n                            mod_type_class.to_nat ia \\<le> k", "assume col_not_eq: \"column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<noteq>\n      column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n      (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n      to_nat i \\<le> k}. (x \\<bullet> column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k) / (x \\<bullet> x)) *\\<^sub>R x)\"\n      and i: \"to_nat i \\<le> Suc k\""], ["proof (state)\nthis:\n  column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<noteq>\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                mod_type_class.to_nat i \\<le> k}.\n     (x \\<bullet>\n      column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n  mod_type_class.to_nat i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>column i\n                 (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                   (Suc k)) \\<noteq>\n                column (mod_type_class.from_nat (Suc k))\n                 (Gram_Schmidt_upt_k A k) -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                              mod_type_class.to_nat i \\<le> k}.\n                   (x \\<bullet>\n                    column (mod_type_class.from_nat (Suc k))\n                     (Gram_Schmidt_upt_k A k) /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        mod_type_class.to_nat i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i\n                             (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                               (Suc k)) =\n                            column ia (Gram_Schmidt_upt_k A k) \\<and>\n                            mod_type_class.to_nat ia \\<le> k", "have i_not_suc_k: \"i \\<noteq> from_nat (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc k)", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. i = mod_type_class.from_nat (Suc k) \\<Longrightarrow> False", "assume i2: \"i = from_nat (Suc k)\""], ["proof (state)\nthis:\n  i = mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. i = mod_type_class.from_nat (Suc k) \\<Longrightarrow> False", "have \"column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n        column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n        (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n        to_nat i \\<le> k}. (x \\<bullet> column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k) / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "unfolding i2  Gram_Schmidt_column_k_def column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat (Suc k)\n             then (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) -\n                  proj_onto (\\<chi>i. Gram_Schmidt_upt_k A k $ i $ b)\n                   {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i. i < b}\n             else \\<chi>i. Gram_Schmidt_upt_k A k $ i $ b) $\n            a) $\n        i $\n        mod_type_class.from_nat (Suc k)) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        (\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k) -\n        proj_onto\n         (\\<chi>i.\n             Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k))\n         {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n          i < mod_type_class.from_nat (Suc k)} $\n        i) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        (\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "unfolding set_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k) -\n        proj_onto\n         (\\<chi>i.\n             Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k))\n         {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n          mod_type_class.to_nat i \\<le> k} $\n        i) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        (\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "unfolding vector_scaleR_component[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k) -\n        proj_onto\n         (\\<chi>i.\n             Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k))\n         {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n          mod_type_class.to_nat i \\<le> k} $\n        i) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        (\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "unfolding sum_component[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k) -\n        proj_onto\n         (\\<chi>i.\n             Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k))\n         {\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n          mod_type_class.to_nat i \\<le> k} $\n        i) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        (\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k) -\n        (\\<Sum>u\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                      mod_type_class.to_nat i \\<le> k}.\n           ((\\<chi>i.\n                Gram_Schmidt_upt_k A k $ i $\n                mod_type_class.from_nat (Suc k)) \\<bullet>\n            u /\n            (u \\<bullet> u)) *\\<^sub>R\n           u) $\n        i) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       (x \\<bullet>\n        (\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "unfolding proj_onto_sum_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k) -\n        (\\<Sum>u\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                      mod_type_class.to_nat i \\<le> k}.\n           ((\\<chi>i.\n                Gram_Schmidt_upt_k A k $ i $\n                mod_type_class.from_nat (Suc k)) \\<bullet>\n            u /\n            (u \\<bullet> u)) *\\<^sub>R\n           u) $\n        i) =\n    (\\<chi>i.\n        Gram_Schmidt_upt_k A k $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. Gram_Schmidt_upt_k A k $ ia $ i |i.\n                  mod_type_class.to_nat i \\<le> k}.\n       ((\\<chi>i.\n            Gram_Schmidt_upt_k A k $ i $\n            mod_type_class.from_nat (Suc k)) \\<bullet>\n        x /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "by vector"], ["proof (state)\nthis:\n  column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                mod_type_class.to_nat i \\<le> k}.\n     (x \\<bullet>\n      column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n\ngoal (1 subgoal):\n 1. i = mod_type_class.from_nat (Suc k) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                mod_type_class.to_nat i \\<le> k}.\n     (x \\<bullet>\n      column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n\ngoal (1 subgoal):\n 1. False", "using col_not_eq"], ["proof (prove)\nusing this:\n  column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                mod_type_class.to_nat i \\<le> k}.\n     (x \\<bullet>\n      column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n  column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \\<noteq>\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                mod_type_class.to_nat i \\<le> k}.\n     (x \\<bullet>\n      column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>column i\n                 (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                   (Suc k)) \\<noteq>\n                column (mod_type_class.from_nat (Suc k))\n                 (Gram_Schmidt_upt_k A k) -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                              mod_type_class.to_nat i \\<le> k}.\n                   (x \\<bullet>\n                    column (mod_type_class.from_nat (Suc k))\n                     (Gram_Schmidt_upt_k A k) /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        mod_type_class.to_nat i \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i\n                             (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n                               (Suc k)) =\n                            column ia (Gram_Schmidt_upt_k A k) \\<and>\n                            mod_type_class.to_nat ia \\<le> k", "show \"\\<exists>ia. column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) \n      = column ia (Gram_Schmidt_upt_k A k) \\<and> to_nat ia \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n       column ia (Gram_Schmidt_upt_k A k) \\<and>\n       mod_type_class.to_nat ia \\<le> k", "proof (rule exI[of _ i], rule conjI, unfold Gram_Schmidt_upt_k_suc[symmetric], rule column_Gram_Schmidt_upt_k_preserves)"], ["proof (state)\ngoal (3 subgoals):\n 1. mod_type_class.to_nat i < Suc k\n 2. Suc k < CARD('cols)\n 3. mod_type_class.to_nat i \\<le> k", "show \"to_nat i < Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc k", "using i i_not_suc_k"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<le> Suc k\n  i \\<noteq> mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < Suc k", "by (metis le_imp_less_or_eq from_nat_to_nat_id)"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < Suc k\n\ngoal (2 subgoals):\n 1. Suc k < CARD('cols)\n 2. mod_type_class.to_nat i \\<le> k", "thus \"to_nat i \\<le> k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> k", "using less_Suc_eq_le"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < Suc k\n  (?m < Suc ?n) = (?m \\<le> ?n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> k\n\ngoal (1 subgoal):\n 1. Suc k < CARD('cols)", "show \"Suc k < CARD('cols)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k < CARD('cols)", "using k"], ["proof (prove)\nusing this:\n  Suc k < CARD('cols)\n\ngoal (1 subgoal):\n 1. Suc k < CARD('cols)", "."], ["proof (state)\nthis:\n  Suc k < CARD('cols)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n     column ia (Gram_Schmidt_upt_k A k) \\<and>\n     mod_type_class.to_nat ia \\<le> k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {column i (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) |i.\n   mod_type_class.to_nat i \\<le> Suc k} =\n  {column i (Gram_Schmidt_upt_k A k) |i.\n   mod_type_class.to_nat i \\<le> k} \\<union>\n  {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n   (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                 mod_type_class.to_nat i \\<le> k}.\n      (x \\<bullet>\n       column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n       (x \\<bullet> x)) *\\<^sub>R\n      x)}\n\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n     mod_type_class.to_nat i \\<le> Suc k} =\n    {column i (Gram_Schmidt_upt_k A k) |i.\n     mod_type_class.to_nat i \\<le> k} \\<union>\n    {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n     (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                   mod_type_class.to_nat i \\<le> k}.\n        (x \\<bullet>\n         column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n         (x \\<bullet> x)) *\\<^sub>R\n        x)}", "finally"], ["proof (chain)\npicking this:\n  {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n   mod_type_class.to_nat i \\<le> Suc k} =\n  {column i (Gram_Schmidt_upt_k A k) |i.\n   mod_type_class.to_nat i \\<le> k} \\<union>\n  {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n   (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                 mod_type_class.to_nat i \\<le> k}.\n      (x \\<bullet>\n       column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n       (x \\<bullet> x)) *\\<^sub>R\n      x)}", "show ?thesis"], ["proof (prove)\nusing this:\n  {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n   mod_type_class.to_nat i \\<le> Suc k} =\n  {column i (Gram_Schmidt_upt_k A k) |i.\n   mod_type_class.to_nat i \\<le> k} \\<union>\n  {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n   (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                 mod_type_class.to_nat i \\<le> k}.\n      (x \\<bullet>\n       column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n       (x \\<bullet> x)) *\\<^sub>R\n      x)}\n\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n     mod_type_class.to_nat i \\<le> Suc k} =\n    {column i (Gram_Schmidt_upt_k A k) |i.\n     mod_type_class.to_nat i \\<le> k} \\<union>\n    {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n     (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                   mod_type_class.to_nat i \\<le> k}.\n        (x \\<bullet>\n         column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n         (x \\<bullet> x)) *\\<^sub>R\n        x)}", "."], ["proof (state)\nthis:\n  {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n   mod_type_class.to_nat i \\<le> Suc k} =\n  {column i (Gram_Schmidt_upt_k A k) |i.\n   mod_type_class.to_nat i \\<le> k} \\<union>\n  {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n   (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                 mod_type_class.to_nat i \\<le> k}.\n      (x \\<bullet>\n       column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n       (x \\<bullet> x)) *\\<^sub>R\n      x)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_Gram_Schmidt_upt_k:\n  assumes s: \"k < ncols A\"\n  shows \"pairwise orthogonal ({column i (Gram_Schmidt_upt_k A k) |i. to_nat i\\<le>k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A k) |i. mod_type_class.to_nat i \\<le> k}", "using s"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A k) |i. mod_type_class.to_nat i \\<le> k}", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A 0) |i. mod_type_class.to_nat i \\<le> 0}\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                pairwise orthogonal\n                 {column i (Gram_Schmidt_upt_k A k) |i.\n                  mod_type_class.to_nat i \\<le> k};\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> pairwise orthogonal\n                          {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n                           mod_type_class.to_nat i \\<le> Suc k}", "case 0"], ["proof (state)\nthis:\n  0 < ncols A\n\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A 0) |i. mod_type_class.to_nat i \\<le> 0}\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                pairwise orthogonal\n                 {column i (Gram_Schmidt_upt_k A k) |i.\n                  mod_type_class.to_nat i \\<le> k};\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> pairwise orthogonal\n                          {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n                           mod_type_class.to_nat i \\<le> Suc k}", "have set_rw: \"{column i (Gram_Schmidt_upt_k A 0) |i. to_nat i \\<le> 0} =  {column 0 (Gram_Schmidt_upt_k A 0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A 0) |i.\n     mod_type_class.to_nat i \\<le> 0} =\n    {column (0::'b) (Gram_Schmidt_upt_k A 0)}", "by (simp add: to_nat_eq_0)"], ["proof (state)\nthis:\n  {column i (Gram_Schmidt_upt_k A 0) |i. mod_type_class.to_nat i \\<le> 0} =\n  {column (0::'b) (Gram_Schmidt_upt_k A 0)}\n\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A 0) |i. mod_type_class.to_nat i \\<le> 0}\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                pairwise orthogonal\n                 {column i (Gram_Schmidt_upt_k A k) |i.\n                  mod_type_class.to_nat i \\<le> k};\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> pairwise orthogonal\n                          {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n                           mod_type_class.to_nat i \\<le> Suc k}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A 0) |i. mod_type_class.to_nat i \\<le> 0}", "unfolding set_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal {column (0::'b) (Gram_Schmidt_upt_k A 0)}", "unfolding pairwise_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{column (0::'b) (Gram_Schmidt_upt_k A 0)}.\n       \\<forall>y\\<in>{column (0::'b) (Gram_Schmidt_upt_k A 0)}.\n          x \\<noteq> y \\<longrightarrow> orthogonal x y", "by auto"], ["proof (state)\nthis:\n  pairwise orthogonal\n   {column i (Gram_Schmidt_upt_k A 0) |i. mod_type_class.to_nat i \\<le> 0}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                pairwise orthogonal\n                 {column i (Gram_Schmidt_upt_k A k) |i.\n                  mod_type_class.to_nat i \\<le> k};\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> pairwise orthogonal\n                          {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n                           mod_type_class.to_nat i \\<le> Suc k}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                pairwise orthogonal\n                 {column i (Gram_Schmidt_upt_k A k) |i.\n                  mod_type_class.to_nat i \\<le> k};\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> pairwise orthogonal\n                          {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n                           mod_type_class.to_nat i \\<le> Suc k}", "case (Suc k)"], ["proof (state)\nthis:\n  k < ncols A \\<Longrightarrow>\n  pairwise orthogonal\n   {column i (Gram_Schmidt_upt_k A k) |i. mod_type_class.to_nat i \\<le> k}\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                pairwise orthogonal\n                 {column i (Gram_Schmidt_upt_k A k) |i.\n                  mod_type_class.to_nat i \\<le> k};\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> pairwise orthogonal\n                          {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n                           mod_type_class.to_nat i \\<le> Suc k}", "have rw: \"[0..<Suc (Suc k)] = [0..<Suc k] @ [(Suc k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                pairwise orthogonal\n                 {column i (Gram_Schmidt_upt_k A k) |i.\n                  mod_type_class.to_nat i \\<le> k};\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> pairwise orthogonal\n                          {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n                           mod_type_class.to_nat i \\<le> Suc k}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n      mod_type_class.to_nat i \\<le> Suc k}", "unfolding column_set_Gram_Schmidt_upt_k[OF Suc.prems[unfolded ncols_def], of A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     ({column i (Gram_Schmidt_upt_k A k) |i.\n       mod_type_class.to_nat i \\<le> k} \\<union>\n      {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n       (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                     mod_type_class.to_nat i \\<le> k}.\n          (x \\<bullet>\n           column (mod_type_class.from_nat (Suc k))\n            (Gram_Schmidt_upt_k A k) /\n           (x \\<bullet> x)) *\\<^sub>R\n          x)})", "unfolding proj_onto_sum_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     ({column i (Gram_Schmidt_upt_k A k) |i.\n       mod_type_class.to_nat i \\<le> k} \\<union>\n      {column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n       (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                     mod_type_class.to_nat i \\<le> k}.\n          (column (mod_type_class.from_nat (Suc k))\n            (Gram_Schmidt_upt_k A k) \\<bullet>\n           x /\n           (x \\<bullet> x)) *\\<^sub>R\n          x)})", "by (auto simp add: proj_def[symmetric] proj_onto_def[symmetric])\n       (rule pairwise_orthogonal_proj_set, auto simp add: Suc.hyps Suc.prems Suc_lessD)"], ["proof (state)\nthis:\n  pairwise orthogonal\n   {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n    mod_type_class.to_nat i \\<le> Suc k}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma columns_Gram_Schmidt_matrix_rw: \n  \"{column i (Gram_Schmidt_matrix A) |i. i \\<in> UNIV} \n  = {column i (Gram_Schmidt_upt_k A (ncols A - 1)) |i. to_nat i\\<le> (ncols A - 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_matrix A) |i. i \\<in> UNIV} =\n    {column i (Gram_Schmidt_upt_k A (ncols A - 1)) |i.\n     mod_type_class.to_nat i \\<le> ncols A - 1}", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<exists>ia.\n          column i (Gram_Schmidt_matrix A) =\n          column ia (Gram_Schmidt_upt_k A (ncols A - Suc 0)) \\<and>\n          mod_type_class.to_nat ia \\<le> ncols A - Suc 0\n 2. \\<And>i.\n       mod_type_class.to_nat i \\<le> ncols A - Suc 0 \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A (ncols A - Suc 0)) =\n          column ia (Gram_Schmidt_matrix A)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<exists>ia.\n          column i (Gram_Schmidt_matrix A) =\n          column ia (Gram_Schmidt_upt_k A (ncols A - Suc 0)) \\<and>\n          mod_type_class.to_nat ia \\<le> ncols A - Suc 0\n 2. \\<And>i.\n       mod_type_class.to_nat i \\<le> ncols A - Suc 0 \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A (ncols A - Suc 0)) =\n          column ia (Gram_Schmidt_matrix A)", "show \"\\<exists>ia. column i (Gram_Schmidt_matrix A) \n    = column ia (Gram_Schmidt_upt_k A (ncols A - Suc 0)) \\<and> to_nat ia \\<le> ncols A - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i (Gram_Schmidt_matrix A) =\n       column ia (Gram_Schmidt_upt_k A (ncols A - Suc 0)) \\<and>\n       mod_type_class.to_nat ia \\<le> ncols A - Suc 0", "apply (rule exI[of _ i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_matrix A) =\n    column i (Gram_Schmidt_upt_k A (ncols A - Suc 0)) \\<and>\n    mod_type_class.to_nat i \\<le> ncols A - Suc 0", "unfolding Gram_Schmidt_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (ncols A - 1)) =\n    column i (Gram_Schmidt_upt_k A (ncols A - Suc 0)) \\<and>\n    mod_type_class.to_nat i \\<le> ncols A - Suc 0", "using to_nat_less_card[of i]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < CARD('c)\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (ncols A - 1)) =\n    column i (Gram_Schmidt_upt_k A (ncols A - Suc 0)) \\<and>\n    mod_type_class.to_nat i \\<le> ncols A - Suc 0", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < CARD('c)\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (CARD('c) - 1)) =\n    column i (Gram_Schmidt_upt_k A (CARD('c) - Suc 0)) \\<and>\n    mod_type_class.to_nat i \\<le> CARD('c) - Suc 0", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i (Gram_Schmidt_matrix A) =\n     column ia (Gram_Schmidt_upt_k A (ncols A - Suc 0)) \\<and>\n     mod_type_class.to_nat ia \\<le> ncols A - Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       mod_type_class.to_nat i \\<le> ncols A - Suc 0 \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A (ncols A - Suc 0)) =\n          column ia (Gram_Schmidt_matrix A)", "show \"\\<exists>ia. column i (Gram_Schmidt_upt_k A (ncols A - Suc 0)) = column ia (Gram_Schmidt_matrix A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i (Gram_Schmidt_upt_k A (ncols A - Suc 0)) =\n       column ia (Gram_Schmidt_matrix A)", "unfolding Gram_Schmidt_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i (Gram_Schmidt_upt_k A (ncols A - Suc 0)) =\n       column ia (Gram_Schmidt_upt_k A (ncols A - 1))", "by auto"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i (Gram_Schmidt_upt_k A (ncols A - Suc 0)) =\n     column ia (Gram_Schmidt_matrix A)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary orthogonal_Gram_Schmidt_matrix:\n  shows \"pairwise orthogonal ({column i (Gram_Schmidt_matrix A) |i. i \\<in> UNIV})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal {column i (Gram_Schmidt_matrix A) |i. i \\<in> UNIV}", "unfolding columns_Gram_Schmidt_matrix_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal\n     {column i (Gram_Schmidt_upt_k A (ncols A - 1)) |i.\n      mod_type_class.to_nat i \\<le> ncols A - 1}", "by (rule orthogonal_Gram_Schmidt_upt_k, simp add: ncols_def)"], ["", "corollary orthogonal_Gram_Schmidt_matrix2:\n  shows \"pairwise orthogonal (columns (Gram_Schmidt_matrix A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal (columns (Gram_Schmidt_matrix A))", "unfolding columns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise orthogonal {column i (Gram_Schmidt_matrix A) |i. i \\<in> UNIV}", "using orthogonal_Gram_Schmidt_matrix"], ["proof (prove)\nusing this:\n  pairwise orthogonal {column i (Gram_Schmidt_matrix ?A) |i. i \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. pairwise orthogonal {column i (Gram_Schmidt_matrix A) |i. i \\<in> UNIV}", "."], ["", "lemma column_Gram_Schmidt_column_k:\n  fixes A::\"'a::{real_inner}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"column k (Gram_Schmidt_column_k A (to_nat k)) = \n  (column k A) - (\\<Sum>x\\<in>{column i A|i. i < k}. (x \\<bullet> (column k A) / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) =\n    column k A -\n    (\\<Sum>x\\<in>{column i A |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "unfolding Gram_Schmidt_column_k_def column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat (mod_type_class.to_nat k)\n             then (\\<chi>i. A $ i $ b) -\n                  proj_onto (\\<chi>i. A $ i $ b)\n                   {\\<chi>ia. A $ ia $ i |i. i < b}\n             else \\<chi>i. A $ i $ b) $\n            a) $\n        i $\n        k) =\n    (\\<chi>i. A $ i $ k) -\n    (\\<Sum>x\\<in>{\\<chi>ia. A $ ia $ i |i. i < k}.\n       (x \\<bullet> (\\<chi>i. A $ i $ k) / (x \\<bullet> x)) *\\<^sub>R x)", "unfolding from_nat_to_nat_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        (\\<chi>a b.\n            (if b = k\n             then (\\<chi>i. A $ i $ b) -\n                  proj_onto (\\<chi>i. A $ i $ b)\n                   {\\<chi>ia. A $ ia $ i |i. i < b}\n             else \\<chi>i. A $ i $ b) $\n            a) $\n        i $\n        k) =\n    (\\<chi>i. A $ i $ k) -\n    (\\<Sum>x\\<in>{\\<chi>ia. A $ ia $ i |i. i < k}.\n       (x \\<bullet> (\\<chi>i. A $ i $ k) / (x \\<bullet> x)) *\\<^sub>R x)", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        (\\<chi>a b.\n            (if b = k\n             then (\\<chi>i. A $ i $ b) -\n                  (\\<Sum>u\\<in>{\\<chi>ia. A $ ia $ i |i. i < b}.\n                     ((\\<chi>i. A $ i $ b) \\<bullet> u /\n                      (u \\<bullet> u)) *\\<^sub>R\n                     u)\n             else \\<chi>i. A $ i $ b) $\n            a) $\n        i $\n        k) =\n    (\\<chi>i. A $ i $ k) -\n    (\\<Sum>x\\<in>{\\<chi>ia. A $ ia $ i |i. i < k}.\n       (x \\<bullet> (\\<chi>i. A $ i $ k) / (x \\<bullet> x)) *\\<^sub>R x)", "unfolding proj_onto_sum_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        (\\<chi>a b.\n            (if b = k\n             then (\\<chi>i. A $ i $ b) -\n                  (\\<Sum>u\\<in>{\\<chi>ia. A $ ia $ i |i. i < b}.\n                     ((\\<chi>i. A $ i $ b) \\<bullet> u /\n                      (u \\<bullet> u)) *\\<^sub>R\n                     u)\n             else \\<chi>i. A $ i $ b) $\n            a) $\n        i $\n        k) =\n    (\\<chi>i. A $ i $ k) -\n    (\\<Sum>x\\<in>{\\<chi>ia. A $ ia $ i |i. i < k}.\n       ((\\<chi>i. A $ i $ k) \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x)", "by vector"], ["", "lemma column_Gram_Schmidt_column_k':\n  fixes A::\"'a::{real_inner}^'n::{mod_type}^'m::{mod_type}\"\n  assumes i_not_k: \"i\\<noteq>k\"\n  shows \"column i (Gram_Schmidt_column_k A (to_nat k)) = (column i A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) =\n    column i A", "using i_not_k"], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_column_k A (mod_type_class.to_nat k)) =\n    column i A", "unfolding Gram_Schmidt_column_k_def column_def"], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. (\\<chi>ia.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat (mod_type_class.to_nat k)\n             then (\\<chi>i. A $ i $ b) -\n                  proj_onto (\\<chi>i. A $ i $ b)\n                   {\\<chi>ia. A $ ia $ i |i. i < b}\n             else \\<chi>i. A $ i $ b) $\n            a) $\n        ia $\n        i) =\n    (\\<chi>ia. A $ ia $ i)", "unfolding from_nat_to_nat_id"], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. (\\<chi>ia.\n        (\\<chi>a b.\n            (if b = k\n             then (\\<chi>i. A $ i $ b) -\n                  proj_onto (\\<chi>i. A $ i $ b)\n                   {\\<chi>ia. A $ ia $ i |i. i < b}\n             else \\<chi>i. A $ i $ b) $\n            a) $\n        ia $\n        i) =\n    (\\<chi>ia. A $ ia $ i)", "by vector"], ["", "definition \"cols_upt_k A k = {column i A|i. i\\<le>from_nat k}\""], ["", "lemma cols_upt_k_insert:\n  fixes A::\"'a^'n::{mod_type}^'m::{mod_type}\"\n  assumes k: \"(Suc k)<ncols A\"\n  shows \"cols_upt_k A (Suc k) = (insert (column (from_nat (Suc k)) A) (cols_upt_k A k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cols_upt_k A (Suc k) =\n    insert (column (mod_type_class.from_nat (Suc k)) A) (cols_upt_k A k)", "proof (unfold cols_upt_k_def, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>column i A \\<noteq>\n                column (mod_type_class.from_nat (Suc k)) A;\n        i \\<le> mod_type_class.from_nat (Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i A = column ia A \\<and>\n                            ia \\<le> mod_type_class.from_nat k\n 2. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (Suc k)", "fix i::'n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>column i A \\<noteq>\n                column (mod_type_class.from_nat (Suc k)) A;\n        i \\<le> mod_type_class.from_nat (Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i A = column ia A \\<and>\n                            ia \\<le> mod_type_class.from_nat k\n 2. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (Suc k)", "assume i: \"i \\<le> from_nat (Suc k)\" and \"column i A \\<noteq> column (from_nat (Suc k)) A\""], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat (Suc k)\n  column i A \\<noteq> column (mod_type_class.from_nat (Suc k)) A\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>column i A \\<noteq>\n                column (mod_type_class.from_nat (Suc k)) A;\n        i \\<le> mod_type_class.from_nat (Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i A = column ia A \\<and>\n                            ia \\<le> mod_type_class.from_nat k\n 2. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (Suc k)", "hence i_not_suc_k: \"i \\<noteq> from_nat (Suc k)\""], ["proof (prove)\nusing this:\n  i \\<le> mod_type_class.from_nat (Suc k)\n  column i A \\<noteq> column (mod_type_class.from_nat (Suc k)) A\n\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat (Suc k)", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.from_nat (Suc k)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>column i A \\<noteq>\n                column (mod_type_class.from_nat (Suc k)) A;\n        i \\<le> mod_type_class.from_nat (Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i A = column ia A \\<and>\n                            ia \\<le> mod_type_class.from_nat k\n 2. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (Suc k)", "have i_le:  \"i \\<le> from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat k", "have \"i < from_nat (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < mod_type_class.from_nat (Suc k)", "by (metis le_imp_less_or_eq i i_not_suc_k)"], ["proof (state)\nthis:\n  i < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat k", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat k", "by (metis Suc_eq_plus1 from_nat_suc le_Suc not_less)"], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>column i A \\<noteq>\n                column (mod_type_class.from_nat (Suc k)) A;\n        i \\<le> mod_type_class.from_nat (Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            column i A = column ia A \\<and>\n                            ia \\<le> mod_type_class.from_nat k\n 2. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (Suc k)", "thus \"\\<exists>ia. column i A = column ia A \\<and> ia \\<le> from_nat k\""], ["proof (prove)\nusing this:\n  i \\<le> mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k", "by auto"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (Suc k)", "fix i::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (Suc k)", "assume i: \"i \\<le> from_nat k\""], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (Suc k)", "also"], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (Suc k)", "have \"... < from_nat (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k < mod_type_class.from_nat (Suc k)", "by (rule from_nat_mono[OF _ k[unfolded ncols_def]], simp)"], ["proof (state)\nthis:\n  mod_type_class.from_nat k < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (Suc k)", "finally"], ["proof (chain)\npicking this:\n  i < mod_type_class.from_nat (Suc k)", "have \"i \\<le> from_nat (Suc k)\""], ["proof (prove)\nusing this:\n  i < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat (Suc k)", "by simp"], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (Suc k)", "thus \"\\<exists>ia. column i A = column ia A \\<and> ia \\<le> from_nat (Suc k)\""], ["proof (prove)\nusing this:\n  i \\<le> mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i A = column ia A \\<and>\n       ia \\<le> mod_type_class.from_nat (Suc k)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i A = column ia A \\<and>\n     ia \\<le> mod_type_class.from_nat (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma columns_eq_cols_upt_k:\n  fixes A::\"'a^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"cols_upt_k A (ncols A - 1) = columns A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cols_upt_k A (ncols A - 1) = columns A", "proof (unfold cols_upt_k_def columns_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (ncols A - Suc 0)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia \\<le> mod_type_class.from_nat (ncols A - Suc 0)", "show \"\\<exists>ia. column i A = column ia A \\<and> ia \\<le> from_nat (ncols A - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i A = column ia A \\<and>\n       ia \\<le> mod_type_class.from_nat (ncols A - Suc 0)", "proof (rule exI[of _ i], simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat (ncols A - Suc 0)", "have \"to_nat i < ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < ncols A", "using to_nat_less_card[of i]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < CARD('cols)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < ncols A", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < CARD('cols)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('cols)", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < ncols A\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat (ncols A - Suc 0)", "hence \"to_nat i \\<le> (ncols A - 1)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < ncols A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> ncols A - 1", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> ncols A - 1\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat (ncols A - Suc 0)", "hence \"to_nat i \\<le> to_nat (from_nat (ncols A - 1)::'cols)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<le> ncols A - 1\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i\n    \\<le> mod_type_class.to_nat (mod_type_class.from_nat (ncols A - 1))", "using to_nat_from_nat_id[of \"ncols A - 1\", where ?'a='cols]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<le> ncols A - 1\n  ncols A - 1 < CARD('cols) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat (ncols A - 1)) =\n  ncols A - 1\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i\n    \\<le> mod_type_class.to_nat (mod_type_class.from_nat (ncols A - 1))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<le> CARD('cols) - 1\n  CARD('cols) - 1 < CARD('cols) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat (CARD('cols) - 1)) =\n  CARD('cols) - 1\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i\n    \\<le> mod_type_class.to_nat (mod_type_class.from_nat (CARD('cols) - 1))", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat i\n  \\<le> mod_type_class.to_nat (mod_type_class.from_nat (ncols A - 1))\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat (ncols A - Suc 0)", "thus \"i \\<le> from_nat (ncols A - Suc 0)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i\n  \\<le> mod_type_class.to_nat (mod_type_class.from_nat (ncols A - 1))\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat (ncols A - Suc 0)", "by (metis One_nat_def less_le_not_le linear to_nat_mono)"], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat (ncols A - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i A = column ia A \\<and>\n     ia \\<le> mod_type_class.from_nat (ncols A - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma span_cols_upt_k_Gram_Schmidt_column_k:\n  fixes A::\"'a::{real_inner}^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"k < ncols A\"\n  and \"j < ncols A\"\n  shows \"span (cols_upt_k A k) = span (cols_upt_k (Gram_Schmidt_column_k A j) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (cols_upt_k A k) = span (cols_upt_k (Gram_Schmidt_column_k A j) k)", "using assms"], ["proof (prove)\nusing this:\n  k < ncols A\n  j < ncols A\n\ngoal (1 subgoal):\n 1. span (cols_upt_k A k) = span (cols_upt_k (Gram_Schmidt_column_k A j) k)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < ncols A; j < ncols A\\<rbrakk>\n    \\<Longrightarrow> span (cols_upt_k A 0) =\n                      span (cols_upt_k (Gram_Schmidt_column_k A j) 0)\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n                \\<Longrightarrow> span (cols_upt_k A k) =\n                                  span\n                                   (cols_upt_k (Gram_Schmidt_column_k A j)\n                                     k);\n        Suc k < ncols A; j < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (cols_upt_k A (Suc k)) =\n                         span\n                          (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "case 0"], ["proof (state)\nthis:\n  0 < ncols A\n  j < ncols A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < ncols A; j < ncols A\\<rbrakk>\n    \\<Longrightarrow> span (cols_upt_k A 0) =\n                      span (cols_upt_k (Gram_Schmidt_column_k A j) 0)\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n                \\<Longrightarrow> span (cols_upt_k A k) =\n                                  span\n                                   (cols_upt_k (Gram_Schmidt_column_k A j)\n                                     k);\n        Suc k < ncols A; j < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (cols_upt_k A (Suc k)) =\n                         span\n                          (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have set_rw: \"{\\<chi> ia. A $ ia $ i |i. i < 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<chi>ia. A $ ia $ i |i. i < (0::'n)} = {}", "using least_mod_type not_less"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> ?n\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. {\\<chi>ia. A $ ia $ i |i. i < (0::'n)} = {}", "by auto"], ["proof (state)\nthis:\n  {\\<chi>ia. A $ ia $ i |i. i < (0::'n)} = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < ncols A; j < ncols A\\<rbrakk>\n    \\<Longrightarrow> span (cols_upt_k A 0) =\n                      span (cols_upt_k (Gram_Schmidt_column_k A j) 0)\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n                \\<Longrightarrow> span (cols_upt_k A k) =\n                                  span\n                                   (cols_upt_k (Gram_Schmidt_column_k A j)\n                                     k);\n        Suc k < ncols A; j < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (cols_upt_k A (Suc k)) =\n                         span\n                          (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have set_rw2: \"{column i (Gram_Schmidt_column_k A j) |i. i \\<le> 0} = {column 0 (Gram_Schmidt_column_k A j)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_column_k A j) |i. i \\<le> (0::'n)} =\n    {column (0::'n) (Gram_Schmidt_column_k A j)}", "by (auto, metis eq_iff least_mod_type)"], ["proof (state)\nthis:\n  {column i (Gram_Schmidt_column_k A j) |i. i \\<le> (0::'n)} =\n  {column (0::'n) (Gram_Schmidt_column_k A j)}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < ncols A; j < ncols A\\<rbrakk>\n    \\<Longrightarrow> span (cols_upt_k A 0) =\n                      span (cols_upt_k (Gram_Schmidt_column_k A j) 0)\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n                \\<Longrightarrow> span (cols_upt_k A k) =\n                                  span\n                                   (cols_upt_k (Gram_Schmidt_column_k A j)\n                                     k);\n        Suc k < ncols A; j < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (cols_upt_k A (Suc k)) =\n                         span\n                          (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have set_rw3: \"{column i A |i. i \\<le> 0} ={column 0 A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i A |i. i \\<le> (0::'n)} = {column (0::'n) A}", "by (auto, metis eq_iff least_mod_type)"], ["proof (state)\nthis:\n  {column i A |i. i \\<le> (0::'n)} = {column (0::'n) A}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < ncols A; j < ncols A\\<rbrakk>\n    \\<Longrightarrow> span (cols_upt_k A 0) =\n                      span (cols_upt_k (Gram_Schmidt_column_k A j) 0)\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n                \\<Longrightarrow> span (cols_upt_k A k) =\n                                  span\n                                   (cols_upt_k (Gram_Schmidt_column_k A j)\n                                     k);\n        Suc k < ncols A; j < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (cols_upt_k A (Suc k)) =\n                         span\n                          (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have col_0_eq: \"column 0 (Gram_Schmidt_column_k A j) = column 0 A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (0::'n) (Gram_Schmidt_column_k A j) = column (0::'n) A", "unfolding Gram_Schmidt_column_k_def column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat j\n             then (\\<chi>i. A $ i $ b) -\n                  proj_onto (\\<chi>i. A $ i $ b)\n                   {\\<chi>ia. A $ ia $ i |i. i < b}\n             else \\<chi>i. A $ i $ b) $\n            a) $\n        i $\n        (0::'n)) =\n    (\\<chi>i. A $ i $ (0::'n))", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat j\n             then (\\<chi>i. A $ i $ b) -\n                  (\\<Sum>u\\<in>{\\<chi>ia. A $ ia $ i |i. i < b}.\n                     ((\\<chi>i. A $ i $ b) \\<bullet> u /\n                      (u \\<bullet> u)) *\\<^sub>R\n                     u)\n             else \\<chi>i. A $ i $ b) $\n            a) $\n        i $\n        (0::'n)) =\n    (\\<chi>i. A $ i $ (0::'n))", "by (simp add: set_rw)"], ["proof (state)\nthis:\n  column (0::'n) (Gram_Schmidt_column_k A j) = column (0::'n) A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < ncols A; j < ncols A\\<rbrakk>\n    \\<Longrightarrow> span (cols_upt_k A 0) =\n                      span (cols_upt_k (Gram_Schmidt_column_k A j) 0)\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n                \\<Longrightarrow> span (cols_upt_k A k) =\n                                  span\n                                   (cols_upt_k (Gram_Schmidt_column_k A j)\n                                     k);\n        Suc k < ncols A; j < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (cols_upt_k A (Suc k)) =\n                         span\n                          (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. span (cols_upt_k A 0) = span (cols_upt_k (Gram_Schmidt_column_k A j) 0)", "unfolding cols_upt_k_def from_nat_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. span {column i A |i. i \\<le> (0::'n)} =\n    span {column i (Gram_Schmidt_column_k A j) |i. i \\<le> (0::'n)}", "unfolding set_rw2 set_rw3"], ["proof (prove)\ngoal (1 subgoal):\n 1. span {column (0::'n) A} =\n    span {column (0::'n) (Gram_Schmidt_column_k A j)}", "unfolding col_0_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. span {column (0::'n) A} = span {column (0::'n) A}", ".."], ["proof (state)\nthis:\n  span (cols_upt_k A 0) = span (cols_upt_k (Gram_Schmidt_column_k A j) 0)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n                \\<Longrightarrow> span (cols_upt_k A k) =\n                                  span\n                                   (cols_upt_k (Gram_Schmidt_column_k A j)\n                                     k);\n        Suc k < ncols A; j < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (cols_upt_k A (Suc k)) =\n                         span\n                          (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n                \\<Longrightarrow> span (cols_upt_k A k) =\n                                  span\n                                   (cols_upt_k (Gram_Schmidt_column_k A j)\n                                     k);\n        Suc k < ncols A; j < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (cols_upt_k A (Suc k)) =\n                         span\n                          (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n  \\<Longrightarrow> span (cols_upt_k A k) =\n                    span (cols_upt_k (Gram_Schmidt_column_k A j) k)\n  Suc k < ncols A\n  j < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n                \\<Longrightarrow> span (cols_upt_k A k) =\n                                  span\n                                   (cols_upt_k (Gram_Schmidt_column_k A j)\n                                     k);\n        Suc k < ncols A; j < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (cols_upt_k A (Suc k)) =\n                         span\n                          (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have hyp: \"span (cols_upt_k A k) = span (cols_upt_k (Gram_Schmidt_column_k A j) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (cols_upt_k A k) = span (cols_upt_k (Gram_Schmidt_column_k A j) k)", "using Suc.prems Suc.hyps"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n  j < ncols A\n  \\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n  \\<Longrightarrow> span (cols_upt_k A k) =\n                    span (cols_upt_k (Gram_Schmidt_column_k A j) k)\n\ngoal (1 subgoal):\n 1. span (cols_upt_k A k) = span (cols_upt_k (Gram_Schmidt_column_k A j) k)", "by auto"], ["proof (state)\nthis:\n  span (cols_upt_k A k) = span (cols_upt_k (Gram_Schmidt_column_k A j) k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n                \\<Longrightarrow> span (cols_upt_k A k) =\n                                  span\n                                   (cols_upt_k (Gram_Schmidt_column_k A j)\n                                     k);\n        Suc k < ncols A; j < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (cols_upt_k A (Suc k)) =\n                         span\n                          (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have set_rw1: \"(cols_upt_k A (Suc k)) = insert (column (from_nat (Suc k)) A) (cols_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cols_upt_k A (Suc k) =\n    insert (column (mod_type_class.from_nat (Suc k)) A) (cols_upt_k A k)", "using cols_upt_k_insert"], ["proof (prove)\nusing this:\n  Suc ?k < ncols ?A \\<Longrightarrow>\n  cols_upt_k ?A (Suc ?k) =\n  insert (column (mod_type_class.from_nat (Suc ?k)) ?A) (cols_upt_k ?A ?k)\n\ngoal (1 subgoal):\n 1. cols_upt_k A (Suc k) =\n    insert (column (mod_type_class.from_nat (Suc k)) A) (cols_upt_k A k)", "by (auto intro!: cols_upt_k_insert[OF Suc.prems(1)])"], ["proof (state)\nthis:\n  cols_upt_k A (Suc k) =\n  insert (column (mod_type_class.from_nat (Suc k)) A) (cols_upt_k A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n                \\<Longrightarrow> span (cols_upt_k A k) =\n                                  span\n                                   (cols_upt_k (Gram_Schmidt_column_k A j)\n                                     k);\n        Suc k < ncols A; j < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (cols_upt_k A (Suc k)) =\n                         span\n                          (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have set_rw2: \"(cols_upt_k (Gram_Schmidt_column_k A j) (Suc k)) = \n    insert (column (from_nat (Suc k)) (Gram_Schmidt_column_k A j)) (cols_upt_k (Gram_Schmidt_column_k A j) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cols_upt_k (Gram_Schmidt_column_k A j) (Suc k) =\n    insert\n     (column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_column_k A j))\n     (cols_upt_k (Gram_Schmidt_column_k A j) k)", "using cols_upt_k_insert  Suc.prems(1)"], ["proof (prove)\nusing this:\n  Suc ?k < ncols ?A \\<Longrightarrow>\n  cols_upt_k ?A (Suc ?k) =\n  insert (column (mod_type_class.from_nat (Suc ?k)) ?A) (cols_upt_k ?A ?k)\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. cols_upt_k (Gram_Schmidt_column_k A j) (Suc k) =\n    insert\n     (column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_column_k A j))\n     (cols_upt_k (Gram_Schmidt_column_k A j) k)", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc ?k < CARD(?'n) \\<Longrightarrow>\n  cols_upt_k ?A (Suc ?k) =\n  insert (column (mod_type_class.from_nat (Suc ?k)) ?A) (cols_upt_k ?A ?k)\n  Suc k < CARD('n)\n\ngoal (1 subgoal):\n 1. cols_upt_k (Gram_Schmidt_column_k A j) (Suc k) =\n    insert\n     (column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_column_k A j))\n     (cols_upt_k (Gram_Schmidt_column_k A j) k)", "by auto"], ["proof (state)\nthis:\n  cols_upt_k (Gram_Schmidt_column_k A j) (Suc k) =\n  insert\n   (column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_column_k A j))\n   (cols_upt_k (Gram_Schmidt_column_k A j) k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>k < ncols A; j < ncols A\\<rbrakk>\n                \\<Longrightarrow> span (cols_upt_k A k) =\n                                  span\n                                   (cols_upt_k (Gram_Schmidt_column_k A j)\n                                     k);\n        Suc k < ncols A; j < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (cols_upt_k A (Suc k)) =\n                         span\n                          (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "proof (cases \"j=Suc k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))\n 2. j \\<noteq> Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "case False"], ["proof (state)\nthis:\n  j \\<noteq> Suc k\n\ngoal (2 subgoals):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))\n 2. j \\<noteq> Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have suc_not_k: \"from_nat (Suc k) \\<noteq> (from_nat j::'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc k) \\<noteq> mod_type_class.from_nat j", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc k) =\n    mod_type_class.from_nat j \\<Longrightarrow>\n    False", "assume \"from_nat (Suc k) = (from_nat j::'n)\""], ["proof (state)\nthis:\n  mod_type_class.from_nat (Suc k) = mod_type_class.from_nat j\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc k) =\n    mod_type_class.from_nat j \\<Longrightarrow>\n    False", "hence \"Suc k = j\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (Suc k) = mod_type_class.from_nat j\n\ngoal (1 subgoal):\n 1. Suc k = j", "apply (rule from_nat_eq_imp_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc k < CARD('n)\n 2. j < CARD('n)", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n  j < ncols A\n\ngoal (2 subgoals):\n 1. Suc k < CARD('n)\n 2. j < CARD('n)", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('n)\n  j < CARD('n)\n\ngoal (2 subgoals):\n 1. Suc k < CARD('n)\n 2. j < CARD('n)", "."], ["proof (state)\nthis:\n  Suc k = j\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc k) =\n    mod_type_class.from_nat j \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  Suc k = j\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  Suc k = j\n  j \\<noteq> Suc k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat (Suc k) \\<noteq> mod_type_class.from_nat j\n\ngoal (2 subgoals):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))\n 2. j \\<noteq> Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have tnfnj: \"to_nat (from_nat j::'n) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat j) = j", "using to_nat_from_nat_id[OF Suc.prems(2)[unfolded ncols_def]]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (mod_type_class.from_nat j) = j\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat j) = j", "."], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat j) = j\n\ngoal (2 subgoals):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))\n 2. j \\<noteq> Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "let ?a_suc_k = \"column (from_nat (Suc k)) A\""], ["proof (state)\ngoal (2 subgoals):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))\n 2. j \\<noteq> Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have col_eq: \"column (from_nat (Suc k)) (Gram_Schmidt_column_k A j) = ?a_suc_k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_column_k A j) =\n    column (mod_type_class.from_nat (Suc k)) A", "using column_Gram_Schmidt_column_k'[OF suc_not_k]"], ["proof (prove)\nusing this:\n  column (mod_type_class.from_nat (Suc k))\n   (Gram_Schmidt_column_k ?A\n     (mod_type_class.to_nat (mod_type_class.from_nat j))) =\n  column (mod_type_class.from_nat (Suc k)) ?A\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_column_k A j) =\n    column (mod_type_class.from_nat (Suc k)) A", "unfolding tnfnj"], ["proof (prove)\nusing this:\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_column_k ?A j) =\n  column (mod_type_class.from_nat (Suc k)) ?A\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_column_k A j) =\n    column (mod_type_class.from_nat (Suc k)) A", "."], ["proof (state)\nthis:\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_column_k A j) =\n  column (mod_type_class.from_nat (Suc k)) A\n\ngoal (2 subgoals):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))\n 2. j \\<noteq> Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have k: \"k<CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < CARD('n)", "using Suc.prems(1)[unfolded ncols_def]"], ["proof (prove)\nusing this:\n  Suc k < CARD('n)\n\ngoal (1 subgoal):\n 1. k < CARD('n)", "by simp"], ["proof (state)\nthis:\n  k < CARD('n)\n\ngoal (2 subgoals):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))\n 2. j \\<noteq> Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "unfolding set_rw1 set_rw2 col_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. span\n     (insert (column (mod_type_class.from_nat (Suc k)) A)\n       (cols_upt_k A k)) =\n    span\n     (insert (column (mod_type_class.from_nat (Suc k)) A)\n       (cols_upt_k (Gram_Schmidt_column_k A j) k))", "unfolding span_insert"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>k.\n           x - k *\\<^sub>R column (mod_type_class.from_nat (Suc k)) A\n           \\<in> span (cols_upt_k A k)} =\n    {x. \\<exists>k.\n           x - k *\\<^sub>R column (mod_type_class.from_nat (Suc k)) A\n           \\<in> span (cols_upt_k (Gram_Schmidt_column_k A j) k)}", "unfolding hyp"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>k.\n           x - k *\\<^sub>R column (mod_type_class.from_nat (Suc k)) A\n           \\<in> span (cols_upt_k (Gram_Schmidt_column_k A j) k)} =\n    {x. \\<exists>k.\n           x - k *\\<^sub>R column (mod_type_class.from_nat (Suc k)) A\n           \\<in> span (cols_upt_k (Gram_Schmidt_column_k A j) k)}", ".."], ["proof (state)\nthis:\n  span (cols_upt_k A (Suc k)) =\n  span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))\n\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "case True"], ["proof (state)\nthis:\n  j = Suc k\n\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "define C where \"C = cols_upt_k A k\""], ["proof (state)\nthis:\n  C = cols_upt_k A k\n\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "define B where \"B = cols_upt_k (Gram_Schmidt_column_k A j) k\""], ["proof (state)\nthis:\n  B = cols_upt_k (Gram_Schmidt_column_k A j) k\n\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "define a where \"a = column (from_nat (Suc k)) A\""], ["proof (state)\nthis:\n  a = column (mod_type_class.from_nat (Suc k)) A\n\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "let ?a=\"a - sum (\\<lambda>x. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x) C\""], ["proof (state)\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "let ?C=\"insert ?a C\""], ["proof (state)\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have col_rw: \"{column i A |i. i \\<le> from_nat k} = {column i A |i. i < from_nat (Suc k)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i A |i. i \\<le> mod_type_class.from_nat k} =\n    {column i A |i. i < mod_type_class.from_nat (Suc k)}", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia < mod_type_class.from_nat (Suc k)\n 2. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k", "fix i::'n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia < mod_type_class.from_nat (Suc k)\n 2. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k", "assume i: \"i \\<le> from_nat k\""], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia < mod_type_class.from_nat (Suc k)\n 2. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k", "also"], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia < mod_type_class.from_nat (Suc k)\n 2. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k", "have \"... < from_nat (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k < mod_type_class.from_nat (Suc k)", "by (rule from_nat_mono[OF _ Suc.prems(1)[unfolded ncols_def]], simp)"], ["proof (state)\nthis:\n  mod_type_class.from_nat k < mod_type_class.from_nat (Suc k)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> mod_type_class.from_nat k \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and>\n          ia < mod_type_class.from_nat (Suc k)\n 2. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k", "finally"], ["proof (chain)\npicking this:\n  i < mod_type_class.from_nat (Suc k)", "show \"\\<exists>ia. column i A = column ia A \\<and> ia < from_nat (Suc k)\""], ["proof (prove)\nusing this:\n  i < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i A = column ia A \\<and> ia < mod_type_class.from_nat (Suc k)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i A = column ia A \\<and> ia < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k", "fix i::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k", "assume i: \"i < from_nat (Suc k)\""], ["proof (state)\nthis:\n  i < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k", "hence \"i\\<le> from_nat k\""], ["proof (prove)\nusing this:\n  i < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat k", "unfolding Suc_eq_plus1"], ["proof (prove)\nusing this:\n  i < mod_type_class.from_nat (k + 1)\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat k", "unfolding from_nat_suc"], ["proof (prove)\nusing this:\n  i < mod_type_class.from_nat k + (1::'n)\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat k", "by (metis le_Suc not_less)"], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k", "thus \" \\<exists>ia. column i A = column ia A \\<and> ia \\<le> from_nat k\""], ["proof (prove)\nusing this:\n  i \\<le> mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k", "by auto"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i A = column ia A \\<and> ia \\<le> mod_type_class.from_nat k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {column i A |i. i \\<le> mod_type_class.from_nat k} =\n  {column i A |i. i < mod_type_class.from_nat (Suc k)}\n\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have rw: \"column (from_nat (Suc k)) (Gram_Schmidt_column_k A j) = (a - (\\<Sum>x\\<in>cols_upt_k A k. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_column_k A j) =\n    a -\n    (\\<Sum>x\\<in>cols_upt_k A k.\n       (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)", "unfolding Gram_Schmidt_column_k_def True"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (\\<chi>a b.\n         (if b = mod_type_class.from_nat (Suc k)\n          then column b A - proj_onto (column b A) {column i A |i. i < b}\n          else column b A) $\n         a) =\n    a -\n    (\\<Sum>x\\<in>cols_upt_k A k.\n       (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)", "unfolding cols_upt_k_def a_def C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (\\<chi>a b.\n         (if b = mod_type_class.from_nat (Suc k)\n          then column b A - proj_onto (column b A) {column i A |i. i < b}\n          else column b A) $\n         a) =\n    column (mod_type_class.from_nat (Suc k)) A -\n    (\\<Sum>x\\<in>{column i A |i. i \\<le> mod_type_class.from_nat k}.\n       (x \\<bullet> column (mod_type_class.from_nat (Suc k)) A /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "unfolding  column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        (\\<chi>a b.\n            (if b = mod_type_class.from_nat (Suc k)\n             then (\\<chi>i. A $ i $ b) -\n                  proj_onto (\\<chi>i. A $ i $ b)\n                   {\\<chi>ia. A $ ia $ i |i. i < b}\n             else \\<chi>i. A $ i $ b) $\n            a) $\n        i $\n        mod_type_class.from_nat (Suc k)) =\n    (\\<chi>i. A $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. A $ ia $ i |i.\n                  i \\<le> mod_type_class.from_nat k}.\n       (x \\<bullet> (\\<chi>i. A $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        A $ i $ mod_type_class.from_nat (Suc k) -\n        proj_onto (\\<chi>i. A $ i $ mod_type_class.from_nat (Suc k))\n         {\\<chi>ia. A $ ia $ i |i. i < mod_type_class.from_nat (Suc k)} $\n        i) =\n    (\\<chi>i. A $ i $ mod_type_class.from_nat (Suc k)) -\n    (\\<Sum>x\\<in>{\\<chi>ia. A $ ia $ i |i.\n                  i \\<le> mod_type_class.from_nat k}.\n       (x \\<bullet> (\\<chi>i. A $ i $ mod_type_class.from_nat (Suc k)) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "unfolding column_def[symmetric] col_rw minus_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        A $ i $ mod_type_class.from_nat (Suc k) -\n        proj_onto (column (mod_type_class.from_nat (Suc k)) A)\n         {column i A |i. i < mod_type_class.from_nat (Suc k)} $\n        i) =\n    (\\<chi>i.\n        column (mod_type_class.from_nat (Suc k)) A $ i -\n        (\\<Sum>x\\<in>{column i A |i. i < mod_type_class.from_nat (Suc k)}.\n           (x \\<bullet> column (mod_type_class.from_nat (Suc k)) A /\n            (x \\<bullet> x)) *\\<^sub>R\n           x) $\n        i)", "unfolding column_def vec_lambda_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        A $ i $ mod_type_class.from_nat (Suc k) -\n        proj_onto (\\<chi>i. A $ i $ mod_type_class.from_nat (Suc k))\n         {\\<chi>ia. A $ ia $ i |i. i < mod_type_class.from_nat (Suc k)} $\n        i) =\n    (\\<chi>i.\n        A $ i $ mod_type_class.from_nat (Suc k) -\n        (\\<Sum>x\\<in>{\\<chi>ia. A $ ia $ i |i.\n                      i < mod_type_class.from_nat (Suc k)}.\n           (x \\<bullet> (\\<chi>i. A $ i $ mod_type_class.from_nat (Suc k)) /\n            (x \\<bullet> x)) *\\<^sub>R\n           x) $\n        i)", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        A $ i $ mod_type_class.from_nat (Suc k) -\n        (\\<Sum>u\\<in>{\\<chi>ia. A $ ia $ i |i.\n                      i < mod_type_class.from_nat (Suc k)}.\n           ((\\<chi>i. A $ i $ mod_type_class.from_nat (Suc k)) \\<bullet> u /\n            (u \\<bullet> u)) *\\<^sub>R\n           u) $\n        i) =\n    (\\<chi>i.\n        A $ i $ mod_type_class.from_nat (Suc k) -\n        (\\<Sum>x\\<in>{\\<chi>ia. A $ ia $ i |i.\n                      i < mod_type_class.from_nat (Suc k)}.\n           (x \\<bullet> (\\<chi>i. A $ i $ mod_type_class.from_nat (Suc k)) /\n            (x \\<bullet> x)) *\\<^sub>R\n           x) $\n        i)", "unfolding proj_onto_sum_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        A $ i $ mod_type_class.from_nat (Suc k) -\n        (\\<Sum>u\\<in>{\\<chi>ia. A $ ia $ i |i.\n                      i < mod_type_class.from_nat (Suc k)}.\n           ((\\<chi>i. A $ i $ mod_type_class.from_nat (Suc k)) \\<bullet> u /\n            (u \\<bullet> u)) *\\<^sub>R\n           u) $\n        i) =\n    (\\<chi>i.\n        A $ i $ mod_type_class.from_nat (Suc k) -\n        (\\<Sum>x\\<in>{\\<chi>ia. A $ ia $ i |i.\n                      i < mod_type_class.from_nat (Suc k)}.\n           ((\\<chi>i. A $ i $ mod_type_class.from_nat (Suc k)) \\<bullet> x /\n            (x \\<bullet> x)) *\\<^sub>R\n           x) $\n        i)", "by auto"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_column_k A j) =\n  a -\n  (\\<Sum>x\\<in>cols_upt_k A k.\n     (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have finite_C: \"finite C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite C", "unfolding C_def cols_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {column i A |i. i \\<le> mod_type_class.from_nat k}", "by auto"], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "{"], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "fix x b"], ["proof (state)\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have th0: \"!!(a::'a^'m::{mod_type}) b c. a - (b - c) = c + (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. a - (b - c) = c + (a - b)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  ?a - (?b - ?c) = ?c + (?a - ?b)\n\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "have \"x - b *\\<^sub>R  (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x))  *\\<^sub>R  x)) \\<in> span C \\<longleftrightarrow> x - b  *\\<^sub>R  a \\<in> span C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x -\n     b *\\<^sub>R\n     (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n     \\<in> span C) =\n    (x - b *\\<^sub>R a \\<in> span C)", "apply (simp only: scaleR_right_diff_distrib th0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (b *\\<^sub>R\n     (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x) +\n     (x - b *\\<^sub>R a)\n     \\<in> span C) =\n    (x - b *\\<^sub>R a \\<in> span C)", "apply (rule span_add_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b *\\<^sub>R\n    (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)\n    \\<in> span C", "apply (rule span_mul)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x)\n    \\<in> span C", "apply (rule span_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x \\<in> span C", "apply (rule span_mul)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<in> span C", "apply (rule span_base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> x \\<in> C", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (x -\n   b *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (x - b *\\<^sub>R a \\<in> span C)\n\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "}"], ["proof (state)\nthis:\n  (?x2 -\n   ?b2 *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (?x2 - ?b2 *\\<^sub>R a \\<in> span C)\n\ngoal (1 subgoal):\n 1. j = Suc k \\<Longrightarrow>\n    span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?x2 -\n   ?b2 *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (?x2 - ?b2 *\\<^sub>R a \\<in> span C)\n\ngoal (1 subgoal):\n 1. span (cols_upt_k A (Suc k)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))", "unfolding set_eq_iff"], ["proof (prove)\nusing this:\n  (?x2 -\n   ?b2 *\\<^sub>R\n   (a - (\\<Sum>x\\<in>C. (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span C) =\n  (?x2 - ?b2 *\\<^sub>R a \\<in> span C)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> span (cols_upt_k A (Suc k))) =\n       (x \\<in> span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k)))", "unfolding C_def B_def"], ["proof (prove)\nusing this:\n  (?x2 -\n   ?b2 *\\<^sub>R\n   (a -\n    (\\<Sum>x\\<in>cols_upt_k A k.\n       (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span (cols_upt_k A k)) =\n  (?x2 - ?b2 *\\<^sub>R a \\<in> span (cols_upt_k A k))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> span (cols_upt_k A (Suc k))) =\n       (x \\<in> span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k)))", "unfolding set_rw1"], ["proof (prove)\nusing this:\n  (?x2 -\n   ?b2 *\\<^sub>R\n   (a -\n    (\\<Sum>x\\<in>cols_upt_k A k.\n       (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span (cols_upt_k A k)) =\n  (?x2 - ?b2 *\\<^sub>R a \\<in> span (cols_upt_k A k))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> span\n                 (insert (column (mod_type_class.from_nat (Suc k)) A)\n                   (cols_upt_k A k))) =\n       (x \\<in> span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k)))", "unfolding set_rw2"], ["proof (prove)\nusing this:\n  (?x2 -\n   ?b2 *\\<^sub>R\n   (a -\n    (\\<Sum>x\\<in>cols_upt_k A k.\n       (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span (cols_upt_k A k)) =\n  (?x2 - ?b2 *\\<^sub>R a \\<in> span (cols_upt_k A k))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> span\n                 (insert (column (mod_type_class.from_nat (Suc k)) A)\n                   (cols_upt_k A k))) =\n       (x \\<in> span\n                 (insert\n                   (column (mod_type_class.from_nat (Suc k))\n                     (Gram_Schmidt_column_k A j))\n                   (cols_upt_k (Gram_Schmidt_column_k A j) k)))", "unfolding span_breakdown_eq"], ["proof (prove)\nusing this:\n  (?x2 -\n   ?b2 *\\<^sub>R\n   (a -\n    (\\<Sum>x\\<in>cols_upt_k A k.\n       (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span (cols_upt_k A k)) =\n  (?x2 - ?b2 *\\<^sub>R a \\<in> span (cols_upt_k A k))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>k.\n           x - k *\\<^sub>R column (mod_type_class.from_nat (Suc k)) A\n           \\<in> span (cols_upt_k A k)) =\n       (\\<exists>k.\n           x -\n           k *\\<^sub>R\n           column (mod_type_class.from_nat (Suc k))\n            (Gram_Schmidt_column_k A j)\n           \\<in> span (cols_upt_k (Gram_Schmidt_column_k A j) k))", "unfolding hyp"], ["proof (prove)\nusing this:\n  (?x2 -\n   ?b2 *\\<^sub>R\n   (a -\n    (\\<Sum>x\\<in>cols_upt_k A k.\n       (x \\<bullet> a / (x \\<bullet> x)) *\\<^sub>R x))\n   \\<in> span (cols_upt_k (Gram_Schmidt_column_k A j) k)) =\n  (?x2 - ?b2 *\\<^sub>R a\n   \\<in> span (cols_upt_k (Gram_Schmidt_column_k A j) k))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>k.\n           x - k *\\<^sub>R column (mod_type_class.from_nat (Suc k)) A\n           \\<in> span (cols_upt_k (Gram_Schmidt_column_k A j) k)) =\n       (\\<exists>k.\n           x -\n           k *\\<^sub>R\n           column (mod_type_class.from_nat (Suc k))\n            (Gram_Schmidt_column_k A j)\n           \\<in> span (cols_upt_k (Gram_Schmidt_column_k A j) k))", "by (metis (mono_tags) B_def a_def rw)"], ["proof (state)\nthis:\n  span (cols_upt_k A (Suc k)) =\n  span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  span (cols_upt_k A (Suc k)) =\n  span (cols_upt_k (Gram_Schmidt_column_k A j) (Suc k))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary span_Gram_Schmidt_column_k:\n  fixes A::\"'a::{real_inner}^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"k<ncols A\"\n  shows \"span (columns A) = span (columns (Gram_Schmidt_column_k A k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (columns A) = span (columns (Gram_Schmidt_column_k A k))", "unfolding columns_eq_cols_upt_k[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. span (cols_upt_k A (ncols A - 1)) =\n    span\n     (cols_upt_k (Gram_Schmidt_column_k A k)\n       (ncols (Gram_Schmidt_column_k A k) - 1))", "using span_cols_upt_k_Gram_Schmidt_column_k[of \"ncols A - 1\" A k]"], ["proof (prove)\nusing this:\n  \\<lbrakk>ncols A - 1 < ncols A; k < ncols A\\<rbrakk>\n  \\<Longrightarrow> span (cols_upt_k A (ncols A - 1)) =\n                    span\n                     (cols_upt_k (Gram_Schmidt_column_k A k) (ncols A - 1))\n\ngoal (1 subgoal):\n 1. span (cols_upt_k A (ncols A - 1)) =\n    span\n     (cols_upt_k (Gram_Schmidt_column_k A k)\n       (ncols (Gram_Schmidt_column_k A k) - 1))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>ncols A - 1 < ncols A; k < ncols A\\<rbrakk>\n  \\<Longrightarrow> span (cols_upt_k A (ncols A - 1)) =\n                    span\n                     (cols_upt_k (Gram_Schmidt_column_k A k) (ncols A - 1))\n  k < ncols A\n\ngoal (1 subgoal):\n 1. span (cols_upt_k A (ncols A - 1)) =\n    span\n     (cols_upt_k (Gram_Schmidt_column_k A k)\n       (ncols (Gram_Schmidt_column_k A k) - 1))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>CARD('n) - 1 < CARD('n); k < CARD('n)\\<rbrakk>\n  \\<Longrightarrow> span (cols_upt_k A (CARD('n) - 1)) =\n                    span\n                     (cols_upt_k (Gram_Schmidt_column_k A k) (CARD('n) - 1))\n  k < CARD('n)\n\ngoal (1 subgoal):\n 1. span (cols_upt_k A (CARD('n) - 1)) =\n    span (cols_upt_k (Gram_Schmidt_column_k A k) (CARD('n) - 1))", "by auto"], ["", "corollary span_Gram_Schmidt_upt_k:\n  fixes A::\"'a::{real_inner}^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"k<ncols A\"\n  shows \"span (columns A) = span (columns (Gram_Schmidt_upt_k A k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (columns A) = span (columns (Gram_Schmidt_upt_k A k))", "using assms"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. span (columns A) = span (columns (Gram_Schmidt_upt_k A k))", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    span (columns A) = span (columns (Gram_Schmidt_upt_k A 0))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                span (columns A) = span (columns (Gram_Schmidt_upt_k A k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (columns A) =\n                         span (columns (Gram_Schmidt_upt_k A (Suc k)))", "case 0"], ["proof (state)\nthis:\n  0 < ncols A\n\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    span (columns A) = span (columns (Gram_Schmidt_upt_k A 0))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                span (columns A) = span (columns (Gram_Schmidt_upt_k A k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (columns A) =\n                         span (columns (Gram_Schmidt_upt_k A (Suc k)))", "have \"columns (Gram_Schmidt_column_k A 0) = columns A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. columns (Gram_Schmidt_column_k A 0) = columns A", "proof (unfold columns_def, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. \\<exists>ia. column i (Gram_Schmidt_column_k A 0) = column ia A\n 2. \\<And>i. \\<exists>ia. column i A = column ia (Gram_Schmidt_column_k A 0)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. \\<exists>ia. column i (Gram_Schmidt_column_k A 0) = column ia A\n 2. \\<And>i. \\<exists>ia. column i A = column ia (Gram_Schmidt_column_k A 0)", "have set_rw: \"{\\<chi> ia. A $ ia $ i |i. i < from_nat 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<chi>ia. A $ ia $ i |i. i < mod_type_class.from_nat 0} = {}", "by (auto, metis less_le_not_le least_mod_type from_nat_0)"], ["proof (state)\nthis:\n  {\\<chi>ia. A $ ia $ i |i. i < mod_type_class.from_nat 0} = {}\n\ngoal (2 subgoals):\n 1. \\<And>i. \\<exists>ia. column i (Gram_Schmidt_column_k A 0) = column ia A\n 2. \\<And>i. \\<exists>ia. column i A = column ia (Gram_Schmidt_column_k A 0)", "thus \"\\<exists>ia. column i (Gram_Schmidt_column_k A 0) = column ia A\""], ["proof (prove)\nusing this:\n  {\\<chi>ia. A $ ia $ i |i. i < mod_type_class.from_nat 0} = {}\n\ngoal (1 subgoal):\n 1. \\<exists>ia. column i (Gram_Schmidt_column_k A 0) = column ia A", "unfolding Gram_Schmidt_column_k_def column_def"], ["proof (prove)\nusing this:\n  {\\<chi>ia. A $ ia $ i |i. i < mod_type_class.from_nat 0} = {}\n\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       (\\<chi>ia.\n           (\\<chi>a b.\n               (if b = mod_type_class.from_nat 0\n                then (\\<chi>i. A $ i $ b) -\n                     proj_onto (\\<chi>i. A $ i $ b)\n                      {\\<chi>ia. A $ ia $ i |i. i < b}\n                else \\<chi>i. A $ i $ b) $\n               a) $\n           ia $\n           i) =\n       (\\<chi>i. A $ i $ ia)", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\nusing this:\n  {\\<chi>ia. A $ ia $ i |i. i < mod_type_class.from_nat 0} = {}\n\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       (\\<chi>ia.\n           (\\<chi>a b.\n               (if b = mod_type_class.from_nat 0\n                then (\\<chi>i. A $ i $ b) -\n                     (\\<Sum>u\\<in>{\\<chi>ia. A $ ia $ i |i. i < b}.\n                        ((\\<chi>i. A $ i $ b) \\<bullet> u /\n                         (u \\<bullet> u)) *\\<^sub>R\n                        u)\n                else \\<chi>i. A $ i $ b) $\n               a) $\n           ia $\n           i) =\n       (\\<chi>i. A $ i $ ia)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ia. column i (Gram_Schmidt_column_k A 0) = column ia A\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>ia. column i A = column ia (Gram_Schmidt_column_k A 0)", "show \"\\<exists>ia. column i A = column ia (Gram_Schmidt_column_k A 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia. column i A = column ia (Gram_Schmidt_column_k A 0)", "using set_rw"], ["proof (prove)\nusing this:\n  {\\<chi>ia. A $ ia $ i |i. i < mod_type_class.from_nat 0} = {}\n\ngoal (1 subgoal):\n 1. \\<exists>ia. column i A = column ia (Gram_Schmidt_column_k A 0)", "unfolding Gram_Schmidt_column_k_def column_def"], ["proof (prove)\nusing this:\n  {\\<chi>ia. A $ ia $ i |i. i < mod_type_class.from_nat 0} = {}\n\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       (\\<chi>ia. A $ ia $ i) =\n       (\\<chi>i.\n           (\\<chi>a b.\n               (if b = mod_type_class.from_nat 0\n                then (\\<chi>i. A $ i $ b) -\n                     proj_onto (\\<chi>i. A $ i $ b)\n                      {\\<chi>ia. A $ ia $ i |i. i < b}\n                else \\<chi>i. A $ i $ b) $\n               a) $\n           i $\n           ia)", "unfolding from_nat_0"], ["proof (prove)\nusing this:\n  {\\<chi>ia. A $ ia $ i |i. i < (0::'n)} = {}\n\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       (\\<chi>ia. A $ ia $ i) =\n       (\\<chi>i.\n           (\\<chi>a b.\n               (if b = (0::'n)\n                then (\\<chi>i. A $ i $ b) -\n                     proj_onto (\\<chi>i. A $ i $ b)\n                      {\\<chi>ia. A $ ia $ i |i. i < b}\n                else \\<chi>i. A $ i $ b) $\n               a) $\n           i $\n           ia)", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\nusing this:\n  {\\<chi>ia. A $ ia $ i |i. i < (0::'n)} = {}\n\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       (\\<chi>ia. A $ ia $ i) =\n       (\\<chi>i.\n           (\\<chi>a b.\n               (if b = (0::'n)\n                then (\\<chi>i. A $ i $ b) -\n                     (\\<Sum>u\\<in>{\\<chi>ia. A $ ia $ i |i. i < b}.\n                        ((\\<chi>i. A $ i $ b) \\<bullet> u /\n                         (u \\<bullet> u)) *\\<^sub>R\n                        u)\n                else \\<chi>i. A $ i $ b) $\n               a) $\n           i $\n           ia)", "by force"], ["proof (state)\nthis:\n  \\<exists>ia. column i A = column ia (Gram_Schmidt_column_k A 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  columns (Gram_Schmidt_column_k A 0) = columns A\n\ngoal (2 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    span (columns A) = span (columns (Gram_Schmidt_upt_k A 0))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                span (columns A) = span (columns (Gram_Schmidt_upt_k A k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (columns A) =\n                         span (columns (Gram_Schmidt_upt_k A (Suc k)))", "thus ?case"], ["proof (prove)\nusing this:\n  columns (Gram_Schmidt_column_k A 0) = columns A\n\ngoal (1 subgoal):\n 1. span (columns A) = span (columns (Gram_Schmidt_upt_k A 0))", "unfolding Gram_Schmidt_upt_k_def"], ["proof (prove)\nusing this:\n  columns (Gram_Schmidt_column_k A 0) = columns A\n\ngoal (1 subgoal):\n 1. span (columns A) =\n    span (columns (foldl Gram_Schmidt_column_k A [0..<Suc 0]))", "by auto"], ["proof (state)\nthis:\n  span (columns A) = span (columns (Gram_Schmidt_upt_k A 0))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                span (columns A) = span (columns (Gram_Schmidt_upt_k A k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (columns A) =\n                         span (columns (Gram_Schmidt_upt_k A (Suc k)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                span (columns A) = span (columns (Gram_Schmidt_upt_k A k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (columns A) =\n                         span (columns (Gram_Schmidt_upt_k A (Suc k)))", "case (Suc k)"], ["proof (state)\nthis:\n  k < ncols A \\<Longrightarrow>\n  span (columns A) = span (columns (Gram_Schmidt_upt_k A k))\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                span (columns A) = span (columns (Gram_Schmidt_upt_k A k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (columns A) =\n                         span (columns (Gram_Schmidt_upt_k A (Suc k)))", "have hyp: \"span (columns A) = span (columns (Gram_Schmidt_upt_k A k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (columns A) = span (columns (Gram_Schmidt_upt_k A k))", "using Suc.prems Suc.hyps"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n  k < ncols A \\<Longrightarrow>\n  span (columns A) = span (columns (Gram_Schmidt_upt_k A k))\n\ngoal (1 subgoal):\n 1. span (columns A) = span (columns (Gram_Schmidt_upt_k A k))", "by auto"], ["proof (state)\nthis:\n  span (columns A) = span (columns (Gram_Schmidt_upt_k A k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                span (columns A) = span (columns (Gram_Schmidt_upt_k A k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (columns A) =\n                         span (columns (Gram_Schmidt_upt_k A (Suc k)))", "have \"span (columns (Gram_Schmidt_upt_k A (Suc k))) \n    = span (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (columns (Gram_Schmidt_upt_k A (Suc k))) =\n    span (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)))", "unfolding Gram_Schmidt_upt_k_suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. span\n     (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))) =\n    span (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)))", ".."], ["proof (state)\nthis:\n  span (columns (Gram_Schmidt_upt_k A (Suc k))) =\n  span (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                span (columns A) = span (columns (Gram_Schmidt_upt_k A k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (columns A) =\n                         span (columns (Gram_Schmidt_upt_k A (Suc k)))", "also"], ["proof (state)\nthis:\n  span (columns (Gram_Schmidt_upt_k A (Suc k))) =\n  span (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                span (columns A) = span (columns (Gram_Schmidt_upt_k A k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (columns A) =\n                         span (columns (Gram_Schmidt_upt_k A (Suc k)))", "have \"... = span (columns (Gram_Schmidt_upt_k A k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span\n     (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))) =\n    span (columns (Gram_Schmidt_upt_k A k))", "using span_Gram_Schmidt_column_k[of \"Suc k\" \"(Gram_Schmidt_upt_k A k)\"]"], ["proof (prove)\nusing this:\n  Suc k < ncols (Gram_Schmidt_upt_k A k) \\<Longrightarrow>\n  span (columns (Gram_Schmidt_upt_k A k)) =\n  span (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)))\n\ngoal (1 subgoal):\n 1. span\n     (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))) =\n    span (columns (Gram_Schmidt_upt_k A k))", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc k < ncols (Gram_Schmidt_upt_k A k) \\<Longrightarrow>\n  span (columns (Gram_Schmidt_upt_k A k)) =\n  span (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)))\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. span\n     (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))) =\n    span (columns (Gram_Schmidt_upt_k A k))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('n) \\<Longrightarrow>\n  span (columns (Gram_Schmidt_upt_k A k)) =\n  span (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)))\n  Suc k < CARD('n)\n\ngoal (1 subgoal):\n 1. span\n     (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))) =\n    span (columns (Gram_Schmidt_upt_k A k))", "by auto"], ["proof (state)\nthis:\n  span (columns (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))) =\n  span (columns (Gram_Schmidt_upt_k A k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                span (columns A) = span (columns (Gram_Schmidt_upt_k A k));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> span (columns A) =\n                         span (columns (Gram_Schmidt_upt_k A (Suc k)))", "finally"], ["proof (chain)\npicking this:\n  span (columns (Gram_Schmidt_upt_k A (Suc k))) =\n  span (columns (Gram_Schmidt_upt_k A k))", "show ?case"], ["proof (prove)\nusing this:\n  span (columns (Gram_Schmidt_upt_k A (Suc k))) =\n  span (columns (Gram_Schmidt_upt_k A k))\n\ngoal (1 subgoal):\n 1. span (columns A) = span (columns (Gram_Schmidt_upt_k A (Suc k)))", "using hyp"], ["proof (prove)\nusing this:\n  span (columns (Gram_Schmidt_upt_k A (Suc k))) =\n  span (columns (Gram_Schmidt_upt_k A k))\n  span (columns A) = span (columns (Gram_Schmidt_upt_k A k))\n\ngoal (1 subgoal):\n 1. span (columns A) = span (columns (Gram_Schmidt_upt_k A (Suc k)))", "by auto"], ["proof (state)\nthis:\n  span (columns A) = span (columns (Gram_Schmidt_upt_k A (Suc k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary span_Gram_Schmidt_matrix:\n  fixes A::\"'a::{real_inner}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"span (columns A) = span (columns (Gram_Schmidt_matrix A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (columns A) = span (columns (Gram_Schmidt_matrix A))", "unfolding Gram_Schmidt_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. span (columns A) = span (columns (Gram_Schmidt_upt_k A (ncols A - 1)))", "by (simp add: span_Gram_Schmidt_upt_k ncols_def)"], ["", "lemma is_basis_columns_Gram_Schmidt_matrix:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes b: \"is_basis (columns A)\"\n  and c: \"card (columns A) = ncols A\"\n  shows \"is_basis (columns (Gram_Schmidt_matrix A)) \n  \\<and> card (columns (Gram_Schmidt_matrix A)) = ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_basis (columns (Gram_Schmidt_matrix A)) \\<and>\n    card (columns (Gram_Schmidt_matrix A)) = ncols A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_basis (columns (Gram_Schmidt_matrix A)) \\<and>\n    card (columns (Gram_Schmidt_matrix A)) = ncols A", "have span_UNIV: \"vec.span (columns (Gram_Schmidt_matrix A)) = (UNIV::(real^'m::{mod_type}) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.span (columns (Gram_Schmidt_matrix A)) = UNIV", "using span_Gram_Schmidt_matrix b"], ["proof (prove)\nusing this:\n  span (columns ?A) = span (columns (Gram_Schmidt_matrix ?A))\n  is_basis (columns A)\n\ngoal (1 subgoal):\n 1. vec.span (columns (Gram_Schmidt_matrix A)) = UNIV", "unfolding is_basis_def"], ["proof (prove)\nusing this:\n  span (columns ?A) = span (columns (Gram_Schmidt_matrix ?A))\n  vec.independent (columns A) \\<and> vec.span (columns A) = UNIV\n\ngoal (1 subgoal):\n 1. vec.span (columns (Gram_Schmidt_matrix A)) = UNIV", "by (metis span_vec_eq)"], ["proof (state)\nthis:\n  vec.span (columns (Gram_Schmidt_matrix A)) = UNIV\n\ngoal (1 subgoal):\n 1. is_basis (columns (Gram_Schmidt_matrix A)) \\<and>\n    card (columns (Gram_Schmidt_matrix A)) = ncols A", "moreover"], ["proof (state)\nthis:\n  vec.span (columns (Gram_Schmidt_matrix A)) = UNIV\n\ngoal (1 subgoal):\n 1. is_basis (columns (Gram_Schmidt_matrix A)) \\<and>\n    card (columns (Gram_Schmidt_matrix A)) = ncols A", "have c_eq: \"card (columns (Gram_Schmidt_matrix A)) = ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (columns (Gram_Schmidt_matrix A)) = ncols A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (columns (Gram_Schmidt_matrix A)) = ncols A", "have \"card (columns A) \\<le> card (columns (Gram_Schmidt_matrix A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (columns A) \\<le> card (columns (Gram_Schmidt_matrix A))", "by (metis b is_basis_def finite_columns vec.independent_span_bound span_UNIV top_greatest)"], ["proof (state)\nthis:\n  card (columns A) \\<le> card (columns (Gram_Schmidt_matrix A))\n\ngoal (1 subgoal):\n 1. card (columns (Gram_Schmidt_matrix A)) = ncols A", "thus ?thesis"], ["proof (prove)\nusing this:\n  card (columns A) \\<le> card (columns (Gram_Schmidt_matrix A))\n\ngoal (1 subgoal):\n 1. card (columns (Gram_Schmidt_matrix A)) = ncols A", "using c"], ["proof (prove)\nusing this:\n  card (columns A) \\<le> card (columns (Gram_Schmidt_matrix A))\n  card (columns A) = ncols A\n\ngoal (1 subgoal):\n 1. card (columns (Gram_Schmidt_matrix A)) = ncols A", "using card_columns_le_ncols"], ["proof (prove)\nusing this:\n  card (columns A) \\<le> card (columns (Gram_Schmidt_matrix A))\n  card (columns A) = ncols A\n  card (columns ?A) \\<le> ncols ?A\n\ngoal (1 subgoal):\n 1. card (columns (Gram_Schmidt_matrix A)) = ncols A", "by (metis le_antisym ncols_def)"], ["proof (state)\nthis:\n  card (columns (Gram_Schmidt_matrix A)) = ncols A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (columns (Gram_Schmidt_matrix A)) = ncols A\n\ngoal (1 subgoal):\n 1. is_basis (columns (Gram_Schmidt_matrix A)) \\<and>\n    card (columns (Gram_Schmidt_matrix A)) = ncols A", "moreover"], ["proof (state)\nthis:\n  card (columns (Gram_Schmidt_matrix A)) = ncols A\n\ngoal (1 subgoal):\n 1. is_basis (columns (Gram_Schmidt_matrix A)) \\<and>\n    card (columns (Gram_Schmidt_matrix A)) = ncols A", "have \"vec.independent (columns (Gram_Schmidt_matrix A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (columns (Gram_Schmidt_matrix A))", "proof (rule vec.card_le_dim_spanning[of _ \"UNIV::(real^'m::{mod_type}) set\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. columns (Gram_Schmidt_matrix A) \\<subseteq> UNIV\n 2. UNIV \\<subseteq> vec.span (columns (Gram_Schmidt_matrix A))\n 3. finite (columns (Gram_Schmidt_matrix A))\n 4. card (columns (Gram_Schmidt_matrix A)) \\<le> vec.dim UNIV", "show \"columns (Gram_Schmidt_matrix A) \\<subseteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. columns (Gram_Schmidt_matrix A) \\<subseteq> UNIV", "by simp"], ["proof (state)\nthis:\n  columns (Gram_Schmidt_matrix A) \\<subseteq> UNIV\n\ngoal (3 subgoals):\n 1. UNIV \\<subseteq> vec.span (columns (Gram_Schmidt_matrix A))\n 2. finite (columns (Gram_Schmidt_matrix A))\n 3. card (columns (Gram_Schmidt_matrix A)) \\<le> vec.dim UNIV", "show \"UNIV \\<subseteq> vec.span (columns (Gram_Schmidt_matrix A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> vec.span (columns (Gram_Schmidt_matrix A))", "using span_UNIV"], ["proof (prove)\nusing this:\n  vec.span (columns (Gram_Schmidt_matrix A)) = UNIV\n\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> vec.span (columns (Gram_Schmidt_matrix A))", "by auto"], ["proof (state)\nthis:\n  UNIV \\<subseteq> vec.span (columns (Gram_Schmidt_matrix A))\n\ngoal (2 subgoals):\n 1. finite (columns (Gram_Schmidt_matrix A))\n 2. card (columns (Gram_Schmidt_matrix A)) \\<le> vec.dim UNIV", "show \"finite (columns (Gram_Schmidt_matrix A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (columns (Gram_Schmidt_matrix A))", "using finite_columns"], ["proof (prove)\nusing this:\n  finite (columns ?A)\n\ngoal (1 subgoal):\n 1. finite (columns (Gram_Schmidt_matrix A))", "."], ["proof (state)\nthis:\n  finite (columns (Gram_Schmidt_matrix A))\n\ngoal (1 subgoal):\n 1. card (columns (Gram_Schmidt_matrix A)) \\<le> vec.dim UNIV", "show \"card (columns (Gram_Schmidt_matrix A)) \\<le> vec.dim (UNIV::(real^'m::{mod_type}) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (columns (Gram_Schmidt_matrix A)) \\<le> vec.dim UNIV", "by (metis b c c_eq eq_iff is_basis_def vec.dim_span_eq_card_independent)"], ["proof (state)\nthis:\n  card (columns (Gram_Schmidt_matrix A)) \\<le> vec.dim UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec.independent (columns (Gram_Schmidt_matrix A))\n\ngoal (1 subgoal):\n 1. is_basis (columns (Gram_Schmidt_matrix A)) \\<and>\n    card (columns (Gram_Schmidt_matrix A)) = ncols A", "ultimately"], ["proof (chain)\npicking this:\n  vec.span (columns (Gram_Schmidt_matrix A)) = UNIV\n  card (columns (Gram_Schmidt_matrix A)) = ncols A\n  vec.independent (columns (Gram_Schmidt_matrix A))", "show ?thesis"], ["proof (prove)\nusing this:\n  vec.span (columns (Gram_Schmidt_matrix A)) = UNIV\n  card (columns (Gram_Schmidt_matrix A)) = ncols A\n  vec.independent (columns (Gram_Schmidt_matrix A))\n\ngoal (1 subgoal):\n 1. is_basis (columns (Gram_Schmidt_matrix A)) \\<and>\n    card (columns (Gram_Schmidt_matrix A)) = ncols A", "unfolding is_basis_def"], ["proof (prove)\nusing this:\n  vec.span (columns (Gram_Schmidt_matrix A)) = UNIV\n  card (columns (Gram_Schmidt_matrix A)) = ncols A\n  vec.independent (columns (Gram_Schmidt_matrix A))\n\ngoal (1 subgoal):\n 1. (vec.independent (columns (Gram_Schmidt_matrix A)) \\<and>\n     vec.span (columns (Gram_Schmidt_matrix A)) = UNIV) \\<and>\n    card (columns (Gram_Schmidt_matrix A)) = ncols A", "by simp"], ["proof (state)\nthis:\n  is_basis (columns (Gram_Schmidt_matrix A)) \\<and>\n  card (columns (Gram_Schmidt_matrix A)) = ncols A\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>From here on, we present some lemmas that will be useful for the formalisation of the QR\n  decomposition.\\<close>"], ["", "lemma column_gr_k_Gram_Schmidt_upt:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"i>k\"\n  and i: \"i<ncols A\"\n  shows \"column (from_nat i) (Gram_Schmidt_upt_k A k) = column (from_nat i) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat i) A", "using assms(1)"], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat i) A", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow>\n    column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A 0) =\n    column (mod_type_class.from_nat i) A\n 2. \\<And>k.\n       \\<lbrakk>k < i \\<Longrightarrow>\n                column (mod_type_class.from_nat i)\n                 (Gram_Schmidt_upt_k A k) =\n                column (mod_type_class.from_nat i) A;\n        Suc k < i\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat i)\n                          (Gram_Schmidt_upt_k A (Suc k)) =\n                         column (mod_type_class.from_nat i) A", "assume \"0 < i\""], ["proof (state)\nthis:\n  0 < i\n\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow>\n    column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A 0) =\n    column (mod_type_class.from_nat i) A\n 2. \\<And>k.\n       \\<lbrakk>k < i \\<Longrightarrow>\n                column (mod_type_class.from_nat i)\n                 (Gram_Schmidt_upt_k A k) =\n                column (mod_type_class.from_nat i) A;\n        Suc k < i\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat i)\n                          (Gram_Schmidt_upt_k A (Suc k)) =\n                         column (mod_type_class.from_nat i) A", "hence \"(from_nat i::'n) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> (0::'n)", "unfolding from_nat_0[symmetric]"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat 0", "using bij_from_nat[where ?'a='n]"], ["proof (prove)\nusing this:\n  0 < i\n  bij_betw mod_type_class.from_nat {0..<CARD('n)} UNIV\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat 0", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  0 < i\n  inj_on mod_type_class.from_nat {0..<CARD('n)} \\<and>\n  mod_type_class.from_nat ` {0..<CARD('n)} = UNIV\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat 0", "by (metis from_nat_eq_imp_eq gr_implies_not0 i ncols_def neq0_conv)"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<noteq> (0::'n)\n\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow>\n    column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A 0) =\n    column (mod_type_class.from_nat i) A\n 2. \\<And>k.\n       \\<lbrakk>k < i \\<Longrightarrow>\n                column (mod_type_class.from_nat i)\n                 (Gram_Schmidt_upt_k A k) =\n                column (mod_type_class.from_nat i) A;\n        Suc k < i\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat i)\n                          (Gram_Schmidt_upt_k A (Suc k)) =\n                         column (mod_type_class.from_nat i) A", "thus \"column (from_nat i) (Gram_Schmidt_upt_k A 0) = column (from_nat i) A\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i \\<noteq> (0::'n)\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A 0) =\n    column (mod_type_class.from_nat i) A", "unfolding Gram_Schmidt_upt_k_def"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i \\<noteq> (0::'n)\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat i)\n     (foldl Gram_Schmidt_column_k A [0..<Suc 0]) =\n    column (mod_type_class.from_nat i) A", "by (simp add: Gram_Schmidt_column_k_def from_nat_0 column_def)"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A 0) =\n  column (mod_type_class.from_nat i) A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < i \\<Longrightarrow>\n                column (mod_type_class.from_nat i)\n                 (Gram_Schmidt_upt_k A k) =\n                column (mod_type_class.from_nat i) A;\n        Suc k < i\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat i)\n                          (Gram_Schmidt_upt_k A (Suc k)) =\n                         column (mod_type_class.from_nat i) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < i \\<Longrightarrow>\n                column (mod_type_class.from_nat i)\n                 (Gram_Schmidt_upt_k A k) =\n                column (mod_type_class.from_nat i) A;\n        Suc k < i\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat i)\n                          (Gram_Schmidt_upt_k A (Suc k)) =\n                         column (mod_type_class.from_nat i) A", "case (Suc k)"], ["proof (state)\nthis:\n  k < i \\<Longrightarrow>\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k) =\n  column (mod_type_class.from_nat i) A\n  Suc k < i\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < i \\<Longrightarrow>\n                column (mod_type_class.from_nat i)\n                 (Gram_Schmidt_upt_k A k) =\n                column (mod_type_class.from_nat i) A;\n        Suc k < i\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat i)\n                          (Gram_Schmidt_upt_k A (Suc k)) =\n                         column (mod_type_class.from_nat i) A", "have hyp: \"column (from_nat i) (Gram_Schmidt_upt_k A k) = column (from_nat i) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat i) A", "using Suc.hyps Suc.prems"], ["proof (prove)\nusing this:\n  k < i \\<Longrightarrow>\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k) =\n  column (mod_type_class.from_nat i) A\n  Suc k < i\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat i) A", "by auto"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k) =\n  column (mod_type_class.from_nat i) A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < i \\<Longrightarrow>\n                column (mod_type_class.from_nat i)\n                 (Gram_Schmidt_upt_k A k) =\n                column (mod_type_class.from_nat i) A;\n        Suc k < i\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat i)\n                          (Gram_Schmidt_upt_k A (Suc k)) =\n                         column (mod_type_class.from_nat i) A", "have to_nat_from_nat_suc_k: \"(to_nat (from_nat (Suc k)::'n)) = Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "by (metis Suc.prems dual_order.strict_trans from_nat_not_eq i ncols_def)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < i \\<Longrightarrow>\n                column (mod_type_class.from_nat i)\n                 (Gram_Schmidt_upt_k A k) =\n                column (mod_type_class.from_nat i) A;\n        Suc k < i\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat i)\n                          (Gram_Schmidt_upt_k A (Suc k)) =\n                         column (mod_type_class.from_nat i) A", "have \"column (from_nat i) (Gram_Schmidt_upt_k A (Suc k)) \n    = column (from_nat i) (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A (Suc k)) =\n    column (mod_type_class.from_nat i)\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))", "unfolding Gram_Schmidt_upt_k_suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat i)\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column (mod_type_class.from_nat i)\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))", ".."], ["proof (state)\nthis:\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A (Suc k)) =\n  column (mod_type_class.from_nat i)\n   (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < i \\<Longrightarrow>\n                column (mod_type_class.from_nat i)\n                 (Gram_Schmidt_upt_k A k) =\n                column (mod_type_class.from_nat i) A;\n        Suc k < i\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat i)\n                          (Gram_Schmidt_upt_k A (Suc k)) =\n                         column (mod_type_class.from_nat i) A", "also"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A (Suc k)) =\n  column (mod_type_class.from_nat i)\n   (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < i \\<Longrightarrow>\n                column (mod_type_class.from_nat i)\n                 (Gram_Schmidt_upt_k A k) =\n                column (mod_type_class.from_nat i) A;\n        Suc k < i\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat i)\n                          (Gram_Schmidt_upt_k A (Suc k)) =\n                         column (mod_type_class.from_nat i) A", "have \"... =  column (from_nat i) (Gram_Schmidt_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat i)\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)", "proof (rule column_Gram_Schmidt_column_k'\n      [of \"from_nat i\" \"from_nat (Suc k)\" \" (Gram_Schmidt_upt_k A k)\", unfolded to_nat_from_nat_suc_k])"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat (Suc k)", "show \"from_nat i \\<noteq> (from_nat (Suc k)::'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat (Suc k)", "by (metis Suc.prems not_less_iff_gr_or_eq\n        from_nat_not_eq i ncols_def to_nat_from_nat_suc_k)"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<noteq> mod_type_class.from_nat (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat i)\n   (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < i \\<Longrightarrow>\n                column (mod_type_class.from_nat i)\n                 (Gram_Schmidt_upt_k A k) =\n                column (mod_type_class.from_nat i) A;\n        Suc k < i\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat i)\n                          (Gram_Schmidt_upt_k A (Suc k)) =\n                         column (mod_type_class.from_nat i) A", "finally"], ["proof (chain)\npicking this:\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A (Suc k)) =\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)", "show ?case"], ["proof (prove)\nusing this:\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A (Suc k)) =\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A k)\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A (Suc k)) =\n    column (mod_type_class.from_nat i) A", "unfolding hyp"], ["proof (prove)\nusing this:\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A (Suc k)) =\n  column (mod_type_class.from_nat i) A\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A (Suc k)) =\n    column (mod_type_class.from_nat i) A", "."], ["proof (state)\nthis:\n  column (mod_type_class.from_nat i) (Gram_Schmidt_upt_k A (Suc k)) =\n  column (mod_type_class.from_nat i) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma columns_Gram_Schmidt_upt_k_rw:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes k: \"Suc k < ncols A\"\n  shows \"{column i (Gram_Schmidt_upt_k A (Suc k)) |i. i < from_nat (Suc k)} \n  = {column i (Gram_Schmidt_upt_k A k) |i. i < from_nat (Suc k)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n     i < mod_type_class.from_nat (Suc k)} =\n    {column i (Gram_Schmidt_upt_k A k) |i.\n     i < mod_type_class.from_nat (Suc k)}", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A (Suc k)) =\n          column ia (Gram_Schmidt_upt_k A k) \\<and>\n          ia < mod_type_class.from_nat (Suc k)\n 2. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A k) =\n          column ia (Gram_Schmidt_upt_k A (Suc k)) \\<and>\n          ia < mod_type_class.from_nat (Suc k)", "fix i::'n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A (Suc k)) =\n          column ia (Gram_Schmidt_upt_k A k) \\<and>\n          ia < mod_type_class.from_nat (Suc k)\n 2. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A k) =\n          column ia (Gram_Schmidt_upt_k A (Suc k)) \\<and>\n          ia < mod_type_class.from_nat (Suc k)", "assume i: \"i < from_nat (Suc k)\""], ["proof (state)\nthis:\n  i < mod_type_class.from_nat (Suc k)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A (Suc k)) =\n          column ia (Gram_Schmidt_upt_k A k) \\<and>\n          ia < mod_type_class.from_nat (Suc k)\n 2. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A k) =\n          column ia (Gram_Schmidt_upt_k A (Suc k)) \\<and>\n          ia < mod_type_class.from_nat (Suc k)", "have to_nat_from_nat_k: \"to_nat (from_nat (Suc k)::'n) = Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "using to_nat_from_nat_id k"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  Suc k < CARD('n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A (Suc k)) =\n          column ia (Gram_Schmidt_upt_k A k) \\<and>\n          ia < mod_type_class.from_nat (Suc k)\n 2. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A k) =\n          column ia (Gram_Schmidt_upt_k A (Suc k)) \\<and>\n          ia < mod_type_class.from_nat (Suc k)", "show \"\\<exists>ia. column i (Gram_Schmidt_upt_k A (Suc k)) = column ia (Gram_Schmidt_upt_k A k) \\<and> ia < from_nat (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i (Gram_Schmidt_upt_k A (Suc k)) =\n       column ia (Gram_Schmidt_upt_k A k) \\<and>\n       ia < mod_type_class.from_nat (Suc k)", "by (metis column_Gram_Schmidt_upt_k_preserves i k ncols_def to_nat_le)"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i (Gram_Schmidt_upt_k A (Suc k)) =\n     column ia (Gram_Schmidt_upt_k A k) \\<and>\n     ia < mod_type_class.from_nat (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < mod_type_class.from_nat (Suc k) \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A k) =\n          column ia (Gram_Schmidt_upt_k A (Suc k)) \\<and>\n          ia < mod_type_class.from_nat (Suc k)", "show \"\\<exists>ia. column i (Gram_Schmidt_upt_k A k) = column ia (Gram_Schmidt_upt_k A (Suc k)) \\<and> ia < from_nat (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i (Gram_Schmidt_upt_k A k) =\n       column ia (Gram_Schmidt_upt_k A (Suc k)) \\<and>\n       ia < mod_type_class.from_nat (Suc k)", "by (metis column_Gram_Schmidt_upt_k_preserves i k ncols_def to_nat_le)"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i (Gram_Schmidt_upt_k A k) =\n     column ia (Gram_Schmidt_upt_k A (Suc k)) \\<and>\n     ia < mod_type_class.from_nat (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma column_Gram_Schmidt_upt_k:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"k<ncols A\"\n  shows \"column (from_nat k) (Gram_Schmidt_upt_k A k) = \n  (column (from_nat k) A) - (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k)|i. i < (from_nat k)}. (x \\<bullet> (column (from_nat k) A) / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat k) A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  i < mod_type_class.from_nat k}.\n       (x \\<bullet> column (mod_type_class.from_nat k) A /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "using assms"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat k) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat k) A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  i < mod_type_class.from_nat k}.\n       (x \\<bullet> column (mod_type_class.from_nat k) A /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "proof (induct k, unfold from_nat_0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < ncols A; k < ncols A\\<rbrakk>\n    \\<Longrightarrow> column (0::'n) (Gram_Schmidt_upt_k A 0) =\n                      column (0::'n) A -\n                      (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A 0) |i.\n                                    i < (0::'n)}.\n                         (x \\<bullet> column (0::'n) A /\n                          (x \\<bullet> x)) *\\<^sub>R\n                         x)\n 2. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "have set_rw: \"{column i (Gram_Schmidt_upt_k A 0) |i. i < 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A 0) |i. i < (0::'n)} = {}", "by (auto, metis least_mod_type not_le)"], ["proof (state)\nthis:\n  {column i (Gram_Schmidt_upt_k A 0) |i. i < (0::'n)} = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < ncols A; k < ncols A\\<rbrakk>\n    \\<Longrightarrow> column (0::'n) (Gram_Schmidt_upt_k A 0) =\n                      column (0::'n) A -\n                      (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A 0) |i.\n                                    i < (0::'n)}.\n                         (x \\<bullet> column (0::'n) A /\n                          (x \\<bullet> x)) *\\<^sub>R\n                         x)\n 2. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "have set_rw2: \"{column i A |i. i < 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i A |i. i < (0::'n)} = {}", "by (auto, metis least_mod_type not_le)"], ["proof (state)\nthis:\n  {column i A |i. i < (0::'n)} = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < ncols A; k < ncols A\\<rbrakk>\n    \\<Longrightarrow> column (0::'n) (Gram_Schmidt_upt_k A 0) =\n                      column (0::'n) A -\n                      (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A 0) |i.\n                                    i < (0::'n)}.\n                         (x \\<bullet> column (0::'n) A /\n                          (x \\<bullet> x)) *\\<^sub>R\n                         x)\n 2. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "have col_rw: \"column 0 A = column 0 (Gram_Schmidt_upt_k A 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (0::'n) A = column (0::'n) (Gram_Schmidt_upt_k A 0)", "unfolding Gram_Schmidt_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (0::'n) A =\n    column (0::'n) (foldl Gram_Schmidt_column_k A [0..<Suc 0])", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (0::'n) A = column (0::'n) (Gram_Schmidt_column_k A 0)", "unfolding Gram_Schmidt_column_k_def from_nat_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (0::'n) A =\n    column (0::'n)\n     (\\<chi>a b.\n         (if b = (0::'n)\n          then column b A - proj_onto (column b A) {column i A |i. i < b}\n          else column b A) $\n         a)", "unfolding column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. A $ i $ (0::'n)) =\n    (\\<chi>i.\n        (\\<chi>a b.\n            (if b = (0::'n)\n             then (\\<chi>i. A $ i $ b) -\n                  proj_onto (\\<chi>i. A $ i $ b)\n                   {\\<chi>ia. A $ ia $ i |i. i < b}\n             else \\<chi>i. A $ i $ b) $\n            a) $\n        i $\n        (0::'n))", "using set_rw2"], ["proof (prove)\nusing this:\n  {column i A |i. i < (0::'n)} = {}\n\ngoal (1 subgoal):\n 1. (\\<chi>i. A $ i $ (0::'n)) =\n    (\\<chi>i.\n        (\\<chi>a b.\n            (if b = (0::'n)\n             then (\\<chi>i. A $ i $ b) -\n                  proj_onto (\\<chi>i. A $ i $ b)\n                   {\\<chi>ia. A $ ia $ i |i. i < b}\n             else \\<chi>i. A $ i $ b) $\n            a) $\n        i $\n        (0::'n))", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\nusing this:\n  {column i A |i. i < (0::'n)} = {}\n\ngoal (1 subgoal):\n 1. (\\<chi>i. A $ i $ (0::'n)) =\n    (\\<chi>i.\n        (\\<chi>a b.\n            (if b = (0::'n)\n             then (\\<chi>i. A $ i $ b) -\n                  (\\<Sum>u\\<in>{\\<chi>ia. A $ ia $ i |i. i < b}.\n                     ((\\<chi>i. A $ i $ b) \\<bullet> u /\n                      (u \\<bullet> u)) *\\<^sub>R\n                     u)\n             else \\<chi>i. A $ i $ b) $\n            a) $\n        i $\n        (0::'n))", "by vector"], ["proof (state)\nthis:\n  column (0::'n) A = column (0::'n) (Gram_Schmidt_upt_k A 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < ncols A; k < ncols A\\<rbrakk>\n    \\<Longrightarrow> column (0::'n) (Gram_Schmidt_upt_k A 0) =\n                      column (0::'n) A -\n                      (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A 0) |i.\n                                    i < (0::'n)}.\n                         (x \\<bullet> column (0::'n) A /\n                          (x \\<bullet> x)) *\\<^sub>R\n                         x)\n 2. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "show \"column 0 (Gram_Schmidt_upt_k A 0) \n    = column 0 A - (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A 0) |i. i < 0}. (x \\<bullet> column 0 A / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (0::'n) (Gram_Schmidt_upt_k A 0) =\n    column (0::'n) A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A 0) |i. i < (0::'n)}.\n       (x \\<bullet> column (0::'n) A / (x \\<bullet> x)) *\\<^sub>R x)", "unfolding set_rw col_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (0::'n) (Gram_Schmidt_upt_k A 0) =\n    column (0::'n) (Gram_Schmidt_upt_k A 0) -\n    (\\<Sum>x\\<in>{}.\n       (x \\<bullet> column (0::'n) (Gram_Schmidt_upt_k A 0) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "by simp"], ["proof (state)\nthis:\n  column (0::'n) (Gram_Schmidt_upt_k A 0) =\n  column (0::'n) A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A 0) |i. i < (0::'n)}.\n     (x \\<bullet> column (0::'n) A / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "case (Suc k)"], ["proof (state)\nthis:\n  k < ncols A \\<Longrightarrow>\n  column (mod_type_class.from_nat k) (Gram_Schmidt_upt_k A k) =\n  column (mod_type_class.from_nat k) A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                i < mod_type_class.from_nat k}.\n     (x \\<bullet> column (mod_type_class.from_nat k) A /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "let ?ak=\"column (from_nat k) A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "let ?uk=\"column (from_nat k) (Gram_Schmidt_upt_k A k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "let ?a_suck= \"column (from_nat (Suc k)) A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "let ?u_suck=\"column (from_nat (Suc k)) (Gram_Schmidt_upt_k A (Suc k))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "have to_nat_from_nat_k: \"to_nat (from_nat (Suc k)::'n) = (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "using to_nat_from_nat_id Suc.prems"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  Suc k < CARD('n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat (Suc k)) = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "have a_suc_rw: \"column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k) = ?a_suck\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) =\n    column (mod_type_class.from_nat (Suc k)) A", "by (rule column_gr_k_Gram_Schmidt_upt, auto simp add: Suc.prems)"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) =\n  column (mod_type_class.from_nat (Suc k)) A\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "have set_rw: \"{column i (Gram_Schmidt_upt_k A (Suc k)) |i. i < from_nat (Suc k)} \n    = {column i (Gram_Schmidt_upt_k A k) |i. i < from_nat (Suc k)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n     i < mod_type_class.from_nat (Suc k)} =\n    {column i (Gram_Schmidt_upt_k A k) |i.\n     i < mod_type_class.from_nat (Suc k)}", "by (rule columns_Gram_Schmidt_upt_k_rw[OF Suc.prems])"], ["proof (state)\nthis:\n  {column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n   i < mod_type_class.from_nat (Suc k)} =\n  {column i (Gram_Schmidt_upt_k A k) |i.\n   i < mod_type_class.from_nat (Suc k)}\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "have \"?u_suck = column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n    i < from_nat (Suc k)}. (x \\<bullet> column (from_nat (Suc k)) (Gram_Schmidt_upt_k A k) / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_upt_k A (Suc k)) =\n    column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  i < mod_type_class.from_nat (Suc k)}.\n       (x \\<bullet>\n        column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "unfolding Gram_Schmidt_upt_k_suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  i < mod_type_class.from_nat (Suc k)}.\n       (x \\<bullet>\n        column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "using column_Gram_Schmidt_column_k[of \"from_nat (Suc k)\" \"(Gram_Schmidt_upt_k A k)\"]"], ["proof (prove)\nusing this:\n  column (mod_type_class.from_nat (Suc k))\n   (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k)\n     (mod_type_class.to_nat (mod_type_class.from_nat (Suc k)))) =\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                i < mod_type_class.from_nat (Suc k)}.\n     (x \\<bullet>\n      column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  i < mod_type_class.from_nat (Suc k)}.\n       (x \\<bullet>\n        column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "unfolding to_nat_from_nat_k"], ["proof (prove)\nusing this:\n  column (mod_type_class.from_nat (Suc k))\n   (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                i < mod_type_class.from_nat (Suc k)}.\n     (x \\<bullet>\n      column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A k) (Suc k)) =\n    column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  i < mod_type_class.from_nat (Suc k)}.\n       (x \\<bullet>\n        column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "by auto"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A (Suc k)) =\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                i < mod_type_class.from_nat (Suc k)}.\n     (x \\<bullet>\n      column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "also"], ["proof (state)\nthis:\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A (Suc k)) =\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                i < mod_type_class.from_nat (Suc k)}.\n     (x \\<bullet>\n      column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "have \"... = ?a_suck -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n    i < from_nat (Suc k)}. (x \\<bullet> ?a_suck / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  i < mod_type_class.from_nat (Suc k)}.\n       (x \\<bullet>\n        column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n        (x \\<bullet> x)) *\\<^sub>R\n       x) =\n    column (mod_type_class.from_nat (Suc k)) A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  i < mod_type_class.from_nat (Suc k)}.\n       (x \\<bullet> column (mod_type_class.from_nat (Suc k)) A /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "unfolding a_suc_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k)) A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  i < mod_type_class.from_nat (Suc k)}.\n       (x \\<bullet> column (mod_type_class.from_nat (Suc k)) A /\n        (x \\<bullet> x)) *\\<^sub>R\n       x) =\n    column (mod_type_class.from_nat (Suc k)) A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  i < mod_type_class.from_nat (Suc k)}.\n       (x \\<bullet> column (mod_type_class.from_nat (Suc k)) A /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", ".."], ["proof (state)\nthis:\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                i < mod_type_class.from_nat (Suc k)}.\n     (x \\<bullet>\n      column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A k) /\n      (x \\<bullet> x)) *\\<^sub>R\n     x) =\n  column (mod_type_class.from_nat (Suc k)) A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                i < mod_type_class.from_nat (Suc k)}.\n     (x \\<bullet> column (mod_type_class.from_nat (Suc k)) A /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ka < ncols A \\<Longrightarrow>\n                column (mod_type_class.from_nat ka)\n                 (Gram_Schmidt_upt_k A ka) =\n                column (mod_type_class.from_nat ka) A -\n                (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A ka) |i.\n                              i < mod_type_class.from_nat ka}.\n                   (x \\<bullet> column (mod_type_class.from_nat ka) A /\n                    (x \\<bullet> x)) *\\<^sub>R\n                   x);\n        Suc ka < ncols A; k < ncols A\\<rbrakk>\n       \\<Longrightarrow> column (mod_type_class.from_nat (Suc ka))\n                          (Gram_Schmidt_upt_k A (Suc ka)) =\n                         column (mod_type_class.from_nat (Suc ka)) A -\n                         (\\<Sum>x\\<in>{column i\n  (Gram_Schmidt_upt_k A (Suc ka)) |\n i. i < mod_type_class.from_nat (Suc ka)}.\n                            (x \\<bullet>\n                             column (mod_type_class.from_nat (Suc ka)) A /\n                             (x \\<bullet> x)) *\\<^sub>R\n                            x)", "finally"], ["proof (chain)\npicking this:\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A (Suc k)) =\n  column (mod_type_class.from_nat (Suc k)) A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                i < mod_type_class.from_nat (Suc k)}.\n     (x \\<bullet> column (mod_type_class.from_nat (Suc k)) A /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)", "show \"?u_suck = ?a_suck - (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n    i < from_nat (Suc k)}. (x \\<bullet> ?a_suck / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\nusing this:\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A (Suc k)) =\n  column (mod_type_class.from_nat (Suc k)) A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                i < mod_type_class.from_nat (Suc k)}.\n     (x \\<bullet> column (mod_type_class.from_nat (Suc k)) A /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_upt_k A (Suc k)) =\n    column (mod_type_class.from_nat (Suc k)) A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n                  i < mod_type_class.from_nat (Suc k)}.\n       (x \\<bullet> column (mod_type_class.from_nat (Suc k)) A /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "unfolding set_rw"], ["proof (prove)\nusing this:\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A (Suc k)) =\n  column (mod_type_class.from_nat (Suc k)) A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                i < mod_type_class.from_nat (Suc k)}.\n     (x \\<bullet> column (mod_type_class.from_nat (Suc k)) A /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc k))\n     (Gram_Schmidt_upt_k A (Suc k)) =\n    column (mod_type_class.from_nat (Suc k)) A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A k) |i.\n                  i < mod_type_class.from_nat (Suc k)}.\n       (x \\<bullet> column (mod_type_class.from_nat (Suc k)) A /\n        (x \\<bullet> x)) *\\<^sub>R\n       x)", "."], ["proof (state)\nthis:\n  column (mod_type_class.from_nat (Suc k)) (Gram_Schmidt_upt_k A (Suc k)) =\n  column (mod_type_class.from_nat (Suc k)) A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A (Suc k)) |i.\n                i < mod_type_class.from_nat (Suc k)}.\n     (x \\<bullet> column (mod_type_class.from_nat (Suc k)) A /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma column_Gram_Schmidt_upt_k_preserves2:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"a\\<le>(from_nat i)\"\n  and \"i \\<le> j\"\n  and \"j<ncols A\"\n  shows \"column a (Gram_Schmidt_upt_k A i) = column a (Gram_Schmidt_upt_k A j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column a (Gram_Schmidt_upt_k A i) = column a (Gram_Schmidt_upt_k A j)", "using assms"], ["proof (prove)\nusing this:\n  a \\<le> mod_type_class.from_nat i\n  i \\<le> j\n  j < ncols A\n\ngoal (1 subgoal):\n 1. column a (Gram_Schmidt_upt_k A i) = column a (Gram_Schmidt_upt_k A j)", "proof (induct j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> mod_type_class.from_nat i; i \\<le> 0;\n     0 < ncols A\\<rbrakk>\n    \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                      column a (Gram_Schmidt_upt_k A 0)\n 2. \\<And>j.\n       \\<lbrakk>\\<lbrakk>a \\<le> mod_type_class.from_nat i; i \\<le> j;\n                 j < ncols A\\<rbrakk>\n                \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                                  column a (Gram_Schmidt_upt_k A j);\n        a \\<le> mod_type_class.from_nat i; i \\<le> Suc j;\n        Suc j < ncols A\\<rbrakk>\n       \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                         column a (Gram_Schmidt_upt_k A (Suc j))", "case 0"], ["proof (state)\nthis:\n  a \\<le> mod_type_class.from_nat i\n  i \\<le> 0\n  0 < ncols A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> mod_type_class.from_nat i; i \\<le> 0;\n     0 < ncols A\\<rbrakk>\n    \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                      column a (Gram_Schmidt_upt_k A 0)\n 2. \\<And>j.\n       \\<lbrakk>\\<lbrakk>a \\<le> mod_type_class.from_nat i; i \\<le> j;\n                 j < ncols A\\<rbrakk>\n                \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                                  column a (Gram_Schmidt_upt_k A j);\n        a \\<le> mod_type_class.from_nat i; i \\<le> Suc j;\n        Suc j < ncols A\\<rbrakk>\n       \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                         column a (Gram_Schmidt_upt_k A (Suc j))", "show \"column a (Gram_Schmidt_upt_k A i) = column a (Gram_Schmidt_upt_k A 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column a (Gram_Schmidt_upt_k A i) = column a (Gram_Schmidt_upt_k A 0)", "by (metis \"0.prems\"(2) le_0_eq)"], ["proof (state)\nthis:\n  column a (Gram_Schmidt_upt_k A i) = column a (Gram_Schmidt_upt_k A 0)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>a \\<le> mod_type_class.from_nat i; i \\<le> j;\n                 j < ncols A\\<rbrakk>\n                \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                                  column a (Gram_Schmidt_upt_k A j);\n        a \\<le> mod_type_class.from_nat i; i \\<le> Suc j;\n        Suc j < ncols A\\<rbrakk>\n       \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                         column a (Gram_Schmidt_upt_k A (Suc j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>a \\<le> mod_type_class.from_nat i; i \\<le> j;\n                 j < ncols A\\<rbrakk>\n                \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                                  column a (Gram_Schmidt_upt_k A j);\n        a \\<le> mod_type_class.from_nat i; i \\<le> Suc j;\n        Suc j < ncols A\\<rbrakk>\n       \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                         column a (Gram_Schmidt_upt_k A (Suc j))", "case (Suc j)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<le> mod_type_class.from_nat i; i \\<le> j;\n   j < ncols A\\<rbrakk>\n  \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                    column a (Gram_Schmidt_upt_k A j)\n  a \\<le> mod_type_class.from_nat i\n  i \\<le> Suc j\n  Suc j < ncols A\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<lbrakk>a \\<le> mod_type_class.from_nat i; i \\<le> j;\n                 j < ncols A\\<rbrakk>\n                \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                                  column a (Gram_Schmidt_upt_k A j);\n        a \\<le> mod_type_class.from_nat i; i \\<le> Suc j;\n        Suc j < ncols A\\<rbrakk>\n       \\<Longrightarrow> column a (Gram_Schmidt_upt_k A i) =\n                         column a (Gram_Schmidt_upt_k A (Suc j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "proof (cases \"a=from_nat (Suc j)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))\n 2. a \\<noteq> mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "case False"], ["proof (state)\nthis:\n  a \\<noteq> mod_type_class.from_nat (Suc j)\n\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))\n 2. a \\<noteq> mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "note a_not_suc_j=False"], ["proof (state)\nthis:\n  a \\<noteq> mod_type_class.from_nat (Suc j)\n\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))\n 2. a \\<noteq> mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "have rw1: \"(to_nat (from_nat (Suc j)::'n)) = Suc j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc j)) = Suc j", "using to_nat_from_nat_id Suc.prems"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  a \\<le> mod_type_class.from_nat i\n  i \\<le> Suc j\n  Suc j < ncols A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc j)) = Suc j", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  a \\<le> mod_type_class.from_nat i\n  i \\<le> Suc j\n  Suc j < CARD('n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc j)) = Suc j", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat (Suc j)) = Suc j\n\ngoal (2 subgoals):\n 1. a = mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))\n 2. a \\<noteq> mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "unfolding Gram_Schmidt_upt_k_suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A j) (Suc j))", "using column_Gram_Schmidt_column_k'[OF a_not_suc_j]"], ["proof (prove)\nusing this:\n  column a\n   (Gram_Schmidt_column_k ?A\n     (mod_type_class.to_nat (mod_type_class.from_nat (Suc j)))) =\n  column a ?A\n\ngoal (1 subgoal):\n 1. column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A j) (Suc j))", "unfolding rw1"], ["proof (prove)\nusing this:\n  column a (Gram_Schmidt_column_k ?A (Suc j)) = column a ?A\n\ngoal (1 subgoal):\n 1. column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_column_k (Gram_Schmidt_upt_k A j) (Suc j))", "by (metis Gram_Schmidt_upt_k_suc Suc.hyps Suc.prems(2) Suc.prems(3) Suc_le_lessD assms(1) le_Suc_eq nat_less_le)"], ["proof (state)\nthis:\n  column a (Gram_Schmidt_upt_k A i) =\n  column a (Gram_Schmidt_upt_k A (Suc j))\n\ngoal (1 subgoal):\n 1. a = mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "case True"], ["proof (state)\nthis:\n  a = mod_type_class.from_nat (Suc j)\n\ngoal (1 subgoal):\n 1. a = mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "have \"(from_nat i::'n) \\<le> from_nat (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i \\<le> mod_type_class.from_nat (Suc j)", "by (rule from_nat_mono'[OF Suc.prems(2) Suc.prems(3)[unfolded ncols_def]])"], ["proof (state)\nthis:\n  mod_type_class.from_nat i \\<le> mod_type_class.from_nat (Suc j)\n\ngoal (1 subgoal):\n 1. a = mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "hence \"from_nat i = (from_nat (Suc j)::'n)\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i \\<le> mod_type_class.from_nat (Suc j)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i = mod_type_class.from_nat (Suc j)", "using Suc.prems(1)"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i \\<le> mod_type_class.from_nat (Suc j)\n  a \\<le> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i = mod_type_class.from_nat (Suc j)", "unfolding True"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i \\<le> mod_type_class.from_nat (Suc j)\n  mod_type_class.from_nat (Suc j) \\<le> mod_type_class.from_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat i = mod_type_class.from_nat (Suc j)", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat i = mod_type_class.from_nat (Suc j)\n\ngoal (1 subgoal):\n 1. a = mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "hence i_eq_suc: \"i=Suc j\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i = mod_type_class.from_nat (Suc j)\n\ngoal (1 subgoal):\n 1. i = Suc j", "apply (rule from_nat_eq_imp_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < CARD('n)\n 2. Suc j < CARD('n)", "using Suc.prems"], ["proof (prove)\nusing this:\n  a \\<le> mod_type_class.from_nat i\n  i \\<le> Suc j\n  Suc j < ncols A\n\ngoal (2 subgoals):\n 1. i < CARD('n)\n 2. Suc j < CARD('n)", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  a \\<le> mod_type_class.from_nat i\n  i \\<le> Suc j\n  Suc j < CARD('n)\n\ngoal (2 subgoals):\n 1. i < CARD('n)\n 2. Suc j < CARD('n)", "by auto"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. a = mod_type_class.from_nat (Suc j) \\<Longrightarrow>\n    column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. column a (Gram_Schmidt_upt_k A i) =\n    column a (Gram_Schmidt_upt_k A (Suc j))", "unfolding True i_eq_suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. column (mod_type_class.from_nat (Suc j))\n     (Gram_Schmidt_upt_k A (Suc j)) =\n    column (mod_type_class.from_nat (Suc j)) (Gram_Schmidt_upt_k A (Suc j))", ".."], ["proof (state)\nthis:\n  column a (Gram_Schmidt_upt_k A i) =\n  column a (Gram_Schmidt_upt_k A (Suc j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  column a (Gram_Schmidt_upt_k A i) =\n  column a (Gram_Schmidt_upt_k A (Suc j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_columns_Gram_Schmidt_matrix: \n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  shows \"{column i (Gram_Schmidt_matrix A)|i. i < k} = {column i (Gram_Schmidt_upt_k A (to_nat k))|i. i < k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_matrix A) |i. i < k} =\n    {column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) |i. i < k}", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_matrix A) =\n          column ia (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) \\<and>\n          ia < k\n 2. \\<And>i.\n       i < k \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n          column ia (Gram_Schmidt_matrix A) \\<and>\n          ia < k", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_matrix A) =\n          column ia (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) \\<and>\n          ia < k\n 2. \\<And>i.\n       i < k \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n          column ia (Gram_Schmidt_matrix A) \\<and>\n          ia < k", "assume i: \"i<k\""], ["proof (state)\nthis:\n  i < k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_matrix A) =\n          column ia (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) \\<and>\n          ia < k\n 2. \\<And>i.\n       i < k \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n          column ia (Gram_Schmidt_matrix A) \\<and>\n          ia < k", "show \"\\<exists>ia. column i (Gram_Schmidt_matrix A) = column ia (Gram_Schmidt_upt_k A (to_nat k)) \\<and> ia < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i (Gram_Schmidt_matrix A) =\n       column ia (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) \\<and>\n       ia < k", "proof (rule exI[of _ i], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. column i (Gram_Schmidt_matrix A) =\n    column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k))\n 2. i < k", "show \"column i (Gram_Schmidt_matrix A) = column i (Gram_Schmidt_upt_k A (to_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_matrix A) =\n    column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k))", "unfolding Gram_Schmidt_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (ncols A - 1)) =\n    column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k))", "proof (rule column_Gram_Schmidt_upt_k_preserves2[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. i \\<le> mod_type_class.from_nat (mod_type_class.to_nat k)\n 2. mod_type_class.to_nat k \\<le> ncols A - 1\n 3. ncols A - 1 < ncols A", "show \"i \\<le> from_nat (to_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat (mod_type_class.to_nat k)", "using i"], ["proof (prove)\nusing this:\n  i < k\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat (mod_type_class.to_nat k)", "unfolding from_nat_to_nat_id"], ["proof (prove)\nusing this:\n  i < k\n\ngoal (1 subgoal):\n 1. i \\<le> k", "by auto"], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat (mod_type_class.to_nat k)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat k \\<le> ncols A - 1\n 2. ncols A - 1 < ncols A", "show \"to_nat k \\<le> ncols A - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k \\<le> ncols A - 1", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k \\<le> CARD('n) - 1", "using to_nat_less_card[of k]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat k < CARD('n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k \\<le> CARD('n) - 1", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat k \\<le> ncols A - 1\n\ngoal (1 subgoal):\n 1. ncols A - 1 < ncols A", "show \"ncols A - 1 < ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols A - 1 < ncols A", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('n) - 1 < CARD('n)", "by simp"], ["proof (state)\nthis:\n  ncols A - 1 < ncols A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  column i (Gram_Schmidt_matrix A) =\n  column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k))\n\ngoal (1 subgoal):\n 1. i < k", "show \"i < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < k", "using i"], ["proof (prove)\nusing this:\n  i < k\n\ngoal (1 subgoal):\n 1. i < k", "."], ["proof (state)\nthis:\n  i < k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i (Gram_Schmidt_matrix A) =\n     column ia (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) \\<and>\n     ia < k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < k \\<Longrightarrow>\n       \\<exists>ia.\n          column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n          column ia (Gram_Schmidt_matrix A) \\<and>\n          ia < k", "show \"\\<exists>ia. column i (Gram_Schmidt_upt_k A (to_nat k)) = column ia (Gram_Schmidt_matrix A) \\<and> ia < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n       column ia (Gram_Schmidt_matrix A) \\<and>\n       ia < k", "proof (rule exI[of _ i], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n    column i (Gram_Schmidt_matrix A)\n 2. i < k", "show \"column i (Gram_Schmidt_upt_k A (to_nat k)) = column i (Gram_Schmidt_matrix A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n    column i (Gram_Schmidt_matrix A)", "unfolding Gram_Schmidt_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n    column i (Gram_Schmidt_upt_k A (ncols A - 1))", "proof (rule column_Gram_Schmidt_upt_k_preserves2)"], ["proof (state)\ngoal (3 subgoals):\n 1. i \\<le> mod_type_class.from_nat (mod_type_class.to_nat k)\n 2. mod_type_class.to_nat k \\<le> ncols A - 1\n 3. ncols A - 1 < ncols A", "show \"i \\<le> from_nat (to_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat (mod_type_class.to_nat k)", "using i"], ["proof (prove)\nusing this:\n  i < k\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat (mod_type_class.to_nat k)", "unfolding from_nat_to_nat_id"], ["proof (prove)\nusing this:\n  i < k\n\ngoal (1 subgoal):\n 1. i \\<le> k", "by auto"], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat (mod_type_class.to_nat k)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat k \\<le> ncols A - 1\n 2. ncols A - 1 < ncols A", "show \"to_nat k \\<le> ncols A - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k \\<le> ncols A - 1", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k \\<le> CARD('n) - 1", "using to_nat_less_card[of k]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat k < CARD('n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k \\<le> CARD('n) - 1", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat k \\<le> ncols A - 1\n\ngoal (1 subgoal):\n 1. ncols A - 1 < ncols A", "show \"ncols A - 1 < ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols A - 1 < ncols A", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('n) - 1 < CARD('n)", "by simp"], ["proof (state)\nthis:\n  ncols A - 1 < ncols A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n  column i (Gram_Schmidt_matrix A)\n\ngoal (1 subgoal):\n 1. i < k", "show \"i < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < k", "using i"], ["proof (prove)\nusing this:\n  i < k\n\ngoal (1 subgoal):\n 1. i < k", "."], ["proof (state)\nthis:\n  i < k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n     column ia (Gram_Schmidt_matrix A) \\<and>\n     ia < k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma column_Gram_Schmidt_matrix:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  shows \"column k (Gram_Schmidt_matrix A) \n  = (column k A) - (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A)|i. i < k}. (x \\<bullet> (column k A) / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_matrix A) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_matrix A) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "have k: \"to_nat k < ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k < ncols A", "using to_nat_less_card[of k]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat k < CARD('n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k < ncols A", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat k < CARD('n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k < CARD('n)", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat k < ncols A\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_matrix A) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "have \"column k (Gram_Schmidt_matrix A) = column k (Gram_Schmidt_upt_k A (ncols A - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_matrix A) =\n    column k (Gram_Schmidt_upt_k A (ncols A - 1))", "unfolding Gram_Schmidt_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_upt_k A (ncols A - 1)) =\n    column k (Gram_Schmidt_upt_k A (ncols A - 1))", ".."], ["proof (state)\nthis:\n  column k (Gram_Schmidt_matrix A) =\n  column k (Gram_Schmidt_upt_k A (ncols A - 1))\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_matrix A) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "also"], ["proof (state)\nthis:\n  column k (Gram_Schmidt_matrix A) =\n  column k (Gram_Schmidt_upt_k A (ncols A - 1))\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_matrix A) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "have \"... = column k (Gram_Schmidt_upt_k A (to_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_upt_k A (ncols A - 1)) =\n    column k (Gram_Schmidt_upt_k A (mod_type_class.to_nat k))", "proof (rule column_Gram_Schmidt_upt_k_preserves2[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. k \\<le> mod_type_class.from_nat (mod_type_class.to_nat k)\n 2. mod_type_class.to_nat k \\<le> ncols A - 1\n 3. ncols A - 1 < ncols A", "show \"k \\<le> from_nat (to_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> mod_type_class.from_nat (mod_type_class.to_nat k)", "unfolding from_nat_to_nat_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> k", ".."], ["proof (state)\nthis:\n  k \\<le> mod_type_class.from_nat (mod_type_class.to_nat k)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat k \\<le> ncols A - 1\n 2. ncols A - 1 < ncols A", "show \"to_nat k \\<le> ncols A - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k \\<le> ncols A - 1", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k \\<le> CARD('n) - 1", "using to_nat_less_card[where ?'a='n]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?j < CARD('n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat k \\<le> CARD('n) - 1", "by (metis le_diff_conv2 add_leE less_diff_conv less_imp_le_nat  less_le_not_le\n        nat_le_linear suc_not_zero to_nat_plus_one_less_card')"], ["proof (state)\nthis:\n  mod_type_class.to_nat k \\<le> ncols A - 1\n\ngoal (1 subgoal):\n 1. ncols A - 1 < ncols A", "show \"ncols A - 1 < ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols A - 1 < ncols A", "unfolding ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('n) - 1 < CARD('n)", "by auto"], ["proof (state)\nthis:\n  ncols A - 1 < ncols A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  column k (Gram_Schmidt_upt_k A (ncols A - 1)) =\n  column k (Gram_Schmidt_upt_k A (mod_type_class.to_nat k))\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_matrix A) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "also"], ["proof (state)\nthis:\n  column k (Gram_Schmidt_upt_k A (ncols A - 1)) =\n  column k (Gram_Schmidt_upt_k A (mod_type_class.to_nat k))\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_matrix A) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "have \"... = column k A - (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A (to_nat k)) |i. i < k}. (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n    column k A -\n    (\\<Sum>x\\<in>{column i\n                   (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) |\n                  i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "using column_Gram_Schmidt_upt_k[OF k]"], ["proof (prove)\nusing this:\n  column (mod_type_class.from_nat (mod_type_class.to_nat k))\n   (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n  column (mod_type_class.from_nat (mod_type_class.to_nat k)) A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) |\n                i. i < mod_type_class.from_nat (mod_type_class.to_nat k)}.\n     (x \\<bullet>\n      column (mod_type_class.from_nat (mod_type_class.to_nat k)) A /\n      (x \\<bullet> x)) *\\<^sub>R\n     x)\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n    column k A -\n    (\\<Sum>x\\<in>{column i\n                   (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) |\n                  i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "unfolding from_nat_to_nat_id"], ["proof (prove)\nusing this:\n  column k (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n  column k A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) |\n                i. i < k}.\n     (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n    column k A -\n    (\\<Sum>x\\<in>{column i\n                   (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) |\n                  i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "by auto"], ["proof (state)\nthis:\n  column k (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n  column k A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) |\n                i. i < k}.\n     (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_matrix A) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "also"], ["proof (state)\nthis:\n  column k (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) =\n  column k A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) |\n                i. i < k}.\n     (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_matrix A) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "have \"... = column k A - (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}. (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column k A -\n    (\\<Sum>x\\<in>{column i\n                   (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) |\n                  i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "unfolding set_columns_Gram_Schmidt_matrix[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", ".."], ["proof (state)\nthis:\n  column k A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_upt_k A (mod_type_class.to_nat k)) |\n                i. i < k}.\n     (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x) =\n  column k A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n     (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_matrix A) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "finally"], ["proof (chain)\npicking this:\n  column k (Gram_Schmidt_matrix A) =\n  column k A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n     (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "show ?thesis"], ["proof (prove)\nusing this:\n  column k (Gram_Schmidt_matrix A) =\n  column k A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n     (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. column k (Gram_Schmidt_matrix A) =\n    column k A -\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "."], ["proof (state)\nthis:\n  column k (Gram_Schmidt_matrix A) =\n  column k A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n     (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary column_Gram_Schmidt_matrix2:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  shows \"(column k A) = column k (Gram_Schmidt_matrix A) \n  + (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A)|i. i < k}. (x \\<bullet> (column k A) / (x \\<bullet> x)) *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column k A =\n    column k (Gram_Schmidt_matrix A) +\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "using column_Gram_Schmidt_matrix[of k A]"], ["proof (prove)\nusing this:\n  column k (Gram_Schmidt_matrix A) =\n  column k A -\n  (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n     (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. column k A =\n    column k (Gram_Schmidt_matrix A) +\n    (\\<Sum>x\\<in>{column i (Gram_Schmidt_matrix A) |i. i < k}.\n       (x \\<bullet> column k A / (x \\<bullet> x)) *\\<^sub>R x)", "by simp"], ["", "lemma independent_columns_Gram_Schmidt_matrix:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes b: \"vec.independent (columns A)\"\n  and c: \"card (columns A) = ncols A\"\n  shows \"vec.independent (columns (Gram_Schmidt_matrix A)) \\<and> card (columns (Gram_Schmidt_matrix A)) = ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent (columns (Gram_Schmidt_matrix A)) \\<and>\n    card (columns (Gram_Schmidt_matrix A)) = ncols A", "using  b c card_columns_le_ncols vec.card_eq_dim_span_indep vec.dim_span eq_iff finite_columns \n    vec.independent_span_bound ncols_def span_Gram_Schmidt_matrix"], ["proof (prove)\nusing this:\n  vec.independent (columns A)\n  card (columns A) = ncols A\n  card (columns ?A) \\<le> ncols ?A\n  \\<lbrakk>vec.dim (vec.span ?A) = card ?A; finite ?A\\<rbrakk>\n  \\<Longrightarrow> vec.independent ?A\n  vec.dim (vec.span ?S) = vec.dim ?S\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n  finite (columns ?A)\n  \\<lbrakk>finite ?T; vec.independent ?S;\n   ?S \\<subseteq> vec.span ?T\\<rbrakk>\n  \\<Longrightarrow> finite ?S \\<and> card ?S \\<le> card ?T\n  ncols ?A = CARD(?'columns)\n  span (columns ?A) = span (columns (Gram_Schmidt_matrix ?A))\n\ngoal (1 subgoal):\n 1. vec.independent (columns (Gram_Schmidt_matrix A)) \\<and>\n    card (columns (Gram_Schmidt_matrix A)) = ncols A", "by (metis (no_types, lifting) vec.card_ge_dim_independent vec.dim_span_eq_card_independent span_vec_eq)"], ["", "lemma column_eq_Gram_Schmidt_matrix:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  and c: \"column i (Gram_Schmidt_matrix A) = column ia (Gram_Schmidt_matrix A)\"\n  shows \"i = ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = ia", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow> False", "assume i_not_ia: \"i \\<noteq> ia\""], ["proof (state)\nthis:\n  i \\<noteq> ia\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow> False", "have \"columns (Gram_Schmidt_matrix A) = (\\<lambda>x. column x (Gram_Schmidt_matrix A))` (UNIV::('n::{mod_type}) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. columns (Gram_Schmidt_matrix A) =\n    range (\\<lambda>x. column x (Gram_Schmidt_matrix A))", "unfolding columns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {column i (Gram_Schmidt_matrix A) |i. i \\<in> UNIV} =\n    range (\\<lambda>x. column x (Gram_Schmidt_matrix A))", "by auto"], ["proof (state)\nthis:\n  columns (Gram_Schmidt_matrix A) =\n  range (\\<lambda>x. column x (Gram_Schmidt_matrix A))\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  columns (Gram_Schmidt_matrix A) =\n  range (\\<lambda>x. column x (Gram_Schmidt_matrix A))\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow> False", "have \"... = (\\<lambda>x. column x (Gram_Schmidt_matrix A))` ((UNIV::('n::{mod_type}) set)-{ia})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>x. column x (Gram_Schmidt_matrix A)) =\n    (\\<lambda>x. column x (Gram_Schmidt_matrix A)) ` (UNIV - {ia})", "proof (unfold image_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<exists>x\\<in>UNIV - {ia}.\n          column xa (Gram_Schmidt_matrix A) =\n          column x (Gram_Schmidt_matrix A)", "fix xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<exists>x\\<in>UNIV - {ia}.\n          column xa (Gram_Schmidt_matrix A) =\n          column x (Gram_Schmidt_matrix A)", "show \"\\<exists>x\\<in>UNIV - {ia}. column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>UNIV - {ia}.\n       column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)", "proof (cases \"xa = ia\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xa = ia \\<Longrightarrow>\n    \\<exists>x\\<in>UNIV - {ia}.\n       column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)\n 2. xa \\<noteq> ia \\<Longrightarrow>\n    \\<exists>x\\<in>UNIV - {ia}.\n       column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)", "case True"], ["proof (state)\nthis:\n  xa = ia\n\ngoal (2 subgoals):\n 1. xa = ia \\<Longrightarrow>\n    \\<exists>x\\<in>UNIV - {ia}.\n       column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)\n 2. xa \\<noteq> ia \\<Longrightarrow>\n    \\<exists>x\\<in>UNIV - {ia}.\n       column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xa = ia\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>UNIV - {ia}.\n       column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)", "using c i_not_ia"], ["proof (prove)\nusing this:\n  xa = ia\n  column i (Gram_Schmidt_matrix A) = column ia (Gram_Schmidt_matrix A)\n  i \\<noteq> ia\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>UNIV - {ia}.\n       column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)", "by (metis DiffI UNIV_I empty_iff insert_iff)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>UNIV - {ia}.\n     column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)\n\ngoal (1 subgoal):\n 1. xa \\<noteq> ia \\<Longrightarrow>\n    \\<exists>x\\<in>UNIV - {ia}.\n       column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xa \\<noteq> ia \\<Longrightarrow>\n    \\<exists>x\\<in>UNIV - {ia}.\n       column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)", "case False"], ["proof (state)\nthis:\n  xa \\<noteq> ia\n\ngoal (1 subgoal):\n 1. xa \\<noteq> ia \\<Longrightarrow>\n    \\<exists>x\\<in>UNIV - {ia}.\n       column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xa \\<noteq> ia\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>UNIV - {ia}.\n       column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>UNIV - {ia}.\n     column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x\\<in>UNIV - {ia}.\n     column xa (Gram_Schmidt_matrix A) = column x (Gram_Schmidt_matrix A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  range (\\<lambda>x. column x (Gram_Schmidt_matrix A)) =\n  (\\<lambda>x. column x (Gram_Schmidt_matrix A)) ` (UNIV - {ia})\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  columns (Gram_Schmidt_matrix A) =\n  (\\<lambda>x. column x (Gram_Schmidt_matrix A)) ` (UNIV - {ia})", "have columns_rw: \"columns (Gram_Schmidt_matrix A) = (\\<lambda>x. column x (Gram_Schmidt_matrix A)) ` (UNIV - {ia})\""], ["proof (prove)\nusing this:\n  columns (Gram_Schmidt_matrix A) =\n  (\\<lambda>x. column x (Gram_Schmidt_matrix A)) ` (UNIV - {ia})\n\ngoal (1 subgoal):\n 1. columns (Gram_Schmidt_matrix A) =\n    (\\<lambda>x. column x (Gram_Schmidt_matrix A)) ` (UNIV - {ia})", "."], ["proof (state)\nthis:\n  columns (Gram_Schmidt_matrix A) =\n  (\\<lambda>x. column x (Gram_Schmidt_matrix A)) ` (UNIV - {ia})\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow> False", "have \"ncols A = card (columns (Gram_Schmidt_matrix A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols A = card (columns (Gram_Schmidt_matrix A))", "by (metis full_rank_imp_is_basis2 independent_columns_Gram_Schmidt_matrix r)"], ["proof (state)\nthis:\n  ncols A = card (columns (Gram_Schmidt_matrix A))\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  ncols A = card (columns (Gram_Schmidt_matrix A))\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow> False", "have \"... \\<le> card (UNIV - {ia})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (columns (Gram_Schmidt_matrix A)) \\<le> card (UNIV - {ia})", "unfolding columns_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>x. column x (Gram_Schmidt_matrix A)) ` (UNIV - {ia}))\n    \\<le> card (UNIV - {ia})", "by (rule card_image_le, simp)"], ["proof (state)\nthis:\n  card (columns (Gram_Schmidt_matrix A)) \\<le> card (UNIV - {ia})\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card (columns (Gram_Schmidt_matrix A)) \\<le> card (UNIV - {ia})\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow> False", "have \"... = card (UNIV::'n set) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (UNIV - {ia}) = CARD('n) - 1", "by (simp add: card_Diff_singleton)"], ["proof (state)\nthis:\n  card (UNIV - {ia}) = CARD('n) - 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> ia \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  ncols A \\<le> CARD('n) - 1", "show False"], ["proof (prove)\nusing this:\n  ncols A \\<le> CARD('n) - 1\n\ngoal (1 subgoal):\n 1. False", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  CARD('n) \\<le> CARD('n) - 1\n\ngoal (1 subgoal):\n 1. False", "by (metis Nat.add_0_right le_diff_conv2 One_nat_def Suc_n_not_le_n add_Suc_right one_le_card_finite)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scaleR_columns_Gram_Schmidt_matrix:\n  fixes A::\"real^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"i \\<noteq> j\"\n  and \"rank A = ncols A\"\n  shows \"column j (Gram_Schmidt_matrix A) \\<bullet> column i (Gram_Schmidt_matrix A) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_matrix A) \\<bullet>\n    column i (Gram_Schmidt_matrix A) =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_matrix A) \\<bullet>\n    column i (Gram_Schmidt_matrix A) =\n    0", "have \"column j (Gram_Schmidt_matrix A) \\<noteq> column i (Gram_Schmidt_matrix A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_matrix A) \\<noteq>\n    column i (Gram_Schmidt_matrix A)", "using column_eq_Gram_Schmidt_matrix assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>rank ?A = ncols ?A;\n   column ?i (Gram_Schmidt_matrix ?A) =\n   column ?ia (Gram_Schmidt_matrix ?A)\\<rbrakk>\n  \\<Longrightarrow> ?i = ?ia\n  i \\<noteq> j\n  rank A = ncols A\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_matrix A) \\<noteq>\n    column i (Gram_Schmidt_matrix A)", "by auto"], ["proof (state)\nthis:\n  column j (Gram_Schmidt_matrix A) \\<noteq> column i (Gram_Schmidt_matrix A)\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_matrix A) \\<bullet>\n    column i (Gram_Schmidt_matrix A) =\n    0", "thus ?thesis"], ["proof (prove)\nusing this:\n  column j (Gram_Schmidt_matrix A) \\<noteq> column i (Gram_Schmidt_matrix A)\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_matrix A) \\<bullet>\n    column i (Gram_Schmidt_matrix A) =\n    0", "using orthogonal_Gram_Schmidt_matrix2"], ["proof (prove)\nusing this:\n  column j (Gram_Schmidt_matrix A) \\<noteq> column i (Gram_Schmidt_matrix A)\n  pairwise orthogonal (columns (Gram_Schmidt_matrix ?A))\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_matrix A) \\<bullet>\n    column i (Gram_Schmidt_matrix A) =\n    0", "unfolding pairwise_def orthogonal_def columns_def"], ["proof (prove)\nusing this:\n  column j (Gram_Schmidt_matrix A) \\<noteq> column i (Gram_Schmidt_matrix A)\n  \\<forall>x\\<in>{column i (Gram_Schmidt_matrix ?A) |i. i \\<in> UNIV}.\n     \\<forall>y\\<in>{column i (Gram_Schmidt_matrix ?A) |i. i \\<in> UNIV}.\n        x \\<noteq> y \\<longrightarrow> x \\<bullet> y = 0\n\ngoal (1 subgoal):\n 1. column j (Gram_Schmidt_matrix A) \\<bullet>\n    column i (Gram_Schmidt_matrix A) =\n    0", "by blast"], ["proof (state)\nthis:\n  column j (Gram_Schmidt_matrix A) \\<bullet>\n  column i (Gram_Schmidt_matrix A) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Examples of execution\\<close>"], ["", "text\\<open>Code lemma\\<close>"], ["", "lemmas Gram_Schmidt_step_def[unfolded proj_onto_def proj_def[abs_def],code]"], ["", "value \"let a = map (list_to_vec::real list=> real^4) [[4,-2,-1,2], \n  [-6,3,4,-8], [5,-5,-3,-4]] in \n  map vec_to_list (Gram_Schmidt a)\""], ["", "value \"let a = map (list_to_vec::real list=> real^4) [[4,-2,-1,2], \n  [-6,3,4,-8], [5,-5,-3,-4]] in \n  map vec_to_list (Gram_Schmidt2 a)\""], ["", "value \"let A = list_of_list_to_matrix [[4,-2,-1,2], \n  [-6,3,4,-8], [5,-5,-3,-4]]::real^4^3 in \n  matrix_to_list_of_list (Gram_Schmidt_matrix A)\""], ["", "end"]]}