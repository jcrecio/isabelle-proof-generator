{"file_name": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition/Matrix_To_IArray_QR.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition", "problem_names": ["lemma vec_to_iarray_nth:\n  fixes A::\"'a^'n::{finite, mod_type}\"\n  assumes i: \"i<CARD('n)\"\n  shows \"(vec_to_iarray A) !! i = A $ (from_nat i)\"", "lemma vec_to_iarray_nth':\n  fixes A::\"'a^'n::{mod_type}\"\n  shows \"(vec_to_iarray A) !! (to_nat i) = A $ i\"", "lemma iarray_to_vec_nth:\n  shows \"(iarray_to_vec A) $ i = A !! (to_nat i)\"", "lemma vec_to_iarray_morph:\n  fixes A::\"'a^'n::{mod_type}\"\n  shows \"(A = B) = (vec_to_iarray A = vec_to_iarray B)\"", "lemma inj_vec_to_iarray:\n  shows \"inj vec_to_iarray\"", "lemma iarray_to_vec_vec_to_iarray:\n  fixes A::\"'a^'n::{mod_type}\"\n  shows \"iarray_to_vec (vec_to_iarray A)=A\"", "lemma vec_to_iarray_iarray_to_vec:\n  assumes length_eq: \"IArray.length A = CARD('n::{mod_type})\"\n  shows \"vec_to_iarray (iarray_to_vec A::'a^'n::{mod_type}) = A\"", "lemma length_vec_to_iarray:\n  fixes xa::\"'a^'n::{mod_type}\"\n  shows \"IArray.length (vec_to_iarray xa) = CARD('n)\"", "lemma matrix_to_iarray_morph:\n  fixes A::\"'a^'n::{mod_type}^'m::{mod_type}\"\n  shows \"(A = B) = (matrix_to_iarray A = matrix_to_iarray B)\"", "lemma matrix_to_iarray_eq_of_fun:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes vec_eq_f: \"\\<forall>i. vec_to_iarray (A $ i) = f (to_nat i)\"\n  and n_eq_length: \"n=IArray.length (matrix_to_iarray A)\"\n  shows \"matrix_to_iarray A = IArray.of_fun f n\"", "lemma map_vec_to_iarray_rw[simp]: \n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"map (\\<lambda>x. vec_to_iarray (A $ from_nat x)) [0..<CARD('rows)] ! to_nat i = vec_to_iarray (A $ i)\"", "lemma matrix_to_iarray_nth:\n  \"matrix_to_iarray A !! to_nat i !! to_nat j = A $ i $ j\"", "lemma vec_matrix: \"vec_to_iarray (A$i) = (matrix_to_iarray A) !! (to_nat i)\"", "lemma iarray_to_matrix_matrix_to_iarray:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"iarray_to_matrix (matrix_to_iarray A) = A\"", "lemma is_zero_iarray_eq_iff:\n  fixes A::\"'a::{zero}^'n::{mod_type}\"\n  shows \"(A = 0) = (is_zero_iarray (vec_to_iarray A))\"", "lemma mult_iarray_works:\n  assumes \"a<IArray.length A\" shows \"mult_iarray A q !! a = q * A!!a\"", "lemma length_eq_card_rows:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"IArray.length (matrix_to_iarray A) = CARD('rows)\"", "lemma nrows_eq_card_rows:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"nrows_iarray (matrix_to_iarray A) = CARD('rows)\"", "lemma length_eq_card_columns:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"IArray.length (matrix_to_iarray A !! 0) = CARD ('columns)\"", "lemma ncols_eq_card_columns:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"ncols_iarray (matrix_to_iarray A) = CARD('columns)\"", "lemma matrix_to_iarray_nrows:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"nrows A = nrows_iarray (matrix_to_iarray A)\"", "lemma matrix_to_iarray_ncols:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"ncols A = ncols_iarray (matrix_to_iarray A)\"", "lemma vec_to_iarray_row[code_unfold]: \"vec_to_iarray (row i A) = row_iarray (to_nat i) (matrix_to_iarray A)\"", "lemma vec_to_iarray_row': \"vec_to_iarray (row i A) = (matrix_to_iarray A) !! (to_nat i)\"", "lemma vec_to_iarray_column[code_unfold]: \"vec_to_iarray (column i A) = column_iarray (to_nat i) (matrix_to_iarray A)\"", "lemma vec_to_iarray_column':\n  assumes k: \"k<ncols A\"\n  shows \"(vec_to_iarray (column (from_nat k) A)) = (column_iarray k (matrix_to_iarray A))\"", "lemma column_iarray_nth:\n  assumes i: \"i<nrows_iarray A\"\n  shows \"column_iarray j A !! i = A !! i !! j\"", "lemma vec_to_iarray_rows: \"vec_to_iarray` (rows A) = rows_iarray (matrix_to_iarray A)\"", "lemma vec_to_iarray_columns: \"vec_to_iarray` (columns A) = columns_iarray (matrix_to_iarray A)\"", "lemma vec_to_iarray_plus[code_unfold]: \"vec_to_iarray (a + b) =  (vec_to_iarray a) + (vec_to_iarray b)\"", "lemma matrix_to_iarray_plus[code_unfold]: \"matrix_to_iarray (A + B) = (matrix_to_iarray A) + (matrix_to_iarray B)\"", "lemma matrix_to_iarray_mat[code_unfold]:\n  \"matrix_to_iarray (mat k ::'a::{zero}^'n::{mod_type}^'n::{mod_type}) = mat_iarray k CARD('n::{mod_type})\"", "lemma matrix_to_iarray_transpose[code_unfold]:\n  shows \"matrix_to_iarray (transpose A) = transpose_iarray (matrix_to_iarray A)\"", "lemma matrix_to_iarray_matrix_matrix_mult[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'m::{mod_type}^'n::{mod_type}\" and B::\"'a^'b::{mod_type}^'m::{mod_type}\"\n  shows \"matrix_to_iarray (A ** B) = (matrix_to_iarray A) **i (matrix_to_iarray B)\"", "lemma vec_to_iarray_matrix_matrix_mult[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'m::{mod_type}^'n::{mod_type}\" and x::\"'a^'m::{mod_type}\"\n  shows \"vec_to_iarray (A *v x) = (matrix_to_iarray A) *iv (vec_to_iarray x)\"", "lemma vec_to_iarray_vector_matrix_mult[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'m::{mod_type}^'n::{mod_type}\" and x::\"'a^'n::{mod_type}\"\n  shows \"vec_to_iarray (x v* A) = (vec_to_iarray x) v*i (matrix_to_iarray A)\"", "lemma matrix_to_iarray_interchange_rows[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (interchange_rows A i j) = interchange_rows_iarray (matrix_to_iarray A) (to_nat i) (to_nat j)\"", "lemma matrix_to_iarray_mult_row[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (mult_row A i q) = mult_row_iarray (matrix_to_iarray A) (to_nat i) q\"", "lemma matrix_to_iarray_row_add[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (row_add A i j q) = row_add_iarray (matrix_to_iarray A) (to_nat i) (to_nat j) q\"", "lemma matrix_to_iarray_interchange_columns[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (interchange_columns A i j) = interchange_columns_iarray (matrix_to_iarray A) (to_nat i) (to_nat j)\"", "lemma matrix_to_iarray_mult_columns[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (mult_column A i q) = mult_column_iarray (matrix_to_iarray A) (to_nat i) q\"", "lemma matrix_to_iarray_column_add[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (column_add A i j q) = column_add_iarray (matrix_to_iarray A) (to_nat i) (to_nat j) q\""], "translations": [["", "lemma vec_to_iarray_nth:\n  fixes A::\"'a^'n::{finite, mod_type}\"\n  assumes i: \"i<CARD('n)\"\n  shows \"(vec_to_iarray A) !! i = A $ (from_nat i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray A !! i = A $ mod_type_class.from_nat i", "unfolding vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i) CARD('n) !!\n    i =\n    A $ mod_type_class.from_nat i", "using of_fun_nth[OF i]"], ["proof (prove)\nusing this:\n  IArray.of_fun ?f CARD('n) !! i = ?f i\n\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i) CARD('n) !!\n    i =\n    A $ mod_type_class.from_nat i", "."], ["", "lemma vec_to_iarray_nth':\n  fixes A::\"'a^'n::{mod_type}\"\n  shows \"(vec_to_iarray A) !! (to_nat i) = A $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray A !! mod_type_class.to_nat i = A $ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_to_iarray A !! mod_type_class.to_nat i = A $ i", "have to_nat_less_card: \"to_nat i<CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('n)", "using bij_to_nat[where ?'a='n]"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('n)", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('n)", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < CARD('n)\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !! mod_type_class.to_nat i = A $ i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray A !! mod_type_class.to_nat i = A $ i", "unfolding vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i) CARD('n) !!\n    mod_type_class.to_nat i =\n    A $ i", "unfolding of_fun_nth[OF to_nat_less_card] from_nat_to_nat_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i = A $ i", ".."], ["proof (state)\nthis:\n  vec_to_iarray A !! mod_type_class.to_nat i = A $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iarray_to_vec_nth:\n  shows \"(iarray_to_vec A) $ i = A !! (to_nat i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iarray_to_vec A $ i = A !! mod_type_class.to_nat i", "unfolding iarray_to_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. A !! mod_type_class.to_nat i) $ i =\n    A !! mod_type_class.to_nat i", "by simp"], ["", "lemma vec_to_iarray_morph:\n  fixes A::\"'a^'n::{mod_type}\"\n  shows \"(A = B) = (vec_to_iarray A = vec_to_iarray B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A = B) = (vec_to_iarray A = vec_to_iarray B)", "by (metis vec_eq_iff vec_to_iarray_nth')"], ["", "lemma inj_vec_to_iarray:\n  shows \"inj vec_to_iarray\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj vec_to_iarray", "using vec_to_iarray_morph"], ["proof (prove)\nusing this:\n  (?A = ?B) = (vec_to_iarray ?A = vec_to_iarray ?B)\n\ngoal (1 subgoal):\n 1. inj vec_to_iarray", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  (?A = ?B) = (vec_to_iarray ?A = vec_to_iarray ?B)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          vec_to_iarray x = vec_to_iarray y \\<longrightarrow> x = y", "by blast"], ["", "lemma iarray_to_vec_vec_to_iarray:\n  fixes A::\"'a^'n::{mod_type}\"\n  shows \"iarray_to_vec (vec_to_iarray A)=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iarray_to_vec (vec_to_iarray A) = A", "proof (unfold vec_to_iarray_def iarray_to_vec_def, vector, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       map (\\<lambda>i. A $ mod_type_class.from_nat i) [0..<CARD('n)] !\n       mod_type_class.to_nat i =\n       A $ i", "fix i::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       map (\\<lambda>i. A $ mod_type_class.from_nat i) [0..<CARD('n)] !\n       mod_type_class.to_nat i =\n       A $ i", "have \"to_nat i<CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('n)", "using bij_to_nat[where ?'a='n]"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('n)", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('n)", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       map (\\<lambda>i. A $ mod_type_class.from_nat i) [0..<CARD('n)] !\n       mod_type_class.to_nat i =\n       A $ i", "thus \"map (\\<lambda>i. A $ from_nat i) [0..<CARD('n)] ! to_nat i = A $ i\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < CARD('n)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. A $ mod_type_class.from_nat i) [0..<CARD('n)] !\n    mod_type_class.to_nat i =\n    A $ i", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>i. A $ mod_type_class.from_nat i) [0..<CARD('n)] !\n  mod_type_class.to_nat i =\n  A $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_to_iarray_iarray_to_vec:\n  assumes length_eq: \"IArray.length A = CARD('n::{mod_type})\"\n  shows \"vec_to_iarray (iarray_to_vec A::'a^'n::{mod_type}) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (iarray_to_vec A) = A", "proof (unfold vec_to_iarray_def iarray_to_vec_def, vector, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>i.\n              IArray.list_of A !\n              mod_type_class.to_nat (mod_type_class.from_nat i))\n       [0..<CARD('n)]) =\n    A", "obtain xs where xs: \"A = IArray xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. A = IArray xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis iarray.exhaust)"], ["proof (state)\nthis:\n  A = IArray xs\n\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>i.\n              IArray.list_of A !\n              mod_type_class.to_nat (mod_type_class.from_nat i))\n       [0..<CARD('n)]) =\n    A", "show \"IArray (map (\\<lambda>i. IArray.list_of A ! to_nat (from_nat i::'n)) [0..<CARD('n)]) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>i.\n              IArray.list_of A !\n              mod_type_class.to_nat (mod_type_class.from_nat i))\n       [0..<CARD('n)]) =\n    A", "proof(unfold xs iarray.inject list_eq_iff_nth_eq, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. CARD('n) = length xs\n 2. \\<And>i.\n       i < CARD('n) \\<Longrightarrow>\n       xs ! mod_type_class.to_nat (mod_type_class.from_nat i) = xs ! i", "show \"CARD('n) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('n) = length xs", "using length_eq"], ["proof (prove)\nusing this:\n  IArray.length A = CARD('n)\n\ngoal (1 subgoal):\n 1. CARD('n) = length xs", "unfolding xs"], ["proof (prove)\nusing this:\n  IArray.length (IArray xs) = CARD('n)\n\ngoal (1 subgoal):\n 1. CARD('n) = length xs", "by simp"], ["proof (state)\nthis:\n  CARD('n) = length xs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < CARD('n) \\<Longrightarrow>\n       xs ! mod_type_class.to_nat (mod_type_class.from_nat i) = xs ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < CARD('n) \\<Longrightarrow>\n       xs ! mod_type_class.to_nat (mod_type_class.from_nat i) = xs ! i", "assume i: \"i < CARD('n)\""], ["proof (state)\nthis:\n  i < CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < CARD('n) \\<Longrightarrow>\n       xs ! mod_type_class.to_nat (mod_type_class.from_nat i) = xs ! i", "show \"xs ! to_nat (from_nat i::'n) = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! mod_type_class.to_nat (mod_type_class.from_nat i) = xs ! i", "unfolding to_nat_from_nat_id[OF i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! i = xs ! i", ".."], ["proof (state)\nthis:\n  xs ! mod_type_class.to_nat (mod_type_class.from_nat i) = xs ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IArray\n   (map (\\<lambda>i.\n            IArray.list_of A !\n            mod_type_class.to_nat (mod_type_class.from_nat i))\n     [0..<CARD('n)]) =\n  A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_vec_to_iarray:\n  fixes xa::\"'a^'n::{mod_type}\"\n  shows \"IArray.length (vec_to_iarray xa) = CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (vec_to_iarray xa) = CARD('n)", "unfolding vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray.of_fun (\\<lambda>i. xa $ mod_type_class.from_nat i) CARD('n)) =\n    CARD('n)", "by simp"], ["", "subsubsection\\<open>Isomorphism between matrix and nested iarrays\\<close>"], ["", "definition matrix_to_iarray :: \"'a^'n::{mod_type}^'m::{mod_type} => 'a iarray iarray\"\n  where \"matrix_to_iarray A = IArray (map (vec_to_iarray \\<circ> (($) A) \\<circ> (from_nat::nat=>'m)) [0..<CARD('m)])\""], ["", "definition iarray_to_matrix :: \"'a iarray iarray \\<Rightarrow> 'a^'n::{mod_type}^'m::{mod_type}\"\n  where \"iarray_to_matrix A = (\\<chi> i j. A !! (to_nat i) !! (to_nat j))\""], ["", "lemma matrix_to_iarray_morph:\n  fixes A::\"'a^'n::{mod_type}^'m::{mod_type}\"\n  shows \"(A = B) = (matrix_to_iarray A = matrix_to_iarray B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A = B) = (matrix_to_iarray A = matrix_to_iarray B)", "unfolding matrix_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A = B) =\n    (IArray\n      (map (vec_to_iarray \\<circ> ($) A \\<circ> mod_type_class.from_nat)\n        [0..<CARD('m)]) =\n     IArray\n      (map (vec_to_iarray \\<circ> ($) B \\<circ> mod_type_class.from_nat)\n        [0..<CARD('m)]))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A = B) =\n    (\\<forall>x\\<in>{0..<CARD('m)}.\n        vec_to_iarray (A $ mod_type_class.from_nat x) =\n        vec_to_iarray (B $ mod_type_class.from_nat x))", "unfolding forall_from_nat_rw[of \"\\<lambda>x. vec_to_iarray (A $ x) = vec_to_iarray (B $ x)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A = B) =\n    (\\<forall>x.\n        vec_to_iarray (A $ mod_type_class.from_nat x) =\n        vec_to_iarray (B $ mod_type_class.from_nat x))", "by (metis from_nat_to_nat_id vec_eq_iff vec_to_iarray_morph)"], ["", "lemma matrix_to_iarray_eq_of_fun:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes vec_eq_f: \"\\<forall>i. vec_to_iarray (A $ i) = f (to_nat i)\"\n  and n_eq_length: \"n=IArray.length (matrix_to_iarray A)\"\n  shows \"matrix_to_iarray A = IArray.of_fun f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray A = IArray.of_fun f n", "proof (unfold IArray.of_fun_def matrix_to_iarray_def iarray.inject list_eq_iff_nth_eq, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. CARD('rows) = n\n 2. \\<And>i.\n       i < CARD('rows) \\<Longrightarrow>\n       vec_to_iarray (A $ mod_type_class.from_nat i) = map f [0..<n] ! i", "show *: \"CARD('rows) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) = n", "using n_eq_length"], ["proof (prove)\nusing this:\n  n = IArray.length (matrix_to_iarray A)\n\ngoal (1 subgoal):\n 1. CARD('rows) = n", "unfolding matrix_to_iarray_def"], ["proof (prove)\nusing this:\n  n =\n  IArray.length\n   (IArray\n     (map (vec_to_iarray \\<circ> ($) A \\<circ> mod_type_class.from_nat)\n       [0..<CARD('rows)]))\n\ngoal (1 subgoal):\n 1. CARD('rows) = n", "by auto"], ["proof (state)\nthis:\n  CARD('rows) = n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < CARD('rows) \\<Longrightarrow>\n       vec_to_iarray (A $ mod_type_class.from_nat i) = map f [0..<n] ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < CARD('rows) \\<Longrightarrow>\n       vec_to_iarray (A $ mod_type_class.from_nat i) = map f [0..<n] ! i", "assume i: \"i < CARD('rows)\""], ["proof (state)\nthis:\n  i < CARD('rows)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < CARD('rows) \\<Longrightarrow>\n       vec_to_iarray (A $ mod_type_class.from_nat i) = map f [0..<n] ! i", "hence i_less_n: \"i<n\""], ["proof (prove)\nusing this:\n  i < CARD('rows)\n\ngoal (1 subgoal):\n 1. i < n", "using * i"], ["proof (prove)\nusing this:\n  i < CARD('rows)\n  CARD('rows) = n\n  i < CARD('rows)\n\ngoal (1 subgoal):\n 1. i < n", "by simp"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < CARD('rows) \\<Longrightarrow>\n       vec_to_iarray (A $ mod_type_class.from_nat i) = map f [0..<n] ! i", "show \"vec_to_iarray (A $ from_nat i) = map f [0..<n] ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (A $ mod_type_class.from_nat i) = map f [0..<n] ! i", "using vec_eq_f"], ["proof (prove)\nusing this:\n  \\<forall>i. vec_to_iarray (A $ i) = f (mod_type_class.to_nat i)\n\ngoal (1 subgoal):\n 1. vec_to_iarray (A $ mod_type_class.from_nat i) = map f [0..<n] ! i", "using i_less_n"], ["proof (prove)\nusing this:\n  \\<forall>i. vec_to_iarray (A $ i) = f (mod_type_class.to_nat i)\n  i < n\n\ngoal (1 subgoal):\n 1. vec_to_iarray (A $ mod_type_class.from_nat i) = map f [0..<n] ! i", "by (simp, unfold to_nat_from_nat_id[OF i], simp)"], ["proof (state)\nthis:\n  vec_to_iarray (A $ mod_type_class.from_nat i) = map f [0..<n] ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_vec_to_iarray_rw[simp]: \n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"map (\\<lambda>x. vec_to_iarray (A $ from_nat x)) [0..<CARD('rows)] ! to_nat i = vec_to_iarray (A $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n     [0..<CARD('rows)] !\n    mod_type_class.to_nat i =\n    vec_to_iarray (A $ i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n     [0..<CARD('rows)] !\n    mod_type_class.to_nat i =\n    vec_to_iarray (A $ i)", "have i_less_card: \"to_nat i < CARD('rows)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('rows)", "using bij_to_nat[where ?'a='rows]"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('rows)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('rows)", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('rows)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('rows)", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < CARD('rows)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n     [0..<CARD('rows)] !\n    mod_type_class.to_nat i =\n    vec_to_iarray (A $ i)", "hence \"map (\\<lambda>x. vec_to_iarray (A $ from_nat x)) [0..<CARD('rows)] ! to_nat i \n    = vec_to_iarray (A $ from_nat (to_nat i))\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < CARD('rows)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n     [0..<CARD('rows)] !\n    mod_type_class.to_nat i =\n    vec_to_iarray (A $ mod_type_class.from_nat (mod_type_class.to_nat i))", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n   [0..<CARD('rows)] !\n  mod_type_class.to_nat i =\n  vec_to_iarray (A $ mod_type_class.from_nat (mod_type_class.to_nat i))\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n     [0..<CARD('rows)] !\n    mod_type_class.to_nat i =\n    vec_to_iarray (A $ i)", "also"], ["proof (state)\nthis:\n  map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n   [0..<CARD('rows)] !\n  mod_type_class.to_nat i =\n  vec_to_iarray (A $ mod_type_class.from_nat (mod_type_class.to_nat i))\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n     [0..<CARD('rows)] !\n    mod_type_class.to_nat i =\n    vec_to_iarray (A $ i)", "have \"... =  vec_to_iarray (A $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (A $ mod_type_class.from_nat (mod_type_class.to_nat i)) =\n    vec_to_iarray (A $ i)", "unfolding from_nat_to_nat_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (A $ i) = vec_to_iarray (A $ i)", ".."], ["proof (state)\nthis:\n  vec_to_iarray (A $ mod_type_class.from_nat (mod_type_class.to_nat i)) =\n  vec_to_iarray (A $ i)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n     [0..<CARD('rows)] !\n    mod_type_class.to_nat i =\n    vec_to_iarray (A $ i)", "finally"], ["proof (chain)\npicking this:\n  map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n   [0..<CARD('rows)] !\n  mod_type_class.to_nat i =\n  vec_to_iarray (A $ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n   [0..<CARD('rows)] !\n  mod_type_class.to_nat i =\n  vec_to_iarray (A $ i)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n     [0..<CARD('rows)] !\n    mod_type_class.to_nat i =\n    vec_to_iarray (A $ i)", "."], ["proof (state)\nthis:\n  map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n   [0..<CARD('rows)] !\n  mod_type_class.to_nat i =\n  vec_to_iarray (A $ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_nth:\n  \"matrix_to_iarray A !! to_nat i !! to_nat j = A $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray A !! mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    A $ i $ j", "unfolding matrix_to_iarray_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n       [0..<CARD('c)]) !!\n    mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    A $ i $ j", "using vec_to_iarray_nth'"], ["proof (prove)\nusing this:\n  vec_to_iarray ?A !! mod_type_class.to_nat ?i = ?A $ ?i\n\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n       [0..<CARD('c)]) !!\n    mod_type_class.to_nat i !!\n    mod_type_class.to_nat j =\n    A $ i $ j", "by auto"], ["", "lemma vec_matrix: \"vec_to_iarray (A$i) = (matrix_to_iarray A) !! (to_nat i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (A $ i) = matrix_to_iarray A !! mod_type_class.to_nat i", "unfolding matrix_to_iarray_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (A $ i) =\n    IArray\n     (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n       [0..<CARD('c)]) !!\n    mod_type_class.to_nat i", "by fastforce"], ["", "lemma iarray_to_matrix_matrix_to_iarray:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"iarray_to_matrix (matrix_to_iarray A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iarray_to_matrix (matrix_to_iarray A) = A", "unfolding matrix_to_iarray_def iarray_to_matrix_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j.\n        IArray\n         (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n           [0..<CARD('rows)]) !!\n        mod_type_class.to_nat i !!\n        mod_type_class.to_nat j) =\n    A", "by (vector, auto, metis IArray.sub_def vec_to_iarray_nth')"], ["", "subsection\\<open>Definition of operations over matrices implemented by iarrays\\<close>"], ["", "definition mult_iarray :: \"'a::{times} iarray => 'a => 'a iarray\"\n  where \"mult_iarray A q = IArray.of_fun (\\<lambda>n. q * A!!n) (IArray.length A)\""], ["", "definition row_iarray :: \"nat => 'a iarray iarray => 'a iarray\"\n  where \"row_iarray k A = A !! k\""], ["", "definition column_iarray :: \"nat => 'a iarray iarray  => 'a iarray\"\n  where \"column_iarray k A = IArray.of_fun (\\<lambda>m. A !! m !! k) (IArray.length A)\""], ["", "definition nrows_iarray :: \"'a iarray iarray => nat\"\n  where \"nrows_iarray A = IArray.length A\""], ["", "definition ncols_iarray :: \"'a iarray iarray => nat\"\n  where \"ncols_iarray A = IArray.length (A!!0)\""], ["", "definition \"rows_iarray A = {row_iarray i A | i. i \\<in> {..<nrows_iarray A}}\""], ["", "definition \"columns_iarray A = {column_iarray i A | i. i \\<in> {..<ncols_iarray A}}\""], ["", "definition tabulate2 :: \"nat => nat => (nat => nat => 'a) => 'a iarray iarray\"\n  where \"tabulate2 m n f = IArray.of_fun (\\<lambda>i. IArray.of_fun (f i) n) m\""], ["", "definition transpose_iarray :: \"'a iarray iarray => 'a iarray iarray\"\n  where \"transpose_iarray A =  tabulate2 (ncols_iarray A) (nrows_iarray A) (\\<lambda>a b. A!!b!!a)\""], ["", "definition matrix_matrix_mult_iarray :: \"'a::{times, comm_monoid_add} iarray iarray => 'a iarray iarray => 'a iarray iarray\"  (infixl \"**i\" 70)\n  where \"A **i B = tabulate2 (nrows_iarray A) (ncols_iarray B) (\\<lambda>i j. sum (\\<lambda>k. ((A!!i)!!k) * ((B!!k)!!j)) {0..<ncols_iarray A})\""], ["", "definition matrix_vector_mult_iarray :: \"'a::{semiring_1} iarray iarray => 'a iarray => 'a iarray\" (infixl \"*iv\" 70)\n  where \"A *iv x = IArray.of_fun (\\<lambda>i. sum (\\<lambda>j. ((A!!i)!!j) * (x!!j)) {0..<IArray.length x}) (nrows_iarray A)\""], ["", "definition vector_matrix_mult_iarray :: \"'a::{semiring_1} iarray => 'a iarray iarray => 'a iarray\" (infixl \"v*i\" 70)\n  where \"x v*i A = IArray.of_fun (\\<lambda>j. sum (\\<lambda>i. ((A!!i)!!j) * (x!!i)) {0..<IArray.length x}) (ncols_iarray A)\""], ["", "definition mat_iarray :: \"'a::{zero} => nat => 'a iarray iarray\"\n  where \"mat_iarray k n = tabulate2 n n (\\<lambda> i j. if i = j then k else 0)\""], ["", "definition is_zero_iarray :: \"'a::{zero} iarray \\<Rightarrow> bool\"\n  where \"is_zero_iarray A = IArray_Addenda_QR.all (\\<lambda>i. A !! i = 0) (IArray[0..<IArray.length A])\""], ["", "subsubsection\\<open>Properties of previous definitions\\<close>"], ["", "lemma is_zero_iarray_eq_iff:\n  fixes A::\"'a::{zero}^'n::{mod_type}\"\n  shows \"(A = 0) = (is_zero_iarray (vec_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A = 0) = is_zero_iarray (vec_to_iarray A)", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow> is_zero_iarray (vec_to_iarray 0)\n 2. is_zero_iarray (vec_to_iarray A) \\<Longrightarrow> A = 0", "show \"is_zero_iarray (vec_to_iarray 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_iarray (vec_to_iarray 0)", "by (simp add: vec_to_iarray_def is_zero_iarray_def Option.is_none_def find_None_iff)"], ["proof (state)\nthis:\n  is_zero_iarray (vec_to_iarray 0)\n\ngoal (1 subgoal):\n 1. is_zero_iarray (vec_to_iarray A) \\<Longrightarrow> A = 0", "show \"is_zero_iarray (vec_to_iarray A) \\<Longrightarrow> A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_iarray (vec_to_iarray A) \\<Longrightarrow> A = 0", "proof (simp add: vec_to_iarray_def is_zero_iarray_def Option.is_none_def find_None_iff vec_eq_iff, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<forall>i\\<in>{0..<CARD('n)}.\n          A $ mod_type_class.from_nat i = (0::'a) \\<Longrightarrow>\n       A $ i = (0::'a)", "fix i::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<forall>i\\<in>{0..<CARD('n)}.\n          A $ mod_type_class.from_nat i = (0::'a) \\<Longrightarrow>\n       A $ i = (0::'a)", "assume \"\\<forall>i\\<in>{0..<CARD('n)}. A $ mod_type_class.from_nat i = 0\""], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..<CARD('n)}. A $ mod_type_class.from_nat i = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<forall>i\\<in>{0..<CARD('n)}.\n          A $ mod_type_class.from_nat i = (0::'a) \\<Longrightarrow>\n       A $ i = (0::'a)", "hence eq_zero: \"\\<forall>x<CARD('n). A $ from_nat x = 0\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{0..<CARD('n)}. A $ mod_type_class.from_nat i = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x<CARD('n). A $ mod_type_class.from_nat x = (0::'a)", "by force"], ["proof (state)\nthis:\n  \\<forall>x<CARD('n). A $ mod_type_class.from_nat x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<forall>i\\<in>{0..<CARD('n)}.\n          A $ mod_type_class.from_nat i = (0::'a) \\<Longrightarrow>\n       A $ i = (0::'a)", "have \"to_nat i<CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('n)", "using bij_to_nat[where ?'a='n]"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('n)", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('n)", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<forall>i\\<in>{0..<CARD('n)}.\n          A $ mod_type_class.from_nat i = (0::'a) \\<Longrightarrow>\n       A $ i = (0::'a)", "hence \"A $ (from_nat (to_nat i)) = 0\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < CARD('n)\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat (mod_type_class.to_nat i) = (0::'a)", "using eq_zero"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < CARD('n)\n  \\<forall>x<CARD('n). A $ mod_type_class.from_nat x = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat (mod_type_class.to_nat i) = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat (mod_type_class.to_nat i) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<forall>i\\<in>{0..<CARD('n)}.\n          A $ mod_type_class.from_nat i = (0::'a) \\<Longrightarrow>\n       A $ i = (0::'a)", "thus \"A $ i = 0\""], ["proof (prove)\nusing this:\n  A $ mod_type_class.from_nat (mod_type_class.to_nat i) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i = (0::'a)", "unfolding from_nat_to_nat_id"], ["proof (prove)\nusing this:\n  A $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i = (0::'a)", "."], ["proof (state)\nthis:\n  A $ i = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_iarray (vec_to_iarray A) \\<Longrightarrow> A = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_iarray_works:\n  assumes \"a<IArray.length A\" shows \"mult_iarray A q !! a = q * A!!a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_iarray A q !! a = q * A !! a", "unfolding mult_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>n. q * A !! n) (IArray.length A) !! a =\n    q * A !! a", "unfolding IArray.of_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray (map (\\<lambda>n. q * A !! n) [0..<IArray.length A]) !! a =\n    q * A !! a", "unfolding sub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray (map (\\<lambda>n. q * A !! n) [0..<IArray.length A]) !! a =\n    q * A !! a", "using assms"], ["proof (prove)\nusing this:\n  a < IArray.length A\n\ngoal (1 subgoal):\n 1. IArray (map (\\<lambda>n. q * A !! n) [0..<IArray.length A]) !! a =\n    q * A !! a", "by simp"], ["", "lemma length_eq_card_rows:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"IArray.length (matrix_to_iarray A) = CARD('rows)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (matrix_to_iarray A) = CARD('rows)", "unfolding matrix_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (vec_to_iarray \\<circ> ($) A \\<circ> mod_type_class.from_nat)\n         [0..<CARD('rows)])) =\n    CARD('rows)", "by auto"], ["", "lemma nrows_eq_card_rows:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"nrows_iarray (matrix_to_iarray A) = CARD('rows)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows_iarray (matrix_to_iarray A) = CARD('rows)", "unfolding nrows_iarray_def length_eq_card_rows"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) = CARD('rows)", ".."], ["", "lemma length_eq_card_columns:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"IArray.length (matrix_to_iarray A !! 0) = CARD ('columns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (matrix_to_iarray A !! 0) = CARD('columns)", "unfolding matrix_to_iarray_def o_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray\n       (map (\\<lambda>x.\n                IArray.of_fun\n                 (\\<lambda>i.\n                     A $ mod_type_class.from_nat x $\n                     mod_type_class.from_nat i)\n                 CARD('columns))\n         [0..<CARD('rows)]) !!\n      0) =\n    CARD('columns)", "by simp"], ["", "lemma ncols_eq_card_columns:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"ncols_iarray (matrix_to_iarray A) = CARD('columns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols_iarray (matrix_to_iarray A) = CARD('columns)", "unfolding ncols_iarray_def length_eq_card_columns"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('columns) = CARD('columns)", ".."], ["", "lemma matrix_to_iarray_nrows:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"nrows A = nrows_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A = nrows_iarray (matrix_to_iarray A)", "unfolding nrows_def nrows_eq_card_rows"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) = CARD('rows)", ".."], ["", "lemma matrix_to_iarray_ncols:\n  fixes A::\"'a^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"ncols A = ncols_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols A = ncols_iarray (matrix_to_iarray A)", "unfolding ncols_def ncols_eq_card_columns"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('columns) = CARD('columns)", ".."], ["", "lemma vec_to_iarray_row[code_unfold]: \"vec_to_iarray (row i A) = row_iarray (to_nat i) (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (row i A) =\n    row_iarray (mod_type_class.to_nat i) (matrix_to_iarray A)", "unfolding row_def row_iarray_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>ia. vec_lambda (($) (A $ i)) $ mod_type_class.from_nat ia)\n     CARD('b) =\n    matrix_to_iarray A !! mod_type_class.to_nat i", "by (auto, metis IArray.sub_def IArray.of_fun_def vec_matrix vec_to_iarray_def)"], ["", "lemma vec_to_iarray_row': \"vec_to_iarray (row i A) = (matrix_to_iarray A) !! (to_nat i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (row i A) = matrix_to_iarray A !! mod_type_class.to_nat i", "unfolding row_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>ia. vec_lambda (($) (A $ i)) $ mod_type_class.from_nat ia)\n     CARD('b) =\n    matrix_to_iarray A !! mod_type_class.to_nat i", "by (auto, metis IArray.sub_def IArray.of_fun_def vec_matrix vec_to_iarray_def)"], ["", "lemma vec_to_iarray_column[code_unfold]: \"vec_to_iarray (column i A) = column_iarray (to_nat i) (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (column i A) =\n    column_iarray (mod_type_class.to_nat i) (matrix_to_iarray A)", "unfolding column_def vec_to_iarray_def column_iarray_def length_eq_card_rows"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>ia. (\\<chi>ia. A $ ia $ i) $ mod_type_class.from_nat ia)\n     CARD('b) =\n    IArray.of_fun\n     (\\<lambda>m. matrix_to_iarray A !! m !! mod_type_class.to_nat i)\n     CARD('b)", "by (auto, metis IArray.sub_def from_nat_not_eq vec_matrix vec_to_iarray_nth')"], ["", "lemma vec_to_iarray_column':\n  assumes k: \"k<ncols A\"\n  shows \"(vec_to_iarray (column (from_nat k) A)) = (column_iarray k (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (column (mod_type_class.from_nat k) A) =\n    column_iarray k (matrix_to_iarray A)", "unfolding vec_to_iarray_column"], ["proof (prove)\ngoal (1 subgoal):\n 1. column_iarray (mod_type_class.to_nat (mod_type_class.from_nat k))\n     (matrix_to_iarray A) =\n    column_iarray k (matrix_to_iarray A)", "unfolding to_nat_from_nat_id[OF k[unfolded ncols_def]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. column_iarray k (matrix_to_iarray A) =\n    column_iarray k (matrix_to_iarray A)", ".."], ["", "lemma column_iarray_nth:\n  assumes i: \"i<nrows_iarray A\"\n  shows \"column_iarray j A !! i = A !! i !! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column_iarray j A !! i = A !! i !! j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. column_iarray j A !! i = A !! i !! j", "have \"column_iarray j A !! i = map (\\<lambda>m. A !! m !! j) [0..<IArray.length A] ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column_iarray j A !! i =\n    map (\\<lambda>m. A !! m !! j) [0..<IArray.length A] ! i", "unfolding column_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>m. A !! m !! j) (IArray.length A) !! i =\n    map (\\<lambda>m. A !! m !! j) [0..<IArray.length A] ! i", "by auto"], ["proof (state)\nthis:\n  column_iarray j A !! i =\n  map (\\<lambda>m. A !! m !! j) [0..<IArray.length A] ! i\n\ngoal (1 subgoal):\n 1. column_iarray j A !! i = A !! i !! j", "also"], ["proof (state)\nthis:\n  column_iarray j A !! i =\n  map (\\<lambda>m. A !! m !! j) [0..<IArray.length A] ! i\n\ngoal (1 subgoal):\n 1. column_iarray j A !! i = A !! i !! j", "have \"... = (\\<lambda>m. A !! m !! j) ([0..<IArray.length A] ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>m. A !! m !! j) [0..<IArray.length A] ! i =\n    A !! ([0..<IArray.length A] ! i) !! j", "using i nth_map"], ["proof (prove)\nusing this:\n  i < nrows_iarray A\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>m. A !! m !! j) [0..<IArray.length A] ! i =\n    A !! ([0..<IArray.length A] ! i) !! j", "unfolding nrows_iarray_def"], ["proof (prove)\nusing this:\n  i < IArray.length A\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>m. A !! m !! j) [0..<IArray.length A] ! i =\n    A !! ([0..<IArray.length A] ! i) !! j", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>m. A !! m !! j) [0..<IArray.length A] ! i =\n  A !! ([0..<IArray.length A] ! i) !! j\n\ngoal (1 subgoal):\n 1. column_iarray j A !! i = A !! i !! j", "also"], ["proof (state)\nthis:\n  map (\\<lambda>m. A !! m !! j) [0..<IArray.length A] ! i =\n  A !! ([0..<IArray.length A] ! i) !! j\n\ngoal (1 subgoal):\n 1. column_iarray j A !! i = A !! i !! j", "have \"... = (\\<lambda>m. A !! m !! j) (i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A !! ([0..<IArray.length A] ! i) !! j = A !! i !! j", "using nth_upt[of 0 i \"IArray.length A\"] i"], ["proof (prove)\nusing this:\n  0 + i < IArray.length A \\<Longrightarrow>\n  [0..<IArray.length A] ! i = 0 + i\n  i < nrows_iarray A\n\ngoal (1 subgoal):\n 1. A !! ([0..<IArray.length A] ! i) !! j = A !! i !! j", "unfolding nrows_iarray_def"], ["proof (prove)\nusing this:\n  0 + i < IArray.length A \\<Longrightarrow>\n  [0..<IArray.length A] ! i = 0 + i\n  i < IArray.length A\n\ngoal (1 subgoal):\n 1. A !! ([0..<IArray.length A] ! i) !! j = A !! i !! j", "by simp"], ["proof (state)\nthis:\n  A !! ([0..<IArray.length A] ! i) !! j = A !! i !! j\n\ngoal (1 subgoal):\n 1. column_iarray j A !! i = A !! i !! j", "finally"], ["proof (chain)\npicking this:\n  column_iarray j A !! i = A !! i !! j", "show ?thesis"], ["proof (prove)\nusing this:\n  column_iarray j A !! i = A !! i !! j\n\ngoal (1 subgoal):\n 1. column_iarray j A !! i = A !! i !! j", "."], ["proof (state)\nthis:\n  column_iarray j A !! i = A !! i !! j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_to_iarray_rows: \"vec_to_iarray` (rows A) = rows_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray ` rows A = rows_iarray (matrix_to_iarray A)", "unfolding rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray ` {row i A |i. i \\<in> UNIV} =\n    rows_iarray (matrix_to_iarray A)", "unfolding rows_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray ` {row i A |i. i \\<in> UNIV} =\n    {row_iarray i (matrix_to_iarray A) |i.\n     i \\<in> {..<nrows_iarray (matrix_to_iarray A)}}", "apply (auto simp add: vec_to_iarray_row to_nat_less_card nrows_eq_card_rows)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < CARD('c) \\<Longrightarrow>\n       row_iarray i (matrix_to_iarray A)\n       \\<in> vec_to_iarray ` {uu_. \\<exists>i. uu_ = row i A}", "by (unfold image_def, auto, metis from_nat_not_eq vec_to_iarray_row)"], ["", "lemma vec_to_iarray_columns: \"vec_to_iarray` (columns A) = columns_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray ` columns A = columns_iarray (matrix_to_iarray A)", "unfolding columns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray ` {column i A |i. i \\<in> UNIV} =\n    columns_iarray (matrix_to_iarray A)", "unfolding columns_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray ` {column i A |i. i \\<in> UNIV} =\n    {column_iarray i (matrix_to_iarray A) |i.\n     i \\<in> {..<ncols_iarray (matrix_to_iarray A)}}", "apply(auto simp add: ncols_eq_card_columns to_nat_less_card vec_to_iarray_column)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < CARD('c) \\<Longrightarrow>\n       column_iarray i (matrix_to_iarray A)\n       \\<in> vec_to_iarray ` {uu_. \\<exists>i. uu_ = column i A}", "by (unfold image_def, auto, metis from_nat_not_eq vec_to_iarray_column)"], ["", "subsection\\<open>Definition of elementary operations\\<close>"], ["", "definition interchange_rows_iarray :: \"'a iarray iarray => nat => nat => 'a iarray iarray\"\n  where \"interchange_rows_iarray A a b = IArray.of_fun (\\<lambda>n. if n=a then A!!b else if n=b then A!!a else A!!n) (IArray.length A)\""], ["", "definition mult_row_iarray :: \"'a::{times} iarray iarray => nat => 'a => 'a iarray iarray\"\n  where \"mult_row_iarray A a q = IArray.of_fun (\\<lambda>n. if n=a then mult_iarray (A!!a) q else A!!n) (IArray.length A)\""], ["", "definition row_add_iarray :: \"'a::{plus, times,zero} iarray iarray => nat => nat => 'a => 'a iarray iarray\"\n  where \"row_add_iarray A a b q = IArray.of_fun (\\<lambda>n. if n=a then A!!a + mult_iarray (A!!b) q else A!!n) (IArray.length A)\""], ["", "definition interchange_columns_iarray :: \"'a iarray iarray => nat => nat => 'a iarray iarray\"\n  where \"interchange_columns_iarray A a b =  tabulate2 (nrows_iarray A) (ncols_iarray A) (\\<lambda>i j. if j = a then A !! i !! b else if j = b then A !! i !! a else A !! i !! j)\""], ["", "definition mult_column_iarray :: \"'a::{times} iarray iarray => nat => 'a => 'a iarray iarray\"\n  where \"mult_column_iarray A n q = tabulate2 (nrows_iarray A) (ncols_iarray A) (\\<lambda>i j. if j = n then A !! i !! j * q else A !! i !! j)\""], ["", "definition column_add_iarray :: \"'a::{plus, times} iarray iarray => nat => nat => 'a => 'a iarray iarray\"\n  where \"column_add_iarray A n m q = tabulate2 (nrows_iarray A) (ncols_iarray A) (\\<lambda>i j. if j = n then A !! i !! n + A !! i !! m * q else A !! i !! j)\""], ["", "subsubsection\\<open>Code generator\\<close>"], ["", "lemma vec_to_iarray_plus[code_unfold]: \"vec_to_iarray (a + b) =  (vec_to_iarray a) + (vec_to_iarray b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (a + b) = vec_to_iarray a + vec_to_iarray b", "unfolding vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. (a + b) $ mod_type_class.from_nat i)\n     CARD('b) =\n    IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i) CARD('b) +\n    IArray.of_fun (\\<lambda>i. b $ mod_type_class.from_nat i) CARD('b)", "unfolding plus_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. (a + b) $ mod_type_class.from_nat i)\n     CARD('b) =\n    IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>aa.\n              if aa < IArray.length\n                       (IArray.of_fun\n                         (\\<lambda>i. a $ mod_type_class.from_nat i)\n                         CARD('b))\n              then IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i)\n                    CARD('b) !!\n                   aa\n              else (0::'a))\n          (max (IArray.length\n                 (IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i)\n                   CARD('b)))\n            (IArray.length\n              (IArray.of_fun (\\<lambda>i. b $ mod_type_class.from_nat i)\n                CARD('b)))) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>a.\n              if a < IArray.length\n                      (IArray.of_fun\n                        (\\<lambda>i. b $ mod_type_class.from_nat i)\n                        CARD('b))\n              then IArray.of_fun (\\<lambda>i. b $ mod_type_class.from_nat i)\n                    CARD('b) !!\n                   a\n              else (0::'a))\n          (max (IArray.length\n                 (IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i)\n                   CARD('b)))\n            (IArray.length\n              (IArray.of_fun (\\<lambda>i. b $ mod_type_class.from_nat i)\n                CARD('b)))) !!\n         aa)\n     (max (IArray.length\n            (IArray.of_fun (\\<lambda>i. a $ mod_type_class.from_nat i)\n              CARD('b)))\n       (IArray.length\n         (IArray.of_fun (\\<lambda>i. b $ mod_type_class.from_nat i)\n           CARD('b))))", "by auto"], ["", "lemma matrix_to_iarray_plus[code_unfold]: \"matrix_to_iarray (A + B) = (matrix_to_iarray A) + (matrix_to_iarray B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (A + B) = matrix_to_iarray A + matrix_to_iarray B", "unfolding matrix_to_iarray_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x. vec_to_iarray ((A + B) $ mod_type_class.from_nat x))\n       [0..<CARD('c)]) =\n    IArray\n     (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n       [0..<CARD('c)]) +\n    IArray\n     (map (\\<lambda>x. vec_to_iarray (B $ mod_type_class.from_nat x))\n       [0..<CARD('c)])", "by (simp add: plus_iarray_def Let_def vec_to_iarray_plus)"], ["", "lemma matrix_to_iarray_mat[code_unfold]:\n  \"matrix_to_iarray (mat k ::'a::{zero}^'n::{mod_type}^'n::{mod_type}) = mat_iarray k CARD('n::{mod_type})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (mat k) = mat_iarray k CARD('n)", "unfolding matrix_to_iarray_def o_def vec_to_iarray_def mat_def mat_iarray_def tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>i.\n                   (\\<chi>i j. if i = j then k else (0::'a)) $\n                   mod_type_class.from_nat x $\n                   mod_type_class.from_nat i)\n               CARD('n))\n       [0..<CARD('n)]) =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun (\\<lambda>j. if i = j then k else (0::'a)) CARD('n))\n     CARD('n)", "using from_nat_eq_imp_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>mod_type_class.from_nat ?x = mod_type_class.from_nat ?xa;\n   ?x < CARD(?'a); ?xa < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> ?x = ?xa\n\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>i.\n                   (\\<chi>i j. if i = j then k else (0::'a)) $\n                   mod_type_class.from_nat x $\n                   mod_type_class.from_nat i)\n               CARD('n))\n       [0..<CARD('n)]) =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun (\\<lambda>j. if i = j then k else (0::'a)) CARD('n))\n     CARD('n)", "by fastforce"], ["", "lemma matrix_to_iarray_transpose[code_unfold]:\n  shows \"matrix_to_iarray (transpose A) = transpose_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Finite_Cartesian_Product.transpose A) =\n    transpose_iarray (matrix_to_iarray A)", "unfolding matrix_to_iarray_def transpose_def transpose_iarray_def \n    o_def tabulate2_def nrows_iarray_def ncols_iarray_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>i.\n                   (\\<chi>i j. A $ j $ i) $ mod_type_class.from_nat x $\n                   mod_type_class.from_nat i)\n               CARD('b))\n       [0..<CARD('c)]) =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>b.\n              IArray\n               (map (\\<lambda>x.\n                        IArray.of_fun\n                         (\\<lambda>i.\n                             A $ mod_type_class.from_nat x $\n                             mod_type_class.from_nat i)\n                         CARD('c))\n                 [0..<CARD('b)]) !!\n              b !!\n              i)\n          (IArray.length\n            (IArray\n              (map (\\<lambda>x.\n                       IArray.of_fun\n                        (\\<lambda>i.\n                            A $ mod_type_class.from_nat x $\n                            mod_type_class.from_nat i)\n                        CARD('c))\n                [0..<CARD('b)]))))\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('c))\n           [0..<CARD('b)]) !!\n        0))", "by auto"], ["", "lemma matrix_to_iarray_matrix_matrix_mult[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'m::{mod_type}^'n::{mod_type}\" and B::\"'a^'b::{mod_type}^'m::{mod_type}\"\n  shows \"matrix_to_iarray (A ** B) = (matrix_to_iarray A) **i (matrix_to_iarray B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (A ** B) = matrix_to_iarray A **i matrix_to_iarray B", "unfolding matrix_to_iarray_def matrix_matrix_mult_iarray_def matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (vec_to_iarray \\<circ>\n           ($) (\\<chi>i j. \\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) \\<circ>\n           mod_type_class.from_nat)\n       [0..<CARD('n)]) =\n    tabulate2\n     (nrows_iarray\n       (IArray\n         (map (vec_to_iarray \\<circ> ($) A \\<circ> mod_type_class.from_nat)\n           [0..<CARD('n)])))\n     (ncols_iarray\n       (IArray\n         (map (vec_to_iarray \\<circ> ($) B \\<circ> mod_type_class.from_nat)\n           [0..<CARD('m)])))\n     (\\<lambda>i j.\n         \\<Sum>k = 0..<ncols_iarray\n                        (IArray\n                          (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                                mod_type_class.from_nat)\n                            [0..<CARD('n)])).\n            IArray\n             (map (vec_to_iarray \\<circ> ($) A \\<circ>\n                   mod_type_class.from_nat)\n               [0..<CARD('n)]) !!\n            i !!\n            k *\n            IArray\n             (map (vec_to_iarray \\<circ> ($) B \\<circ>\n                   mod_type_class.from_nat)\n               [0..<CARD('m)]) !!\n            k !!\n            j)", "unfolding o_def tabulate2_def nrows_iarray_def ncols_iarray_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>i.\n                   (\\<chi>i j. \\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) $\n                   mod_type_class.from_nat x $\n                   mod_type_class.from_nat i)\n               CARD('b))\n       [0..<CARD('n)]) =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>j.\n              \\<Sum>k = 0..<IArray.length\n                             (IArray\n                               (map (\\<lambda>x.\n  IArray.of_fun\n   (\\<lambda>i. A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n   CARD('m))\n                                 [0..<CARD('n)]) !!\n                              0).\n                 IArray\n                  (map (\\<lambda>x.\n                           IArray.of_fun\n                            (\\<lambda>i.\n                                A $ mod_type_class.from_nat x $\n                                mod_type_class.from_nat i)\n                            CARD('m))\n                    [0..<CARD('n)]) !!\n                 i !!\n                 k *\n                 IArray\n                  (map (\\<lambda>x.\n                           IArray.of_fun\n                            (\\<lambda>i.\n                                B $ mod_type_class.from_nat x $\n                                mod_type_class.from_nat i)\n                            CARD('b))\n                    [0..<CARD('m)]) !!\n                 k !!\n                 j)\n          (IArray.length\n            (IArray\n              (map (\\<lambda>x.\n                       IArray.of_fun\n                        (\\<lambda>i.\n                            B $ mod_type_class.from_nat x $\n                            mod_type_class.from_nat i)\n                        CARD('b))\n                [0..<CARD('m)]) !!\n             0)))\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('m))\n           [0..<CARD('n)])))", "using sum.reindex_cong[of \"from_nat::nat=>'m\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on mod_type_class.from_nat ?B;\n   ?A = mod_type_class.from_nat ` ?B;\n   \\<And>x.\n      x \\<in> ?B \\<Longrightarrow>\n      ?g (mod_type_class.from_nat x) = ?h x\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?h ?B\n\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>i.\n                   (\\<chi>i j. \\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) $\n                   mod_type_class.from_nat x $\n                   mod_type_class.from_nat i)\n               CARD('b))\n       [0..<CARD('n)]) =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>j.\n              \\<Sum>k = 0..<IArray.length\n                             (IArray\n                               (map (\\<lambda>x.\n  IArray.of_fun\n   (\\<lambda>i. A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n   CARD('m))\n                                 [0..<CARD('n)]) !!\n                              0).\n                 IArray\n                  (map (\\<lambda>x.\n                           IArray.of_fun\n                            (\\<lambda>i.\n                                A $ mod_type_class.from_nat x $\n                                mod_type_class.from_nat i)\n                            CARD('m))\n                    [0..<CARD('n)]) !!\n                 i !!\n                 k *\n                 IArray\n                  (map (\\<lambda>x.\n                           IArray.of_fun\n                            (\\<lambda>i.\n                                B $ mod_type_class.from_nat x $\n                                mod_type_class.from_nat i)\n                            CARD('b))\n                    [0..<CARD('m)]) !!\n                 k !!\n                 j)\n          (IArray.length\n            (IArray\n              (map (\\<lambda>x.\n                       IArray.of_fun\n                        (\\<lambda>i.\n                            B $ mod_type_class.from_nat x $\n                            mod_type_class.from_nat i)\n                        CARD('b))\n                [0..<CARD('m)]) !!\n             0)))\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('m))\n           [0..<CARD('n)])))", "using bij_from_nat"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on mod_type_class.from_nat ?B;\n   ?A = mod_type_class.from_nat ` ?B;\n   \\<And>x.\n      x \\<in> ?B \\<Longrightarrow>\n      ?g (mod_type_class.from_nat x) = ?h x\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?h ?B\n  bij_betw mod_type_class.from_nat {0..<CARD(?'a)} UNIV\n\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>i.\n                   (\\<chi>i j. \\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) $\n                   mod_type_class.from_nat x $\n                   mod_type_class.from_nat i)\n               CARD('b))\n       [0..<CARD('n)]) =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>j.\n              \\<Sum>k = 0..<IArray.length\n                             (IArray\n                               (map (\\<lambda>x.\n  IArray.of_fun\n   (\\<lambda>i. A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n   CARD('m))\n                                 [0..<CARD('n)]) !!\n                              0).\n                 IArray\n                  (map (\\<lambda>x.\n                           IArray.of_fun\n                            (\\<lambda>i.\n                                A $ mod_type_class.from_nat x $\n                                mod_type_class.from_nat i)\n                            CARD('m))\n                    [0..<CARD('n)]) !!\n                 i !!\n                 k *\n                 IArray\n                  (map (\\<lambda>x.\n                           IArray.of_fun\n                            (\\<lambda>i.\n                                B $ mod_type_class.from_nat x $\n                                mod_type_class.from_nat i)\n                            CARD('b))\n                    [0..<CARD('m)]) !!\n                 k !!\n                 j)\n          (IArray.length\n            (IArray\n              (map (\\<lambda>x.\n                       IArray.of_fun\n                        (\\<lambda>i.\n                            B $ mod_type_class.from_nat x $\n                            mod_type_class.from_nat i)\n                        CARD('b))\n                [0..<CARD('m)]) !!\n             0)))\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('m))\n           [0..<CARD('n)])))", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on mod_type_class.from_nat ?B;\n   ?A = mod_type_class.from_nat ` ?B;\n   \\<And>x.\n      x \\<in> ?B \\<Longrightarrow>\n      ?g (mod_type_class.from_nat x) = ?h x\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?h ?B\n  inj_on mod_type_class.from_nat {0..<CARD(?'a)} \\<and>\n  mod_type_class.from_nat ` {0..<CARD(?'a)} = UNIV\n\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>i.\n                   (\\<chi>i j. \\<Sum>k\\<in>UNIV. A $ i $ k * B $ k $ j) $\n                   mod_type_class.from_nat x $\n                   mod_type_class.from_nat i)\n               CARD('b))\n       [0..<CARD('n)]) =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>j.\n              \\<Sum>k = 0..<IArray.length\n                             (IArray\n                               (map (\\<lambda>x.\n  IArray.of_fun\n   (\\<lambda>i. A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n   CARD('m))\n                                 [0..<CARD('n)]) !!\n                              0).\n                 IArray\n                  (map (\\<lambda>x.\n                           IArray.of_fun\n                            (\\<lambda>i.\n                                A $ mod_type_class.from_nat x $\n                                mod_type_class.from_nat i)\n                            CARD('m))\n                    [0..<CARD('n)]) !!\n                 i !!\n                 k *\n                 IArray\n                  (map (\\<lambda>x.\n                           IArray.of_fun\n                            (\\<lambda>i.\n                                B $ mod_type_class.from_nat x $\n                                mod_type_class.from_nat i)\n                            CARD('b))\n                    [0..<CARD('m)]) !!\n                 k !!\n                 j)\n          (IArray.length\n            (IArray\n              (map (\\<lambda>x.\n                       IArray.of_fun\n                        (\\<lambda>i.\n                            B $ mod_type_class.from_nat x $\n                            mod_type_class.from_nat i)\n                        CARD('b))\n                [0..<CARD('m)]) !!\n             0)))\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('m))\n           [0..<CARD('n)])))", "by fastforce"], ["", "lemma vec_to_iarray_matrix_matrix_mult[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'m::{mod_type}^'n::{mod_type}\" and x::\"'a^'m::{mod_type}\"\n  shows \"vec_to_iarray (A *v x) = (matrix_to_iarray A) *iv (vec_to_iarray x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (A *v x) = matrix_to_iarray A *iv vec_to_iarray x", "unfolding matrix_vector_mult_iarray_def matrix_vector_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (\\<chi>i. \\<Sum>j\\<in>UNIV. A $ i $ j * x $ j) =\n    IArray.of_fun\n     (\\<lambda>i.\n         \\<Sum>j = 0..<IArray.length (vec_to_iarray x).\n            matrix_to_iarray A !! i !! j * vec_to_iarray x !! j)\n     (nrows_iarray (matrix_to_iarray A))", "unfolding o_def tabulate2_def nrows_iarray_def ncols_iarray_def matrix_to_iarray_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         (\\<chi>i. \\<Sum>j\\<in>UNIV. A $ i $ j * x $ j) $\n         mod_type_class.from_nat i)\n     CARD('n) =\n    IArray.of_fun\n     (\\<lambda>i.\n         \\<Sum>j = 0..<IArray.length\n                        (IArray.of_fun\n                          (\\<lambda>i. x $ mod_type_class.from_nat i)\n                          CARD('m)).\n            IArray\n             (map (\\<lambda>x.\n                      IArray.of_fun\n                       (\\<lambda>i.\n                           A $ mod_type_class.from_nat x $\n                           mod_type_class.from_nat i)\n                       CARD('m))\n               [0..<CARD('n)]) !!\n            i !!\n            j *\n            IArray.of_fun (\\<lambda>i. x $ mod_type_class.from_nat i)\n             CARD('m) !!\n            j)\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('m))\n           [0..<CARD('n)])))", "using sum.reindex_cong[of \"from_nat::nat=>'m\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on mod_type_class.from_nat ?B;\n   ?A = mod_type_class.from_nat ` ?B;\n   \\<And>x.\n      x \\<in> ?B \\<Longrightarrow>\n      ?g (mod_type_class.from_nat x) = ?h x\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?h ?B\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         (\\<chi>i. \\<Sum>j\\<in>UNIV. A $ i $ j * x $ j) $\n         mod_type_class.from_nat i)\n     CARD('n) =\n    IArray.of_fun\n     (\\<lambda>i.\n         \\<Sum>j = 0..<IArray.length\n                        (IArray.of_fun\n                          (\\<lambda>i. x $ mod_type_class.from_nat i)\n                          CARD('m)).\n            IArray\n             (map (\\<lambda>x.\n                      IArray.of_fun\n                       (\\<lambda>i.\n                           A $ mod_type_class.from_nat x $\n                           mod_type_class.from_nat i)\n                       CARD('m))\n               [0..<CARD('n)]) !!\n            i !!\n            j *\n            IArray.of_fun (\\<lambda>i. x $ mod_type_class.from_nat i)\n             CARD('m) !!\n            j)\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('m))\n           [0..<CARD('n)])))", "using bij_from_nat"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on mod_type_class.from_nat ?B;\n   ?A = mod_type_class.from_nat ` ?B;\n   \\<And>x.\n      x \\<in> ?B \\<Longrightarrow>\n      ?g (mod_type_class.from_nat x) = ?h x\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?h ?B\n  bij_betw mod_type_class.from_nat {0..<CARD(?'a)} UNIV\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         (\\<chi>i. \\<Sum>j\\<in>UNIV. A $ i $ j * x $ j) $\n         mod_type_class.from_nat i)\n     CARD('n) =\n    IArray.of_fun\n     (\\<lambda>i.\n         \\<Sum>j = 0..<IArray.length\n                        (IArray.of_fun\n                          (\\<lambda>i. x $ mod_type_class.from_nat i)\n                          CARD('m)).\n            IArray\n             (map (\\<lambda>x.\n                      IArray.of_fun\n                       (\\<lambda>i.\n                           A $ mod_type_class.from_nat x $\n                           mod_type_class.from_nat i)\n                       CARD('m))\n               [0..<CARD('n)]) !!\n            i !!\n            j *\n            IArray.of_fun (\\<lambda>i. x $ mod_type_class.from_nat i)\n             CARD('m) !!\n            j)\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('m))\n           [0..<CARD('n)])))", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on mod_type_class.from_nat ?B;\n   ?A = mod_type_class.from_nat ` ?B;\n   \\<And>x.\n      x \\<in> ?B \\<Longrightarrow>\n      ?g (mod_type_class.from_nat x) = ?h x\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?h ?B\n  inj_on mod_type_class.from_nat {0..<CARD(?'a)} \\<and>\n  mod_type_class.from_nat ` {0..<CARD(?'a)} = UNIV\n\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         (\\<chi>i. \\<Sum>j\\<in>UNIV. A $ i $ j * x $ j) $\n         mod_type_class.from_nat i)\n     CARD('n) =\n    IArray.of_fun\n     (\\<lambda>i.\n         \\<Sum>j = 0..<IArray.length\n                        (IArray.of_fun\n                          (\\<lambda>i. x $ mod_type_class.from_nat i)\n                          CARD('m)).\n            IArray\n             (map (\\<lambda>x.\n                      IArray.of_fun\n                       (\\<lambda>i.\n                           A $ mod_type_class.from_nat x $\n                           mod_type_class.from_nat i)\n                       CARD('m))\n               [0..<CARD('n)]) !!\n            i !!\n            j *\n            IArray.of_fun (\\<lambda>i. x $ mod_type_class.from_nat i)\n             CARD('m) !!\n            j)\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('m))\n           [0..<CARD('n)])))", "by fastforce"], ["", "lemma vec_to_iarray_vector_matrix_mult[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'m::{mod_type}^'n::{mod_type}\" and x::\"'a^'n::{mod_type}\"\n  shows \"vec_to_iarray (x v* A) = (vec_to_iarray x) v*i (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (x v* A) = vec_to_iarray x v*i matrix_to_iarray A", "unfolding vector_matrix_mult_def vector_matrix_mult_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (\\<chi>j. \\<Sum>i\\<in>UNIV. A $ i $ j * x $ i) =\n    IArray.of_fun\n     (\\<lambda>j.\n         \\<Sum>i = 0..<IArray.length (vec_to_iarray x).\n            matrix_to_iarray A !! i !! j * vec_to_iarray x !! i)\n     (ncols_iarray (matrix_to_iarray A))", "unfolding o_def tabulate2_def nrows_iarray_def ncols_iarray_def matrix_to_iarray_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         (\\<chi>j. \\<Sum>i\\<in>UNIV. A $ i $ j * x $ i) $\n         mod_type_class.from_nat i)\n     CARD('m) =\n    IArray.of_fun\n     (\\<lambda>j.\n         \\<Sum>i = 0..<IArray.length\n                        (IArray.of_fun\n                          (\\<lambda>i. x $ mod_type_class.from_nat i)\n                          CARD('n)).\n            IArray\n             (map (\\<lambda>x.\n                      IArray.of_fun\n                       (\\<lambda>i.\n                           A $ mod_type_class.from_nat x $\n                           mod_type_class.from_nat i)\n                       CARD('m))\n               [0..<CARD('n)]) !!\n            i !!\n            j *\n            IArray.of_fun (\\<lambda>i. x $ mod_type_class.from_nat i)\n             CARD('n) !!\n            i)\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('m))\n           [0..<CARD('n)]) !!\n        0))", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa < CARD('m) \\<Longrightarrow>\n       (\\<Sum>i\\<in>UNIV. A $ i $ mod_type_class.from_nat xa * x $ i) =\n       (\\<Sum>i = 0..<CARD('n).\n           A $ mod_type_class.from_nat i $ mod_type_class.from_nat xa *\n           x $ mod_type_class.from_nat i)", "fix xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa < CARD('m) \\<Longrightarrow>\n       (\\<Sum>i\\<in>UNIV. A $ i $ mod_type_class.from_nat xa * x $ i) =\n       (\\<Sum>i = 0..<CARD('n).\n           A $ mod_type_class.from_nat i $ mod_type_class.from_nat xa *\n           x $ mod_type_class.from_nat i)", "show \"(\\<Sum>i\\<in>UNIV. A $ i $ from_nat xa * x $ i) = (\\<Sum>i = 0..<CARD('n). A $ from_nat i $ from_nat xa * x $ from_nat i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. A $ i $ mod_type_class.from_nat xa * x $ i) =\n    (\\<Sum>i = 0..<CARD('n).\n        A $ mod_type_class.from_nat i $ mod_type_class.from_nat xa *\n        x $ mod_type_class.from_nat i)", "apply (rule sum.reindex_cong[of \"from_nat::nat=>'n\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on mod_type_class.from_nat {0..<CARD('n)}\n 2. UNIV = mod_type_class.from_nat ` {0..<CARD('n)}\n 3. \\<And>xb.\n       xb \\<in> {0..<CARD('n)} \\<Longrightarrow>\n       A $ mod_type_class.from_nat xb $ mod_type_class.from_nat xa *\n       x $ mod_type_class.from_nat xb =\n       A $ mod_type_class.from_nat xb $ mod_type_class.from_nat xa *\n       x $ mod_type_class.from_nat xb", "using bij_from_nat[where ?'a='n]"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.from_nat {0..<CARD('n)} UNIV\n\ngoal (3 subgoals):\n 1. inj_on mod_type_class.from_nat {0..<CARD('n)}\n 2. UNIV = mod_type_class.from_nat ` {0..<CARD('n)}\n 3. \\<And>xb.\n       xb \\<in> {0..<CARD('n)} \\<Longrightarrow>\n       A $ mod_type_class.from_nat xb $ mod_type_class.from_nat xa *\n       x $ mod_type_class.from_nat xb =\n       A $ mod_type_class.from_nat xb $ mod_type_class.from_nat xa *\n       x $ mod_type_class.from_nat xb", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj_on mod_type_class.from_nat {0..<CARD('n)} \\<and>\n  mod_type_class.from_nat ` {0..<CARD('n)} = UNIV\n\ngoal (3 subgoals):\n 1. inj_on mod_type_class.from_nat {0..<CARD('n)}\n 2. UNIV = mod_type_class.from_nat ` {0..<CARD('n)}\n 3. \\<And>xb.\n       xb \\<in> {0..<CARD('n)} \\<Longrightarrow>\n       A $ mod_type_class.from_nat xb $ mod_type_class.from_nat xa *\n       x $ mod_type_class.from_nat xb =\n       A $ mod_type_class.from_nat xb $ mod_type_class.from_nat xa *\n       x $ mod_type_class.from_nat xb", "by fast+"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. A $ i $ mod_type_class.from_nat xa * x $ i) =\n  (\\<Sum>i = 0..<CARD('n).\n      A $ mod_type_class.from_nat i $ mod_type_class.from_nat xa *\n      x $ mod_type_class.from_nat i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_interchange_rows[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (interchange_rows A i j) = interchange_rows_iarray (matrix_to_iarray A) (to_nat i) (to_nat j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (interchange_rows A i j) =\n    interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (mod_type_class.to_nat j)", "proof (unfold matrix_to_iarray_def interchange_rows_iarray_def o_def map_vec_to_iarray_rw, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < CARD('rows); x \\<noteq> mod_type_class.to_nat j;\n        x \\<noteq> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> vec_to_iarray\n                          (interchange_rows A i j $\n                           mod_type_class.from_nat x) =\n                         vec_to_iarray (A $ mod_type_class.from_nat x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < CARD('rows); x \\<noteq> mod_type_class.to_nat j;\n        x \\<noteq> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> vec_to_iarray\n                          (interchange_rows A i j $\n                           mod_type_class.from_nat x) =\n                         vec_to_iarray (A $ mod_type_class.from_nat x)", "assume x_less_card: \"x < CARD('rows)\"\n    and x_not_j: \"x \\<noteq> to_nat j\" and x_not_i: \"x \\<noteq> to_nat i\""], ["proof (state)\nthis:\n  x < CARD('rows)\n  x \\<noteq> mod_type_class.to_nat j\n  x \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < CARD('rows); x \\<noteq> mod_type_class.to_nat j;\n        x \\<noteq> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> vec_to_iarray\n                          (interchange_rows A i j $\n                           mod_type_class.from_nat x) =\n                         vec_to_iarray (A $ mod_type_class.from_nat x)", "show \"vec_to_iarray (interchange_rows A i j $ from_nat x) = vec_to_iarray (A $ from_nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (interchange_rows A i j $ mod_type_class.from_nat x) =\n    vec_to_iarray (A $ mod_type_class.from_nat x)", "by (metis interchange_rows_preserves to_nat_from_nat_id x_less_card x_not_i x_not_j)"], ["proof (state)\nthis:\n  vec_to_iarray (interchange_rows A i j $ mod_type_class.from_nat x) =\n  vec_to_iarray (A $ mod_type_class.from_nat x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_mult_row[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (mult_row A i q) = mult_row_iarray (matrix_to_iarray A) (to_nat i) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (mult_row A i q) =\n    mult_row_iarray (matrix_to_iarray A) (mod_type_class.to_nat i) q", "unfolding matrix_to_iarray_def mult_row_iarray_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              vec_to_iarray (mult_row A i q $ mod_type_class.from_nat x))\n       [0..<CARD('rows)]) =\n    IArray.of_fun\n     (\\<lambda>n.\n         if n = mod_type_class.to_nat i\n         then mult_iarray\n               (IArray\n                 (map (\\<lambda>x.\n                          vec_to_iarray (A $ mod_type_class.from_nat x))\n                   [0..<CARD('rows)]) !!\n                mod_type_class.to_nat i)\n               q\n         else IArray\n               (map (\\<lambda>x.\n                        vec_to_iarray (A $ mod_type_class.from_nat x))\n                 [0..<CARD('rows)]) !!\n              n)\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x. vec_to_iarray (A $ mod_type_class.from_nat x))\n           [0..<CARD('rows)])))", "unfolding mult_iarray_def vec_to_iarray_def mult_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>ia.\n                   (\\<chi>ia j.\n                       if ia = i then q * A $ i $ j else A $ ia $ j) $\n                   mod_type_class.from_nat x $\n                   mod_type_class.from_nat ia)\n               CARD('columns))\n       [0..<CARD('rows)]) =\n    IArray.of_fun\n     (\\<lambda>n.\n         if n = mod_type_class.to_nat i\n         then IArray.of_fun\n               (\\<lambda>n.\n                   q *\n                   IArray\n                    (map (\\<lambda>x.\n                             IArray.of_fun\n                              (\\<lambda>i.\n                                  A $ mod_type_class.from_nat x $\n                                  mod_type_class.from_nat i)\n                              CARD('columns))\n                      [0..<CARD('rows)]) !!\n                   mod_type_class.to_nat i !!\n                   n)\n               (IArray.length\n                 (IArray\n                   (map (\\<lambda>x.\n                            IArray.of_fun\n                             (\\<lambda>i.\n                                 A $ mod_type_class.from_nat x $\n                                 mod_type_class.from_nat i)\n                             CARD('columns))\n                     [0..<CARD('rows)]) !!\n                  mod_type_class.to_nat i))\n         else IArray\n               (map (\\<lambda>x.\n                        IArray.of_fun\n                         (\\<lambda>i.\n                             A $ mod_type_class.from_nat x $\n                             mod_type_class.from_nat i)\n                         CARD('columns))\n                 [0..<CARD('rows)]) !!\n              n)\n     (IArray.length\n       (IArray\n         (map (\\<lambda>x.\n                  IArray.of_fun\n                   (\\<lambda>i.\n                       A $ mod_type_class.from_nat x $\n                       mod_type_class.from_nat i)\n                   CARD('columns))\n           [0..<CARD('rows)])))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('rows);\n        x \\<noteq> mod_type_class.to_nat (mod_type_class.from_nat x);\n        i = mod_type_class.from_nat x; xa < CARD('columns)\\<rbrakk>\n       \\<Longrightarrow> q *\n                         A $ mod_type_class.from_nat x $\n                         mod_type_class.from_nat xa =\n                         A $ mod_type_class.from_nat x $\n                         mod_type_class.from_nat xa", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('rows);\n        x \\<noteq> mod_type_class.to_nat (mod_type_class.from_nat x);\n        i = mod_type_class.from_nat x; xa < CARD('columns)\\<rbrakk>\n       \\<Longrightarrow> q *\n                         A $ mod_type_class.from_nat x $\n                         mod_type_class.from_nat xa =\n                         A $ mod_type_class.from_nat x $\n                         mod_type_class.from_nat xa", "fix i x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('rows);\n        x \\<noteq> mod_type_class.to_nat (mod_type_class.from_nat x);\n        i = mod_type_class.from_nat x; xa < CARD('columns)\\<rbrakk>\n       \\<Longrightarrow> q *\n                         A $ mod_type_class.from_nat x $\n                         mod_type_class.from_nat xa =\n                         A $ mod_type_class.from_nat x $\n                         mod_type_class.from_nat xa", "assume i_contr:\"i \\<noteq> to_nat (from_nat i::'rows)\" and \"x < CARD('columns)\"\n    and \"i<CARD('rows)\""], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.to_nat (mod_type_class.from_nat i)\n  x < CARD('columns)\n  i < CARD('rows)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('rows);\n        x \\<noteq> mod_type_class.to_nat (mod_type_class.from_nat x);\n        i = mod_type_class.from_nat x; xa < CARD('columns)\\<rbrakk>\n       \\<Longrightarrow> q *\n                         A $ mod_type_class.from_nat x $\n                         mod_type_class.from_nat xa =\n                         A $ mod_type_class.from_nat x $\n                         mod_type_class.from_nat xa", "hence \"i = to_nat (from_nat i::'rows)\""], ["proof (prove)\nusing this:\n  i \\<noteq> mod_type_class.to_nat (mod_type_class.from_nat i)\n  x < CARD('columns)\n  i < CARD('rows)\n\ngoal (1 subgoal):\n 1. i = mod_type_class.to_nat (mod_type_class.from_nat i)", "using to_nat_from_nat_id"], ["proof (prove)\nusing this:\n  i \\<noteq> mod_type_class.to_nat (mod_type_class.from_nat i)\n  x < CARD('columns)\n  i < CARD('rows)\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n\ngoal (1 subgoal):\n 1. i = mod_type_class.to_nat (mod_type_class.from_nat i)", "by fastforce"], ["proof (state)\nthis:\n  i = mod_type_class.to_nat (mod_type_class.from_nat i)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x < CARD('rows);\n        x \\<noteq> mod_type_class.to_nat (mod_type_class.from_nat x);\n        i = mod_type_class.from_nat x; xa < CARD('columns)\\<rbrakk>\n       \\<Longrightarrow> q *\n                         A $ mod_type_class.from_nat x $\n                         mod_type_class.from_nat xa =\n                         A $ mod_type_class.from_nat x $\n                         mod_type_class.from_nat xa", "thus \"q * A $ from_nat i $ from_nat x = A $ from_nat i $ from_nat x\""], ["proof (prove)\nusing this:\n  i = mod_type_class.to_nat (mod_type_class.from_nat i)\n\ngoal (1 subgoal):\n 1. q * A $ mod_type_class.from_nat i $ mod_type_class.from_nat x =\n    A $ mod_type_class.from_nat i $ mod_type_class.from_nat x", "using i_contr"], ["proof (prove)\nusing this:\n  i = mod_type_class.to_nat (mod_type_class.from_nat i)\n  i \\<noteq> mod_type_class.to_nat (mod_type_class.from_nat i)\n\ngoal (1 subgoal):\n 1. q * A $ mod_type_class.from_nat i $ mod_type_class.from_nat x =\n    A $ mod_type_class.from_nat i $ mod_type_class.from_nat x", "by contradiction"], ["proof (state)\nthis:\n  q * A $ mod_type_class.from_nat i $ mod_type_class.from_nat x =\n  A $ mod_type_class.from_nat i $ mod_type_class.from_nat x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_row_add[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (row_add A i j q) = row_add_iarray (matrix_to_iarray A) (to_nat i) (to_nat j) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (row_add A i j q) =\n    row_add_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (mod_type_class.to_nat j) q", "proof (unfold matrix_to_iarray_def row_add_iarray_def o_def, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat i < CARD('rows) \\<Longrightarrow>\n    vec_to_iarray (row_add A i j q $ i) =\n    vec_to_iarray (A $ i) + mult_iarray (vec_to_iarray (A $ j)) q\n 2. \\<And>x.\n       \\<lbrakk>x < CARD('rows); x \\<noteq> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> vec_to_iarray\n                          (row_add A i j q $ mod_type_class.from_nat x) =\n                         vec_to_iarray (A $ mod_type_class.from_nat x)", "show \"vec_to_iarray (row_add A i j q $ i) = vec_to_iarray (A $ i) + mult_iarray (vec_to_iarray (A $ j)) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (row_add A i j q $ i) =\n    vec_to_iarray (A $ i) + mult_iarray (vec_to_iarray (A $ j)) q", "unfolding mult_iarray_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>ia. row_add A i j q $ i $ mod_type_class.from_nat ia)\n     CARD('columns) =\n    IArray.of_fun (\\<lambda>ia. A $ i $ mod_type_class.from_nat ia)\n     CARD('columns) +\n    IArray.of_fun\n     (\\<lambda>n.\n         q *\n         IArray.of_fun (\\<lambda>i. A $ j $ mod_type_class.from_nat i)\n          CARD('columns) !!\n         n)\n     (IArray.length\n       (IArray.of_fun (\\<lambda>i. A $ j $ mod_type_class.from_nat i)\n         CARD('columns)))", "unfolding plus_iarray_def Let_def row_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>ia.\n         (\\<chi>ia ja.\n             if ia = i then A $ i $ ja + q * A $ j $ ja else A $ ia $ ja) $\n         i $\n         mod_type_class.from_nat ia)\n     CARD('columns) =\n    IArray.of_fun\n     (\\<lambda>a.\n         IArray.of_fun\n          (\\<lambda>a.\n              if a < IArray.length\n                      (IArray.of_fun\n                        (\\<lambda>ia. A $ i $ mod_type_class.from_nat ia)\n                        CARD('columns))\n              then IArray.of_fun\n                    (\\<lambda>ia. A $ i $ mod_type_class.from_nat ia)\n                    CARD('columns) !!\n                   a\n              else (0::'a))\n          (max (IArray.length\n                 (IArray.of_fun\n                   (\\<lambda>ia. A $ i $ mod_type_class.from_nat ia)\n                   CARD('columns)))\n            (IArray.length\n              (IArray.of_fun\n                (\\<lambda>n.\n                    q *\n                    IArray.of_fun\n                     (\\<lambda>i. A $ j $ mod_type_class.from_nat i)\n                     CARD('columns) !!\n                    n)\n                (IArray.length\n                  (IArray.of_fun\n                    (\\<lambda>i. A $ j $ mod_type_class.from_nat i)\n                    CARD('columns)))))) !!\n         a +\n         IArray.of_fun\n          (\\<lambda>a.\n              if a < IArray.length\n                      (IArray.of_fun\n                        (\\<lambda>n.\n                            q *\n                            IArray.of_fun\n                             (\\<lambda>i. A $ j $ mod_type_class.from_nat i)\n                             CARD('columns) !!\n                            n)\n                        (IArray.length\n                          (IArray.of_fun\n                            (\\<lambda>i. A $ j $ mod_type_class.from_nat i)\n                            CARD('columns))))\n              then IArray.of_fun\n                    (\\<lambda>n.\n                        q *\n                        IArray.of_fun\n                         (\\<lambda>i. A $ j $ mod_type_class.from_nat i)\n                         CARD('columns) !!\n                        n)\n                    (IArray.length\n                      (IArray.of_fun\n                        (\\<lambda>i. A $ j $ mod_type_class.from_nat i)\n                        CARD('columns))) !!\n                   a\n              else (0::'a))\n          (max (IArray.length\n                 (IArray.of_fun\n                   (\\<lambda>ia. A $ i $ mod_type_class.from_nat ia)\n                   CARD('columns)))\n            (IArray.length\n              (IArray.of_fun\n                (\\<lambda>n.\n                    q *\n                    IArray.of_fun\n                     (\\<lambda>i. A $ j $ mod_type_class.from_nat i)\n                     CARD('columns) !!\n                    n)\n                (IArray.length\n                  (IArray.of_fun\n                    (\\<lambda>i. A $ j $ mod_type_class.from_nat i)\n                    CARD('columns)))))) !!\n         a)\n     (max (IArray.length\n            (IArray.of_fun (\\<lambda>ia. A $ i $ mod_type_class.from_nat ia)\n              CARD('columns)))\n       (IArray.length\n         (IArray.of_fun\n           (\\<lambda>n.\n               q *\n               IArray.of_fun (\\<lambda>i. A $ j $ mod_type_class.from_nat i)\n                CARD('columns) !!\n               n)\n           (IArray.length\n             (IArray.of_fun (\\<lambda>i. A $ j $ mod_type_class.from_nat i)\n               CARD('columns))))))", "by auto"], ["proof (state)\nthis:\n  vec_to_iarray (row_add A i j q $ i) =\n  vec_to_iarray (A $ i) + mult_iarray (vec_to_iarray (A $ j)) q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < CARD('rows); x \\<noteq> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> vec_to_iarray\n                          (row_add A i j q $ mod_type_class.from_nat x) =\n                         vec_to_iarray (A $ mod_type_class.from_nat x)", "fix ia"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < CARD('rows); x \\<noteq> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> vec_to_iarray\n                          (row_add A i j q $ mod_type_class.from_nat x) =\n                         vec_to_iarray (A $ mod_type_class.from_nat x)", "assume ia_not_i: \"ia \\<noteq> to_nat i\" and ia_card: \"ia < CARD('rows) \""], ["proof (state)\nthis:\n  ia \\<noteq> mod_type_class.to_nat i\n  ia < CARD('rows)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < CARD('rows); x \\<noteq> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> vec_to_iarray\n                          (row_add A i j q $ mod_type_class.from_nat x) =\n                         vec_to_iarray (A $ mod_type_class.from_nat x)", "have from_nat_ia_not_i: \"from_nat ia \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat ia \\<noteq> i", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat ia \\<noteq> i \\<Longrightarrow> False", "assume \"\\<not> from_nat ia \\<noteq> i\""], ["proof (state)\nthis:\n  \\<not> mod_type_class.from_nat ia \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat ia \\<noteq> i \\<Longrightarrow> False", "hence \"from_nat ia = i\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.from_nat ia \\<noteq> i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat ia = i", "by simp"], ["proof (state)\nthis:\n  mod_type_class.from_nat ia = i\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat ia \\<noteq> i \\<Longrightarrow> False", "hence \"to_nat (from_nat ia::'rows) = to_nat i\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat ia = i\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat ia) =\n    mod_type_class.to_nat i", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat ia) =\n  mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat ia \\<noteq> i \\<Longrightarrow> False", "hence \"ia=to_nat i\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (mod_type_class.from_nat ia) =\n  mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. ia = mod_type_class.to_nat i", "using to_nat_from_nat_id ia_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (mod_type_class.from_nat ia) =\n  mod_type_class.to_nat i\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  ia < CARD('rows)\n\ngoal (1 subgoal):\n 1. ia = mod_type_class.to_nat i", "by fastforce"], ["proof (state)\nthis:\n  ia = mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat ia \\<noteq> i \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  ia = mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. False", "using ia_not_i"], ["proof (prove)\nusing this:\n  ia = mod_type_class.to_nat i\n  ia \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat ia \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < CARD('rows); x \\<noteq> mod_type_class.to_nat i\\<rbrakk>\n       \\<Longrightarrow> vec_to_iarray\n                          (row_add A i j q $ mod_type_class.from_nat x) =\n                         vec_to_iarray (A $ mod_type_class.from_nat x)", "show \"vec_to_iarray (row_add A i j q $ from_nat ia) = vec_to_iarray (A $ from_nat ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (row_add A i j q $ mod_type_class.from_nat ia) =\n    vec_to_iarray (A $ mod_type_class.from_nat ia)", "using ia_not_i"], ["proof (prove)\nusing this:\n  ia \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. vec_to_iarray (row_add A i j q $ mod_type_class.from_nat ia) =\n    vec_to_iarray (A $ mod_type_class.from_nat ia)", "unfolding vec_to_iarray_morph[symmetric]"], ["proof (prove)\nusing this:\n  ia \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. row_add A i j q $ mod_type_class.from_nat ia =\n    A $ mod_type_class.from_nat ia", "unfolding row_add_def"], ["proof (prove)\nusing this:\n  ia \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = i then A $ i $ ja + q * A $ j $ ja else A $ ia $ ja) $\n    mod_type_class.from_nat ia =\n    A $ mod_type_class.from_nat ia", "using from_nat_ia_not_i"], ["proof (prove)\nusing this:\n  ia \\<noteq> mod_type_class.to_nat i\n  mod_type_class.from_nat ia \\<noteq> i\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = i then A $ i $ ja + q * A $ j $ ja else A $ ia $ ja) $\n    mod_type_class.from_nat ia =\n    A $ mod_type_class.from_nat ia", "by vector"], ["proof (state)\nthis:\n  vec_to_iarray (row_add A i j q $ mod_type_class.from_nat ia) =\n  vec_to_iarray (A $ mod_type_class.from_nat ia)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_interchange_columns[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (interchange_columns A i j) = interchange_columns_iarray (matrix_to_iarray A) (to_nat i) (to_nat j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (interchange_columns A i j) =\n    interchange_columns_iarray (matrix_to_iarray A)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j)", "unfolding interchange_columns_def interchange_columns_iarray_def o_def tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (\\<chi>ia ja.\n         if ja = i then A $ ia $ j\n         else if ja = j then A $ ia $ i else A $ ia $ ja) =\n    IArray.of_fun\n     (\\<lambda>ia.\n         IArray.of_fun\n          (\\<lambda>ja.\n              if ja = mod_type_class.to_nat i\n              then matrix_to_iarray A !! ia !! mod_type_class.to_nat j\n              else if ja = mod_type_class.to_nat j\n                   then matrix_to_iarray A !! ia !! mod_type_class.to_nat i\n                   else matrix_to_iarray A !! ia !! ja)\n          (ncols_iarray (matrix_to_iarray A)))\n     (nrows_iarray (matrix_to_iarray A))", "unfolding nrows_eq_card_rows ncols_eq_card_columns"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (\\<chi>ia ja.\n         if ja = i then A $ ia $ j\n         else if ja = j then A $ ia $ i else A $ ia $ ja) =\n    IArray.of_fun\n     (\\<lambda>ia.\n         IArray.of_fun\n          (\\<lambda>ja.\n              if ja = mod_type_class.to_nat i\n              then matrix_to_iarray A !! ia !! mod_type_class.to_nat j\n              else if ja = mod_type_class.to_nat j\n                   then matrix_to_iarray A !! ia !! mod_type_class.to_nat i\n                   else matrix_to_iarray A !! ia !! ja)\n          CARD('columns))\n     CARD('rows)", "unfolding  matrix_to_iarray_def o_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>ia.\n                   (\\<chi>ia ja.\n                       if ja = i then A $ ia $ j\n                       else if ja = j then A $ ia $ i else A $ ia $ ja) $\n                   mod_type_class.from_nat x $\n                   mod_type_class.from_nat ia)\n               CARD('columns))\n       [0..<CARD('rows)]) =\n    IArray.of_fun\n     (\\<lambda>ia.\n         IArray.of_fun\n          (\\<lambda>ja.\n              if ja = mod_type_class.to_nat i\n              then IArray\n                    (map (\\<lambda>x.\n                             IArray.of_fun\n                              (\\<lambda>i.\n                                  A $ mod_type_class.from_nat x $\n                                  mod_type_class.from_nat i)\n                              CARD('columns))\n                      [0..<CARD('rows)]) !!\n                   ia !!\n                   mod_type_class.to_nat j\n              else if ja = mod_type_class.to_nat j\n                   then IArray\n                         (map (\\<lambda>x.\n                                  IArray.of_fun\n                                   (\\<lambda>i.\n A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n                                   CARD('columns))\n                           [0..<CARD('rows)]) !!\n                        ia !!\n                        mod_type_class.to_nat i\n                   else IArray\n                         (map (\\<lambda>x.\n                                  IArray.of_fun\n                                   (\\<lambda>i.\n A $ mod_type_class.from_nat x $ mod_type_class.from_nat i)\n                                   CARD('columns))\n                           [0..<CARD('rows)]) !!\n                        ia !!\n                        ja)\n          CARD('columns))\n     CARD('rows)", "by (auto simp add: to_nat_from_nat_id to_nat_less_card[of i] to_nat_less_card[of j])"], ["", "lemma matrix_to_iarray_mult_columns[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (mult_column A i q) = mult_column_iarray (matrix_to_iarray A) (to_nat i) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (mult_column A i q) =\n    mult_column_iarray (matrix_to_iarray A) (mod_type_class.to_nat i) q", "unfolding mult_column_def mult_column_iarray_def o_def tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (\\<chi>ia j. if j = i then A $ ia $ j * q else A $ ia $ j) =\n    IArray.of_fun\n     (\\<lambda>ia.\n         IArray.of_fun\n          (\\<lambda>j.\n              if j = mod_type_class.to_nat i\n              then matrix_to_iarray A !! ia !! j * q\n              else matrix_to_iarray A !! ia !! j)\n          (ncols_iarray (matrix_to_iarray A)))\n     (nrows_iarray (matrix_to_iarray A))", "unfolding nrows_eq_card_rows ncols_eq_card_columns"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (\\<chi>ia j. if j = i then A $ ia $ j * q else A $ ia $ j) =\n    IArray.of_fun\n     (\\<lambda>ia.\n         IArray.of_fun\n          (\\<lambda>j.\n              if j = mod_type_class.to_nat i\n              then matrix_to_iarray A !! ia !! j * q\n              else matrix_to_iarray A !! ia !! j)\n          CARD('columns))\n     CARD('rows)", "unfolding  matrix_to_iarray_def o_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>ia.\n                   (\\<chi>ia j.\n                       if j = i then A $ ia $ j * q else A $ ia $ j) $\n                   mod_type_class.from_nat x $\n                   mod_type_class.from_nat ia)\n               CARD('columns))\n       [0..<CARD('rows)]) =\n    IArray.of_fun\n     (\\<lambda>ia.\n         IArray.of_fun\n          (\\<lambda>j.\n              if j = mod_type_class.to_nat i\n              then IArray\n                    (map (\\<lambda>x.\n                             IArray.of_fun\n                              (\\<lambda>i.\n                                  A $ mod_type_class.from_nat x $\n                                  mod_type_class.from_nat i)\n                              CARD('columns))\n                      [0..<CARD('rows)]) !!\n                   ia !!\n                   j *\n                   q\n              else IArray\n                    (map (\\<lambda>x.\n                             IArray.of_fun\n                              (\\<lambda>i.\n                                  A $ mod_type_class.from_nat x $\n                                  mod_type_class.from_nat i)\n                              CARD('columns))\n                      [0..<CARD('rows)]) !!\n                   ia !!\n                   j)\n          CARD('columns))\n     CARD('rows)", "by (auto simp add: to_nat_from_nat_id)"], ["", "lemma matrix_to_iarray_column_add[code_unfold]:\n  fixes A::\"'a::{semiring_1}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (column_add A i j q) = column_add_iarray (matrix_to_iarray A) (to_nat i) (to_nat j) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (column_add A i j q) =\n    column_add_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (mod_type_class.to_nat j) q", "unfolding column_add_def column_add_iarray_def o_def tabulate2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (\\<chi>ia ja.\n         if ja = i then A $ ia $ i + A $ ia $ j * q else A $ ia $ ja) =\n    IArray.of_fun\n     (\\<lambda>ia.\n         IArray.of_fun\n          (\\<lambda>ja.\n              if ja = mod_type_class.to_nat i\n              then matrix_to_iarray A !! ia !! mod_type_class.to_nat i +\n                   matrix_to_iarray A !! ia !! mod_type_class.to_nat j * q\n              else matrix_to_iarray A !! ia !! ja)\n          (ncols_iarray (matrix_to_iarray A)))\n     (nrows_iarray (matrix_to_iarray A))", "unfolding nrows_eq_card_rows ncols_eq_card_columns"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (\\<chi>ia ja.\n         if ja = i then A $ ia $ i + A $ ia $ j * q else A $ ia $ ja) =\n    IArray.of_fun\n     (\\<lambda>ia.\n         IArray.of_fun\n          (\\<lambda>ja.\n              if ja = mod_type_class.to_nat i\n              then matrix_to_iarray A !! ia !! mod_type_class.to_nat i +\n                   matrix_to_iarray A !! ia !! mod_type_class.to_nat j * q\n              else matrix_to_iarray A !! ia !! ja)\n          CARD('columns))\n     CARD('rows)", "unfolding  matrix_to_iarray_def o_def vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (map (\\<lambda>x.\n              IArray.of_fun\n               (\\<lambda>ia.\n                   (\\<chi>ia ja.\n                       if ja = i then A $ ia $ i + A $ ia $ j * q\n                       else A $ ia $ ja) $\n                   mod_type_class.from_nat x $\n                   mod_type_class.from_nat ia)\n               CARD('columns))\n       [0..<CARD('rows)]) =\n    IArray.of_fun\n     (\\<lambda>ia.\n         IArray.of_fun\n          (\\<lambda>ja.\n              if ja = mod_type_class.to_nat i\n              then IArray\n                    (map (\\<lambda>x.\n                             IArray.of_fun\n                              (\\<lambda>i.\n                                  A $ mod_type_class.from_nat x $\n                                  mod_type_class.from_nat i)\n                              CARD('columns))\n                      [0..<CARD('rows)]) !!\n                   ia !!\n                   mod_type_class.to_nat i +\n                   IArray\n                    (map (\\<lambda>x.\n                             IArray.of_fun\n                              (\\<lambda>i.\n                                  A $ mod_type_class.from_nat x $\n                                  mod_type_class.from_nat i)\n                              CARD('columns))\n                      [0..<CARD('rows)]) !!\n                   ia !!\n                   mod_type_class.to_nat j *\n                   q\n              else IArray\n                    (map (\\<lambda>x.\n                             IArray.of_fun\n                              (\\<lambda>i.\n                                  A $ mod_type_class.from_nat x $\n                                  mod_type_class.from_nat i)\n                              CARD('columns))\n                      [0..<CARD('rows)]) !!\n                   ia !!\n                   ja)\n          CARD('columns))\n     CARD('rows)", "by (auto simp add: to_nat_from_nat_id to_nat_less_card[of i] to_nat_less_card[of j])"], ["", "end"]]}