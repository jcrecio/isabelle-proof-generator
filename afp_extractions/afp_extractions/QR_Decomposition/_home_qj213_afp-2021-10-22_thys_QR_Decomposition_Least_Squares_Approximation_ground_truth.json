{"file_name": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition/Least_Squares_Approximation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition", "problem_names": ["lemma null_space_orthogonal_complement_row_space:\n  fixes A::\"real^'cols^'rows::{finite,wellorder}\"\n  shows \"null_space A = orthogonal_complement (row_space A)\"", "lemma left_null_space_orthogonal_complement_col_space:\n  fixes A::\"real^'cols::{finite,wellorder}^'rows\"\n  shows \"left_null_space A = orthogonal_complement (col_space A)\"", "lemma least_squares_approximation:\n  fixes X::\"'a::{euclidean_space} set\"\n  assumes subspace_S: \"subspace S\"\n  and ind_X: \"independent X\"\n  and X: \"X \\<subseteq> S\"\n  and span_X: \"S \\<subseteq> span X\"\n  and o: \"pairwise orthogonal X\"\n  and not_eq: \"proj_onto v X \\<noteq> y\"\n  and y: \"y \\<in> S\"\n  shows \"norm (v - proj_onto v X) < norm (v - y)\"", "lemma least_squares_approximation2:\n  fixes S::\"'a::{euclidean_space} set\"\n  assumes subspace_S: \"subspace S\"\n  and y: \"y \\<in> S\"\n  shows \"\\<exists>p\\<in>S. norm (v - p) \\<le> norm (v - y) \\<and> (v-p) \\<in> orthogonal_complement S\"", "lemma norm_least_squares:\n  fixes A::\"real^'cols::{finite,wellorder}^'rows\"\n  shows \"\\<exists>x. \\<forall>x'. norm (b - A *v x) \\<le> norm (b - A *v x')\"", "lemma in_set_least_squares_approximation:\n  fixes A::\"real^'cols::{finite, wellorder}^'rows\"\n  assumes o: \"A *v x - b \\<in> orthogonal_complement (col_space A)\"\n  shows \"(x \\<in> set_least_squares_approximation A b)\"", "lemma in_set_least_squares_approximation_eq:\n  fixes A::\"real^'cols::{finite,wellorder}^'rows\"\n  shows \"(x \\<in> set_least_squares_approximation A b) = (transpose A ** A *v x = transpose A *v b)\"", "lemma in_set_least_squares_approximation_eq_full_rank:\n  fixes A::\"real^'cols::mod_type^'rows::mod_type\"\n  assumes r: \"rank A = ncols A\"\n  shows \"(x \\<in> set_least_squares_approximation A b) = (x = matrix_inv (transpose A ** A)**transpose A *v b)\"", "lemma in_set_least_squares_approximation_eq_full_rank_QR:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"(x \\<in> set_least_squares_approximation A b) = ((snd (QR_decomposition A)) *v x = transpose (fst (QR_decomposition A)) *v b)\"", "lemma set_least_squares_approximation_unique_solution:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"(set_least_squares_approximation A b) = {matrix_inv (transpose A ** A)**transpose A *v b}\"", "lemma set_least_squares_approximation_unique_solution_QR:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"(set_least_squares_approximation A b) = {matrix_inv (snd (QR_decomposition A)) ** transpose (fst (QR_decomposition A)) *v b}\""], "translations": [["", "lemma null_space_orthogonal_complement_row_space:\n  fixes A::\"real^'cols^'rows::{finite,wellorder}\"\n  shows \"null_space A = orthogonal_complement (row_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null_space A = orthogonal_complement (row_space A)", "proof (unfold null_space_def orthogonal_complement_def, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>A *v x = 0; xa \\<in> row_space A\\<rbrakk>\n       \\<Longrightarrow> orthogonal x xa\n 2. \\<And>x.\n       \\<forall>xa\\<in>row_space A. orthogonal x xa \\<Longrightarrow>\n       A *v x = 0", "fix x xa"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>A *v x = 0; xa \\<in> row_space A\\<rbrakk>\n       \\<Longrightarrow> orthogonal x xa\n 2. \\<And>x.\n       \\<forall>xa\\<in>row_space A. orthogonal x xa \\<Longrightarrow>\n       A *v x = 0", "assume Ax: \"A *v x = 0\" and xa: \"xa \\<in> row_space A\""], ["proof (state)\nthis:\n  A *v x = 0\n  xa \\<in> row_space A\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>A *v x = 0; xa \\<in> row_space A\\<rbrakk>\n       \\<Longrightarrow> orthogonal x xa\n 2. \\<And>x.\n       \\<forall>xa\\<in>row_space A. orthogonal x xa \\<Longrightarrow>\n       A *v x = 0", "obtain y where y: \"xa = transpose A *v y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        xa = Finite_Cartesian_Product.transpose A *v y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using xa"], ["proof (prove)\nusing this:\n  xa \\<in> row_space A\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        xa = Finite_Cartesian_Product.transpose A *v y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding row_space_eq"], ["proof (prove)\nusing this:\n  xa \\<in> {w. \\<exists>y. Finite_Cartesian_Product.transpose A *v y = w}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        xa = Finite_Cartesian_Product.transpose A *v y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xa = Finite_Cartesian_Product.transpose A *v y\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>A *v x = 0; xa \\<in> row_space A\\<rbrakk>\n       \\<Longrightarrow> orthogonal x xa\n 2. \\<And>x.\n       \\<forall>xa\\<in>row_space A. orthogonal x xa \\<Longrightarrow>\n       A *v x = 0", "have \"y v* A = xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y v* A = xa", "using transpose_vector y"], ["proof (prove)\nusing this:\n  ?x v* ?A = Finite_Cartesian_Product.transpose ?A *v ?x\n  xa = Finite_Cartesian_Product.transpose A *v y\n\ngoal (1 subgoal):\n 1. y v* A = xa", "by fastforce"], ["proof (state)\nthis:\n  y v* A = xa\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>A *v x = 0; xa \\<in> row_space A\\<rbrakk>\n       \\<Longrightarrow> orthogonal x xa\n 2. \\<And>x.\n       \\<forall>xa\\<in>row_space A. orthogonal x xa \\<Longrightarrow>\n       A *v x = 0", "thus \"orthogonal x xa\""], ["proof (prove)\nusing this:\n  y v* A = xa\n\ngoal (1 subgoal):\n 1. orthogonal x xa", "unfolding orthogonal_def"], ["proof (prove)\nusing this:\n  y v* A = xa\n\ngoal (1 subgoal):\n 1. x \\<bullet> xa = 0", "using Ax dot_lmul_matrix inner_commute inner_zero_right"], ["proof (prove)\nusing this:\n  y v* A = xa\n  A *v x = 0\n  (?x v* ?A) \\<bullet> ?y = ?x \\<bullet> (?A *v ?y)\n  ?x \\<bullet> ?y = ?y \\<bullet> ?x\n  ?x \\<bullet> (0::?'a) = 0\n\ngoal (1 subgoal):\n 1. x \\<bullet> xa = 0", "by (metis Ax dot_lmul_matrix inner_commute inner_zero_right)"], ["proof (state)\nthis:\n  orthogonal x xa\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>xa\\<in>row_space A. orthogonal x xa \\<Longrightarrow>\n       A *v x = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>xa\\<in>row_space A. orthogonal x xa \\<Longrightarrow>\n       A *v x = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>xa\\<in>row_space A. orthogonal x xa \\<Longrightarrow>\n       A *v x = 0", "assume xa: \"\\<forall>xa\\<in>row_space A. orthogonal x xa\""], ["proof (state)\nthis:\n  \\<forall>xa\\<in>row_space A. orthogonal x xa\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>xa\\<in>row_space A. orthogonal x xa \\<Longrightarrow>\n       A *v x = 0", "show \"A *v x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v x = 0", "using xa"], ["proof (prove)\nusing this:\n  \\<forall>xa\\<in>row_space A. orthogonal x xa\n\ngoal (1 subgoal):\n 1. A *v x = 0", "unfolding row_space_eq orthogonal_def"], ["proof (prove)\nusing this:\n  \\<forall>xa\\<in>{w. \\<exists>y.\n                         Finite_Cartesian_Product.transpose A *v y = w}.\n     x \\<bullet> xa = 0\n\ngoal (1 subgoal):\n 1. A *v x = 0", "by (auto, metis transpose_transpose dot_lmul_matrix inner_eq_zero_iff transpose_vector)"], ["proof (state)\nthis:\n  A *v x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_null_space_orthogonal_complement_col_space:\n  fixes A::\"real^'cols::{finite,wellorder}^'rows\"\n  shows \"left_null_space A = orthogonal_complement (col_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_null_space A = orthogonal_complement (col_space A)", "using null_space_orthogonal_complement_row_space[of \"transpose A\"]"], ["proof (prove)\nusing this:\n  null_space (Finite_Cartesian_Product.transpose A) =\n  orthogonal_complement (row_space (Finite_Cartesian_Product.transpose A))\n\ngoal (1 subgoal):\n 1. left_null_space A = orthogonal_complement (col_space A)", "unfolding left_null_space_eq_null_space_transpose"], ["proof (prove)\nusing this:\n  null_space (Finite_Cartesian_Product.transpose A) =\n  orthogonal_complement (row_space (Finite_Cartesian_Product.transpose A))\n\ngoal (1 subgoal):\n 1. null_space (Finite_Cartesian_Product.transpose A) =\n    orthogonal_complement (col_space A)", "unfolding col_space_eq_row_space_transpose"], ["proof (prove)\nusing this:\n  null_space (Finite_Cartesian_Product.transpose A) =\n  orthogonal_complement (row_space (Finite_Cartesian_Product.transpose A))\n\ngoal (1 subgoal):\n 1. null_space (Finite_Cartesian_Product.transpose A) =\n    orthogonal_complement (row_space (Finite_Cartesian_Product.transpose A))", "."], ["", "subsection\\<open>Least Squares Approximation\\<close>"], ["", "text\\<open>See @{url \"https://people.math.osu.edu/husen.1/teaching/571/least_squares.pdf\"}\\<close>"], ["", "text\\<open>Part 3 of the Theorem 1.7 in the previous website.\\<close>"], ["", "lemma least_squares_approximation:\n  fixes X::\"'a::{euclidean_space} set\"\n  assumes subspace_S: \"subspace S\"\n  and ind_X: \"independent X\"\n  and X: \"X \\<subseteq> S\"\n  and span_X: \"S \\<subseteq> span X\"\n  and o: \"pairwise orthogonal X\"\n  and not_eq: \"proj_onto v X \\<noteq> y\"\n  and y: \"y \\<in> S\"\n  shows \"norm (v - proj_onto v X) < norm (v - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "have S_eq_spanX: \"S = span X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = span X", "using X span_X span_subspace subspace_S"], ["proof (prove)\nusing this:\n  X \\<subseteq> S\n  S \\<subseteq> span X\n  \\<lbrakk>?A \\<subseteq> ?B; ?B \\<subseteq> span ?A; subspace ?B\\<rbrakk>\n  \\<Longrightarrow> span ?A = ?B\n  subspace S\n\ngoal (1 subgoal):\n 1. S = span X", "by auto"], ["proof (state)\nthis:\n  S = span X\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "let ?p=\"proj_onto v X\""], ["proof (state)\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "have not_0: \"(norm(?p - y))^2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (proj_onto v X - y))\\<^sup>2 \\<noteq> 0", "by (metis (lifting) eq_iff_diff_eq_0 norm_eq_zero not_eq power_eq_0_iff)"], ["proof (state)\nthis:\n  (norm (proj_onto v X - y))\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "have \"norm (v-y)^2 = norm (v - ?p + ?p - y)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (v - y))\\<^sup>2 =\n    (norm (v - proj_onto v X + proj_onto v X - y))\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  (norm (v - y))\\<^sup>2 =\n  (norm (v - proj_onto v X + proj_onto v X - y))\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "also"], ["proof (state)\nthis:\n  (norm (v - y))\\<^sup>2 =\n  (norm (v - proj_onto v X + proj_onto v X - y))\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "have \"... = norm ((v - ?p) + (?p - y))^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (v - proj_onto v X + proj_onto v X - y))\\<^sup>2 =\n    (norm (v - proj_onto v X + (proj_onto v X - y)))\\<^sup>2", "unfolding add.assoc[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (v - proj_onto v X + proj_onto v X - y))\\<^sup>2 =\n    (norm (v - proj_onto v X + (proj_onto v X - y)))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (norm (v - proj_onto v X + proj_onto v X - y))\\<^sup>2 =\n  (norm (v - proj_onto v X + (proj_onto v X - y)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "also"], ["proof (state)\nthis:\n  (norm (v - proj_onto v X + proj_onto v X - y))\\<^sup>2 =\n  (norm (v - proj_onto v X + (proj_onto v X - y)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "have \"... = (norm (v - ?p))^2 + (norm(?p - y))^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (v - proj_onto v X + (proj_onto v X - y)))\\<^sup>2 =\n    (norm (v - proj_onto v X))\\<^sup>2 + (norm (proj_onto v X - y))\\<^sup>2", "proof (rule phytagorean_theorem_norm, rule in_orthogonal_complement_imp_orthogonal)"], ["proof (state)\ngoal (2 subgoals):\n 1. proj_onto v X - y \\<in> ?S2\n 2. v - proj_onto v X \\<in> orthogonal_complement ?S2", "show \"?p - y \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_onto v X - y \\<in> S", "unfolding proj_onto_def proj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>X. (v \\<bullet> u / (u \\<bullet> u)) *\\<^sub>R u) - y\n    \\<in> S", "proof (rule subspace_diff[OF subspace_S _ y],\n        rule subspace_sum[OF subspace_S])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       (v \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x \\<in> S", "show \"x \\<in> X \\<Longrightarrow> (v \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x \\<in> S\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow>\n    (v \\<bullet> x / (x \\<bullet> x)) *\\<^sub>R x \\<in> S", "by (metis S_eq_spanX X rev_subsetD span_mul)"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow>\n  (v \\<bullet> ?x / (?x \\<bullet> ?x)) *\\<^sub>R ?x \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj_onto v X - y \\<in> S\n\ngoal (1 subgoal):\n 1. v - proj_onto v X \\<in> orthogonal_complement S", "show \"v - ?p \\<in> orthogonal_complement S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - proj_onto v X \\<in> orthogonal_complement S", "using v_minus_p_orthogonal_complement assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>subspace ?S; independent ?X; ?X \\<subseteq> ?S;\n   ?S \\<subseteq> span ?X; pairwise orthogonal ?X\\<rbrakk>\n  \\<Longrightarrow> ?v - proj_onto ?v ?X \\<in> orthogonal_complement ?S\n  subspace S\n  independent X\n  X \\<subseteq> S\n  S \\<subseteq> span X\n  pairwise orthogonal X\n  proj_onto v X \\<noteq> y\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. v - proj_onto v X \\<in> orthogonal_complement S", "by auto"], ["proof (state)\nthis:\n  v - proj_onto v X \\<in> orthogonal_complement S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (norm (v - proj_onto v X + (proj_onto v X - y)))\\<^sup>2 =\n  (norm (v - proj_onto v X))\\<^sup>2 + (norm (proj_onto v X - y))\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "finally"], ["proof (chain)\npicking this:\n  (norm (v - y))\\<^sup>2 =\n  (norm (v - proj_onto v X))\\<^sup>2 + (norm (proj_onto v X - y))\\<^sup>2", "have \"norm (v-?p)^2 < norm (v-y)^2\""], ["proof (prove)\nusing this:\n  (norm (v - y))\\<^sup>2 =\n  (norm (v - proj_onto v X))\\<^sup>2 + (norm (proj_onto v X - y))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (norm (v - proj_onto v X))\\<^sup>2 < (norm (v - y))\\<^sup>2", "using not_0"], ["proof (prove)\nusing this:\n  (norm (v - y))\\<^sup>2 =\n  (norm (v - proj_onto v X))\\<^sup>2 + (norm (proj_onto v X - y))\\<^sup>2\n  (norm (proj_onto v X - y))\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (norm (v - proj_onto v X))\\<^sup>2 < (norm (v - y))\\<^sup>2", "by fastforce"], ["proof (state)\nthis:\n  (norm (v - proj_onto v X))\\<^sup>2 < (norm (v - y))\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (norm (v - proj_onto v X))\\<^sup>2 < (norm (v - y))\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "by (metis (full_types) norm_gt_square power2_norm_eq_inner)"], ["proof (state)\nthis:\n  norm (v - proj_onto v X) < norm (v - y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma least_squares_approximation2:\n  fixes S::\"'a::{euclidean_space} set\"\n  assumes subspace_S: \"subspace S\"\n  and y: \"y \\<in> S\"\n  shows \"\\<exists>p\\<in>S. norm (v - p) \\<le> norm (v - y) \\<and> (v-p) \\<in> orthogonal_complement S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>S.\n       norm (v - p) \\<le> norm (v - y) \\<and>\n       v - p \\<in> orthogonal_complement S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>S.\n       norm (v - p) \\<le> norm (v - y) \\<and>\n       v - p \\<in> orthogonal_complement S", "obtain X where  ind_X: \"independent X\"\n    and X: \"X \\<subseteq> S\"\n    and span_X: \"S \\<subseteq> span X\"\n    and o: \"pairwise orthogonal X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>independent X; X \\<subseteq> S; S \\<subseteq> span X;\n         pairwise orthogonal X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis order_refl orthonormal_basis_subspace subspace_S)"], ["proof (state)\nthis:\n  independent X\n  X \\<subseteq> S\n  S \\<subseteq> span X\n  pairwise orthogonal X\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>S.\n       norm (v - p) \\<le> norm (v - y) \\<and>\n       v - p \\<in> orthogonal_complement S", "let ?p=\"proj_onto v X\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>S.\n       norm (v - p) \\<le> norm (v - y) \\<and>\n       v - p \\<in> orthogonal_complement S", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>S.\n       norm (v - p) \\<le> norm (v - y) \\<and>\n       v - p \\<in> orthogonal_complement S", "proof (rule bexI[of _ ?p], rule conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. norm (v - proj_onto v X) \\<le> norm (v - y)\n 2. v - proj_onto v X \\<in> orthogonal_complement S\n 3. proj_onto v X \\<in> S", "show \"norm (v - proj_onto v X) \\<le> norm (v - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) \\<le> norm (v - y)", "proof (cases \"?p=y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. proj_onto v X = y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)\n 2. proj_onto v X \\<noteq> y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)", "case True"], ["proof (state)\nthis:\n  proj_onto v X = y\n\ngoal (2 subgoals):\n 1. proj_onto v X = y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)\n 2. proj_onto v X \\<noteq> y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)", "thus \"norm (v - ?p) \\<le> norm (v - y)\""], ["proof (prove)\nusing this:\n  proj_onto v X = y\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) \\<le> norm (v - y)", "by simp"], ["proof (state)\nthis:\n  norm (v - proj_onto v X) \\<le> norm (v - y)\n\ngoal (1 subgoal):\n 1. proj_onto v X \\<noteq> y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_onto v X \\<noteq> y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)", "case False"], ["proof (state)\nthis:\n  proj_onto v X \\<noteq> y\n\ngoal (1 subgoal):\n 1. proj_onto v X \\<noteq> y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)", "have \"norm (v - ?p) < norm (v - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "by (rule least_squares_approximation[OF subspace_S ind_X X span_X o False y])"], ["proof (state)\nthis:\n  norm (v - proj_onto v X) < norm (v - y)\n\ngoal (1 subgoal):\n 1. proj_onto v X \\<noteq> y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)", "thus \"norm (v - ?p) \\<le> norm (v - y)\""], ["proof (prove)\nusing this:\n  norm (v - proj_onto v X) < norm (v - y)\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) \\<le> norm (v - y)", "by simp"], ["proof (state)\nthis:\n  norm (v - proj_onto v X) \\<le> norm (v - y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (v - proj_onto v X) \\<le> norm (v - y)\n\ngoal (2 subgoals):\n 1. v - proj_onto v X \\<in> orthogonal_complement S\n 2. proj_onto v X \\<in> S", "show \"?p \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_onto v X \\<in> S", "using [[unfold_abs_def = false]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_onto v X \\<in> S", "proof (unfold proj_onto_def proj_def, rule subspace_sum)"], ["proof (state)\ngoal (2 subgoals):\n 1. subspace S\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> proj v x \\<in> S", "show \"subspace S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace S", "using subspace_S"], ["proof (prove)\nusing this:\n  subspace S\n\ngoal (1 subgoal):\n 1. subspace S", "."], ["proof (state)\nthis:\n  subspace S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> proj v x \\<in> S", "show \"x\\<in>X \\<Longrightarrow> proj v x \\<in> S\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> proj v x \\<in> S", "by (simp add: proj_def X rev_subsetD subspace_S subspace_mul)"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> proj v ?x \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj_onto v X \\<in> S\n\ngoal (1 subgoal):\n 1. v - proj_onto v X \\<in> orthogonal_complement S", "show \"v - ?p\\<in> orthogonal_complement S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - proj_onto v X \\<in> orthogonal_complement S", "by (rule v_minus_p_orthogonal_complement[OF subspace_S ind_X X span_X o])"], ["proof (state)\nthis:\n  v - proj_onto v X \\<in> orthogonal_complement S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p\\<in>S.\n     norm (v - p) \\<le> norm (v - y) \\<and>\n     v - p \\<in> orthogonal_complement S\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary least_squares_approximation3:\n  fixes S::\"'a::{euclidean_space} set\"\n  assumes subspace_S: \"subspace S\"\n  shows \"\\<exists>p\\<in>S. \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y) \\<and> (v-p) \\<in> orthogonal_complement S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>S.\n       \\<forall>y\\<in>S.\n          norm (v - p) \\<le> norm (v - y) \\<and>\n          v - p \\<in> orthogonal_complement S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>S.\n       \\<forall>y\\<in>S.\n          norm (v - p) \\<le> norm (v - y) \\<and>\n          v - p \\<in> orthogonal_complement S", "obtain X where  ind_X: \"independent X\"\n    and X: \"X \\<subseteq> S\"\n    and span_X: \"S \\<subseteq> span X\"\n    and o: \"pairwise orthogonal X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>independent X; X \\<subseteq> S; S \\<subseteq> span X;\n         pairwise orthogonal X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis order_refl orthonormal_basis_subspace subspace_S)"], ["proof (state)\nthis:\n  independent X\n  X \\<subseteq> S\n  S \\<subseteq> span X\n  pairwise orthogonal X\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>S.\n       \\<forall>y\\<in>S.\n          norm (v - p) \\<le> norm (v - y) \\<and>\n          v - p \\<in> orthogonal_complement S", "let ?p=\"proj_onto v X\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>S.\n       \\<forall>y\\<in>S.\n          norm (v - p) \\<le> norm (v - y) \\<and>\n          v - p \\<in> orthogonal_complement S", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>S.\n       \\<forall>y\\<in>S.\n          norm (v - p) \\<le> norm (v - y) \\<and>\n          v - p \\<in> orthogonal_complement S", "proof (rule bexI[of _ ?p], auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>y.\n       y \\<in> S \\<Longrightarrow>\n       norm (v - proj_onto v X) \\<le> norm (v - y)\n 2. \\<And>y.\n       y \\<in> S \\<Longrightarrow>\n       v - proj_onto v X \\<in> orthogonal_complement S\n 3. proj_onto v X \\<in> S", "fix y"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>y.\n       y \\<in> S \\<Longrightarrow>\n       norm (v - proj_onto v X) \\<le> norm (v - y)\n 2. \\<And>y.\n       y \\<in> S \\<Longrightarrow>\n       v - proj_onto v X \\<in> orthogonal_complement S\n 3. proj_onto v X \\<in> S", "assume y: \"y\\<in>S\""], ["proof (state)\nthis:\n  y \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>y.\n       y \\<in> S \\<Longrightarrow>\n       norm (v - proj_onto v X) \\<le> norm (v - y)\n 2. \\<And>y.\n       y \\<in> S \\<Longrightarrow>\n       v - proj_onto v X \\<in> orthogonal_complement S\n 3. proj_onto v X \\<in> S", "show \"norm (v - ?p) \\<le> norm (v - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) \\<le> norm (v - y)", "proof (cases \"?p=y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. proj_onto v X = y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)\n 2. proj_onto v X \\<noteq> y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)", "case True"], ["proof (state)\nthis:\n  proj_onto v X = y\n\ngoal (2 subgoals):\n 1. proj_onto v X = y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)\n 2. proj_onto v X \\<noteq> y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  proj_onto v X = y\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) \\<le> norm (v - y)", "by simp"], ["proof (state)\nthis:\n  norm (v - proj_onto v X) \\<le> norm (v - y)\n\ngoal (1 subgoal):\n 1. proj_onto v X \\<noteq> y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_onto v X \\<noteq> y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)", "case False"], ["proof (state)\nthis:\n  proj_onto v X \\<noteq> y\n\ngoal (1 subgoal):\n 1. proj_onto v X \\<noteq> y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)", "have \"norm (v - ?p) < norm (v - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) < norm (v - y)", "by (rule least_squares_approximation[OF subspace_S ind_X X span_X o False y])"], ["proof (state)\nthis:\n  norm (v - proj_onto v X) < norm (v - y)\n\ngoal (1 subgoal):\n 1. proj_onto v X \\<noteq> y \\<Longrightarrow>\n    norm (v - proj_onto v X) \\<le> norm (v - y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  norm (v - proj_onto v X) < norm (v - y)\n\ngoal (1 subgoal):\n 1. norm (v - proj_onto v X) \\<le> norm (v - y)", "by simp"], ["proof (state)\nthis:\n  norm (v - proj_onto v X) \\<le> norm (v - y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (v - proj_onto v X) \\<le> norm (v - y)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> S \\<Longrightarrow>\n       v - proj_onto v X \\<in> orthogonal_complement S\n 2. proj_onto v X \\<in> S", "show \"v - ?p \\<in> orthogonal_complement S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - proj_onto v X \\<in> orthogonal_complement S", "by (rule v_minus_p_orthogonal_complement[OF subspace_S ind_X X span_X o])"], ["proof (state)\nthis:\n  v - proj_onto v X \\<in> orthogonal_complement S\n\ngoal (1 subgoal):\n 1. proj_onto v X \\<in> S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_onto v X \\<in> S", "show \"?p \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_onto v X \\<in> S", "proof (unfold proj_onto_def, rule subspace_sum)"], ["proof (state)\ngoal (2 subgoals):\n 1. subspace S\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> proj v x \\<in> S", "show \"subspace S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace S", "using subspace_S"], ["proof (prove)\nusing this:\n  subspace S\n\ngoal (1 subgoal):\n 1. subspace S", "."], ["proof (state)\nthis:\n  subspace S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> proj v x \\<in> S", "show \"x \\<in> X \\<Longrightarrow> proj v x \\<in> S\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> proj v x \\<in> S", "by (metis Projections.proj_def X subset_iff subspace_S subspace_mul)"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> proj v ?x \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj_onto v X \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p\\<in>S.\n     \\<forall>y\\<in>S.\n        norm (v - p) \\<le> norm (v - y) \\<and>\n        v - p \\<in> orthogonal_complement S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm_least_squares:\n  fixes A::\"real^'cols::{finite,wellorder}^'rows\"\n  shows \"\\<exists>x. \\<forall>x'. norm (b - A *v x) \\<le> norm (b - A *v x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>x'. norm (b - A *v x) \\<le> norm (b - A *v x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>x'. norm (b - A *v x) \\<le> norm (b - A *v x')", "have \"\\<exists>p\\<in>col_space A. \\<forall>y\\<in>col_space A. norm (b - p) \\<le> norm (b - y) \\<and> (b-p) \\<in> orthogonal_complement (col_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>col_space A.\n       \\<forall>y\\<in>col_space A.\n          norm (b - p) \\<le> norm (b - y) \\<and>\n          b - p \\<in> orthogonal_complement (col_space A)", "using least_squares_approximation3[OF subspace_col_space[of A, unfolded subspace_vec_eq]]"], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>col_space A.\n     \\<forall>y\\<in>col_space A.\n        norm (?v - p) \\<le> norm (?v - y) \\<and>\n        ?v - p \\<in> orthogonal_complement (col_space A)\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>col_space A.\n       \\<forall>y\\<in>col_space A.\n          norm (b - p) \\<le> norm (b - y) \\<and>\n          b - p \\<in> orthogonal_complement (col_space A)", "."], ["proof (state)\nthis:\n  \\<exists>p\\<in>col_space A.\n     \\<forall>y\\<in>col_space A.\n        norm (b - p) \\<le> norm (b - y) \\<and>\n        b - p \\<in> orthogonal_complement (col_space A)\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>x'. norm (b - A *v x) \\<le> norm (b - A *v x')", "from this"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>col_space A.\n     \\<forall>y\\<in>col_space A.\n        norm (b - p) \\<le> norm (b - y) \\<and>\n        b - p \\<in> orthogonal_complement (col_space A)", "obtain p where p: \"p \\<in> col_space A\" and least: \"\\<forall>y\\<in>col_space A. norm (b - p) \\<le> norm (b - y)\"\n    and bp_orthogonal: \"(b-p) \\<in> orthogonal_complement (col_space A)\""], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>col_space A.\n     \\<forall>y\\<in>col_space A.\n        norm (b - p) \\<le> norm (b - y) \\<and>\n        b - p \\<in> orthogonal_complement (col_space A)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> col_space A;\n         \\<forall>y\\<in>col_space A. norm (b - p) \\<le> norm (b - y);\n         b - p \\<in> orthogonal_complement (col_space A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in> col_space A\n  \\<forall>y\\<in>col_space A. norm (b - p) \\<le> norm (b - y)\n  b - p \\<in> orthogonal_complement (col_space A)\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>x'. norm (b - A *v x) \\<le> norm (b - A *v x')", "obtain x where x: \"p = A *v x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. p = A *v x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using p"], ["proof (prove)\nusing this:\n  p \\<in> col_space A\n\ngoal (1 subgoal):\n 1. (\\<And>x. p = A *v x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding col_space_eq"], ["proof (prove)\nusing this:\n  p \\<in> {y. \\<exists>x. A *v x = y}\n\ngoal (1 subgoal):\n 1. (\\<And>x. p = A *v x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  p = A *v x\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>x'. norm (b - A *v x) \\<le> norm (b - A *v x')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>x'. norm (b - A *v x) \\<le> norm (b - A *v x')", "proof (rule exI[of _ x], auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x'. norm (b - A *v x) \\<le> norm (b - A *v x')", "fix x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x'. norm (b - A *v x) \\<le> norm (b - A *v x')", "have \"A *v x' \\<in> col_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v x' \\<in> col_space A", "unfolding col_space_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v x' \\<in> {y. \\<exists>x. A *v x = y}", "by auto"], ["proof (state)\nthis:\n  A *v x' \\<in> col_space A\n\ngoal (1 subgoal):\n 1. \\<And>x'. norm (b - A *v x) \\<le> norm (b - A *v x')", "thus \"norm (b - A *v x) \\<le> norm (b - A *v x')\""], ["proof (prove)\nusing this:\n  A *v x' \\<in> col_space A\n\ngoal (1 subgoal):\n 1. norm (b - A *v x) \\<le> norm (b - A *v x')", "using least"], ["proof (prove)\nusing this:\n  A *v x' \\<in> col_space A\n  \\<forall>y\\<in>col_space A. norm (b - p) \\<le> norm (b - y)\n\ngoal (1 subgoal):\n 1. norm (b - A *v x) \\<le> norm (b - A *v x')", "unfolding x"], ["proof (prove)\nusing this:\n  A *v x' \\<in> col_space A\n  \\<forall>y\\<in>col_space A. norm (b - A *v x) \\<le> norm (b - y)\n\ngoal (1 subgoal):\n 1. norm (b - A *v x) \\<le> norm (b - A *v x')", "by auto"], ["proof (state)\nthis:\n  norm (b - A *v x) \\<le> norm (b - A *v x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>x'. norm (b - A *v x) \\<le> norm (b - A *v x')\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"set_least_squares_approximation A b = {x. \\<forall>y. norm (b - A *v x) \\<le> norm (b - A *v y)}\""], ["", "corollary least_squares_approximation4:\n  fixes S::\"'a::{euclidean_space} set\"\n  assumes subspace_S: \"subspace S\"\n  shows \"\\<exists>!p\\<in>S. \\<forall>y\\<in>S-{p}. norm (v - p) < norm (v - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!p.\n       p \\<in> S \\<and>\n       (\\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y))", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<in> S \\<and>\n       (\\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y))\n 2. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S - {y}. norm (v - y) < norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "obtain X where  ind_X: \"independent X\"\n    and X: \"X \\<subseteq> S\"\n    and span_X: \"S \\<subseteq> span X\"\n    and o: \"pairwise orthogonal X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>independent X; X \\<subseteq> S; S \\<subseteq> span X;\n         pairwise orthogonal X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis order_refl orthonormal_basis_subspace subspace_S)"], ["proof (state)\nthis:\n  independent X\n  X \\<subseteq> S\n  S \\<subseteq> span X\n  pairwise orthogonal X\n\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<in> S \\<and>\n       (\\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y))\n 2. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S - {y}. norm (v - y) < norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "let ?p=\"sum (proj v) X\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<in> S \\<and>\n       (\\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y))\n 2. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S - {y}. norm (v - y) < norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "show \"\\<exists>p. p \\<in> S \\<and> (\\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p \\<in> S \\<and>\n       (\\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y))", "proof (rule exI[of _ ?p], rule conjI,  rule subspace_sum)"], ["proof (state)\ngoal (3 subgoals):\n 1. subspace S\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> proj v x \\<in> S\n 3. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y)", "show \"subspace S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace S", "using subspace_S"], ["proof (prove)\nusing this:\n  subspace S\n\ngoal (1 subgoal):\n 1. subspace S", "."], ["proof (state)\nthis:\n  subspace S\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> proj v x \\<in> S\n 2. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y)", "show \"x \\<in> X \\<Longrightarrow> proj v x \\<in> S\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> proj v x \\<in> S", "by (metis Projections.proj_def X subset_iff subspace_S subspace_mul)"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> proj v ?x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y)", "show \"\\<forall>y\\<in>S - {?p}. norm (v - ?p) < norm (v - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y)", "using X ind_X least_squares_approximation  o span_X subspace_S proj_onto_def"], ["proof (prove)\nusing this:\n  X \\<subseteq> S\n  independent X\n  \\<lbrakk>subspace ?S; independent ?X; ?X \\<subseteq> ?S;\n   ?S \\<subseteq> span ?X; pairwise orthogonal ?X;\n   proj_onto ?v ?X \\<noteq> ?y; ?y \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> norm (?v - proj_onto ?v ?X) < norm (?v - ?y)\n  pairwise orthogonal X\n  S \\<subseteq> span X\n  subspace S\n  proj_onto ?a ?S = sum (proj ?a) ?S\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y)", "by (metis (mono_tags) Diff_iff singletonI)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>S - {sum (proj v) X}.\n     norm (v - sum (proj v) X) < norm (v - y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p.\n     p \\<in> S \\<and> (\\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y))\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S - {y}. norm (v - y) < norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "fix p y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S - {y}. norm (v - y) < norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "assume p: \"p \\<in> S\"\n    and \"\\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y)\"\n    and \"y \\<in> S\"\n    and \"\\<forall>ya\\<in>S - {y}. norm (v - y) < norm (v - ya)\""], ["proof (state)\nthis:\n  p \\<in> S\n  \\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y)\n  y \\<in> S\n  \\<forall>ya\\<in>S - {y}. norm (v - y) < norm (v - ya)\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S - {y}. norm (v - y) < norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "thus \"p = y\""], ["proof (prove)\nusing this:\n  p \\<in> S\n  \\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y)\n  y \\<in> S\n  \\<forall>ya\\<in>S - {y}. norm (v - y) < norm (v - ya)\n\ngoal (1 subgoal):\n 1. p = y", "by (metis member_remove not_less_iff_gr_or_eq remove_def)"], ["proof (state)\nthis:\n  p = y\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary least_squares_approximation4':\n  fixes S::\"'a::{euclidean_space} set\"\n  assumes subspace_S: \"subspace S\"\n  shows \"\\<exists>!p\\<in>S. \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!p.\n       p \\<in> S \\<and> (\\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y))", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<in> S \\<and> (\\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y))\n 2. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "obtain X where ind_X: \"independent X\"\n    and X: \"X \\<subseteq> S\"\n    and span_X: \"S \\<subseteq> span X\"\n    and o: \"pairwise orthogonal X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>independent X; X \\<subseteq> S; S \\<subseteq> span X;\n         pairwise orthogonal X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis order_refl orthonormal_basis_subspace subspace_S)"], ["proof (state)\nthis:\n  independent X\n  X \\<subseteq> S\n  S \\<subseteq> span X\n  pairwise orthogonal X\n\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<in> S \\<and> (\\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y))\n 2. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "let ?p=\"sum (proj v) X\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<in> S \\<and> (\\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y))\n 2. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "show \"\\<exists>p. p \\<in> S \\<and> (\\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p \\<in> S \\<and> (\\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y))", "proof (rule exI[of _ ?p], rule conjI, rule subspace_sum)"], ["proof (state)\ngoal (3 subgoals):\n 1. subspace S\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> proj v x \\<in> S\n 3. \\<forall>y\\<in>S. norm (v - sum (proj v) X) \\<le> norm (v - y)", "show \"subspace S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace S", "using subspace_S"], ["proof (prove)\nusing this:\n  subspace S\n\ngoal (1 subgoal):\n 1. subspace S", "."], ["proof (state)\nthis:\n  subspace S\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> proj v x \\<in> S\n 2. \\<forall>y\\<in>S. norm (v - sum (proj v) X) \\<le> norm (v - y)", "show \"x \\<in> X \\<Longrightarrow> proj v x \\<in> S\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> proj v x \\<in> S", "by (metis Projections.proj_def X subset_iff subspace_S subspace_mul)"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> proj v ?x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S. norm (v - sum (proj v) X) \\<le> norm (v - y)", "show \"\\<forall>y\\<in>S. norm (v - ?p) \\<le> norm (v - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S. norm (v - sum (proj v) X) \\<le> norm (v - y)", "by (metis (mono_tags) proj_onto_def X dual_order.refl ind_X \n         least_squares_approximation less_imp_le o span_X subspace_S)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>S. norm (v - sum (proj v) X) \\<le> norm (v - y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p.\n     p \\<in> S \\<and> (\\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y))\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "fix p y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "assume p: \"p \\<in> S\" and p': \"\\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y)\"\n    and y: \"y \\<in> S\" and y': \"\\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\""], ["proof (state)\nthis:\n  p \\<in> S\n  \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y)\n  y \\<in> S\n  \\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "obtain a where a: \"a\\<in>S\" and a': \"\\<forall>y\\<in>S-{a}. norm (v - a) < norm (v - y)\"\n    and a_uniq: \"\\<forall>b. (b\\<in>S \\<and> (\\<forall>c\\<in>S-{b}. norm (v - b) < norm (v - c))) \\<longrightarrow> b=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> S;\n         \\<forall>y\\<in>S - {a}. norm (v - a) < norm (v - y);\n         \\<forall>b.\n            b \\<in> S \\<and>\n            (\\<forall>c\\<in>S - {b}.\n                norm (v - b) < norm (v - c)) \\<longrightarrow>\n            b = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using least_squares_approximation4[OF subspace_S]"], ["proof (prove)\nusing this:\n  \\<exists>!p.\n     p \\<in> S \\<and>\n     (\\<forall>y\\<in>S - {p}. norm (?v - p) < norm (?v - y))\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> S;\n         \\<forall>y\\<in>S - {a}. norm (v - a) < norm (v - y);\n         \\<forall>b.\n            b \\<in> S \\<and>\n            (\\<forall>c\\<in>S - {b}.\n                norm (v - b) < norm (v - c)) \\<longrightarrow>\n            b = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  a \\<in> S\n  \\<forall>y\\<in>S - {a}. norm (v - a) < norm (v - y)\n  \\<forall>b.\n     b \\<in> S \\<and>\n     (\\<forall>c\\<in>S - {b}. norm (v - b) < norm (v - c)) \\<longrightarrow>\n     b = a\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "have \"p=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = a", "using p p' a_uniq leD"], ["proof (prove)\nusing this:\n  p \\<in> S\n  \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y)\n  \\<forall>b.\n     b \\<in> S \\<and>\n     (\\<forall>c\\<in>S - {b}. norm (v - b) < norm (v - c)) \\<longrightarrow>\n     b = a\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n\ngoal (1 subgoal):\n 1. p = a", "by (metis a a' member_remove remove_def)"], ["proof (state)\nthis:\n  p = a\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "moreover"], ["proof (state)\nthis:\n  p = a\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "have \"y=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = a", "using y y' a_uniq"], ["proof (prove)\nusing this:\n  y \\<in> S\n  \\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\n  \\<forall>b.\n     b \\<in> S \\<and>\n     (\\<forall>c\\<in>S - {b}. norm (v - b) < norm (v - c)) \\<longrightarrow>\n     b = a\n\ngoal (1 subgoal):\n 1. y = a", "by (metis a a' leD member_remove remove_def)"], ["proof (state)\nthis:\n  y = a\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y); y \\<in> S;\n        \\<forall>ya\\<in>S. norm (v - y) \\<le> norm (v - ya)\\<rbrakk>\n       \\<Longrightarrow> p = y", "ultimately"], ["proof (chain)\npicking this:\n  p = a\n  y = a", "show \"p = y\""], ["proof (prove)\nusing this:\n  p = a\n  y = a\n\ngoal (1 subgoal):\n 1. p = y", "by simp"], ["proof (state)\nthis:\n  p = y\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary least_squares_approximation5:\n  fixes S::\"'a::{euclidean_space} set\"\n  assumes subspace_S: \"subspace S\"\n  shows \"\\<exists>!p\\<in>S. \\<forall>y\\<in>S-{p}. norm (v - p) < norm (v - y) \\<and> v-p \\<in> orthogonal_complement S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!p.\n       p \\<in> S \\<and>\n       (\\<forall>y\\<in>S - {p}.\n           norm (v - p) < norm (v - y) \\<and>\n           v - p \\<in> orthogonal_complement S)", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<in> S \\<and>\n       (\\<forall>y\\<in>S - {p}.\n           norm (v - p) < norm (v - y) \\<and>\n           v - p \\<in> orthogonal_complement S)\n 2. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S - {p}.\n           norm (v - p) < norm (v - y) \\<and>\n           v - p \\<in> orthogonal_complement S;\n        y \\<in> S;\n        \\<forall>ya\\<in>S - {y}.\n           norm (v - y) < norm (v - ya) \\<and>\n           v - y \\<in> orthogonal_complement S\\<rbrakk>\n       \\<Longrightarrow> p = y", "obtain X where  ind_X: \"independent X\"\n    and X: \"X \\<subseteq> S\"\n    and span_X: \"S \\<subseteq> span X\"\n    and o: \"pairwise orthogonal X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>independent X; X \\<subseteq> S; S \\<subseteq> span X;\n         pairwise orthogonal X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis order_refl orthonormal_basis_subspace subspace_S)"], ["proof (state)\nthis:\n  independent X\n  X \\<subseteq> S\n  S \\<subseteq> span X\n  pairwise orthogonal X\n\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<in> S \\<and>\n       (\\<forall>y\\<in>S - {p}.\n           norm (v - p) < norm (v - y) \\<and>\n           v - p \\<in> orthogonal_complement S)\n 2. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S - {p}.\n           norm (v - p) < norm (v - y) \\<and>\n           v - p \\<in> orthogonal_complement S;\n        y \\<in> S;\n        \\<forall>ya\\<in>S - {y}.\n           norm (v - y) < norm (v - ya) \\<and>\n           v - y \\<in> orthogonal_complement S\\<rbrakk>\n       \\<Longrightarrow> p = y", "let ?p=\"sum (proj v) X\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>p.\n       p \\<in> S \\<and>\n       (\\<forall>y\\<in>S - {p}.\n           norm (v - p) < norm (v - y) \\<and>\n           v - p \\<in> orthogonal_complement S)\n 2. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S - {p}.\n           norm (v - p) < norm (v - y) \\<and>\n           v - p \\<in> orthogonal_complement S;\n        y \\<in> S;\n        \\<forall>ya\\<in>S - {y}.\n           norm (v - y) < norm (v - ya) \\<and>\n           v - y \\<in> orthogonal_complement S\\<rbrakk>\n       \\<Longrightarrow> p = y", "show \"\\<exists>p. p \\<in> S \\<and> (\\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y) \\<and> v - p \\<in> orthogonal_complement S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p \\<in> S \\<and>\n       (\\<forall>y\\<in>S - {p}.\n           norm (v - p) < norm (v - y) \\<and>\n           v - p \\<in> orthogonal_complement S)", "proof (rule exI[of _ ?p], rule conjI, rule subspace_sum)"], ["proof (state)\ngoal (3 subgoals):\n 1. subspace S\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> proj v x \\<in> S\n 3. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y) \\<and>\n       v - sum (proj v) X \\<in> orthogonal_complement S", "show \"subspace S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace S", "using subspace_S"], ["proof (prove)\nusing this:\n  subspace S\n\ngoal (1 subgoal):\n 1. subspace S", "."], ["proof (state)\nthis:\n  subspace S\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> proj v x \\<in> S\n 2. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y) \\<and>\n       v - sum (proj v) X \\<in> orthogonal_complement S", "show \"x \\<in> X \\<Longrightarrow> proj v x \\<in> S\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> proj v x \\<in> S", "by (simp add: Projections.proj_def X rev_subsetD subspace_S subspace_mul)"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> proj v ?x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y) \\<and>\n       v - sum (proj v) X \\<in> orthogonal_complement S", "have \"\\<forall>y\\<in>S - {?p}. norm (v - ?p) < norm (v - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y)", "using least_squares_approximation[OF subspace_S ind_X X span_X o]"], ["proof (prove)\nusing this:\n  \\<lbrakk>proj_onto ?v X \\<noteq> ?y; ?y \\<in> S\\<rbrakk>\n  \\<Longrightarrow> norm (?v - proj_onto ?v X) < norm (?v - ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y)", "unfolding proj_onto_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>sum (proj ?v) X \\<noteq> ?y; ?y \\<in> S\\<rbrakk>\n  \\<Longrightarrow> norm (?v - sum (proj ?v) X) < norm (?v - ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y)", "by (metis (no_types) member_remove remove_def)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>S - {sum (proj v) X}.\n     norm (v - sum (proj v) X) < norm (v - y)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y) \\<and>\n       v - sum (proj v) X \\<in> orthogonal_complement S", "moreover"], ["proof (state)\nthis:\n  \\<forall>y\\<in>S - {sum (proj v) X}.\n     norm (v - sum (proj v) X) < norm (v - y)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y) \\<and>\n       v - sum (proj v) X \\<in> orthogonal_complement S", "have \"v - ?p \\<in> orthogonal_complement S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - sum (proj v) X \\<in> orthogonal_complement S", "by (metis (no_types) X ind_X o span_X subspace_S v_minus_p_orthogonal_complement proj_onto_def)"], ["proof (state)\nthis:\n  v - sum (proj v) X \\<in> orthogonal_complement S\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y) \\<and>\n       v - sum (proj v) X \\<in> orthogonal_complement S", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>S - {sum (proj v) X}.\n     norm (v - sum (proj v) X) < norm (v - y)\n  v - sum (proj v) X \\<in> orthogonal_complement S", "show \"\\<forall>y\\<in>S - {?p}. norm (v - ?p) < norm (v - y) \\<and> v - ?p \\<in> orthogonal_complement S\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>S - {sum (proj v) X}.\n     norm (v - sum (proj v) X) < norm (v - y)\n  v - sum (proj v) X \\<in> orthogonal_complement S\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>S - {sum (proj v) X}.\n       norm (v - sum (proj v) X) < norm (v - y) \\<and>\n       v - sum (proj v) X \\<in> orthogonal_complement S", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>S - {sum (proj v) X}.\n     norm (v - sum (proj v) X) < norm (v - y) \\<and>\n     v - sum (proj v) X \\<in> orthogonal_complement S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p.\n     p \\<in> S \\<and>\n     (\\<forall>y\\<in>S - {p}.\n         norm (v - p) < norm (v - y) \\<and>\n         v - p \\<in> orthogonal_complement S)\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S - {p}.\n           norm (v - p) < norm (v - y) \\<and>\n           v - p \\<in> orthogonal_complement S;\n        y \\<in> S;\n        \\<forall>ya\\<in>S - {y}.\n           norm (v - y) < norm (v - ya) \\<and>\n           v - y \\<in> orthogonal_complement S\\<rbrakk>\n       \\<Longrightarrow> p = y", "fix p y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S - {p}.\n           norm (v - p) < norm (v - y) \\<and>\n           v - p \\<in> orthogonal_complement S;\n        y \\<in> S;\n        \\<forall>ya\\<in>S - {y}.\n           norm (v - y) < norm (v - ya) \\<and>\n           v - y \\<in> orthogonal_complement S\\<rbrakk>\n       \\<Longrightarrow> p = y", "assume p: \"p \\<in> S\" and p': \"\\<forall>y\\<in>S - {p}. norm (v - p) < norm (v - y) \\<and> v - p \\<in> orthogonal_complement S\"\n    and y: \"y \\<in> S\" and y': \"\\<forall>ya\\<in>S - {y}. norm (v - y) < norm (v - ya) \\<and> v - y \\<in> orthogonal_complement S\""], ["proof (state)\nthis:\n  p \\<in> S\n  \\<forall>y\\<in>S - {p}.\n     norm (v - p) < norm (v - y) \\<and> v - p \\<in> orthogonal_complement S\n  y \\<in> S\n  \\<forall>ya\\<in>S - {y}.\n     norm (v - y) < norm (v - ya) \\<and> v - y \\<in> orthogonal_complement S\n\ngoal (1 subgoal):\n 1. \\<And>p y.\n       \\<lbrakk>p \\<in> S;\n        \\<forall>y\\<in>S - {p}.\n           norm (v - p) < norm (v - y) \\<and>\n           v - p \\<in> orthogonal_complement S;\n        y \\<in> S;\n        \\<forall>ya\\<in>S - {y}.\n           norm (v - y) < norm (v - ya) \\<and>\n           v - y \\<in> orthogonal_complement S\\<rbrakk>\n       \\<Longrightarrow> p = y", "show \"p=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = y", "by (metis least_squares_approximation4 p p' subspace_S y y')"], ["proof (state)\nthis:\n  p = y\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary least_squares_approximation5':\n  fixes S::\"'a::{euclidean_space} set\"\n  assumes subspace_S: \"subspace S\"\n  shows \"\\<exists>!p\\<in>S. \\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y) \\<and> v-p \\<in> orthogonal_complement S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!p.\n       p \\<in> S \\<and>\n       (\\<forall>y\\<in>S.\n           norm (v - p) \\<le> norm (v - y) \\<and>\n           v - p \\<in> orthogonal_complement S)", "by (metis least_squares_approximation3 least_squares_approximation4' subspace_S)"], ["", "corollary least_squares_approximation6:\n  fixes S::\"'a::{euclidean_space} set\"\n  assumes subspace_S: \"subspace S\"\n  and \"p\\<in>S\"\n  and \"\\<forall>y\\<in>S. norm (v - p) \\<le> norm (v - y)\"\n  shows \"v-p \\<in> orthogonal_complement S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - p \\<in> orthogonal_complement S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v - p \\<in> orthogonal_complement S", "obtain a where a: \"a\\<in>S\" and a': \"\\<forall>y\\<in>S. norm (v - a) \\<le> norm (v - y) \\<and> v-a \\<in> orthogonal_complement S\"\n    and \"\\<forall>b. (b\\<in>S \\<and> (\\<forall>y\\<in>S. norm (v - b) \\<le> norm (v - y) \\<and> v-b \\<in> orthogonal_complement S)) \\<longrightarrow> b=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> S;\n         \\<forall>y\\<in>S.\n            norm (v - a) \\<le> norm (v - y) \\<and>\n            v - a \\<in> orthogonal_complement S;\n         \\<forall>b.\n            b \\<in> S \\<and>\n            (\\<forall>y\\<in>S.\n                norm (v - b) \\<le> norm (v - y) \\<and>\n                v - b \\<in> orthogonal_complement S) \\<longrightarrow>\n            b = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using least_squares_approximation5'[OF subspace_S]"], ["proof (prove)\nusing this:\n  \\<exists>!p.\n     p \\<in> S \\<and>\n     (\\<forall>y\\<in>S.\n         norm (?v - p) \\<le> norm (?v - y) \\<and>\n         ?v - p \\<in> orthogonal_complement S)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> S;\n         \\<forall>y\\<in>S.\n            norm (v - a) \\<le> norm (v - y) \\<and>\n            v - a \\<in> orthogonal_complement S;\n         \\<forall>b.\n            b \\<in> S \\<and>\n            (\\<forall>y\\<in>S.\n                norm (v - b) \\<le> norm (v - y) \\<and>\n                v - b \\<in> orthogonal_complement S) \\<longrightarrow>\n            b = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  a \\<in> S\n  \\<forall>y\\<in>S.\n     norm (v - a) \\<le> norm (v - y) \\<and>\n     v - a \\<in> orthogonal_complement S\n  \\<forall>b.\n     b \\<in> S \\<and>\n     (\\<forall>y\\<in>S.\n         norm (v - b) \\<le> norm (v - y) \\<and>\n         v - b \\<in> orthogonal_complement S) \\<longrightarrow>\n     b = a\n\ngoal (1 subgoal):\n 1. v - p \\<in> orthogonal_complement S", "have \"p=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = a", "by (metis a a' assms(2) assms(3) least_squares_approximation4' subspace_S)"], ["proof (state)\nthis:\n  p = a\n\ngoal (1 subgoal):\n 1. v - p \\<in> orthogonal_complement S", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = a\n\ngoal (1 subgoal):\n 1. v - p \\<in> orthogonal_complement S", "using a'"], ["proof (prove)\nusing this:\n  p = a\n  \\<forall>y\\<in>S.\n     norm (v - a) \\<le> norm (v - y) \\<and>\n     v - a \\<in> orthogonal_complement S\n\ngoal (1 subgoal):\n 1. v - p \\<in> orthogonal_complement S", "by (metis assms(2))"], ["proof (state)\nthis:\n  v - p \\<in> orthogonal_complement S\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary least_squares_approximation7:\n  fixes S::\"'a::{euclidean_space} set\"\n  assumes subspace_S: \"subspace S\"\n  and \"v - p \\<in> orthogonal_complement S\"\n  and \"p\\<in>S\"\n  and \"y \\<in> S\"\n  shows \"norm (v - p) \\<le> norm (v - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (v - p) \\<le> norm (v - y)", "proof (cases \"y=p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = p \\<Longrightarrow> norm (v - p) \\<le> norm (v - y)\n 2. y \\<noteq> p \\<Longrightarrow> norm (v - p) \\<le> norm (v - y)", "case True"], ["proof (state)\nthis:\n  y = p\n\ngoal (2 subgoals):\n 1. y = p \\<Longrightarrow> norm (v - p) \\<le> norm (v - y)\n 2. y \\<noteq> p \\<Longrightarrow> norm (v - p) \\<le> norm (v - y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = p\n\ngoal (1 subgoal):\n 1. norm (v - p) \\<le> norm (v - y)", "by simp"], ["proof (state)\nthis:\n  norm (v - p) \\<le> norm (v - y)\n\ngoal (1 subgoal):\n 1. y \\<noteq> p \\<Longrightarrow> norm (v - p) \\<le> norm (v - y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> p \\<Longrightarrow> norm (v - p) \\<le> norm (v - y)", "case False"], ["proof (state)\nthis:\n  y \\<noteq> p\n\ngoal (1 subgoal):\n 1. y \\<noteq> p \\<Longrightarrow> norm (v - p) \\<le> norm (v - y)", "have \"norm (v - y)^2 = norm ((v - p) + (p - y))^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (v - y))\\<^sup>2 = (norm (v - p + (p - y)))\\<^sup>2", "by (metis (hide_lams, no_types) add_diff_cancel_left add_ac(1) add_diff_add add_diff_cancel)"], ["proof (state)\nthis:\n  (norm (v - y))\\<^sup>2 = (norm (v - p + (p - y)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. y \\<noteq> p \\<Longrightarrow> norm (v - p) \\<le> norm (v - y)", "also"], ["proof (state)\nthis:\n  (norm (v - y))\\<^sup>2 = (norm (v - p + (p - y)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. y \\<noteq> p \\<Longrightarrow> norm (v - p) \\<le> norm (v - y)", "have \"... = norm (v - p)^2 + norm (p - y)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (v - p + (p - y)))\\<^sup>2 =\n    (norm (v - p))\\<^sup>2 + (norm (p - y))\\<^sup>2", "proof (rule phytagorean_theorem_norm, rule in_orthogonal_complement_imp_orthogonal)"], ["proof (state)\ngoal (2 subgoals):\n 1. p - y \\<in> ?S2\n 2. v - p \\<in> orthogonal_complement ?S2", "show \"p - y \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - y \\<in> S", "by (metis assms(3) assms(4) subspace_S subspace_diff)"], ["proof (state)\nthis:\n  p - y \\<in> S\n\ngoal (1 subgoal):\n 1. v - p \\<in> orthogonal_complement S", "show \"v - p \\<in> orthogonal_complement S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - p \\<in> orthogonal_complement S", "by (metis assms(2))"], ["proof (state)\nthis:\n  v - p \\<in> orthogonal_complement S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (norm (v - p + (p - y)))\\<^sup>2 =\n  (norm (v - p))\\<^sup>2 + (norm (p - y))\\<^sup>2\n\ngoal (1 subgoal):\n 1. y \\<noteq> p \\<Longrightarrow> norm (v - p) \\<le> norm (v - y)", "finally"], ["proof (chain)\npicking this:\n  (norm (v - y))\\<^sup>2 = (norm (v - p))\\<^sup>2 + (norm (p - y))\\<^sup>2", "have \"norm (v - p)^2 \\<le> norm (v - y)^2\""], ["proof (prove)\nusing this:\n  (norm (v - y))\\<^sup>2 = (norm (v - p))\\<^sup>2 + (norm (p - y))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (norm (v - p))\\<^sup>2 \\<le> (norm (v - y))\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  (norm (v - p))\\<^sup>2 \\<le> (norm (v - y))\\<^sup>2\n\ngoal (1 subgoal):\n 1. y \\<noteq> p \\<Longrightarrow> norm (v - p) \\<le> norm (v - y)", "thus \"norm (v - p)\\<le> norm (v - y)\""], ["proof (prove)\nusing this:\n  (norm (v - p))\\<^sup>2 \\<le> (norm (v - y))\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm (v - p) \\<le> norm (v - y)", "by (metis norm_ge_zero power2_le_imp_le)"], ["proof (state)\nthis:\n  norm (v - p) \\<le> norm (v - y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_least_squares_approximation:\n  fixes A::\"real^'cols::{finite, wellorder}^'rows\"\n  assumes o: \"A *v x - b \\<in> orthogonal_complement (col_space A)\"\n  shows \"(x \\<in> set_least_squares_approximation A b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set_least_squares_approximation A b", "proof (unfold set_least_squares_approximation_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. norm (b - A *v x) \\<le> norm (b - A *v y)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. norm (b - A *v x) \\<le> norm (b - A *v y)", "show \" norm (b - A *v x) \\<le> norm (b - A *v y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (b - A *v x) \\<le> norm (b - A *v y)", "proof (rule least_squares_approximation7)"], ["proof (state)\ngoal (4 subgoals):\n 1. subspace ?S\n 2. b - A *v x \\<in> orthogonal_complement ?S\n 3. A *v x \\<in> ?S\n 4. A *v y \\<in> ?S", "show \"subspace (col_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace (col_space A)", "using subspace_col_space[of A, unfolded subspace_vec_eq]"], ["proof (prove)\nusing this:\n  subspace (col_space A)\n\ngoal (1 subgoal):\n 1. subspace (col_space A)", "."], ["proof (state)\nthis:\n  subspace (col_space A)\n\ngoal (3 subgoals):\n 1. b - A *v x \\<in> orthogonal_complement (col_space A)\n 2. A *v x \\<in> col_space A\n 3. A *v y \\<in> col_space A", "show \"b - A *v x \\<in> orthogonal_complement (col_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b - A *v x \\<in> orthogonal_complement (col_space A)", "using o subspace_orthogonal_complement[of \"(col_space A)\"]"], ["proof (prove)\nusing this:\n  A *v x - b \\<in> orthogonal_complement (col_space A)\n  subspace (orthogonal_complement (col_space A))\n\ngoal (1 subgoal):\n 1. b - A *v x \\<in> orthogonal_complement (col_space A)", "using minus_diff_eq subspace_neg"], ["proof (prove)\nusing this:\n  A *v x - b \\<in> orthogonal_complement (col_space A)\n  subspace (orthogonal_complement (col_space A))\n  - (?a - ?b) = ?b - ?a\n  \\<lbrakk>subspace ?S; ?x \\<in> ?S\\<rbrakk> \\<Longrightarrow> - ?x \\<in> ?S\n\ngoal (1 subgoal):\n 1. b - A *v x \\<in> orthogonal_complement (col_space A)", "by metis"], ["proof (state)\nthis:\n  b - A *v x \\<in> orthogonal_complement (col_space A)\n\ngoal (2 subgoals):\n 1. A *v x \\<in> col_space A\n 2. A *v y \\<in> col_space A", "show \"A *v x \\<in> col_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v x \\<in> col_space A", "unfolding col_space_eq[of A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v x \\<in> {y. \\<exists>x. A *v x = y}", "by auto"], ["proof (state)\nthis:\n  A *v x \\<in> col_space A\n\ngoal (1 subgoal):\n 1. A *v y \\<in> col_space A", "show \"A *v y \\<in> col_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v y \\<in> col_space A", "unfolding col_space_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v y \\<in> {y. \\<exists>x. A *v x = y}", "by auto"], ["proof (state)\nthis:\n  A *v y \\<in> col_space A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (b - A *v x) \\<le> norm (b - A *v y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_least_squares_approximation_eq:\n  fixes A::\"real^'cols::{finite,wellorder}^'rows\"\n  shows \"(x \\<in> set_least_squares_approximation A b) = (transpose A ** A *v x = transpose A *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (Finite_Cartesian_Product.transpose A ** A *v x =\n     Finite_Cartesian_Product.transpose A *v b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set_least_squares_approximation A b \\<Longrightarrow>\n    Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b\n 2. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "assume x: \"x \\<in> set_least_squares_approximation A b\""], ["proof (state)\nthis:\n  x \\<in> set_least_squares_approximation A b\n\ngoal (2 subgoals):\n 1. x \\<in> set_least_squares_approximation A b \\<Longrightarrow>\n    Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b\n 2. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "hence a: \"\\<forall>a. norm (b - A *v x) \\<le> norm (b - A *v a)\""], ["proof (prove)\nusing this:\n  x \\<in> set_least_squares_approximation A b\n\ngoal (1 subgoal):\n 1. \\<forall>a. norm (b - A *v x) \\<le> norm (b - A *v a)", "unfolding set_least_squares_approximation_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. \\<forall>y. norm (b - A *v x) \\<le> norm (b - A *v y)}\n\ngoal (1 subgoal):\n 1. \\<forall>a. norm (b - A *v x) \\<le> norm (b - A *v a)", "by simp"], ["proof (state)\nthis:\n  \\<forall>a. norm (b - A *v x) \\<le> norm (b - A *v a)\n\ngoal (2 subgoals):\n 1. x \\<in> set_least_squares_approximation A b \\<Longrightarrow>\n    Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b\n 2. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "have \"b - A *v x \\<in> orthogonal_complement (col_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b - A *v x \\<in> orthogonal_complement (col_space A)", "proof (rule least_squares_approximation6)"], ["proof (state)\ngoal (3 subgoals):\n 1. subspace (col_space A)\n 2. A *v x \\<in> col_space A\n 3. \\<forall>y\\<in>col_space A. norm (b - A *v x) \\<le> norm (b - y)", "show \"subspace (col_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace (col_space A)", "using subspace_col_space[of A, unfolded subspace_vec_eq]"], ["proof (prove)\nusing this:\n  subspace (col_space A)\n\ngoal (1 subgoal):\n 1. subspace (col_space A)", "."], ["proof (state)\nthis:\n  subspace (col_space A)\n\ngoal (2 subgoals):\n 1. A *v x \\<in> col_space A\n 2. \\<forall>y\\<in>col_space A. norm (b - A *v x) \\<le> norm (b - y)", "show \"A *v x \\<in> col_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v x \\<in> col_space A", "unfolding col_space_eq[of A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v x \\<in> {y. \\<exists>x. A *v x = y}", "by auto"], ["proof (state)\nthis:\n  A *v x \\<in> col_space A\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>col_space A. norm (b - A *v x) \\<le> norm (b - y)", "show \"\\<forall>y\\<in>col_space A. norm (b - A *v x) \\<le> norm (b - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>col_space A. norm (b - A *v x) \\<le> norm (b - y)", "using a"], ["proof (prove)\nusing this:\n  \\<forall>a. norm (b - A *v x) \\<le> norm (b - A *v a)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>col_space A. norm (b - A *v x) \\<le> norm (b - y)", "unfolding col_space_eq"], ["proof (prove)\nusing this:\n  \\<forall>a. norm (b - A *v x) \\<le> norm (b - A *v a)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>{y. \\<exists>x. A *v x = y}.\n       norm (b - A *v x) \\<le> norm (b - y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>col_space A. norm (b - A *v x) \\<le> norm (b - y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b - A *v x \\<in> orthogonal_complement (col_space A)\n\ngoal (2 subgoals):\n 1. x \\<in> set_least_squares_approximation A b \\<Longrightarrow>\n    Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b\n 2. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "hence \"b - A *v x \\<in> null_space (transpose A)\""], ["proof (prove)\nusing this:\n  b - A *v x \\<in> orthogonal_complement (col_space A)\n\ngoal (1 subgoal):\n 1. b - A *v x \\<in> null_space (Finite_Cartesian_Product.transpose A)", "unfolding null_space_orthogonal_complement_row_space"], ["proof (prove)\nusing this:\n  b - A *v x \\<in> orthogonal_complement (col_space A)\n\ngoal (1 subgoal):\n 1. b - A *v x\n    \\<in> orthogonal_complement\n           (row_space (Finite_Cartesian_Product.transpose A))", "unfolding col_space_eq_row_space_transpose"], ["proof (prove)\nusing this:\n  b - A *v x\n  \\<in> orthogonal_complement\n         (row_space (Finite_Cartesian_Product.transpose A))\n\ngoal (1 subgoal):\n 1. b - A *v x\n    \\<in> orthogonal_complement\n           (row_space (Finite_Cartesian_Product.transpose A))", "."], ["proof (state)\nthis:\n  b - A *v x \\<in> null_space (Finite_Cartesian_Product.transpose A)\n\ngoal (2 subgoals):\n 1. x \\<in> set_least_squares_approximation A b \\<Longrightarrow>\n    Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b\n 2. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "hence \"transpose A *v (b - A *v x) = 0\""], ["proof (prove)\nusing this:\n  b - A *v x \\<in> null_space (Finite_Cartesian_Product.transpose A)\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A *v (b - A *v x) = 0", "unfolding null_space_def"], ["proof (prove)\nusing this:\n  b - A *v x \\<in> {x. Finite_Cartesian_Product.transpose A *v x = 0}\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A *v (b - A *v x) = 0", "by simp"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose A *v (b - A *v x) = 0\n\ngoal (2 subgoals):\n 1. x \\<in> set_least_squares_approximation A b \\<Longrightarrow>\n    Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b\n 2. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "thus \"(transpose A ** A) *v x = (transpose A) *v b\""], ["proof (prove)\nusing this:\n  Finite_Cartesian_Product.transpose A *v (b - A *v x) = 0\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b", "by (metis eq_iff_diff_eq_0 matrix_vector_mul_assoc matrix_vector_right_distrib_minus)"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose A ** A *v x =\n  Finite_Cartesian_Product.transpose A *v b\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "assume \"transpose A ** A *v x = transpose A *v b\""], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose A ** A *v x =\n  Finite_Cartesian_Product.transpose A *v b\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "hence \"(transpose A) *v (A *v x - b) = 0\""], ["proof (prove)\nusing this:\n  Finite_Cartesian_Product.transpose A ** A *v x =\n  Finite_Cartesian_Product.transpose A *v b\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A *v (A *v x - b) = 0", "by (metis diff_self matrix_vector_mul_assoc matrix_vector_right_distrib_minus)"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose A *v (A *v x - b) = 0\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "hence \"(A *v x - b) \\<in> null_space (transpose A)\""], ["proof (prove)\nusing this:\n  Finite_Cartesian_Product.transpose A *v (A *v x - b) = 0\n\ngoal (1 subgoal):\n 1. A *v x - b \\<in> null_space (Finite_Cartesian_Product.transpose A)", "unfolding null_space_def"], ["proof (prove)\nusing this:\n  Finite_Cartesian_Product.transpose A *v (A *v x - b) = 0\n\ngoal (1 subgoal):\n 1. A *v x - b \\<in> {x. Finite_Cartesian_Product.transpose A *v x = 0}", "by simp"], ["proof (state)\nthis:\n  A *v x - b \\<in> null_space (Finite_Cartesian_Product.transpose A)\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "hence \"(A *v x - b) \\<in> orthogonal_complement (col_space A)\""], ["proof (prove)\nusing this:\n  A *v x - b \\<in> null_space (Finite_Cartesian_Product.transpose A)\n\ngoal (1 subgoal):\n 1. A *v x - b \\<in> orthogonal_complement (col_space A)", "by (metis left_null_space_eq_null_space_transpose left_null_space_orthogonal_complement_col_space)"], ["proof (state)\nthis:\n  A *v x - b \\<in> orthogonal_complement (col_space A)\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "thus \"x \\<in> set_least_squares_approximation A b\""], ["proof (prove)\nusing this:\n  A *v x - b \\<in> orthogonal_complement (col_space A)\n\ngoal (1 subgoal):\n 1. x \\<in> set_least_squares_approximation A b", "by (rule in_set_least_squares_approximation)"], ["proof (state)\nthis:\n  x \\<in> set_least_squares_approximation A b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_least_squares_approximation_eq_full_rank:\n  fixes A::\"real^'cols::mod_type^'rows::mod_type\"\n  assumes r: \"rank A = ncols A\"\n  shows \"(x \\<in> set_least_squares_approximation A b) = (x = matrix_inv (transpose A ** A)**transpose A *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n     Finite_Cartesian_Product.transpose A *v\n     b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n     Finite_Cartesian_Product.transpose A *v\n     b)", "have int_tA: \"invertible (transpose A ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "using invertible_transpose_mult[OF r]"], ["proof (prove)\nusing this:\n  invertible (Finite_Cartesian_Product.transpose A ** A)\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.transpose A ** A)", "."], ["proof (state)\nthis:\n  invertible (Finite_Cartesian_Product.transpose A ** A)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n     Finite_Cartesian_Product.transpose A *v\n     b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n     Finite_Cartesian_Product.transpose A *v\n     b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set_least_squares_approximation A b \\<Longrightarrow>\n    x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b\n 2. x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set_least_squares_approximation A b \\<Longrightarrow>\n    x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b\n 2. x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "assume \"x \\<in> set_least_squares_approximation A b\""], ["proof (state)\nthis:\n  x \\<in> set_least_squares_approximation A b\n\ngoal (2 subgoals):\n 1. x \\<in> set_least_squares_approximation A b \\<Longrightarrow>\n    x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b\n 2. x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "hence \"transpose A ** A *v x = transpose A *v b\""], ["proof (prove)\nusing this:\n  x \\<in> set_least_squares_approximation A b\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b", "using in_set_least_squares_approximation_eq"], ["proof (prove)\nusing this:\n  x \\<in> set_least_squares_approximation A b\n  (?x \\<in> set_least_squares_approximation ?A ?b) =\n  (Finite_Cartesian_Product.transpose ?A ** ?A *v ?x =\n   Finite_Cartesian_Product.transpose ?A *v ?b)\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b", "by auto"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose A ** A *v x =\n  Finite_Cartesian_Product.transpose A *v b\n\ngoal (2 subgoals):\n 1. x \\<in> set_least_squares_approximation A b \\<Longrightarrow>\n    x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b\n 2. x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "thus \"x = matrix_inv (transpose A ** A) ** transpose A *v b\""], ["proof (prove)\nusing this:\n  Finite_Cartesian_Product.transpose A ** A *v x =\n  Finite_Cartesian_Product.transpose A *v b\n\ngoal (1 subgoal):\n 1. x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b", "by (metis int_tA matrix_inv_left matrix_vector_mul_assoc matrix_vector_mul_lid)"], ["proof (state)\nthis:\n  x =\n  matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n  Finite_Cartesian_Product.transpose A *v\n  b\n\ngoal (1 subgoal):\n 1. x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "assume \"x = matrix_inv (transpose A ** A) ** transpose A *v b\""], ["proof (state)\nthis:\n  x =\n  matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n  Finite_Cartesian_Product.transpose A *v\n  b\n\ngoal (1 subgoal):\n 1. x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "hence \"transpose A ** A *v x = transpose A *v b\""], ["proof (prove)\nusing this:\n  x =\n  matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n  Finite_Cartesian_Product.transpose A *v\n  b\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b", "by (metis int_tA matrix_inv_right matrix_vector_mul_assoc matrix_vector_mul_lid)"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose A ** A *v x =\n  Finite_Cartesian_Product.transpose A *v b\n\ngoal (1 subgoal):\n 1. x =\n    matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n    Finite_Cartesian_Product.transpose A *v\n    b \\<Longrightarrow>\n    x \\<in> set_least_squares_approximation A b", "thus \"x \\<in> set_least_squares_approximation A b\""], ["proof (prove)\nusing this:\n  Finite_Cartesian_Product.transpose A ** A *v x =\n  Finite_Cartesian_Product.transpose A *v b\n\ngoal (1 subgoal):\n 1. x \\<in> set_least_squares_approximation A b", "unfolding in_set_least_squares_approximation_eq"], ["proof (prove)\nusing this:\n  Finite_Cartesian_Product.transpose A ** A *v x =\n  Finite_Cartesian_Product.transpose A *v b\n\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose A ** A *v x =\n    Finite_Cartesian_Product.transpose A *v b", "."], ["proof (state)\nthis:\n  x \\<in> set_least_squares_approximation A b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> set_least_squares_approximation A b) =\n  (x =\n   matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n   Finite_Cartesian_Product.transpose A *v\n   b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_least_squares_approximation_eq_full_rank_QR:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"(x \\<in> set_least_squares_approximation A b) = ((snd (QR_decomposition A)) *v x = transpose (fst (QR_decomposition A)) *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "let ?Q = \"fst (QR_decomposition A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "let ?R = \"snd (QR_decomposition A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "have inv_tR: \"invertible (transpose ?R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)))", "by (metis invertible_snd_QR_decomposition invertible_transpose r)"], ["proof (state)\nthis:\n  invertible (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)))\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "have inv_inv_tR: \"invertible (matrix_inv (transpose ?R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (matrix_inv\n       (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))))", "by (metis inv_tR invertible_fst_Gauss_Jordan_PA matrix_inv_Gauss_Jordan_PA)"], ["proof (state)\nthis:\n  invertible\n   (matrix_inv\n     (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))))\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "have \"(x \\<in> set_least_squares_approximation A b) = (transpose A ** A *v x = transpose A *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (Finite_Cartesian_Product.transpose A ** A *v x =\n     Finite_Cartesian_Product.transpose A *v b)", "using in_set_least_squares_approximation_eq"], ["proof (prove)\nusing this:\n  (?x \\<in> set_least_squares_approximation ?A ?b) =\n  (Finite_Cartesian_Product.transpose ?A ** ?A *v ?x =\n   Finite_Cartesian_Product.transpose ?A *v ?b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (Finite_Cartesian_Product.transpose A ** A *v x =\n     Finite_Cartesian_Product.transpose A *v b)", "."], ["proof (state)\nthis:\n  (x \\<in> set_least_squares_approximation A b) =\n  (Finite_Cartesian_Product.transpose A ** A *v x =\n   Finite_Cartesian_Product.transpose A *v b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "also"], ["proof (state)\nthis:\n  (x \\<in> set_least_squares_approximation A b) =\n  (Finite_Cartesian_Product.transpose A ** A *v x =\n   Finite_Cartesian_Product.transpose A *v b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "have \"... = (transpose (?Q ** ?R) ** (?Q ** ?R) *v x = transpose (?Q ** ?R) *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A ** A *v x =\n     Finite_Cartesian_Product.transpose A *v b) =\n    (Finite_Cartesian_Product.transpose\n      (fst (QR_decomposition A) ** snd (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x =\n     Finite_Cartesian_Product.transpose\n      (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     b)", "using QR_decomposition_mult[OF r]"], ["proof (prove)\nusing this:\n  A = fst (QR_decomposition A) ** snd (QR_decomposition A)\n\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose A ** A *v x =\n     Finite_Cartesian_Product.transpose A *v b) =\n    (Finite_Cartesian_Product.transpose\n      (fst (QR_decomposition A) ** snd (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x =\n     Finite_Cartesian_Product.transpose\n      (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     b)", "by simp"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A ** A *v x =\n   Finite_Cartesian_Product.transpose A *v b) =\n  (Finite_Cartesian_Product.transpose\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) **\n   (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   x =\n   Finite_Cartesian_Product.transpose\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "also"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose A ** A *v x =\n   Finite_Cartesian_Product.transpose A *v b) =\n  (Finite_Cartesian_Product.transpose\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) **\n   (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   x =\n   Finite_Cartesian_Product.transpose\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "have \"... = (transpose ?R ** transpose ?Q **  (?Q ** ?R) *v x  = transpose ?R ** transpose ?Q *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose\n      (fst (QR_decomposition A) ** snd (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x =\n     Finite_Cartesian_Product.transpose\n      (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     b) =\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x =\n     Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "by (metis (hide_lams, no_types) matrix_transpose_mul)"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) **\n   (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   x =\n   Finite_Cartesian_Product.transpose\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   b) =\n  (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n   (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   x =\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n   b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "also"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) **\n   (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   x =\n   Finite_Cartesian_Product.transpose\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   b) =\n  (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n   (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   x =\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n   b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "have \"... = (transpose ?R *v (transpose ?Q ** (?Q ** ?R) *v x)  = transpose ?R *v (transpose ?Q *v b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x =\n     Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b) =\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n     (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n      (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n      x) =\n     Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n     (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b))", "by (metis (hide_lams, no_types) matrix_vector_mul_assoc)"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n   (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   x =\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n   b) =\n  (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n    x) =\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b))\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "also"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n   (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   x =\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n   b) =\n  (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n    x) =\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b))\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "have \"... = (matrix_inv (transpose ?R) *v (transpose ?R *v (transpose ?Q ** (?Q ** ?R) *v x))  \n    = matrix_inv (transpose ?R) *v (transpose ?R *v (transpose ?Q *v b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n     (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n      (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n      x) =\n     Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n     (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)) =\n    (matrix_inv\n      (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n     (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n      (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n       (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n       x)) =\n     matrix_inv\n      (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n     (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n      (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)))", "using inv_matrix_vector_mul_left[OF inv_inv_tR]"], ["proof (prove)\nusing this:\n  (matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n   ?x =\n   matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n   ?y) =\n  (?x = ?y)\n\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n     (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n      (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n      x) =\n     Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n     (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)) =\n    (matrix_inv\n      (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n     (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n      (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n       (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n       x)) =\n     matrix_inv\n      (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n     (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n      (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)))", "by auto"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n    x) =\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)) =\n  (matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n   (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n    (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x)) =\n   matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n   (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n    (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)))\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "also"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n    x) =\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)) =\n  (matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n   (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n    (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x)) =\n   matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n   (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n    (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)))\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "have \"... = ((matrix_inv (transpose ?R) ** transpose ?R) *v (transpose ?Q ** (?Q ** ?R) *v x)  \n    = (matrix_inv (transpose ?R) ** transpose ?R) *v (transpose ?Q *v b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (matrix_inv\n      (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n     (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n      (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n       (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n       x)) =\n     matrix_inv\n      (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n     (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n      (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n       b))) =\n    (matrix_inv\n      (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) **\n     Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n     (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n      (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n      x) =\n     matrix_inv\n      (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) **\n     Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n     (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b))", "by (metis (hide_lams, no_types) matrix_vector_mul_assoc)"], ["proof (state)\nthis:\n  (matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n   (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n    (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x)) =\n   matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n   (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n    (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b))) =\n  (matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) **\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n    x) =\n   matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) **\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b))\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "also"], ["proof (state)\nthis:\n  (matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n   (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n    (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x)) =\n   matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) *v\n   (Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n    (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b))) =\n  (matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) **\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n    x) =\n   matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) **\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b))\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "have \"... = (transpose ?Q ** (?Q ** ?R) *v x = transpose ?Q *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (matrix_inv\n      (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) **\n     Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n     (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n      (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n      x) =\n     matrix_inv\n      (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) **\n     Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n     (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)) =\n    (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "unfolding matrix_inv_left[OF inv_tR]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat 1 *v\n     (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n      (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n      x) =\n     mat 1 *v\n     (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)) =\n    (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "unfolding matrix_vector_mul_lid"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b) =\n    (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", ".."], ["proof (state)\nthis:\n  (matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) **\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n    x) =\n   matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) **\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)) =\n  (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n   (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "also"], ["proof (state)\nthis:\n  (matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) **\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n    (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n    x) =\n   matrix_inv\n    (Finite_Cartesian_Product.transpose (snd (QR_decomposition A))) **\n   Finite_Cartesian_Product.transpose (snd (QR_decomposition A)) *v\n   (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)) =\n  (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n   (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "have \"... = ((transpose ?Q ** ?Q) ** ?R *v x = transpose ?Q *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n     x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b) =\n    (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     fst (QR_decomposition A) **\n     snd (QR_decomposition A) *v\n     x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "by (metis (hide_lams, no_types) matrix_mul_assoc)"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n   (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b) =\n  (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n   fst (QR_decomposition A) **\n   snd (QR_decomposition A) *v\n   x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "also"], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n   (fst (QR_decomposition A) ** snd (QR_decomposition A)) *v\n   x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b) =\n  (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n   fst (QR_decomposition A) **\n   snd (QR_decomposition A) *v\n   x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "have \"... = (?R *v x = transpose ?Q *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n     fst (QR_decomposition A) **\n     snd (QR_decomposition A) *v\n     x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "unfolding orthogonal_matrix_fst_QR_decomposition[OF r]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat 1 ** snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "unfolding matrix_mul_lid"], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", ".."], ["proof (state)\nthis:\n  (Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) **\n   fst (QR_decomposition A) **\n   snd (QR_decomposition A) *v\n   x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b) =\n  (snd (QR_decomposition A) *v x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "finally"], ["proof (chain)\npicking this:\n  (x \\<in> set_least_squares_approximation A b) =\n  (snd (QR_decomposition A) *v x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "show \"(x \\<in> set_least_squares_approximation A b) = (?R *v x = (transpose ?Q) *v b)\""], ["proof (prove)\nusing this:\n  (x \\<in> set_least_squares_approximation A b) =\n  (snd (QR_decomposition A) *v x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "."], ["proof (state)\nthis:\n  (x \\<in> set_least_squares_approximation A b) =\n  (snd (QR_decomposition A) *v x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*TODO: Maybe demonstrate that in this case there's only one solution.*)"], ["", "corollary in_set_least_squares_approximation_eq_full_rank_QR2:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"(x \\<in> set_least_squares_approximation A b) = (x = matrix_inv (snd (QR_decomposition A)) ** transpose (fst (QR_decomposition A)) *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "let ?Q = \"fst (QR_decomposition A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "let ?R = \"snd (QR_decomposition A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "have inv_R: \"invertible ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (snd (QR_decomposition A))", "by (metis invertible_snd_QR_decomposition r)"], ["proof (state)\nthis:\n  invertible (snd (QR_decomposition A))\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "have \"(x \\<in> set_least_squares_approximation A b) = (?R *v x = transpose ?Q *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "using in_set_least_squares_approximation_eq_full_rank_QR[OF r]"], ["proof (prove)\nusing this:\n  (?x \\<in> set_least_squares_approximation A ?b) =\n  (snd (QR_decomposition A) *v ?x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v ?b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)", "."], ["proof (state)\nthis:\n  (x \\<in> set_least_squares_approximation A b) =\n  (snd (QR_decomposition A) *v x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "also"], ["proof (state)\nthis:\n  (x \\<in> set_least_squares_approximation A b) =\n  (snd (QR_decomposition A) *v x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "have \"... = (matrix_inv ?R ** ?R *v x = matrix_inv ?R ** transpose ?Q *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd (QR_decomposition A) *v x =\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b) =\n    (matrix_inv (snd (QR_decomposition A)) ** snd (QR_decomposition A) *v\n     x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "by (metis (hide_lams, no_types) Gauss_Jordan_PA_eq calculation fst_Gauss_Jordan_PA inv_R \n      inv_matrix_vector_mul_left invertible_fst_Gauss_Jordan_PA matrix_inv_Gauss matrix_vector_mul_assoc)"], ["proof (state)\nthis:\n  (snd (QR_decomposition A) *v x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b) =\n  (matrix_inv (snd (QR_decomposition A)) ** snd (QR_decomposition A) *v x =\n   matrix_inv (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n   b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "also"], ["proof (state)\nthis:\n  (snd (QR_decomposition A) *v x =\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v b) =\n  (matrix_inv (snd (QR_decomposition A)) ** snd (QR_decomposition A) *v x =\n   matrix_inv (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n   b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "have \"... = (x = matrix_inv ?R ** transpose ?Q *v b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (matrix_inv (snd (QR_decomposition A)) ** snd (QR_decomposition A) *v\n     x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b) =\n    (x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "by (metis inv_R matrix_inv_left matrix_vector_mul_lid)"], ["proof (state)\nthis:\n  (matrix_inv (snd (QR_decomposition A)) ** snd (QR_decomposition A) *v x =\n   matrix_inv (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n   b) =\n  (x =\n   matrix_inv (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n   b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "finally"], ["proof (chain)\npicking this:\n  (x \\<in> set_least_squares_approximation A b) =\n  (x =\n   matrix_inv (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n   b)", "show \"(x \\<in> set_least_squares_approximation A b) = (x = matrix_inv ?R ** transpose ?Q *v b)\""], ["proof (prove)\nusing this:\n  (x \\<in> set_least_squares_approximation A b) =\n  (x =\n   matrix_inv (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n   b)\n\ngoal (1 subgoal):\n 1. (x \\<in> set_least_squares_approximation A b) =\n    (x =\n     matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b)", "."], ["proof (state)\nthis:\n  (x \\<in> set_least_squares_approximation A b) =\n  (x =\n   matrix_inv (snd (QR_decomposition A)) **\n   Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n   b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_least_squares_approximation_unique_solution:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"(set_least_squares_approximation A b) = {matrix_inv (transpose A ** A)**transpose A *v b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_least_squares_approximation A b =\n    {matrix_inv (Finite_Cartesian_Product.transpose A ** A) **\n     Finite_Cartesian_Product.transpose A *v\n     b}", "by (metis (hide_lams, mono_tags) empty_iff in_set_least_squares_approximation_eq_full_rank\n    empty_iff insertI1 r subsetI subset_singletonD)"], ["", "lemma set_least_squares_approximation_unique_solution_QR:\n  fixes A::\"real^'cols::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"rank A = ncols A\"\n  shows \"(set_least_squares_approximation A b) = {matrix_inv (snd (QR_decomposition A)) ** transpose (fst (QR_decomposition A)) *v b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_least_squares_approximation A b =\n    {matrix_inv (snd (QR_decomposition A)) **\n     Finite_Cartesian_Product.transpose (fst (QR_decomposition A)) *v\n     b}", "by (metis (hide_lams, mono_tags) empty_iff in_set_least_squares_approximation_eq_full_rank_QR2 insertI1 r subsetI subset_singletonD)"], ["", "end"]]}