{"file_name": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition/IArray_Addenda_QR.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/QR_Decomposition", "problem_names": ["lemma iarray_exhaust2: \n  \"(xs = ys) = (IArray.list_of xs = IArray.list_of ys)\"", "lemma of_fun_nth:\n  assumes i: \"i<n\"\n  shows \"(IArray.of_fun f n) !! i = f i\""], "translations": [["", "lemma iarray_exhaust2: \n  \"(xs = ys) = (IArray.list_of xs = IArray.list_of ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = ys) = (IArray.list_of xs = IArray.list_of ys)", "by (metis iarray.exhaust list_of.simps)"], ["", "lemma of_fun_nth:\n  assumes i: \"i<n\"\n  shows \"(IArray.of_fun f n) !! i = f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun f n !! i = f i", "unfolding IArray.of_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray (map f [0..<n]) !! i = f i", "using map_nth i"], ["proof (prove)\nusing this:\n  map ((!) ?xs) [0..<length ?xs] = ?xs\n  i < n\n\ngoal (1 subgoal):\n 1. IArray (map f [0..<n]) !! i = f i", "by auto"], ["", "subsection\\<open>Some previous instances\\<close>"], ["", "instantiation iarray :: (\"{plus,zero}\") plus\nbegin"], ["", "definition plus_iarray :: \"'a iarray \\<Rightarrow> 'a iarray \\<Rightarrow> 'a iarray\"\n  where \"plus_iarray A B = \n  (let length_A = (IArray.length A);\n  length_B= (IArray.length B);\n  n=max length_A length_B ; \n  A'= IArray.of_fun (\\<lambda>a. if a < length_A then A!!a else 0) n;\n  B'=IArray.of_fun (\\<lambda>a. if a < length_B then B!!a else 0) n\n  in\n  IArray.of_fun (\\<lambda>a. A' !! a + B' !! a) n)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a iarray, plus_class)", "proof"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation iarray :: (zero) zero\nbegin"], ["", "definition \"zero_iarray = (IArray[]::'a iarray)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a iarray, zero_class)", "proof"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation iarray :: (comm_monoid_add) comm_monoid_add\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a iarray, comm_monoid_add_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "fix a b c::\"'a iarray\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "have max_eq: \"(max (IArray.length 0) (IArray.length a)) =(IArray.length a) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (IArray.length 0) (IArray.length a) = IArray.length a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. max (IArray.length 0) (IArray.length a) = IArray.length a", "have \"max (length (IArray.list_of (0::'a iarray))) (length (IArray.list_of a)) = length (IArray.list_of a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (length (IArray.list_of 0)) (length (IArray.list_of a)) =\n    length (IArray.list_of a)", "by (metis list.size(3) list_of.simps max_0L zero_iarray_def)"], ["proof (state)\nthis:\n  max (length (IArray.list_of 0)) (length (IArray.list_of a)) =\n  length (IArray.list_of a)\n\ngoal (1 subgoal):\n 1. max (IArray.length 0) (IArray.length a) = IArray.length a", "thus \"max (IArray.length 0) (IArray.length a) = IArray.length a\""], ["proof (prove)\nusing this:\n  max (length (IArray.list_of 0)) (length (IArray.list_of a)) =\n  length (IArray.list_of a)\n\ngoal (1 subgoal):\n 1. max (IArray.length 0) (IArray.length a) = IArray.length a", "by (metis IArray.length_def list.size(3) list_of.simps zero_iarray_def)"], ["proof (state)\nthis:\n  max (IArray.length 0) (IArray.length a) = IArray.length a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max (IArray.length 0) (IArray.length a) = IArray.length a\n\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "have length0: \"IArray.length 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length 0 = 0", "unfolding zero_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (IArray []) = 0", "by auto"], ["proof (state)\nthis:\n  IArray.length 0 = 0\n\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "show \"0 + a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + a = a", "proof (unfold iarray_exhaust2 list_eq_iff_nth_eq, auto, unfold IArray.length_def[symmetric] IArray.sub_def[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. IArray.length (0 + a) = IArray.length a\n 2. \\<And>i.\n       i < IArray.length (0 + a) \\<Longrightarrow> (0 + a) !! i = a !! i", "show length_eq: \"IArray.length (0 + a) = IArray.length a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (0 + a) = IArray.length a", "unfolding plus_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray.of_fun\n       (\\<lambda>aa.\n           IArray.of_fun\n            (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n            (max (IArray.length 0) (IArray.length a)) !!\n           aa +\n           IArray.of_fun\n            (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n            (max (IArray.length 0) (IArray.length a)) !!\n           aa)\n       (max (IArray.length 0) (IArray.length a))) =\n    IArray.length a", "using max_eq"], ["proof (prove)\nusing this:\n  max (IArray.length 0) (IArray.length a) = IArray.length a\n\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray.of_fun\n       (\\<lambda>aa.\n           IArray.of_fun\n            (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n            (max (IArray.length 0) (IArray.length a)) !!\n           aa +\n           IArray.of_fun\n            (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n            (max (IArray.length 0) (IArray.length a)) !!\n           aa)\n       (max (IArray.length 0) (IArray.length a))) =\n    IArray.length a", "by auto"], ["proof (state)\nthis:\n  IArray.length (0 + a) = IArray.length a\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (0 + a) \\<Longrightarrow> (0 + a) !! i = a !! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (0 + a) \\<Longrightarrow> (0 + a) !! i = a !! i", "assume i: \"i < IArray.length (0 + a)\""], ["proof (state)\nthis:\n  i < IArray.length (0 + a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (0 + a) \\<Longrightarrow> (0 + a) !! i = a !! i", "have i2: \"i < IArray.length a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length a", "by (metis length_eq i)"], ["proof (state)\nthis:\n  i < IArray.length a\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (0 + a) \\<Longrightarrow> (0 + a) !! i = a !! i", "have \"(0 + a) !! i = (\\<lambda>aa. IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else 0) (IArray.length a) !! aa +\n      IArray.of_fun (\\<lambda>aa. if aa < IArray.length a then a !! aa else 0) (IArray.length a) !! aa) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 + a) !! i =\n    IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n     (IArray.length a) !!\n    i +\n    IArray.of_fun\n     (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n     (IArray.length a) !!\n    i", "unfolding plus_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n          (max (IArray.length 0) (IArray.length a)) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n          (max (IArray.length 0) (IArray.length a)) !!\n         aa)\n     (max (IArray.length 0) (IArray.length a)) !!\n    i =\n    IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n     (IArray.length a) !!\n    i +\n    IArray.of_fun\n     (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n     (IArray.length a) !!\n    i", "unfolding max_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length 0 then 0 !! a else (0::'a))\n          (IArray.length a) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n          (IArray.length a) !!\n         aa)\n     (IArray.length a) !!\n    i =\n    IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n     (IArray.length a) !!\n    i +\n    IArray.of_fun\n     (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n     (IArray.length a) !!\n    i", "unfolding length0"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n          (IArray.length a) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n          (IArray.length a) !!\n         aa)\n     (IArray.length a) !!\n    i =\n    IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n     (IArray.length a) !!\n    i +\n    IArray.of_fun\n     (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n     (IArray.length a) !!\n    i", "unfolding sub_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n          (IArray.length a) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n          (IArray.length a) !!\n         aa)\n     (IArray.length a) !!\n    i =\n    IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n     (IArray.length a) !!\n    i +\n    IArray.of_fun\n     (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n     (IArray.length a) !!\n    i", "by (rule of_fun_nth[OF i2])"], ["proof (state)\nthis:\n  (0 + a) !! i =\n  IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n   (IArray.length a) !!\n  i +\n  IArray.of_fun\n   (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n   (IArray.length a) !!\n  i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (0 + a) \\<Longrightarrow> (0 + a) !! i = a !! i", "also"], ["proof (state)\nthis:\n  (0 + a) !! i =\n  IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n   (IArray.length a) !!\n  i +\n  IArray.of_fun\n   (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n   (IArray.length a) !!\n  i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (0 + a) \\<Longrightarrow> (0 + a) !! i = a !! i", "have \"... = (\\<lambda>aa. 0 + IArray.of_fun (\\<lambda>aa. if aa < IArray.length a then a !! aa else 0) (IArray.length a) !! aa) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n     (IArray.length a) !!\n    i +\n    IArray.of_fun\n     (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n     (IArray.length a) !!\n    i =\n    (0::'a) +\n    IArray.of_fun\n     (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n     (IArray.length a) !!\n    i", "using i2"], ["proof (prove)\nusing this:\n  i < IArray.length a\n\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n     (IArray.length a) !!\n    i +\n    IArray.of_fun\n     (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n     (IArray.length a) !!\n    i =\n    (0::'a) +\n    IArray.of_fun\n     (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n     (IArray.length a) !!\n    i", "by auto"], ["proof (state)\nthis:\n  IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n   (IArray.length a) !!\n  i +\n  IArray.of_fun\n   (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n   (IArray.length a) !!\n  i =\n  (0::'a) +\n  IArray.of_fun\n   (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n   (IArray.length a) !!\n  i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (0 + a) \\<Longrightarrow> (0 + a) !! i = a !! i", "also"], ["proof (state)\nthis:\n  IArray.of_fun (\\<lambda>a. if a < 0 then 0 !! a else (0::'a))\n   (IArray.length a) !!\n  i +\n  IArray.of_fun\n   (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n   (IArray.length a) !!\n  i =\n  (0::'a) +\n  IArray.of_fun\n   (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n   (IArray.length a) !!\n  i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (0 + a) \\<Longrightarrow> (0 + a) !! i = a !! i", "have \"... =  a !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) +\n    IArray.of_fun\n     (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n     (IArray.length a) !!\n    i =\n    a !! i", "using i2"], ["proof (prove)\nusing this:\n  i < IArray.length a\n\ngoal (1 subgoal):\n 1. (0::'a) +\n    IArray.of_fun\n     (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n     (IArray.length a) !!\n    i =\n    a !! i", "by simp"], ["proof (state)\nthis:\n  (0::'a) +\n  IArray.of_fun\n   (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n   (IArray.length a) !!\n  i =\n  a !! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (0 + a) \\<Longrightarrow> (0 + a) !! i = a !! i", "finally"], ["proof (chain)\npicking this:\n  (0 + a) !! i = a !! i", "show \"(0 + a) !! i =  a !! i\""], ["proof (prove)\nusing this:\n  (0 + a) !! i = a !! i\n\ngoal (1 subgoal):\n 1. (0 + a) !! i = a !! i", "."], ["proof (state)\nthis:\n  (0 + a) !! i = a !! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 + a = a\n\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a", "show \"a + b = b + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = b + a", "proof (unfold iarray_exhaust2 list_eq_iff_nth_eq, auto, unfold IArray.length_def[symmetric] IArray.sub_def[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. IArray.length (a + b) = IArray.length (b + a)\n 2. \\<And>i.\n       i < IArray.length (a + b) \\<Longrightarrow>\n       (a + b) !! i = (b + a) !! i", "have max_eq: \"(max (IArray.length a) (IArray.length b)) = IArray.length (a + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (IArray.length a) (IArray.length b) = IArray.length (a + b)", "unfolding plus_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max (IArray.length a) (IArray.length b) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>aa.\n           IArray.of_fun\n            (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n            (max (IArray.length a) (IArray.length b)) !!\n           aa +\n           IArray.of_fun\n            (\\<lambda>a. if a < IArray.length b then b !! a else (0::'a))\n            (max (IArray.length a) (IArray.length b)) !!\n           aa)\n       (max (IArray.length a) (IArray.length b)))", "by auto"], ["proof (state)\nthis:\n  max (IArray.length a) (IArray.length b) = IArray.length (a + b)\n\ngoal (2 subgoals):\n 1. IArray.length (a + b) = IArray.length (b + a)\n 2. \\<And>i.\n       i < IArray.length (a + b) \\<Longrightarrow>\n       (a + b) !! i = (b + a) !! i", "show length_eq: \"IArray.length (a + b) = IArray.length (b + a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (a + b) = IArray.length (b + a)", "unfolding plus_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray.of_fun\n       (\\<lambda>aa.\n           IArray.of_fun\n            (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n            (max (IArray.length a) (IArray.length b)) !!\n           aa +\n           IArray.of_fun\n            (\\<lambda>a. if a < IArray.length b then b !! a else (0::'a))\n            (max (IArray.length a) (IArray.length b)) !!\n           aa)\n       (max (IArray.length a) (IArray.length b))) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>aa.\n           IArray.of_fun\n            (\\<lambda>a. if a < IArray.length b then b !! a else (0::'a))\n            (max (IArray.length b) (IArray.length a)) !!\n           aa +\n           IArray.of_fun\n            (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n            (max (IArray.length b) (IArray.length a)) !!\n           aa)\n       (max (IArray.length b) (IArray.length a)))", "by auto"], ["proof (state)\nthis:\n  IArray.length (a + b) = IArray.length (b + a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (a + b) \\<Longrightarrow>\n       (a + b) !! i = (b + a) !! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (a + b) \\<Longrightarrow>\n       (a + b) !! i = (b + a) !! i", "assume i: \"i < IArray.length (a + b)\""], ["proof (state)\nthis:\n  i < IArray.length (a + b)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (a + b) \\<Longrightarrow>\n       (a + b) !! i = (b + a) !! i", "have i2: \"i < IArray.length (b+a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < IArray.length (b + a)", "using i"], ["proof (prove)\nusing this:\n  i < IArray.length (a + b)\n\ngoal (1 subgoal):\n 1. i < IArray.length (b + a)", "unfolding length_eq"], ["proof (prove)\nusing this:\n  i < IArray.length (b + a)\n\ngoal (1 subgoal):\n 1. i < IArray.length (b + a)", "."], ["proof (state)\nthis:\n  i < IArray.length (b + a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (a + b) \\<Longrightarrow>\n       (a + b) !! i = (b + a) !! i", "have i3: \"i < (max (IArray.length a) (IArray.length b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < max (IArray.length a) (IArray.length b)", "by (metis i max_eq)"], ["proof (state)\nthis:\n  i < max (IArray.length a) (IArray.length b)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (a + b) \\<Longrightarrow>\n       (a + b) !! i = (b + a) !! i", "have i4: \"i < (max (IArray.length b) (IArray.length a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < max (IArray.length b) (IArray.length a)", "by (metis i3 max.commute)"], ["proof (state)\nthis:\n  i < max (IArray.length b) (IArray.length a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (a + b) \\<Longrightarrow>\n       (a + b) !! i = (b + a) !! i", "show \"(a + b) !! i = (b + a) !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b) !! i = (b + a) !! i", "unfolding plus_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n          (max (IArray.length a) (IArray.length b)) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length b then b !! a else (0::'a))\n          (max (IArray.length a) (IArray.length b)) !!\n         aa)\n     (max (IArray.length a) (IArray.length b)) !!\n    i =\n    IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length b then b !! a else (0::'a))\n          (max (IArray.length b) (IArray.length a)) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n          (max (IArray.length b) (IArray.length a)) !!\n         aa)\n     (max (IArray.length b) (IArray.length a)) !!\n    i", "unfolding of_fun_nth[OF i3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < IArray.length a then a !! i else (0::'a)) +\n    (if i < IArray.length b then b !! i else (0::'a)) =\n    IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length b then b !! a else (0::'a))\n          (max (IArray.length b) (IArray.length a)) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n          (max (IArray.length b) (IArray.length a)) !!\n         aa)\n     (max (IArray.length b) (IArray.length a)) !!\n    i", "unfolding of_fun_nth[OF i4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < IArray.length a then a !! i else (0::'a)) +\n    (if i < IArray.length b then b !! i else (0::'a)) =\n    (if i < IArray.length b then b !! i else (0::'a)) +\n    (if i < IArray.length a then a !! i else (0::'a))", "by (simp only: add.commute)"], ["proof (state)\nthis:\n  (a + b) !! i = (b + a) !! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a + b = b + a\n\ngoal (1 subgoal):\n 1. \\<And>a b c. a + b + c = a + (b + c)", "show \"a + b + c = a + (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "proof (unfold iarray_exhaust2 list_eq_iff_nth_eq, auto, unfold IArray.length_def[symmetric] IArray.sub_def[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. IArray.length (a + b + c) = IArray.length (a + (b + c))\n 2. \\<And>i.\n       i < IArray.length (a + b + c) \\<Longrightarrow>\n       (a + b + c) !! i = (a + (b + c)) !! i", "show length_eq: \"IArray.length (a + b + c) = IArray.length (a + (b + c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length (a + b + c) = IArray.length (a + (b + c))", "unfolding plus_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.length\n     (IArray.of_fun\n       (\\<lambda>aa.\n           IArray.of_fun\n            (\\<lambda>aa.\n                if aa < IArray.length\n                         (IArray.of_fun\n                           (\\<lambda>aa.\n                               IArray.of_fun\n                                (\\<lambda>aa.\n                                    if aa < IArray.length a then a !! aa\n                                    else (0::'a))\n                                (max (IArray.length a) (IArray.length b)) !!\n                               aa +\n                               IArray.of_fun\n                                (\\<lambda>a.\n                                    if a < IArray.length b then b !! a\n                                    else (0::'a))\n                                (max (IArray.length a) (IArray.length b)) !!\n                               aa)\n                           (max (IArray.length a) (IArray.length b)))\n                then IArray.of_fun\n                      (\\<lambda>aa.\n                          IArray.of_fun\n                           (\\<lambda>aa.\n                               if aa < IArray.length a then a !! aa\n                               else (0::'a))\n                           (max (IArray.length a) (IArray.length b)) !!\n                          aa +\n                          IArray.of_fun\n                           (\\<lambda>a.\n                               if a < IArray.length b then b !! a\n                               else (0::'a))\n                           (max (IArray.length a) (IArray.length b)) !!\n                          aa)\n                      (max (IArray.length a) (IArray.length b)) !!\n                     aa\n                else (0::'a))\n            (max (IArray.length\n                   (IArray.of_fun\n                     (\\<lambda>aa.\n                         IArray.of_fun\n                          (\\<lambda>aa.\n                              if aa < IArray.length a then a !! aa\n                              else (0::'a))\n                          (max (IArray.length a) (IArray.length b)) !!\n                         aa +\n                         IArray.of_fun\n                          (\\<lambda>a.\n                              if a < IArray.length b then b !! a\n                              else (0::'a))\n                          (max (IArray.length a) (IArray.length b)) !!\n                         aa)\n                     (max (IArray.length a) (IArray.length b))))\n              (IArray.length c)) !!\n           aa +\n           IArray.of_fun\n            (\\<lambda>a. if a < IArray.length c then c !! a else (0::'a))\n            (max (IArray.length\n                   (IArray.of_fun\n                     (\\<lambda>aa.\n                         IArray.of_fun\n                          (\\<lambda>aa.\n                              if aa < IArray.length a then a !! aa\n                              else (0::'a))\n                          (max (IArray.length a) (IArray.length b)) !!\n                         aa +\n                         IArray.of_fun\n                          (\\<lambda>a.\n                              if a < IArray.length b then b !! a\n                              else (0::'a))\n                          (max (IArray.length a) (IArray.length b)) !!\n                         aa)\n                     (max (IArray.length a) (IArray.length b))))\n              (IArray.length c)) !!\n           aa)\n       (max (IArray.length\n              (IArray.of_fun\n                (\\<lambda>aa.\n                    IArray.of_fun\n                     (\\<lambda>aa.\n                         if aa < IArray.length a then a !! aa else (0::'a))\n                     (max (IArray.length a) (IArray.length b)) !!\n                    aa +\n                    IArray.of_fun\n                     (\\<lambda>a.\n                         if a < IArray.length b then b !! a else (0::'a))\n                     (max (IArray.length a) (IArray.length b)) !!\n                    aa)\n                (max (IArray.length a) (IArray.length b))))\n         (IArray.length c))) =\n    IArray.length\n     (IArray.of_fun\n       (\\<lambda>aa.\n           IArray.of_fun\n            (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n            (max (IArray.length a)\n              (IArray.length\n                (IArray.of_fun\n                  (\\<lambda>a.\n                      IArray.of_fun\n                       (\\<lambda>a.\n                           if a < IArray.length b then b !! a else (0::'a))\n                       (max (IArray.length b) (IArray.length c)) !!\n                      a +\n                      IArray.of_fun\n                       (\\<lambda>a.\n                           if a < IArray.length c then c !! a else (0::'a))\n                       (max (IArray.length b) (IArray.length c)) !!\n                      a)\n                  (max (IArray.length b) (IArray.length c))))) !!\n           aa +\n           IArray.of_fun\n            (\\<lambda>a.\n                if a < IArray.length\n                        (IArray.of_fun\n                          (\\<lambda>a.\n                              IArray.of_fun\n                               (\\<lambda>a.\n                                   if a < IArray.length b then b !! a\n                                   else (0::'a))\n                               (max (IArray.length b) (IArray.length c)) !!\n                              a +\n                              IArray.of_fun\n                               (\\<lambda>a.\n                                   if a < IArray.length c then c !! a\n                                   else (0::'a))\n                               (max (IArray.length b) (IArray.length c)) !!\n                              a)\n                          (max (IArray.length b) (IArray.length c)))\n                then IArray.of_fun\n                      (\\<lambda>a.\n                          IArray.of_fun\n                           (\\<lambda>a.\n                               if a < IArray.length b then b !! a\n                               else (0::'a))\n                           (max (IArray.length b) (IArray.length c)) !!\n                          a +\n                          IArray.of_fun\n                           (\\<lambda>a.\n                               if a < IArray.length c then c !! a\n                               else (0::'a))\n                           (max (IArray.length b) (IArray.length c)) !!\n                          a)\n                      (max (IArray.length b) (IArray.length c)) !!\n                     a\n                else (0::'a))\n            (max (IArray.length a)\n              (IArray.length\n                (IArray.of_fun\n                  (\\<lambda>a.\n                      IArray.of_fun\n                       (\\<lambda>a.\n                           if a < IArray.length b then b !! a else (0::'a))\n                       (max (IArray.length b) (IArray.length c)) !!\n                      a +\n                      IArray.of_fun\n                       (\\<lambda>a.\n                           if a < IArray.length c then c !! a else (0::'a))\n                       (max (IArray.length b) (IArray.length c)) !!\n                      a)\n                  (max (IArray.length b) (IArray.length c))))) !!\n           aa)\n       (max (IArray.length a)\n         (IArray.length\n           (IArray.of_fun\n             (\\<lambda>a.\n                 IArray.of_fun\n                  (\\<lambda>a.\n                      if a < IArray.length b then b !! a else (0::'a))\n                  (max (IArray.length b) (IArray.length c)) !!\n                 a +\n                 IArray.of_fun\n                  (\\<lambda>a.\n                      if a < IArray.length c then c !! a else (0::'a))\n                  (max (IArray.length b) (IArray.length c)) !!\n                 a)\n             (max (IArray.length b) (IArray.length c))))))", "by auto"], ["proof (state)\nthis:\n  IArray.length (a + b + c) = IArray.length (a + (b + c))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (a + b + c) \\<Longrightarrow>\n       (a + b + c) !! i = (a + (b + c)) !! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (a + b + c) \\<Longrightarrow>\n       (a + b + c) !! i = (a + (b + c)) !! i", "assume i: \"i < IArray.length (a + b + c)\""], ["proof (state)\nthis:\n  i < IArray.length (a + b + c)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (a + b + c) \\<Longrightarrow>\n       (a + b + c) !! i = (a + (b + c)) !! i", "have i2: \"i<(max (IArray.length (IArray.of_fun (\\<lambda>aa. IArray.of_fun \n      (\\<lambda>aa. if aa < IArray.length a then a !! aa else 0) (max (IArray.length a) (IArray.length b)) !! aa +\n      IArray.of_fun (\\<lambda>a. if a < IArray.length b then b !! a else 0) (max (IArray.length a) (IArray.length b)) !! aa)\n      (max (IArray.length a) (IArray.length b))))\n      (IArray.length c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < max (IArray.length\n              (IArray.of_fun\n                (\\<lambda>aa.\n                    IArray.of_fun\n                     (\\<lambda>aa.\n                         if aa < IArray.length a then a !! aa else (0::'a))\n                     (max (IArray.length a) (IArray.length b)) !!\n                    aa +\n                    IArray.of_fun\n                     (\\<lambda>a.\n                         if a < IArray.length b then b !! a else (0::'a))\n                     (max (IArray.length a) (IArray.length b)) !!\n                    aa)\n                (max (IArray.length a) (IArray.length b))))\n         (IArray.length c)", "using i"], ["proof (prove)\nusing this:\n  i < IArray.length (a + b + c)\n\ngoal (1 subgoal):\n 1. i < max (IArray.length\n              (IArray.of_fun\n                (\\<lambda>aa.\n                    IArray.of_fun\n                     (\\<lambda>aa.\n                         if aa < IArray.length a then a !! aa else (0::'a))\n                     (max (IArray.length a) (IArray.length b)) !!\n                    aa +\n                    IArray.of_fun\n                     (\\<lambda>a.\n                         if a < IArray.length b then b !! a else (0::'a))\n                     (max (IArray.length a) (IArray.length b)) !!\n                    aa)\n                (max (IArray.length a) (IArray.length b))))\n         (IArray.length c)", "unfolding plus_iarray_def Let_def"], ["proof (prove)\nusing this:\n  i < IArray.length\n       (IArray.of_fun\n         (\\<lambda>aa.\n             IArray.of_fun\n              (\\<lambda>aa.\n                  if aa < IArray.length\n                           (IArray.of_fun\n                             (\\<lambda>aa.\n                                 IArray.of_fun\n                                  (\\<lambda>aa.\nif aa < IArray.length a then a !! aa else (0::'a))\n                                  (max (IArray.length a)\n                                    (IArray.length b)) !!\n                                 aa +\n                                 IArray.of_fun\n                                  (\\<lambda>a.\nif a < IArray.length b then b !! a else (0::'a))\n                                  (max (IArray.length a)\n                                    (IArray.length b)) !!\n                                 aa)\n                             (max (IArray.length a) (IArray.length b)))\n                  then IArray.of_fun\n                        (\\<lambda>aa.\n                            IArray.of_fun\n                             (\\<lambda>aa.\n                                 if aa < IArray.length a then a !! aa\n                                 else (0::'a))\n                             (max (IArray.length a) (IArray.length b)) !!\n                            aa +\n                            IArray.of_fun\n                             (\\<lambda>a.\n                                 if a < IArray.length b then b !! a\n                                 else (0::'a))\n                             (max (IArray.length a) (IArray.length b)) !!\n                            aa)\n                        (max (IArray.length a) (IArray.length b)) !!\n                       aa\n                  else (0::'a))\n              (max (IArray.length\n                     (IArray.of_fun\n                       (\\<lambda>aa.\n                           IArray.of_fun\n                            (\\<lambda>aa.\n                                if aa < IArray.length a then a !! aa\n                                else (0::'a))\n                            (max (IArray.length a) (IArray.length b)) !!\n                           aa +\n                           IArray.of_fun\n                            (\\<lambda>a.\n                                if a < IArray.length b then b !! a\n                                else (0::'a))\n                            (max (IArray.length a) (IArray.length b)) !!\n                           aa)\n                       (max (IArray.length a) (IArray.length b))))\n                (IArray.length c)) !!\n             aa +\n             IArray.of_fun\n              (\\<lambda>a. if a < IArray.length c then c !! a else (0::'a))\n              (max (IArray.length\n                     (IArray.of_fun\n                       (\\<lambda>aa.\n                           IArray.of_fun\n                            (\\<lambda>aa.\n                                if aa < IArray.length a then a !! aa\n                                else (0::'a))\n                            (max (IArray.length a) (IArray.length b)) !!\n                           aa +\n                           IArray.of_fun\n                            (\\<lambda>a.\n                                if a < IArray.length b then b !! a\n                                else (0::'a))\n                            (max (IArray.length a) (IArray.length b)) !!\n                           aa)\n                       (max (IArray.length a) (IArray.length b))))\n                (IArray.length c)) !!\n             aa)\n         (max (IArray.length\n                (IArray.of_fun\n                  (\\<lambda>aa.\n                      IArray.of_fun\n                       (\\<lambda>aa.\n                           if aa < IArray.length a then a !! aa\n                           else (0::'a))\n                       (max (IArray.length a) (IArray.length b)) !!\n                      aa +\n                      IArray.of_fun\n                       (\\<lambda>a.\n                           if a < IArray.length b then b !! a else (0::'a))\n                       (max (IArray.length a) (IArray.length b)) !!\n                      aa)\n                  (max (IArray.length a) (IArray.length b))))\n           (IArray.length c)))\n\ngoal (1 subgoal):\n 1. i < max (IArray.length\n              (IArray.of_fun\n                (\\<lambda>aa.\n                    IArray.of_fun\n                     (\\<lambda>aa.\n                         if aa < IArray.length a then a !! aa else (0::'a))\n                     (max (IArray.length a) (IArray.length b)) !!\n                    aa +\n                    IArray.of_fun\n                     (\\<lambda>a.\n                         if a < IArray.length b then b !! a else (0::'a))\n                     (max (IArray.length a) (IArray.length b)) !!\n                    aa)\n                (max (IArray.length a) (IArray.length b))))\n         (IArray.length c)", "by auto"], ["proof (state)\nthis:\n  i < max (IArray.length\n            (IArray.of_fun\n              (\\<lambda>aa.\n                  IArray.of_fun\n                   (\\<lambda>aa.\n                       if aa < IArray.length a then a !! aa else (0::'a))\n                   (max (IArray.length a) (IArray.length b)) !!\n                  aa +\n                  IArray.of_fun\n                   (\\<lambda>a.\n                       if a < IArray.length b then b !! a else (0::'a))\n                   (max (IArray.length a) (IArray.length b)) !!\n                  aa)\n              (max (IArray.length a) (IArray.length b))))\n       (IArray.length c)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (a + b + c) \\<Longrightarrow>\n       (a + b + c) !! i = (a + (b + c)) !! i", "have i3: \"i< (max (IArray.length a) (IArray.length (IArray.of_fun\n      (\\<lambda>a. IArray.of_fun (\\<lambda>a. if a < IArray.length b then b !! a else 0) (max (IArray.length b) (IArray.length c)) !! a +\n      IArray.of_fun (\\<lambda>a. if a < IArray.length c then c !! a else 0) (max (IArray.length b) (IArray.length c)) !! a)\n      (max (IArray.length b) (IArray.length c)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < max (IArray.length a)\n         (IArray.length\n           (IArray.of_fun\n             (\\<lambda>a.\n                 IArray.of_fun\n                  (\\<lambda>a.\n                      if a < IArray.length b then b !! a else (0::'a))\n                  (max (IArray.length b) (IArray.length c)) !!\n                 a +\n                 IArray.of_fun\n                  (\\<lambda>a.\n                      if a < IArray.length c then c !! a else (0::'a))\n                  (max (IArray.length b) (IArray.length c)) !!\n                 a)\n             (max (IArray.length b) (IArray.length c))))", "using i"], ["proof (prove)\nusing this:\n  i < IArray.length (a + b + c)\n\ngoal (1 subgoal):\n 1. i < max (IArray.length a)\n         (IArray.length\n           (IArray.of_fun\n             (\\<lambda>a.\n                 IArray.of_fun\n                  (\\<lambda>a.\n                      if a < IArray.length b then b !! a else (0::'a))\n                  (max (IArray.length b) (IArray.length c)) !!\n                 a +\n                 IArray.of_fun\n                  (\\<lambda>a.\n                      if a < IArray.length c then c !! a else (0::'a))\n                  (max (IArray.length b) (IArray.length c)) !!\n                 a)\n             (max (IArray.length b) (IArray.length c))))", "unfolding plus_iarray_def Let_def"], ["proof (prove)\nusing this:\n  i < IArray.length\n       (IArray.of_fun\n         (\\<lambda>aa.\n             IArray.of_fun\n              (\\<lambda>aa.\n                  if aa < IArray.length\n                           (IArray.of_fun\n                             (\\<lambda>aa.\n                                 IArray.of_fun\n                                  (\\<lambda>aa.\nif aa < IArray.length a then a !! aa else (0::'a))\n                                  (max (IArray.length a)\n                                    (IArray.length b)) !!\n                                 aa +\n                                 IArray.of_fun\n                                  (\\<lambda>a.\nif a < IArray.length b then b !! a else (0::'a))\n                                  (max (IArray.length a)\n                                    (IArray.length b)) !!\n                                 aa)\n                             (max (IArray.length a) (IArray.length b)))\n                  then IArray.of_fun\n                        (\\<lambda>aa.\n                            IArray.of_fun\n                             (\\<lambda>aa.\n                                 if aa < IArray.length a then a !! aa\n                                 else (0::'a))\n                             (max (IArray.length a) (IArray.length b)) !!\n                            aa +\n                            IArray.of_fun\n                             (\\<lambda>a.\n                                 if a < IArray.length b then b !! a\n                                 else (0::'a))\n                             (max (IArray.length a) (IArray.length b)) !!\n                            aa)\n                        (max (IArray.length a) (IArray.length b)) !!\n                       aa\n                  else (0::'a))\n              (max (IArray.length\n                     (IArray.of_fun\n                       (\\<lambda>aa.\n                           IArray.of_fun\n                            (\\<lambda>aa.\n                                if aa < IArray.length a then a !! aa\n                                else (0::'a))\n                            (max (IArray.length a) (IArray.length b)) !!\n                           aa +\n                           IArray.of_fun\n                            (\\<lambda>a.\n                                if a < IArray.length b then b !! a\n                                else (0::'a))\n                            (max (IArray.length a) (IArray.length b)) !!\n                           aa)\n                       (max (IArray.length a) (IArray.length b))))\n                (IArray.length c)) !!\n             aa +\n             IArray.of_fun\n              (\\<lambda>a. if a < IArray.length c then c !! a else (0::'a))\n              (max (IArray.length\n                     (IArray.of_fun\n                       (\\<lambda>aa.\n                           IArray.of_fun\n                            (\\<lambda>aa.\n                                if aa < IArray.length a then a !! aa\n                                else (0::'a))\n                            (max (IArray.length a) (IArray.length b)) !!\n                           aa +\n                           IArray.of_fun\n                            (\\<lambda>a.\n                                if a < IArray.length b then b !! a\n                                else (0::'a))\n                            (max (IArray.length a) (IArray.length b)) !!\n                           aa)\n                       (max (IArray.length a) (IArray.length b))))\n                (IArray.length c)) !!\n             aa)\n         (max (IArray.length\n                (IArray.of_fun\n                  (\\<lambda>aa.\n                      IArray.of_fun\n                       (\\<lambda>aa.\n                           if aa < IArray.length a then a !! aa\n                           else (0::'a))\n                       (max (IArray.length a) (IArray.length b)) !!\n                      aa +\n                      IArray.of_fun\n                       (\\<lambda>a.\n                           if a < IArray.length b then b !! a else (0::'a))\n                       (max (IArray.length a) (IArray.length b)) !!\n                      aa)\n                  (max (IArray.length a) (IArray.length b))))\n           (IArray.length c)))\n\ngoal (1 subgoal):\n 1. i < max (IArray.length a)\n         (IArray.length\n           (IArray.of_fun\n             (\\<lambda>a.\n                 IArray.of_fun\n                  (\\<lambda>a.\n                      if a < IArray.length b then b !! a else (0::'a))\n                  (max (IArray.length b) (IArray.length c)) !!\n                 a +\n                 IArray.of_fun\n                  (\\<lambda>a.\n                      if a < IArray.length c then c !! a else (0::'a))\n                  (max (IArray.length b) (IArray.length c)) !!\n                 a)\n             (max (IArray.length b) (IArray.length c))))", "by auto"], ["proof (state)\nthis:\n  i < max (IArray.length a)\n       (IArray.length\n         (IArray.of_fun\n           (\\<lambda>a.\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length b then b !! a else (0::'a))\n                (max (IArray.length b) (IArray.length c)) !!\n               a +\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length c then c !! a else (0::'a))\n                (max (IArray.length b) (IArray.length c)) !!\n               a)\n           (max (IArray.length b) (IArray.length c))))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < IArray.length (a + b + c) \\<Longrightarrow>\n       (a + b + c) !! i = (a + (b + c)) !! i", "show \"(a + b + c) !! i = (a + (b + c)) !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b + c) !! i = (a + (b + c)) !! i", "unfolding plus_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let length_A =\n           IArray.length\n            (let length_A = IArray.length a; length_B = IArray.length b;\n                 n = max length_A length_B;\n                 A' = IArray.of_fun\n                       (\\<lambda>aa.\n                           if aa < length_A then a !! aa else (0::'a))\n                       n;\n                 B' = IArray.of_fun\n                       (\\<lambda>a.\n                           if a < length_B then b !! a else (0::'a))\n                       n\n             in IArray.of_fun (\\<lambda>a. A' !! a + B' !! a) n);\n         length_B = IArray.length c; n = max length_A length_B;\n         A' = IArray.of_fun\n               (\\<lambda>aa.\n                   if aa < length_A\n                   then (let length_A = IArray.length a;\n                             length_B = IArray.length b;\n                             n = max length_A length_B;\n                             A' = IArray.of_fun\n                                   (\\<lambda>aa.\n if aa < length_A then a !! aa else (0::'a))\n                                   n;\n                             B' = IArray.of_fun\n                                   (\\<lambda>a.\n if a < length_B then b !! a else (0::'a))\n                                   n\n                         in IArray.of_fun (\\<lambda>a. A' !! a + B' !! a)\n                             n) !!\n                        aa\n                   else (0::'a))\n               n;\n         B' = IArray.of_fun\n               (\\<lambda>a. if a < length_B then c !! a else (0::'a)) n\n     in IArray.of_fun (\\<lambda>a. A' !! a + B' !! a) n) !!\n    i =\n    (let length_A = IArray.length a;\n         length_B =\n           IArray.length\n            (let length_A = IArray.length b; length_B = IArray.length c;\n                 n = max length_A length_B;\n                 A' = IArray.of_fun\n                       (\\<lambda>a.\n                           if a < length_A then b !! a else (0::'a))\n                       n;\n                 B' = IArray.of_fun\n                       (\\<lambda>a.\n                           if a < length_B then c !! a else (0::'a))\n                       n\n             in IArray.of_fun (\\<lambda>a. A' !! a + B' !! a) n);\n         n = max length_A length_B;\n         A' = IArray.of_fun\n               (\\<lambda>aa. if aa < length_A then a !! aa else (0::'a)) n;\n         B' = IArray.of_fun\n               (\\<lambda>a.\n                   if a < length_B\n                   then (let length_A = IArray.length b;\n                             length_B = IArray.length c;\n                             n = max length_A length_B;\n                             A' = IArray.of_fun\n                                   (\\<lambda>a.\n if a < length_A then b !! a else (0::'a))\n                                   n;\n                             B' = IArray.of_fun\n                                   (\\<lambda>a.\n if a < length_B then c !! a else (0::'a))\n                                   n\n                         in IArray.of_fun (\\<lambda>a. A' !! a + B' !! a)\n                             n) !!\n                        a\n                   else (0::'a))\n               n\n     in IArray.of_fun (\\<lambda>a. A' !! a + B' !! a) n) !!\n    i", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>aa.\n              if aa < IArray.length\n                       (IArray.of_fun\n                         (\\<lambda>aa.\n                             IArray.of_fun\n                              (\\<lambda>aa.\n                                  if aa < IArray.length a then a !! aa\n                                  else (0::'a))\n                              (max (IArray.length a) (IArray.length b)) !!\n                             aa +\n                             IArray.of_fun\n                              (\\<lambda>a.\n                                  if a < IArray.length b then b !! a\n                                  else (0::'a))\n                              (max (IArray.length a) (IArray.length b)) !!\n                             aa)\n                         (max (IArray.length a) (IArray.length b)))\n              then IArray.of_fun\n                    (\\<lambda>aa.\n                        IArray.of_fun\n                         (\\<lambda>aa.\n                             if aa < IArray.length a then a !! aa\n                             else (0::'a))\n                         (max (IArray.length a) (IArray.length b)) !!\n                        aa +\n                        IArray.of_fun\n                         (\\<lambda>a.\n                             if a < IArray.length b then b !! a\n                             else (0::'a))\n                         (max (IArray.length a) (IArray.length b)) !!\n                        aa)\n                    (max (IArray.length a) (IArray.length b)) !!\n                   aa\n              else (0::'a))\n          (max (IArray.length\n                 (IArray.of_fun\n                   (\\<lambda>aa.\n                       IArray.of_fun\n                        (\\<lambda>aa.\n                            if aa < IArray.length a then a !! aa\n                            else (0::'a))\n                        (max (IArray.length a) (IArray.length b)) !!\n                       aa +\n                       IArray.of_fun\n                        (\\<lambda>a.\n                            if a < IArray.length b then b !! a else (0::'a))\n                        (max (IArray.length a) (IArray.length b)) !!\n                       aa)\n                   (max (IArray.length a) (IArray.length b))))\n            (IArray.length c)) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>a. if a < IArray.length c then c !! a else (0::'a))\n          (max (IArray.length\n                 (IArray.of_fun\n                   (\\<lambda>aa.\n                       IArray.of_fun\n                        (\\<lambda>aa.\n                            if aa < IArray.length a then a !! aa\n                            else (0::'a))\n                        (max (IArray.length a) (IArray.length b)) !!\n                       aa +\n                       IArray.of_fun\n                        (\\<lambda>a.\n                            if a < IArray.length b then b !! a else (0::'a))\n                        (max (IArray.length a) (IArray.length b)) !!\n                       aa)\n                   (max (IArray.length a) (IArray.length b))))\n            (IArray.length c)) !!\n         aa)\n     (max (IArray.length\n            (IArray.of_fun\n              (\\<lambda>aa.\n                  IArray.of_fun\n                   (\\<lambda>aa.\n                       if aa < IArray.length a then a !! aa else (0::'a))\n                   (max (IArray.length a) (IArray.length b)) !!\n                  aa +\n                  IArray.of_fun\n                   (\\<lambda>a.\n                       if a < IArray.length b then b !! a else (0::'a))\n                   (max (IArray.length a) (IArray.length b)) !!\n                  aa)\n              (max (IArray.length a) (IArray.length b))))\n       (IArray.length c)) !!\n    i =\n    IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n          (max (IArray.length a)\n            (IArray.length\n              (IArray.of_fun\n                (\\<lambda>a.\n                    IArray.of_fun\n                     (\\<lambda>a.\n                         if a < IArray.length b then b !! a else (0::'a))\n                     (max (IArray.length b) (IArray.length c)) !!\n                    a +\n                    IArray.of_fun\n                     (\\<lambda>a.\n                         if a < IArray.length c then c !! a else (0::'a))\n                     (max (IArray.length b) (IArray.length c)) !!\n                    a)\n                (max (IArray.length b) (IArray.length c))))) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>a.\n              if a < IArray.length\n                      (IArray.of_fun\n                        (\\<lambda>a.\n                            IArray.of_fun\n                             (\\<lambda>a.\n                                 if a < IArray.length b then b !! a\n                                 else (0::'a))\n                             (max (IArray.length b) (IArray.length c)) !!\n                            a +\n                            IArray.of_fun\n                             (\\<lambda>a.\n                                 if a < IArray.length c then c !! a\n                                 else (0::'a))\n                             (max (IArray.length b) (IArray.length c)) !!\n                            a)\n                        (max (IArray.length b) (IArray.length c)))\n              then IArray.of_fun\n                    (\\<lambda>a.\n                        IArray.of_fun\n                         (\\<lambda>a.\n                             if a < IArray.length b then b !! a\n                             else (0::'a))\n                         (max (IArray.length b) (IArray.length c)) !!\n                        a +\n                        IArray.of_fun\n                         (\\<lambda>a.\n                             if a < IArray.length c then c !! a\n                             else (0::'a))\n                         (max (IArray.length b) (IArray.length c)) !!\n                        a)\n                    (max (IArray.length b) (IArray.length c)) !!\n                   a\n              else (0::'a))\n          (max (IArray.length a)\n            (IArray.length\n              (IArray.of_fun\n                (\\<lambda>a.\n                    IArray.of_fun\n                     (\\<lambda>a.\n                         if a < IArray.length b then b !! a else (0::'a))\n                     (max (IArray.length b) (IArray.length c)) !!\n                    a +\n                    IArray.of_fun\n                     (\\<lambda>a.\n                         if a < IArray.length c then c !! a else (0::'a))\n                     (max (IArray.length b) (IArray.length c)) !!\n                    a)\n                (max (IArray.length b) (IArray.length c))))) !!\n         aa)\n     (max (IArray.length a)\n       (IArray.length\n         (IArray.of_fun\n           (\\<lambda>a.\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length b then b !! a else (0::'a))\n                (max (IArray.length b) (IArray.length c)) !!\n               a +\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length c then c !! a else (0::'a))\n                (max (IArray.length b) (IArray.length c)) !!\n               a)\n           (max (IArray.length b) (IArray.length c))))) !!\n    i", "unfolding of_fun_nth[OF i2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < IArray.length\n             (IArray.of_fun\n               (\\<lambda>aa.\n                   IArray.of_fun\n                    (\\<lambda>aa.\n                        if aa < IArray.length a then a !! aa else (0::'a))\n                    (max (IArray.length a) (IArray.length b)) !!\n                   aa +\n                   IArray.of_fun\n                    (\\<lambda>a.\n                        if a < IArray.length b then b !! a else (0::'a))\n                    (max (IArray.length a) (IArray.length b)) !!\n                   aa)\n               (max (IArray.length a) (IArray.length b)))\n     then IArray.of_fun\n           (\\<lambda>aa.\n               IArray.of_fun\n                (\\<lambda>aa.\n                    if aa < IArray.length a then a !! aa else (0::'a))\n                (max (IArray.length a) (IArray.length b)) !!\n               aa +\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length b then b !! a else (0::'a))\n                (max (IArray.length a) (IArray.length b)) !!\n               aa)\n           (max (IArray.length a) (IArray.length b)) !!\n          i\n     else (0::'a)) +\n    (if i < IArray.length c then c !! i else (0::'a)) =\n    IArray.of_fun\n     (\\<lambda>aa.\n         IArray.of_fun\n          (\\<lambda>aa. if aa < IArray.length a then a !! aa else (0::'a))\n          (max (IArray.length a)\n            (IArray.length\n              (IArray.of_fun\n                (\\<lambda>a.\n                    IArray.of_fun\n                     (\\<lambda>a.\n                         if a < IArray.length b then b !! a else (0::'a))\n                     (max (IArray.length b) (IArray.length c)) !!\n                    a +\n                    IArray.of_fun\n                     (\\<lambda>a.\n                         if a < IArray.length c then c !! a else (0::'a))\n                     (max (IArray.length b) (IArray.length c)) !!\n                    a)\n                (max (IArray.length b) (IArray.length c))))) !!\n         aa +\n         IArray.of_fun\n          (\\<lambda>a.\n              if a < IArray.length\n                      (IArray.of_fun\n                        (\\<lambda>a.\n                            IArray.of_fun\n                             (\\<lambda>a.\n                                 if a < IArray.length b then b !! a\n                                 else (0::'a))\n                             (max (IArray.length b) (IArray.length c)) !!\n                            a +\n                            IArray.of_fun\n                             (\\<lambda>a.\n                                 if a < IArray.length c then c !! a\n                                 else (0::'a))\n                             (max (IArray.length b) (IArray.length c)) !!\n                            a)\n                        (max (IArray.length b) (IArray.length c)))\n              then IArray.of_fun\n                    (\\<lambda>a.\n                        IArray.of_fun\n                         (\\<lambda>a.\n                             if a < IArray.length b then b !! a\n                             else (0::'a))\n                         (max (IArray.length b) (IArray.length c)) !!\n                        a +\n                        IArray.of_fun\n                         (\\<lambda>a.\n                             if a < IArray.length c then c !! a\n                             else (0::'a))\n                         (max (IArray.length b) (IArray.length c)) !!\n                        a)\n                    (max (IArray.length b) (IArray.length c)) !!\n                   a\n              else (0::'a))\n          (max (IArray.length a)\n            (IArray.length\n              (IArray.of_fun\n                (\\<lambda>a.\n                    IArray.of_fun\n                     (\\<lambda>a.\n                         if a < IArray.length b then b !! a else (0::'a))\n                     (max (IArray.length b) (IArray.length c)) !!\n                    a +\n                    IArray.of_fun\n                     (\\<lambda>a.\n                         if a < IArray.length c then c !! a else (0::'a))\n                     (max (IArray.length b) (IArray.length c)) !!\n                    a)\n                (max (IArray.length b) (IArray.length c))))) !!\n         aa)\n     (max (IArray.length a)\n       (IArray.length\n         (IArray.of_fun\n           (\\<lambda>a.\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length b then b !! a else (0::'a))\n                (max (IArray.length b) (IArray.length c)) !!\n               a +\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length c then c !! a else (0::'a))\n                (max (IArray.length b) (IArray.length c)) !!\n               a)\n           (max (IArray.length b) (IArray.length c))))) !!\n    i", "unfolding of_fun_nth[OF i3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < IArray.length\n             (IArray.of_fun\n               (\\<lambda>aa.\n                   IArray.of_fun\n                    (\\<lambda>aa.\n                        if aa < IArray.length a then a !! aa else (0::'a))\n                    (max (IArray.length a) (IArray.length b)) !!\n                   aa +\n                   IArray.of_fun\n                    (\\<lambda>a.\n                        if a < IArray.length b then b !! a else (0::'a))\n                    (max (IArray.length a) (IArray.length b)) !!\n                   aa)\n               (max (IArray.length a) (IArray.length b)))\n     then IArray.of_fun\n           (\\<lambda>aa.\n               IArray.of_fun\n                (\\<lambda>aa.\n                    if aa < IArray.length a then a !! aa else (0::'a))\n                (max (IArray.length a) (IArray.length b)) !!\n               aa +\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length b then b !! a else (0::'a))\n                (max (IArray.length a) (IArray.length b)) !!\n               aa)\n           (max (IArray.length a) (IArray.length b)) !!\n          i\n     else (0::'a)) +\n    (if i < IArray.length c then c !! i else (0::'a)) =\n    (if i < IArray.length a then a !! i else (0::'a)) +\n    (if i < IArray.length\n             (IArray.of_fun\n               (\\<lambda>a.\n                   IArray.of_fun\n                    (\\<lambda>a.\n                        if a < IArray.length b then b !! a else (0::'a))\n                    (max (IArray.length b) (IArray.length c)) !!\n                   a +\n                   IArray.of_fun\n                    (\\<lambda>a.\n                        if a < IArray.length c then c !! a else (0::'a))\n                    (max (IArray.length b) (IArray.length c)) !!\n                   a)\n               (max (IArray.length b) (IArray.length c)))\n     then IArray.of_fun\n           (\\<lambda>a.\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length b then b !! a else (0::'a))\n                (max (IArray.length b) (IArray.length c)) !!\n               a +\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length c then c !! a else (0::'a))\n                (max (IArray.length b) (IArray.length c)) !!\n               a)\n           (max (IArray.length b) (IArray.length c)) !!\n          i\n     else (0::'a))", "using i2 i3"], ["proof (prove)\nusing this:\n  i < max (IArray.length\n            (IArray.of_fun\n              (\\<lambda>aa.\n                  IArray.of_fun\n                   (\\<lambda>aa.\n                       if aa < IArray.length a then a !! aa else (0::'a))\n                   (max (IArray.length a) (IArray.length b)) !!\n                  aa +\n                  IArray.of_fun\n                   (\\<lambda>a.\n                       if a < IArray.length b then b !! a else (0::'a))\n                   (max (IArray.length a) (IArray.length b)) !!\n                  aa)\n              (max (IArray.length a) (IArray.length b))))\n       (IArray.length c)\n  i < max (IArray.length a)\n       (IArray.length\n         (IArray.of_fun\n           (\\<lambda>a.\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length b then b !! a else (0::'a))\n                (max (IArray.length b) (IArray.length c)) !!\n               a +\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length c then c !! a else (0::'a))\n                (max (IArray.length b) (IArray.length c)) !!\n               a)\n           (max (IArray.length b) (IArray.length c))))\n\ngoal (1 subgoal):\n 1. (if i < IArray.length\n             (IArray.of_fun\n               (\\<lambda>aa.\n                   IArray.of_fun\n                    (\\<lambda>aa.\n                        if aa < IArray.length a then a !! aa else (0::'a))\n                    (max (IArray.length a) (IArray.length b)) !!\n                   aa +\n                   IArray.of_fun\n                    (\\<lambda>a.\n                        if a < IArray.length b then b !! a else (0::'a))\n                    (max (IArray.length a) (IArray.length b)) !!\n                   aa)\n               (max (IArray.length a) (IArray.length b)))\n     then IArray.of_fun\n           (\\<lambda>aa.\n               IArray.of_fun\n                (\\<lambda>aa.\n                    if aa < IArray.length a then a !! aa else (0::'a))\n                (max (IArray.length a) (IArray.length b)) !!\n               aa +\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length b then b !! a else (0::'a))\n                (max (IArray.length a) (IArray.length b)) !!\n               aa)\n           (max (IArray.length a) (IArray.length b)) !!\n          i\n     else (0::'a)) +\n    (if i < IArray.length c then c !! i else (0::'a)) =\n    (if i < IArray.length a then a !! i else (0::'a)) +\n    (if i < IArray.length\n             (IArray.of_fun\n               (\\<lambda>a.\n                   IArray.of_fun\n                    (\\<lambda>a.\n                        if a < IArray.length b then b !! a else (0::'a))\n                    (max (IArray.length b) (IArray.length c)) !!\n                   a +\n                   IArray.of_fun\n                    (\\<lambda>a.\n                        if a < IArray.length c then c !! a else (0::'a))\n                    (max (IArray.length b) (IArray.length c)) !!\n                   a)\n               (max (IArray.length b) (IArray.length c)))\n     then IArray.of_fun\n           (\\<lambda>a.\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length b then b !! a else (0::'a))\n                (max (IArray.length b) (IArray.length c)) !!\n               a +\n               IArray.of_fun\n                (\\<lambda>a.\n                    if a < IArray.length c then c !! a else (0::'a))\n                (max (IArray.length b) (IArray.length c)) !!\n               a)\n           (max (IArray.length b) (IArray.length c)) !!\n          i\n     else (0::'a))", "by (auto simp add: add.assoc)"], ["proof (state)\nthis:\n  (a + b + c) !! i = (a + (b + c)) !! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a + b + c = a + (b + c)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation iarray :: (uminus) uminus\nbegin"], ["", "definition uminus_iarray :: \"'a iarray  \\<Rightarrow> 'a iarray\"\n  where \"uminus_iarray A  =  IArray.of_fun (\\<lambda>n. - A!!n) (IArray.length A)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a iarray, uminus_class)", "proof"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation iarray :: (\"{minus,zero}\") minus\nbegin"], ["", "definition minus_iarray :: \"'a iarray \\<Rightarrow> 'a iarray \\<Rightarrow> 'a iarray\"\n  where \"minus_iarray A B = \n  (let length_A= (IArray.length A);\n  length_B= (IArray.length B);\n  n=max length_A length_B ; \n  A'= IArray.of_fun (\\<lambda>a. if a < length_A then A!!a else 0) n;\n  B'=IArray.of_fun (\\<lambda>a. if a < length_B then B!!a else 0) n\n  in\n  IArray.of_fun (\\<lambda>a. A' !! a - B' !! a) n)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a iarray, minus_class)", "proof"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open>Some previous definitions and properties for IArrays\\<close>"], ["", "subsubsection\\<open>Lemmas\\<close>"], ["", "subsubsection\\<open>Definitions\\<close>"], ["", "fun all :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a iarray \\<Rightarrow> bool\"\n  where \"all p (IArray as) = (ALL a : set as. p a)\""], ["", "hide_const (open) all"], ["", "fun exists :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a iarray \\<Rightarrow> bool\"\n  where \"exists p (IArray as) = (EX a : set as. p a)\""], ["", "hide_const (open) exists"], ["", "subsection\\<open>Code generation\\<close>"], ["", "code_printing \n  constant \"IArray_Addenda_QR.exists\" \\<rightharpoonup> (SML) \"Vector.exists\"\n  | constant \"IArray_Addenda_QR.all\" \\<rightharpoonup> (SML) \"Vector.all\""], ["", "end"]]}