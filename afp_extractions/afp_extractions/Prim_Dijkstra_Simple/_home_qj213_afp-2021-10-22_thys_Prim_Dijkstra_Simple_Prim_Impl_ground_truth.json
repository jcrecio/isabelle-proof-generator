{"file_name": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple/Prim_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple", "problem_names": ["lemmas [simp] = G.wgraph_specs", "lemmas [simp] = M.map_specs", "lemmas [simp] = Q.prio_map_specs", "lemma prim_impl_alt: \"prim_impl = (let \n  \\<comment> \\<open>Initialization\\<close>\n  (Q,\\<pi>) = (Q_update r 0 Q_empty, M_empty);\n  \\<comment> \\<open>Main loop: Iterate until PQ is empty\\<close>\n  (Q, \\<pi>) = \n  while (\\<lambda>(Q, \\<pi>). \\<not> Q_is_empty Q) (\\<lambda>(Q, \\<pi>). let \n    (u, _) = Q_getmin Q;\n    \\<comment> \\<open>Inner loop: Update for adjacent nodes\\<close>\n    (Q, \\<pi>) = \n    foldr ((\\<lambda>(v, d) (Q, \\<pi>). let\n        qv = Q_lookup Q v;\n        \\<pi>v = M_lookup \\<pi> v\n      in\n        if v\\<noteq>r \\<and> (qv\\<noteq>None \\<or> \\<pi>v=None) \\<and> enat d < enat_of_option qv \n        then (Q_update v d Q, M_update v u \\<pi>) \n        else (Q, \\<pi>))\n    ) (G_adj g u) (Q, \\<pi>); \n    Q = Q_delete u Q\n    in (Q, \\<pi>)) (Q, \\<pi>)\n  in \\<pi>\n)\"", "lemma Q_\\<alpha>_empty: \"Q_\\<alpha> Q_empty = (\\<lambda>_. \\<infinity>)\"", "lemma Q_\\<alpha>_update: \"Q_invar Q \\<Longrightarrow> Q_\\<alpha> (Q_update u d Q) = (Q_\\<alpha> Q)(u := enat d)\"", "lemma Q_\\<alpha>_is_empty: \"Q_invar Q \\<Longrightarrow> Q_lookup Q = Map.empty \\<longleftrightarrow> Q_\\<alpha> Q = (\\<lambda>_. \\<infinity>)\"", "lemma Q_\\<alpha>_delete: \"Q_invar Q \\<Longrightarrow> Q_\\<alpha> (Q_delete u Q) = (Q_\\<alpha> Q)(u:=\\<infinity>)\"", "lemma Q_\\<alpha>_min:\n  assumes MIN: \"Q_getmin Qi = (u, d)\"\n  assumes I: \"Q_invar Qi\"\n  assumes NE: \"\\<not> Q_is_empty Qi\"\n  shows \"Q_\\<alpha> Qi u = enat d\" (is ?G1) and\n        \"\\<forall>v. enat d \\<le> Q_\\<alpha> Qi v\" (is ?G2)", "lemmas Q_\\<alpha>_specs = Q_\\<alpha>_empty Q_\\<alpha>_update Q_\\<alpha>_is_empty Q_\\<alpha>_delete", "lemma foreach_impl_correct:\n  fixes Qi Vi \\<pi>i defines \"Q \\<equiv> Q_\\<alpha> Qi\" and \"\\<pi> \\<equiv> M_lookup \\<pi>i\"\n  assumes A: \"foreach_impl Qi \\<pi>i u (G_adj g u) = (Qi',\\<pi>i')\" \n  assumes I: \"prim_invar_impl Qi \\<pi>i\"\n  shows \"Q_invar Qi'\" and \"M_invar \\<pi>i'\" \n    and \"Q_\\<alpha> Qi' = Qinter Q \\<pi> u\" and \"M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u\"", "lemma foreach_impl_correct_presentation:\n  fixes Qi Vi \\<pi>i defines \"Q \\<equiv> Q_\\<alpha> Qi\" and \"\\<pi> \\<equiv> M_lookup \\<pi>i\"\n  assumes A: \"foreach_impl Qi \\<pi>i u (G_adj g u) = (Qi',\\<pi>i')\" \n  assumes I: \"prim_invar_impl Qi \\<pi>i\"\n  shows \"Q_invar Qi' \\<and> M_invar \\<pi>i' \n        \\<and> Q_\\<alpha> Qi' = Qinter Q \\<pi> u \\<and> M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u\"", "lemma prim_invar_impl_init: \"prim_invar_impl (Q_update r 0 Q_empty) M_empty\"", "lemma maintain_prim_invar_impl:  \n  assumes \n      I: \"prim_invar_impl Qi \\<pi>i\" and\n      NE: \"\\<not> Q_is_empty Qi\" and\n      MIN: \"Q_getmin Qi = (u, d)\" and\n      FOREACH: \"foreach_impl Qi \\<pi>i u (G_adj g u) = (Qi', \\<pi>i')\"\n  shows \"prim_invar_impl (Q_delete u Qi') \\<pi>i'\" (is ?G1)\n     and \"T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi,\\<pi>i)\" (is \"?G2\")", "lemma maintain_prim_invar_impl_presentation:  \n  assumes \n      I: \"prim_invar_impl Qi \\<pi>i\" and\n      NE: \"\\<not> Q_is_empty Qi\" and\n      MIN: \"Q_getmin Qi = (u, d)\" and\n      FOREACH: \"foreach_impl Qi \\<pi>i u (G_adj g u) = (Qi', \\<pi>i')\"\n  shows \"prim_invar_impl (Q_delete u Qi') \\<pi>i'\n       \\<and> T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi,\\<pi>i)\"", "lemma prim_invar_impl_finish:\n  \"\\<lbrakk>Q_is_empty Q; prim_invar_impl Q \\<pi>\\<rbrakk> \n    \\<Longrightarrow> invar_MST \\<pi> \\<and> is_MST (G_\\<alpha>w g) rg (\\<alpha>_MST \\<pi>)\"", "lemma prim_impl_correct:\n  assumes \"prim_impl = \\<pi>i\"\n  shows \n    \"invar_MST \\<pi>i\" (is ?G1)\n    \"is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r) (\\<alpha>_MST \\<pi>i)\" (is ?G2)", "lemma prim_impl_correct_presentation:\n  \"invar_MST prim_impl \n  \\<and> is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r) (\\<alpha>_MST prim_impl)\"", "lemma G_from_list_unfold:  \"G_from_list = G.from_list\"", "lemma [code]: \"G_from_list l = foldr (\\<lambda>(e, d). G_add_edge e d) l G_empty\"", "lemmas [code] = P.prim_impl_alt", "lemmas prim_impl_correct = AUX.prim_impl_correct[folded prim_impl_def]", "theorem prim_list_impl_correct:\n  shows \"case prim_list_impl l r of \n    None \\<Rightarrow> \\<not>G.valid_wgraph_repr l \\<comment> \\<open>Invalid input\\<close>\n  | Some \\<pi>i \\<Rightarrow> \n        G.valid_wgraph_repr l \\<and> (let Gi = G.from_list l in G.invar Gi \\<comment> \\<open>Valid input\\<close>\n        \\<and> P.invar_MST \\<pi>i \\<comment> \\<open>Output satisfies invariants\\<close>\n        \\<and> is_MST (G.\\<alpha>w Gi) (component_of (G.\\<alpha>g Gi) r) (P.\\<alpha>_MST r \\<pi>i)) \\<comment> \\<open>and represents MST\\<close>\"", "theorem prim_list_impl_correct_presentation:\n  shows \"case prim_list_impl l r of \n    None \\<Rightarrow> \\<not>G.valid_wgraph_repr l \\<comment> \\<open>Invalid input\\<close>\n  | Some \\<pi>i \\<Rightarrow> let \n      g=G.\\<alpha>g (G.from_list l); \n      w=G.\\<alpha>w (G.from_list l); \n      rg=component_of g r;\n      t=P.\\<alpha>_MST r \\<pi>i\n    in \n        G.valid_wgraph_repr l \\<comment> \\<open>Valid input\\<close> \n      \\<and> P.invar_MST \\<pi>i \\<comment> \\<open>Output satisfies invariants\\<close>\n      \\<and> is_MST w rg t \\<comment> \\<open>and represents MST\\<close>\""], "translations": [["", "lemmas [simp] = G.wgraph_specs"], ["", "lemmas [simp] = M.map_specs"], ["", "lemmas [simp] = Q.prio_map_specs"], ["", "end"], ["", "locale Prim_Impl_Defs = Prim_Impl_Adts  \n  where typG = typG and typM = typM and typQ = typQ and G_\\<alpha>w = G_\\<alpha>w and G_\\<alpha>g = G_\\<alpha>g\n  for typG :: \"'g itself\" and typM :: \"'m itself\" and typQ :: \"'q itself\" \n  and G_\\<alpha>w and G_\\<alpha>g :: \"'g \\<Rightarrow> ('v::linorder) ugraph\" and g :: 'g and r :: 'v\nbegin"], ["", "subsubsection \\<open>Concrete Algorithm\\<close>"], ["", "term M_lookup"], ["", "definition \"foreach_impl_body u \\<equiv> (\\<lambda>(v,d) (Qi,\\<pi>i).\n  if v=r then (Qi,\\<pi>i)\n  else \n    case (Q_lookup Qi v, M_lookup \\<pi>i v) of\n      (None,None) \\<Rightarrow> (Q_update v d Qi, M_update v u \\<pi>i)\n    | (Some d',_) \\<Rightarrow> (if d<d' then (Q_update v d Qi, M_update v u \\<pi>i) else (Qi,\\<pi>i))\n    | (None, Some _) \\<Rightarrow> (Qi,\\<pi>i)\n  )\""], ["", "definition foreach_impl :: \"'q \\<Rightarrow> 'm \\<Rightarrow> 'v \\<Rightarrow> ('v\\<times>nat) list \\<Rightarrow> 'q \\<times> 'm\" where\n  \"foreach_impl Qi \\<pi>i u adjs = foldr (foreach_impl_body u) adjs (Qi,\\<pi>i)\""], ["", "definition \"outer_loop_impl Qi \\<pi>i \\<equiv> while (\\<lambda>(Qi,\\<pi>i). \\<not>Q_is_empty Qi) (\\<lambda>(Qi,\\<pi>i). \n  let\n    (u,_) = Q_getmin Qi;\n    adjs = G_adj g u;\n    (Qi,\\<pi>i) = foreach_impl Qi \\<pi>i u adjs;\n    Qi = Q_delete u Qi\n  in (Qi,\\<pi>i)) (Qi,\\<pi>i)\""], ["", "definition \"prim_impl = (let\n  Qi = Q_update r 0 Q_empty;\n  \\<pi>i = M_empty;\n  (Qi,\\<pi>i) = outer_loop_impl Qi \\<pi>i\n  in \\<pi>i)\n\""], ["", "text \\<open>The whole algorithm as one function\\<close>"], ["", "lemma prim_impl_alt: \"prim_impl = (let \n  \\<comment> \\<open>Initialization\\<close>\n  (Q,\\<pi>) = (Q_update r 0 Q_empty, M_empty);\n  \\<comment> \\<open>Main loop: Iterate until PQ is empty\\<close>\n  (Q, \\<pi>) = \n  while (\\<lambda>(Q, \\<pi>). \\<not> Q_is_empty Q) (\\<lambda>(Q, \\<pi>). let \n    (u, _) = Q_getmin Q;\n    \\<comment> \\<open>Inner loop: Update for adjacent nodes\\<close>\n    (Q, \\<pi>) = \n    foldr ((\\<lambda>(v, d) (Q, \\<pi>). let\n        qv = Q_lookup Q v;\n        \\<pi>v = M_lookup \\<pi> v\n      in\n        if v\\<noteq>r \\<and> (qv\\<noteq>None \\<or> \\<pi>v=None) \\<and> enat d < enat_of_option qv \n        then (Q_update v d Q, M_update v u \\<pi>) \n        else (Q, \\<pi>))\n    ) (G_adj g u) (Q, \\<pi>); \n    Q = Q_delete u Q\n    in (Q, \\<pi>)) (Q, \\<pi>)\n  in \\<pi>\n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_impl =\n    (let (Q, \\<pi>) = (Q_update r 0 Q_empty, M_empty);\n         (Q, \\<pi>) =\n           while (\\<lambda>(Q, \\<pi>). \\<not> Q_is_empty Q)\n            (\\<lambda>(Q, \\<pi>).\n                let (u, uu_) = Q_getmin Q;\n                    (Q, \\<pi>) =\n                      foldr\n                       (\\<lambda>(v, d) (Q, \\<pi>).\n                           let qv = Q_lookup Q v; \\<pi>v = M_lookup \\<pi> v\n                           in if v \\<noteq> r \\<and>\n                                 (qv \\<noteq> None \\<or>\n                                  \\<pi>v = None) \\<and>\n                                 enat d < enat_of_option qv\n                              then (Q_update v d Q, M_update v u \\<pi>)\n                              else (Q, \\<pi>))\n                       (G_adj g u) (Q, \\<pi>);\n                    Q = Q_delete u Q\n                in (Q, \\<pi>))\n            (Q, \\<pi>)\n     in \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prim_impl =\n    (let (Q, \\<pi>) = (Q_update r 0 Q_empty, M_empty);\n         (Q, \\<pi>) =\n           while (\\<lambda>(Q, \\<pi>). \\<not> Q_is_empty Q)\n            (\\<lambda>(Q, \\<pi>).\n                let (u, uu_) = Q_getmin Q;\n                    (Q, \\<pi>) =\n                      foldr\n                       (\\<lambda>(v, d) (Q, \\<pi>).\n                           let qv = Q_lookup Q v; \\<pi>v = M_lookup \\<pi> v\n                           in if v \\<noteq> r \\<and>\n                                 (qv \\<noteq> None \\<or>\n                                  \\<pi>v = None) \\<and>\n                                 enat d < enat_of_option qv\n                              then (Q_update v d Q, M_update v u \\<pi>)\n                              else (Q, \\<pi>))\n                       (G_adj g u) (Q, \\<pi>);\n                    Q = Q_delete u Q\n                in (Q, \\<pi>))\n            (Q, \\<pi>)\n     in \\<pi>)", "have 1: \"foreach_impl_body u = (\\<lambda>(v,d) (Qi,\\<pi>i). let\n        qiv = (Q_lookup Qi v);\n        \\<pi>iv = M_lookup \\<pi>i v\n      in\n        if v\\<noteq>r \\<and> (qiv\\<noteq>None \\<or> \\<pi>iv=None) \\<and> enat d < enat_of_option qiv \n        then (Q_update v d Qi, M_update v u \\<pi>i) \n        else (Qi, \\<pi>i))\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. foreach_impl_body u =\n    (\\<lambda>(v, d) (Qi, \\<pi>i).\n        let qiv = Q_lookup Qi v; \\<pi>iv = M_lookup \\<pi>i v\n        in if v \\<noteq> r \\<and>\n              (qiv \\<noteq> None \\<or> \\<pi>iv = None) \\<and>\n              enat d < enat_of_option qiv\n           then (Q_update v d Qi, M_update v u \\<pi>i) else (Qi, \\<pi>i))", "unfolding foreach_impl_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(v, d) (Qi, \\<pi>i).\n        if v = r then (Qi, \\<pi>i)\n        else case (Q_lookup Qi v, M_lookup \\<pi>i v) of\n             (None, None) \\<Rightarrow>\n               (Q_update v d Qi, M_update v u \\<pi>i)\n             | (None, Some xa) \\<Rightarrow> (Qi, \\<pi>i)\n             | (Some d', x) \\<Rightarrow>\n                 if d < d' then (Q_update v d Qi, M_update v u \\<pi>i)\n                 else (Qi, \\<pi>i)) =\n    (\\<lambda>(v, d) (Qi, \\<pi>i).\n        let qiv = Q_lookup Qi v; \\<pi>iv = M_lookup \\<pi>i v\n        in if v \\<noteq> r \\<and>\n              (qiv \\<noteq> None \\<or> \\<pi>iv = None) \\<and>\n              enat d < enat_of_option qiv\n           then (Q_update v d Qi, M_update v u \\<pi>i) else (Qi, \\<pi>i))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (case x of\n        (v, d) \\<Rightarrow>\n          \\<lambda>(Qi, \\<pi>i).\n             if v = r then (Qi, \\<pi>i)\n             else case (Q_lookup Qi v, M_lookup \\<pi>i v) of\n                  (None, None) \\<Rightarrow>\n                    (Q_update v d Qi, M_update v u \\<pi>i)\n                  | (None, Some xa) \\<Rightarrow> (Qi, \\<pi>i)\n                  | (Some d', x) \\<Rightarrow>\n                      if d < d' then (Q_update v d Qi, M_update v u \\<pi>i)\n                      else (Qi, \\<pi>i))\n        xa =\n       (case x of\n        (v, d) \\<Rightarrow>\n          \\<lambda>(Qi, \\<pi>i).\n             let qiv = Q_lookup Qi v; \\<pi>iv = M_lookup \\<pi>i v\n             in if v \\<noteq> r \\<and>\n                   (qiv \\<noteq> None \\<or> \\<pi>iv = None) \\<and>\n                   enat d < enat_of_option qiv\n                then (Q_update v d Qi, M_update v u \\<pi>i)\n                else (Qi, \\<pi>i))\n        xa", "by (auto split: option.split)"], ["proof (state)\nthis:\n  foreach_impl_body ?u =\n  (\\<lambda>(v, d) (Qi, \\<pi>i).\n      let qiv = Q_lookup Qi v; \\<pi>iv = M_lookup \\<pi>i v\n      in if v \\<noteq> r \\<and>\n            (qiv \\<noteq> None \\<or> \\<pi>iv = None) \\<and>\n            enat d < enat_of_option qiv\n         then (Q_update v d Qi, M_update v ?u \\<pi>i) else (Qi, \\<pi>i))\n\ngoal (1 subgoal):\n 1. prim_impl =\n    (let (Q, \\<pi>) = (Q_update r 0 Q_empty, M_empty);\n         (Q, \\<pi>) =\n           while (\\<lambda>(Q, \\<pi>). \\<not> Q_is_empty Q)\n            (\\<lambda>(Q, \\<pi>).\n                let (u, uu_) = Q_getmin Q;\n                    (Q, \\<pi>) =\n                      foldr\n                       (\\<lambda>(v, d) (Q, \\<pi>).\n                           let qv = Q_lookup Q v; \\<pi>v = M_lookup \\<pi> v\n                           in if v \\<noteq> r \\<and>\n                                 (qv \\<noteq> None \\<or>\n                                  \\<pi>v = None) \\<and>\n                                 enat d < enat_of_option qv\n                              then (Q_update v d Q, M_update v u \\<pi>)\n                              else (Q, \\<pi>))\n                       (G_adj g u) (Q, \\<pi>);\n                    Q = Q_delete u Q\n                in (Q, \\<pi>))\n            (Q, \\<pi>)\n     in \\<pi>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_impl =\n    (let (Q, \\<pi>) = (Q_update r 0 Q_empty, M_empty);\n         (Q, \\<pi>) =\n           while (\\<lambda>(Q, \\<pi>). \\<not> Q_is_empty Q)\n            (\\<lambda>(Q, \\<pi>).\n                let (u, uu_) = Q_getmin Q;\n                    (Q, \\<pi>) =\n                      foldr\n                       (\\<lambda>(v, d) (Q, \\<pi>).\n                           let qv = Q_lookup Q v; \\<pi>v = M_lookup \\<pi> v\n                           in if v \\<noteq> r \\<and>\n                                 (qv \\<noteq> None \\<or>\n                                  \\<pi>v = None) \\<and>\n                                 enat d < enat_of_option qv\n                              then (Q_update v d Q, M_update v u \\<pi>)\n                              else (Q, \\<pi>))\n                       (G_adj g u) (Q, \\<pi>);\n                    Q = Q_delete u Q\n                in (Q, \\<pi>))\n            (Q, \\<pi>)\n     in \\<pi>)", "unfolding prim_impl_def outer_loop_impl_def foreach_impl_def 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let Qi = Q_update r 0 Q_empty; \\<pi>i = M_empty;\n         (Qi, \\<pi>i) =\n           while (\\<lambda>(Qi, \\<pi>i). \\<not> Q_is_empty Qi)\n            (\\<lambda>(Qi, \\<pi>i).\n                let (u, uu_) = Q_getmin Qi; adjs = G_adj g u;\n                    (Qi, \\<pi>i) =\n                      foldr\n                       (\\<lambda>(v, d) (Qi, \\<pi>i).\n                           let qiv = Q_lookup Qi v;\n                               \\<pi>iv = M_lookup \\<pi>i v\n                           in if v \\<noteq> r \\<and>\n                                 (qiv \\<noteq> None \\<or>\n                                  \\<pi>iv = None) \\<and>\n                                 enat d < enat_of_option qiv\n                              then (Q_update v d Qi, M_update v u \\<pi>i)\n                              else (Qi, \\<pi>i))\n                       adjs (Qi, \\<pi>i);\n                    Qi = Q_delete u Qi\n                in (Qi, \\<pi>i))\n            (Qi, \\<pi>i)\n     in \\<pi>i) =\n    (let (Q, \\<pi>) = (Q_update r 0 Q_empty, M_empty);\n         (Q, \\<pi>) =\n           while (\\<lambda>(Q, \\<pi>). \\<not> Q_is_empty Q)\n            (\\<lambda>(Q, \\<pi>).\n                let (u, uu_) = Q_getmin Q;\n                    (Q, \\<pi>) =\n                      foldr\n                       (\\<lambda>(v, d) (Q, \\<pi>).\n                           let qv = Q_lookup Q v; \\<pi>v = M_lookup \\<pi> v\n                           in if v \\<noteq> r \\<and>\n                                 (qv \\<noteq> None \\<or>\n                                  \\<pi>v = None) \\<and>\n                                 enat d < enat_of_option qv\n                              then (Q_update v d Q, M_update v u \\<pi>)\n                              else (Q, \\<pi>))\n                       (G_adj g u) (Q, \\<pi>);\n                    Q = Q_delete u Q\n                in (Q, \\<pi>))\n            (Q, \\<pi>)\n     in \\<pi>)", "by (simp)"], ["proof (state)\nthis:\n  prim_impl =\n  (let (Q, \\<pi>) = (Q_update r 0 Q_empty, M_empty);\n       (Q, \\<pi>) =\n         while (\\<lambda>(Q, \\<pi>). \\<not> Q_is_empty Q)\n          (\\<lambda>(Q, \\<pi>).\n              let (u, uu_) = Q_getmin Q;\n                  (Q, \\<pi>) =\n                    foldr\n                     (\\<lambda>(v, d) (Q, \\<pi>).\n                         let qv = Q_lookup Q v; \\<pi>v = M_lookup \\<pi> v\n                         in if v \\<noteq> r \\<and>\n                               (qv \\<noteq> None \\<or> \\<pi>v = None) \\<and>\n                               enat d < enat_of_option qv\n                            then (Q_update v d Q, M_update v u \\<pi>)\n                            else (Q, \\<pi>))\n                     (G_adj g u) (Q, \\<pi>);\n                  Q = Q_delete u Q\n              in (Q, \\<pi>))\n          (Q, \\<pi>)\n   in \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Abstraction of Result\\<close>"], ["", "text \\<open>Invariant for the result, and its interpretation as (minimum spanning) tree:\n  \\<^item> The map \\<open>\\<pi>i\\<close> and set \\<open>Vi\\<close> satisfy their implementation invariants\n  \\<^item> The \\<open>\\<pi>i\\<close> encodes irreflexive edges consistent with the nodes determined \n    by \\<open>Vi\\<close>. Note that the edges in \\<open>\\<pi>i\\<close> will not be symmetric, thus we take \n    their symmetric closure \\<open>E\\<union>E\\<inverse>\\<close>.\n    \n\\<close>"], ["", "definition \"invar_MST \\<pi>i \\<equiv> M_invar \\<pi>i\""], ["", "definition \"\\<alpha>_MST \\<pi>i \\<equiv> graph {r} {(u,v) | u v. M_lookup \\<pi>i u = Some v}\""], ["", "end"], ["", "subsection \\<open>Refinement of State\\<close>"], ["", "locale Prim_Impl = Prim_Impl_Defs \n  where typG = typG and typM = typM and typQ = typQ and G_\\<alpha>w = G_\\<alpha>w and G_\\<alpha>g = G_\\<alpha>g\n  for typG :: \"'g itself\" and typM :: \"'m itself\" and typQ :: \"'q itself\" \n  and G_\\<alpha>w and G_\\<alpha>g :: \"'g \\<Rightarrow> ('v::linorder) ugraph\" \n  +\n  assumes G_invar[simp]: \"G_invar g\"\nbegin"], ["", "sublocale Prim2 \"G_\\<alpha>w g\" \"G_\\<alpha>g g\" r"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsubsection \\<open>Abstraction of \\<open>Q\\<close>\\<close>"], ["", "text \\<open>The priority map implements a function of type @{typ \\<open>'v\\<Rightarrow>enat\\<close>}, \n  mapping @{const None} to @{term \\<infinity>}.\n\\<close>"], ["", "definition \"Q_\\<alpha> Qi \\<equiv> enat_of_option o Q_lookup Qi :: 'v \\<Rightarrow> enat\""], ["", "lemma Q_\\<alpha>_empty: \"Q_\\<alpha> Q_empty = (\\<lambda>_. \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_\\<alpha> Q_empty = (\\<lambda>_. \\<infinity>)", "unfolding Q_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. enat_of_option \\<circ> Q_lookup Q_empty = (\\<lambda>_. \\<infinity>)", "by (auto)"], ["", "lemma Q_\\<alpha>_update: \"Q_invar Q \\<Longrightarrow> Q_\\<alpha> (Q_update u d Q) = (Q_\\<alpha> Q)(u := enat d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_invar Q \\<Longrightarrow>\n    Q_\\<alpha> (Q_update u d Q) = (Q_\\<alpha> Q)(u := enat d)", "unfolding Q_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_invar Q \\<Longrightarrow>\n    enat_of_option \\<circ> Q_lookup (Q_update u d Q) =\n    (enat_of_option \\<circ> Q_lookup Q)(u := enat d)", "by (auto)"], ["", "lemma Q_\\<alpha>_is_empty: \"Q_invar Q \\<Longrightarrow> Q_lookup Q = Map.empty \\<longleftrightarrow> Q_\\<alpha> Q = (\\<lambda>_. \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_invar Q \\<Longrightarrow>\n    (Q_lookup Q = Map.empty) = (Q_\\<alpha> Q = (\\<lambda>_. \\<infinity>))", "unfolding Q_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_invar Q \\<Longrightarrow>\n    (Q_lookup Q = Map.empty) =\n    (enat_of_option \\<circ> Q_lookup Q = (\\<lambda>_. \\<infinity>))", "by (auto simp: fun_eq_iff)"], ["", "lemma Q_\\<alpha>_delete: \"Q_invar Q \\<Longrightarrow> Q_\\<alpha> (Q_delete u Q) = (Q_\\<alpha> Q)(u:=\\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_invar Q \\<Longrightarrow>\n    Q_\\<alpha> (Q_delete u Q) = (Q_\\<alpha> Q)(u := \\<infinity>)", "unfolding Q_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_invar Q \\<Longrightarrow>\n    enat_of_option \\<circ> Q_lookup (Q_delete u Q) =\n    (enat_of_option \\<circ> Q_lookup Q)(u := \\<infinity>)", "by (auto simp: fun_eq_iff)"], ["", "lemma Q_\\<alpha>_min:\n  assumes MIN: \"Q_getmin Qi = (u, d)\"\n  assumes I: \"Q_invar Qi\"\n  assumes NE: \"\\<not> Q_is_empty Qi\"\n  shows \"Q_\\<alpha> Qi u = enat d\" (is ?G1) and\n        \"\\<forall>v. enat d \\<le> Q_\\<alpha> Qi v\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_\\<alpha> Qi u = enat d &&& \\<forall>v. enat d \\<le> Q_\\<alpha> Qi v", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Q_\\<alpha> Qi u = enat d\n 2. \\<forall>v. enat d \\<le> Q_\\<alpha> Qi v", "from Q.map_getmin[OF MIN]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Q_invar Qi; Q_lookup Qi \\<noteq> Map.empty\\<rbrakk>\n  \\<Longrightarrow> Q_lookup Qi u = Some d \\<and>\n                    (\\<forall>p'\\<in>ran (Q_lookup Qi). d \\<le> p')", "have \"Q_lookup Qi u = Some d\" \"(\\<forall>x\\<in>ran (Q_lookup Qi). d \\<le> x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Q_invar Qi; Q_lookup Qi \\<noteq> Map.empty\\<rbrakk>\n  \\<Longrightarrow> Q_lookup Qi u = Some d \\<and>\n                    (\\<forall>p'\\<in>ran (Q_lookup Qi). d \\<le> p')\n\ngoal (1 subgoal):\n 1. Q_lookup Qi u = Some d &&& \\<forall>x\\<in>ran (Q_lookup Qi). d \\<le> x", "using NE I"], ["proof (prove)\nusing this:\n  \\<lbrakk>Q_invar Qi; Q_lookup Qi \\<noteq> Map.empty\\<rbrakk>\n  \\<Longrightarrow> Q_lookup Qi u = Some d \\<and>\n                    (\\<forall>p'\\<in>ran (Q_lookup Qi). d \\<le> p')\n  \\<not> Q_is_empty Qi\n  Q_invar Qi\n\ngoal (1 subgoal):\n 1. Q_lookup Qi u = Some d &&& \\<forall>x\\<in>ran (Q_lookup Qi). d \\<le> x", "by auto"], ["proof (state)\nthis:\n  Q_lookup Qi u = Some d\n  \\<forall>x\\<in>ran (Q_lookup Qi). d \\<le> x\n\ngoal (2 subgoals):\n 1. Q_\\<alpha> Qi u = enat d\n 2. \\<forall>v. enat d \\<le> Q_\\<alpha> Qi v", "thus \"?G1\" \"?G2\""], ["proof (prove)\nusing this:\n  Q_lookup Qi u = Some d\n  \\<forall>x\\<in>ran (Q_lookup Qi). d \\<le> x\n\ngoal (1 subgoal):\n 1. Q_\\<alpha> Qi u = enat d &&& \\<forall>v. enat d \\<le> Q_\\<alpha> Qi v", "unfolding Q_\\<alpha>_def"], ["proof (prove)\nusing this:\n  Q_lookup Qi u = Some d\n  \\<forall>x\\<in>ran (Q_lookup Qi). d \\<le> x\n\ngoal (1 subgoal):\n 1. (enat_of_option \\<circ> Q_lookup Qi) u = enat d &&&\n    \\<forall>v. enat d \\<le> (enat_of_option \\<circ> Q_lookup Qi) v", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q_lookup Qi u = Some d;\n     \\<forall>x\\<in>ran (Q_lookup Qi). d \\<le> x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         enat d \\<le> enat_of_option (Q_lookup Qi v)", "by (metis enat_of_option.elims enat_ord_simps(1) enat_ord_simps(3) ranI)"], ["proof (state)\nthis:\n  Q_\\<alpha> Qi u = enat d\n  \\<forall>v. enat d \\<le> Q_\\<alpha> Qi v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas Q_\\<alpha>_specs = Q_\\<alpha>_empty Q_\\<alpha>_update Q_\\<alpha>_is_empty Q_\\<alpha>_delete"], ["", "subsubsection \\<open>Concrete Invariant\\<close>"], ["", "text \\<open>The implementation invariants of the concrete state's components,\n  and the abstract invariant of the state's abstraction\\<close>"], ["", "definition \"prim_invar_impl Qi \\<pi>i \\<equiv> \n    Q_invar Qi \\<and> M_invar \\<pi>i \\<and> prim_invar2 (Q_\\<alpha> Qi) (M_lookup \\<pi>i)\""], ["", "end"], ["", "subsection \\<open>Refinement of Algorithm\\<close>"], ["", "context Prim_Impl\nbegin"], ["", "lemma foreach_impl_correct:\n  fixes Qi Vi \\<pi>i defines \"Q \\<equiv> Q_\\<alpha> Qi\" and \"\\<pi> \\<equiv> M_lookup \\<pi>i\"\n  assumes A: \"foreach_impl Qi \\<pi>i u (G_adj g u) = (Qi',\\<pi>i')\" \n  assumes I: \"prim_invar_impl Qi \\<pi>i\"\n  shows \"Q_invar Qi'\" and \"M_invar \\<pi>i'\" \n    and \"Q_\\<alpha> Qi' = Qinter Q \\<pi> u\" and \"M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q_invar Qi' &&& M_invar \\<pi>i') &&&\n    Q_\\<alpha> Qi' = Qinter Q \\<pi> u &&&\n    M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. Q_invar Qi'\n 2. M_invar \\<pi>i'\n 3. Q_\\<alpha> Qi' = Qinter Q \\<pi> u\n 4. M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "from I"], ["proof (chain)\npicking this:\n  prim_invar_impl Qi \\<pi>i", "have [simp]: \"Q_invar Qi\" \"M_invar \\<pi>i\""], ["proof (prove)\nusing this:\n  prim_invar_impl Qi \\<pi>i\n\ngoal (1 subgoal):\n 1. Q_invar Qi &&& M_invar \\<pi>i", "unfolding prim_invar_impl_def Q_def \\<pi>_def"], ["proof (prove)\nusing this:\n  Q_invar Qi \\<and>\n  M_invar \\<pi>i \\<and> prim_invar2 (Q_\\<alpha> Qi) (M_lookup \\<pi>i)\n\ngoal (1 subgoal):\n 1. Q_invar Qi &&& M_invar \\<pi>i", "by auto"], ["proof (state)\nthis:\n  Q_invar Qi\n  M_invar \\<pi>i\n\ngoal (4 subgoals):\n 1. Q_invar Qi'\n 2. M_invar \\<pi>i'\n 3. Q_\\<alpha> Qi' = Qinter Q \\<pi> u\n 4. M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "{"], ["proof (state)\nthis:\n  Q_invar Qi\n  M_invar \\<pi>i\n\ngoal (4 subgoals):\n 1. Q_invar Qi'\n 2. M_invar \\<pi>i'\n 3. Q_\\<alpha> Qi' = Qinter Q \\<pi> u\n 4. M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "fix Qi \\<pi>i d v and adjs :: \"('v \\<times> nat) list\""], ["proof (state)\ngoal (4 subgoals):\n 1. Q_invar Qi'\n 2. M_invar \\<pi>i'\n 3. Q_\\<alpha> Qi' = Qinter Q \\<pi> u\n 4. M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "assume \"Q_invar Qi\" \"M_invar \\<pi>i\" \"(v, d) \\<in> set adjs\""], ["proof (state)\nthis:\n  Q_invar Qi\n  M_invar \\<pi>i\n  (v, d) \\<in> set adjs\n\ngoal (4 subgoals):\n 1. Q_invar Qi'\n 2. M_invar \\<pi>i'\n 3. Q_\\<alpha> Qi' = Qinter Q \\<pi> u\n 4. M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "then"], ["proof (chain)\npicking this:\n  Q_invar Qi\n  M_invar \\<pi>i\n  (v, d) \\<in> set adjs", "have \n      \"(case foreach_impl_body u (v, d) (Qi, \\<pi>i) of \n         (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i) \n              \\<and> map_prod Q_\\<alpha> M_lookup (foreach_impl_body u (v, d) (Qi, \\<pi>i)) \n                = foreach_body u (v, d) (Q_\\<alpha> Qi, M_lookup \\<pi>i)\""], ["proof (prove)\nusing this:\n  Q_invar Qi\n  M_invar \\<pi>i\n  (v, d) \\<in> set adjs\n\ngoal (1 subgoal):\n 1. (case foreach_impl_body u (v, d) (Qi, \\<pi>i) of\n     (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n    map_prod Q_\\<alpha> M_lookup (foreach_impl_body u (v, d) (Qi, \\<pi>i)) =\n    foreach_body u (v, d) (Q_\\<alpha> Qi, M_lookup \\<pi>i)", "unfolding foreach_impl_body_def foreach_body_def"], ["proof (prove)\nusing this:\n  Q_invar Qi\n  M_invar \\<pi>i\n  (v, d) \\<in> set adjs\n\ngoal (1 subgoal):\n 1. (case (case (v, d) of\n           (v, d) \\<Rightarrow>\n             \\<lambda>(Qi, \\<pi>i).\n                if v = r then (Qi, \\<pi>i)\n                else case (Q_lookup Qi v, M_lookup \\<pi>i v) of\n                     (None, None) \\<Rightarrow>\n                       (Q_update v d Qi, M_update v u \\<pi>i)\n                     | (None, Some xa) \\<Rightarrow> (Qi, \\<pi>i)\n                     | (Some d', x) \\<Rightarrow>\n                         if d < d'\n                         then (Q_update v d Qi, M_update v u \\<pi>i)\n                         else (Qi, \\<pi>i))\n           (Qi, \\<pi>i) of\n     (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n    map_prod Q_\\<alpha> M_lookup\n     ((case (v, d) of\n       (v, d) \\<Rightarrow>\n         \\<lambda>(Qi, \\<pi>i).\n            if v = r then (Qi, \\<pi>i)\n            else case (Q_lookup Qi v, M_lookup \\<pi>i v) of\n                 (None, None) \\<Rightarrow>\n                   (Q_update v d Qi, M_update v u \\<pi>i)\n                 | (None, Some xa) \\<Rightarrow> (Qi, \\<pi>i)\n                 | (Some d', x) \\<Rightarrow>\n                     if d < d' then (Q_update v d Qi, M_update v u \\<pi>i)\n                     else (Qi, \\<pi>i))\n       (Qi, \\<pi>i)) =\n    (case (v, d) of\n     (v, d) \\<Rightarrow>\n       \\<lambda>(Q, \\<pi>).\n          if v = r then (Q, \\<pi>)\n          else case (Q v, \\<pi> v) of\n               (enat d', x) \\<Rightarrow>\n                 if d < d' then (Q(v := enat d), \\<pi>(v \\<mapsto> u))\n                 else (Q, \\<pi>)\n               | (\\<infinity>, None) \\<Rightarrow>\n                   (Q(v := enat d), \\<pi>(v \\<mapsto> u))\n               | (\\<infinity>, Some xa) \\<Rightarrow> (Q, \\<pi>))\n     (Q_\\<alpha> Qi, M_lookup \\<pi>i)", "unfolding Q_\\<alpha>_def"], ["proof (prove)\nusing this:\n  Q_invar Qi\n  M_invar \\<pi>i\n  (v, d) \\<in> set adjs\n\ngoal (1 subgoal):\n 1. (case (case (v, d) of\n           (v, d) \\<Rightarrow>\n             \\<lambda>(Qi, \\<pi>i).\n                if v = r then (Qi, \\<pi>i)\n                else case (Q_lookup Qi v, M_lookup \\<pi>i v) of\n                     (None, None) \\<Rightarrow>\n                       (Q_update v d Qi, M_update v u \\<pi>i)\n                     | (None, Some xa) \\<Rightarrow> (Qi, \\<pi>i)\n                     | (Some d', x) \\<Rightarrow>\n                         if d < d'\n                         then (Q_update v d Qi, M_update v u \\<pi>i)\n                         else (Qi, \\<pi>i))\n           (Qi, \\<pi>i) of\n     (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n    map_prod (\\<lambda>Qi. enat_of_option \\<circ> Q_lookup Qi) M_lookup\n     ((case (v, d) of\n       (v, d) \\<Rightarrow>\n         \\<lambda>(Qi, \\<pi>i).\n            if v = r then (Qi, \\<pi>i)\n            else case (Q_lookup Qi v, M_lookup \\<pi>i v) of\n                 (None, None) \\<Rightarrow>\n                   (Q_update v d Qi, M_update v u \\<pi>i)\n                 | (None, Some xa) \\<Rightarrow> (Qi, \\<pi>i)\n                 | (Some d', x) \\<Rightarrow>\n                     if d < d' then (Q_update v d Qi, M_update v u \\<pi>i)\n                     else (Qi, \\<pi>i))\n       (Qi, \\<pi>i)) =\n    (case (v, d) of\n     (v, d) \\<Rightarrow>\n       \\<lambda>(Q, \\<pi>).\n          if v = r then (Q, \\<pi>)\n          else case (Q v, \\<pi> v) of\n               (enat d', x) \\<Rightarrow>\n                 if d < d' then (Q(v := enat d), \\<pi>(v \\<mapsto> u))\n                 else (Q, \\<pi>)\n               | (\\<infinity>, None) \\<Rightarrow>\n                   (Q(v := enat d), \\<pi>(v \\<mapsto> u))\n               | (\\<infinity>, Some xa) \\<Rightarrow> (Q, \\<pi>))\n     (enat_of_option \\<circ> Q_lookup Qi, M_lookup \\<pi>i)", "by (auto simp: fun_eq_iff split: option.split)"], ["proof (state)\nthis:\n  (case foreach_impl_body u (v, d) (Qi, \\<pi>i) of\n   (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n  map_prod Q_\\<alpha> M_lookup (foreach_impl_body u (v, d) (Qi, \\<pi>i)) =\n  foreach_body u (v, d) (Q_\\<alpha> Qi, M_lookup \\<pi>i)\n\ngoal (4 subgoals):\n 1. Q_invar Qi'\n 2. M_invar \\<pi>i'\n 3. Q_\\<alpha> Qi' = Qinter Q \\<pi> u\n 4. M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Q_invar ?Qia3; M_invar ?\\<pi>ia3;\n   (?v3, ?d3) \\<in> set ?adjs3\\<rbrakk>\n  \\<Longrightarrow> (case foreach_impl_body u (?v3, ?d3)\n                           (?Qia3, ?\\<pi>ia3) of\n                     (Qi, \\<pi>i) \\<Rightarrow>\n                       Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                    map_prod Q_\\<alpha> M_lookup\n                     (foreach_impl_body u (?v3, ?d3) (?Qia3, ?\\<pi>ia3)) =\n                    foreach_body u (?v3, ?d3)\n                     (Q_\\<alpha> ?Qia3, M_lookup ?\\<pi>ia3)\n\ngoal (4 subgoals):\n 1. Q_invar Qi'\n 2. M_invar \\<pi>i'\n 3. Q_\\<alpha> Qi' = Qinter Q \\<pi> u\n 4. M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "note aux=this"], ["proof (state)\nthis:\n  \\<lbrakk>Q_invar ?Qia3; M_invar ?\\<pi>ia3;\n   (?v3, ?d3) \\<in> set ?adjs3\\<rbrakk>\n  \\<Longrightarrow> (case foreach_impl_body u (?v3, ?d3)\n                           (?Qia3, ?\\<pi>ia3) of\n                     (Qi, \\<pi>i) \\<Rightarrow>\n                       Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                    map_prod Q_\\<alpha> M_lookup\n                     (foreach_impl_body u (?v3, ?d3) (?Qia3, ?\\<pi>ia3)) =\n                    foreach_body u (?v3, ?d3)\n                     (Q_\\<alpha> ?Qia3, M_lookup ?\\<pi>ia3)\n\ngoal (4 subgoals):\n 1. Q_invar Qi'\n 2. M_invar \\<pi>i'\n 3. Q_\\<alpha> Qi' = Qinter Q \\<pi> u\n 4. M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "from foldr_refine[\n    where I=\"\\<lambda>(Qi,\\<pi>i). Q_invar Qi \\<and> M_invar \\<pi>i\" and \\<alpha>=\"map_prod Q_\\<alpha> M_lookup\",\n    of \"(Qi,\\<pi>i)\" \"(G_adj g u)\" \"foreach_impl_body u\" \"foreach_body u\"\n    ]\n  and A aux[where ?adjs3=\"(G_adj g u)\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>case (Qi, \\<pi>i) of\n           (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i;\n   \\<And>s x.\n      \\<lbrakk>case s of\n               (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i;\n       x \\<in> set (G_adj g u)\\<rbrakk>\n      \\<Longrightarrow> (case foreach_impl_body u x s of\n                         (Qi, \\<pi>i) \\<Rightarrow>\n                           Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                        map_prod Q_\\<alpha> M_lookup\n                         (foreach_impl_body u x s) =\n                        foreach_body u x\n                         (map_prod Q_\\<alpha> M_lookup s)\\<rbrakk>\n  \\<Longrightarrow> (case foldr (foreach_impl_body u) (G_adj g u)\n                           (Qi, \\<pi>i) of\n                     (Qi, \\<pi>i) \\<Rightarrow>\n                       Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                    map_prod Q_\\<alpha> M_lookup\n                     (foldr (foreach_impl_body u) (G_adj g u)\n                       (Qi, \\<pi>i)) =\n                    foldr (foreach_body u) (G_adj g u)\n                     (map_prod Q_\\<alpha> M_lookup (Qi, \\<pi>i))\n  foreach_impl Qi \\<pi>i u (G_adj g u) = (Qi', \\<pi>i')\n  \\<lbrakk>Q_invar ?Qia3; M_invar ?\\<pi>ia3;\n   (?v3, ?d3) \\<in> set (G_adj g u)\\<rbrakk>\n  \\<Longrightarrow> (case foreach_impl_body u (?v3, ?d3)\n                           (?Qia3, ?\\<pi>ia3) of\n                     (Qi, \\<pi>i) \\<Rightarrow>\n                       Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                    map_prod Q_\\<alpha> M_lookup\n                     (foreach_impl_body u (?v3, ?d3) (?Qia3, ?\\<pi>ia3)) =\n                    foreach_body u (?v3, ?d3)\n                     (Q_\\<alpha> ?Qia3, M_lookup ?\\<pi>ia3)", "have \"Q_invar Qi'\" \"M_invar \\<pi>i'\" \n      and 1: \"foreach u (G_adj g u) (Q_\\<alpha> Qi, M_lookup \\<pi>i) \n              = (Q_\\<alpha> Qi', M_lookup \\<pi>i')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>case (Qi, \\<pi>i) of\n           (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i;\n   \\<And>s x.\n      \\<lbrakk>case s of\n               (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i;\n       x \\<in> set (G_adj g u)\\<rbrakk>\n      \\<Longrightarrow> (case foreach_impl_body u x s of\n                         (Qi, \\<pi>i) \\<Rightarrow>\n                           Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                        map_prod Q_\\<alpha> M_lookup\n                         (foreach_impl_body u x s) =\n                        foreach_body u x\n                         (map_prod Q_\\<alpha> M_lookup s)\\<rbrakk>\n  \\<Longrightarrow> (case foldr (foreach_impl_body u) (G_adj g u)\n                           (Qi, \\<pi>i) of\n                     (Qi, \\<pi>i) \\<Rightarrow>\n                       Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                    map_prod Q_\\<alpha> M_lookup\n                     (foldr (foreach_impl_body u) (G_adj g u)\n                       (Qi, \\<pi>i)) =\n                    foldr (foreach_body u) (G_adj g u)\n                     (map_prod Q_\\<alpha> M_lookup (Qi, \\<pi>i))\n  foreach_impl Qi \\<pi>i u (G_adj g u) = (Qi', \\<pi>i')\n  \\<lbrakk>Q_invar ?Qia3; M_invar ?\\<pi>ia3;\n   (?v3, ?d3) \\<in> set (G_adj g u)\\<rbrakk>\n  \\<Longrightarrow> (case foreach_impl_body u (?v3, ?d3)\n                           (?Qia3, ?\\<pi>ia3) of\n                     (Qi, \\<pi>i) \\<Rightarrow>\n                       Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                    map_prod Q_\\<alpha> M_lookup\n                     (foreach_impl_body u (?v3, ?d3) (?Qia3, ?\\<pi>ia3)) =\n                    foreach_body u (?v3, ?d3)\n                     (Q_\\<alpha> ?Qia3, M_lookup ?\\<pi>ia3)\n\ngoal (1 subgoal):\n 1. (Q_invar Qi' &&& M_invar \\<pi>i') &&&\n    foreach u (G_adj g u) (Q_\\<alpha> Qi, M_lookup \\<pi>i) =\n    (Q_\\<alpha> Qi', M_lookup \\<pi>i')", "unfolding foreach_impl_def foreach_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>case (Qi, \\<pi>i) of\n           (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i;\n   \\<And>s x.\n      \\<lbrakk>case s of\n               (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i;\n       x \\<in> set (G_adj g u)\\<rbrakk>\n      \\<Longrightarrow> (case foreach_impl_body u x s of\n                         (Qi, \\<pi>i) \\<Rightarrow>\n                           Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                        map_prod Q_\\<alpha> M_lookup\n                         (foreach_impl_body u x s) =\n                        foreach_body u x\n                         (map_prod Q_\\<alpha> M_lookup s)\\<rbrakk>\n  \\<Longrightarrow> (case foldr (foreach_impl_body u) (G_adj g u)\n                           (Qi, \\<pi>i) of\n                     (Qi, \\<pi>i) \\<Rightarrow>\n                       Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                    map_prod Q_\\<alpha> M_lookup\n                     (foldr (foreach_impl_body u) (G_adj g u)\n                       (Qi, \\<pi>i)) =\n                    foldr (foreach_body u) (G_adj g u)\n                     (map_prod Q_\\<alpha> M_lookup (Qi, \\<pi>i))\n  foldr (foreach_impl_body u) (G_adj g u) (Qi, \\<pi>i) = (Qi', \\<pi>i')\n  \\<lbrakk>Q_invar ?Qia3; M_invar ?\\<pi>ia3;\n   (?v3, ?d3) \\<in> set (G_adj g u)\\<rbrakk>\n  \\<Longrightarrow> (case foreach_impl_body u (?v3, ?d3)\n                           (?Qia3, ?\\<pi>ia3) of\n                     (Qi, \\<pi>i) \\<Rightarrow>\n                       Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                    map_prod Q_\\<alpha> M_lookup\n                     (foreach_impl_body u (?v3, ?d3) (?Qia3, ?\\<pi>ia3)) =\n                    foreach_body u (?v3, ?d3)\n                     (Q_\\<alpha> ?Qia3, M_lookup ?\\<pi>ia3)\n\ngoal (1 subgoal):\n 1. (Q_invar Qi' &&& M_invar \\<pi>i') &&&\n    foldr (foreach_body u) (G_adj g u) (Q_\\<alpha> Qi, M_lookup \\<pi>i) =\n    (Q_\\<alpha> Qi', M_lookup \\<pi>i')", "unfolding Q_def \\<pi>_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>case (Qi, \\<pi>i) of\n           (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i;\n   \\<And>s x.\n      \\<lbrakk>case s of\n               (Qi, \\<pi>i) \\<Rightarrow> Q_invar Qi \\<and> M_invar \\<pi>i;\n       x \\<in> set (G_adj g u)\\<rbrakk>\n      \\<Longrightarrow> (case foreach_impl_body u x s of\n                         (Qi, \\<pi>i) \\<Rightarrow>\n                           Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                        map_prod Q_\\<alpha> M_lookup\n                         (foreach_impl_body u x s) =\n                        foreach_body u x\n                         (map_prod Q_\\<alpha> M_lookup s)\\<rbrakk>\n  \\<Longrightarrow> (case foldr (foreach_impl_body u) (G_adj g u)\n                           (Qi, \\<pi>i) of\n                     (Qi, \\<pi>i) \\<Rightarrow>\n                       Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                    map_prod Q_\\<alpha> M_lookup\n                     (foldr (foreach_impl_body u) (G_adj g u)\n                       (Qi, \\<pi>i)) =\n                    foldr (foreach_body u) (G_adj g u)\n                     (map_prod Q_\\<alpha> M_lookup (Qi, \\<pi>i))\n  foldr (foreach_impl_body u) (G_adj g u) (Qi, \\<pi>i) = (Qi', \\<pi>i')\n  \\<lbrakk>Q_invar ?Qia3; M_invar ?\\<pi>ia3;\n   (?v3, ?d3) \\<in> set (G_adj g u)\\<rbrakk>\n  \\<Longrightarrow> (case foreach_impl_body u (?v3, ?d3)\n                           (?Qia3, ?\\<pi>ia3) of\n                     (Qi, \\<pi>i) \\<Rightarrow>\n                       Q_invar Qi \\<and> M_invar \\<pi>i) \\<and>\n                    map_prod Q_\\<alpha> M_lookup\n                     (foreach_impl_body u (?v3, ?d3) (?Qia3, ?\\<pi>ia3)) =\n                    foreach_body u (?v3, ?d3)\n                     (Q_\\<alpha> ?Qia3, M_lookup ?\\<pi>ia3)\n\ngoal (1 subgoal):\n 1. (Q_invar Qi' &&& M_invar \\<pi>i') &&&\n    foldr (foreach_body u) (G_adj g u) (Q_\\<alpha> Qi, M_lookup \\<pi>i) =\n    (Q_\\<alpha> Qi', M_lookup \\<pi>i')", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  Q_invar Qi'\n  M_invar \\<pi>i'\n  foreach u (G_adj g u) (Q_\\<alpha> Qi, M_lookup \\<pi>i) =\n  (Q_\\<alpha> Qi', M_lookup \\<pi>i')\n\ngoal (4 subgoals):\n 1. Q_invar Qi'\n 2. M_invar \\<pi>i'\n 3. Q_\\<alpha> Qi' = Qinter Q \\<pi> u\n 4. M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "then"], ["proof (chain)\npicking this:\n  Q_invar Qi'\n  M_invar \\<pi>i'\n  foreach u (G_adj g u) (Q_\\<alpha> Qi, M_lookup \\<pi>i) =\n  (Q_\\<alpha> Qi', M_lookup \\<pi>i')", "show \"Q_invar Qi'\" \"M_invar \\<pi>i'\""], ["proof (prove)\nusing this:\n  Q_invar Qi'\n  M_invar \\<pi>i'\n  foreach u (G_adj g u) (Q_\\<alpha> Qi, M_lookup \\<pi>i) =\n  (Q_\\<alpha> Qi', M_lookup \\<pi>i')\n\ngoal (1 subgoal):\n 1. Q_invar Qi' &&& M_invar \\<pi>i'", "by auto"], ["proof (state)\nthis:\n  Q_invar Qi'\n  M_invar \\<pi>i'\n\ngoal (2 subgoals):\n 1. Q_\\<alpha> Qi' = Qinter Q \\<pi> u\n 2. M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "from 1 foreach_refine[where adjs=\"G_adj g u\" and u=u]"], ["proof (chain)\npicking this:\n  foreach u (G_adj g u) (Q_\\<alpha> Qi, M_lookup \\<pi>i) =\n  (Q_\\<alpha> Qi', M_lookup \\<pi>i')\n  set (G_adj g u) =\n  {(v, d).\n   (u, v) \\<in> edges (G_\\<alpha>g g) \\<and>\n   G_\\<alpha>w g {u, v} = d} \\<Longrightarrow>\n  foreach u (G_adj g u) (?Q, ?\\<pi>) =\n  (Qinter ?Q ?\\<pi> u, \\<pi>' ?Q ?\\<pi> u)", "show \n    \"Q_\\<alpha> Qi' = Qinter Q \\<pi> u\" and \"M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u\""], ["proof (prove)\nusing this:\n  foreach u (G_adj g u) (Q_\\<alpha> Qi, M_lookup \\<pi>i) =\n  (Q_\\<alpha> Qi', M_lookup \\<pi>i')\n  set (G_adj g u) =\n  {(v, d).\n   (u, v) \\<in> edges (G_\\<alpha>g g) \\<and>\n   G_\\<alpha>w g {u, v} = d} \\<Longrightarrow>\n  foreach u (G_adj g u) (?Q, ?\\<pi>) =\n  (Qinter ?Q ?\\<pi> u, \\<pi>' ?Q ?\\<pi> u)\n\ngoal (1 subgoal):\n 1. Q_\\<alpha> Qi' = Qinter Q \\<pi> u &&&\n    M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "by (auto simp: Q_def \\<pi>_def)"], ["proof (state)\nthis:\n  Q_\\<alpha> Qi' = Qinter Q \\<pi> u\n  M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "lemma foreach_impl_correct_presentation:\n  fixes Qi Vi \\<pi>i defines \"Q \\<equiv> Q_\\<alpha> Qi\" and \"\\<pi> \\<equiv> M_lookup \\<pi>i\"\n  assumes A: \"foreach_impl Qi \\<pi>i u (G_adj g u) = (Qi',\\<pi>i')\" \n  assumes I: \"prim_invar_impl Qi \\<pi>i\"\n  shows \"Q_invar Qi' \\<and> M_invar \\<pi>i' \n        \\<and> Q_\\<alpha> Qi' = Qinter Q \\<pi> u \\<and> M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_invar Qi' \\<and>\n    M_invar \\<pi>i' \\<and>\n    Q_\\<alpha> Qi' = Qinter Q \\<pi> u \\<and>\n    M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "using foreach_impl_correct assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>foreach_impl ?Qi ?\\<pi>i ?u (G_adj g ?u) = (?Qi', ?\\<pi>i');\n   prim_invar_impl ?Qi ?\\<pi>i\\<rbrakk>\n  \\<Longrightarrow> Q_invar ?Qi'\n  \\<lbrakk>foreach_impl ?Qi ?\\<pi>i ?u (G_adj g ?u) = (?Qi', ?\\<pi>i');\n   prim_invar_impl ?Qi ?\\<pi>i\\<rbrakk>\n  \\<Longrightarrow> M_invar ?\\<pi>i'\n  \\<lbrakk>foreach_impl ?Qi ?\\<pi>i ?u (G_adj g ?u) = (?Qi', ?\\<pi>i');\n   prim_invar_impl ?Qi ?\\<pi>i\\<rbrakk>\n  \\<Longrightarrow> Q_\\<alpha> ?Qi' =\n                    Qinter (Q_\\<alpha> ?Qi) (M_lookup ?\\<pi>i) ?u\n  \\<lbrakk>foreach_impl ?Qi ?\\<pi>i ?u (G_adj g ?u) = (?Qi', ?\\<pi>i');\n   prim_invar_impl ?Qi ?\\<pi>i\\<rbrakk>\n  \\<Longrightarrow> M_lookup ?\\<pi>i' =\n                    \\<pi>' (Q_\\<alpha> ?Qi) (M_lookup ?\\<pi>i) ?u\n  Q \\<equiv> Q_\\<alpha> Qi\n  \\<pi> \\<equiv> M_lookup \\<pi>i\n  foreach_impl Qi \\<pi>i u (G_adj g u) = (Qi', \\<pi>i')\n  prim_invar_impl Qi \\<pi>i\n\ngoal (1 subgoal):\n 1. Q_invar Qi' \\<and>\n    M_invar \\<pi>i' \\<and>\n    Q_\\<alpha> Qi' = Qinter Q \\<pi> u \\<and>\n    M_lookup \\<pi>i' = \\<pi>' Q \\<pi> u", "by blast"], ["", "(*>*)"], ["", "definition \"T_measure_impl \\<equiv> \\<lambda>(Qi,\\<pi>i). T_measure2 (Q_\\<alpha> Qi) (M_lookup \\<pi>i)\""], ["", "lemma prim_invar_impl_init: \"prim_invar_impl (Q_update r 0 Q_empty) M_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar_impl (Q_update r 0 Q_empty) M_empty", "using invar2_init"], ["proof (prove)\nusing this:\n  prim_invar2 initQ init\\<pi>\n\ngoal (1 subgoal):\n 1. prim_invar_impl (Q_update r 0 Q_empty) M_empty", "by (auto simp: prim_invar_impl_def Q_\\<alpha>_specs initQ_def init\\<pi>_def zero_enat_def)"], ["", "lemma maintain_prim_invar_impl:  \n  assumes \n      I: \"prim_invar_impl Qi \\<pi>i\" and\n      NE: \"\\<not> Q_is_empty Qi\" and\n      MIN: \"Q_getmin Qi = (u, d)\" and\n      FOREACH: \"foreach_impl Qi \\<pi>i u (G_adj g u) = (Qi', \\<pi>i')\"\n  shows \"prim_invar_impl (Q_delete u Qi') \\<pi>i'\" (is ?G1)\n     and \"T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi,\\<pi>i)\" (is \"?G2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar_impl (Q_delete u Qi') \\<pi>i' &&&\n    T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi, \\<pi>i)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar_impl (Q_delete u Qi') \\<pi>i'\n 2. T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi, \\<pi>i)", "note II[simp] = I[unfolded prim_invar_impl_def]"], ["proof (state)\nthis:\n  Q_invar Qi \\<and>\n  M_invar \\<pi>i \\<and> prim_invar2 (Q_\\<alpha> Qi) (M_lookup \\<pi>i)\n\ngoal (2 subgoals):\n 1. prim_invar_impl (Q_delete u Qi') \\<pi>i'\n 2. T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi, \\<pi>i)", "note FI[simp] = foreach_impl_correct[OF FOREACH I]"], ["proof (state)\nthis:\n  Q_invar Qi'\n  M_invar \\<pi>i'\n  Q_\\<alpha> Qi' = Qinter (Q_\\<alpha> Qi) (M_lookup \\<pi>i) u\n  M_lookup \\<pi>i' = \\<pi>' (Q_\\<alpha> Qi) (M_lookup \\<pi>i) u\n\ngoal (2 subgoals):\n 1. prim_invar_impl (Q_delete u Qi') \\<pi>i'\n 2. T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi, \\<pi>i)", "note MIN' = Q_\\<alpha>_min[OF MIN _ NE, simplified]"], ["proof (state)\nthis:\n  Q_\\<alpha> Qi u = enat d\n  \\<forall>v. enat d \\<le> Q_\\<alpha> Qi v\n\ngoal (2 subgoals):\n 1. prim_invar_impl (Q_delete u Qi') \\<pi>i'\n 2. T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi, \\<pi>i)", "show ?G1"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar_impl (Q_delete u Qi') \\<pi>i'", "unfolding prim_invar_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_invar (Q_delete u Qi') \\<and>\n    M_invar \\<pi>i' \\<and>\n    prim_invar2 (Q_\\<alpha> (Q_delete u Qi')) (M_lookup \\<pi>i')", "using Q_\\<alpha>_delete maintain_invar2[OF _ MIN']"], ["proof (prove)\nusing this:\n  Q_invar ?Q \\<Longrightarrow>\n  Q_\\<alpha> (Q_delete ?u ?Q) = (Q_\\<alpha> ?Q)(?u := \\<infinity>)\n  prim_invar2 (Q_\\<alpha> Qi) ?\\<pi> \\<Longrightarrow>\n  prim_invar2 (Q' (Q_\\<alpha> Qi) ?\\<pi> u)\n   (\\<pi>' (Q_\\<alpha> Qi) ?\\<pi> u)\n  prim_invar2 (Q_\\<alpha> Qi) ?\\<pi> \\<Longrightarrow>\n  T_measure2 (Q' (Q_\\<alpha> Qi) ?\\<pi> u) (\\<pi>' (Q_\\<alpha> Qi) ?\\<pi> u)\n  < T_measure2 (Q_\\<alpha> Qi) ?\\<pi>\n\ngoal (1 subgoal):\n 1. Q_invar (Q_delete u Qi') \\<and>\n    M_invar \\<pi>i' \\<and>\n    prim_invar2 (Q_\\<alpha> (Q_delete u Qi')) (M_lookup \\<pi>i')", "by (simp add: Q'_def)"], ["proof (state)\nthis:\n  prim_invar_impl (Q_delete u Qi') \\<pi>i'\n\ngoal (1 subgoal):\n 1. T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi, \\<pi>i)", "show ?G2"], ["proof (prove)\ngoal (1 subgoal):\n 1. T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi, \\<pi>i)", "unfolding prim_invar_impl_def T_measure_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (Q_delete u Qi', \\<pi>i') of\n     (Qi, \\<pi>i) \\<Rightarrow>\n       T_measure2 (Q_\\<alpha> Qi) (M_lookup \\<pi>i))\n    < (case (Qi, \\<pi>i) of\n       (Qi, \\<pi>i) \\<Rightarrow>\n         T_measure2 (Q_\\<alpha> Qi) (M_lookup \\<pi>i))", "using Q_\\<alpha>_delete maintain_invar2[OF _ MIN']"], ["proof (prove)\nusing this:\n  Q_invar ?Q \\<Longrightarrow>\n  Q_\\<alpha> (Q_delete ?u ?Q) = (Q_\\<alpha> ?Q)(?u := \\<infinity>)\n  prim_invar2 (Q_\\<alpha> Qi) ?\\<pi> \\<Longrightarrow>\n  prim_invar2 (Q' (Q_\\<alpha> Qi) ?\\<pi> u)\n   (\\<pi>' (Q_\\<alpha> Qi) ?\\<pi> u)\n  prim_invar2 (Q_\\<alpha> Qi) ?\\<pi> \\<Longrightarrow>\n  T_measure2 (Q' (Q_\\<alpha> Qi) ?\\<pi> u) (\\<pi>' (Q_\\<alpha> Qi) ?\\<pi> u)\n  < T_measure2 (Q_\\<alpha> Qi) ?\\<pi>\n\ngoal (1 subgoal):\n 1. (case (Q_delete u Qi', \\<pi>i') of\n     (Qi, \\<pi>i) \\<Rightarrow>\n       T_measure2 (Q_\\<alpha> Qi) (M_lookup \\<pi>i))\n    < (case (Qi, \\<pi>i) of\n       (Qi, \\<pi>i) \\<Rightarrow>\n         T_measure2 (Q_\\<alpha> Qi) (M_lookup \\<pi>i))", "apply (simp add: Q'_def Q_\\<alpha>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Q u.\n                Q_invar Q \\<Longrightarrow>\n                enat_of_option \\<circ> (Q_lookup Q)(u := None) =\n                (enat_of_option \\<circ> Q_lookup Q)(u := \\<infinity>);\n     \\<And>\\<pi>.\n        prim_invar2 (\\<lambda>v. enat_of_option (Q_lookup Qi v))\n         \\<pi> \\<Longrightarrow>\n        prim_invar2\n         ((Qinter (\\<lambda>v. enat_of_option (Q_lookup Qi v)) \\<pi> u)\n          (u := \\<infinity>))\n         (\\<pi>' (\\<lambda>v. enat_of_option (Q_lookup Qi v)) \\<pi> u);\n     \\<And>\\<pi>.\n        prim_invar2 (\\<lambda>v. enat_of_option (Q_lookup Qi v))\n         \\<pi> \\<Longrightarrow>\n        T_measure2\n         ((Qinter (\\<lambda>v. enat_of_option (Q_lookup Qi v)) \\<pi> u)\n          (u := \\<infinity>))\n         (\\<pi>' (\\<lambda>v. enat_of_option (Q_lookup Qi v)) \\<pi> u)\n        < T_measure2 (\\<lambda>v. enat_of_option (Q_lookup Qi v))\n           \\<pi>\\<rbrakk>\n    \\<Longrightarrow> T_measure2\n                       ((enat_of_option \\<circ> Q_lookup Qi')\n                        (u := \\<infinity>))\n                       (\\<pi>' (enat_of_option \\<circ> Q_lookup Qi)\n                         (M_lookup \\<pi>i) u)\n                      < T_measure2 (enat_of_option \\<circ> Q_lookup Qi)\n                         (M_lookup \\<pi>i)", "by (metis FI(3) II Q'_def Q_\\<alpha>_def \n        \\<open>\\<And>\\<pi>. prim_invar2 (Q_\\<alpha> Qi) \\<pi> \n            \\<Longrightarrow> T_measure2 (Q' (Q_\\<alpha> Qi) \\<pi> u) (\\<pi>' (Q_\\<alpha> Qi) \\<pi> u) \n                < T_measure2 (Q_\\<alpha> Qi) \\<pi>\\<close>)"], ["proof (state)\nthis:\n  T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi, \\<pi>i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maintain_prim_invar_impl_presentation:  \n  assumes \n      I: \"prim_invar_impl Qi \\<pi>i\" and\n      NE: \"\\<not> Q_is_empty Qi\" and\n      MIN: \"Q_getmin Qi = (u, d)\" and\n      FOREACH: \"foreach_impl Qi \\<pi>i u (G_adj g u) = (Qi', \\<pi>i')\"\n  shows \"prim_invar_impl (Q_delete u Qi') \\<pi>i'\n       \\<and> T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi,\\<pi>i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar_impl (Q_delete u Qi') \\<pi>i' \\<and>\n    T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi, \\<pi>i)", "using maintain_prim_invar_impl assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>prim_invar_impl ?Qi ?\\<pi>i; \\<not> Q_is_empty ?Qi;\n   Q_getmin ?Qi = (?u, ?d);\n   foreach_impl ?Qi ?\\<pi>i ?u (G_adj g ?u) = (?Qi', ?\\<pi>i')\\<rbrakk>\n  \\<Longrightarrow> prim_invar_impl (Q_delete ?u ?Qi') ?\\<pi>i'\n  \\<lbrakk>prim_invar_impl ?Qi ?\\<pi>i; \\<not> Q_is_empty ?Qi;\n   Q_getmin ?Qi = (?u, ?d);\n   foreach_impl ?Qi ?\\<pi>i ?u (G_adj g ?u) = (?Qi', ?\\<pi>i')\\<rbrakk>\n  \\<Longrightarrow> T_measure_impl (Q_delete ?u ?Qi', ?\\<pi>i')\n                    < T_measure_impl (?Qi, ?\\<pi>i)\n  prim_invar_impl Qi \\<pi>i\n  \\<not> Q_is_empty Qi\n  Q_getmin Qi = (u, d)\n  foreach_impl Qi \\<pi>i u (G_adj g u) = (Qi', \\<pi>i')\n\ngoal (1 subgoal):\n 1. prim_invar_impl (Q_delete u Qi') \\<pi>i' \\<and>\n    T_measure_impl (Q_delete u Qi', \\<pi>i') < T_measure_impl (Qi, \\<pi>i)", "by blast"], ["", "lemma prim_invar_impl_finish:\n  \"\\<lbrakk>Q_is_empty Q; prim_invar_impl Q \\<pi>\\<rbrakk> \n    \\<Longrightarrow> invar_MST \\<pi> \\<and> is_MST (G_\\<alpha>w g) rg (\\<alpha>_MST \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q_is_empty Q; prim_invar_impl Q \\<pi>\\<rbrakk>\n    \\<Longrightarrow> invar_MST \\<pi> \\<and>\n                      is_MST (G_\\<alpha>w g) rg (\\<alpha>_MST \\<pi>)", "using invar2_finish"], ["proof (prove)\nusing this:\n  \\<lbrakk>prim_invar2 ?Q ?\\<pi>; ?Q = (\\<lambda>_. \\<infinity>)\\<rbrakk>\n  \\<Longrightarrow> is_MST (G_\\<alpha>w g) rg\n                     (graph {r} {(u, v). ?\\<pi> u = Some v})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q_is_empty Q; prim_invar_impl Q \\<pi>\\<rbrakk>\n    \\<Longrightarrow> invar_MST \\<pi> \\<and>\n                      is_MST (G_\\<alpha>w g) rg (\\<alpha>_MST \\<pi>)", "by (auto simp: Q_\\<alpha>_specs prim_invar_impl_def invar_MST_def \\<alpha>_MST_def Let_def)"], ["", "lemma prim_impl_correct:\n  assumes \"prim_impl = \\<pi>i\"\n  shows \n    \"invar_MST \\<pi>i\" (is ?G1)\n    \"is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r) (\\<alpha>_MST \\<pi>i)\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_MST \\<pi>i &&&\n    is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r)\n     (\\<alpha>_MST \\<pi>i)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. invar_MST \\<pi>i\n 2. is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r)\n     (\\<alpha>_MST \\<pi>i)", "have \"let (Qi, \\<pi>i) = outer_loop_impl (Q_update r 0 Q_empty) M_empty in \n    invar_MST \\<pi>i \\<and> is_MST (G_\\<alpha>w g) rg (\\<alpha>_MST \\<pi>i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let (Qi, \\<pi>i) = outer_loop_impl (Q_update r 0 Q_empty) M_empty\n    in invar_MST \\<pi>i \\<and>\n       is_MST (G_\\<alpha>w g) rg (\\<alpha>_MST \\<pi>i)", "unfolding outer_loop_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let (Qi, \\<pi>i) =\n          while (\\<lambda>(Qi, \\<pi>i). \\<not> Q_is_empty Qi)\n           (\\<lambda>(Qi, \\<pi>i).\n               let (u, uu_) = Q_getmin Qi; adjs = G_adj g u;\n                   (Qi, \\<pi>i) = foreach_impl Qi \\<pi>i u adjs;\n                   Qi = Q_delete u Qi\n               in (Qi, \\<pi>i))\n           (Q_update r 0 Q_empty, M_empty)\n    in invar_MST \\<pi>i \\<and>\n       is_MST (G_\\<alpha>w g) rg (\\<alpha>_MST \\<pi>i)", "apply (rule while_rule[where \n      P=\"\\<lambda>(Qi,\\<pi>i). prim_invar_impl Qi \\<pi>i\" and r=\"measure T_measure_impl\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. case (Q_update r 0 Q_empty, M_empty) of\n    (x, xa) \\<Rightarrow> prim_invar_impl x xa\n 2. \\<And>s.\n       \\<lbrakk>case s of (x, xa) \\<Rightarrow> prim_invar_impl x xa;\n        case s of (Qi, \\<pi>i) \\<Rightarrow> \\<not> Q_is_empty Qi\\<rbrakk>\n       \\<Longrightarrow> case case s of\n                              (Qi, \\<pi>i) \\<Rightarrow>\n                                let (u, uu_) = Q_getmin Qi;\n                                    adjs = G_adj g u;\n                                    (Qi, \\<pi>i) =\nforeach_impl Qi \\<pi>i u adjs;\n                                    Qi = Q_delete u Qi\n                                in (Qi, \\<pi>i) of\n                         (x, xa) \\<Rightarrow> prim_invar_impl x xa\n 3. \\<And>s.\n       \\<lbrakk>case s of (x, xa) \\<Rightarrow> prim_invar_impl x xa;\n        \\<not> (case s of\n                (Qi, \\<pi>i) \\<Rightarrow> \\<not> Q_is_empty Qi)\\<rbrakk>\n       \\<Longrightarrow> let a = s\n                         in case a of\n                            (Qi, \\<pi>i) \\<Rightarrow>\n                              invar_MST \\<pi>i \\<and>\n                              is_MST (G_\\<alpha>w g) rg\n                               (\\<alpha>_MST \\<pi>i)\n 4. wf (measure T_measure_impl)\n 5. \\<And>s.\n       \\<lbrakk>case s of (x, xa) \\<Rightarrow> prim_invar_impl x xa;\n        case s of (Qi, \\<pi>i) \\<Rightarrow> \\<not> Q_is_empty Qi\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (Qi, \\<pi>i) \\<Rightarrow>\n                            let (u, uu_) = Q_getmin Qi; adjs = G_adj g u;\n                                (Qi, \\<pi>i) =\n                                  foreach_impl Qi \\<pi>i u adjs;\n                                Qi = Q_delete u Qi\n                            in (Qi, \\<pi>i),\n                          s)\n                         \\<in> measure T_measure_impl", "apply (all \\<open>clarsimp split: prod.splits simp: Q_\\<alpha>_specs\\<close>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. prim_invar_impl (Q_update r 0 Q_empty) M_empty\n 2. \\<And>x1 x2 x1a x1b x2a x2b.\n       \\<lbrakk>\\<not> Q_is_empty x1; prim_invar_impl x1 x2;\n        foreach_impl x1 x2 x1a (G_adj g x1a) = (x1b, x2a);\n        Q_getmin x1 = (x1a, x2b)\\<rbrakk>\n       \\<Longrightarrow> prim_invar_impl (Q_delete x1a x1b) x2a\n 3. \\<And>x1 x2.\n       \\<lbrakk>Q_is_empty x1; prim_invar_impl x1 x2\\<rbrakk>\n       \\<Longrightarrow> invar_MST x2 \\<and>\n                         is_MST (G_\\<alpha>w g) rg (\\<alpha>_MST x2)\n 4. \\<And>x1 x2 x1a x1b x2a x2b.\n       \\<lbrakk>\\<not> Q_is_empty x1; prim_invar_impl x1 x2;\n        foreach_impl x1 x2 x1a (G_adj g x1a) = (x1b, x2a);\n        Q_getmin x1 = (x1a, x2b)\\<rbrakk>\n       \\<Longrightarrow> T_measure_impl (Q_delete x1a x1b, x2a)\n                         < T_measure_impl (x1, x2)", "apply (simp_all add: prim_invar_impl_init maintain_prim_invar_impl \n                         prim_invar_impl_finish)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  let (Qi, \\<pi>i) = outer_loop_impl (Q_update r 0 Q_empty) M_empty\n  in invar_MST \\<pi>i \\<and> is_MST (G_\\<alpha>w g) rg (\\<alpha>_MST \\<pi>i)\n\ngoal (2 subgoals):\n 1. invar_MST \\<pi>i\n 2. is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r)\n     (\\<alpha>_MST \\<pi>i)", "with assms"], ["proof (chain)\npicking this:\n  prim_impl = \\<pi>i\n  let (Qi, \\<pi>i) = outer_loop_impl (Q_update r 0 Q_empty) M_empty\n  in invar_MST \\<pi>i \\<and> is_MST (G_\\<alpha>w g) rg (\\<alpha>_MST \\<pi>i)", "show ?G1 ?G2"], ["proof (prove)\nusing this:\n  prim_impl = \\<pi>i\n  let (Qi, \\<pi>i) = outer_loop_impl (Q_update r 0 Q_empty) M_empty\n  in invar_MST \\<pi>i \\<and> is_MST (G_\\<alpha>w g) rg (\\<alpha>_MST \\<pi>i)\n\ngoal (1 subgoal):\n 1. invar_MST \\<pi>i &&&\n    is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r)\n     (\\<alpha>_MST \\<pi>i)", "unfolding rg_def prim_impl_def"], ["proof (prove)\nusing this:\n  (let Qi = Q_update r 0 Q_empty; \\<pi>i = M_empty;\n       (Qi, \\<pi>i) = outer_loop_impl Qi \\<pi>i\n   in \\<pi>i) =\n  \\<pi>i\n  let (Qi, \\<pi>i) = outer_loop_impl (Q_update r 0 Q_empty) M_empty\n  in invar_MST \\<pi>i \\<and>\n     is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r)\n      (\\<alpha>_MST \\<pi>i)\n\ngoal (1 subgoal):\n 1. invar_MST \\<pi>i &&&\n    is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r)\n     (\\<alpha>_MST \\<pi>i)", "by (simp_all split: prod.splits)"], ["proof (state)\nthis:\n  invar_MST \\<pi>i\n  is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r)\n   (\\<alpha>_MST \\<pi>i)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "lemma prim_impl_correct_presentation:\n  \"invar_MST prim_impl \n  \\<and> is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r) (\\<alpha>_MST prim_impl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_MST prim_impl \\<and>\n    is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r)\n     (\\<alpha>_MST prim_impl)", "using prim_impl_correct"], ["proof (prove)\nusing this:\n  prim_impl = ?\\<pi>i \\<Longrightarrow> invar_MST ?\\<pi>i\n  prim_impl = ?\\<pi>i \\<Longrightarrow>\n  is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r)\n   (\\<alpha>_MST ?\\<pi>i)\n\ngoal (1 subgoal):\n 1. invar_MST prim_impl \\<and>\n    is_MST (G_\\<alpha>w g) (component_of (G_\\<alpha>g g) r)\n     (\\<alpha>_MST prim_impl)", "by blast"], ["", "(*>*)"], ["", "end"], ["", "subsection \\<open>Instantiation with Actual Data Structures\\label{sec:prim_inst_ds}\\<close>"], ["", "global_interpretation \n  G: wgraph_by_map RBT_Set.empty RBT_Map.update RBT_Map.delete \n        Lookup2.lookup RBT_Map.M.invar\n  defines G_empty = G.empty\n      and G_add_edge = G.add_edge\n      and G_add_edge1 = G.add_edge1\n      and G_adj = G.adj\n      and G_from_list = G.from_list\n      and G_valid_wgraph_repr = G.valid_wgraph_repr"], ["proof (prove)\ngoal (1 subgoal):\n 1. wgraph_by_map RBT_Set.empty RBT_Map.update RBT_Map.delete lookup M.invar", "by unfold_locales"], ["", "(* FIXME: Something is strange with generated constants. *)"], ["", "lemma G_from_list_unfold:  \"G_from_list = G.from_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G_from_list = G.from_list", "by (simp add: G_add_edge_def G_empty_def G_from_list_def)"], ["", "(* FIXME: The interpretation does not generate a code theorem at all!? *)"], ["", "lemma [code]: \"G_from_list l = foldr (\\<lambda>(e, d). G_add_edge e d) l G_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G_from_list l = foldr (\\<lambda>(e, d). G_add_edge e d) l G_empty", "by (simp add: G.from_list_def G_from_list_unfold)"], ["", "global_interpretation Prim_Impl_Adts _ _ _\n  G.\\<alpha>w G.\\<alpha>g G.invar G.adj G.empty G.add_edge\n  \n  RBT_Set.empty RBT_Map.update RBT_Map.delete Lookup2.lookup RBT_Map.M.invar\n  \n  PST_RBT.empty PST_RBT.update PST_RBT.delete PST_RBT.PM.invar \n  Lookup2.lookup PST_RBT.rbt_is_empty pst_getmin"], ["proof (prove)\ngoal (1 subgoal):\n 1. Prim_Impl_Adts G.\\<alpha>w G.\\<alpha>g G.invar G_adj G_empty G_add_edge\n     RBT_Set.empty RBT_Map.update RBT_Map.delete lookup M.invar\n     PST_RBT.empty PST_RBT.update PST_RBT.delete PM.invar lookup\n     rbt_is_empty pst_getmin", ".."], ["", "global_interpretation P: Prim_Impl_Defs G.invar G.adj G.empty G.add_edge\n  RBT_Set.empty RBT_Map.update RBT_Map.delete Lookup2.lookup RBT_Map.M.invar\n  \n  PST_RBT.empty PST_RBT.update PST_RBT.delete PST_RBT.PM.invar \n  Lookup2.lookup PST_RBT.rbt_is_empty pst_getmin\n  \n  _ _ _ G.\\<alpha>w G.\\<alpha>g g r  \n  for g and r::\"'a::linorder\"\n  defines prim_impl = P.prim_impl\n      and outer_loop_impl = P.outer_loop_impl\n      and foreach_impl = P.foreach_impl\n      and foreach_impl_body = P.foreach_impl_body"], ["proof (prove)\ngoal (1 subgoal):\n 1. Prim_Impl_Defs G.invar G_adj G_empty G_add_edge RBT_Set.empty\n     RBT_Map.update RBT_Map.delete lookup M.invar PST_RBT.empty\n     PST_RBT.update PST_RBT.delete PM.invar lookup rbt_is_empty pst_getmin\n     G.\\<alpha>w G.\\<alpha>g", "by unfold_locales"], ["", "lemmas [code] = P.prim_impl_alt"], ["", "context\n  fixes g\n  assumes [simp]: \"G.invar g\"  \nbegin"], ["", "interpretation AUX: Prim_Impl\n  G.invar G.adj G.empty G.add_edge\n  \n  RBT_Set.empty RBT_Map.update RBT_Map.delete Lookup2.lookup RBT_Map.M.invar\n  \n  PST_RBT.empty PST_RBT.update PST_RBT.delete PST_RBT.PM.invar \n  Lookup2.lookup PST_RBT.rbt_is_empty pst_getmin\n  \n  g r _ _ _ G.\\<alpha>w G.\\<alpha>g for r::\"'a::linorder\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prim_Impl G.invar G_adj G_empty G_add_edge RBT_Set.empty RBT_Map.update\n     RBT_Map.delete lookup M.invar PST_RBT.empty PST_RBT.update\n     PST_RBT.delete PM.invar lookup rbt_is_empty pst_getmin g G.\\<alpha>w\n     G.\\<alpha>g", "by unfold_locales simp_all"], ["", "lemmas prim_impl_correct = AUX.prim_impl_correct[folded prim_impl_def]"], ["", "end"], ["", "subsubsection \\<open>Adding a Graph-From-List Parser\\<close>"], ["", "definition \"prim_list_impl l r \n  \\<equiv> if G_valid_wgraph_repr l then Some (prim_impl (G_from_list l) r) else None\""], ["", "subsection \\<open>Main Correctness Theorem\\<close>"], ["", "text \\<open>\n  The @{const prim_list_impl} algorithm returns @{const None}, if the input was \n  invalid. Otherwise it returns @{term \\<open>Some (\\<pi>i,Vi)\\<close>}, which satisfy the \n  map/set invariants and encode a minimum spanning tree of the component of the\n  graph that contains \\<open>r\\<close>.\n  \n  Notes:\n    \\<^item> If \\<open>r\\<close> is n ot a node of the graph, \\<open>component_of\\<close> will return the graph\n      with the only node \\<open>r\\<close>. (@{thm [source] component_of_not_node})\n\\<close>"], ["", "theorem prim_list_impl_correct:\n  shows \"case prim_list_impl l r of \n    None \\<Rightarrow> \\<not>G.valid_wgraph_repr l \\<comment> \\<open>Invalid input\\<close>\n  | Some \\<pi>i \\<Rightarrow> \n        G.valid_wgraph_repr l \\<and> (let Gi = G.from_list l in G.invar Gi \\<comment> \\<open>Valid input\\<close>\n        \\<and> P.invar_MST \\<pi>i \\<comment> \\<open>Output satisfies invariants\\<close>\n        \\<and> is_MST (G.\\<alpha>w Gi) (component_of (G.\\<alpha>g Gi) r) (P.\\<alpha>_MST r \\<pi>i)) \\<comment> \\<open>and represents MST\\<close>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case prim_list_impl l r of\n    None \\<Rightarrow> \\<not> G_valid_wgraph_repr l\n    | Some \\<pi>i \\<Rightarrow>\n        G_valid_wgraph_repr l \\<and>\n        (let Gi = G.from_list l\n         in G.invar Gi \\<and>\n            P.invar_MST \\<pi>i \\<and>\n            is_MST (G.\\<alpha>w Gi) (component_of (G.\\<alpha>g Gi) r)\n             (P.\\<alpha>_MST r \\<pi>i))", "unfolding prim_list_impl_def G_from_list_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. case if G_valid_wgraph_repr l then Some (prim_impl (G.from_list l) r)\n         else None of\n    None \\<Rightarrow> \\<not> G_valid_wgraph_repr l\n    | Some \\<pi>i \\<Rightarrow>\n        G_valid_wgraph_repr l \\<and>\n        (let Gi = G.from_list l\n         in G.invar Gi \\<and>\n            P.invar_MST \\<pi>i \\<and>\n            is_MST (G.\\<alpha>w Gi) (component_of (G.\\<alpha>g Gi) r)\n             (P.\\<alpha>_MST r \\<pi>i))", "using prim_impl_correct[of \"G.from_list l\" r] G.from_list_correct[of l]"], ["proof (prove)\nusing this:\n  \\<lbrakk>G.invar (G.from_list l);\n   prim_impl (G.from_list l) r = ?\\<pi>i\\<rbrakk>\n  \\<Longrightarrow> P.invar_MST ?\\<pi>i\n  \\<lbrakk>G.invar (G.from_list l);\n   prim_impl (G.from_list l) r = ?\\<pi>i\\<rbrakk>\n  \\<Longrightarrow> is_MST (G.\\<alpha>w (G.from_list l))\n                     (component_of (G.\\<alpha>g (G.from_list l)) r)\n                     (P.\\<alpha>_MST r ?\\<pi>i)\n  G_valid_wgraph_repr l \\<Longrightarrow> G.invar (G.from_list l)\n  G_valid_wgraph_repr l \\<Longrightarrow>\n  nodes (G.\\<alpha>g (G.from_list l)) =\n  fst ` fst ` set l \\<union> snd ` fst ` set l\n  G_valid_wgraph_repr l \\<Longrightarrow>\n  edges (G.\\<alpha>g (G.from_list l)) =\n  fst ` set l \\<union> (fst ` set l)\\<inverse>\n  \\<lbrakk>G_valid_wgraph_repr l; ((?u, ?v), ?d) \\<in> set l\\<rbrakk>\n  \\<Longrightarrow> G.\\<alpha>w (G.from_list l) {?u, ?v} = ?d\n\ngoal (1 subgoal):\n 1. case if G_valid_wgraph_repr l then Some (prim_impl (G.from_list l) r)\n         else None of\n    None \\<Rightarrow> \\<not> G_valid_wgraph_repr l\n    | Some \\<pi>i \\<Rightarrow>\n        G_valid_wgraph_repr l \\<and>\n        (let Gi = G.from_list l\n         in G.invar Gi \\<and>\n            P.invar_MST \\<pi>i \\<and>\n            is_MST (G.\\<alpha>w Gi) (component_of (G.\\<alpha>g Gi) r)\n             (P.\\<alpha>_MST r \\<pi>i))", "by (auto simp: Let_def)"], ["", "theorem prim_list_impl_correct_presentation:\n  shows \"case prim_list_impl l r of \n    None \\<Rightarrow> \\<not>G.valid_wgraph_repr l \\<comment> \\<open>Invalid input\\<close>\n  | Some \\<pi>i \\<Rightarrow> let \n      g=G.\\<alpha>g (G.from_list l); \n      w=G.\\<alpha>w (G.from_list l); \n      rg=component_of g r;\n      t=P.\\<alpha>_MST r \\<pi>i\n    in \n        G.valid_wgraph_repr l \\<comment> \\<open>Valid input\\<close> \n      \\<and> P.invar_MST \\<pi>i \\<comment> \\<open>Output satisfies invariants\\<close>\n      \\<and> is_MST w rg t \\<comment> \\<open>and represents MST\\<close>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case prim_list_impl l r of\n    None \\<Rightarrow> \\<not> G_valid_wgraph_repr l\n    | Some \\<pi>i \\<Rightarrow>\n        let g = G.\\<alpha>g (G.from_list l);\n            w = G.\\<alpha>w (G.from_list l); rg = component_of g r;\n            t = P.\\<alpha>_MST r \\<pi>i\n        in G_valid_wgraph_repr l \\<and>\n           P.invar_MST \\<pi>i \\<and> is_MST w rg t", "using prim_list_impl_correct[of l r]"], ["proof (prove)\nusing this:\n  case prim_list_impl l r of None \\<Rightarrow> \\<not> G_valid_wgraph_repr l\n  | Some \\<pi>i \\<Rightarrow>\n      G_valid_wgraph_repr l \\<and>\n      (let Gi = G.from_list l\n       in G.invar Gi \\<and>\n          P.invar_MST \\<pi>i \\<and>\n          is_MST (G.\\<alpha>w Gi) (component_of (G.\\<alpha>g Gi) r)\n           (P.\\<alpha>_MST r \\<pi>i))\n\ngoal (1 subgoal):\n 1. case prim_list_impl l r of\n    None \\<Rightarrow> \\<not> G_valid_wgraph_repr l\n    | Some \\<pi>i \\<Rightarrow>\n        let g = G.\\<alpha>g (G.from_list l);\n            w = G.\\<alpha>w (G.from_list l); rg = component_of g r;\n            t = P.\\<alpha>_MST r \\<pi>i\n        in G_valid_wgraph_repr l \\<and>\n           P.invar_MST \\<pi>i \\<and> is_MST w rg t", "unfolding Let_def"], ["proof (prove)\nusing this:\n  case prim_list_impl l r of None \\<Rightarrow> \\<not> G_valid_wgraph_repr l\n  | Some \\<pi>i \\<Rightarrow>\n      G_valid_wgraph_repr l \\<and>\n      G.invar (G.from_list l) \\<and>\n      P.invar_MST \\<pi>i \\<and>\n      is_MST (G.\\<alpha>w (G.from_list l))\n       (component_of (G.\\<alpha>g (G.from_list l)) r)\n       (P.\\<alpha>_MST r \\<pi>i)\n\ngoal (1 subgoal):\n 1. case prim_list_impl l r of\n    None \\<Rightarrow> \\<not> G_valid_wgraph_repr l\n    | Some \\<pi>i \\<Rightarrow>\n        G_valid_wgraph_repr l \\<and>\n        P.invar_MST \\<pi>i \\<and>\n        is_MST (G.\\<alpha>w (G.from_list l))\n         (component_of (G.\\<alpha>g (G.from_list l)) r)\n         (P.\\<alpha>_MST r \\<pi>i)", "by (auto split: option.splits)"], ["", "subsection \\<open>Code Generation and Test\\label{sec:prim_exec}\\<close>"], ["", "definition prim_list_impl_int :: \"_ \\<Rightarrow> int \\<Rightarrow> _\" \n  where \"prim_list_impl_int \\<equiv> prim_list_impl\""], ["", "export_code prim_list_impl prim_list_impl_int checking SML"], ["", "experiment begin"], ["", "abbreviation \"a \\<equiv> 1\""], ["", "abbreviation \"b \\<equiv> 2\""], ["", "abbreviation \"c \\<equiv> 3\""], ["", "abbreviation \"d \\<equiv> 4\""], ["", "abbreviation \"e \\<equiv> 5\""], ["", "abbreviation \"f \\<equiv> 6\""], ["", "abbreviation \"g \\<equiv> 7\""], ["", "abbreviation \"h \\<equiv> 8\""], ["", "abbreviation \"i \\<equiv> 9\""], ["", "value \"(prim_list_impl_int [\n  ((a,b),4),\n  ((a,h),8),\n  ((b,h),11),\n  ((b,c),8),\n  ((h,i),7),\n  ((h,g),1),\n  ((c,i),2),\n  ((g,i),6),\n  ((c,d),7),\n  ((c,f),4),\n  ((g,f),2),\n  ((d,f),14),\n  ((d,e),9),\n  ((e,f),10)\n] 1)\""], ["", "end"], ["", "end"]]}