{"file_name": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple/Undirected_Graph_Specs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple", "problem_names": ["lemmas wgraph_specs = adj_correct empty_correct add_edge_correct", "lemma empty_spec_presentation: \n  \"invar empty \\<and> \\<alpha>g empty = graph {} {} \\<and> \\<alpha>w empty = (\\<lambda>_. 0)\"", "lemma add_edge_spec_presentation:\n  \"\\<lbrakk>invar g; (u,v)\\<notin>edges (\\<alpha>g g); u\\<noteq>v\\<rbrakk> \\<Longrightarrow>\n    invar (add_edge (u,v) d g)\n  \\<and> \\<alpha>g (add_edge (u,v) d g) = ins_edge (u,v) (\\<alpha>g g)\n  \\<and> \\<alpha>w (add_edge (u,v) d g) = (\\<alpha>w g)({u,v}:=d)\"", "lemma graph_from_list_foldl: \"graph_from_list l = fold ins_edge l graph_empty\"", "lemma nodes_of_graph_from_list: \"nodes (graph_from_list l) = fst`set l \\<union> snd`set l\"", "lemma edges_of_graph_from_list: \n  assumes valid: \"valid_graph_repr l\"\n  shows \"edges (graph_from_list l) = set l \\<union> (set l)\\<inverse>\"", "lemma graph_from_list_simps:\n  \"graph_from_list [] = graph_empty\"\n  \"graph_from_list ((u,v)#l) = ins_edge (u,v) (graph_from_list l)\"", "lemma weight_from_list_simps:\n  \"weight_from_list [] = (\\<lambda>_. 0)\"  \n  \"weight_from_list (((u,v),d)#xs) = (weight_from_list xs)({u,v}:=d)\"", "lemma valid_graph_repr_simps:\n  \"valid_graph_repr []\"\n  \"valid_graph_repr ((u,v)#xs) \\<longleftrightarrow> u\\<noteq>v \\<and> valid_graph_repr xs\"", "lemma valid_weight_repr_simps:\n  \"valid_weight_repr []\"  \n  \"valid_weight_repr (((u,v),w)#xs) \n    \\<longleftrightarrow> uedge (u,v)\\<notin>uedge`fst`set xs \\<and> valid_weight_repr xs\"", "lemma weight_from_list_correct: \n  assumes \"valid_weight_repr l\"\n  assumes \"((u,v),d)\\<in>set l\"\n  shows \"weight_from_list l {u,v} = d\"", "lemma from_list_refine: \"valid_wgraph_repr l \\<Longrightarrow> \n    invar (from_list l) \n  \\<and> \\<alpha>g (from_list l) = graph_from_list (map fst l)\n  \\<and> \\<alpha>w (from_list l) = weight_from_list l\"", "lemma from_list_correct: \n  assumes \"valid_wgraph_repr l\"  \n  shows \n    \"invar (from_list l)\"\n    \"nodes (\\<alpha>g (from_list l)) = fst`fst`set l \\<union> snd`fst`set l\"\n    \"edges (\\<alpha>g (from_list l)) = (fst`set l) \\<union> (fst`set l)\\<inverse>\"\n    \"((u,v),d)\\<in>set l \\<Longrightarrow> \\<alpha>w (from_list l) {u,v} = d\"", "lemma valid_wgraph_repr_presentation: \"valid_wgraph_repr l \\<longleftrightarrow> \n  (\\<forall>((u,v),d)\\<in>set l. u\\<noteq>v) \\<and> distinct [ {u,v}. ((u,v),d)\\<leftarrow>l ]\"", "lemma from_list_correct_presentation:\n  assumes \"valid_wgraph_repr l\"  \n  shows \"let gi=from_list l; g=\\<alpha>g gi; w=\\<alpha>w gi in\n      invar gi \n    \\<and> nodes g = \\<Union>{{u,v} | u v. \\<exists>d. ((u,v),d)\\<in>set l}\n    \\<and> edges g = \\<Union>{{(u,v),(v,u)} | u v. \\<exists>d. ((u,v),d)\\<in>set l}\n    \\<and> (\\<forall>((u,v),d)\\<in>set l. w {u,v}=d)\n  \""], "translations": [["", "lemmas wgraph_specs = adj_correct empty_correct add_edge_correct"], ["", "lemma empty_spec_presentation: \n  \"invar empty \\<and> \\<alpha>g empty = graph {} {} \\<and> \\<alpha>w empty = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar empty \\<and>\n    \\<alpha>g empty = graph {} {} \\<and> \\<alpha>w empty = (\\<lambda>_. 0)", "by (auto simp: wgraph_specs)"], ["", "lemma add_edge_spec_presentation:\n  \"\\<lbrakk>invar g; (u,v)\\<notin>edges (\\<alpha>g g); u\\<noteq>v\\<rbrakk> \\<Longrightarrow>\n    invar (add_edge (u,v) d g)\n  \\<and> \\<alpha>g (add_edge (u,v) d g) = ins_edge (u,v) (\\<alpha>g g)\n  \\<and> \\<alpha>w (add_edge (u,v) d g) = (\\<alpha>w g)({u,v}:=d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> invar (add_edge (u, v) d g) \\<and>\n                      \\<alpha>g (add_edge (u, v) d g) =\n                      ins_edge (u, v) (\\<alpha>g g) \\<and>\n                      \\<alpha>w (add_edge (u, v) d g) = (\\<alpha>w g)\n                      ({u, v} := d)", "by (auto simp: wgraph_specs)"], ["", "end"], ["", "subsection \\<open>Generic From-List Algorithm\\<close>"], ["", "definition valid_graph_repr :: \"('v\\<times>'v) list \\<Rightarrow> bool\" \n  where \"valid_graph_repr l \\<longleftrightarrow> (\\<forall>(u,v)\\<in>set l. u\\<noteq>v)\""], ["", "definition graph_from_list :: \"('v\\<times>'v) list \\<Rightarrow> 'v ugraph\"\n  where \"graph_from_list l = foldr ins_edge l graph_empty\""], ["", "lemma graph_from_list_foldl: \"graph_from_list l = fold ins_edge l graph_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_from_list l = fold ins_edge l graph_empty", "unfolding graph_from_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr ins_edge l graph_empty = fold ins_edge l graph_empty", "apply (rule foldr_fold[THEN fun_cong])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set l; y \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> ins_edge y \\<circ> ins_edge x =\n                         ins_edge x \\<circ> ins_edge y", "by (auto simp: fun_eq_iff graph_eq_iff edges_ins_edge)"], ["", "lemma nodes_of_graph_from_list: \"nodes (graph_from_list l) = fst`set l \\<union> snd`set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (graph_from_list l) = fst ` set l \\<union> snd ` set l", "apply (induction l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nodes (graph_from_list []) = fst ` set [] \\<union> snd ` set []\n 2. \\<And>a l.\n       nodes (graph_from_list l) =\n       fst ` set l \\<union> snd ` set l \\<Longrightarrow>\n       nodes (graph_from_list (a # l)) =\n       fst ` set (a # l) \\<union> snd ` set (a # l)", "unfolding graph_from_list_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. nodes (foldr ins_edge [] graph_empty) =\n    fst ` set [] \\<union> snd ` set []\n 2. \\<And>a l.\n       nodes (foldr ins_edge l graph_empty) =\n       fst ` set l \\<union> snd ` set l \\<Longrightarrow>\n       nodes (foldr ins_edge (a # l) graph_empty) =\n       fst ` set (a # l) \\<union> snd ` set (a # l)", "by auto"], ["", "lemma edges_of_graph_from_list: \n  assumes valid: \"valid_graph_repr l\"\n  shows \"edges (graph_from_list l) = set l \\<union> (set l)\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (graph_from_list l) = set l \\<union> (set l)\\<inverse>", "using valid"], ["proof (prove)\nusing this:\n  valid_graph_repr l\n\ngoal (1 subgoal):\n 1. edges (graph_from_list l) = set l \\<union> (set l)\\<inverse>", "apply (induction l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_graph_repr [] \\<Longrightarrow>\n    edges (graph_from_list []) = set [] \\<union> (set [])\\<inverse>\n 2. \\<And>a l.\n       \\<lbrakk>valid_graph_repr l \\<Longrightarrow>\n                edges (graph_from_list l) =\n                set l \\<union> (set l)\\<inverse>;\n        valid_graph_repr (a # l)\\<rbrakk>\n       \\<Longrightarrow> edges (graph_from_list (a # l)) =\n                         set (a # l) \\<union> (set (a # l))\\<inverse>", "unfolding graph_from_list_def valid_graph_repr_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>(u, v)\\<in>set []. u \\<noteq> v \\<Longrightarrow>\n    edges (foldr ins_edge [] graph_empty) =\n    set [] \\<union> (set [])\\<inverse>\n 2. \\<And>a l.\n       \\<lbrakk>\\<forall>(u, v)\\<in>set l. u \\<noteq> v \\<Longrightarrow>\n                edges (foldr ins_edge l graph_empty) =\n                set l \\<union> (set l)\\<inverse>;\n        \\<forall>(u, v)\\<in>set (a # l). u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> edges (foldr ins_edge (a # l) graph_empty) =\n                         set (a # l) \\<union> (set (a # l))\\<inverse>", "by auto"], ["", "definition \"valid_weight_repr l \\<equiv> distinct (map (uedge o fst) l)\""], ["", "definition weight_from_list :: \"(('v\\<times>'v)\\<times>nat) list \\<Rightarrow> 'v set \\<Rightarrow> nat\" where\n  \"weight_from_list l \\<equiv> foldr (\\<lambda>((u,v),d) w. w({u,v}:=d)) l (\\<lambda>_. 0)\""], ["", "lemma graph_from_list_simps:\n  \"graph_from_list [] = graph_empty\"\n  \"graph_from_list ((u,v)#l) = ins_edge (u,v) (graph_from_list l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_from_list [] = graph_empty &&&\n    graph_from_list ((u, v) # l) = ins_edge (u, v) (graph_from_list l)", "by (auto simp: graph_from_list_def)"], ["", "lemma weight_from_list_simps:\n  \"weight_from_list [] = (\\<lambda>_. 0)\"  \n  \"weight_from_list (((u,v),d)#xs) = (weight_from_list xs)({u,v}:=d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_from_list [] = (\\<lambda>_. 0) &&&\n    weight_from_list (((u, v), d) # xs) = (weight_from_list xs)({u, v} := d)", "by (auto simp: weight_from_list_def)"], ["", "lemma valid_graph_repr_simps:\n  \"valid_graph_repr []\"\n  \"valid_graph_repr ((u,v)#xs) \\<longleftrightarrow> u\\<noteq>v \\<and> valid_graph_repr xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph_repr [] &&&\n    valid_graph_repr ((u, v) # xs) =\n    (u \\<noteq> v \\<and> valid_graph_repr xs)", "unfolding valid_graph_repr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(u, v)\\<in>set []. u \\<noteq> v &&&\n    (\\<forall>(u, v)\\<in>set ((u, v) # xs). u \\<noteq> v) =\n    (u \\<noteq> v \\<and> (\\<forall>(u, v)\\<in>set xs. u \\<noteq> v))", "by auto"], ["", "lemma valid_weight_repr_simps:\n  \"valid_weight_repr []\"  \n  \"valid_weight_repr (((u,v),w)#xs) \n    \\<longleftrightarrow> uedge (u,v)\\<notin>uedge`fst`set xs \\<and> valid_weight_repr xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_weight_repr [] &&&\n    valid_weight_repr (((u, v), w) # xs) =\n    (uedge (u, v) \\<notin> uedge ` fst ` set xs \\<and> valid_weight_repr xs)", "unfolding valid_weight_repr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (uedge \\<circ> fst) []) &&&\n    distinct (map (uedge \\<circ> fst) (((u, v), w) # xs)) =\n    (uedge (u, v) \\<notin> uedge ` fst ` set xs \\<and>\n     distinct (map (uedge \\<circ> fst) xs))", "by (force simp: uedge_def doubleton_eq_iff)+"], ["", "lemma weight_from_list_correct: \n  assumes \"valid_weight_repr l\"\n  assumes \"((u,v),d)\\<in>set l\"\n  shows \"weight_from_list l {u,v} = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_from_list l {u, v} = d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. weight_from_list l {u, v} = d", "from assms"], ["proof (chain)\npicking this:\n  valid_weight_repr l\n  ((u, v), d) \\<in> set l", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_weight_repr l\n  ((u, v), d) \\<in> set l\n\ngoal (1 subgoal):\n 1. weight_from_list l {u, v} = d", "apply (induction l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_weight_repr []; ((u, v), d) \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> weight_from_list [] {u, v} = d\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_weight_repr l;\n                 ((u, v), d) \\<in> set l\\<rbrakk>\n                \\<Longrightarrow> weight_from_list l {u, v} = d;\n        valid_weight_repr (a # l); ((u, v), d) \\<in> set (a # l)\\<rbrakk>\n       \\<Longrightarrow> weight_from_list (a # l) {u, v} = d", "unfolding valid_weight_repr_def weight_from_list_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map (uedge \\<circ> fst) []);\n     ((u, v), d) \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>((u, v), d) w. w({u, v} := d)) []\n                       (\\<lambda>_. 0) {u, v} =\n                      d\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>distinct (map (uedge \\<circ> fst) l);\n                 ((u, v), d) \\<in> set l\\<rbrakk>\n                \\<Longrightarrow> foldr\n                                   (\\<lambda>((u, v), d) w. w({u, v} := d))\n                                   l (\\<lambda>_. 0) {u, v} =\n                                  d;\n        distinct (map (uedge \\<circ> fst) (a # l));\n        ((u, v), d) \\<in> set (a # l)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>((u, v), d) w. w({u, v} := d))\n                          (a # l) (\\<lambda>_. 0) {u, v} =\n                         d", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map (uedge \\<circ> fst) []);\n     ((u, v), d) \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> foldr (\\<lambda>((u, v), d) w. w({u, v} := d)) []\n                       (\\<lambda>_. 0) {u, v} =\n                      d", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>distinct (map (uedge \\<circ> fst) l);\n                 ((u, v), d) \\<in> set l\\<rbrakk>\n                \\<Longrightarrow> foldr\n                                   (\\<lambda>((u, v), d) w. w({u, v} := d))\n                                   l (\\<lambda>_. 0) {u, v} =\n                                  d;\n        distinct (map (uedge \\<circ> fst) (a # l));\n        ((u, v), d) \\<in> set (a # l)\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>((u, v), d) w. w({u, v} := d))\n                          (a # l) (\\<lambda>_. 0) {u, v} =\n                         d", "by (force simp: doubleton_eq_iff)"], ["proof (state)\nthis:\n  weight_from_list l {u, v} = d\n\ngoal:\nNo subgoals!", "qed"], ["", "context adt_wgraph \nbegin"], ["", "definition \"valid_wgraph_repr l \n  \\<longleftrightarrow> valid_graph_repr (map fst l) \\<and> valid_weight_repr l\""], ["", "definition \"from_list l = foldr (\\<lambda>(e,d). add_edge e d) l empty\""], ["", "lemma from_list_refine: \"valid_wgraph_repr l \\<Longrightarrow> \n    invar (from_list l) \n  \\<and> \\<alpha>g (from_list l) = graph_from_list (map fst l)\n  \\<and> \\<alpha>w (from_list l) = weight_from_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_wgraph_repr l \\<Longrightarrow>\n    invar (from_list l) \\<and>\n    \\<alpha>g (from_list l) = graph_from_list (map fst l) \\<and>\n    \\<alpha>w (from_list l) = weight_from_list l", "unfolding from_list_def valid_wgraph_repr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph_repr (map fst l) \\<and>\n    valid_weight_repr l \\<Longrightarrow>\n    invar (foldr (\\<lambda>(x, y). add_edge x y) l empty) \\<and>\n    \\<alpha>g (foldr (\\<lambda>(x, y). add_edge x y) l empty) =\n    graph_from_list (map fst l) \\<and>\n    \\<alpha>w (foldr (\\<lambda>(x, y). add_edge x y) l empty) =\n    weight_from_list l", "supply [simp] = wgraph_specs graph_from_list_simps weight_from_list_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph_repr (map fst l) \\<and>\n    valid_weight_repr l \\<Longrightarrow>\n    invar (foldr (\\<lambda>(x, y). add_edge x y) l empty) \\<and>\n    \\<alpha>g (foldr (\\<lambda>(x, y). add_edge x y) l empty) =\n    graph_from_list (map fst l) \\<and>\n    \\<alpha>w (foldr (\\<lambda>(x, y). add_edge x y) l empty) =\n    weight_from_list l", "apply (induction l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_graph_repr (map fst []) \\<and>\n    valid_weight_repr [] \\<Longrightarrow>\n    invar (foldr (\\<lambda>(x, y). add_edge x y) [] empty) \\<and>\n    \\<alpha>g (foldr (\\<lambda>(x, y). add_edge x y) [] empty) =\n    graph_from_list (map fst []) \\<and>\n    \\<alpha>w (foldr (\\<lambda>(x, y). add_edge x y) [] empty) =\n    weight_from_list []\n 2. \\<And>a l.\n       \\<lbrakk>valid_graph_repr (map fst l) \\<and>\n                valid_weight_repr l \\<Longrightarrow>\n                invar (foldr (\\<lambda>(x, y). add_edge x y) l empty) \\<and>\n                \\<alpha>g (foldr (\\<lambda>(x, y). add_edge x y) l empty) =\n                graph_from_list (map fst l) \\<and>\n                \\<alpha>w (foldr (\\<lambda>(x, y). add_edge x y) l empty) =\n                weight_from_list l;\n        valid_graph_repr (map fst (a # l)) \\<and>\n        valid_weight_repr (a # l)\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (foldr (\\<lambda>(x, y). add_edge x y) (a # l)\n                            empty) \\<and>\n                         \\<alpha>g\n                          (foldr (\\<lambda>(x, y). add_edge x y) (a # l)\n                            empty) =\n                         graph_from_list (map fst (a # l)) \\<and>\n                         \\<alpha>w\n                          (foldr (\\<lambda>(x, y). add_edge x y) (a # l)\n                            empty) =\n                         weight_from_list (a # l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph_repr (map fst []) \\<and>\n    valid_weight_repr [] \\<Longrightarrow>\n    invar (foldr (\\<lambda>(x, y). add_edge x y) [] empty) \\<and>\n    \\<alpha>g (foldr (\\<lambda>(x, y). add_edge x y) [] empty) =\n    graph_from_list (map fst []) \\<and>\n    \\<alpha>w (foldr (\\<lambda>(x, y). add_edge x y) [] empty) =\n    weight_from_list []", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>valid_graph_repr (map fst l) \\<and>\n                valid_weight_repr l \\<Longrightarrow>\n                invar (foldr (\\<lambda>(x, y). add_edge x y) l empty) \\<and>\n                \\<alpha>g (foldr (\\<lambda>(x, y). add_edge x y) l empty) =\n                graph_from_list (map fst l) \\<and>\n                \\<alpha>w (foldr (\\<lambda>(x, y). add_edge x y) l empty) =\n                weight_from_list l;\n        valid_graph_repr (map fst (a # l)) \\<and>\n        valid_weight_repr (a # l)\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (foldr (\\<lambda>(x, y). add_edge x y) (a # l)\n                            empty) \\<and>\n                         \\<alpha>g\n                          (foldr (\\<lambda>(x, y). add_edge x y) (a # l)\n                            empty) =\n                         graph_from_list (map fst (a # l)) \\<and>\n                         \\<alpha>w\n                          (foldr (\\<lambda>(x, y). add_edge x y) (a # l)\n                            empty) =\n                         weight_from_list (a # l)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_graph_repr (map fst l_) \\<and>\n             valid_weight_repr l_ \\<Longrightarrow>\n             invar (foldr (\\<lambda>(x, y). add_edge x y) l_ empty) \\<and>\n             \\<alpha>g (foldr (\\<lambda>(x, y). add_edge x y) l_ empty) =\n             graph_from_list (map fst l_) \\<and>\n             \\<alpha>w (foldr (\\<lambda>(x, y). add_edge x y) l_ empty) =\n             weight_from_list l_;\n     valid_graph_repr (map fst (a_ # l_)) \\<and>\n     valid_weight_repr (a_ # l_)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (foldr (\\<lambda>(x, y). add_edge x y) (a_ # l_)\n                         empty) \\<and>\n                      \\<alpha>g\n                       (foldr (\\<lambda>(x, y). add_edge x y) (a_ # l_)\n                         empty) =\n                      graph_from_list (map fst (a_ # l_)) \\<and>\n                      \\<alpha>w\n                       (foldr (\\<lambda>(x, y). add_edge x y) (a_ # l_)\n                         empty) =\n                      weight_from_list (a_ # l_)", "by (\n      intro conjI; \n      clarsimp \n        simp: uedge_def valid_graph_repr_simps valid_weight_repr_simps\n        split: prod.splits;\n      subst wgraph_specs; \n      auto simp: edges_of_graph_from_list\n    )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma from_list_correct: \n  assumes \"valid_wgraph_repr l\"  \n  shows \n    \"invar (from_list l)\"\n    \"nodes (\\<alpha>g (from_list l)) = fst`fst`set l \\<union> snd`fst`set l\"\n    \"edges (\\<alpha>g (from_list l)) = (fst`set l) \\<union> (fst`set l)\\<inverse>\"\n    \"((u,v),d)\\<in>set l \\<Longrightarrow> \\<alpha>w (from_list l) {u,v} = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invar (from_list l) &&&\n     nodes (\\<alpha>g (from_list l)) =\n     fst ` fst ` set l \\<union> snd ` fst ` set l) &&&\n    edges (\\<alpha>g (from_list l)) =\n    fst ` set l \\<union> (fst ` set l)\\<inverse> &&&\n    (((u, v), d) \\<in> set l \\<Longrightarrow>\n     \\<alpha>w (from_list l) {u, v} = d)", "apply (simp_all add: from_list_refine[OF assms])"], ["proof (prove)\ngoal (3 subgoals):\n 1. nodes (graph_from_list (map fst l)) =\n    fst ` fst ` set l \\<union> snd ` fst ` set l\n 2. edges (graph_from_list (map fst l)) =\n    fst ` set l \\<union> (fst ` set l)\\<inverse>\n 3. ((u, v), d) \\<in> set l \\<Longrightarrow> weight_from_list l {u, v} = d", "using assms"], ["proof (prove)\nusing this:\n  valid_wgraph_repr l\n\ngoal (3 subgoals):\n 1. nodes (graph_from_list (map fst l)) =\n    fst ` fst ` set l \\<union> snd ` fst ` set l\n 2. edges (graph_from_list (map fst l)) =\n    fst ` set l \\<union> (fst ` set l)\\<inverse>\n 3. ((u, v), d) \\<in> set l \\<Longrightarrow> weight_from_list l {u, v} = d", "unfolding valid_wgraph_repr_def"], ["proof (prove)\nusing this:\n  valid_graph_repr (map fst l) \\<and> valid_weight_repr l\n\ngoal (3 subgoals):\n 1. nodes (graph_from_list (map fst l)) =\n    fst ` fst ` set l \\<union> snd ` fst ` set l\n 2. edges (graph_from_list (map fst l)) =\n    fst ` set l \\<union> (fst ` set l)\\<inverse>\n 3. ((u, v), d) \\<in> set l \\<Longrightarrow> weight_from_list l {u, v} = d", "apply (simp_all add: \n      edges_of_graph_from_list nodes_of_graph_from_list weight_from_list_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_wgraph_repr_presentation: \"valid_wgraph_repr l \\<longleftrightarrow> \n  (\\<forall>((u,v),d)\\<in>set l. u\\<noteq>v) \\<and> distinct [ {u,v}. ((u,v),d)\\<leftarrow>l ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_wgraph_repr l =\n    ((\\<forall>((u, v), d)\\<in>set l. u \\<noteq> v) \\<and>\n     distinct (map (\\<lambda>((u, v), d). {u, v}) l))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_wgraph_repr l =\n    ((\\<forall>((u, v), d)\\<in>set l. u \\<noteq> v) \\<and>\n     distinct (map (\\<lambda>((u, v), d). {u, v}) l))", "have [simp]: \"uedge \\<circ> fst = (\\<lambda>((u, v), w). {u, v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uedge \\<circ> fst = (\\<lambda>((u, v), w). {u, v})", "unfolding uedge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). {a, b}) \\<circ> fst = (\\<lambda>((u, v), w). {u, v})", "by auto"], ["proof (state)\nthis:\n  uedge \\<circ> fst = (\\<lambda>((u, v), w). {u, v})\n\ngoal (1 subgoal):\n 1. valid_wgraph_repr l =\n    ((\\<forall>((u, v), d)\\<in>set l. u \\<noteq> v) \\<and>\n     distinct (map (\\<lambda>((u, v), d). {u, v}) l))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_wgraph_repr l =\n    ((\\<forall>((u, v), d)\\<in>set l. u \\<noteq> v) \\<and>\n     distinct (map (\\<lambda>((u, v), d). {u, v}) l))", "unfolding valid_wgraph_repr_def valid_graph_repr_def valid_weight_repr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>(u, v)\\<in>set (map fst l). u \\<noteq> v) \\<and>\n     distinct (map (uedge \\<circ> fst) l)) =\n    ((\\<forall>((u, v), d)\\<in>set l. u \\<noteq> v) \\<and>\n     distinct (map (\\<lambda>((u, v), d). {u, v}) l))", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  valid_wgraph_repr l =\n  ((\\<forall>((u, v), d)\\<in>set l. u \\<noteq> v) \\<and>\n   distinct (map (\\<lambda>((u, v), d). {u, v}) l))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma from_list_correct_presentation:\n  assumes \"valid_wgraph_repr l\"  \n  shows \"let gi=from_list l; g=\\<alpha>g gi; w=\\<alpha>w gi in\n      invar gi \n    \\<and> nodes g = \\<Union>{{u,v} | u v. \\<exists>d. ((u,v),d)\\<in>set l}\n    \\<and> edges g = \\<Union>{{(u,v),(v,u)} | u v. \\<exists>d. ((u,v),d)\\<in>set l}\n    \\<and> (\\<forall>((u,v),d)\\<in>set l. w {u,v}=d)\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. let gi = from_list l; g = \\<alpha>g gi; w = \\<alpha>w gi\n    in invar gi \\<and>\n       nodes g =\n       \\<Union> {{u, v} |u v. \\<exists>d. ((u, v), d) \\<in> set l} \\<and>\n       edges g =\n       \\<Union>\n        {{(u, v), (v, u)} |u v. \\<exists>d. ((u, v), d) \\<in> set l} \\<and>\n       (\\<forall>((u, v), d)\\<in>set l. w {u, v} = d)", "unfolding Let_def from_list_correct(2-3)[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (from_list l) \\<and>\n    fst ` fst ` set l \\<union> snd ` fst ` set l =\n    \\<Union> {{u, v} |u v. \\<exists>d. ((u, v), d) \\<in> set l} \\<and>\n    fst ` set l \\<union> (fst ` set l)\\<inverse> =\n    \\<Union>\n     {{(u, v), (v, u)} |u v. \\<exists>d. ((u, v), d) \\<in> set l} \\<and>\n    Ball (set l)\n     (case_prod (\\<lambda>(u, v). (=) (\\<alpha>w (from_list l) {u, v})))", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. invar (from_list l)\n 2. fst ` fst ` set l \\<union> snd ` fst ` set l =\n    \\<Union> {{u, v} |u v. \\<exists>d. ((u, v), d) \\<in> set l}\n 3. fst ` set l \\<union> (fst ` set l)\\<inverse> =\n    \\<Union> {{(u, v), (v, u)} |u v. \\<exists>d. ((u, v), d) \\<in> set l}\n 4. Ball (set l)\n     (case_prod (\\<lambda>(u, v). (=) (\\<alpha>w (from_list l) {u, v})))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (from_list l)", "by (simp add: from_list_correct(1)[OF assms])"], ["proof (prove)\ngoal (3 subgoals):\n 1. fst ` fst ` set l \\<union> snd ` fst ` set l =\n    \\<Union> {{u, v} |u v. \\<exists>d. ((u, v), d) \\<in> set l}\n 2. fst ` set l \\<union> (fst ` set l)\\<inverse> =\n    \\<Union> {{(u, v), (v, u)} |u v. \\<exists>d. ((u, v), d) \\<in> set l}\n 3. Ball (set l)\n     (case_prod (\\<lambda>(u, v). (=) (\\<alpha>w (from_list l) {u, v})))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` fst ` set l \\<union> snd ` fst ` set l =\n    \\<Union> {{u, v} |u v. \\<exists>d. ((u, v), d) \\<in> set l}", "by (auto 0 0 simp: in_set_conv_decomp; blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fst ` set l \\<union> (fst ` set l)\\<inverse> =\n    \\<Union> {{(u, v), (v, u)} |u v. \\<exists>d. ((u, v), d) \\<in> set l}\n 2. Ball (set l)\n     (case_prod (\\<lambda>(u, v). (=) (\\<alpha>w (from_list l) {u, v})))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set l \\<union> (fst ` set l)\\<inverse> =\n    \\<Union> {{(u, v), (v, u)} |u v. \\<exists>d. ((u, v), d) \\<in> set l}", "by (auto 0 0 simp: in_set_conv_decomp; blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set l)\n     (case_prod (\\<lambda>(u, v). (=) (\\<alpha>w (from_list l) {u, v})))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set l)\n     (case_prod (\\<lambda>(u, v). (=) (\\<alpha>w (from_list l) {u, v})))", "using from_list_correct(4)[OF assms]"], ["proof (prove)\nusing this:\n  ((?u, ?v), ?d) \\<in> set l \\<Longrightarrow>\n  \\<alpha>w (from_list l) {?u, ?v} = ?d\n\ngoal (1 subgoal):\n 1. Ball (set l)\n     (case_prod (\\<lambda>(u, v). (=) (\\<alpha>w (from_list l) {u, v})))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}