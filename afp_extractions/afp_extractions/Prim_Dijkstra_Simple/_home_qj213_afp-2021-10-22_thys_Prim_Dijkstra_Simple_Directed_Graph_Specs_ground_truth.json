{"file_name": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple/Directed_Graph_Specs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple", "problem_names": ["lemmas wgraph_specs = succ_correct empty_graph_correct add_edge_correct", "lemma edges_empty[simp]: \"WGraph.edges (\\<lambda>_. \\<infinity>) = {}\"", "lemma edges_insert[simp]: \n  \"WGraph.edges (g(e:=enat d)) = Set.insert e (WGraph.edges g)\"", "lemma valid_graph_rep_code[code]: \n  \"valid_graph_rep l \\<longleftrightarrow> distinct (map (\\<lambda>(u,v,_). (u,v)) l)\"", "lemma valid_graph_rep_simps[simp]:\n  \"valid_graph_rep []\"\n  \"valid_graph_rep ((u,v,d) # l) \\<longleftrightarrow> valid_graph_rep l \\<and> (\\<forall>d'. (u,v,d')\\<notin>set l)\"", "lemma valid_graph_rep_ex1: \n  \"valid_graph_rep l \\<Longrightarrow> \\<exists>! w. \\<forall>u v d. w (u,v) = enat d \\<longleftrightarrow> (u,v,d)\\<in>set l\"", "lemma edges_undef_simps[simp]:\n  \"edges_undef [] w\"  \n  \"edges_undef l (\\<lambda>_. \\<infinity>)\"\n  \"edges_undef ((u,v,d)#l) w \\<longleftrightarrow> edges_undef l w \\<and> w (u,v) = \\<infinity>\"\n  \"edges_undef l (w((u,v) := enat d)) \\<longleftrightarrow> edges_undef l w \\<and> (\\<forall>d'. (u,v,d')\\<notin>set l)\"", "lemma from_list_correct_aux:\n  assumes \"valid_graph_rep l\"\n  assumes \"edges_undef l (\\<alpha> g)\"\n  assumes \"invar g\"\n  defines \"g' \\<equiv> fold (\\<lambda>(u,v,d). add_edge (u,v) d) l g\"\n  shows \"invar g'\"\n    and \"(\\<forall>u v d. \\<alpha> g' (u,v) = enat d \\<longleftrightarrow> \\<alpha> g (u,v) = enat d \\<or> (u,v,d)\\<in>set l)\"", "lemma from_list_correct':\n  assumes \"valid_graph_rep l\"\n  shows \"invar (from_list l)\" \n    and \"(u,v,d)\\<in>set l \\<longleftrightarrow> \\<alpha> (from_list l) (u,v) = enat d\"", "lemma from_list_correct:\n  assumes \"valid_graph_rep l\"\n  shows \"invar (from_list l)\" \"\\<alpha> (from_list l) = wgraph_of_list l\""], "translations": [["", "lemmas wgraph_specs = succ_correct empty_graph_correct add_edge_correct"], ["", "end"], ["", "locale adt_finite_wgraph = adt_wgraph where \\<alpha>=\\<alpha> for \\<alpha> :: \"'g \\<Rightarrow> ('v) wgraph\" +\n  assumes finite: \"invar g \\<Longrightarrow> finite (WGraph.edges (\\<alpha> g))\""], ["", "subsection \\<open>Constructing Weighted Graphs from Lists\\<close>"], ["", "lemma edges_empty[simp]: \"WGraph.edges (\\<lambda>_. \\<infinity>) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WGraph.edges (\\<lambda>_. \\<infinity>) = {}", "by (auto simp: WGraph.edges_def)"], ["", "lemma edges_insert[simp]: \n  \"WGraph.edges (g(e:=enat d)) = Set.insert e (WGraph.edges g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WGraph.edges (g(e := enat d)) = insert e (WGraph.edges g)", "by (auto simp: WGraph.edges_def)"], ["", "text \\<open>A list represents a graph if there are no multi-edges or duplicate edges\\<close>"], ["", "definition \"valid_graph_rep l \\<equiv> \n  (\\<forall>u d d' v. (u,v,d)\\<in>set l \\<and> (u,v,d')\\<in>set l \\<longrightarrow> d=d')\n\\<and> distinct l\n  \""], ["", "text \\<open>Alternative characterization: all node pairs must be distinct\\<close>"], ["", "lemma valid_graph_rep_code[code]: \n  \"valid_graph_rep l \\<longleftrightarrow> distinct (map (\\<lambda>(u,v,_). (u,v)) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph_rep l = distinct (map (\\<lambda>(u, v, uu_). (u, v)) l)", "by (auto simp: valid_graph_rep_def distinct_map inj_on_def)"], ["", "lemma valid_graph_rep_simps[simp]:\n  \"valid_graph_rep []\"\n  \"valid_graph_rep ((u,v,d) # l) \\<longleftrightarrow> valid_graph_rep l \\<and> (\\<forall>d'. (u,v,d')\\<notin>set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph_rep [] &&&\n    valid_graph_rep ((u, v, d) # l) =\n    (valid_graph_rep l \\<and> (\\<forall>d'. (u, v, d') \\<notin> set l))", "by (auto simp: valid_graph_rep_def)"], ["", "text \\<open>For a valid graph representation, there is exactly one graph that \n  corresponds to it\\<close>"], ["", "lemma valid_graph_rep_ex1: \n  \"valid_graph_rep l \\<Longrightarrow> \\<exists>! w. \\<forall>u v d. w (u,v) = enat d \\<longleftrightarrow> (u,v,d)\\<in>set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph_rep l \\<Longrightarrow>\n    \\<exists>!w.\n       \\<forall>u v d. (w (u, v) = enat d) = ((u, v, d) \\<in> set l)", "unfolding valid_graph_rep_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>(u, v, uu_). (u, v)) l) \\<Longrightarrow>\n    \\<exists>!w.\n       \\<forall>u v d. (w (u, v) = enat d) = ((u, v, d) \\<in> set l)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map (\\<lambda>(u, v, uu_). (u, v)) l) \\<Longrightarrow>\n    \\<exists>w.\n       \\<forall>u v d. (w (u, v) = enat d) = ((u, v, d) \\<in> set l)\n 2. \\<And>w y.\n       \\<lbrakk>distinct (map (\\<lambda>(u, v, uu_). (u, v)) l);\n        \\<forall>u v d. (w (u, v) = enat d) = ((u, v, d) \\<in> set l);\n        \\<forall>u v d.\n           (y (u, v) = enat d) = ((u, v, d) \\<in> set l)\\<rbrakk>\n       \\<Longrightarrow> w = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>(u, v, uu_). (u, v)) l) \\<Longrightarrow>\n    \\<exists>w.\n       \\<forall>u v d. (w (u, v) = enat d) = ((u, v, d) \\<in> set l)", "apply (rule exI[where x=\"\\<lambda>(u,v).\n        if \\<exists>d. (u,v,d)\\<in>set l then enat (SOME d. (u,v,d)\\<in>set l) else \\<infinity>\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>(u, v, uu_). (u, v)) l) \\<Longrightarrow>\n    \\<forall>u v d.\n       ((case (u, v) of\n         (u, v) \\<Rightarrow>\n           if \\<exists>d. (u, v, d) \\<in> set l\n           then enat (SOME d. (u, v, d) \\<in> set l) else \\<infinity>) =\n        enat d) =\n       ((u, v, d) \\<in> set l)", "by (auto intro: someI simp: distinct_map inj_on_def split: prod.splits; \n           blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w y.\n       \\<lbrakk>distinct (map (\\<lambda>(u, v, uu_). (u, v)) l);\n        \\<forall>u v d. (w (u, v) = enat d) = ((u, v, d) \\<in> set l);\n        \\<forall>u v d.\n           (y (u, v) = enat d) = ((u, v, d) \\<in> set l)\\<rbrakk>\n       \\<Longrightarrow> w = y", "subgoal for w w'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map (\\<lambda>(u, v, uu_). (u, v)) l);\n     \\<forall>u v d. (w (u, v) = enat d) = ((u, v, d) \\<in> set l);\n     \\<forall>u v d. (w' (u, v) = enat d) = ((u, v, d) \\<in> set l)\\<rbrakk>\n    \\<Longrightarrow> w = w'", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map (\\<lambda>(u, v, uu_). (u, v)) l);\n     \\<forall>u v d. (w (u, v) = enat d) = ((u, v, d) \\<in> set l);\n     \\<forall>u v d. (w' (u, v) = enat d) = ((u, v, d) \\<in> set l)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b. w (a, b) = w' (a, b)", "by (metis (mono_tags, hide_lams) not_enat_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We define this graph using determinate choice\\<close>"], ["", "definition \"wgraph_of_list l \\<equiv> THE w. \\<forall>u v d. w (u,v) = enat d \\<longleftrightarrow> (u,v,d)\\<in>set l\""], ["", "locale wgraph_from_list_algo = adt_wgraph \nbegin"], ["", "definition \"from_list l \\<equiv> fold (\\<lambda>(u,v,d). add_edge (u,v) d) l empty_graph\""], ["", "definition \"edges_undef l w \\<equiv> \\<forall>u v d. (u,v,d)\\<in>set l \\<longrightarrow> w (u,v) = \\<infinity>\""], ["", "lemma edges_undef_simps[simp]:\n  \"edges_undef [] w\"  \n  \"edges_undef l (\\<lambda>_. \\<infinity>)\"\n  \"edges_undef ((u,v,d)#l) w \\<longleftrightarrow> edges_undef l w \\<and> w (u,v) = \\<infinity>\"\n  \"edges_undef l (w((u,v) := enat d)) \\<longleftrightarrow> edges_undef l w \\<and> (\\<forall>d'. (u,v,d')\\<notin>set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edges_undef [] w &&& edges_undef l (\\<lambda>_. \\<infinity>)) &&&\n    edges_undef ((u, v, d) # l) w =\n    (edges_undef l w \\<and> w (u, v) = \\<infinity>) &&&\n    edges_undef l (w((u, v) := enat d)) =\n    (edges_undef l w \\<and> (\\<forall>d'. (u, v, d') \\<notin> set l))", "by (auto simp: edges_undef_def)"], ["", "lemma from_list_correct_aux:\n  assumes \"valid_graph_rep l\"\n  assumes \"edges_undef l (\\<alpha> g)\"\n  assumes \"invar g\"\n  defines \"g' \\<equiv> fold (\\<lambda>(u,v,d). add_edge (u,v) d) l g\"\n  shows \"invar g'\"\n    and \"(\\<forall>u v d. \\<alpha> g' (u,v) = enat d \\<longleftrightarrow> \\<alpha> g (u,v) = enat d \\<or> (u,v,d)\\<in>set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g' &&&\n    \\<forall>u v d.\n       (\\<alpha> g' (u, v) = enat d) =\n       (\\<alpha> g (u, v) = enat d \\<or> (u, v, d) \\<in> set l)", "using assms(1-3)"], ["proof (prove)\nusing this:\n  valid_graph_rep l\n  edges_undef l (\\<alpha> g)\n  invar g\n\ngoal (1 subgoal):\n 1. invar g' &&&\n    \\<forall>u v d.\n       (\\<alpha> g' (u, v) = enat d) =\n       (\\<alpha> g (u, v) = enat d \\<or> (u, v, d) \\<in> set l)", "unfolding g'_def"], ["proof (prove)\nusing this:\n  valid_graph_rep l\n  edges_undef l (\\<alpha> g)\n  invar g\n\ngoal (1 subgoal):\n 1. invar (fold (\\<lambda>(u, v, d). add_edge (u, v) d) l g) &&&\n    \\<forall>u v d.\n       (\\<alpha> (fold (\\<lambda>(u, v, d). add_edge (u, v) d) l g) (u, v) =\n        enat d) =\n       (\\<alpha> g (u, v) = enat d \\<or> (u, v, d) \\<in> set l)", "apply (induction l arbitrary: g)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g.\n       \\<lbrakk>valid_graph_rep []; edges_undef [] (\\<alpha> g);\n        invar g\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (fold (\\<lambda>(u, v, y). add_edge (u, v) y) []\n                            g)\n 2. \\<And>g.\n       \\<lbrakk>valid_graph_rep []; edges_undef [] (\\<alpha> g);\n        invar g\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u v d.\n                            (\\<alpha>\n                              (fold (\\<lambda>(u, v, y). add_edge (u, v) y)\n                                [] g)\n                              (u, v) =\n                             enat d) =\n                            (\\<alpha> g (u, v) = enat d \\<or>\n                             (u, v, d) \\<in> set [])\n 3. \\<And>a l g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>valid_graph_rep l; edges_undef l (\\<alpha> g);\n                    invar g\\<rbrakk>\n                   \\<Longrightarrow> invar\n(fold (\\<lambda>(u, v, y). add_edge (u, v) y) l g);\n        \\<And>g.\n           \\<lbrakk>valid_graph_rep l; edges_undef l (\\<alpha> g);\n            invar g\\<rbrakk>\n           \\<Longrightarrow> \\<forall>u v d.\n                                (\\<alpha>\n                                  (fold\n                                    (\\<lambda>(u, v, y). add_edge (u, v) y)\n                                    l g)\n                                  (u, v) =\n                                 enat d) =\n                                (\\<alpha> g (u, v) = enat d \\<or>\n                                 (u, v, d) \\<in> set l);\n        valid_graph_rep (a # l); edges_undef (a # l) (\\<alpha> g);\n        invar g\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (fold (\\<lambda>(u, v, y). add_edge (u, v) y)\n                            (a # l) g)\n 4. \\<And>a l g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>valid_graph_rep l; edges_undef l (\\<alpha> g);\n                    invar g\\<rbrakk>\n                   \\<Longrightarrow> invar\n(fold (\\<lambda>(u, v, y). add_edge (u, v) y) l g);\n        \\<And>g.\n           \\<lbrakk>valid_graph_rep l; edges_undef l (\\<alpha> g);\n            invar g\\<rbrakk>\n           \\<Longrightarrow> \\<forall>u v d.\n                                (\\<alpha>\n                                  (fold\n                                    (\\<lambda>(u, v, y). add_edge (u, v) y)\n                                    l g)\n                                  (u, v) =\n                                 enat d) =\n                                (\\<alpha> g (u, v) = enat d \\<or>\n                                 (u, v, d) \\<in> set l);\n        valid_graph_rep (a # l); edges_undef (a # l) (\\<alpha> g);\n        invar g\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u v d.\n                            (\\<alpha>\n                              (fold (\\<lambda>(u, v, y). add_edge (u, v) y)\n                                (a # l) g)\n                              (u, v) =\n                             enat d) =\n                            (\\<alpha> g (u, v) = enat d \\<or>\n                             (u, v, d) \\<in> set (a # l))", "by (auto simp: wgraph_specs split: if_splits)"], ["", "lemma from_list_correct':\n  assumes \"valid_graph_rep l\"\n  shows \"invar (from_list l)\" \n    and \"(u,v,d)\\<in>set l \\<longleftrightarrow> \\<alpha> (from_list l) (u,v) = enat d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (from_list l) &&&\n    ((u, v, d) \\<in> set l) = (\\<alpha> (from_list l) (u, v) = enat d)", "unfolding from_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (fold (\\<lambda>(u, v, d). add_edge (u, v) d) l empty_graph) &&&\n    ((u, v, d) \\<in> set l) =\n    (\\<alpha> (fold (\\<lambda>(u, v, d). add_edge (u, v) d) l empty_graph)\n      (u, v) =\n     enat d)", "using from_list_correct_aux[OF assms, where g=empty_graph]"], ["proof (prove)\nusing this:\n  \\<lbrakk>edges_undef l (\\<alpha> empty_graph); invar empty_graph\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (fold (\\<lambda>(u, v, d). add_edge (u, v) d) l\n                       empty_graph)\n  \\<lbrakk>edges_undef l (\\<alpha> empty_graph); invar empty_graph\\<rbrakk>\n  \\<Longrightarrow> \\<forall>u v d.\n                       (\\<alpha>\n                         (fold (\\<lambda>(u, v, d). add_edge (u, v) d) l\n                           empty_graph)\n                         (u, v) =\n                        enat d) =\n                       (\\<alpha> empty_graph (u, v) = enat d \\<or>\n                        (u, v, d) \\<in> set l)\n\ngoal (1 subgoal):\n 1. invar (fold (\\<lambda>(u, v, d). add_edge (u, v) d) l empty_graph) &&&\n    ((u, v, d) \\<in> set l) =\n    (\\<alpha> (fold (\\<lambda>(u, v, d). add_edge (u, v) d) l empty_graph)\n      (u, v) =\n     enat d)", "by (auto simp: wgraph_specs)"], ["", "lemma from_list_correct:\n  assumes \"valid_graph_rep l\"\n  shows \"invar (from_list l)\" \"\\<alpha> (from_list l) = wgraph_of_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (from_list l) &&& \\<alpha> (from_list l) = wgraph_of_list l", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. invar (from_list l)\n 2. \\<alpha> (from_list l) = wgraph_of_list l", "from theI'[OF valid_graph_rep_ex1[OF assms], folded wgraph_of_list_def]"], ["proof (chain)\npicking this:\n  \\<forall>u v d.\n     (wgraph_of_list l (u, v) = enat d) = ((u, v, d) \\<in> set l)", "have \"(wgraph_of_list l (u, v) = enat d) = ((u, v, d) \\<in> set l)\" for u v d"], ["proof (prove)\nusing this:\n  \\<forall>u v d.\n     (wgraph_of_list l (u, v) = enat d) = ((u, v, d) \\<in> set l)\n\ngoal (1 subgoal):\n 1. (wgraph_of_list l (u, v) = enat d) = ((u, v, d) \\<in> set l)", "by blast"], ["proof (state)\nthis:\n  (wgraph_of_list l (?u, ?v) = enat ?d) = ((?u, ?v, ?d) \\<in> set l)\n\ngoal (2 subgoals):\n 1. invar (from_list l)\n 2. \\<alpha> (from_list l) = wgraph_of_list l", "then"], ["proof (chain)\npicking this:\n  (wgraph_of_list l (?u, ?v) = enat ?d) = ((?u, ?v, ?d) \\<in> set l)", "show \"\\<alpha> (from_list l) = wgraph_of_list l\""], ["proof (prove)\nusing this:\n  (wgraph_of_list l (?u, ?v) = enat ?d) = ((?u, ?v, ?d) \\<in> set l)\n\ngoal (1 subgoal):\n 1. \\<alpha> (from_list l) = wgraph_of_list l", "using from_list_correct_aux[OF assms, where g=empty_graph]"], ["proof (prove)\nusing this:\n  (wgraph_of_list l (?u, ?v) = enat ?d) = ((?u, ?v, ?d) \\<in> set l)\n  \\<lbrakk>edges_undef l (\\<alpha> empty_graph); invar empty_graph\\<rbrakk>\n  \\<Longrightarrow> invar\n                     (fold (\\<lambda>(u, v, d). add_edge (u, v) d) l\n                       empty_graph)\n  \\<lbrakk>edges_undef l (\\<alpha> empty_graph); invar empty_graph\\<rbrakk>\n  \\<Longrightarrow> \\<forall>u v d.\n                       (\\<alpha>\n                         (fold (\\<lambda>(u, v, d). add_edge (u, v) d) l\n                           empty_graph)\n                         (u, v) =\n                        enat d) =\n                       (\\<alpha> empty_graph (u, v) = enat d \\<or>\n                        (u, v, d) \\<in> set l)\n\ngoal (1 subgoal):\n 1. \\<alpha> (from_list l) = wgraph_of_list l", "apply (clarsimp simp: fun_eq_iff wgraph_specs from_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>u v d.\n                   (wgraph_of_list l (u, v) = enat d) =\n                   ((u, v, d) \\<in> set l);\n        invar (fold (\\<lambda>(u, v, y). add_edge (u, v) y) l empty_graph);\n        \\<forall>u v d.\n           (\\<alpha>\n             (fold (\\<lambda>(u, v, y). add_edge (u, v) y) l empty_graph)\n             (u, v) =\n            enat d) =\n           ((u, v, d) \\<in> set l)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                          (fold (\\<lambda>(u, v, y). add_edge (u, v) y) l\n                            empty_graph)\n                          (a, b) =\n                         wgraph_of_list l (a, b)", "apply (metis (no_types) enat.exhaust)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<alpha> (from_list l) = wgraph_of_list l\n\ngoal (1 subgoal):\n 1. invar (from_list l)", "show \"invar (from_list l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (from_list l)", "by (simp add: assms from_list_correct')"], ["proof (state)\nthis:\n  invar (from_list l)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}