{"file_name": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple/Dijkstra_Abstract.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple", "problem_names": ["lemma relax_mono: \"relax_outgoing u D v \\<le> D v\"", "lemma unfinished_nodes_subset: \"unfinished_dnodes S \\<subseteq> all_dnodes\"", "theorem (in Dijkstra) invar_init: \"D_invar initD initS\"", "lemma maintain_upper_bound: \"\\<delta> s u \\<le> (relax_outgoing v D) u\"", "lemma relax_precise_id: \"D v = \\<delta> s v \\<Longrightarrow> relax_outgoing u D v = \\<delta> s v\"", "lemma relax_finished_id: \"v\\<in>S \\<Longrightarrow> relax_outgoing u D v = D v\"", "lemma maintain_S_precise_and_connected:  \n  assumes UNS: \"u\\<notin>S\"\n  assumes MIN: \"\\<forall>v. v\\<notin>S \\<longrightarrow> D u \\<le> D v\"\n  shows \"D u = \\<delta> s u\"", "theorem maintain_D_invar:\n  assumes UNS: \"u\\<notin>S\"\n  assumes UNI: \"D u < \\<infinity>\"\n  assumes MIN: \"\\<forall>v. v\\<notin>S \\<longrightarrow> D u \\<le> D v\"\n  shows \"D_invar (relax_outgoing u D) (Set.insert u S)\"", "lemma invar_finish_imp_correct:\n  assumes F: \"\\<forall>u. u\\<notin>S \\<longrightarrow> D u = \\<infinity>\"\n  shows \"D u = \\<delta> s u\"", "lemma unfinished_nodes_decr:\n  assumes UNS: \"u\\<notin>S\"\n  assumes UNI: \"D u < \\<infinity>\"\n  shows \"unfinished_dnodes (Set.insert u S) \\<subset> unfinished_dnodes S\"", "lemma enat_of_option_inj[simp]: \"enat_of_option x = enat_of_option y \\<longleftrightarrow> x=y\"", "lemma enat_of_option_simps[simp]:\n  \"enat_of_option x = enat n \\<longleftrightarrow> x = Some n\"\n  \"enat_of_option x = \\<infinity> \\<longleftrightarrow> x = None\"\n  \"enat n = enat_of_option x \\<longleftrightarrow> x = Some n\"\n  \"\\<infinity> = enat_of_option x \\<longleftrightarrow> x = None\"", "lemma enat_of_option_le_conv: \n  \"enat_of_option m \\<le> enat_of_option n \\<longleftrightarrow> (case (m,n) of \n      (_,None) \\<Rightarrow> True\n    | (Some a, Some b) \\<Rightarrow> a\\<le>b\n    | (_, _) \\<Rightarrow> False\n  )\"", "lemma coupling_fun: \"coupling Q V D S \\<Longrightarrow> coupling Q V D' S' \\<Longrightarrow> D'=D \\<and> S'=S\"", "lemma (in Dijkstra_Invar) coupling_step:\n  assumes C: \"coupling Q V D S\"\n  assumes UNS: \"u\\<notin>S\"\n  assumes UNI: \"D u = enat du\"\n  \n  shows \"coupling \n    ((relax_outgoing' u du V Q)(u:=None)) (V(u\\<mapsto>du)) \n    (relax_outgoing u D) (Set.insert u S)\"", "lemma coupling_init:\n  \"coupling initQ initV initD initS\"", "lemma coupling_cond:\n  assumes \"coupling Q V D S\"\n  shows \"(Q = Map.empty) \\<longleftrightarrow> (\\<forall>u. u\\<notin>S \\<longrightarrow> D u = \\<infinity>)\"", "lemma coupling_unfinished: \n  \"coupling Q V D S \\<Longrightarrow> unfinished_dnodes' V = unfinished_dnodes S\"", "lemma relax_outgoing''_refine:\n  assumes \"set l = {(d,v). w (u,v) = enat d}\"  \n  shows \"relax_outgoing'' l du V Q = relax_outgoing' u du V Q\""], "translations": [["", "lemma relax_mono: \"relax_outgoing u D v \\<le> D v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relax_outgoing u D v \\<le> D v", "by (auto simp: relax_outgoing_def)"], ["", "definition \"all_dnodes \\<equiv> Set.insert s { v . \\<exists>u. w (u,v)\\<noteq>\\<infinity> }\""], ["", "definition \"unfinished_dnodes S \\<equiv> all_dnodes - S \""], ["", "lemma unfinished_nodes_subset: \"unfinished_dnodes S \\<subseteq> all_dnodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfinished_dnodes S \\<subseteq> all_dnodes", "by (auto simp: unfinished_dnodes_def)"], ["", "end"], ["", "subsubsection \\<open>Invariant\\<close>"], ["", "text \\<open>The invariant is defined as locale\\<close>"], ["", "locale Dijkstra_Invar = Dijkstra w s for w and s :: 'v +\n  fixes D :: \"'v estimate\" and S :: \"'v set\"\n  assumes upper_bound: \\<open>\\<delta> s u \\<le> D u\\<close> \\<comment> \\<open>\\<open>D\\<close> is a valid estimate\\<close>\n  assumes s_in_S: \\<open>s\\<in>S \\<or> (D=(\\<lambda>_. \\<infinity>)(s:=0) \\<and> S={})\\<close> \\<comment> \\<open>The start node is \n    finished, or we are in initial state\\<close>  \n  assumes S_precise: \"u\\<in>S \\<Longrightarrow> D u = \\<delta> s u\" \\<comment> \\<open>Finished nodes have precise \n    estimate\\<close>\n  assumes S_relaxed: \\<open>v\\<in>S \\<Longrightarrow> D u \\<le> \\<delta> s v + w (v,u)\\<close> \\<comment> \\<open>Outgoing edges of \n    finished nodes have been relaxed, using precise distance\\<close>\nbegin"], ["", "abbreviation (in Dijkstra) \"D_invar \\<equiv> Dijkstra_Invar w s\""], ["", "text \\<open>The invariant holds for the initial state\\<close>"], ["", "theorem (in Dijkstra) invar_init: \"D_invar initD initS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D_invar initD initS", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u. \\<delta> s u \\<le> initD u\n 2. s \\<in> initS \\<or>\n    initD = (\\<lambda>_. \\<infinity>)(s := 0) \\<and> initS = {}\n 3. \\<And>u. u \\<in> initS \\<Longrightarrow> initD u = \\<delta> s u\n 4. \\<And>v u.\n       v \\<in> initS \\<Longrightarrow> initD u \\<le> \\<delta> s v + w (v, u)", "unfolding initD_def initS_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u. \\<delta> s u \\<le> ((\\<lambda>_. \\<infinity>)(s := 0)) u\n 2. s \\<in> {} \\<or>\n    (\\<lambda>_. \\<infinity>)(s := 0) = (\\<lambda>_. \\<infinity>)\n    (s := 0) \\<and>\n    {} = {}\n 3. \\<And>u.\n       u \\<in> {} \\<Longrightarrow>\n       ((\\<lambda>_. \\<infinity>)(s := 0)) u = \\<delta> s u\n 4. \\<And>v u.\n       v \\<in> {} \\<Longrightarrow>\n       ((\\<lambda>_. \\<infinity>)(s := 0)) u \\<le> \\<delta> s v + w (v, u)", "by (auto simp: relax_outgoing_def distance_direct)"], ["", "text \\<open>Relaxing some edges maintains the upper bound property\\<close>"], ["", "lemma maintain_upper_bound: \"\\<delta> s u \\<le> (relax_outgoing v D) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s u \\<le> relax_outgoing v D u", "apply (clarsimp simp: relax_outgoing_def upper_bound split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s u \\<le> D v + w (v, u)", "using triangle upper_bound add_right_mono dual_order.trans"], ["proof (prove)\nusing this:\n  \\<delta> ?s ?v \\<le> \\<delta> ?s ?u + w (?u, ?v)\n  \\<delta> s ?u \\<le> D ?u\n  ?a \\<le> ?b \\<Longrightarrow> ?a + ?c \\<le> ?b + ?c\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<le> D v + w (v, u)", "by blast"], ["", "text \\<open>Relaxing edges will not affect nodes with already precise estimates\\<close>"], ["", "lemma relax_precise_id: \"D v = \\<delta> s v \\<Longrightarrow> relax_outgoing u D v = \\<delta> s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D v = \\<delta> s v \\<Longrightarrow> relax_outgoing u D v = \\<delta> s v", "using maintain_upper_bound upper_bound relax_mono"], ["proof (prove)\nusing this:\n  \\<delta> s ?u \\<le> relax_outgoing ?v D ?u\n  \\<delta> s ?u \\<le> D ?u\n  relax_outgoing ?u ?D ?v \\<le> ?D ?v\n\ngoal (1 subgoal):\n 1. D v = \\<delta> s v \\<Longrightarrow> relax_outgoing u D v = \\<delta> s v", "by (metis antisym)"], ["", "text \\<open>In particular, relaxing edges will not affect finished nodes\\<close>"], ["", "lemma relax_finished_id: \"v\\<in>S \\<Longrightarrow> relax_outgoing u D v = D v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> S \\<Longrightarrow> relax_outgoing u D v = D v", "by (simp add: S_precise relax_precise_id)"], ["", "text \\<open>The least (finite) estimate among all nodes \\<open>u\\<close> not in \\<open>S\\<close> is already precise.\n  This will allow us to add the node \\<open>u\\<close> to \\<open>S\\<close>. \\<close>"], ["", "lemma maintain_S_precise_and_connected:  \n  assumes UNS: \"u\\<notin>S\"\n  assumes MIN: \"\\<forall>v. v\\<notin>S \\<longrightarrow> D u \\<le> D v\"\n  shows \"D u = \\<delta> s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "text \\<open>We start with a case distinction whether we are in the first \n    step of the loop, where we process the start node, or in subsequent steps,\n    where the start node has already been finished.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "proof (cases \"u=s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u = s \\<Longrightarrow> D u = \\<delta> s u\n 2. u \\<noteq> s \\<Longrightarrow> D u = \\<delta> s u", "assume [simp]: \"u=s\" \\<comment> \\<open>First step of loop\\<close>"], ["proof (state)\nthis:\n  u = s\n\ngoal (2 subgoals):\n 1. u = s \\<Longrightarrow> D u = \\<delta> s u\n 2. u \\<noteq> s \\<Longrightarrow> D u = \\<delta> s u", "then"], ["proof (chain)\npicking this:\n  u = s", "show ?thesis"], ["proof (prove)\nusing this:\n  u = s\n\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "using \\<open>u\\<notin>S\\<close> s_in_S"], ["proof (prove)\nusing this:\n  u = s\n  u \\<notin> S\n  s \\<in> S \\<or> D = (\\<lambda>_. \\<infinity>)(s := 0) \\<and> S = {}\n\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "by simp"], ["proof (state)\nthis:\n  D u = \\<delta> s u\n\ngoal (1 subgoal):\n 1. u \\<noteq> s \\<Longrightarrow> D u = \\<delta> s u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> s \\<Longrightarrow> D u = \\<delta> s u", "assume \\<open>u\\<noteq>s\\<close> \\<comment> \\<open>Later step of loop\\<close>"], ["proof (state)\nthis:\n  u \\<noteq> s\n\ngoal (1 subgoal):\n 1. u \\<noteq> s \\<Longrightarrow> D u = \\<delta> s u", "text \\<open>The start node has already been finished\\<close>"], ["proof (state)\nthis:\n  u \\<noteq> s\n\ngoal (1 subgoal):\n 1. u \\<noteq> s \\<Longrightarrow> D u = \\<delta> s u", "with s_in_S MIN"], ["proof (chain)\npicking this:\n  s \\<in> S \\<or> D = (\\<lambda>_. \\<infinity>)(s := 0) \\<and> S = {}\n  \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\n  u \\<noteq> s", "have \\<open>s\\<in>S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S \\<or> D = (\\<lambda>_. \\<infinity>)(s := 0) \\<and> S = {}\n  \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\n  u \\<noteq> s\n\ngoal (1 subgoal):\n 1. s \\<in> S", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. (if v = s then 0 else \\<infinity>) = \\<infinity>;\n     u \\<noteq> s; S = {}; D = (\\<lambda>_. \\<infinity>)(s := 0)\\<rbrakk>\n    \\<Longrightarrow> False", "using infinity_ne_i0"], ["proof (prove)\nusing this:\n  \\<infinity> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. (if v = s then 0 else \\<infinity>) = \\<infinity>;\n     u \\<noteq> s; S = {}; D = (\\<lambda>_. \\<infinity>)(s := 0)\\<rbrakk>\n    \\<Longrightarrow> False", "by metis"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. u \\<noteq> s \\<Longrightarrow> D u = \\<delta> s u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "text \\<open>Next, we handle the case that \\<open>u\\<close> is unreachable.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "proof (cases \\<open>\\<delta> s u < \\<infinity>\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u\n 2. \\<not> \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "assume \"\\<not>(\\<delta> s u < \\<infinity>)\" \\<comment> \\<open>Node is unreachable (infinite distance)\\<close>"], ["proof (state)\nthis:\n  \\<not> \\<delta> s u < \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u\n 2. \\<not> \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "text \\<open>By the upper-bound property, we get \\<open>D u = \\<delta> s u = \\<infinity>\\<close>\\<close>"], ["proof (state)\nthis:\n  \\<not> \\<delta> s u < \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u\n 2. \\<not> \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<delta> s u < \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<delta> s u < \\<infinity>\n\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "using upper_bound[of u]"], ["proof (prove)\nusing this:\n  \\<not> \\<delta> s u < \\<infinity>\n  \\<delta> s u \\<le> D u\n\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "by auto"], ["proof (state)\nthis:\n  D u = \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "assume \"\\<delta> s u < \\<infinity>\" \\<comment> \\<open>Main case: Node has finite distance\\<close>"], ["proof (state)\nthis:\n  \\<delta> s u < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "text \\<open>Consider a shortest path from \\<open>s\\<close> to \\<open>u\\<close>\\<close>"], ["proof (state)\nthis:\n  \\<delta> s u < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "obtain p where \"path s p u\" and DSU: \"\\<delta> s u = sum_list p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path s p u; \\<delta> s u = sum_list p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_shortest_path)"], ["proof (state)\nthis:\n  path s p u\n  \\<delta> s u = sum_list p\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "text \\<open>It goes from inside \\<open>S\\<close> to outside \\<open>S\\<close>, so there must be an edge at the border.\n      Let \\<open>(x,y)\\<close> be such an edge, with \\<open>x\\<in>S\\<close> and \\<open>y\\<notin>S\\<close>.\\<close>"], ["proof (state)\nthis:\n  path s p u\n  \\<delta> s u = sum_list p\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "from find_leave_edgeE[OF \\<open>path s p u\\<close> \\<open>s\\<in>S\\<close> \\<open>u\\<notin>S\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>p1 x y p2.\n      \\<lbrakk>p = p1 @ w (x, y) # p2; x \\<in> S; y \\<notin> S; path s p1 x;\n       path y p2 u\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain p1 x y p2 where\n      [simp]: \"p = p1 @ w (x, y) # p2\" \n      and DECOMP: \"x \\<in> S\" \"y \\<notin> S\" \"path s p1 x\" \"path y p2 u\""], ["proof (prove)\nusing this:\n  (\\<And>p1 x y p2.\n      \\<lbrakk>p = p1 @ w (x, y) # p2; x \\<in> S; y \\<notin> S; path s p1 x;\n       path y p2 u\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p1 x y p2.\n        \\<lbrakk>p = p1 @ w (x, y) # p2; x \\<in> S; y \\<notin> S;\n         path s p1 x; path y p2 u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  p = p1 @ w (x, y) # p2\n  x \\<in> S\n  y \\<notin> S\n  path s p1 x\n  path y p2 u\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "text \\<open>As prefixes of shortest paths are again shortest paths, the shortest \n          path to \\<open>y\\<close> ends with edge \\<open>(x,y)\\<close> \\<close>"], ["proof (state)\nthis:\n  p = p1 @ w (x, y) # p2\n  x \\<in> S\n  y \\<notin> S\n  path s p1 x\n  path y p2 u\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "have DSX: \"\\<delta> s x = sum_list p1\" and DSY: \"\\<delta> s y = \\<delta> s x + w (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s x = sum_list p1 &&& \\<delta> s y = \\<delta> s x + w (x, y)", "using shortest_path_prefix[of s p1 x \"w (x,y)#p2\" u] \n        and shortest_path_prefix[of s \"p1@[w (x,y)]\" y p2 u]\n        and \\<open>\\<delta> s u < \\<infinity>\\<close> DECOMP"], ["proof (prove)\nusing this:\n  \\<lbrakk>path s p1 x; path x (w (x, y) # p2) u;\n   \\<delta> s u = sum_list p1 + sum_list (w (x, y) # p2);\n   \\<delta> s u < \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s x = sum_list p1\n  \\<lbrakk>path s p1 x; path x (w (x, y) # p2) u;\n   \\<delta> s u = sum_list p1 + sum_list (w (x, y) # p2);\n   \\<delta> s u < \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s x < \\<infinity>\n  \\<lbrakk>path s (p1 @ [w (x, y)]) y; path y p2 u;\n   \\<delta> s u = sum_list (p1 @ [w (x, y)]) + sum_list p2;\n   \\<delta> s u < \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s y = sum_list (p1 @ [w (x, y)])\n  \\<lbrakk>path s (p1 @ [w (x, y)]) y; path y p2 u;\n   \\<delta> s u = sum_list (p1 @ [w (x, y)]) + sum_list p2;\n   \\<delta> s u < \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> \\<delta> s y < \\<infinity>\n  \\<delta> s u < \\<infinity>\n  x \\<in> S\n  y \\<notin> S\n  path s p1 x\n  path y p2 u\n\ngoal (1 subgoal):\n 1. \\<delta> s x = sum_list p1 &&& \\<delta> s y = \\<delta> s x + w (x, y)", "by (force simp: DSU)+"], ["proof (state)\nthis:\n  \\<delta> s x = sum_list p1\n  \\<delta> s y = \\<delta> s x + w (x, y)\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "text \\<open>Upon adding \\<open>x\\<close> to \\<open>S\\<close>, this edge has been relaxed with the precise\n       estimate for \\<open>x\\<close>. At this point the estimate for \\<open>y\\<close> has become \n       precise, too\\<close>"], ["proof (state)\nthis:\n  \\<delta> s x = sum_list p1\n  \\<delta> s y = \\<delta> s x + w (x, y)\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "with \\<open>x\\<in>S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S\n  \\<delta> s x = sum_list p1\n  \\<delta> s y = \\<delta> s x + w (x, y)", "have \"D y = \\<delta> s y\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  \\<delta> s x = sum_list p1\n  \\<delta> s y = \\<delta> s x + w (x, y)\n\ngoal (1 subgoal):\n 1. D y = \\<delta> s y", "by (metis S_relaxed antisym_conv upper_bound)"], ["proof (state)\nthis:\n  D y = \\<delta> s y\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "moreover"], ["proof (state)\nthis:\n  D y = \\<delta> s y\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "text \\<open>The shortest path to \\<open>y\\<close> is a prefix of that to \\<open>u\\<close>, thus \n      it shorter or equal\\<close>"], ["proof (state)\nthis:\n  D y = \\<delta> s y\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "have \"\\<dots> \\<le> \\<delta> s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s y \\<le> \\<delta> s u", "using DSU"], ["proof (prove)\nusing this:\n  \\<delta> s u = sum_list p\n\ngoal (1 subgoal):\n 1. \\<delta> s y \\<le> \\<delta> s u", "by (simp add: DSX DSY)"], ["proof (state)\nthis:\n  \\<delta> s y \\<le> \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "moreover"], ["proof (state)\nthis:\n  \\<delta> s y \\<le> \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "text \\<open>The estimate for \\<open>u\\<close> is an upper bound\\<close>"], ["proof (state)\nthis:\n  \\<delta> s y \\<le> \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "have \"\\<dots> \\<le> D u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s u \\<le> D u", "using upper_bound"], ["proof (prove)\nusing this:\n  \\<delta> s ?u \\<le> D ?u\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<le> D u", "by (auto)"], ["proof (state)\nthis:\n  \\<delta> s u \\<le> D u\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "moreover"], ["proof (state)\nthis:\n  \\<delta> s u \\<le> D u\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "text \\<open>\\<open>u\\<close> was a node with smallest estimate\\<close>"], ["proof (state)\nthis:\n  \\<delta> s u \\<le> D u\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "have \"\\<dots> \\<le> D y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D u \\<le> D y", "using \\<open>u\\<notin>S\\<close> \\<open>y\\<notin>S\\<close> MIN"], ["proof (prove)\nusing this:\n  u \\<notin> S\n  y \\<notin> S\n  \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\n\ngoal (1 subgoal):\n 1. D u \\<le> D y", "by auto"], ["proof (state)\nthis:\n  D u \\<le> D y\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity> \\<Longrightarrow> D u = \\<delta> s u", "ultimately"], ["proof (chain)\npicking this:\n  D y = \\<delta> s y\n  \\<delta> s y \\<le> \\<delta> s u\n  \\<delta> s u \\<le> D u\n  D u \\<le> D y", "text \\<open>This closed a cycle in the inequation chain. Thus, by \n      antisymmetry, all items are equal. In particular, \\<open>D u = \\<delta> s u\\<close>, qed.\\<close>"], ["proof (chain)\npicking this:\n  D y = \\<delta> s y\n  \\<delta> s y \\<le> \\<delta> s u\n  \\<delta> s u \\<le> D u\n  D u \\<le> D y", "show \"D u = \\<delta> s u\""], ["proof (prove)\nusing this:\n  D y = \\<delta> s y\n  \\<delta> s y \\<le> \\<delta> s u\n  \\<delta> s u \\<le> D u\n  D u \\<le> D y\n\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "by simp"], ["proof (state)\nthis:\n  D u = \\<delta> s u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D u = \\<delta> s u\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A step of Dijkstra's algorithm maintains the invariant.\n  More precisely, in a step of Dijkstra's algorithm, \n  we pick a node \\<open>u\\<notin>S\\<close> with least finite estimate, relax the outgoing \n  edges of \\<open>u\\<close>, and add \\<open>u\\<close> to \\<open>S\\<close>.\\<close>"], ["", "theorem maintain_D_invar:\n  assumes UNS: \"u\\<notin>S\"\n  assumes UNI: \"D u < \\<infinity>\"\n  assumes MIN: \"\\<forall>v. v\\<notin>S \\<longrightarrow> D u \\<le> D v\"\n  shows \"D_invar (relax_outgoing u D) (Set.insert u S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D_invar (relax_outgoing u D) (insert u S)", "apply (cases \\<open>s\\<in>S\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s \\<in> S \\<Longrightarrow> D_invar (relax_outgoing u D) (insert u S)\n 2. s \\<notin> S \\<Longrightarrow> D_invar (relax_outgoing u D) (insert u S)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> D_invar (relax_outgoing u D) (insert u S)", "apply (unfold_locales)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ua.\n       s \\<in> S \\<Longrightarrow> \\<delta> s ua \\<le> relax_outgoing u D ua\n 2. s \\<in> S \\<Longrightarrow>\n    s \\<in> insert u S \\<or>\n    relax_outgoing u D = (\\<lambda>_. \\<infinity>)(s := 0) \\<and>\n    insert u S = {}\n 3. \\<And>ua.\n       \\<lbrakk>s \\<in> S; ua \\<in> insert u S\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D ua = \\<delta> s ua\n 4. \\<And>v ua.\n       \\<lbrakk>s \\<in> S; v \\<in> insert u S\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D ua\n                         \\<le> \\<delta> s v + w (v, ua)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> \\<delta> s ua_ \\<le> relax_outgoing u D ua_", "by (simp add: maintain_upper_bound)"], ["proof (prove)\ngoal (3 subgoals):\n 1. s \\<in> S \\<Longrightarrow>\n    s \\<in> insert u S \\<or>\n    relax_outgoing u D = (\\<lambda>_. \\<infinity>)(s := 0) \\<and>\n    insert u S = {}\n 2. \\<And>ua.\n       \\<lbrakk>s \\<in> S; ua \\<in> insert u S\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D ua = \\<delta> s ua\n 3. \\<And>v ua.\n       \\<lbrakk>s \\<in> S; v \\<in> insert u S\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D ua\n                         \\<le> \\<delta> s v + w (v, ua)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow>\n    s \\<in> insert u S \\<or>\n    relax_outgoing u D = (\\<lambda>_. \\<infinity>)(s := 0) \\<and>\n    insert u S = {}", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ua.\n       \\<lbrakk>s \\<in> S; ua \\<in> insert u S\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D ua = \\<delta> s ua\n 2. \\<And>v ua.\n       \\<lbrakk>s \\<in> S; v \\<in> insert u S\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D ua\n                         \\<le> \\<delta> s v + w (v, ua)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; ua_ \\<in> insert u S\\<rbrakk>\n    \\<Longrightarrow> relax_outgoing u D ua_ = \\<delta> s ua_", "using maintain_S_precise_and_connected[OF UNS MIN] S_precise"], ["proof (prove)\nusing this:\n  D u = \\<delta> s u\n  ?u \\<in> S \\<Longrightarrow> D ?u = \\<delta> s ?u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; ua_ \\<in> insert u S\\<rbrakk>\n    \\<Longrightarrow> relax_outgoing u D ua_ = \\<delta> s ua_", "by (auto simp: relax_precise_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v ua.\n       \\<lbrakk>s \\<in> S; v \\<in> insert u S\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D ua\n                         \\<le> \\<delta> s v + w (v, ua)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; v_ \\<in> insert u S\\<rbrakk>\n    \\<Longrightarrow> relax_outgoing u D ua_\n                      \\<le> \\<delta> s v_ + w (v_, ua_)", "using maintain_S_precise_and_connected[OF UNS MIN]"], ["proof (prove)\nusing this:\n  D u = \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; v_ \\<in> insert u S\\<rbrakk>\n    \\<Longrightarrow> relax_outgoing u D ua_\n                      \\<le> \\<delta> s v_ + w (v_, ua_)", "by (auto simp: relax_outgoing_def S_relaxed min.coboundedI1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<notin> S \\<Longrightarrow> D_invar (relax_outgoing u D) (insert u S)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<notin> S \\<Longrightarrow> D_invar (relax_outgoing u D) (insert u S)", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ua.\n       s \\<notin> S \\<Longrightarrow>\n       \\<delta> s ua \\<le> relax_outgoing u D ua\n 2. s \\<notin> S \\<Longrightarrow>\n    s \\<in> insert u S \\<or>\n    relax_outgoing u D = (\\<lambda>_. \\<infinity>)(s := 0) \\<and>\n    insert u S = {}\n 3. \\<And>ua.\n       \\<lbrakk>s \\<notin> S; ua \\<in> insert u S\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D ua = \\<delta> s ua\n 4. \\<And>v ua.\n       \\<lbrakk>s \\<notin> S; v \\<in> insert u S\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D ua\n                         \\<le> \\<delta> s v + w (v, ua)", "using s_in_S UNI distance_direct"], ["proof (prove)\nusing this:\n  s \\<in> S \\<or> D = (\\<lambda>_. \\<infinity>)(s := 0) \\<and> S = {}\n  D u < \\<infinity>\n  \\<delta> ?s ?u \\<le> w (?s, ?u)\n\ngoal (4 subgoals):\n 1. \\<And>ua.\n       s \\<notin> S \\<Longrightarrow>\n       \\<delta> s ua \\<le> relax_outgoing u D ua\n 2. s \\<notin> S \\<Longrightarrow>\n    s \\<in> insert u S \\<or>\n    relax_outgoing u D = (\\<lambda>_. \\<infinity>)(s := 0) \\<and>\n    insert u S = {}\n 3. \\<And>ua.\n       \\<lbrakk>s \\<notin> S; ua \\<in> insert u S\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D ua = \\<delta> s ua\n 4. \\<And>v ua.\n       \\<lbrakk>s \\<notin> S; v \\<in> insert u S\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D ua\n                         \\<le> \\<delta> s v + w (v, ua)", "by (auto simp: relax_outgoing_def split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>When the algorithm is finished, i.e., when there are \n  no unfinished nodes with finite estimates left,\n  then all estimates are accurate.\\<close>"], ["", "lemma invar_finish_imp_correct:\n  assumes F: \"\\<forall>u. u\\<notin>S \\<longrightarrow> D u = \\<infinity>\"\n  shows \"D u = \\<delta> s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "proof (cases \"u\\<in>S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> S \\<Longrightarrow> D u = \\<delta> s u\n 2. u \\<notin> S \\<Longrightarrow> D u = \\<delta> s u", "assume \"u\\<in>S\""], ["proof (state)\nthis:\n  u \\<in> S\n\ngoal (2 subgoals):\n 1. u \\<in> S \\<Longrightarrow> D u = \\<delta> s u\n 2. u \\<notin> S \\<Longrightarrow> D u = \\<delta> s u", "text \\<open>The estimates of finished nodes are accurate\\<close>"], ["proof (state)\nthis:\n  u \\<in> S\n\ngoal (2 subgoals):\n 1. u \\<in> S \\<Longrightarrow> D u = \\<delta> s u\n 2. u \\<notin> S \\<Longrightarrow> D u = \\<delta> s u", "then"], ["proof (chain)\npicking this:\n  u \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> S\n\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "using S_precise"], ["proof (prove)\nusing this:\n  u \\<in> S\n  ?u \\<in> S \\<Longrightarrow> D ?u = \\<delta> s ?u\n\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "by simp"], ["proof (state)\nthis:\n  D u = \\<delta> s u\n\ngoal (1 subgoal):\n 1. u \\<notin> S \\<Longrightarrow> D u = \\<delta> s u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> S \\<Longrightarrow> D u = \\<delta> s u", "assume \\<open>u\\<notin>S\\<close>"], ["proof (state)\nthis:\n  u \\<notin> S\n\ngoal (1 subgoal):\n 1. u \\<notin> S \\<Longrightarrow> D u = \\<delta> s u", "text \\<open>\\<open>D u\\<close> is minimal, and minimal estimates are precise\\<close>"], ["proof (state)\nthis:\n  u \\<notin> S\n\ngoal (1 subgoal):\n 1. u \\<notin> S \\<Longrightarrow> D u = \\<delta> s u", "then"], ["proof (chain)\npicking this:\n  u \\<notin> S", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<notin> S\n\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "using F maintain_S_precise_and_connected[of u]"], ["proof (prove)\nusing this:\n  u \\<notin> S\n  \\<forall>u. u \\<notin> S \\<longrightarrow> D u = \\<infinity>\n  \\<lbrakk>u \\<notin> S;\n   \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\\<rbrakk>\n  \\<Longrightarrow> D u = \\<delta> s u\n\ngoal (1 subgoal):\n 1. D u = \\<delta> s u", "by auto"], ["proof (state)\nthis:\n  D u = \\<delta> s u\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A step decreases the set of unfinished nodes.\\<close>"], ["", "lemma unfinished_nodes_decr:\n  assumes UNS: \"u\\<notin>S\"\n  assumes UNI: \"D u < \\<infinity>\"\n  shows \"unfinished_dnodes (Set.insert u S) \\<subset> unfinished_dnodes S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfinished_dnodes (insert u S) \\<subset> unfinished_dnodes S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unfinished_dnodes (insert u S) \\<subset> unfinished_dnodes S", "text \\<open>There is a path to \\<open>u\\<close>\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. unfinished_dnodes (insert u S) \\<subset> unfinished_dnodes S", "from UNI"], ["proof (chain)\npicking this:\n  D u < \\<infinity>", "have \"\\<delta> s u < \\<infinity>\""], ["proof (prove)\nusing this:\n  D u < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity>", "using upper_bound[of u] leD"], ["proof (prove)\nusing this:\n  D u < \\<infinity>\n  \\<delta> s u \\<le> D u\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n\ngoal (1 subgoal):\n 1. \\<delta> s u < \\<infinity>", "by fastforce"], ["proof (state)\nthis:\n  \\<delta> s u < \\<infinity>\n\ngoal (1 subgoal):\n 1. unfinished_dnodes (insert u S) \\<subset> unfinished_dnodes S", "text \\<open>Thus, \\<open>u\\<close> is among \\<open>all_dnodes\\<close>\\<close>"], ["proof (state)\nthis:\n  \\<delta> s u < \\<infinity>\n\ngoal (1 subgoal):\n 1. unfinished_dnodes (insert u S) \\<subset> unfinished_dnodes S", "have \"u\\<in>all_dnodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> all_dnodes", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> all_dnodes", "obtain p where \"path s p u\" \"sum_list p < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path s p u; sum_list p < \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule obtain_shortest_path[of s u])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>path s p u; sum_list p < \\<infinity>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        path s p u; \\<delta> s u = sum_list p\\<rbrakk>\n       \\<Longrightarrow> thesis", "using \\<open>\\<delta> s u < \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  \\<delta> s u < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>path s p u; sum_list p < \\<infinity>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        path s p u; \\<delta> s u = sum_list p\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  path s p u\n  sum_list p < \\<infinity>\n\ngoal (1 subgoal):\n 1. u \\<in> all_dnodes", "with \\<open>u\\<notin>S\\<close>"], ["proof (chain)\npicking this:\n  u \\<notin> S\n  path s p u\n  sum_list p < \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<notin> S\n  path s p u\n  sum_list p < \\<infinity>\n\ngoal (1 subgoal):\n 1. u \\<in> all_dnodes", "apply (cases p rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u \\<notin> S; path s p u; sum_list p < \\<infinity>;\n     p = []\\<rbrakk>\n    \\<Longrightarrow> u \\<in> all_dnodes\n 2. \\<And>ys y.\n       \\<lbrakk>u \\<notin> S; path s p u; sum_list p < \\<infinity>;\n        p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> u \\<in> all_dnodes", "by (auto simp: Dijkstra.all_dnodes_def)"], ["proof (state)\nthis:\n  u \\<in> all_dnodes\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<in> all_dnodes\n\ngoal (1 subgoal):\n 1. unfinished_dnodes (insert u S) \\<subset> unfinished_dnodes S", "text \\<open>Which implies the proposition\\<close>"], ["proof (state)\nthis:\n  u \\<in> all_dnodes\n\ngoal (1 subgoal):\n 1. unfinished_dnodes (insert u S) \\<subset> unfinished_dnodes S", "with \\<open>u\\<notin>S\\<close>"], ["proof (chain)\npicking this:\n  u \\<notin> S\n  u \\<in> all_dnodes", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<notin> S\n  u \\<in> all_dnodes\n\ngoal (1 subgoal):\n 1. unfinished_dnodes (insert u S) \\<subset> unfinished_dnodes S", "by (auto simp: unfinished_dnodes_def)"], ["proof (state)\nthis:\n  unfinished_dnodes (insert u S) \\<subset> unfinished_dnodes S\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Refinement by Priority Map and Map\\<close>"], ["", "text \\<open>\n  In a second step, we implement \\<open>D\\<close> and \\<open>S\\<close> by a priority map \\<open>Q\\<close> and a map \\<open>V\\<close>.\n  Both map nodes to finite weights, where \\<open>Q\\<close> maps unfinished nodes, and \\<open>V\\<close> \n  maps finished nodes.\n\n  Note that this implementation is slightly non-standard: \n  In the standard implementation, \\<open>Q\\<close> contains also unfinished nodes with \n  infinite weight.\n  \n  We chose this implementation because it avoids enumerating all nodes of \n  the graph upon initialization of \\<open>Q\\<close>.\n  However, on relaxing an edge to a node not in \\<open>Q\\<close>, we require an extra \n  lookup to check whether the node is finished. \n\\<close>"], ["", "subsubsection \\<open>Implementing \\<open>enat\\<close> by Option\\<close>"], ["", "text \\<open>Our maps are functions to \\<open>nat option\\<close>,which are interpreted as \\<open>enat\\<close>,\n  \\<open>None\\<close> being \\<open>\\<infinity>\\<close>\\<close>"], ["", "fun enat_of_option :: \"nat option \\<Rightarrow> enat\" where\n  \"enat_of_option None = \\<infinity>\" \n| \"enat_of_option (Some n) = enat n\""], ["", "lemma enat_of_option_inj[simp]: \"enat_of_option x = enat_of_option y \\<longleftrightarrow> x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Dijkstra_Abstract.enat_of_option x =\n     Dijkstra_Abstract.enat_of_option y) =\n    (x = y)", "by (cases x; cases y; simp)"], ["", "lemma enat_of_option_simps[simp]:\n  \"enat_of_option x = enat n \\<longleftrightarrow> x = Some n\"\n  \"enat_of_option x = \\<infinity> \\<longleftrightarrow> x = None\"\n  \"enat n = enat_of_option x \\<longleftrightarrow> x = Some n\"\n  \"\\<infinity> = enat_of_option x \\<longleftrightarrow> x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Dijkstra_Abstract.enat_of_option x = enat n) = (x = Some n) &&&\n     (Dijkstra_Abstract.enat_of_option x = \\<infinity>) = (x = None)) &&&\n    (enat n = Dijkstra_Abstract.enat_of_option x) = (x = Some n) &&&\n    (\\<infinity> = Dijkstra_Abstract.enat_of_option x) = (x = None)", "by (cases x; auto; fail)+"], ["", "lemma enat_of_option_le_conv: \n  \"enat_of_option m \\<le> enat_of_option n \\<longleftrightarrow> (case (m,n) of \n      (_,None) \\<Rightarrow> True\n    | (Some a, Some b) \\<Rightarrow> a\\<le>b\n    | (_, _) \\<Rightarrow> False\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Dijkstra_Abstract.enat_of_option m\n     \\<le> Dijkstra_Abstract.enat_of_option n) =\n    (case (m, n) of (None, None) \\<Rightarrow> True\n     | (None, Some aa) \\<Rightarrow> False\n     | (Some aa, None) \\<Rightarrow> True\n     | (Some aa, Some b) \\<Rightarrow> aa \\<le> b)", "by (auto split: option.split)"], ["", "subsubsection \\<open>Implementing \\<open>D,S\\<close> by Priority Map and Map\\<close>"], ["", "context Dijkstra begin"], ["", "text \\<open>We define a coupling relation, that connects the concrete with the \n  abstract data. \\<close>"], ["", "definition \"coupling Q V D S \\<equiv> \n  D = enat_of_option o (V ++ Q)\n\\<and> S = dom V\n\\<and> dom V \\<inter> dom Q = {}\""], ["", "text \\<open>Note that our coupling relation is functional.\\<close>"], ["", "(* TODO: Why not use functions instead? *)"], ["", "lemma coupling_fun: \"coupling Q V D S \\<Longrightarrow> coupling Q V D' S' \\<Longrightarrow> D'=D \\<and> S'=S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coupling Q V D S; coupling Q V D' S'\\<rbrakk>\n    \\<Longrightarrow> D' = D \\<and> S' = S", "by (auto simp: coupling_def)"], ["", "text \\<open>The concrete version of the invariant.\\<close>"], ["", "definition \"D_invar' Q V \\<equiv>\n  \\<exists>D S. coupling Q V D S \\<and> D_invar D S\""], ["", "text \\<open>Refinement of \\<open>relax-outgoing\\<close>\\<close>"], ["", "definition \"relax_outgoing' u du V Q v \\<equiv> \n  case w (u,v) of\n    \\<infinity> \\<Rightarrow> Q v\n  | enat d \\<Rightarrow> (case Q v of\n      None \\<Rightarrow> if v\\<in>dom V then None else Some (du+d)\n    | Some d' \\<Rightarrow> Some (min d' (du+d)))\n\""], ["", "text \\<open>A step preserves the coupling relation.\\<close>"], ["", "lemma (in Dijkstra_Invar) coupling_step:\n  assumes C: \"coupling Q V D S\"\n  assumes UNS: \"u\\<notin>S\"\n  assumes UNI: \"D u = enat du\"\n  \n  shows \"coupling \n    ((relax_outgoing' u du V Q)(u:=None)) (V(u\\<mapsto>du)) \n    (relax_outgoing u D) (Set.insert u S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coupling ((relax_outgoing' u du V Q)(u := None)) (V(u \\<mapsto> du))\n     (relax_outgoing u D) (insert u S)", "using C"], ["proof (prove)\nusing this:\n  coupling Q V D S\n\ngoal (1 subgoal):\n 1. coupling ((relax_outgoing' u du V Q)(u := None)) (V(u \\<mapsto> du))\n     (relax_outgoing u D) (insert u S)", "unfolding coupling_def"], ["proof (prove)\nusing this:\n  D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q \\<and>\n  S = dom V \\<and> dom V \\<inter> dom Q = {}\n\ngoal (1 subgoal):\n 1. relax_outgoing u D =\n    Dijkstra_Abstract.enat_of_option \\<circ>\n    V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None) \\<and>\n    insert u S = dom (V(u \\<mapsto> du)) \\<and>\n    dom (V(u \\<mapsto> du)) \\<inter>\n    dom ((relax_outgoing' u du V Q)(u := None)) =\n    {}", "proof (intro ext conjI; elim conjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q;\n        D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q; S = dom V;\n        dom V \\<inter> dom Q = {}; S = dom V;\n        dom V \\<inter> dom Q = {}\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D x =\n                         (Dijkstra_Abstract.enat_of_option \\<circ>\n                          V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)\n                          (u := None))\n                          x\n 2. \\<lbrakk>D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q;\n     D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q; S = dom V;\n     dom V \\<inter> dom Q = {}; S = dom V;\n     dom V \\<inter> dom Q = {}\\<rbrakk>\n    \\<Longrightarrow> insert u S = dom (V(u \\<mapsto> du))\n 3. \\<lbrakk>D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q;\n     D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q; S = dom V;\n     dom V \\<inter> dom Q = {}; S = dom V;\n     dom V \\<inter> dom Q = {}\\<rbrakk>\n    \\<Longrightarrow> dom (V(u \\<mapsto> du)) \\<inter>\n                      dom ((relax_outgoing' u du V Q)(u := None)) =\n                      {}", "assume \\<alpha>: \"D = enat_of_option \\<circ> V ++ Q\" \"S = dom V\" \n     and DD: \"dom V \\<inter> dom Q = {}\""], ["proof (state)\nthis:\n  D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q\n  S = dom V\n  dom V \\<inter> dom Q = {}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q;\n        D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q; S = dom V;\n        dom V \\<inter> dom Q = {}; S = dom V;\n        dom V \\<inter> dom Q = {}\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D x =\n                         (Dijkstra_Abstract.enat_of_option \\<circ>\n                          V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)\n                          (u := None))\n                          x\n 2. \\<lbrakk>D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q;\n     D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q; S = dom V;\n     dom V \\<inter> dom Q = {}; S = dom V;\n     dom V \\<inter> dom Q = {}\\<rbrakk>\n    \\<Longrightarrow> insert u S = dom (V(u \\<mapsto> du))\n 3. \\<lbrakk>D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q;\n     D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q; S = dom V;\n     dom V \\<inter> dom Q = {}; S = dom V;\n     dom V \\<inter> dom Q = {}\\<rbrakk>\n    \\<Longrightarrow> dom (V(u \\<mapsto> du)) \\<inter>\n                      dom ((relax_outgoing' u du V Q)(u := None)) =\n                      {}", "show \"Set.insert u S = dom (V(u \\<mapsto> du))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert u S = dom (V(u \\<mapsto> du))", "by (auto simp: \\<alpha>)"], ["proof (state)\nthis:\n  insert u S = dom (V(u \\<mapsto> du))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q;\n        D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q; S = dom V;\n        dom V \\<inter> dom Q = {}; S = dom V;\n        dom V \\<inter> dom Q = {}\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D x =\n                         (Dijkstra_Abstract.enat_of_option \\<circ>\n                          V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)\n                          (u := None))\n                          x\n 2. \\<lbrakk>D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q;\n     D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q; S = dom V;\n     dom V \\<inter> dom Q = {}; S = dom V;\n     dom V \\<inter> dom Q = {}\\<rbrakk>\n    \\<Longrightarrow> dom (V(u \\<mapsto> du)) \\<inter>\n                      dom ((relax_outgoing' u du V Q)(u := None)) =\n                      {}", "have [simp]: \"Q u = Some du\" \"V u = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q u = Some du &&& V u = None", "using DD UNI UNS"], ["proof (prove)\nusing this:\n  dom V \\<inter> dom Q = {}\n  D u = enat du\n  u \\<notin> S\n\ngoal (1 subgoal):\n 1. Q u = Some du &&& V u = None", "by (auto simp: \\<alpha>)"], ["proof (state)\nthis:\n  Q u = Some du\n  V u = None\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q;\n        D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q; S = dom V;\n        dom V \\<inter> dom Q = {}; S = dom V;\n        dom V \\<inter> dom Q = {}\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D x =\n                         (Dijkstra_Abstract.enat_of_option \\<circ>\n                          V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)\n                          (u := None))\n                          x\n 2. \\<lbrakk>D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q;\n     D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q; S = dom V;\n     dom V \\<inter> dom Q = {}; S = dom V;\n     dom V \\<inter> dom Q = {}\\<rbrakk>\n    \\<Longrightarrow> dom (V(u \\<mapsto> du)) \\<inter>\n                      dom ((relax_outgoing' u du V Q)(u := None)) =\n                      {}", "from DD"], ["proof (chain)\npicking this:\n  dom V \\<inter> dom Q = {}", "show \"dom (V(u \\<mapsto> du)) \\<inter> dom ((relax_outgoing' u du V Q)(u := None)) = {}\""], ["proof (prove)\nusing this:\n  dom V \\<inter> dom Q = {}\n\ngoal (1 subgoal):\n 1. dom (V(u \\<mapsto> du)) \\<inter>\n    dom ((relax_outgoing' u du V Q)(u := None)) =\n    {}", "by (auto 0 3 \n          simp: relax_outgoing'_def dom_def \n          split: if_splits enat.splits option.splits)"], ["proof (state)\nthis:\n  dom (V(u \\<mapsto> du)) \\<inter>\n  dom ((relax_outgoing' u du V Q)(u := None)) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q;\n        D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q; S = dom V;\n        dom V \\<inter> dom Q = {}; S = dom V;\n        dom V \\<inter> dom Q = {}\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D x =\n                         (Dijkstra_Abstract.enat_of_option \\<circ>\n                          V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)\n                          (u := None))\n                          x", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q;\n        D = Dijkstra_Abstract.enat_of_option \\<circ> V ++ Q; S = dom V;\n        dom V \\<inter> dom Q = {}; S = dom V;\n        dom V \\<inter> dom Q = {}\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing u D x =\n                         (Dijkstra_Abstract.enat_of_option \\<circ>\n                          V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)\n                          (u := None))\n                          x", "show \"relax_outgoing u D v \n    = (enat_of_option \\<circ> V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None)) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relax_outgoing u D v =\n    (Dijkstra_Abstract.enat_of_option \\<circ>\n     V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n     v", "proof (cases \"v\\<in>S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> S \\<Longrightarrow>\n    relax_outgoing u D v =\n    (Dijkstra_Abstract.enat_of_option \\<circ>\n     V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n     v\n 2. v \\<notin> S \\<Longrightarrow>\n    relax_outgoing u D v =\n    (Dijkstra_Abstract.enat_of_option \\<circ>\n     V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n     v", "case True"], ["proof (state)\nthis:\n  v \\<in> S\n\ngoal (2 subgoals):\n 1. v \\<in> S \\<Longrightarrow>\n    relax_outgoing u D v =\n    (Dijkstra_Abstract.enat_of_option \\<circ>\n     V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n     v\n 2. v \\<notin> S \\<Longrightarrow>\n    relax_outgoing u D v =\n    (Dijkstra_Abstract.enat_of_option \\<circ>\n     V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n     v", "then"], ["proof (chain)\npicking this:\n  v \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> S\n\ngoal (1 subgoal):\n 1. relax_outgoing u D v =\n    (Dijkstra_Abstract.enat_of_option \\<circ>\n     V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n     v", "using DD"], ["proof (prove)\nusing this:\n  v \\<in> S\n  dom V \\<inter> dom Q = {}\n\ngoal (1 subgoal):\n 1. relax_outgoing u D v =\n    (Dijkstra_Abstract.enat_of_option \\<circ>\n     V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n     v", "apply (simp add: relax_finished_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> S; dom V \\<inter> dom Q = {}\\<rbrakk>\n    \\<Longrightarrow> D v =\n                      Dijkstra_Abstract.enat_of_option\n                       ((V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)\n                         (u := None))\n                         v)", "by (auto \n        simp: relax_outgoing'_def map_add_apply \\<alpha> min_def\n        split: option.splits enat.splits)"], ["proof (state)\nthis:\n  relax_outgoing u D v =\n  (Dijkstra_Abstract.enat_of_option \\<circ>\n   V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n   v\n\ngoal (1 subgoal):\n 1. v \\<notin> S \\<Longrightarrow>\n    relax_outgoing u D v =\n    (Dijkstra_Abstract.enat_of_option \\<circ>\n     V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n     v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> S \\<Longrightarrow>\n    relax_outgoing u D v =\n    (Dijkstra_Abstract.enat_of_option \\<circ>\n     V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n     v", "case False"], ["proof (state)\nthis:\n  v \\<notin> S\n\ngoal (1 subgoal):\n 1. v \\<notin> S \\<Longrightarrow>\n    relax_outgoing u D v =\n    (Dijkstra_Abstract.enat_of_option \\<circ>\n     V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n     v", "then"], ["proof (chain)\npicking this:\n  v \\<notin> S", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> S\n\ngoal (1 subgoal):\n 1. relax_outgoing u D v =\n    (Dijkstra_Abstract.enat_of_option \\<circ>\n     V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n     v", "by (auto \n        simp: relax_outgoing_def relax_outgoing'_def map_add_apply \\<alpha> min_def\n        split: option.splits enat.splits)"], ["proof (state)\nthis:\n  relax_outgoing u D v =\n  (Dijkstra_Abstract.enat_of_option \\<circ>\n   V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n   v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  relax_outgoing u D v =\n  (Dijkstra_Abstract.enat_of_option \\<circ>\n   V(u \\<mapsto> du) ++ (relax_outgoing' u du V Q)(u := None))\n   v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Refinement of initial state\\<close>"], ["", "definition \"initQ \\<equiv> Map.empty(s\\<mapsto>0)\""], ["", "definition \"initV \\<equiv> Map.empty\""], ["", "lemma coupling_init:\n  \"coupling initQ initV initD initS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coupling initQ initV initD initS", "unfolding coupling_def initD_def initQ_def initS_def initV_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. \\<infinity>)(s := 0) =\n    Dijkstra_Abstract.enat_of_option \\<circ>\n    Map.empty ++ [s \\<mapsto> 0] \\<and>\n    {} = dom Map.empty \\<and>\n    dom Map.empty \\<inter> dom [s \\<mapsto> 0] = {}", "by (auto \n    simp: coupling_def relax_outgoing_def map_add_apply enat_0 \n    split: option.split enat.split\n    del: ext intro!: ext)"], ["", "lemma coupling_cond:\n  assumes \"coupling Q V D S\"\n  shows \"(Q = Map.empty) \\<longleftrightarrow> (\\<forall>u. u\\<notin>S \\<longrightarrow> D u = \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q = Map.empty) =\n    (\\<forall>u. u \\<notin> S \\<longrightarrow> D u = \\<infinity>)", "using assms"], ["proof (prove)\nusing this:\n  coupling Q V D S\n\ngoal (1 subgoal):\n 1. (Q = Map.empty) =\n    (\\<forall>u. u \\<notin> S \\<longrightarrow> D u = \\<infinity>)", "by (fastforce simp add: coupling_def)"], ["", "text \\<open>Termination argument: Refinement of unfinished nodes.\\<close>"], ["", "definition \"unfinished_dnodes' V \\<equiv> unfinished_dnodes (dom V)\""], ["", "lemma coupling_unfinished: \n  \"coupling Q V D S \\<Longrightarrow> unfinished_dnodes' V = unfinished_dnodes S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coupling Q V D S \\<Longrightarrow>\n    unfinished_dnodes' V = unfinished_dnodes S", "by (auto simp: coupling_def unfinished_dnodes'_def unfinished_dnodes_def)"], ["", "subsubsection \\<open>Implementing graph by successor list\\<close>"], ["", "definition \"relax_outgoing'' l du V Q = fold (\\<lambda>(d,v) Q.\n  case Q v of None \\<Rightarrow> if v\\<in>dom V then Q else Q(v\\<mapsto>du+d)\n            | Some d' \\<Rightarrow> Q(v\\<mapsto>min (du+d) d')) l Q\""], ["", "lemma relax_outgoing''_refine:\n  assumes \"set l = {(d,v). w (u,v) = enat d}\"  \n  shows \"relax_outgoing'' l du V Q = relax_outgoing' u du V Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relax_outgoing'' l du V Q = relax_outgoing' u du V Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. relax_outgoing'' l du V Q x = relax_outgoing' u du V Q x", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. relax_outgoing'' l du V Q x = relax_outgoing' u du V Q x", "have aux1:\n     \"relax_outgoing'' l du V Q v \n     = (if v\\<in>snd`set l then relax_outgoing' u du V Q v else Q v)\"\n  if \"set l \\<subseteq> {(d,v). w (u,v) = enat d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relax_outgoing'' l du V Q v =\n    (if v \\<in> snd ` set l then relax_outgoing' u du V Q v else Q v)", "using that"], ["proof (prove)\nusing this:\n  set l \\<subseteq> {(d, v). w (u, v) = enat d}\n\ngoal (1 subgoal):\n 1. relax_outgoing'' l du V Q v =\n    (if v \\<in> snd ` set l then relax_outgoing' u du V Q v else Q v)", "apply (induction l arbitrary: Q v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Q v.\n       set [] \\<subseteq> {(d, v). w (u, v) = enat d} \\<Longrightarrow>\n       relax_outgoing'' [] du V Q v =\n       (if v \\<in> snd ` set [] then relax_outgoing' u du V Q v else Q v)\n 2. \\<And>a l Q v.\n       \\<lbrakk>\\<And>Q v.\n                   set l\n                   \\<subseteq> {(d, v). w (u, v) = enat d} \\<Longrightarrow>\n                   relax_outgoing'' l du V Q v =\n                   (if v \\<in> snd ` set l then relax_outgoing' u du V Q v\n                    else Q v);\n        set (a # l) \\<subseteq> {(d, v). w (u, v) = enat d}\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing'' (a # l) du V Q v =\n                         (if v \\<in> snd ` set (a # l)\n                          then relax_outgoing' u du V Q v else Q v)", "by (auto \n      simp: relax_outgoing''_def relax_outgoing'_def image_iff\n      split!: if_splits option.splits)"], ["proof (state)\nthis:\n  set l \\<subseteq> {(d, v). w (u, v) = enat d} \\<Longrightarrow>\n  relax_outgoing'' l du V Q v =\n  (if v \\<in> snd ` set l then relax_outgoing' u du V Q v else Q v)\n\ngoal (1 subgoal):\n 1. \\<And>x. relax_outgoing'' l du V Q x = relax_outgoing' u du V Q x", "have aux2:  \n    \"relax_outgoing' u du V Q v = Q v\" if \"w (u,v) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relax_outgoing' u du V Q v = Q v", "using that"], ["proof (prove)\nusing this:\n  w (u, v) = \\<infinity>\n\ngoal (1 subgoal):\n 1. relax_outgoing' u du V Q v = Q v", "by (auto simp: relax_outgoing'_def)"], ["proof (state)\nthis:\n  w (u, v) = \\<infinity> \\<Longrightarrow> relax_outgoing' u du V Q v = Q v\n\ngoal (1 subgoal):\n 1. \\<And>x. relax_outgoing'' l du V Q x = relax_outgoing' u du V Q x", "show \"relax_outgoing'' l du V Q v = relax_outgoing' u du V Q v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relax_outgoing'' l du V Q v = relax_outgoing' u du V Q v", "using aux1"], ["proof (prove)\nusing this:\n  set l \\<subseteq> {(d, v). w (u, v) = enat d} \\<Longrightarrow>\n  relax_outgoing'' l du V Q v =\n  (if v \\<in> snd ` set l then relax_outgoing' u du V Q v else Q v)\n\ngoal (1 subgoal):\n 1. relax_outgoing'' l du V Q v = relax_outgoing' u du V Q v", "apply (cases \"w (u,v)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>set l\n                \\<subseteq> {(d, v). w (u, v) = enat d} \\<Longrightarrow>\n                relax_outgoing'' l du V Q v =\n                (if v \\<in> snd ` set l then relax_outgoing' u du V Q v\n                 else Q v);\n        w (u, v) = enat nat\\<rbrakk>\n       \\<Longrightarrow> relax_outgoing'' l du V Q v =\n                         relax_outgoing' u du V Q v\n 2. \\<lbrakk>set l \\<subseteq> {(d, v). w (u, v) = enat d} \\<Longrightarrow>\n             relax_outgoing'' l du V Q v =\n             (if v \\<in> snd ` set l then relax_outgoing' u du V Q v\n              else Q v);\n     w (u, v) = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> relax_outgoing'' l du V Q v =\n                      relax_outgoing' u du V Q v", "by (all \\<open>force simp: aux2 assms\\<close>)"], ["proof (state)\nthis:\n  relax_outgoing'' l du V Q v = relax_outgoing' u du V Q v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}