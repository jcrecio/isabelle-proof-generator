{"file_name": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple/Undirected_Graph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple", "problem_names": ["lemma edges_subset: \"edges g \\<subseteq> nodes g \\<times> nodes g\"", "lemma nodes_finite[simp, intro!]: \"finite (nodes g)\"", "lemma edges_sym: \"sym (edges g)\"", "lemma edges_irrefl: \"irrefl (edges g)\"", "lemma nodes_graph: \"\\<lbrakk>finite V; finite E\\<rbrakk> \\<Longrightarrow> nodes (graph V E) = V\\<union>fst`E\\<union>snd`E\"", "lemma edges_graph: \"\\<lbrakk>finite V; finite E\\<rbrakk> \\<Longrightarrow> edges (graph V E) = (E\\<union>E\\<inverse>)-Id\"", "lemmas graph_accs = nodes_graph edges_graph", "lemma nodes_edges_graph_presentation: \"\\<lbrakk>finite V; finite E\\<rbrakk> \n    \\<Longrightarrow> nodes (graph V E) = V \\<union> fst`E \\<union> snd`E \\<and> edges (graph V E) = E\\<union>E\\<inverse> - Id\"", "lemma graph_eq[simp]: \"graph (nodes g) (edges g) = g\"", "lemma edges_finite[simp, intro!]: \"finite (edges g)\"", "lemma graph_cases[cases type]: obtains V E \n  where \"g = graph V E\" \"finite V\" \"finite E\" \"E\\<subseteq>V\\<times>V\" \"sym E\" \"irrefl E\"", "lemma graph_eq_iff: \"g=g' \\<longleftrightarrow> nodes g = nodes g' \\<and> edges g = edges g'\"", "lemma edges_sym': \"(u,v)\\<in>edges g \\<Longrightarrow> (v,u)\\<in>edges g\"", "lemma edges_irrefl'[simp,intro!]: \"(u,u)\\<notin>edges g\"", "lemma edges_irreflI[simp, intro]: \"(u,v)\\<in>edges g \\<Longrightarrow> u\\<noteq>v\"", "lemma edgesT_diff_sng_inv_eq[simp]: \n  \"(edges T - {(x, y), (y, x)})\\<inverse> = edges T - {(x, y), (y, x)}\"", "lemma nodesI[simp,intro]: assumes \"(u,v)\\<in>edges g\" shows \"u\\<in>nodes g\" \"v\\<in>nodes g\"", "lemma split_edges_sym: \"\\<exists>E. E\\<inter>E\\<inverse> = {} \\<and> edges g = E \\<union> E\\<inverse>\"", "lemma rtrancl_edges_sym': \"(u,v)\\<in>(edges g)\\<^sup>* \\<Longrightarrow> (v,u)\\<in>(edges g)\\<^sup>*\"", "lemma trancl_edges_subset: \"(edges g)\\<^sup>+ \\<subseteq> nodes g \\<times> nodes g\"", "lemma find_crossing_edge:\n  assumes \"(u,v)\\<in>E\\<^sup>*\" \"u\\<in>V\" \"v\\<notin>V\"\n  obtains u' v' where \"(u',v')\\<in>E\\<inter>V\\<times>-V\"", "lemma [simp]:\n  assumes \"nodes_edges_consistent V E\"\n  shows nodes_graph': \"nodes (graph V E) = V\" (is ?G1)\n    and edges_graph': \"edges (graph V E) = E\" (is ?G2)", "lemma nec_empty[simp]: \"nodes_edges_consistent {} {}\"", "lemma graph_empty_accs[simp]:\n  \"nodes graph_empty = {}\"\n  \"edges graph_empty = {}\"", "lemma graph_empty[simp]: \"graph {} {} = graph_empty\"", "lemma nodes_empty_iff_empty[simp]: \n  \"nodes G = {} \\<longleftrightarrow> G=graph {} {}\"\n  \"{} = nodes G \\<longleftrightarrow> G=graph_empty\"", "lemma nodes_ins_nodes[simp]: \"nodes (ins_node v g) = insert v (nodes g)\"         \n  and edges_ins_nodes[simp]: \"edges (ins_node v g) = edges g\"", "lemma nodes_ins_edge[simp]: \"nodes (ins_edge e g) = {fst e, snd e} \\<union> nodes g\"\n  and edges_ins_edge: \n    \"edges (ins_edge e g) \n      = (if fst e = snd e then edges g else {e,prod.swap e}\\<union>(edges g))\"", "lemma edges_ins_edge'[simp]: \n  \"u\\<noteq>v \\<Longrightarrow> edges (ins_edge (u,v) g) = {(u,v),(v,u)} \\<union> edges g\"", "lemma edges_ins_edge_ss: \"edges g \\<subseteq> edges (ins_edge e g)\"", "lemma nodes_join[simp]: \"nodes (graph_join g\\<^sub>1 g\\<^sub>2) = nodes g\\<^sub>1 \\<union> nodes g\\<^sub>2\"  \n  and edges_join[simp]: \"edges (graph_join g\\<^sub>1 g\\<^sub>2) = edges g\\<^sub>1 \\<union> edges g\\<^sub>2\"", "lemma nodes_restrict_nodes[simp]: \"nodes (restrict_nodes g V) = nodes g \\<inter> V\"  \n  and edges_restrict_nodes[simp]: \"edges (restrict_nodes g V) = edges g \\<inter> V\\<times>V\"", "lemma nodes_restrict_edges[simp]: \"nodes (restrict_edges g E) = nodes g\"\n  and edges_restrict_edges[simp]: \"edges (restrict_edges g E) = edges g \\<inter> (E\\<union>E\\<inverse>)\"", "lemma unrestricte_edges: \"edges (restrict_edges g E) \\<subseteq> edges g\"", "lemma unrestrictn_edges: \"edges (restrict_nodes g V) \\<subseteq> edges g\"", "lemma unrestrict_nodes: \"nodes (restrict_edges g E) \\<subseteq> nodes g\"", "lemma path_emptyI[intro!]: \"path g u [] u\"", "lemma path_append[simp]: \n  \"path g u (p1@p2) w \\<longleftrightarrow> (\\<exists>v. path g u p1 v \\<and> path g v p2 w)\"", "lemma path_transs1[trans]:\n  \"path g u p v \\<Longrightarrow> (v,w)\\<in>edges g \\<Longrightarrow> path g u (p@[(v,w)]) w\"  \n  \"(u,v)\\<in>edges g \\<Longrightarrow> path g v p w \\<Longrightarrow> path g u ((u,v)#p) w\"\n  \"path g u p1 v \\<Longrightarrow> path g v p2 w \\<Longrightarrow> path g u (p1@p2) w\"", "lemma path_graph_empty[simp]: \"path graph_empty u p v \\<longleftrightarrow> v=u \\<and> p=[]\"", "lemma revp_alt: \"revp p = rev (map (\\<lambda>(u,v). (v,u)) p)\"", "lemma path_rev[simp]: \"path g u (revp p) v \\<longleftrightarrow> path g v p u\"", "lemma path_rev_sym[sym]: \"path g v p u \\<Longrightarrow> path g u (revp p) v\"", "lemma path_transs2[trans]: \n  \"path g u p v \\<Longrightarrow> (w,v)\\<in>edges g \\<Longrightarrow> path g u (p@[(v,w)]) w\"  \n  \"(v,u)\\<in>edges g \\<Longrightarrow> path g v p w \\<Longrightarrow> path g u ((u,v)#p) w\"\n  \"path g u p1 v \\<Longrightarrow> path g w p2 v \\<Longrightarrow> path g u (p1@revp p2) w\"", "lemma path_edges: \"path g u p v \\<Longrightarrow> set p \\<subseteq> edges g\"", "lemma path_graph_cong: \n  \"\\<lbrakk>path g\\<^sub>1 u p v; set p \\<subseteq> edges g\\<^sub>1 \\<Longrightarrow> set p \\<subseteq> edges g\\<^sub>2\\<rbrakk> \\<Longrightarrow> path g\\<^sub>2 u p v\"", "lemma path_endpoints: \n  assumes \"path g u p v\" \"p\\<noteq>[]\" shows \"u\\<in>nodes g\" \"v\\<in>nodes g\"", "lemma path_mono: \"edges g \\<subseteq> edges g' \\<Longrightarrow> path g u p v \\<Longrightarrow> path g' u p v\"", "lemmas unrestricte_path = path_mono[OF unrestricte_edges]", "lemmas unrestrictn_path = path_mono[OF unrestrictn_edges]", "lemma unrestrict_path_edges: \"path (restrict_edges g E) u p v \\<Longrightarrow> path g u p v\"", "lemma unrestrict_path_nodes: \"path (restrict_nodes g E) u p v \\<Longrightarrow> path g u p v\"", "lemma rtrancl_edges_iff_path: \"(u,v)\\<in>(edges g)\\<^sup>* \\<longleftrightarrow> (\\<exists>p. path g u p v)\"", "lemma rtrancl_edges_pathE: \n  assumes \"(u,v)\\<in>(edges g)\\<^sup>*\" obtains p where \"path g u p v\"", "lemma path_rtrancl_edgesD: \"path g u p v \\<Longrightarrow> (u,v)\\<in>(edges g)\\<^sup>*\"", "lemma in_uedge_conv[simp]: \"x\\<in>uedge (u,v) \\<longleftrightarrow> x=u \\<or> x=v\"", "lemma uedge_eq_iff: \"uedge (a,b) = uedge (c,d) \\<longleftrightarrow> a=c \\<and> b=d \\<or> a=d \\<and> b=c\"", "lemma uedge_degen[simp]: \"uedge (a,a) = {a}\"", "lemma uedge_in_set_eq: \"uedge (u, v) \\<in> uedge ` S \\<longleftrightarrow> (u,v)\\<in>S \\<or> (v,u)\\<in>S\"", "lemma uedge_commute: \"uedge (a,b) = uedge (b,a)\"", "lemma simple_empty[simp]: \"simple []\"", "lemma simple_cons[simp]: \"simple (e#p) \\<longleftrightarrow> uedge e \\<notin> uedge ` set p \\<and> simple p\"", "lemma simple_append[simp]: \"simple (p\\<^sub>1@p\\<^sub>2) \n  \\<longleftrightarrow> simple p\\<^sub>1 \\<and> simple p\\<^sub>2 \\<and> uedge ` set p\\<^sub>1 \\<inter> uedge ` set p\\<^sub>2 = {}\"", "lemma simplify_pathD:\n  \"path g u p v \\<Longrightarrow> \\<exists>p'. path g u p' v \\<and> simple p' \\<and> set p' \\<subseteq> set p\"", "lemma simplify_pathE: \n  assumes \"path g u p v\" \n  obtains p' where \"path g u p' v\" \"simple p'\" \"set p' \\<subseteq> set p\"", "lemma find_crossing_edge_on_path:\n  assumes \"path g u p v\" \"\\<not>P u\" \"P v\"\n  obtains u' v' where \"(u',v')\\<in>set p\" \"\\<not>P u'\" \"P v'\"", "lemma find_crossing_edges_on_path:  \n  assumes P: \"path g u p v\" and \"P u\" \"P v\"\n  obtains \"\\<forall>(u,v)\\<in>set p. P u \\<and> P v\"\n        | u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2 p\\<^sub>3 \n          where \"p=p\\<^sub>1@[(u\\<^sub>1,v\\<^sub>1)]@p\\<^sub>2@[(u\\<^sub>2,v\\<^sub>2)]@p\\<^sub>3\" \"P u\\<^sub>1\" \"\\<not>P v\\<^sub>1\" \"\\<not>P u\\<^sub>2\" \"P v\\<^sub>2\"", "lemma find_crossing_edge_rtrancl:\n  assumes \"(u,v)\\<in>(edges g)\\<^sup>*\" \"\\<not>P u\" \"P v\"\n  obtains u' v' where \"(u',v')\\<in>edges g\" \"\\<not>P u'\" \"P v'\"", "lemma path_change: \n  assumes \"u\\<in>S\" \"v\\<notin>S\" \"path g u p v\" \"simple p\"\n  obtains x y p1 p2 where \n    \"(x,y) \\<in> set p\" \"x \\<in> S\" \"y \\<notin> S\"\n    \"path (restrict_edges g (-{(x,y),(y,x)})) u p1 x\" \n    \"path (restrict_edges g (-{(x,y),(y,x)})) y p2 v\"", "lemma cycle_free_alt_in_nodes: \n  \"cycle_free g \\<equiv> \\<nexists>p u. p\\<noteq>[] \\<and> u\\<in>nodes g \\<and> simple p \\<and> path g u p u\"", "lemma cycle_freeI:\n  assumes \"\\<And>p u. \\<lbrakk> path g u p u; p\\<noteq>[]; simple p \\<rbrakk> \\<Longrightarrow> False\"\n  shows \"cycle_free g\"", "lemma cycle_freeD:\n  assumes \"cycle_free g\" \"path g u p u\" \"p\\<noteq>[]\" \"simple p\" \n  shows False", "lemma cycle_free_antimono: \"edges g \\<subseteq> edges g' \\<Longrightarrow> cycle_free g' \\<Longrightarrow> cycle_free g\"", "lemma cycle_free_empty[simp]: \"cycle_free graph_empty\"", "lemma cycle_free_no_edges: \"edges g = {} \\<Longrightarrow> cycle_free g\"", "lemma simple_path_cycle_free_unique:\n  assumes CF: \"cycle_free g\" \n  assumes P: \"path g u p v\" \"path g u p' v\" \"simple p\" \"simple p'\"\n  shows \"p=p'\"", "lemma cycle_free_alt: \"cycle_free g \n  \\<longleftrightarrow> (\\<forall>e\\<in>edges g. e\\<notin>(edges (restrict_edges g (-{e,prod.swap e})))\\<^sup>*)\"", "lemma cycle_free_altI:\n  assumes \"\\<And>u v. \\<lbrakk> (u,v)\\<in>edges g; (u,v)\\<in>(edges g - {(u,v),(v,u)})\\<^sup>* \\<rbrakk> \\<Longrightarrow> False\"\n  shows \"cycle_free g\"", "lemma cycle_free_altD:  \n  assumes \"cycle_free g\"\n  assumes \"(u,v)\\<in>edges g\" \n  shows \"(u,v)\\<notin>(edges g - {(u,v),(v,u)})\\<^sup>*\"", "lemma remove_redundant_edge:\n  assumes \"(u, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\"  \n  shows \"(edges g - {(u, v), (v, u)})\\<^sup>* = (edges g)\\<^sup>*\" (is \"?E'\\<^sup>* = _\")", "lemma connectedI[intro?]: \n  assumes \"\\<And>u v. \\<lbrakk>u\\<in>nodes g; v\\<in>nodes g\\<rbrakk> \\<Longrightarrow> (u,v)\\<in>(edges g)\\<^sup>*\"  \n  shows \"connected g\"", "lemma connectedD[intro?]: \n  assumes \"connected g\" \"u\\<in>nodes g\" \"v\\<in>nodes g\"\n  shows \"(u,v)\\<in>(edges g)\\<^sup>*\"", "lemma connected_empty[simp]: \"connected graph_empty\"", "lemma reachable_nodes_refl[simp, intro!]: \"r \\<in> reachable_nodes g r\"", "lemma reachable_nodes_step: \n  \"edges g `` reachable_nodes g r \\<subseteq> reachable_nodes g r\"", "lemma reachable_nodes_steps: \n  \"(edges g)\\<^sup>* `` reachable_nodes g r \\<subseteq> reachable_nodes g r\"", "lemma reachable_nodes_step':\n  assumes \"u \\<in> reachable_nodes g r\" \"(u, v) \\<in> edges g\" \n  shows \"v\\<in>reachable_nodes g r\" \"(u, v) \\<in> edges (component_of g r)\"", "lemma reachable_nodes_steps':\n  assumes \"u \\<in> reachable_nodes g r\" \"(u, v) \\<in> (edges g)\\<^sup>*\" \n  shows \"v\\<in>reachable_nodes g r\" \"(u, v) \\<in> (edges (component_of g r))\\<^sup>*\"", "lemma reachable_not_node: \"r\\<notin>nodes g \\<Longrightarrow> reachable_nodes g r = {r}\"", "lemma nodes_of_component[simp]: \"nodes (component_of g r) = reachable_nodes g r\"", "lemma component_connected[simp, intro!]: \"connected (component_of g r)\"", "lemma component_edges_subset: \"edges (component_of g r) \\<subseteq> edges g\"", "lemma component_path: \"u\\<in>nodes (component_of g r) \\<Longrightarrow> \n  path (component_of g r) u p v \\<longleftrightarrow> path g u p v\"", "lemma component_cycle_free: \"cycle_free g \\<Longrightarrow> cycle_free (component_of g r)\"", "lemma component_of_connected_graph: \n  \"\\<lbrakk>connected g; r\\<in>nodes g\\<rbrakk> \\<Longrightarrow> component_of g r = g\"", "lemma component_of_not_node: \"r\\<notin>nodes g \\<Longrightarrow> component_of g r = graph {r} {}\"", "lemma tree_empty[simp]: \"tree graph_empty\"", "lemma component_of_tree: \"tree T \\<Longrightarrow> tree (component_of T r)\"", "lemma join_connected:\n  assumes CONN: \"connected g\\<^sub>1\" \"connected g\\<^sub>2\"\n  assumes IN_NODES: \"u\\<in>nodes g\\<^sub>1\" \"v\\<in>nodes g\\<^sub>2\"\n  shows \"connected (ins_edge (u,v) (graph_join g\\<^sub>1 g\\<^sub>2))\" (is \"connected ?g'\")", "lemma join_cycle_free:  \n  assumes CYCF: \"cycle_free g\\<^sub>1\" \"cycle_free g\\<^sub>2\"\n  assumes DJ: \"nodes g\\<^sub>1 \\<inter> nodes g\\<^sub>2 = {}\"\n  assumes IN_NODES: \"u\\<in>nodes g\\<^sub>1\" \"v\\<in>nodes g\\<^sub>2\"\n  shows \"cycle_free (ins_edge (u,v) (graph_join g\\<^sub>1 g\\<^sub>2))\" (is \"cycle_free ?g'\")", "lemma join_trees:     \n  assumes TREE: \"tree g\\<^sub>1\" \"tree g\\<^sub>2\"\n  assumes DJ: \"nodes g\\<^sub>1 \\<inter> nodes g\\<^sub>2 = {}\"\n  assumes IN_NODES: \"u\\<in>nodes g\\<^sub>1\" \"v\\<in>nodes g\\<^sub>2\"\n  shows \"tree (ins_edge (u,v) (graph_join g\\<^sub>1 g\\<^sub>2))\"", "lemma split_tree:\n  assumes \"tree T\" \"(x,y)\\<in>edges T\"\n  defines \"E' \\<equiv> (edges T - {(x,y),(y,x)})\"\n  obtains T1 T2 where \n    \"tree T1\" \"tree T2\" \n    \"nodes T1 \\<inter> nodes T2 = {}\" \"nodes T = nodes T1 \\<union> nodes T2\"\n    \"edges T1 \\<union> edges T2 = E'\"\n    \"nodes T1 = { u. (x,u)\\<in>E'\\<^sup>*}\" \"nodes T2 = { u. (y,u)\\<in>E'\\<^sup>*}\"\n    \"x\\<in>nodes T1\" \"y\\<in>nodes T2\"", "lemma connected_singleton[simp]: \"connected (ins_node u graph_empty)\"", "lemma path_singleton[simp]: \"path (ins_node u graph_empty) v p w \\<longleftrightarrow> v=w \\<and> p=[]\"", "lemma tree_singleton[simp]: \"tree (ins_node u graph_empty)\"", "lemma tree_add_edge_in_out:\n  assumes \"tree T\"\n  assumes \"u\\<in>nodes T\" \"v\\<notin>nodes T\"\n  shows \"tree (ins_edge (u,v) T)\"", "lemma ex_spanning_tree: \n  \"connected g \\<Longrightarrow> \\<exists>t. is_spanning_tree g t\"", "lemma weight_alt: \"weight w g = (\\<Sum>e\\<in>uedge`edges g. w e)\"", "lemma weight_empty[simp]: \"weight w graph_empty = 0\"", "lemma weight_ins_edge[simp]: \"\\<lbrakk>u\\<noteq>v; (u,v)\\<notin>edges g\\<rbrakk> \n  \\<Longrightarrow> weight w (ins_edge (u,v) g) = w {u,v} + weight w g\"", "lemma uedge_img_disj_iff[simp]: \n  \"uedge`edges g\\<^sub>1 \\<inter> uedge`edges g\\<^sub>2 = {} \\<longleftrightarrow> edges g\\<^sub>1 \\<inter> edges g\\<^sub>2 = {}\"", "lemma weight_join[simp]: \"edges g\\<^sub>1 \\<inter> edges g\\<^sub>2 = {} \n  \\<Longrightarrow> weight w (graph_join g\\<^sub>1 g\\<^sub>2) = weight w g\\<^sub>1 + weight w g\\<^sub>2\"", "lemma weight_cong: \"edges g\\<^sub>1 = edges g\\<^sub>2 \\<Longrightarrow> weight w g\\<^sub>1 = weight w g\\<^sub>2\"", "lemma weight_mono: \"edges g \\<subseteq> edges g' \\<Longrightarrow> weight w g \\<le> weight w g'\"", "lemma weight_ge_edge:\n  assumes \"(x,y)\\<in>edges T\"\n  shows \"weight w T \\<ge> w {x,y}\"", "lemma weight_del_edge[simp]: \n  assumes \"(x,y)\\<in>edges T\"  \n  shows \"weight w (restrict_edges T (- {(x, y), (y, x)})) = weight w T - w {x,y}\"", "lemma exists_MST: \"connected g \\<Longrightarrow> \\<exists>t. is_MST w g t\""], "translations": [["", "lemma edges_subset: \"edges g \\<subseteq> nodes g \\<times> nodes g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges g \\<subseteq> nodes g \\<times> nodes g", "unfolding edges_def nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_internal g \\<subseteq> nodes_internal g \\<times> nodes_internal g", "by transfer auto"], ["", "lemma nodes_finite[simp, intro!]: \"finite (nodes g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes g)", "unfolding edges_def nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes_internal g)", "by transfer auto"], ["", "lemma edges_sym: \"sym (edges g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (edges g)", "unfolding edges_def nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (edges_internal g)", "by transfer auto"], ["", "lemma edges_irrefl: \"irrefl (edges g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl (edges g)", "unfolding edges_def nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl (edges_internal g)", "by transfer auto"], ["", "lemma nodes_graph: \"\\<lbrakk>finite V; finite E\\<rbrakk> \\<Longrightarrow> nodes (graph V E) = V\\<union>fst`E\\<union>snd`E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; finite E\\<rbrakk>\n    \\<Longrightarrow> nodes (graph V E) =\n                      V \\<union> fst ` E \\<union> snd ` E", "unfolding edges_def nodes_def graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; finite E\\<rbrakk>\n    \\<Longrightarrow> nodes_internal (graph_internal V E) =\n                      V \\<union> fst ` E \\<union> snd ` E", "by transfer auto"], ["", "lemma edges_graph: \"\\<lbrakk>finite V; finite E\\<rbrakk> \\<Longrightarrow> edges (graph V E) = (E\\<union>E\\<inverse>)-Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; finite E\\<rbrakk>\n    \\<Longrightarrow> edges (graph V E) = E \\<union> E\\<inverse> - Id", "unfolding edges_def nodes_def graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; finite E\\<rbrakk>\n    \\<Longrightarrow> edges_internal (graph_internal V E) =\n                      E \\<union> E\\<inverse> - Id", "by transfer auto"], ["", "lemmas graph_accs = nodes_graph edges_graph"], ["", "lemma nodes_edges_graph_presentation: \"\\<lbrakk>finite V; finite E\\<rbrakk> \n    \\<Longrightarrow> nodes (graph V E) = V \\<union> fst`E \\<union> snd`E \\<and> edges (graph V E) = E\\<union>E\\<inverse> - Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; finite E\\<rbrakk>\n    \\<Longrightarrow> nodes (graph V E) =\n                      V \\<union> fst ` E \\<union> snd ` E \\<and>\n                      edges (graph V E) = E \\<union> E\\<inverse> - Id", "by (simp add: graph_accs)"], ["", "lemma graph_eq[simp]: \"graph (nodes g) (edges g) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph (nodes g) (edges g) = g", "unfolding edges_def nodes_def graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_internal (nodes_internal g) (edges_internal g) = g", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> {(V, E).\n                E \\<subseteq> V \\<times> V \\<and>\n                finite V \\<and> sym E \\<and> irrefl E} \\<Longrightarrow>\n       (if finite (fst g) \\<and> finite (snd g)\n        then (fst g \\<union> fst ` snd g \\<union> snd ` snd g,\n              snd g \\<union> (snd g)\\<inverse> - Id)\n        else ({}, {})) =\n       g", "unfolding sym_def irrefl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> {(V, E).\n                E \\<subseteq> V \\<times> V \\<and>\n                finite V \\<and>\n                (\\<forall>x y.\n                    (x, y) \\<in> E \\<longrightarrow> (y, x) \\<in> E) \\<and>\n                (\\<forall>a. (a, a) \\<notin> E)} \\<Longrightarrow>\n       (if finite (fst g) \\<and> finite (snd g)\n        then (fst g \\<union> fst ` snd g \\<union> snd ` snd g,\n              snd g \\<union> (snd g)\\<inverse> - Id)\n        else ({}, {})) =\n       g", "apply (clarsimp split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>x2 \\<subseteq> x1 \\<times> x1; finite x1;\n        \\<forall>x y. (x, y) \\<in> x2 \\<longrightarrow> (y, x) \\<in> x2;\n        \\<forall>a. (a, a) \\<notin> x2\\<rbrakk>\n       \\<Longrightarrow> (finite x2 \\<longrightarrow>\n                          x1 \\<union> fst ` x2 \\<union> snd ` x2 = x1 \\<and>\n                          x2 \\<union> x2\\<inverse> - Id = x2) \\<and>\n                         (infinite x2 \\<longrightarrow>\n                          {} = x1 \\<and> {} = x2)", "by (fastforce simp: finite_subset)"], ["", "lemma edges_finite[simp, intro!]: \"finite (edges g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edges g)", "using edges_subset finite_subset"], ["proof (prove)\nusing this:\n  edges ?g \\<subseteq> nodes ?g \\<times> nodes ?g\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (edges g)", "by fastforce"], ["", "lemma graph_cases[cases type]: obtains V E \n  where \"g = graph V E\" \"finite V\" \"finite E\" \"E\\<subseteq>V\\<times>V\" \"sym E\" \"irrefl E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>V E.\n        \\<lbrakk>g = graph V E; finite V; finite E;\n         E \\<subseteq> V \\<times> V; sym E; irrefl E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>V E.\n        \\<lbrakk>g = graph V E; finite V; finite E;\n         E \\<subseteq> V \\<times> V; sym E; irrefl E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule that[of \"nodes g\" \"edges g\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. g = graph (nodes g) (edges g)\n 2. finite (nodes g)\n 3. finite (edges g)\n 4. edges g \\<subseteq> nodes g \\<times> nodes g\n 5. sym (edges g)\n 6. irrefl (edges g)", "using edges_subset edges_sym edges_irrefl[of g]"], ["proof (prove)\nusing this:\n  edges ?g \\<subseteq> nodes ?g \\<times> nodes ?g\n  sym (edges ?g)\n  irrefl (edges g)\n\ngoal (6 subgoals):\n 1. g = graph (nodes g) (edges g)\n 2. finite (nodes g)\n 3. finite (edges g)\n 4. edges g \\<subseteq> nodes g \\<times> nodes g\n 5. sym (edges g)\n 6. irrefl (edges g)", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma graph_eq_iff: \"g=g' \\<longleftrightarrow> nodes g = nodes g' \\<and> edges g = edges g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g = g') = (nodes g = nodes g' \\<and> edges g = edges g')", "unfolding edges_def nodes_def graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g = g') =\n    (nodes_internal g = nodes_internal g' \\<and>\n     edges_internal g = edges_internal g')", "by transfer auto"], ["", "lemma edges_sym': \"(u,v)\\<in>edges g \\<Longrightarrow> (v,u)\\<in>edges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> edges g \\<Longrightarrow> (v, u) \\<in> edges g", "using edges_sym"], ["proof (prove)\nusing this:\n  sym (edges ?g)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> edges g \\<Longrightarrow> (v, u) \\<in> edges g", "by (blast intro: symD)"], ["", "lemma edges_irrefl'[simp,intro!]: \"(u,u)\\<notin>edges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, u) \\<notin> edges g", "by (meson edges_irrefl irrefl_def)"], ["", "lemma edges_irreflI[simp, intro]: \"(u,v)\\<in>edges g \\<Longrightarrow> u\\<noteq>v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> edges g \\<Longrightarrow> u \\<noteq> v", "by auto"], ["", "lemma edgesT_diff_sng_inv_eq[simp]: \n  \"(edges T - {(x, y), (y, x)})\\<inverse> = edges T - {(x, y), (y, x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edges T - {(x, y), (y, x)})\\<inverse> = edges T - {(x, y), (y, x)}", "using edges_sym'"], ["proof (prove)\nusing this:\n  (?u, ?v) \\<in> edges ?g \\<Longrightarrow> (?v, ?u) \\<in> edges ?g\n\ngoal (1 subgoal):\n 1. (edges T - {(x, y), (y, x)})\\<inverse> = edges T - {(x, y), (y, x)}", "by fast"], ["", "lemma nodesI[simp,intro]: assumes \"(u,v)\\<in>edges g\" shows \"u\\<in>nodes g\" \"v\\<in>nodes g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> nodes g &&& v \\<in> nodes g", "using assms edges_subset"], ["proof (prove)\nusing this:\n  (u, v) \\<in> edges g\n  edges ?g \\<subseteq> nodes ?g \\<times> nodes ?g\n\ngoal (1 subgoal):\n 1. u \\<in> nodes g &&& v \\<in> nodes g", "by auto"], ["", "lemma split_edges_sym: \"\\<exists>E. E\\<inter>E\\<inverse> = {} \\<and> edges g = E \\<union> E\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E.\n       E \\<inter> E\\<inverse> = {} \\<and> edges g = E \\<union> E\\<inverse>", "using split_sym_rel[OF edges_sym edges_irrefl, of g]"], ["proof (prove)\nusing this:\n  (\\<And>E.\n      \\<lbrakk>E \\<inter> E\\<inverse> = {};\n       edges g = E \\<union> E\\<inverse>\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>E.\n       E \\<inter> E\\<inverse> = {} \\<and> edges g = E \\<union> E\\<inverse>", "by metis"], ["", "subsection \\<open>Connectedness Relation\\<close>"], ["", "lemma rtrancl_edges_sym': \"(u,v)\\<in>(edges g)\\<^sup>* \\<Longrightarrow> (v,u)\\<in>(edges g)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> (edges g)\\<^sup>* \\<Longrightarrow>\n    (v, u) \\<in> (edges g)\\<^sup>*", "by (simp add: edges_sym symD sym_rtrancl)"], ["", "lemma trancl_edges_subset: \"(edges g)\\<^sup>+ \\<subseteq> nodes g \\<times> nodes g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edges g)\\<^sup>+ \\<subseteq> nodes g \\<times> nodes g", "by (simp add: edges_subset trancl_subset_Sigma)"], ["", "lemma find_crossing_edge:\n  assumes \"(u,v)\\<in>E\\<^sup>*\" \"u\\<in>V\" \"v\\<notin>V\"\n  obtains u' v' where \"(u',v')\\<in>E\\<inter>V\\<times>-V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        (u', v') \\<in> E \\<inter> V \\<times> - V \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n  u \\<in> V\n  v \\<notin> V\n\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        (u', v') \\<in> E \\<inter> V \\<times> - V \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (induction rule: converse_rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>u' v'.\n                (u', v') \\<in> E \\<inter> V \\<times> - V \\<Longrightarrow>\n                thesis;\n     v \\<in> V; v \\<notin> V\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> E; (z, v) \\<in> E\\<^sup>*;\n        \\<lbrakk>\\<And>u' v'.\n                    (u', v')\n                    \\<in> E \\<inter> V \\<times> - V \\<Longrightarrow>\n                    thesis;\n         z \\<in> V; v \\<notin> V\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        \\<And>u' v'.\n           (u', v') \\<in> E \\<inter> V \\<times> - V \\<Longrightarrow>\n           thesis;\n        y \\<in> V; v \\<notin> V\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["", "subsection \\<open>Constructing Graphs\\<close>"], ["", "definition \"graph_empty \\<equiv> graph {} {}\""], ["", "definition \"ins_node v g \\<equiv> graph (insert v (nodes g)) (edges g)\""], ["", "definition \"ins_edge e g \\<equiv> graph (nodes g) (insert e (edges g))\""], ["", "definition \"graph_join g\\<^sub>1 g\\<^sub>2 \\<equiv> graph (nodes g\\<^sub>1 \\<union> nodes g\\<^sub>2) (edges g\\<^sub>1 \\<union> edges g\\<^sub>2)\""], ["", "definition \"restrict_nodes g V \\<equiv> graph (nodes g \\<inter> V) (edges g \\<inter> V\\<times>V)\""], ["", "definition \"restrict_edges g E \\<equiv> graph (nodes g) (edges g \\<inter> (E\\<union>E\\<inverse>))\""], ["", "definition \"nodes_edges_consistent V E \\<equiv> finite V \\<and> irrefl E \\<and> sym E \\<and> E \\<subseteq> V\\<times>V\""], ["", "lemma [simp]:\n  assumes \"nodes_edges_consistent V E\"\n  shows nodes_graph': \"nodes (graph V E) = V\" (is ?G1)\n    and edges_graph': \"edges (graph V E) = E\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (graph V E) = V &&& edges (graph V E) = E", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. nodes (graph V E) = V\n 2. edges (graph V E) = E", "from assms"], ["proof (chain)\npicking this:\n  nodes_edges_consistent V E", "have [simp]: \"finite E\""], ["proof (prove)\nusing this:\n  nodes_edges_consistent V E\n\ngoal (1 subgoal):\n 1. finite E", "unfolding nodes_edges_consistent_def"], ["proof (prove)\nusing this:\n  finite V \\<and> irrefl E \\<and> sym E \\<and> E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. finite E", "by (meson finite_SigmaI rev_finite_subset)"], ["proof (state)\nthis:\n  finite E\n\ngoal (2 subgoals):\n 1. nodes (graph V E) = V\n 2. edges (graph V E) = E", "show ?G1 ?G2"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (graph V E) = V &&& edges (graph V E) = E", "using assms"], ["proof (prove)\nusing this:\n  nodes_edges_consistent V E\n\ngoal (1 subgoal):\n 1. nodes (graph V E) = V &&& edges (graph V E) = E", "by (auto simp: nodes_edges_consistent_def nodes_graph edges_graph irrefl_def)"], ["proof (state)\nthis:\n  nodes (graph V E) = V\n  edges (graph V E) = E\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nec_empty[simp]: \"nodes_edges_consistent {} {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_edges_consistent {} {}", "by (auto simp: nodes_edges_consistent_def irrefl_def sym_def)"], ["", "lemma graph_empty_accs[simp]:\n  \"nodes graph_empty = {}\"\n  \"edges graph_empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes graph_empty = {} &&& edges graph_empty = {}", "unfolding graph_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (graph {} {}) = {} &&& edges (graph {} {}) = {}", "by (auto)"], ["", "lemma graph_empty[simp]: \"graph {} {} = graph_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph {} {} = graph_empty", "by (simp add: graph_empty_def)"], ["", "lemma nodes_empty_iff_empty[simp]: \n  \"nodes G = {} \\<longleftrightarrow> G=graph {} {}\"\n  \"{} = nodes G \\<longleftrightarrow> G=graph_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nodes G = {}) = (G = graph {} {}) &&&\n    ({} = nodes G) = (G = graph_empty)", "using edges_subset"], ["proof (prove)\nusing this:\n  edges ?g \\<subseteq> nodes ?g \\<times> nodes ?g\n\ngoal (1 subgoal):\n 1. (nodes G = {}) = (G = graph {} {}) &&&\n    ({} = nodes G) = (G = graph_empty)", "by (auto simp: graph_eq_iff)"], ["", "lemma nodes_ins_nodes[simp]: \"nodes (ins_node v g) = insert v (nodes g)\"         \n  and edges_ins_nodes[simp]: \"edges (ins_node v g) = edges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (ins_node v g) = insert v (nodes g) &&&\n    edges (ins_node v g) = edges g", "unfolding ins_node_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (graph (insert v (nodes g)) (edges g)) = insert v (nodes g) &&&\n    edges (graph (insert v (nodes g)) (edges g)) = edges g", "by (auto simp: graph_accs edges_sym')"], ["", "lemma nodes_ins_edge[simp]: \"nodes (ins_edge e g) = {fst e, snd e} \\<union> nodes g\"\n  and edges_ins_edge: \n    \"edges (ins_edge e g) \n      = (if fst e = snd e then edges g else {e,prod.swap e}\\<union>(edges g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (ins_edge e g) = {fst e, snd e} \\<union> nodes g &&&\n    edges (ins_edge e g) =\n    (if fst e = snd e then edges g else {e, prod.swap e} \\<union> edges g)", "unfolding ins_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (graph (nodes g) (insert e (edges g))) =\n    {fst e, snd e} \\<union> nodes g &&&\n    edges (graph (nodes g) (insert e (edges g))) =\n    (if fst e = snd e then edges g else {e, prod.swap e} \\<union> edges g)", "apply (all \\<open>cases e\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       nodes (graph (nodes g) (insert e (edges g))) =\n       {fst e, snd e} \\<union> nodes g\n 2. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       edges (graph (nodes g) (insert e (edges g))) =\n       (if fst e = snd e then edges g\n        else {e, prod.swap e} \\<union> edges g)", "by (auto simp: graph_accs dest: edges_sym')"], ["", "lemma edges_ins_edge'[simp]: \n  \"u\\<noteq>v \\<Longrightarrow> edges (ins_edge (u,v) g) = {(u,v),(v,u)} \\<union> edges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    edges (ins_edge (u, v) g) = {(u, v), (v, u)} \\<union> edges g", "by (auto simp: edges_ins_edge)"], ["", "lemma edges_ins_edge_ss: \"edges g \\<subseteq> edges (ins_edge e g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges g \\<subseteq> edges (ins_edge e g)", "by (auto simp: edges_ins_edge)"], ["", "lemma nodes_join[simp]: \"nodes (graph_join g\\<^sub>1 g\\<^sub>2) = nodes g\\<^sub>1 \\<union> nodes g\\<^sub>2\"  \n  and edges_join[simp]: \"edges (graph_join g\\<^sub>1 g\\<^sub>2) = edges g\\<^sub>1 \\<union> edges g\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (graph_join g\\<^sub>1 g\\<^sub>2) =\n    nodes g\\<^sub>1 \\<union> nodes g\\<^sub>2 &&&\n    edges (graph_join g\\<^sub>1 g\\<^sub>2) =\n    edges g\\<^sub>1 \\<union> edges g\\<^sub>2", "unfolding graph_join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes\n     (graph (nodes g\\<^sub>1 \\<union> nodes g\\<^sub>2)\n       (edges g\\<^sub>1 \\<union> edges g\\<^sub>2)) =\n    nodes g\\<^sub>1 \\<union> nodes g\\<^sub>2 &&&\n    edges\n     (graph (nodes g\\<^sub>1 \\<union> nodes g\\<^sub>2)\n       (edges g\\<^sub>1 \\<union> edges g\\<^sub>2)) =\n    edges g\\<^sub>1 \\<union> edges g\\<^sub>2", "by (auto simp: graph_accs dest: edges_sym')"], ["", "lemma nodes_restrict_nodes[simp]: \"nodes (restrict_nodes g V) = nodes g \\<inter> V\"  \n  and edges_restrict_nodes[simp]: \"edges (restrict_nodes g V) = edges g \\<inter> V\\<times>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (restrict_nodes g V) = nodes g \\<inter> V &&&\n    edges (restrict_nodes g V) = Restr (edges g) V", "unfolding restrict_nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (graph (nodes g \\<inter> V) (Restr (edges g) V)) =\n    nodes g \\<inter> V &&&\n    edges (graph (nodes g \\<inter> V) (Restr (edges g) V)) =\n    Restr (edges g) V", "by (auto simp: graph_accs dest: edges_sym')"], ["", "lemma nodes_restrict_edges[simp]: \"nodes (restrict_edges g E) = nodes g\"\n  and edges_restrict_edges[simp]: \"edges (restrict_edges g E) = edges g \\<inter> (E\\<union>E\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (restrict_edges g E) = nodes g &&&\n    edges (restrict_edges g E) = edges g \\<inter> (E \\<union> E\\<inverse>)", "unfolding restrict_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (graph (nodes g) (edges g \\<inter> (E \\<union> E\\<inverse>))) =\n    nodes g &&&\n    edges (graph (nodes g) (edges g \\<inter> (E \\<union> E\\<inverse>))) =\n    edges g \\<inter> (E \\<union> E\\<inverse>)", "by (auto simp: graph_accs dest: edges_sym')"], ["", "lemma unrestricte_edges: \"edges (restrict_edges g E) \\<subseteq> edges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (restrict_edges g E) \\<subseteq> edges g", "by auto"], ["", "lemma unrestrictn_edges: \"edges (restrict_nodes g V) \\<subseteq> edges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (restrict_nodes g V) \\<subseteq> edges g", "by auto"], ["", "lemma unrestrict_nodes: \"nodes (restrict_edges g E) \\<subseteq> nodes g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (restrict_edges g E) \\<subseteq> nodes g", "by auto"], ["", "subsection \\<open>Paths\\<close>"], ["", "fun path where\n  \"path g u [] v \\<longleftrightarrow> u=v\"  \n| \"path g u (e#ps) w \\<longleftrightarrow> (\\<exists>v. e=(u,v) \\<and> e\\<in>edges g \\<and> path g v ps w)\""], ["", "lemma path_emptyI[intro!]: \"path g u [] u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path g u [] u", "by auto"], ["", "lemma path_append[simp]: \n  \"path g u (p1@p2) w \\<longleftrightarrow> (\\<exists>v. path g u p1 v \\<and> path g v p2 w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path g u (p1 @ p2) w = (\\<exists>v. path g u p1 v \\<and> path g v p2 w)", "by (induction p1 arbitrary: u) auto"], ["", "lemma path_transs1[trans]:\n  \"path g u p v \\<Longrightarrow> (v,w)\\<in>edges g \\<Longrightarrow> path g u (p@[(v,w)]) w\"  \n  \"(u,v)\\<in>edges g \\<Longrightarrow> path g v p w \\<Longrightarrow> path g u ((u,v)#p) w\"\n  \"path g u p1 v \\<Longrightarrow> path g v p2 w \\<Longrightarrow> path g u (p1@p2) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>path g u p v; (v, w) \\<in> edges g\\<rbrakk>\n     \\<Longrightarrow> path g u (p @ [(v, w)]) w) &&&\n    (\\<lbrakk>(u, v) \\<in> edges g; path g v p w\\<rbrakk>\n     \\<Longrightarrow> path g u ((u, v) # p) w) &&&\n    (\\<lbrakk>path g u p1 v; path g v p2 w\\<rbrakk>\n     \\<Longrightarrow> path g u (p1 @ p2) w)", "by auto"], ["", "lemma path_graph_empty[simp]: \"path graph_empty u p v \\<longleftrightarrow> v=u \\<and> p=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path graph_empty u p v = (v = u \\<and> p = [])", "by (cases p) auto"], ["", "abbreviation \"revp p \\<equiv> rev (map prod.swap p)\""], ["", "lemma revp_alt: \"revp p = rev (map (\\<lambda>(u,v). (v,u)) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. revp p = rev (map (\\<lambda>(u, v). (v, u)) p)", "by auto"], ["", "lemma path_rev[simp]: \"path g u (revp p) v \\<longleftrightarrow> path g v p u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path g u (revp p) v = path g v p u", "by (induction p arbitrary: v) (auto dest: edges_sym')"], ["", "lemma path_rev_sym[sym]: \"path g v p u \\<Longrightarrow> path g u (revp p) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path g v p u \\<Longrightarrow> path g u (revp p) v", "by simp"], ["", "lemma path_transs2[trans]: \n  \"path g u p v \\<Longrightarrow> (w,v)\\<in>edges g \\<Longrightarrow> path g u (p@[(v,w)]) w\"  \n  \"(v,u)\\<in>edges g \\<Longrightarrow> path g v p w \\<Longrightarrow> path g u ((u,v)#p) w\"\n  \"path g u p1 v \\<Longrightarrow> path g w p2 v \\<Longrightarrow> path g u (p1@revp p2) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>path g u p v; (w, v) \\<in> edges g\\<rbrakk>\n     \\<Longrightarrow> path g u (p @ [(v, w)]) w) &&&\n    (\\<lbrakk>(v, u) \\<in> edges g; path g v p w\\<rbrakk>\n     \\<Longrightarrow> path g u ((u, v) # p) w) &&&\n    (\\<lbrakk>path g u p1 v; path g w p2 v\\<rbrakk>\n     \\<Longrightarrow> path g u (p1 @ revp p2) w)", "by (auto dest: edges_sym')"], ["", "lemma path_edges: \"path g u p v \\<Longrightarrow> set p \\<subseteq> edges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path g u p v \\<Longrightarrow> set p \\<subseteq> edges g", "by (induction p arbitrary: u) auto"], ["", "lemma path_graph_cong: \n  \"\\<lbrakk>path g\\<^sub>1 u p v; set p \\<subseteq> edges g\\<^sub>1 \\<Longrightarrow> set p \\<subseteq> edges g\\<^sub>2\\<rbrakk> \\<Longrightarrow> path g\\<^sub>2 u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path g\\<^sub>1 u p v;\n     set p \\<subseteq> edges g\\<^sub>1 \\<Longrightarrow>\n     set p \\<subseteq> edges g\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> path g\\<^sub>2 u p v", "apply (frule path_edges; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path g\\<^sub>1 u p v; set p \\<subseteq> edges g\\<^sub>2;\n     set p \\<subseteq> edges g\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> path g\\<^sub>2 u p v", "apply (induction p arbitrary: u)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>path g\\<^sub>1 u [] v; set [] \\<subseteq> edges g\\<^sub>2;\n        set [] \\<subseteq> edges g\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> path g\\<^sub>2 u [] v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>path g\\<^sub>1 u p v;\n                    set p \\<subseteq> edges g\\<^sub>2;\n                    set p \\<subseteq> edges g\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> path g\\<^sub>2 u p v;\n        path g\\<^sub>1 u (a # p) v; set (a # p) \\<subseteq> edges g\\<^sub>2;\n        set (a # p) \\<subseteq> edges g\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> path g\\<^sub>2 u (a # p) v", "by auto"], ["", "lemma path_endpoints: \n  assumes \"path g u p v\" \"p\\<noteq>[]\" shows \"u\\<in>nodes g\" \"v\\<in>nodes g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> nodes g &&& v \\<in> nodes g", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> nodes g", "using assms"], ["proof (prove)\nusing this:\n  path g u p v\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. u \\<in> nodes g", "by (cases p) (auto intro: nodesI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> nodes g", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> nodes g", "using assms"], ["proof (prove)\nusing this:\n  path g u p v\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. v \\<in> nodes g", "by (cases p rule: rev_cases) (auto intro: nodesI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_mono: \"edges g \\<subseteq> edges g' \\<Longrightarrow> path g u p v \\<Longrightarrow> path g' u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>edges g \\<subseteq> edges g'; path g u p v\\<rbrakk>\n    \\<Longrightarrow> path g' u p v", "by (meson path_edges path_graph_cong subset_trans)"], ["", "lemmas unrestricte_path = path_mono[OF unrestricte_edges]"], ["", "lemmas unrestrictn_path = path_mono[OF unrestrictn_edges]"], ["", "lemma unrestrict_path_edges: \"path (restrict_edges g E) u p v \\<Longrightarrow> path g u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (restrict_edges g E) u p v \\<Longrightarrow> path g u p v", "by (induction p arbitrary: u) auto"], ["", "lemma unrestrict_path_nodes: \"path (restrict_nodes g E) u p v \\<Longrightarrow> path g u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (restrict_nodes g E) u p v \\<Longrightarrow> path g u p v", "by (induction p arbitrary: u) auto"], ["", "subsubsection \\<open>Paths and Connectedness\\<close>"], ["", "lemma rtrancl_edges_iff_path: \"(u,v)\\<in>(edges g)\\<^sup>* \\<longleftrightarrow> (\\<exists>p. path g u p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((u, v) \\<in> (edges g)\\<^sup>*) = (\\<exists>p. path g u p v)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. (u, v) \\<in> (edges g)\\<^sup>* \\<Longrightarrow>\n    \\<exists>p. path g u p v\n 2. \\<exists>p. path g u p v \\<Longrightarrow>\n    (u, v) \\<in> (edges g)\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> (edges g)\\<^sup>* \\<Longrightarrow>\n    \\<exists>p. path g u p v", "apply (induction rule: converse_rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>p. path g v p v\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> edges g; (z, v) \\<in> (edges g)\\<^sup>*;\n        \\<exists>p. path g z p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. path g y p v", "by (auto dest: path_transs1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. path g u p v \\<Longrightarrow>\n    (u, v) \\<in> (edges g)\\<^sup>*", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. path g u p v \\<Longrightarrow> (u, v) \\<in> (edges g)\\<^sup>*", "subgoal for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. path g u p v \\<Longrightarrow> (u, v) \\<in> (edges g)\\<^sup>*", "by (induction p arbitrary: u; force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rtrancl_edges_pathE: \n  assumes \"(u,v)\\<in>(edges g)\\<^sup>*\" obtains p where \"path g u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p. path g u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> (edges g)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>p. path g u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: rtrancl_edges_iff_path)"], ["", "lemma path_rtrancl_edgesD: \"path g u p v \\<Longrightarrow> (u,v)\\<in>(edges g)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path g u p v \\<Longrightarrow> (u, v) \\<in> (edges g)\\<^sup>*", "by (auto simp: rtrancl_edges_iff_path)"], ["", "subsubsection \\<open>Simple Paths\\<close>"], ["", "definition \"uedge \\<equiv> \\<lambda>(a,b). {a,b}\""], ["", "definition \"simple p \\<equiv> distinct (map uedge p)\""], ["", "lemma in_uedge_conv[simp]: \"x\\<in>uedge (u,v) \\<longleftrightarrow> x=u \\<or> x=v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> uedge (u, v)) = (x = u \\<or> x = v)", "by (auto simp: uedge_def)"], ["", "lemma uedge_eq_iff: \"uedge (a,b) = uedge (c,d) \\<longleftrightarrow> a=c \\<and> b=d \\<or> a=d \\<and> b=c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uedge (a, b) = uedge (c, d)) =\n    (a = c \\<and> b = d \\<or> a = d \\<and> b = c)", "by (auto simp: uedge_def doubleton_eq_iff)"], ["", "lemma uedge_degen[simp]: \"uedge (a,a) = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uedge (a, a) = {a}", "by (auto simp: uedge_def)"], ["", "lemma uedge_in_set_eq: \"uedge (u, v) \\<in> uedge ` S \\<longleftrightarrow> (u,v)\\<in>S \\<or> (v,u)\\<in>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uedge (u, v) \\<in> uedge ` S) = ((u, v) \\<in> S \\<or> (v, u) \\<in> S)", "by (auto simp: uedge_def doubleton_eq_iff)"], ["", "lemma uedge_commute: \"uedge (a,b) = uedge (b,a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uedge (a, b) = uedge (b, a)", "by auto"], ["", "lemma simple_empty[simp]: \"simple []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple []", "by (auto simp: simple_def)"], ["", "lemma simple_cons[simp]: \"simple (e#p) \\<longleftrightarrow> uedge e \\<notin> uedge ` set p \\<and> simple p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple (e # p) = (uedge e \\<notin> uedge ` set p \\<and> simple p)", "by (auto simp: simple_def)"], ["", "lemma simple_append[simp]: \"simple (p\\<^sub>1@p\\<^sub>2) \n  \\<longleftrightarrow> simple p\\<^sub>1 \\<and> simple p\\<^sub>2 \\<and> uedge ` set p\\<^sub>1 \\<inter> uedge ` set p\\<^sub>2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple (p\\<^sub>1 @ p\\<^sub>2) =\n    (simple p\\<^sub>1 \\<and>\n     simple p\\<^sub>2 \\<and>\n     uedge ` set p\\<^sub>1 \\<inter> uedge ` set p\\<^sub>2 = {})", "by (auto simp: simple_def)"], ["", "lemma simplify_pathD:\n  \"path g u p v \\<Longrightarrow> \\<exists>p'. path g u p' v \\<and> simple p' \\<and> set p' \\<subseteq> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path g u p v \\<Longrightarrow>\n    \\<exists>p'.\n       path g u p' v \\<and> simple p' \\<and> set p' \\<subseteq> set p", "proof (induction p arbitrary: u v rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs u v.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa.\n                       path g x ys xa \\<longrightarrow>\n                       (\\<exists>p'.\n                           path g x p' xa \\<and>\n                           simple p' \\<and> set p' \\<subseteq> set ys));\n        path g u xs v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            path g u p' v \\<and>\n                            simple p' \\<and> set p' \\<subseteq> set xs", "case A: (1 p)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length p \\<longrightarrow>\n     (\\<forall>x xa.\n         path g x ys xa \\<longrightarrow>\n         (\\<exists>p'.\n             path g x p' xa \\<and>\n             simple p' \\<and> set p' \\<subseteq> set ys))\n  path g u p v\n\ngoal (1 subgoal):\n 1. \\<And>xs u v.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa.\n                       path g x ys xa \\<longrightarrow>\n                       (\\<exists>p'.\n                           path g x p' xa \\<and>\n                           simple p' \\<and> set p' \\<subseteq> set ys));\n        path g u xs v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            path g u p' v \\<and>\n                            simple p' \\<and> set p' \\<subseteq> set xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>ys.\n     length ys < length p \\<longrightarrow>\n     (\\<forall>x xa.\n         path g x ys xa \\<longrightarrow>\n         (\\<exists>p'.\n             path g x p' xa \\<and>\n             simple p' \\<and> set p' \\<subseteq> set ys))\n  path g u p v", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length p \\<longrightarrow>\n     (\\<forall>x xa.\n         path g x ys xa \\<longrightarrow>\n         (\\<exists>p'.\n             path g x p' xa \\<and>\n             simple p' \\<and> set p' \\<subseteq> set ys))\n  path g u p v\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       path g u p' v \\<and> simple p' \\<and> set p' \\<subseteq> set p", "proof (cases \"simple p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ys.\n                length ys < length p \\<longrightarrow>\n                (\\<forall>x xa.\n                    path g x ys xa \\<longrightarrow>\n                    (\\<exists>p'.\n                        path g x p' xa \\<and>\n                        simple p' \\<and> set p' \\<subseteq> set ys));\n     path g u p v; simple p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path g u p' v \\<and>\n                         simple p' \\<and> set p' \\<subseteq> set p\n 2. \\<lbrakk>\\<forall>ys.\n                length ys < length p \\<longrightarrow>\n                (\\<forall>x xa.\n                    path g x ys xa \\<longrightarrow>\n                    (\\<exists>p'.\n                        path g x p' xa \\<and>\n                        simple p' \\<and> set p' \\<subseteq> set ys));\n     path g u p v; \\<not> simple p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path g u p' v \\<and>\n                         simple p' \\<and> set p' \\<subseteq> set p", "assume \"simple p\""], ["proof (state)\nthis:\n  simple p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ys.\n                length ys < length p \\<longrightarrow>\n                (\\<forall>x xa.\n                    path g x ys xa \\<longrightarrow>\n                    (\\<exists>p'.\n                        path g x p' xa \\<and>\n                        simple p' \\<and> set p' \\<subseteq> set ys));\n     path g u p v; simple p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path g u p' v \\<and>\n                         simple p' \\<and> set p' \\<subseteq> set p\n 2. \\<lbrakk>\\<forall>ys.\n                length ys < length p \\<longrightarrow>\n                (\\<forall>x xa.\n                    path g x ys xa \\<longrightarrow>\n                    (\\<exists>p'.\n                        path g x p' xa \\<and>\n                        simple p' \\<and> set p' \\<subseteq> set ys));\n     path g u p v; \\<not> simple p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path g u p' v \\<and>\n                         simple p' \\<and> set p' \\<subseteq> set p", "with A.prems"], ["proof (chain)\npicking this:\n  path g u p v\n  simple p", "show ?case"], ["proof (prove)\nusing this:\n  path g u p v\n  simple p\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       path g u p' v \\<and> simple p' \\<and> set p' \\<subseteq> set p", "by blast"], ["proof (state)\nthis:\n  \\<exists>p'.\n     path g u p' v \\<and> simple p' \\<and> set p' \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ys.\n                length ys < length p \\<longrightarrow>\n                (\\<forall>x xa.\n                    path g x ys xa \\<longrightarrow>\n                    (\\<exists>p'.\n                        path g x p' xa \\<and>\n                        simple p' \\<and> set p' \\<subseteq> set ys));\n     path g u p v; \\<not> simple p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path g u p' v \\<and>\n                         simple p' \\<and> set p' \\<subseteq> set p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ys.\n                length ys < length p \\<longrightarrow>\n                (\\<forall>x xa.\n                    path g x ys xa \\<longrightarrow>\n                    (\\<exists>p'.\n                        path g x p' xa \\<and>\n                        simple p' \\<and> set p' \\<subseteq> set ys));\n     path g u p v; \\<not> simple p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path g u p' v \\<and>\n                         simple p' \\<and> set p' \\<subseteq> set p", "assume \"\\<not>simple p\""], ["proof (state)\nthis:\n  \\<not> simple p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ys.\n                length ys < length p \\<longrightarrow>\n                (\\<forall>x xa.\n                    path g x ys xa \\<longrightarrow>\n                    (\\<exists>p'.\n                        path g x p' xa \\<and>\n                        simple p' \\<and> set p' \\<subseteq> set ys));\n     path g u p v; \\<not> simple p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path g u p' v \\<and>\n                         simple p' \\<and> set p' \\<subseteq> set p", "then"], ["proof (chain)\npicking this:\n  \\<not> simple p", "consider p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3 where \"p=p\\<^sub>1@[(a,b)]@p\\<^sub>2@[(a,b)]@p\\<^sub>3\"\n                | p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3 where \"p=p\\<^sub>1@[(a,b)]@p\\<^sub>2@[(b,a)]@p\\<^sub>3\""], ["proof (prove)\nusing this:\n  \\<not> simple p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n                p =\n                p\\<^sub>1 @\n                [(a, b)] @\n                p\\<^sub>2 @ [(a, b)] @ p\\<^sub>3 \\<Longrightarrow>\n                thesis;\n     \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n        p =\n        p\\<^sub>1 @\n        [(a, b)] @ p\\<^sub>2 @ [(b, a)] @ p\\<^sub>3 \\<Longrightarrow>\n        thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto \n        simp: simple_def map_eq_append_conv uedge_eq_iff \n        dest!: not_distinct_decomp)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n              p =\n              p\\<^sub>1 @\n              [(a, b)] @ p\\<^sub>2 @ [(a, b)] @ p\\<^sub>3 \\<Longrightarrow>\n              ?thesis;\n   \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n      p =\n      p\\<^sub>1 @\n      [(a, b)] @ p\\<^sub>2 @ [(b, a)] @ p\\<^sub>3 \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ys.\n                length ys < length p \\<longrightarrow>\n                (\\<forall>x xa.\n                    path g x ys xa \\<longrightarrow>\n                    (\\<exists>p'.\n                        path g x p' xa \\<and>\n                        simple p' \\<and> set p' \\<subseteq> set ys));\n     path g u p v; \\<not> simple p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path g u p' v \\<and>\n                         simple p' \\<and> set p' \\<subseteq> set p", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n              p =\n              p\\<^sub>1 @\n              [(a, b)] @ p\\<^sub>2 @ [(a, b)] @ p\\<^sub>3 \\<Longrightarrow>\n              ?thesis;\n   \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n      p =\n      p\\<^sub>1 @\n      [(a, b)] @ p\\<^sub>2 @ [(b, a)] @ p\\<^sub>3 \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain p' where \"path g u p' v\" \"length p' < length p\" \"set p' \\<subseteq> set p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n              p =\n              p\\<^sub>1 @\n              [(a, b)] @ p\\<^sub>2 @ [(a, b)] @ p\\<^sub>3 \\<Longrightarrow>\n              ?thesis;\n   \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n      p =\n      p\\<^sub>1 @\n      [(a, b)] @ p\\<^sub>2 @ [(b, a)] @ p\\<^sub>3 \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>path g u p' v; length p' < length p;\n         set p' \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n       \\<lbrakk>\\<And>p'.\n                   \\<lbrakk>path g u p' v; length p' < length p;\n                    set p' \\<subseteq> set p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = p\\<^sub>1 @ [(a, b)] @ p\\<^sub>2 @ [(a, b)] @ p\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n       \\<lbrakk>\\<And>p'.\n                   \\<lbrakk>path g u p' v; length p' < length p;\n                    set p' \\<subseteq> set p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = p\\<^sub>1 @ [(a, b)] @ p\\<^sub>2 @ [(b, a)] @ p\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> thesis", "case [simp]: 1"], ["proof (state)\nthis:\n  p = p\\<^sub>1 @ [(a, b)] @ p\\<^sub>2 @ [(a, b)] @ p\\<^sub>3\n\ngoal (2 subgoals):\n 1. \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n       \\<lbrakk>\\<And>p'.\n                   \\<lbrakk>path g u p' v; length p' < length p;\n                    set p' \\<subseteq> set p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = p\\<^sub>1 @ [(a, b)] @ p\\<^sub>2 @ [(a, b)] @ p\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n       \\<lbrakk>\\<And>p'.\n                   \\<lbrakk>path g u p' v; length p' < length p;\n                    set p' \\<subseteq> set p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = p\\<^sub>1 @ [(a, b)] @ p\\<^sub>2 @ [(b, a)] @ p\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> thesis", "from A.prems"], ["proof (chain)\npicking this:\n  path g u p v", "have \"path g u (p\\<^sub>1@[(a,b)]@p\\<^sub>3) v\""], ["proof (prove)\nusing this:\n  path g u p v\n\ngoal (1 subgoal):\n 1. path g u (p\\<^sub>1 @ [(a, b)] @ p\\<^sub>3) v", "by auto"], ["proof (state)\nthis:\n  path g u (p\\<^sub>1 @ [(a, b)] @ p\\<^sub>3) v\n\ngoal (2 subgoals):\n 1. \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n       \\<lbrakk>\\<And>p'.\n                   \\<lbrakk>path g u p' v; length p' < length p;\n                    set p' \\<subseteq> set p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = p\\<^sub>1 @ [(a, b)] @ p\\<^sub>2 @ [(a, b)] @ p\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n       \\<lbrakk>\\<And>p'.\n                   \\<lbrakk>path g u p' v; length p' < length p;\n                    set p' \\<subseteq> set p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = p\\<^sub>1 @ [(a, b)] @ p\\<^sub>2 @ [(b, a)] @ p\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> thesis", "from that[OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>length (p\\<^sub>1 @ [(a, b)] @ p\\<^sub>3) < length p;\n   set (p\\<^sub>1 @ [(a, b)] @ p\\<^sub>3) \\<subseteq> set p\\<rbrakk>\n  \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length (p\\<^sub>1 @ [(a, b)] @ p\\<^sub>3) < length p;\n   set (p\\<^sub>1 @ [(a, b)] @ p\\<^sub>3) \\<subseteq> set p\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n       \\<lbrakk>\\<And>p'.\n                   \\<lbrakk>path g u p' v; length p' < length p;\n                    set p' \\<subseteq> set p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = p\\<^sub>1 @ [(a, b)] @ p\\<^sub>2 @ [(b, a)] @ p\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n       \\<lbrakk>\\<And>p'.\n                   \\<lbrakk>path g u p' v; length p' < length p;\n                    set p' \\<subseteq> set p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = p\\<^sub>1 @ [(a, b)] @ p\\<^sub>2 @ [(b, a)] @ p\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> thesis", "case [simp]: 2"], ["proof (state)\nthis:\n  p = p\\<^sub>1 @ [(a, b)] @ p\\<^sub>2 @ [(b, a)] @ p\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n       \\<lbrakk>\\<And>p'.\n                   \\<lbrakk>path g u p' v; length p' < length p;\n                    set p' \\<subseteq> set p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = p\\<^sub>1 @ [(a, b)] @ p\\<^sub>2 @ [(b, a)] @ p\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> thesis", "from A.prems"], ["proof (chain)\npicking this:\n  path g u p v", "have \"path g u (p\\<^sub>1@p\\<^sub>3) v\""], ["proof (prove)\nusing this:\n  path g u p v\n\ngoal (1 subgoal):\n 1. path g u (p\\<^sub>1 @ p\\<^sub>3) v", "by auto"], ["proof (state)\nthis:\n  path g u (p\\<^sub>1 @ p\\<^sub>3) v\n\ngoal (1 subgoal):\n 1. \\<And>p\\<^sub>1 a b p\\<^sub>2 p\\<^sub>3.\n       \\<lbrakk>\\<And>p'.\n                   \\<lbrakk>path g u p' v; length p' < length p;\n                    set p' \\<subseteq> set p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = p\\<^sub>1 @ [(a, b)] @ p\\<^sub>2 @ [(b, a)] @ p\\<^sub>3\\<rbrakk>\n       \\<Longrightarrow> thesis", "from that[OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>length (p\\<^sub>1 @ p\\<^sub>3) < length p;\n   set (p\\<^sub>1 @ p\\<^sub>3) \\<subseteq> set p\\<rbrakk>\n  \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length (p\\<^sub>1 @ p\\<^sub>3) < length p;\n   set (p\\<^sub>1 @ p\\<^sub>3) \\<subseteq> set p\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path g u p' v\n  length p' < length p\n  set p' \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ys.\n                length ys < length p \\<longrightarrow>\n                (\\<forall>x xa.\n                    path g x ys xa \\<longrightarrow>\n                    (\\<exists>p'.\n                        path g x p' xa \\<and>\n                        simple p' \\<and> set p' \\<subseteq> set ys));\n     path g u p v; \\<not> simple p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path g u p' v \\<and>\n                         simple p' \\<and> set p' \\<subseteq> set p", "with A.IH"], ["proof (chain)\npicking this:\n  \\<forall>ys.\n     length ys < length p \\<longrightarrow>\n     (\\<forall>x xa.\n         path g x ys xa \\<longrightarrow>\n         (\\<exists>p'.\n             path g x p' xa \\<and>\n             simple p' \\<and> set p' \\<subseteq> set ys))\n  path g u p' v\n  length p' < length p\n  set p' \\<subseteq> set p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length p \\<longrightarrow>\n     (\\<forall>x xa.\n         path g x ys xa \\<longrightarrow>\n         (\\<exists>p'.\n             path g x p' xa \\<and>\n             simple p' \\<and> set p' \\<subseteq> set ys))\n  path g u p' v\n  length p' < length p\n  set p' \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       path g u p' v \\<and> simple p' \\<and> set p' \\<subseteq> set p", "by blast"], ["proof (state)\nthis:\n  \\<exists>p'.\n     path g u p' v \\<and> simple p' \\<and> set p' \\<subseteq> set p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p'.\n     path g u p' v \\<and> simple p' \\<and> set p' \\<subseteq> set p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simplify_pathE: \n  assumes \"path g u p v\" \n  obtains p' where \"path g u p' v\" \"simple p'\" \"set p' \\<subseteq> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>path g u p' v; simple p'; set p' \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  path g u p v\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>path g u p' v; simple p'; set p' \\<subseteq> set p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: simplify_pathD)"], ["", "subsubsection \\<open>Splitting Paths\\<close>"], ["", "lemma find_crossing_edge_on_path:\n  assumes \"path g u p v\" \"\\<not>P u\" \"P v\"\n  obtains u' v' where \"(u',v')\\<in>set p\" \"\\<not>P u'\" \"P v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        \\<lbrakk>(u', v') \\<in> set p; \\<not> P u'; P v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  path g u p v\n  \\<not> P u\n  P v\n\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        \\<lbrakk>(u', v') \\<in> set p; \\<not> P u'; P v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (induction p arbitrary: u) auto"], ["", "lemma find_crossing_edges_on_path:  \n  assumes P: \"path g u p v\" and \"P u\" \"P v\"\n  obtains \"\\<forall>(u,v)\\<in>set p. P u \\<and> P v\"\n        | u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2 p\\<^sub>3 \n          where \"p=p\\<^sub>1@[(u\\<^sub>1,v\\<^sub>1)]@p\\<^sub>2@[(u\\<^sub>2,v\\<^sub>2)]@p\\<^sub>3\" \"P u\\<^sub>1\" \"\\<not>P v\\<^sub>1\" \"\\<not>P u\\<^sub>2\" \"P v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases \"\\<forall>(u,v)\\<in>set p. P u \\<and> P v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<forall>(u, v)\\<in>set p. P u \\<and> P v\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  \\<forall>(u, v)\\<in>set p. P u \\<and> P v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<forall>(u, v)\\<in>set p. P u \\<and> P v\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with that"], ["proof (chain)\npicking this:\n  \\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow> thesis\n  \\<lbrakk>p =\n           ?p\\<^sub>1 @\n           [(?u\\<^sub>1, ?v\\<^sub>1)] @\n           ?p\\<^sub>2 @ [(?u\\<^sub>2, ?v\\<^sub>2)] @ ?p\\<^sub>3;\n   P ?u\\<^sub>1; \\<not> P ?v\\<^sub>1; \\<not> P ?u\\<^sub>2;\n   P ?v\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<forall>(u, v)\\<in>set p. P u \\<and> P v", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow> thesis\n  \\<lbrakk>p =\n           ?p\\<^sub>1 @\n           [(?u\\<^sub>1, ?v\\<^sub>1)] @\n           ?p\\<^sub>2 @ [(?u\\<^sub>2, ?v\\<^sub>2)] @ ?p\\<^sub>3;\n   P ?u\\<^sub>1; \\<not> P ?v\\<^sub>1; \\<not> P ?u\\<^sub>2;\n   P ?v\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<forall>(u, v)\\<in>set p. P u \\<and> P v\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with P \\<open>P u\\<close>"], ["proof (chain)\npicking this:\n  path g u p v\n  P u\n  \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)", "have \"\\<exists>(u\\<^sub>1,v\\<^sub>1)\\<in>set p. P u\\<^sub>1 \\<and> \\<not>P v\\<^sub>1\""], ["proof (prove)\nusing this:\n  path g u p v\n  P u\n  \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)\n\ngoal (1 subgoal):\n 1. \\<exists>(u\\<^sub>1, v\\<^sub>1)\\<in>set p.\n       P u\\<^sub>1 \\<and> \\<not> P v\\<^sub>1", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>path g u p v; P u; (a, b) \\<in> set p;\n        P a \\<longrightarrow> \\<not> P b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set p.\n                            case x of\n                            (u\\<^sub>1, v\\<^sub>1) \\<Rightarrow>\n                              P u\\<^sub>1 \\<and> \\<not> P v\\<^sub>1", "apply (induction p arbitrary: u)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b u.\n       \\<lbrakk>path g u [] v; P u; (a, b) \\<in> set [];\n        P a \\<longrightarrow> \\<not> P b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(u\\<^sub>1, v\\<^sub>1)\\<in>set [].\n                            P u\\<^sub>1 \\<and> \\<not> P v\\<^sub>1\n 2. \\<And>a p aa b u.\n       \\<lbrakk>\\<And>a b u.\n                   \\<lbrakk>path g u p v; P u; (a, b) \\<in> set p;\n                    P a \\<longrightarrow> \\<not> P b\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>(u\\<^sub>1, v\\<^sub>1)\n        \\<in>set p.\n  P u\\<^sub>1 \\<and> \\<not> P v\\<^sub>1;\n        path g u (a # p) v; P u; (aa, b) \\<in> set (a # p);\n        P aa \\<longrightarrow> \\<not> P b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(u\\<^sub>1, v\\<^sub>1)\\<in>set (a # p).\n                            P u\\<^sub>1 \\<and> \\<not> P v\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  \\<exists>(u\\<^sub>1, v\\<^sub>1)\\<in>set p.\n     P u\\<^sub>1 \\<and> \\<not> P v\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>(u\\<^sub>1, v\\<^sub>1)\\<in>set p.\n     P u\\<^sub>1 \\<and> \\<not> P v\\<^sub>1", "obtain u\\<^sub>1 v\\<^sub>1 where \"(u\\<^sub>1,v\\<^sub>1)\\<in>set p\" and PRED1: \"P u\\<^sub>1\" \"\\<not>P v\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<exists>(u\\<^sub>1, v\\<^sub>1)\\<in>set p.\n     P u\\<^sub>1 \\<and> \\<not> P v\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>1 v\\<^sub>1.\n        \\<lbrakk>(u\\<^sub>1, v\\<^sub>1) \\<in> set p; P u\\<^sub>1;\n         \\<not> P v\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (u\\<^sub>1, v\\<^sub>1) \\<in> set p\n  P u\\<^sub>1\n  \\<not> P v\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  (u\\<^sub>1, v\\<^sub>1) \\<in> set p\n  P u\\<^sub>1\n  \\<not> P v\\<^sub>1", "obtain p\\<^sub>1 p\\<^sub>2\\<^sub>3 where [simp]: \"p=p\\<^sub>1@[(u\\<^sub>1,v\\<^sub>1)]@p\\<^sub>2\\<^sub>3\""], ["proof (prove)\nusing this:\n  (u\\<^sub>1, v\\<^sub>1) \\<in> set p\n  P u\\<^sub>1\n  \\<not> P v\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>p\\<^sub>1 p\\<^sub>2\\<^sub>3.\n        p =\n        p\\<^sub>1 @\n        [(u\\<^sub>1, v\\<^sub>1)] @ p\\<^sub>2\\<^sub>3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  p = p\\<^sub>1 @ [(u\\<^sub>1, v\\<^sub>1)] @ p\\<^sub>2\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with P"], ["proof (chain)\npicking this:\n  path g u p v\n  p = p\\<^sub>1 @ [(u\\<^sub>1, v\\<^sub>1)] @ p\\<^sub>2\\<^sub>3", "have \"path g v\\<^sub>1 p\\<^sub>2\\<^sub>3 v\""], ["proof (prove)\nusing this:\n  path g u p v\n  p = p\\<^sub>1 @ [(u\\<^sub>1, v\\<^sub>1)] @ p\\<^sub>2\\<^sub>3\n\ngoal (1 subgoal):\n 1. path g v\\<^sub>1 p\\<^sub>2\\<^sub>3 v", "by auto"], ["proof (state)\nthis:\n  path g v\\<^sub>1 p\\<^sub>2\\<^sub>3 v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from find_crossing_edge_on_path[where P=P, OF this \\<open>\\<not>P v\\<^sub>1\\<close> \\<open>P v\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>u' v'.\n      \\<lbrakk>(u', v') \\<in> set p\\<^sub>2\\<^sub>3; \\<not> P u';\n       P v'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain u\\<^sub>2 v\\<^sub>2 \n    where \"(u\\<^sub>2,v\\<^sub>2)\\<in>set p\\<^sub>2\\<^sub>3\" \"\\<not>P u\\<^sub>2\" \"P v\\<^sub>2\""], ["proof (prove)\nusing this:\n  (\\<And>u' v'.\n      \\<lbrakk>(u', v') \\<in> set p\\<^sub>2\\<^sub>3; \\<not> P u';\n       P v'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>2 v\\<^sub>2.\n        \\<lbrakk>(u\\<^sub>2, v\\<^sub>2) \\<in> set p\\<^sub>2\\<^sub>3;\n         \\<not> P u\\<^sub>2; P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  (u\\<^sub>2, v\\<^sub>2) \\<in> set p\\<^sub>2\\<^sub>3\n  \\<not> P u\\<^sub>2\n  P v\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(u, v)\\<in>set p. P u \\<and> P v \\<Longrightarrow>\n             thesis;\n     \\<And>p\\<^sub>1 u\\<^sub>1 v\\<^sub>1 p\\<^sub>2 u\\<^sub>2 v\\<^sub>2\n        p\\<^sub>3.\n        \\<lbrakk>p =\n                 p\\<^sub>1 @\n                 [(u\\<^sub>1, v\\<^sub>1)] @\n                 p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n         P u\\<^sub>1; \\<not> P v\\<^sub>1; \\<not> P u\\<^sub>2;\n         P v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<not> (\\<forall>(u, v)\\<in>set p. P u \\<and> P v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  (u\\<^sub>2, v\\<^sub>2) \\<in> set p\\<^sub>2\\<^sub>3\n  \\<not> P u\\<^sub>2\n  P v\\<^sub>2", "show thesis"], ["proof (prove)\nusing this:\n  (u\\<^sub>2, v\\<^sub>2) \\<in> set p\\<^sub>2\\<^sub>3\n  \\<not> P u\\<^sub>2\n  P v\\<^sub>2\n\ngoal (1 subgoal):\n 1. thesis", "using PRED1"], ["proof (prove)\nusing this:\n  (u\\<^sub>2, v\\<^sub>2) \\<in> set p\\<^sub>2\\<^sub>3\n  \\<not> P u\\<^sub>2\n  P v\\<^sub>2\n  P u\\<^sub>1\n  \\<not> P v\\<^sub>1\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: in_set_conv_decomp intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_crossing_edge_rtrancl:\n  assumes \"(u,v)\\<in>(edges g)\\<^sup>*\" \"\\<not>P u\" \"P v\"\n  obtains u' v' where \"(u',v')\\<in>edges g\" \"\\<not>P u'\" \"P v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        \\<lbrakk>(u', v') \\<in> edges g; \\<not> P u'; P v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> (edges g)\\<^sup>*\n  \\<not> P u\n  P v\n\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        \\<lbrakk>(u', v') \\<in> edges g; \\<not> P u'; P v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis converse_rtrancl_induct)"], ["", "lemma path_change: \n  assumes \"u\\<in>S\" \"v\\<notin>S\" \"path g u p v\" \"simple p\"\n  obtains x y p1 p2 where \n    \"(x,y) \\<in> set p\" \"x \\<in> S\" \"y \\<notin> S\"\n    \"path (restrict_edges g (-{(x,y),(y,x)})) u p1 x\" \n    \"path (restrict_edges g (-{(x,y),(y,x)})) y p2 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y p1 p2.\n        \\<lbrakk>(x, y) \\<in> set p; x \\<in> S; y \\<notin> S;\n         path (restrict_edges g (- {(x, y), (y, x)})) u p1 x;\n         path (restrict_edges g (- {(x, y), (y, x)})) y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x y p1 p2.\n        \\<lbrakk>(x, y) \\<in> set p; x \\<in> S; y \\<notin> S;\n         path (restrict_edges g (- {(x, y), (y, x)})) u p1 x;\n         path (restrict_edges g (- {(x, y), (y, x)})) y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from find_crossing_edge_on_path[where P=\"\\<lambda>x. x\\<notin>S\"] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>path ?g ?u ?p ?v; \\<not> ?u \\<notin> S; ?v \\<notin> S;\n   \\<And>u' v'.\n      \\<lbrakk>(u', v') \\<in> set ?p; \\<not> u' \\<notin> S;\n       v' \\<notin> S\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  u \\<in> S\n  v \\<notin> S\n  path g u p v\n  simple p", "obtain x y where \n    1: \"(x,y)\\<in>set p\" \"x\\<in>S\" \"y\\<notin>S\""], ["proof (prove)\nusing this:\n  \\<lbrakk>path ?g ?u ?p ?v; \\<not> ?u \\<notin> S; ?v \\<notin> S;\n   \\<And>u' v'.\n      \\<lbrakk>(u', v') \\<in> set ?p; \\<not> u' \\<notin> S;\n       v' \\<notin> S\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  u \\<in> S\n  v \\<notin> S\n  path g u p v\n  simple p\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>(x, y) \\<in> set p; x \\<in> S; y \\<notin> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x, y) \\<in> set p\n  x \\<in> S\n  y \\<notin> S\n\ngoal (1 subgoal):\n 1. (\\<And>x y p1 p2.\n        \\<lbrakk>(x, y) \\<in> set p; x \\<in> S; y \\<notin> S;\n         path (restrict_edges g (- {(x, y), (y, x)})) u p1 x;\n         path (restrict_edges g (- {(x, y), (y, x)})) y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set p\n  x \\<in> S\n  y \\<notin> S", "obtain p1 p2 where [simp]: \"p=p1@[(x,y)]@p2\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> set p\n  x \\<in> S\n  y \\<notin> S\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        p = p1 @ [(x, y)] @ p2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  p = p1 @ [(x, y)] @ p2\n\ngoal (1 subgoal):\n 1. (\\<And>x y p1 p2.\n        \\<lbrakk>(x, y) \\<in> set p; x \\<in> S; y \\<notin> S;\n         path (restrict_edges g (- {(x, y), (y, x)})) u p1 x;\n         path (restrict_edges g (- {(x, y), (y, x)})) y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?g' = \"restrict_edges g (-{(x,y),(y,x)})\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x y p1 p2.\n        \\<lbrakk>(x, y) \\<in> set p; x \\<in> S; y \\<notin> S;\n         path (restrict_edges g (- {(x, y), (y, x)})) u p1 x;\n         path (restrict_edges g (- {(x, y), (y, x)})) y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>path g u p v\\<close>"], ["proof (chain)\npicking this:\n  path g u p v", "have P1: \"path g u p1 x\" and P2: \"path g y p2 v\""], ["proof (prove)\nusing this:\n  path g u p v\n\ngoal (1 subgoal):\n 1. path g u p1 x &&& path g y p2 v", "by auto"], ["proof (state)\nthis:\n  path g u p1 x\n  path g y p2 v\n\ngoal (1 subgoal):\n 1. (\\<And>x y p1 p2.\n        \\<lbrakk>(x, y) \\<in> set p; x \\<in> S; y \\<notin> S;\n         path (restrict_edges g (- {(x, y), (y, x)})) u p1 x;\n         path (restrict_edges g (- {(x, y), (y, x)})) y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>simple p\\<close>"], ["proof (chain)\npicking this:\n  simple p", "have \"uedge (x,y)\\<notin>set (map uedge p1)\" \"uedge (x,y)\\<notin>set (map uedge p2)\""], ["proof (prove)\nusing this:\n  simple p\n\ngoal (1 subgoal):\n 1. uedge (x, y) \\<notin> set (map uedge p1) &&&\n    uedge (x, y) \\<notin> set (map uedge p2)", "by auto"], ["proof (state)\nthis:\n  uedge (x, y) \\<notin> set (map uedge p1)\n  uedge (x, y) \\<notin> set (map uedge p2)\n\ngoal (1 subgoal):\n 1. (\\<And>x y p1 p2.\n        \\<lbrakk>(x, y) \\<in> set p; x \\<in> S; y \\<notin> S;\n         path (restrict_edges g (- {(x, y), (y, x)})) u p1 x;\n         path (restrict_edges g (- {(x, y), (y, x)})) y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  uedge (x, y) \\<notin> set (map uedge p1)\n  uedge (x, y) \\<notin> set (map uedge p2)", "have \"path ?g' u p1 x\" \"path ?g' y p2 v\""], ["proof (prove)\nusing this:\n  uedge (x, y) \\<notin> set (map uedge p1)\n  uedge (x, y) \\<notin> set (map uedge p2)\n\ngoal (1 subgoal):\n 1. path (restrict_edges g (- {(x, y), (y, x)})) u p1 x &&&\n    path (restrict_edges g (- {(x, y), (y, x)})) y p2 v", "using path_graph_cong[OF P1, of ?g'] path_graph_cong[OF P2, of ?g']"], ["proof (prove)\nusing this:\n  uedge (x, y) \\<notin> set (map uedge p1)\n  uedge (x, y) \\<notin> set (map uedge p2)\n  (set p1 \\<subseteq> edges g \\<Longrightarrow>\n   set p1\n   \\<subseteq> edges\n                (restrict_edges g (- {(x, y), (y, x)}))) \\<Longrightarrow>\n  path (restrict_edges g (- {(x, y), (y, x)})) u p1 x\n  (set p2 \\<subseteq> edges g \\<Longrightarrow>\n   set p2\n   \\<subseteq> edges\n                (restrict_edges g (- {(x, y), (y, x)}))) \\<Longrightarrow>\n  path (restrict_edges g (- {(x, y), (y, x)})) y p2 v\n\ngoal (1 subgoal):\n 1. path (restrict_edges g (- {(x, y), (y, x)})) u p1 x &&&\n    path (restrict_edges g (- {(x, y), (y, x)})) y p2 v", "by (auto simp: uedge_in_set_eq)"], ["proof (state)\nthis:\n  path (restrict_edges g (- {(x, y), (y, x)})) u p1 x\n  path (restrict_edges g (- {(x, y), (y, x)})) y p2 v\n\ngoal (1 subgoal):\n 1. (\\<And>x y p1 p2.\n        \\<lbrakk>(x, y) \\<in> set p; x \\<in> S; y \\<notin> S;\n         path (restrict_edges g (- {(x, y), (y, x)})) u p1 x;\n         path (restrict_edges g (- {(x, y), (y, x)})) y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with 1"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set p\n  x \\<in> S\n  y \\<notin> S\n  path (restrict_edges g (- {(x, y), (y, x)})) u p1 x\n  path (restrict_edges g (- {(x, y), (y, x)})) y p2 v", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, y) \\<in> set p\n  x \\<in> S\n  y \\<notin> S\n  path (restrict_edges g (- {(x, y), (y, x)})) u p1 x\n  path (restrict_edges g (- {(x, y), (y, x)})) y p2 v\n\ngoal (1 subgoal):\n 1. thesis", "by (blast intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Cycles\\<close>"], ["", "definition \"cycle_free g \\<equiv> \\<nexists>p u. p\\<noteq>[] \\<and> simple p \\<and> path g u p u\""], ["", "lemma cycle_free_alt_in_nodes: \n  \"cycle_free g \\<equiv> \\<nexists>p u. p\\<noteq>[] \\<and> u\\<in>nodes g \\<and> simple p \\<and> path g u p u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle_free g \\<equiv>\n    \\<nexists>p u.\n       p \\<noteq> [] \\<and>\n       u \\<in> nodes g \\<and> simple p \\<and> path g u p u", "by (smt cycle_free_def path_endpoints(2))"], ["", "lemma cycle_freeI:\n  assumes \"\\<And>p u. \\<lbrakk> path g u p u; p\\<noteq>[]; simple p \\<rbrakk> \\<Longrightarrow> False\"\n  shows \"cycle_free g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle_free g", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. cycle_free g", "unfolding cycle_free_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<nexists>p u. p \\<noteq> [] \\<and> simple p \\<and> path g u p u", "by auto"], ["", "lemma cycle_freeD:\n  assumes \"cycle_free g\" \"path g u p u\" \"p\\<noteq>[]\" \"simple p\" \n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  cycle_free g\n  path g u p u\n  p \\<noteq> []\n  simple p\n\ngoal (1 subgoal):\n 1. False", "unfolding cycle_free_def"], ["proof (prove)\nusing this:\n  \\<nexists>p u. p \\<noteq> [] \\<and> simple p \\<and> path g u p u\n  path g u p u\n  p \\<noteq> []\n  simple p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["", "lemma cycle_free_antimono: \"edges g \\<subseteq> edges g' \\<Longrightarrow> cycle_free g' \\<Longrightarrow> cycle_free g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>edges g \\<subseteq> edges g'; cycle_free g'\\<rbrakk>\n    \\<Longrightarrow> cycle_free g", "unfolding cycle_free_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>edges g \\<subseteq> edges g';\n     \\<nexists>p u.\n        p \\<noteq> [] \\<and> simple p \\<and> path g' u p u\\<rbrakk>\n    \\<Longrightarrow> \\<nexists>p u.\n                         p \\<noteq> [] \\<and> simple p \\<and> path g u p u", "by (auto dest: path_mono)"], ["", "lemma cycle_free_empty[simp]: \"cycle_free graph_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle_free graph_empty", "unfolding cycle_free_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>p u.\n       p \\<noteq> [] \\<and> simple p \\<and> path graph_empty u p u", "by auto"], ["", "lemma cycle_free_no_edges: \"edges g = {} \\<Longrightarrow> cycle_free g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges g = {} \\<Longrightarrow> cycle_free g", "by (rule cycle_freeI) (auto simp: neq_Nil_conv)"], ["", "lemma simple_path_cycle_free_unique:\n  assumes CF: \"cycle_free g\" \n  assumes P: \"path g u p v\" \"path g u p' v\" \"simple p\" \"simple p'\"\n  shows \"p=p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = p'", "using P"], ["proof (prove)\nusing this:\n  path g u p v\n  path g u p' v\n  simple p\n  simple p'\n\ngoal (1 subgoal):\n 1. p = p'", "proof (induction p arbitrary: u p')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u p'.\n       \\<lbrakk>path g u [] v; path g u p' v; simple []; simple p'\\<rbrakk>\n       \\<Longrightarrow> [] = p'\n 2. \\<And>a p u p'.\n       \\<lbrakk>\\<And>u p'.\n                   \\<lbrakk>path g u p v; path g u p' v; simple p;\n                    simple p'\\<rbrakk>\n                   \\<Longrightarrow> p = p';\n        path g u (a # p) v; path g u p' v; simple (a # p);\n        simple p'\\<rbrakk>\n       \\<Longrightarrow> a # p = p'", "case Nil"], ["proof (state)\nthis:\n  path g u [] v\n  path g u p' v\n  simple []\n  simple p'\n\ngoal (2 subgoals):\n 1. \\<And>u p'.\n       \\<lbrakk>path g u [] v; path g u p' v; simple []; simple p'\\<rbrakk>\n       \\<Longrightarrow> [] = p'\n 2. \\<And>a p u p'.\n       \\<lbrakk>\\<And>u p'.\n                   \\<lbrakk>path g u p v; path g u p' v; simple p;\n                    simple p'\\<rbrakk>\n                   \\<Longrightarrow> p = p';\n        path g u (a # p) v; path g u p' v; simple (a # p);\n        simple p'\\<rbrakk>\n       \\<Longrightarrow> a # p = p'", "then"], ["proof (chain)\npicking this:\n  path g u [] v\n  path g u p' v\n  simple []\n  simple p'", "show ?case"], ["proof (prove)\nusing this:\n  path g u [] v\n  path g u p' v\n  simple []\n  simple p'\n\ngoal (1 subgoal):\n 1. [] = p'", "using cycle_freeD[OF CF]"], ["proof (prove)\nusing this:\n  path g u [] v\n  path g u p' v\n  simple []\n  simple p'\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. [] = p'", "by auto"], ["proof (state)\nthis:\n  [] = p'\n\ngoal (1 subgoal):\n 1. \\<And>a p u p'.\n       \\<lbrakk>\\<And>u p'.\n                   \\<lbrakk>path g u p v; path g u p' v; simple p;\n                    simple p'\\<rbrakk>\n                   \\<Longrightarrow> p = p';\n        path g u (a # p) v; path g u p' v; simple (a # p);\n        simple p'\\<rbrakk>\n       \\<Longrightarrow> a # p = p'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p u p'.\n       \\<lbrakk>\\<And>u p'.\n                   \\<lbrakk>path g u p v; path g u p' v; simple p;\n                    simple p'\\<rbrakk>\n                   \\<Longrightarrow> p = p';\n        path g u (a # p) v; path g u p' v; simple (a # p);\n        simple p'\\<rbrakk>\n       \\<Longrightarrow> a # p = p'", "case (Cons e p)"], ["proof (state)\nthis:\n  \\<lbrakk>path g ?u p v; path g ?u ?p' v; simple p; simple ?p'\\<rbrakk>\n  \\<Longrightarrow> p = ?p'\n  path g u (e # p) v\n  path g u p' v\n  simple (e # p)\n  simple p'\n\ngoal (1 subgoal):\n 1. \\<And>a p u p'.\n       \\<lbrakk>\\<And>u p'.\n                   \\<lbrakk>path g u p v; path g u p' v; simple p;\n                    simple p'\\<rbrakk>\n                   \\<Longrightarrow> p = p';\n        path g u (a # p) v; path g u p' v; simple (a # p);\n        simple p'\\<rbrakk>\n       \\<Longrightarrow> a # p = p'", "note CF = cycle_freeD[OF CF]"], ["proof (state)\nthis:\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>a p u p'.\n       \\<lbrakk>\\<And>u p'.\n                   \\<lbrakk>path g u p v; path g u p' v; simple p;\n                    simple p'\\<rbrakk>\n                   \\<Longrightarrow> p = p';\n        path g u (a # p) v; path g u p' v; simple (a # p);\n        simple p'\\<rbrakk>\n       \\<Longrightarrow> a # p = p'", "from Cons.prems"], ["proof (chain)\npicking this:\n  path g u (e # p) v\n  path g u p' v\n  simple (e # p)\n  simple p'", "obtain u' where \n    [simp]: \"e=(u,u')\" \n    and P': \"(u,u')\\<notin>set p\" \"(u',u)\\<notin>set p\" \"(u,u')\\<in>edges g\""], ["proof (prove)\nusing this:\n  path g u (e # p) v\n  path g u p' v\n  simple (e # p)\n  simple p'\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>e = (u, u'); (u, u') \\<notin> set p;\n         (u', u) \\<notin> set p; (u, u') \\<in> edges g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: uedge_in_set_eq)"], ["proof (state)\nthis:\n  e = (u, u')\n  (u, u') \\<notin> set p\n  (u', u) \\<notin> set p\n  (u, u') \\<in> edges g\n\ngoal (1 subgoal):\n 1. \\<And>a p u p'.\n       \\<lbrakk>\\<And>u p'.\n                   \\<lbrakk>path g u p v; path g u p' v; simple p;\n                    simple p'\\<rbrakk>\n                   \\<Longrightarrow> p = p';\n        path g u (a # p) v; path g u p' v; simple (a # p);\n        simple p'\\<rbrakk>\n       \\<Longrightarrow> a # p = p'", "with Cons.prems"], ["proof (chain)\npicking this:\n  path g u (e # p) v\n  path g u p' v\n  simple (e # p)\n  simple p'\n  e = (u, u')\n  (u, u') \\<notin> set p\n  (u', u) \\<notin> set p\n  (u, u') \\<in> edges g", "obtain sp\\<^sub>1 where \n    SP1: \"path g u ((u,u')#sp\\<^sub>1) v\" \"simple ((u,u')#sp\\<^sub>1)\""], ["proof (prove)\nusing this:\n  path g u (e # p) v\n  path g u p' v\n  simple (e # p)\n  simple p'\n  e = (u, u')\n  (u, u') \\<notin> set p\n  (u', u) \\<notin> set p\n  (u, u') \\<in> edges g\n\ngoal (1 subgoal):\n 1. (\\<And>sp\\<^sub>1.\n        \\<lbrakk>path g u ((u, u') # sp\\<^sub>1) v;\n         simple ((u, u') # sp\\<^sub>1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path g u ((u, u') # sp\\<^sub>1) v\n  simple ((u, u') # sp\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>a p u p'.\n       \\<lbrakk>\\<And>u p'.\n                   \\<lbrakk>path g u p v; path g u p' v; simple p;\n                    simple p'\\<rbrakk>\n                   \\<Longrightarrow> p = p';\n        path g u (a # p) v; path g u p' v; simple (a # p);\n        simple p'\\<rbrakk>\n       \\<Longrightarrow> a # p = p'", "from Cons.prems"], ["proof (chain)\npicking this:\n  path g u (e # p) v\n  path g u p' v\n  simple (e # p)\n  simple p'", "obtain u'' p'' where \n    [simp]: \"p' = (u,u'')#p''\" \n    and P'': \"(u,u'')\\<notin>set p''\" \"(u'',u)\\<notin>set p''\" \"(u,u'')\\<in>edges g\""], ["proof (prove)\nusing this:\n  path g u (e # p) v\n  path g u p' v\n  simple (e # p)\n  simple p'\n\ngoal (1 subgoal):\n 1. (\\<And>u'' p''.\n        \\<lbrakk>p' = (u, u'') # p''; (u, u'') \\<notin> set p'';\n         (u'', u) \\<notin> set p''; (u, u'') \\<in> edges g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases p')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>u'' p''.\n                \\<lbrakk>p' = (u, u'') # p''; (u, u'') \\<notin> set p'';\n                 (u'', u) \\<notin> set p''; (u, u'') \\<in> edges g\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     path g u (e # p) v; path g u p' v; simple (e # p); simple p';\n     p' = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>u'' p''.\n                   \\<lbrakk>p' = (u, u'') # p''; (u, u'') \\<notin> set p'';\n                    (u'', u) \\<notin> set p'';\n                    (u, u'') \\<in> edges g\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        path g u (e # p) v; path g u p' v; simple (e # p); simple p';\n        p' = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u'' p''.\n                \\<lbrakk>p' = (u, u'') # p''; (u, u'') \\<notin> set p'';\n                 (u'', u) \\<notin> set p''; (u, u'') \\<in> edges g\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     path g u (e # p) v; path g u p' v; simple (e # p); simple p';\n     p' = []\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto (metis Cons.prems(1) Cons.prems(3) CF list.distinct(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>u'' p''.\n                   \\<lbrakk>p' = (u, u'') # p''; (u, u'') \\<notin> set p'';\n                    (u'', u) \\<notin> set p'';\n                    (u, u'') \\<in> edges g\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        path g u (e # p) v; path g u p' v; simple (e # p); simple p';\n        p' = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (auto simp: uedge_in_set_eq)"], ["proof (state)\nthis:\n  p' = (u, u'') # p''\n  (u, u'') \\<notin> set p''\n  (u'', u) \\<notin> set p''\n  (u, u'') \\<in> edges g\n\ngoal (1 subgoal):\n 1. \\<And>a p u p'.\n       \\<lbrakk>\\<And>u p'.\n                   \\<lbrakk>path g u p v; path g u p' v; simple p;\n                    simple p'\\<rbrakk>\n                   \\<Longrightarrow> p = p';\n        path g u (a # p) v; path g u p' v; simple (a # p);\n        simple p'\\<rbrakk>\n       \\<Longrightarrow> a # p = p'", "with Cons.prems"], ["proof (chain)\npicking this:\n  path g u (e # p) v\n  path g u p' v\n  simple (e # p)\n  simple p'\n  p' = (u, u'') # p''\n  (u, u'') \\<notin> set p''\n  (u'', u) \\<notin> set p''\n  (u, u'') \\<in> edges g", "obtain sp\\<^sub>2 where \n    SP2: \"path g u ((u,u'')#sp\\<^sub>2) v\" \"simple ((u,u'')#sp\\<^sub>2)\""], ["proof (prove)\nusing this:\n  path g u (e # p) v\n  path g u p' v\n  simple (e # p)\n  simple p'\n  p' = (u, u'') # p''\n  (u, u'') \\<notin> set p''\n  (u'', u) \\<notin> set p''\n  (u, u'') \\<in> edges g\n\ngoal (1 subgoal):\n 1. (\\<And>sp\\<^sub>2.\n        \\<lbrakk>path g u ((u, u'') # sp\\<^sub>2) v;\n         simple ((u, u'') # sp\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path g u ((u, u'') # sp\\<^sub>2) v\n  simple ((u, u'') # sp\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a p u p'.\n       \\<lbrakk>\\<And>u p'.\n                   \\<lbrakk>path g u p v; path g u p' v; simple p;\n                    simple p'\\<rbrakk>\n                   \\<Longrightarrow> p = p';\n        path g u (a # p) v; path g u p' v; simple (a # p);\n        simple p'\\<rbrakk>\n       \\<Longrightarrow> a # p = p'", "have \"u''=u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u'' = u'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. u'' \\<noteq> u' \\<Longrightarrow> False", "assume [simp, symmetric, simp]: \"u''\\<noteq>u'\""], ["proof (state)\nthis:\n  u' \\<noteq> u''\n\ngoal (1 subgoal):\n 1. u'' \\<noteq> u' \\<Longrightarrow> False", "have AUX1: \"(u,x)\\<notin>set sp\\<^sub>1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, x) \\<notin> set sp\\<^sub>1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (u, x) \\<in> set sp\\<^sub>1 \\<Longrightarrow> False", "assume \"(u, x) \\<in> set sp\\<^sub>1\""], ["proof (state)\nthis:\n  (u, x) \\<in> set sp\\<^sub>1\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> set sp\\<^sub>1 \\<Longrightarrow> False", "with SP1"], ["proof (chain)\npicking this:\n  path g u ((u, u') # sp\\<^sub>1) v\n  simple ((u, u') # sp\\<^sub>1)\n  (u, x) \\<in> set sp\\<^sub>1", "obtain sp' where \"path g u ((u,u')#sp') u\" and \"simple ((u,u')#sp')\""], ["proof (prove)\nusing this:\n  path g u ((u, u') # sp\\<^sub>1) v\n  simple ((u, u') # sp\\<^sub>1)\n  (u, x) \\<in> set sp\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>sp'.\n        \\<lbrakk>path g u ((u, u') # sp') u; simple ((u, u') # sp')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: in_set_conv_decomp; blast)"], ["proof (state)\nthis:\n  path g u ((u, u') # sp') u\n  simple ((u, u') # sp')\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> set sp\\<^sub>1 \\<Longrightarrow> False", "with CF"], ["proof (chain)\npicking this:\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n  path g u ((u, u') # sp') u\n  simple ((u, u') # sp')", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n  path g u ((u, u') # sp') u\n  simple ((u, u') # sp')\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, ?x) \\<notin> set sp\\<^sub>1\n\ngoal (1 subgoal):\n 1. u'' \\<noteq> u' \\<Longrightarrow> False", "have AUX2:\"(x,u)\\<notin>set sp\\<^sub>1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, u) \\<notin> set sp\\<^sub>1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, u) \\<in> set sp\\<^sub>1 \\<Longrightarrow> False", "assume \"(x, u) \\<in> set sp\\<^sub>1\""], ["proof (state)\nthis:\n  (x, u) \\<in> set sp\\<^sub>1\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> set sp\\<^sub>1 \\<Longrightarrow> False", "with SP1"], ["proof (chain)\npicking this:\n  path g u ((u, u') # sp\\<^sub>1) v\n  simple ((u, u') # sp\\<^sub>1)\n  (x, u) \\<in> set sp\\<^sub>1", "obtain sp' where \"path g u ((u,u')#sp') u\" and \"simple ((u,u')#sp')\""], ["proof (prove)\nusing this:\n  path g u ((u, u') # sp\\<^sub>1) v\n  simple ((u, u') # sp\\<^sub>1)\n  (x, u) \\<in> set sp\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>sp'.\n        \\<lbrakk>path g u ((u, u') # sp') u; simple ((u, u') # sp')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (clarsimp simp: in_set_conv_decomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>\\<And>sp'.\n                   \\<lbrakk>path g u' sp' u;\n                    uedge (u, u') \\<notin> uedge ` set sp' \\<and>\n                    simple sp'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        sp\\<^sub>1 = ys @ (x, u) # zs; (u, u') \\<in> edges g;\n        path g u' ys x; uedge (u, u') \\<noteq> uedge (x, u);\n        uedge (u, u') \\<notin> uedge ` (set ys \\<union> set zs); simple ys;\n        (x, u) \\<in> edges g; path g u zs v;\n        uedge (x, u) \\<notin> uedge ` set zs; simple zs;\n        uedge (x, u) \\<notin> uedge ` set ys;\n        uedge ` set ys \\<inter> uedge ` set zs = {}\\<rbrakk>\n       \\<Longrightarrow> thesis", "(* TODO: Do more explicit, like other AUXes*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>\\<And>sp'.\n                   \\<lbrakk>path g u' sp' u;\n                    uedge (u, u') \\<notin> uedge ` set sp' \\<and>\n                    simple sp'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        sp\\<^sub>1 = ys @ (x, u) # zs; (u, u') \\<in> edges g;\n        path g u' ys x; uedge (u, u') \\<noteq> uedge (x, u);\n        uedge (u, u') \\<notin> uedge ` (set ys \\<union> set zs); simple ys;\n        (x, u) \\<in> edges g; path g u zs v;\n        uedge (x, u) \\<notin> uedge ` set zs; simple zs;\n        uedge (x, u) \\<notin> uedge ` set ys;\n        uedge ` set ys \\<inter> uedge ` set zs = {}\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (metis Cons.prems(1) Cons.prems(3) Un_iff \n        AUX1 \\<open>e = (u, u')\\<close> insert_iff list.simps(15) \n        path.elims(2) path.simps(2) prod.sel(2) set_append simple_cons)"], ["proof (state)\nthis:\n  path g u ((u, u') # sp') u\n  simple ((u, u') # sp')\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> set sp\\<^sub>1 \\<Longrightarrow> False", "with CF"], ["proof (chain)\npicking this:\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n  path g u ((u, u') # sp') u\n  simple ((u, u') # sp')", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n  path g u ((u, u') # sp') u\n  simple ((u, u') # sp')\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?x, u) \\<notin> set sp\\<^sub>1\n\ngoal (1 subgoal):\n 1. u'' \\<noteq> u' \\<Longrightarrow> False", "have AUX3:\"(u,x)\\<notin>set sp\\<^sub>2\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, x) \\<notin> set sp\\<^sub>2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (u, x) \\<in> set sp\\<^sub>2 \\<Longrightarrow> False", "assume \"(u, x) \\<in> set sp\\<^sub>2\""], ["proof (state)\nthis:\n  (u, x) \\<in> set sp\\<^sub>2\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> set sp\\<^sub>2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (u, x) \\<in> set sp\\<^sub>2", "obtain sp' sp'' where [simp]: \"sp\\<^sub>2 = sp'@[(u,x)]@sp''\""], ["proof (prove)\nusing this:\n  (u, x) \\<in> set sp\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>sp' sp''.\n        sp\\<^sub>2 = sp' @ [(u, x)] @ sp'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  sp\\<^sub>2 = sp' @ [(u, x)] @ sp''\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> set sp\\<^sub>2 \\<Longrightarrow> False", "from SP2"], ["proof (chain)\npicking this:\n  path g u ((u, u'') # sp\\<^sub>2) v\n  simple ((u, u'') # sp\\<^sub>2)", "have \"path g u ((u,u'')#sp') u\" \"simple ((u,u'')#sp')\""], ["proof (prove)\nusing this:\n  path g u ((u, u'') # sp\\<^sub>2) v\n  simple ((u, u'') # sp\\<^sub>2)\n\ngoal (1 subgoal):\n 1. path g u ((u, u'') # sp') u &&& simple ((u, u'') # sp')", "by auto"], ["proof (state)\nthis:\n  path g u ((u, u'') # sp') u\n  simple ((u, u'') # sp')\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> set sp\\<^sub>2 \\<Longrightarrow> False", "with CF"], ["proof (chain)\npicking this:\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n  path g u ((u, u'') # sp') u\n  simple ((u, u'') # sp')", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n  path g u ((u, u'') # sp') u\n  simple ((u, u'') # sp')\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, ?x) \\<notin> set sp\\<^sub>2\n\ngoal (1 subgoal):\n 1. u'' \\<noteq> u' \\<Longrightarrow> False", "have AUX4:\"(x,u)\\<notin>set sp\\<^sub>2\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, u) \\<notin> set sp\\<^sub>2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, u) \\<in> set sp\\<^sub>2 \\<Longrightarrow> False", "assume \"(x, u) \\<in> set sp\\<^sub>2\""], ["proof (state)\nthis:\n  (x, u) \\<in> set sp\\<^sub>2\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> set sp\\<^sub>2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (x, u) \\<in> set sp\\<^sub>2", "obtain sp' sp'' where [simp]: \"sp\\<^sub>2 = sp'@[(x,u)]@sp''\""], ["proof (prove)\nusing this:\n  (x, u) \\<in> set sp\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>sp' sp''.\n        sp\\<^sub>2 = sp' @ [(x, u)] @ sp'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  sp\\<^sub>2 = sp' @ [(x, u)] @ sp''\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> set sp\\<^sub>2 \\<Longrightarrow> False", "from SP2"], ["proof (chain)\npicking this:\n  path g u ((u, u'') # sp\\<^sub>2) v\n  simple ((u, u'') # sp\\<^sub>2)", "have \"path g u ((u,u'')#sp'@[(x,u)]) u\" \"simple ((u,u'')#sp'@[(x,u)])\""], ["proof (prove)\nusing this:\n  path g u ((u, u'') # sp\\<^sub>2) v\n  simple ((u, u'') # sp\\<^sub>2)\n\ngoal (1 subgoal):\n 1. path g u ((u, u'') # sp' @ [(x, u)]) u &&&\n    simple ((u, u'') # sp' @ [(x, u)])", "by auto"], ["proof (state)\nthis:\n  path g u ((u, u'') # sp' @ [(x, u)]) u\n  simple ((u, u'') # sp' @ [(x, u)])\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> set sp\\<^sub>2 \\<Longrightarrow> False", "with CF"], ["proof (chain)\npicking this:\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n  path g u ((u, u'') # sp' @ [(x, u)]) u\n  simple ((u, u'') # sp' @ [(x, u)])", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n  path g u ((u, u'') # sp' @ [(x, u)]) u\n  simple ((u, u'') # sp' @ [(x, u)])\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?x, u) \\<notin> set sp\\<^sub>2\n\ngoal (1 subgoal):\n 1. u'' \\<noteq> u' \\<Longrightarrow> False", "have [simp]: \"set (revp p) = (set p)\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (revp p) = (set p)\\<inverse>", "by auto"], ["proof (state)\nthis:\n  set (revp p) = (set p)\\<inverse>\n\ngoal (1 subgoal):\n 1. u'' \\<noteq> u' \\<Longrightarrow> False", "from SP1 SP2"], ["proof (chain)\npicking this:\n  path g u ((u, u') # sp\\<^sub>1) v\n  simple ((u, u') # sp\\<^sub>1)\n  path g u ((u, u'') # sp\\<^sub>2) v\n  simple ((u, u'') # sp\\<^sub>2)", "have \"path g u' (sp\\<^sub>1@revp sp\\<^sub>2) u''\""], ["proof (prove)\nusing this:\n  path g u ((u, u') # sp\\<^sub>1) v\n  simple ((u, u') # sp\\<^sub>1)\n  path g u ((u, u'') # sp\\<^sub>2) v\n  simple ((u, u'') # sp\\<^sub>2)\n\ngoal (1 subgoal):\n 1. path g u' (sp\\<^sub>1 @ revp sp\\<^sub>2) u''", "by auto"], ["proof (state)\nthis:\n  path g u' (sp\\<^sub>1 @ revp sp\\<^sub>2) u''\n\ngoal (1 subgoal):\n 1. u'' \\<noteq> u' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path g u' (sp\\<^sub>1 @ revp sp\\<^sub>2) u''", "obtain sp where \n      SP: \"path g u' sp u''\" \"simple sp\" \"set sp \\<subseteq> set sp\\<^sub>1 \\<union> set (revp sp\\<^sub>2)\""], ["proof (prove)\nusing this:\n  path g u' (sp\\<^sub>1 @ revp sp\\<^sub>2) u''\n\ngoal (1 subgoal):\n 1. (\\<And>sp.\n        \\<lbrakk>path g u' sp u''; simple sp;\n         set sp\n         \\<subseteq> set sp\\<^sub>1 \\<union> set (revp sp\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule_tac simplify_pathE) auto"], ["proof (state)\nthis:\n  path g u' sp u''\n  simple sp\n  set sp \\<subseteq> set sp\\<^sub>1 \\<union> set (revp sp\\<^sub>2)\n\ngoal (1 subgoal):\n 1. u'' \\<noteq> u' \\<Longrightarrow> False", "with \\<open>(u,u')\\<in>edges g\\<close> \\<open>(u,u'')\\<in>edges g\\<close>"], ["proof (chain)\npicking this:\n  (u, u') \\<in> edges g\n  (u, u'') \\<in> edges g\n  path g u' sp u''\n  simple sp\n  set sp \\<subseteq> set sp\\<^sub>1 \\<union> set (revp sp\\<^sub>2)", "have \"path g u ((u,u')#sp@[(u'',u)]) u\""], ["proof (prove)\nusing this:\n  (u, u') \\<in> edges g\n  (u, u'') \\<in> edges g\n  path g u' sp u''\n  simple sp\n  set sp \\<subseteq> set sp\\<^sub>1 \\<union> set (revp sp\\<^sub>2)\n\ngoal (1 subgoal):\n 1. path g u ((u, u') # sp @ [(u'', u)]) u", "by (auto dest: edges_sym' simp: uedge_eq_iff)"], ["proof (state)\nthis:\n  path g u ((u, u') # sp @ [(u'', u)]) u\n\ngoal (1 subgoal):\n 1. u'' \\<noteq> u' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  path g u ((u, u') # sp @ [(u'', u)]) u\n\ngoal (1 subgoal):\n 1. u'' \\<noteq> u' \\<Longrightarrow> False", "from SP SP1 SP2 AUX1 AUX2 AUX3 AUX4"], ["proof (chain)\npicking this:\n  path g u' sp u''\n  simple sp\n  set sp \\<subseteq> set sp\\<^sub>1 \\<union> set (revp sp\\<^sub>2)\n  path g u ((u, u') # sp\\<^sub>1) v\n  simple ((u, u') # sp\\<^sub>1)\n  path g u ((u, u'') # sp\\<^sub>2) v\n  simple ((u, u'') # sp\\<^sub>2)\n  (u, ?x) \\<notin> set sp\\<^sub>1\n  (?x, u) \\<notin> set sp\\<^sub>1\n  (u, ?x) \\<notin> set sp\\<^sub>2\n  (?x, u) \\<notin> set sp\\<^sub>2", "have \"simple (((u,u')#sp@[(u'',u)]))\""], ["proof (prove)\nusing this:\n  path g u' sp u''\n  simple sp\n  set sp \\<subseteq> set sp\\<^sub>1 \\<union> set (revp sp\\<^sub>2)\n  path g u ((u, u') # sp\\<^sub>1) v\n  simple ((u, u') # sp\\<^sub>1)\n  path g u ((u, u'') # sp\\<^sub>2) v\n  simple ((u, u'') # sp\\<^sub>2)\n  (u, ?x) \\<notin> set sp\\<^sub>1\n  (?x, u) \\<notin> set sp\\<^sub>1\n  (u, ?x) \\<notin> set sp\\<^sub>2\n  (?x, u) \\<notin> set sp\\<^sub>2\n\ngoal (1 subgoal):\n 1. simple ((u, u') # sp @ [(u'', u)])", "by (auto 0 3 simp: uedge_eq_iff)"], ["proof (state)\nthis:\n  simple ((u, u') # sp @ [(u'', u)])\n\ngoal (1 subgoal):\n 1. u'' \\<noteq> u' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  path g u ((u, u') # sp @ [(u'', u)]) u\n  simple ((u, u') # sp @ [(u'', u)])", "show False"], ["proof (prove)\nusing this:\n  path g u ((u, u') # sp @ [(u'', u)]) u\n  simple ((u, u') # sp @ [(u'', u)])\n\ngoal (1 subgoal):\n 1. False", "using CF"], ["proof (prove)\nusing this:\n  path g u ((u, u') # sp @ [(u'', u)]) u\n  simple ((u, u') # sp @ [(u'', u)])\n  \\<lbrakk>path g ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u'' = u'\n\ngoal (1 subgoal):\n 1. \\<And>a p u p'.\n       \\<lbrakk>\\<And>u p'.\n                   \\<lbrakk>path g u p v; path g u p' v; simple p;\n                    simple p'\\<rbrakk>\n                   \\<Longrightarrow> p = p';\n        path g u (a # p) v; path g u p' v; simple (a # p);\n        simple p'\\<rbrakk>\n       \\<Longrightarrow> a # p = p'", "with Cons.IH[of u' p''] Cons.prems"], ["proof (chain)\npicking this:\n  \\<lbrakk>path g u' p v; path g u' p'' v; simple p; simple p''\\<rbrakk>\n  \\<Longrightarrow> p = p''\n  path g u (e # p) v\n  path g u p' v\n  simple (e # p)\n  simple p'\n  u'' = u'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>path g u' p v; path g u' p'' v; simple p; simple p''\\<rbrakk>\n  \\<Longrightarrow> p = p''\n  path g u (e # p) v\n  path g u p' v\n  simple (e # p)\n  simple p'\n  u'' = u'\n\ngoal (1 subgoal):\n 1. e # p = p'", "by simp"], ["proof (state)\nthis:\n  e # p = p'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Characterization by Removing Edge\\<close>"], ["", "lemma cycle_free_alt: \"cycle_free g \n  \\<longleftrightarrow> (\\<forall>e\\<in>edges g. e\\<notin>(edges (restrict_edges g (-{e,prod.swap e})))\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle_free g =\n    (\\<forall>e\\<in>edges g.\n        e \\<notin> (edges (restrict_edges g (- {e, prod.swap e})))\\<^sup>*)", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cycle_free g \\<Longrightarrow>\n    \\<forall>e\\<in>edges g.\n       e \\<notin> (edges (restrict_edges g (- {e, prod.swap e})))\\<^sup>*\n 2. \\<forall>e\\<in>edges g.\n       e \\<notin> (edges\n                    (restrict_edges g\n                      (- {e, prod.swap e})))\\<^sup>* \\<Longrightarrow>\n    cycle_free g", "apply (clarsimp simp del: edges_restrict_edges)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>cycle_free g; (a, b) \\<in> edges g;\n        (a, b)\n        \\<in> (edges\n                (restrict_edges g (- {(a, b), (b, a)})))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>e\\<in>edges g.\n       e \\<notin> (edges\n                    (restrict_edges g\n                      (- {e, prod.swap e})))\\<^sup>* \\<Longrightarrow>\n    cycle_free g", "subgoal premises prems for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "note edges_restrict_edges[simp del]"], ["proof (state)\nthis:\n  edges (restrict_edges ?g ?E) =\n  edges ?g \\<inter> (?E \\<union> ?E\\<inverse>)\n\ngoal (1 subgoal):\n 1. False", "let ?rg = \"(restrict_edges g (- {(u,v), (v,u)}))\""], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from \\<open>(u, v) \\<in> (edges ?rg)\\<^sup>*\\<close>"], ["proof (chain)\npicking this:\n  (u, v) \\<in> (edges (restrict_edges g (- {(u, v), (v, u)})))\\<^sup>*", "obtain p where P: \"path ?rg u p v\" and \"simple p\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> (edges (restrict_edges g (- {(u, v), (v, u)})))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path (restrict_edges g (- {(u, v), (v, u)})) u p v;\n         simple p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: rtrancl_edges_iff_path elim: simplify_pathE)"], ["proof (state)\nthis:\n  path (restrict_edges g (- {(u, v), (v, u)})) u p v\n  simple p\n\ngoal (1 subgoal):\n 1. False", "from P"], ["proof (chain)\npicking this:\n  path (restrict_edges g (- {(u, v), (v, u)})) u p v", "have \"path g u p v\""], ["proof (prove)\nusing this:\n  path (restrict_edges g (- {(u, v), (v, u)})) u p v\n\ngoal (1 subgoal):\n 1. path g u p v", "by (rule unrestricte_path)"], ["proof (state)\nthis:\n  path g u p v\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  path g u p v\n\ngoal (1 subgoal):\n 1. False", "note \\<open>(u, v) \\<in> edges g\\<close>"], ["proof (state)\nthis:\n  (u, v) \\<in> edges g\n\ngoal (1 subgoal):\n 1. False", "finally"], ["proof (chain)\npicking this:\n  path g u (p @ [(v, u)]) u", "have \"path g u (p @ [(v, u)]) u\""], ["proof (prove)\nusing this:\n  path g u (p @ [(v, u)]) u\n\ngoal (1 subgoal):\n 1. path g u (p @ [(v, u)]) u", "."], ["proof (state)\nthis:\n  path g u (p @ [(v, u)]) u\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  path g u (p @ [(v, u)]) u\n\ngoal (1 subgoal):\n 1. False", "from path_edges[OF P]"], ["proof (chain)\npicking this:\n  set p \\<subseteq> edges (restrict_edges g (- {(u, v), (v, u)}))", "have \"uedge (u,v) \\<notin> set (map uedge p)\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> edges (restrict_edges g (- {(u, v), (v, u)}))\n\ngoal (1 subgoal):\n 1. uedge (u, v) \\<notin> set (map uedge p)", "by (auto simp: uedge_eq_iff edges_restrict_edges)"], ["proof (state)\nthis:\n  uedge (u, v) \\<notin> set (map uedge p)\n\ngoal (1 subgoal):\n 1. False", "with \\<open>simple p\\<close>"], ["proof (chain)\npicking this:\n  simple p\n  uedge (u, v) \\<notin> set (map uedge p)", "have \"simple (p @ [(v, u)])\""], ["proof (prove)\nusing this:\n  simple p\n  uedge (u, v) \\<notin> set (map uedge p)\n\ngoal (1 subgoal):\n 1. simple (p @ [(v, u)])", "by (auto simp: uedge_eq_iff uedge_in_set_eq)"], ["proof (state)\nthis:\n  simple (p @ [(v, u)])\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  path g u (p @ [(v, u)]) u\n  simple (p @ [(v, u)])", "show ?thesis"], ["proof (prove)\nusing this:\n  path g u (p @ [(v, u)]) u\n  simple (p @ [(v, u)])\n\ngoal (1 subgoal):\n 1. False", "using \\<open>cycle_free g\\<close>"], ["proof (prove)\nusing this:\n  path g u (p @ [(v, u)]) u\n  simple (p @ [(v, u)])\n  cycle_free g\n\ngoal (1 subgoal):\n 1. False", "unfolding cycle_free_def"], ["proof (prove)\nusing this:\n  path g u (p @ [(v, u)]) u\n  simple (p @ [(v, u)])\n  \\<nexists>p u. p \\<noteq> [] \\<and> simple p \\<and> path g u p u\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>edges g.\n       e \\<notin> (edges\n                    (restrict_edges g\n                      (- {e, prod.swap e})))\\<^sup>* \\<Longrightarrow>\n    cycle_free g", "apply (clarsimp simp: cycle_free_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p u.\n       \\<lbrakk>\\<forall>e\\<in>edges g.\n                   e \\<notin> (edges g \\<inter>\n                               (- {e, prod.swap e} \\<union>\n                                (- {e, prod.swap e})\\<inverse>))\\<^sup>*;\n        simple p; p \\<noteq> []; path g u p u\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal premises prems for p u"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from \\<open>p\\<noteq>[]\\<close> \\<open>path g u p u\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  path g u p u", "obtain v p' where \n      [simp]: \"p=(u,v)#p'\" and \"(u,v)\\<in>edges g\" \"path g v p' u\""], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  path g u p u\n\ngoal (1 subgoal):\n 1. (\\<And>v p'.\n        \\<lbrakk>p = (u, v) # p'; (u, v) \\<in> edges g;\n         path g v p' u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p) auto"], ["proof (state)\nthis:\n  p = (u, v) # p'\n  (u, v) \\<in> edges g\n  path g v p' u\n\ngoal (1 subgoal):\n 1. False", "from \\<open>simple p\\<close>"], ["proof (chain)\npicking this:\n  simple p", "have \"simple p'\" \"uedge (u,v) \\<notin> set (map uedge p')\""], ["proof (prove)\nusing this:\n  simple p\n\ngoal (1 subgoal):\n 1. simple p' &&& uedge (u, v) \\<notin> set (map uedge p')", "by auto"], ["proof (state)\nthis:\n  simple p'\n  uedge (u, v) \\<notin> set (map uedge p')\n\ngoal (1 subgoal):\n 1. False", "hence \"(u,v)\\<notin>set p'\" \"(v,u)\\<notin>set p'\""], ["proof (prove)\nusing this:\n  simple p'\n  uedge (u, v) \\<notin> set (map uedge p')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> set p' &&& (v, u) \\<notin> set p'", "by (auto simp: uedge_in_set_eq)"], ["proof (state)\nthis:\n  (u, v) \\<notin> set p'\n  (v, u) \\<notin> set p'\n\ngoal (1 subgoal):\n 1. False", "with \\<open>path g v p' u\\<close>"], ["proof (chain)\npicking this:\n  path g v p' u\n  (u, v) \\<notin> set p'\n  (v, u) \\<notin> set p'", "have \"path (restrict_edges g (-{(u,v),(v,u)})) v p' u\" (is \"path ?rg _ _ _\")"], ["proof (prove)\nusing this:\n  path g v p' u\n  (u, v) \\<notin> set p'\n  (v, u) \\<notin> set p'\n\ngoal (1 subgoal):\n 1. path (restrict_edges g (- {(u, v), (v, u)})) v p' u", "by (erule_tac path_graph_cong) auto"], ["proof (state)\nthis:\n  path (restrict_edges g (- {(u, v), (v, u)})) v p' u\n\ngoal (1 subgoal):\n 1. False", "hence \"(u,v)\\<in>(edges ?rg)\\<^sup>*\""], ["proof (prove)\nusing this:\n  path (restrict_edges g (- {(u, v), (v, u)})) v p' u\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (edges (restrict_edges g (- {(u, v), (v, u)})))\\<^sup>*", "by (meson path_rev rtrancl_edges_iff_path)"], ["proof (state)\nthis:\n  (u, v) \\<in> (edges (restrict_edges g (- {(u, v), (v, u)})))\\<^sup>*\n\ngoal (1 subgoal):\n 1. False", "with prems(1) \\<open>(u,v)\\<in>edges g\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>e\\<in>edges g.\n     e \\<notin> (edges g \\<inter>\n                 (- {e, prod.swap e} \\<union>\n                  (- {e, prod.swap e})\\<inverse>))\\<^sup>*\n  (u, v) \\<in> edges g\n  (u, v) \\<in> (edges (restrict_edges g (- {(u, v), (v, u)})))\\<^sup>*", "show False"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>edges g.\n     e \\<notin> (edges g \\<inter>\n                 (- {e, prod.swap e} \\<union>\n                  (- {e, prod.swap e})\\<inverse>))\\<^sup>*\n  (u, v) \\<in> edges g\n  (u, v) \\<in> (edges (restrict_edges g (- {(u, v), (v, u)})))\\<^sup>*\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cycle_free_altI:\n  assumes \"\\<And>u v. \\<lbrakk> (u,v)\\<in>edges g; (u,v)\\<in>(edges g - {(u,v),(v,u)})\\<^sup>* \\<rbrakk> \\<Longrightarrow> False\"\n  shows \"cycle_free g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle_free g", "unfolding cycle_free_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>edges g.\n       e \\<notin> (edges (restrict_edges g (- {e, prod.swap e})))\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?u, ?v) \\<in> edges g;\n   (?u, ?v) \\<in> (edges g - {(?u, ?v), (?v, ?u)})\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>edges g.\n       e \\<notin> (edges (restrict_edges g (- {e, prod.swap e})))\\<^sup>*", "by (force)"], ["", "lemma cycle_free_altD:  \n  assumes \"cycle_free g\"\n  assumes \"(u,v)\\<in>edges g\" \n  shows \"(u,v)\\<notin>(edges g - {(u,v),(v,u)})\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<notin> (edges g - {(u, v), (v, u)})\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  cycle_free g\n  (u, v) \\<in> edges g\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> (edges g - {(u, v), (v, u)})\\<^sup>*", "unfolding cycle_free_alt"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>edges g.\n     e \\<notin> (edges (restrict_edges g (- {e, prod.swap e})))\\<^sup>*\n  (u, v) \\<in> edges g\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> (edges g - {(u, v), (v, u)})\\<^sup>*", "by (auto)"], ["", "lemma remove_redundant_edge:\n  assumes \"(u, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\"  \n  shows \"(edges g - {(u, v), (v, u)})\\<^sup>* = (edges g)\\<^sup>*\" (is \"?E'\\<^sup>* = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (edges g - {(u, v), (v, u)})\\<^sup>* = (edges g)\\<^sup>*", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (edges g - {(u, v), (v, u)})\\<^sup>* \\<subseteq> (edges g)\\<^sup>*\n 2. (edges g)\\<^sup>* \\<subseteq> (edges g - {(u, v), (v, u)})\\<^sup>*", "show \"?E'\\<^sup>* \\<subseteq> (edges g)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edges g - {(u, v), (v, u)})\\<^sup>* \\<subseteq> (edges g)\\<^sup>*", "by (simp add: Diff_subset rtrancl_mono)"], ["proof (state)\nthis:\n  (edges g - {(u, v), (v, u)})\\<^sup>* \\<subseteq> (edges g)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (edges g)\\<^sup>* \\<subseteq> (edges g - {(u, v), (v, u)})\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (edges g)\\<^sup>* \\<subseteq> (edges g - {(u, v), (v, u)})\\<^sup>*", "show \"(edges g)\\<^sup>* \\<subseteq> ?E'\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edges g)\\<^sup>* \\<subseteq> (edges g - {(u, v), (v, u)})\\<^sup>*", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> (edges g)\\<^sup>* \\<Longrightarrow>\n       (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> (edges g)\\<^sup>* \\<Longrightarrow>\n       (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "assume \"(a,b)\\<in>(edges g)\\<^sup>*\""], ["proof (state)\nthis:\n  (a, b) \\<in> (edges g)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> (edges g)\\<^sup>* \\<Longrightarrow>\n       (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> (edges g)\\<^sup>*", "show \"(a,b)\\<in>?E'\\<^sup>*\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> (edges g)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. (a, a) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(a, y) \\<in> (edges g)\\<^sup>*; (y, z) \\<in> edges g;\n        (a, y) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (a, a) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(a, y) \\<in> (edges g)\\<^sup>*; (y, z) \\<in> edges g;\n        (a, y) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, a) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (a, a) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(a, y) \\<in> (edges g)\\<^sup>*; (y, z) \\<in> edges g;\n        (a, y) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(a, y) \\<in> (edges g)\\<^sup>*; (y, z) \\<in> edges g;\n        (a, y) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "case (step b c)"], ["proof (state)\nthis:\n  (a, b) \\<in> (edges g)\\<^sup>*\n  (b, c) \\<in> edges g\n  (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(a, y) \\<in> (edges g)\\<^sup>*; (y, z) \\<in> edges g;\n        (a, y) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> (edges g)\\<^sup>*\n  (b, c) \\<in> edges g\n  (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  (a, b) \\<in> (edges g)\\<^sup>*\n  (b, c) \\<in> edges g\n  (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "proof (cases \"(b,c)\\<in>{(u,v),(v,u)}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(a, b) \\<in> (edges g)\\<^sup>*; (b, c) \\<in> edges g;\n     (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*;\n     (b, c) \\<in> {(u, v), (v, u)}\\<rbrakk>\n    \\<Longrightarrow> (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n 2. \\<lbrakk>(a, b) \\<in> (edges g)\\<^sup>*; (b, c) \\<in> edges g;\n     (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*;\n     (b, c) \\<notin> {(u, v), (v, u)}\\<rbrakk>\n    \\<Longrightarrow> (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "case True"], ["proof (state)\nthis:\n  (b, c) \\<in> {(u, v), (v, u)}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(a, b) \\<in> (edges g)\\<^sup>*; (b, c) \\<in> edges g;\n     (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*;\n     (b, c) \\<in> {(u, v), (v, u)}\\<rbrakk>\n    \\<Longrightarrow> (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n 2. \\<lbrakk>(a, b) \\<in> (edges g)\\<^sup>*; (b, c) \\<in> edges g;\n     (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*;\n     (b, c) \\<notin> {(u, v), (v, u)}\\<rbrakk>\n    \\<Longrightarrow> (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "have SYME: \"sym (?E'\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym ((edges g - {(u, v), (v, u)})\\<^sup>*)", "apply (rule sym_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (edges g - {(u, v), (v, u)})", "using edges_sym[of g]"], ["proof (prove)\nusing this:\n  sym (edges g)\n\ngoal (1 subgoal):\n 1. sym (edges g - {(u, v), (v, u)})", "by (auto simp: sym_def)"], ["proof (state)\nthis:\n  sym ((edges g - {(u, v), (v, u)})\\<^sup>*)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(a, b) \\<in> (edges g)\\<^sup>*; (b, c) \\<in> edges g;\n     (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*;\n     (b, c) \\<in> {(u, v), (v, u)}\\<rbrakk>\n    \\<Longrightarrow> (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n 2. \\<lbrakk>(a, b) \\<in> (edges g)\\<^sup>*; (b, c) \\<in> edges g;\n     (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*;\n     (b, c) \\<notin> {(u, v), (v, u)}\\<rbrakk>\n    \\<Longrightarrow> (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "with step.IH assms"], ["proof (chain)\npicking this:\n  (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n  (u, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n  sym ((edges g - {(u, v), (v, u)})\\<^sup>*)", "have \n          IH': \"(b,a) \\<in> ?E'\\<^sup>*\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n  (u, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n  sym ((edges g - {(u, v), (v, u)})\\<^sup>*)\n\ngoal (1 subgoal):\n 1. (b, a) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "by (auto intro: symD)"], ["proof (state)\nthis:\n  (b, a) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(a, b) \\<in> (edges g)\\<^sup>*; (b, c) \\<in> edges g;\n     (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*;\n     (b, c) \\<in> {(u, v), (v, u)}\\<rbrakk>\n    \\<Longrightarrow> (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n 2. \\<lbrakk>(a, b) \\<in> (edges g)\\<^sup>*; (b, c) \\<in> edges g;\n     (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*;\n     (b, c) \\<notin> {(u, v), (v, u)}\\<rbrakk>\n    \\<Longrightarrow> (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "from True"], ["proof (chain)\npicking this:\n  (b, c) \\<in> {(u, v), (v, u)}", "show ?thesis"], ["proof (prove)\nusing this:\n  (b, c) \\<in> {(u, v), (v, u)}\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>b = u; c = v\\<rbrakk>\n    \\<Longrightarrow> (a, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n 2. \\<lbrakk>b = v; c = u\\<rbrakk>\n    \\<Longrightarrow> (a, u) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = u; c = v\\<rbrakk>\n    \\<Longrightarrow> (a, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "using assms step.IH"], ["proof (prove)\nusing this:\n  (u, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n  (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b = u; c = v\\<rbrakk>\n    \\<Longrightarrow> (a, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = v; c = u\\<rbrakk>\n    \\<Longrightarrow> (a, u) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = v; c = u\\<rbrakk>\n    \\<Longrightarrow> (a, u) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "using assms IH'"], ["proof (prove)\nusing this:\n  (u, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n  (b, a) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b = v; c = u\\<rbrakk>\n    \\<Longrightarrow> (a, u) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "apply (rule_tac symD[OF SYME])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = v; c = u;\n     (u, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*;\n     (b, a) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> (u, a) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> (edges g)\\<^sup>*; (b, c) \\<in> edges g;\n     (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*;\n     (b, c) \\<notin> {(u, v), (v, u)}\\<rbrakk>\n    \\<Longrightarrow> (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> (edges g)\\<^sup>*; (b, c) \\<in> edges g;\n     (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*;\n     (b, c) \\<notin> {(u, v), (v, u)}\\<rbrakk>\n    \\<Longrightarrow> (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "case False"], ["proof (state)\nthis:\n  (b, c) \\<notin> {(u, v), (v, u)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> (edges g)\\<^sup>*; (b, c) \\<in> edges g;\n     (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*;\n     (b, c) \\<notin> {(u, v), (v, u)}\\<rbrakk>\n    \\<Longrightarrow> (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (b, c) \\<notin> {(u, v), (v, u)}", "show ?thesis"], ["proof (prove)\nusing this:\n  (b, c) \\<notin> {(u, v), (v, u)}\n\ngoal (1 subgoal):\n 1. (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*", "by (meson DiffI rtrancl.rtrancl_into_rtrancl step.IH step.hyps(2))"], ["proof (state)\nthis:\n  (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a, c) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a, b) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (edges g)\\<^sup>* \\<subseteq> (edges g - {(u, v), (v, u)})\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Connected Graphs\\<close>"], ["", "definition connected \n  where \"connected g \\<equiv> nodes g \\<times> nodes g \\<subseteq> (edges g)\\<^sup>*\""], ["", "lemma connectedI[intro?]: \n  assumes \"\\<And>u v. \\<lbrakk>u\\<in>nodes g; v\\<in>nodes g\\<rbrakk> \\<Longrightarrow> (u,v)\\<in>(edges g)\\<^sup>*\"  \n  shows \"connected g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected g", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> nodes g; ?v \\<in> nodes g\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (edges g)\\<^sup>*\n\ngoal (1 subgoal):\n 1. Undirected_Graph.connected g", "unfolding connected_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> nodes g; ?v \\<in> nodes g\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (edges g)\\<^sup>*\n\ngoal (1 subgoal):\n 1. nodes g \\<times> nodes g \\<subseteq> (edges g)\\<^sup>*", "by auto"], ["", "lemma connectedD[intro?]: \n  assumes \"connected g\" \"u\\<in>nodes g\" \"v\\<in>nodes g\"\n  shows \"(u,v)\\<in>(edges g)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> (edges g)\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  Undirected_Graph.connected g\n  u \\<in> nodes g\n  v \\<in> nodes g\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (edges g)\\<^sup>*", "unfolding connected_def"], ["proof (prove)\nusing this:\n  nodes g \\<times> nodes g \\<subseteq> (edges g)\\<^sup>*\n  u \\<in> nodes g\n  v \\<in> nodes g\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (edges g)\\<^sup>*", "by auto"], ["", "lemma connected_empty[simp]: \"connected graph_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected graph_empty", "unfolding connected_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes graph_empty \\<times> nodes graph_empty\n    \\<subseteq> (edges graph_empty)\\<^sup>*", "by auto"], ["", "subsection \\<open>Component Containing Node\\<close>"], ["", "definition \"reachable_nodes g r \\<equiv> (edges g)\\<^sup>*``{r}\""], ["", "definition \"component_of g r \n  \\<equiv> ins_node r (restrict_nodes g (reachable_nodes g r))\""], ["", "lemma reachable_nodes_refl[simp, intro!]: \"r \\<in> reachable_nodes g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> reachable_nodes g r", "by (auto simp: reachable_nodes_def)"], ["", "lemma reachable_nodes_step: \n  \"edges g `` reachable_nodes g r \\<subseteq> reachable_nodes g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges g `` reachable_nodes g r \\<subseteq> reachable_nodes g r", "by (auto simp: reachable_nodes_def)"], ["", "lemma reachable_nodes_steps: \n  \"(edges g)\\<^sup>* `` reachable_nodes g r \\<subseteq> reachable_nodes g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edges g)\\<^sup>* `` reachable_nodes g r \\<subseteq> reachable_nodes g r", "by (auto simp: reachable_nodes_def)"], ["", "lemma reachable_nodes_step':\n  assumes \"u \\<in> reachable_nodes g r\" \"(u, v) \\<in> edges g\" \n  shows \"v\\<in>reachable_nodes g r\" \"(u, v) \\<in> edges (component_of g r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> reachable_nodes g r &&& (u, v) \\<in> edges (component_of g r)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> reachable_nodes g r\n 2. (u, v) \\<in> edges (component_of g r)", "show \"v \\<in> reachable_nodes g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> reachable_nodes g r", "by (meson ImageI assms(1) assms(2) reachable_nodes_step rev_subsetD)"], ["proof (state)\nthis:\n  v \\<in> reachable_nodes g r\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> edges (component_of g r)", "then"], ["proof (chain)\npicking this:\n  v \\<in> reachable_nodes g r", "show \"(u, v) \\<in> edges (component_of g r)\""], ["proof (prove)\nusing this:\n  v \\<in> reachable_nodes g r\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> edges (component_of g r)", "by (simp add: assms(1) assms(2) component_of_def)"], ["proof (state)\nthis:\n  (u, v) \\<in> edges (component_of g r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_nodes_steps':\n  assumes \"u \\<in> reachable_nodes g r\" \"(u, v) \\<in> (edges g)\\<^sup>*\" \n  shows \"v\\<in>reachable_nodes g r\" \"(u, v) \\<in> (edges (component_of g r))\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> reachable_nodes g r &&&\n    (u, v) \\<in> (edges (component_of g r))\\<^sup>*", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> reachable_nodes g r\n 2. (u, v) \\<in> (edges (component_of g r))\\<^sup>*", "show \"v\\<in>reachable_nodes g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> reachable_nodes g r", "using reachable_nodes_steps assms"], ["proof (prove)\nusing this:\n  (edges ?g)\\<^sup>* `` reachable_nodes ?g ?r\n  \\<subseteq> reachable_nodes ?g ?r\n  u \\<in> reachable_nodes g r\n  (u, v) \\<in> (edges g)\\<^sup>*\n\ngoal (1 subgoal):\n 1. v \\<in> reachable_nodes g r", "by fast"], ["proof (state)\nthis:\n  v \\<in> reachable_nodes g r\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (edges (component_of g r))\\<^sup>*", "show \"(u, v) \\<in> (edges (component_of g r))\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> (edges (component_of g r))\\<^sup>*", "using assms(2,1)"], ["proof (prove)\nusing this:\n  (u, v) \\<in> (edges g)\\<^sup>*\n  u \\<in> reachable_nodes g r\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (edges (component_of g r))\\<^sup>*", "apply (induction rule: converse_rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> reachable_nodes g r \\<Longrightarrow>\n    (v, v) \\<in> (edges (component_of g r))\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> edges g; (z, v) \\<in> (edges g)\\<^sup>*;\n        z \\<in> reachable_nodes g r \\<Longrightarrow>\n        (z, v) \\<in> (edges (component_of g r))\\<^sup>*;\n        y \\<in> reachable_nodes g r\\<rbrakk>\n       \\<Longrightarrow> (y, v) \\<in> (edges (component_of g r))\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> reachable_nodes g r \\<Longrightarrow>\n    (v, v) \\<in> (edges (component_of g r))\\<^sup>*", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> edges g; (z, v) \\<in> (edges g)\\<^sup>*;\n        z \\<in> reachable_nodes g r \\<Longrightarrow>\n        (z, v) \\<in> (edges (component_of g r))\\<^sup>*;\n        y \\<in> reachable_nodes g r\\<rbrakk>\n       \\<Longrightarrow> (y, v) \\<in> (edges (component_of g r))\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y_, z_) \\<in> edges g; (z_, v) \\<in> (edges g)\\<^sup>*;\n     z_ \\<in> reachable_nodes g r \\<Longrightarrow>\n     (z_, v) \\<in> (edges (component_of g r))\\<^sup>*;\n     y_ \\<in> reachable_nodes g r\\<rbrakk>\n    \\<Longrightarrow> (y_, v) \\<in> (edges (component_of g r))\\<^sup>*", "by (smt converse_rtrancl_into_rtrancl reachable_nodes_step')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (u, v) \\<in> (edges (component_of g r))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_not_node: \"r\\<notin>nodes g \\<Longrightarrow> reachable_nodes g r = {r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<notin> nodes g \\<Longrightarrow> reachable_nodes g r = {r}", "by (force elim: converse_rtranclE simp: reachable_nodes_def intro: nodesI)"], ["", "lemma nodes_of_component[simp]: \"nodes (component_of g r) = reachable_nodes g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (component_of g r) = reachable_nodes g r", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nodes (component_of g r) \\<subseteq> reachable_nodes g r\n 2. reachable_nodes g r \\<subseteq> nodes (component_of g r)", "unfolding component_of_def reachable_nodes_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. nodes (ins_node r (restrict_nodes g ((edges g)\\<^sup>* `` {r})))\n    \\<subseteq> (edges g)\\<^sup>* `` {r}\n 2. (edges g)\\<^sup>* `` {r}\n    \\<subseteq> nodes\n                 (ins_node r (restrict_nodes g ((edges g)\\<^sup>* `` {r})))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (ins_node r (restrict_nodes g ((edges g)\\<^sup>* `` {r})))\n    \\<subseteq> (edges g)\\<^sup>* `` {r}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (edges g)\\<^sup>* `` {r}\n    \\<subseteq> nodes\n                 (ins_node r (restrict_nodes g ((edges g)\\<^sup>* `` {r})))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (edges g)\\<^sup>* `` {r}\n    \\<subseteq> nodes\n                 (ins_node r (restrict_nodes g ((edges g)\\<^sup>* `` {r})))", "by clarsimp (metis nodesI(2) rtranclE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma component_connected[simp, intro!]: \"connected (component_of g r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected (component_of g r)", "proof (rule connectedI; simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> reachable_nodes g r;\n        v \\<in> reachable_nodes g r\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (edges (component_of g r))\\<^sup>*", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> reachable_nodes g r;\n        v \\<in> reachable_nodes g r\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (edges (component_of g r))\\<^sup>*", "assume A: \"u \\<in> reachable_nodes g r\" \"v \\<in> reachable_nodes g r\""], ["proof (state)\nthis:\n  u \\<in> reachable_nodes g r\n  v \\<in> reachable_nodes g r\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> reachable_nodes g r;\n        v \\<in> reachable_nodes g r\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (edges (component_of g r))\\<^sup>*", "hence \"(u,r)\\<in>(edges g)\\<^sup>*\" \"(r,v)\\<in>(edges g)\\<^sup>*\""], ["proof (prove)\nusing this:\n  u \\<in> reachable_nodes g r\n  v \\<in> reachable_nodes g r\n\ngoal (1 subgoal):\n 1. (u, r) \\<in> (edges g)\\<^sup>* &&& (r, v) \\<in> (edges g)\\<^sup>*", "by (auto simp: reachable_nodes_def dest: rtrancl_edges_sym')"], ["proof (state)\nthis:\n  (u, r) \\<in> (edges g)\\<^sup>*\n  (r, v) \\<in> (edges g)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> reachable_nodes g r;\n        v \\<in> reachable_nodes g r\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (edges (component_of g r))\\<^sup>*", "hence \"(u,v)\\<in>(edges g)\\<^sup>*\""], ["proof (prove)\nusing this:\n  (u, r) \\<in> (edges g)\\<^sup>*\n  (r, v) \\<in> (edges g)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (edges g)\\<^sup>*", "by (rule rtrancl_trans)"], ["proof (state)\nthis:\n  (u, v) \\<in> (edges g)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> reachable_nodes g r;\n        v \\<in> reachable_nodes g r\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (edges (component_of g r))\\<^sup>*", "with A"], ["proof (chain)\npicking this:\n  u \\<in> reachable_nodes g r\n  v \\<in> reachable_nodes g r\n  (u, v) \\<in> (edges g)\\<^sup>*", "show \"(u, v) \\<in> (edges (component_of g r))\\<^sup>*\""], ["proof (prove)\nusing this:\n  u \\<in> reachable_nodes g r\n  v \\<in> reachable_nodes g r\n  (u, v) \\<in> (edges g)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (edges (component_of g r))\\<^sup>*", "by (rule_tac reachable_nodes_steps'(2))"], ["proof (state)\nthis:\n  (u, v) \\<in> (edges (component_of g r))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma component_edges_subset: \"edges (component_of g r) \\<subseteq> edges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (component_of g r) \\<subseteq> edges g", "by (auto simp: component_of_def)"], ["", "lemma component_path: \"u\\<in>nodes (component_of g r) \\<Longrightarrow> \n  path (component_of g r) u p v \\<longleftrightarrow> path g u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> nodes (component_of g r) \\<Longrightarrow>\n    path (component_of g r) u p v = path g u p v", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u \\<in> nodes (component_of g r);\n     path (component_of g r) u p v\\<rbrakk>\n    \\<Longrightarrow> path g u p v\n 2. \\<lbrakk>u \\<in> nodes (component_of g r); path g u p v\\<rbrakk>\n    \\<Longrightarrow> path (component_of g r) u p v", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> nodes (component_of g r);\n     path (component_of g r) u p v\\<rbrakk>\n    \\<Longrightarrow> path g u p v", "by (erule path_mono[OF component_edges_subset])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> nodes (component_of g r); path g u p v\\<rbrakk>\n    \\<Longrightarrow> path (component_of g r) u p v", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> nodes (component_of g r); path g u p v\\<rbrakk>\n    \\<Longrightarrow> path (component_of g r) u p v", "by (induction p arbitrary: u) (auto simp: reachable_nodes_step')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma component_cycle_free: \"cycle_free g \\<Longrightarrow> cycle_free (component_of g r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle_free g \\<Longrightarrow> cycle_free (component_of g r)", "by (meson component_edges_subset cycle_free_antimono)"], ["", "lemma component_of_connected_graph: \n  \"\\<lbrakk>connected g; r\\<in>nodes g\\<rbrakk> \\<Longrightarrow> component_of g r = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g\\<rbrakk>\n    \\<Longrightarrow> component_of g r = g", "unfolding graph_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g\\<rbrakk>\n    \\<Longrightarrow> nodes (component_of g r) = nodes g \\<and>\n                      edges (component_of g r) = edges g", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n        x \\<in> nodes (component_of g r)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nodes g\n 2. \\<And>x.\n       \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n        x \\<in> nodes g\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nodes (component_of g r)\n 3. \\<And>a b.\n       \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n        (a, b) \\<in> edges (component_of g r)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> edges g\n 4. \\<And>a b.\n       \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n        (a, b) \\<in> edges g\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> edges (component_of g r)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n     x_ \\<in> nodes (component_of g r)\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> nodes g", "by simp (metis Image_singleton_iff nodesI(2) reachable_nodes_def rtranclE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n        x \\<in> nodes g\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nodes (component_of g r)\n 2. \\<And>a b.\n       \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n        (a, b) \\<in> edges (component_of g r)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> edges g\n 3. \\<And>a b.\n       \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n        (a, b) \\<in> edges g\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> edges (component_of g r)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n     x_ \\<in> nodes g\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> nodes (component_of g r)", "by (simp add: connectedD reachable_nodes_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n        (a, b) \\<in> edges (component_of g r)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> edges g\n 2. \\<And>a b.\n       \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n        (a, b) \\<in> edges g\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> edges (component_of g r)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n     (a_, b_) \\<in> edges (component_of g r)\\<rbrakk>\n    \\<Longrightarrow> (a_, b_) \\<in> edges g", "by (simp add: component_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n        (a, b) \\<in> edges g\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> edges (component_of g r)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Undirected_Graph.connected g; r \\<in> nodes g;\n     (a_, b_) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> (a_, b_) \\<in> edges (component_of g r)", "by (simp add: connectedD reachable_nodes_def reachable_nodes_step'(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma component_of_not_node: \"r\\<notin>nodes g \\<Longrightarrow> component_of g r = graph {r} {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<notin> nodes g \\<Longrightarrow> component_of g r = graph {r} {}", "by (clarsimp simp: graph_eq_iff component_of_def reachable_not_node graph_accs)"], ["", "subsection \\<open>Trees\\<close>"], ["", "definition \"tree g \\<equiv> connected g \\<and> cycle_free g \""], ["", "lemma tree_empty[simp]: \"tree graph_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree graph_empty", "by (simp add: tree_def)"], ["", "lemma component_of_tree: \"tree T \\<Longrightarrow> tree (component_of T r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree T \\<Longrightarrow> tree (component_of T r)", "unfolding tree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected T \\<and> cycle_free T \\<Longrightarrow>\n    Undirected_Graph.connected (component_of T r) \\<and>\n    cycle_free (component_of T r)", "using component_connected component_cycle_free"], ["proof (prove)\nusing this:\n  Undirected_Graph.connected (component_of ?g ?r)\n  cycle_free ?g \\<Longrightarrow> cycle_free (component_of ?g ?r)\n\ngoal (1 subgoal):\n 1. Undirected_Graph.connected T \\<and> cycle_free T \\<Longrightarrow>\n    Undirected_Graph.connected (component_of T r) \\<and>\n    cycle_free (component_of T r)", "by auto"], ["", "subsubsection \\<open>Joining and Splitting Trees on Single Edge\\<close>"], ["", "lemma join_connected:\n  assumes CONN: \"connected g\\<^sub>1\" \"connected g\\<^sub>2\"\n  assumes IN_NODES: \"u\\<in>nodes g\\<^sub>1\" \"v\\<in>nodes g\\<^sub>2\"\n  shows \"connected (ins_edge (u,v) (graph_join g\\<^sub>1 g\\<^sub>2))\" (is \"connected ?g'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected\n     (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))", "unfolding connected_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) \\<times>\n    nodes (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\n    \\<subseteq> (edges\n                  (ins_edge (u, v)\n                    (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> nodes\n                         (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n        b \\<in> nodes\n                 (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (edges\n                                 (ins_edge (u, v)\n                                   (graph_join g\\<^sub>1\n                                     g\\<^sub>2)))\\<^sup>*", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> nodes\n                         (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n        b \\<in> nodes\n                 (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (edges\n                                 (ins_edge (u, v)\n                                   (graph_join g\\<^sub>1\n                                     g\\<^sub>2)))\\<^sup>*", "assume A: \"a\\<in>nodes ?g'\" \"b\\<in>nodes ?g'\""], ["proof (state)\nthis:\n  a \\<in> nodes (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\n  b \\<in> nodes (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> nodes\n                         (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n        b \\<in> nodes\n                 (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (edges\n                                 (ins_edge (u, v)\n                                   (graph_join g\\<^sub>1\n                                     g\\<^sub>2)))\\<^sup>*", "have ESS: \"(edges g\\<^sub>1)\\<^sup>* \\<subseteq> (edges ?g')\\<^sup>*\" \"(edges g\\<^sub>2)\\<^sup>* \\<subseteq> (edges ?g')\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edges g\\<^sub>1)\\<^sup>*\n    \\<subseteq> (edges\n                  (ins_edge (u, v)\n                    (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>* &&&\n    (edges g\\<^sub>2)\\<^sup>*\n    \\<subseteq> (edges\n                  (ins_edge (u, v)\n                    (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "using edges_ins_edge_ss"], ["proof (prove)\nusing this:\n  edges ?g \\<subseteq> edges (ins_edge ?e ?g)\n\ngoal (1 subgoal):\n 1. (edges g\\<^sub>1)\\<^sup>*\n    \\<subseteq> (edges\n                  (ins_edge (u, v)\n                    (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>* &&&\n    (edges g\\<^sub>2)\\<^sup>*\n    \\<subseteq> (edges\n                  (ins_edge (u, v)\n                    (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "by (force intro!: rtrancl_mono)+"], ["proof (state)\nthis:\n  (edges g\\<^sub>1)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  (edges g\\<^sub>2)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> nodes\n                         (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n        b \\<in> nodes\n                 (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (edges\n                                 (ins_edge (u, v)\n                                   (graph_join g\\<^sub>1\n                                     g\\<^sub>2)))\\<^sup>*", "have UV: \"(u,v)\\<in>(edges ?g')\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "by (simp add: edges_ins_edge r_into_rtrancl)"], ["proof (state)\nthis:\n  (u, v)\n  \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> nodes\n                         (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n        b \\<in> nodes\n                 (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (edges\n                                 (ins_edge (u, v)\n                                   (graph_join g\\<^sub>1\n                                     g\\<^sub>2)))\\<^sup>*", "show \"(a,b)\\<in>(edges ?g')\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "assume \"a\\<in>nodes g\\<^sub>1\" \"b\\<in>nodes g\\<^sub>1\""], ["proof (state)\nthis:\n  a \\<in> nodes g\\<^sub>1\n  b \\<in> nodes g\\<^sub>1\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "hence ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> nodes g\\<^sub>1\n  b \\<in> nodes g\\<^sub>1\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "using \\<open>connected g\\<^sub>1\\<close> ESS(1)"], ["proof (prove)\nusing this:\n  a \\<in> nodes g\\<^sub>1\n  b \\<in> nodes g\\<^sub>1\n  Undirected_Graph.connected g\\<^sub>1\n  (edges g\\<^sub>1)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "unfolding connected_def"], ["proof (prove)\nusing this:\n  a \\<in> nodes g\\<^sub>1\n  b \\<in> nodes g\\<^sub>1\n  nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1\n  \\<subseteq> (edges g\\<^sub>1)\\<^sup>*\n  (edges g\\<^sub>1)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  (a, b)\n  \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>1; b \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>1; b \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>1; b \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "assume \"a\\<in>nodes g\\<^sub>2\" \"b\\<in>nodes g\\<^sub>2\""], ["proof (state)\nthis:\n  a \\<in> nodes g\\<^sub>2\n  b \\<in> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "hence ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> nodes g\\<^sub>2\n  b \\<in> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "using \\<open>connected g\\<^sub>2\\<close> ESS(2)"], ["proof (prove)\nusing this:\n  a \\<in> nodes g\\<^sub>2\n  b \\<in> nodes g\\<^sub>2\n  Undirected_Graph.connected g\\<^sub>2\n  (edges g\\<^sub>2)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "unfolding connected_def"], ["proof (prove)\nusing this:\n  a \\<in> nodes g\\<^sub>2\n  b \\<in> nodes g\\<^sub>2\n  nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2\n  \\<subseteq> (edges g\\<^sub>2)\\<^sup>*\n  (edges g\\<^sub>2)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  (a, b)\n  \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>2; b \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>2; b \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>2; b \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "assume \"a\\<in>nodes g\\<^sub>1\" \"b\\<in>nodes g\\<^sub>2\""], ["proof (state)\nthis:\n  a \\<in> nodes g\\<^sub>1\n  b \\<in> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "with connectedD[OF CONN(1)] connectedD[OF CONN(2)] ESS"], ["proof (chain)\npicking this:\n  \\<lbrakk>?u \\<in> nodes g\\<^sub>1; ?v \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (edges g\\<^sub>1)\\<^sup>*\n  \\<lbrakk>?u \\<in> nodes g\\<^sub>2; ?v \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (edges g\\<^sub>2)\\<^sup>*\n  (edges g\\<^sub>1)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  (edges g\\<^sub>2)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  a \\<in> nodes g\\<^sub>1\n  b \\<in> nodes g\\<^sub>2", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> nodes g\\<^sub>1; ?v \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (edges g\\<^sub>1)\\<^sup>*\n  \\<lbrakk>?u \\<in> nodes g\\<^sub>2; ?v \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (edges g\\<^sub>2)\\<^sup>*\n  (edges g\\<^sub>1)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  (edges g\\<^sub>2)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  a \\<in> nodes g\\<^sub>1\n  b \\<in> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "by (meson UV IN_NODES contra_subsetD rtrancl_trans)"], ["proof (state)\nthis:\n  (a, b)\n  \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>1; b \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>1; b \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>1; b \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "assume \"a\\<in>nodes g\\<^sub>2\" \"b\\<in>nodes g\\<^sub>1\""], ["proof (state)\nthis:\n  a \\<in> nodes g\\<^sub>2\n  b \\<in> nodes g\\<^sub>1\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "with connectedD[OF CONN(1)] connectedD[OF CONN(2)] ESS"], ["proof (chain)\npicking this:\n  \\<lbrakk>?u \\<in> nodes g\\<^sub>1; ?v \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (edges g\\<^sub>1)\\<^sup>*\n  \\<lbrakk>?u \\<in> nodes g\\<^sub>2; ?v \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (edges g\\<^sub>2)\\<^sup>*\n  (edges g\\<^sub>1)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  (edges g\\<^sub>2)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  a \\<in> nodes g\\<^sub>2\n  b \\<in> nodes g\\<^sub>1", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> nodes g\\<^sub>1; ?v \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (edges g\\<^sub>1)\\<^sup>*\n  \\<lbrakk>?u \\<in> nodes g\\<^sub>2; ?v \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (edges g\\<^sub>2)\\<^sup>*\n  (edges g\\<^sub>1)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  (edges g\\<^sub>2)\\<^sup>*\n  \\<subseteq> (edges\n                (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  a \\<in> nodes g\\<^sub>2\n  b \\<in> nodes g\\<^sub>1\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "by (meson UV IN_NODES contra_subsetD rtrancl_edges_sym' rtrancl_trans)"], ["proof (state)\nthis:\n  (a, b)\n  \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>2; b \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>1; b \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  \\<lbrakk>a \\<in> nodes g\\<^sub>2; b \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  \\<lbrakk>a \\<in> nodes g\\<^sub>1; b \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  \\<lbrakk>a \\<in> nodes g\\<^sub>2; b \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>1; b \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  \\<lbrakk>a \\<in> nodes g\\<^sub>2; b \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  \\<lbrakk>a \\<in> nodes g\\<^sub>1; b \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  \\<lbrakk>a \\<in> nodes g\\<^sub>2; b \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "using A IN_NODES"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<in> nodes g\\<^sub>1; b \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  \\<lbrakk>a \\<in> nodes g\\<^sub>2; b \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  \\<lbrakk>a \\<in> nodes g\\<^sub>1; b \\<in> nodes g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  \\<lbrakk>a \\<in> nodes g\\<^sub>2; b \\<in> nodes g\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (a, b)\n                    \\<in> (edges\n                            (ins_edge (u, v)\n                              (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n  a \\<in> nodes (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\n  b \\<in> nodes (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\n  u \\<in> nodes g\\<^sub>1\n  v \\<in> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (a, b)\n  \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a, b)\n  \\<in> (edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma join_cycle_free:  \n  assumes CYCF: \"cycle_free g\\<^sub>1\" \"cycle_free g\\<^sub>2\"\n  assumes DJ: \"nodes g\\<^sub>1 \\<inter> nodes g\\<^sub>2 = {}\"\n  assumes IN_NODES: \"u\\<in>nodes g\\<^sub>1\" \"v\\<in>nodes g\\<^sub>2\"\n  shows \"cycle_free (ins_edge (u,v) (graph_join g\\<^sub>1 g\\<^sub>2))\" (is \"cycle_free ?g'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle_free (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))", "proof (rule cycle_freeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ua.\n       \\<lbrakk>path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) ua p\n                 ua;\n        p \\<noteq> []; simple p\\<rbrakk>\n       \\<Longrightarrow> False", "fix p a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ua.\n       \\<lbrakk>path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) ua p\n                 ua;\n        p \\<noteq> []; simple p\\<rbrakk>\n       \\<Longrightarrow> False", "assume P: \"path ?g' a p a\" \"p\\<noteq>[]\" \"simple p\""], ["proof (state)\nthis:\n  path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) a p a\n  p \\<noteq> []\n  simple p\n\ngoal (1 subgoal):\n 1. \\<And>p ua.\n       \\<lbrakk>path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) ua p\n                 ua;\n        p \\<noteq> []; simple p\\<rbrakk>\n       \\<Longrightarrow> False", "from path_endpoints[OF this(1,2)] IN_NODES"], ["proof (chain)\npicking this:\n  a \\<in> nodes (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\n  a \\<in> nodes (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\n  u \\<in> nodes g\\<^sub>1\n  v \\<in> nodes g\\<^sub>2", "have A_NODE: \"a\\<in>nodes g\\<^sub>1 \\<union> nodes g\\<^sub>2\""], ["proof (prove)\nusing this:\n  a \\<in> nodes (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\n  a \\<in> nodes (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\n  u \\<in> nodes g\\<^sub>1\n  v \\<in> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. a \\<in> nodes g\\<^sub>1 \\<union> nodes g\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  a \\<in> nodes g\\<^sub>1 \\<union> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>p ua.\n       \\<lbrakk>path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) ua p\n                 ua;\n        p \\<noteq> []; simple p\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  a \\<in> nodes g\\<^sub>1 \\<union> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> nodes g\\<^sub>1 \\<Longrightarrow> False\n 2. a \\<in> nodes g\\<^sub>2 \\<Longrightarrow> False", "assume N1: \"a\\<in>nodes g\\<^sub>1\""], ["proof (state)\nthis:\n  a \\<in> nodes g\\<^sub>1\n\ngoal (2 subgoals):\n 1. a \\<in> nodes g\\<^sub>1 \\<Longrightarrow> False\n 2. a \\<in> nodes g\\<^sub>2 \\<Longrightarrow> False", "have \"set p \\<subseteq> nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set p \\<subseteq> nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1", "proof (cases \n      rule: find_crossing_edges_on_path[where P=\"\\<lambda>x. x\\<in>nodes g\\<^sub>1\", OF P(1) N1 N1])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(u, v)\\<in>set p.\n       u \\<in> nodes g\\<^sub>1 \\<and>\n       v \\<in> nodes g\\<^sub>1 \\<Longrightarrow>\n    set p \\<subseteq> nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1\n 2. \\<And>u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2\n       p\\<^sub>3.\n       \\<lbrakk>p =\n                p\\<^sub>1 @\n                [(u\\<^sub>1, v\\<^sub>1)] @\n                p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n        u\\<^sub>1 \\<in> nodes g\\<^sub>1; v\\<^sub>1 \\<notin> nodes g\\<^sub>1;\n        u\\<^sub>2 \\<notin> nodes g\\<^sub>1;\n        v\\<^sub>2 \\<in> nodes g\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> set p\n                         \\<subseteq> nodes g\\<^sub>1 \\<times>\n                                     nodes g\\<^sub>1", "case 1"], ["proof (state)\nthis:\n  \\<forall>(u, v)\\<in>set p.\n     u \\<in> nodes g\\<^sub>1 \\<and> v \\<in> nodes g\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<forall>(u, v)\\<in>set p.\n       u \\<in> nodes g\\<^sub>1 \\<and>\n       v \\<in> nodes g\\<^sub>1 \\<Longrightarrow>\n    set p \\<subseteq> nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1\n 2. \\<And>u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2\n       p\\<^sub>3.\n       \\<lbrakk>p =\n                p\\<^sub>1 @\n                [(u\\<^sub>1, v\\<^sub>1)] @\n                p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n        u\\<^sub>1 \\<in> nodes g\\<^sub>1; v\\<^sub>1 \\<notin> nodes g\\<^sub>1;\n        u\\<^sub>2 \\<notin> nodes g\\<^sub>1;\n        v\\<^sub>2 \\<in> nodes g\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> set p\n                         \\<subseteq> nodes g\\<^sub>1 \\<times>\n                                     nodes g\\<^sub>1", "then"], ["proof (chain)\npicking this:\n  \\<forall>(u, v)\\<in>set p.\n     u \\<in> nodes g\\<^sub>1 \\<and> v \\<in> nodes g\\<^sub>1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>set p.\n     u \\<in> nodes g\\<^sub>1 \\<and> v \\<in> nodes g\\<^sub>1\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  set p \\<subseteq> nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2\n       p\\<^sub>3.\n       \\<lbrakk>p =\n                p\\<^sub>1 @\n                [(u\\<^sub>1, v\\<^sub>1)] @\n                p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n        u\\<^sub>1 \\<in> nodes g\\<^sub>1; v\\<^sub>1 \\<notin> nodes g\\<^sub>1;\n        u\\<^sub>2 \\<notin> nodes g\\<^sub>1;\n        v\\<^sub>2 \\<in> nodes g\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> set p\n                         \\<subseteq> nodes g\\<^sub>1 \\<times>\n                                     nodes g\\<^sub>1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2\n       p\\<^sub>3.\n       \\<lbrakk>p =\n                p\\<^sub>1 @\n                [(u\\<^sub>1, v\\<^sub>1)] @\n                p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n        u\\<^sub>1 \\<in> nodes g\\<^sub>1; v\\<^sub>1 \\<notin> nodes g\\<^sub>1;\n        u\\<^sub>2 \\<notin> nodes g\\<^sub>1;\n        v\\<^sub>2 \\<in> nodes g\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> set p\n                         \\<subseteq> nodes g\\<^sub>1 \\<times>\n                                     nodes g\\<^sub>1", "case (2 u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2 p\\<^sub>3)"], ["proof (state)\nthis:\n  p =\n  p\\<^sub>1 @\n  [(u\\<^sub>1, v\\<^sub>1)] @\n  p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3\n  u\\<^sub>1 \\<in> nodes g\\<^sub>1\n  v\\<^sub>1 \\<notin> nodes g\\<^sub>1\n  u\\<^sub>2 \\<notin> nodes g\\<^sub>1\n  v\\<^sub>2 \\<in> nodes g\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2\n       p\\<^sub>3.\n       \\<lbrakk>p =\n                p\\<^sub>1 @\n                [(u\\<^sub>1, v\\<^sub>1)] @\n                p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n        u\\<^sub>1 \\<in> nodes g\\<^sub>1; v\\<^sub>1 \\<notin> nodes g\\<^sub>1;\n        u\\<^sub>2 \\<notin> nodes g\\<^sub>1;\n        v\\<^sub>2 \\<in> nodes g\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> set p\n                         \\<subseteq> nodes g\\<^sub>1 \\<times>\n                                     nodes g\\<^sub>1", "then"], ["proof (chain)\npicking this:\n  p =\n  p\\<^sub>1 @\n  [(u\\<^sub>1, v\\<^sub>1)] @\n  p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3\n  u\\<^sub>1 \\<in> nodes g\\<^sub>1\n  v\\<^sub>1 \\<notin> nodes g\\<^sub>1\n  u\\<^sub>2 \\<notin> nodes g\\<^sub>1\n  v\\<^sub>2 \\<in> nodes g\\<^sub>1", "show ?thesis"], ["proof (prove)\nusing this:\n  p =\n  p\\<^sub>1 @\n  [(u\\<^sub>1, v\\<^sub>1)] @\n  p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3\n  u\\<^sub>1 \\<in> nodes g\\<^sub>1\n  v\\<^sub>1 \\<notin> nodes g\\<^sub>1\n  u\\<^sub>2 \\<notin> nodes g\\<^sub>1\n  v\\<^sub>2 \\<in> nodes g\\<^sub>1\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1", "using \\<open>simple p\\<close> P"], ["proof (prove)\nusing this:\n  p =\n  p\\<^sub>1 @\n  [(u\\<^sub>1, v\\<^sub>1)] @\n  p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3\n  u\\<^sub>1 \\<in> nodes g\\<^sub>1\n  v\\<^sub>1 \\<notin> nodes g\\<^sub>1\n  u\\<^sub>2 \\<notin> nodes g\\<^sub>1\n  v\\<^sub>2 \\<in> nodes g\\<^sub>1\n  simple p\n  path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) a p a\n  p \\<noteq> []\n  simple p\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p =\n             p\\<^sub>1 @\n             (u\\<^sub>1, v\\<^sub>1) #\n             p\\<^sub>2 @ (u\\<^sub>2, v\\<^sub>2) # p\\<^sub>3;\n     u\\<^sub>1 \\<in> nodes g\\<^sub>1; v\\<^sub>1 \\<notin> nodes g\\<^sub>1;\n     u\\<^sub>2 \\<notin> nodes g\\<^sub>1; v\\<^sub>2 \\<in> nodes g\\<^sub>1;\n     simple p\\<^sub>1;\n     path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) a p\\<^sub>1\n      u\\<^sub>1;\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<noteq> uedge (u\\<^sub>2, v\\<^sub>2);\n     (u\\<^sub>1, v\\<^sub>1)\n     \\<in> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n     uedge (u\\<^sub>1, v\\<^sub>1)\n     \\<notin> uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3);\n     path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) v\\<^sub>1\n      p\\<^sub>2 u\\<^sub>2;\n     simple p\\<^sub>2;\n     (u\\<^sub>2, v\\<^sub>2)\n     \\<in> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n     path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) v\\<^sub>2\n      p\\<^sub>3 a;\n     uedge (u\\<^sub>2, v\\<^sub>2) \\<notin> uedge ` set p\\<^sub>3;\n     simple p\\<^sub>3;\n     uedge (u\\<^sub>2, v\\<^sub>2) \\<notin> uedge ` set p\\<^sub>2;\n     uedge ` set p\\<^sub>2 \\<inter> uedge ` set p\\<^sub>3 = {};\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<notin> uedge ` set p\\<^sub>1;\n     uedge (u\\<^sub>2, v\\<^sub>2) \\<notin> uedge ` set p\\<^sub>1;\n     uedge ` set p\\<^sub>1 \\<inter>\n     uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule path_edges)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p =\n             p\\<^sub>1 @\n             (u\\<^sub>1, v\\<^sub>1) #\n             p\\<^sub>2 @ (u\\<^sub>2, v\\<^sub>2) # p\\<^sub>3;\n     u\\<^sub>1 \\<in> nodes g\\<^sub>1; v\\<^sub>1 \\<notin> nodes g\\<^sub>1;\n     u\\<^sub>2 \\<notin> nodes g\\<^sub>1; v\\<^sub>2 \\<in> nodes g\\<^sub>1;\n     simple p\\<^sub>1;\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<noteq> uedge (u\\<^sub>2, v\\<^sub>2);\n     (u\\<^sub>1, v\\<^sub>1)\n     \\<in> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n     uedge (u\\<^sub>1, v\\<^sub>1)\n     \\<notin> uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3);\n     simple p\\<^sub>2;\n     (u\\<^sub>2, v\\<^sub>2)\n     \\<in> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n     uedge (u\\<^sub>2, v\\<^sub>2) \\<notin> uedge ` set p\\<^sub>3;\n     simple p\\<^sub>3;\n     uedge (u\\<^sub>2, v\\<^sub>2) \\<notin> uedge ` set p\\<^sub>2;\n     uedge ` set p\\<^sub>2 \\<inter> uedge ` set p\\<^sub>3 = {};\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<notin> uedge ` set p\\<^sub>1;\n     uedge (u\\<^sub>2, v\\<^sub>2) \\<notin> uedge ` set p\\<^sub>1;\n     uedge ` set p\\<^sub>1 \\<inter>\n     uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3) =\n     {};\n     set p\\<^sub>1\n     \\<subseteq> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n     set p\\<^sub>2\n     \\<subseteq> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n     set p\\<^sub>3\n     \\<subseteq> edges\n                  (ins_edge (u, v)\n                    (graph_join g\\<^sub>1 g\\<^sub>2))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases \"u=v\"; clarsimp simp: edges_ins_edge uedge_in_set_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p =\n             p\\<^sub>1 @\n             (u\\<^sub>1, v\\<^sub>1) #\n             p\\<^sub>2 @ (u\\<^sub>2, v\\<^sub>2) # p\\<^sub>3;\n     u\\<^sub>1 \\<in> nodes g\\<^sub>1; v\\<^sub>1 \\<notin> nodes g\\<^sub>1;\n     u\\<^sub>2 \\<notin> nodes g\\<^sub>1; v\\<^sub>2 \\<in> nodes g\\<^sub>1;\n     simple p\\<^sub>1;\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<noteq> uedge (u\\<^sub>2, v\\<^sub>2);\n     (u\\<^sub>1, v\\<^sub>1) \\<in> edges g\\<^sub>1 \\<or>\n     (u\\<^sub>1, v\\<^sub>1) \\<in> edges g\\<^sub>2;\n     simple p\\<^sub>2;\n     (u\\<^sub>2, v\\<^sub>2) \\<in> edges g\\<^sub>1 \\<or>\n     (u\\<^sub>2, v\\<^sub>2) \\<in> edges g\\<^sub>2;\n     simple p\\<^sub>3;\n     uedge ` set p\\<^sub>2 \\<inter> uedge ` set p\\<^sub>3 = {};\n     uedge ` set p\\<^sub>1 \\<inter>\n     uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3) =\n     {};\n     set p\\<^sub>1 \\<subseteq> edges g\\<^sub>1 \\<union> edges g\\<^sub>2;\n     set p\\<^sub>2 \\<subseteq> edges g\\<^sub>1 \\<union> edges g\\<^sub>2;\n     set p\\<^sub>3 \\<subseteq> edges g\\<^sub>1 \\<union> edges g\\<^sub>2;\n     u = v; (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>2;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>3;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>3;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>2;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>2;\n     (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>1;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>1;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>1;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>1;\n     (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>3;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>2;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>3\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>p =\n             p\\<^sub>1 @\n             (u\\<^sub>1, v\\<^sub>1) #\n             p\\<^sub>2 @ (u\\<^sub>2, v\\<^sub>2) # p\\<^sub>3;\n     u\\<^sub>1 \\<in> nodes g\\<^sub>1; v\\<^sub>1 \\<notin> nodes g\\<^sub>1;\n     u\\<^sub>2 \\<notin> nodes g\\<^sub>1; v\\<^sub>2 \\<in> nodes g\\<^sub>1;\n     simple p\\<^sub>1;\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<noteq> uedge (u\\<^sub>2, v\\<^sub>2);\n     u\\<^sub>1 = u \\<and> v\\<^sub>1 = v \\<or>\n     u\\<^sub>1 = v \\<and> v\\<^sub>1 = u \\<or>\n     (u\\<^sub>1, v\\<^sub>1) \\<in> edges g\\<^sub>1 \\<or>\n     (u\\<^sub>1, v\\<^sub>1) \\<in> edges g\\<^sub>2;\n     simple p\\<^sub>2;\n     u\\<^sub>2 = u \\<and> v\\<^sub>2 = v \\<or>\n     u\\<^sub>2 = v \\<and> v\\<^sub>2 = u \\<or>\n     (u\\<^sub>2, v\\<^sub>2) \\<in> edges g\\<^sub>1 \\<or>\n     (u\\<^sub>2, v\\<^sub>2) \\<in> edges g\\<^sub>2;\n     simple p\\<^sub>3;\n     uedge ` set p\\<^sub>2 \\<inter> uedge ` set p\\<^sub>3 = {};\n     uedge ` set p\\<^sub>1 \\<inter>\n     uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3) =\n     {};\n     set p\\<^sub>1\n     \\<subseteq> insert (u, v)\n                  (insert (v, u)\n                    (edges g\\<^sub>1 \\<union> edges g\\<^sub>2));\n     set p\\<^sub>2\n     \\<subseteq> insert (u, v)\n                  (insert (v, u)\n                    (edges g\\<^sub>1 \\<union> edges g\\<^sub>2));\n     set p\\<^sub>3\n     \\<subseteq> insert (u, v)\n                  (insert (v, u)\n                    (edges g\\<^sub>1 \\<union> edges g\\<^sub>2));\n     u \\<noteq> v; (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>2;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>3;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>3;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>2;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>2;\n     (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>1;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>1;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>1;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>1;\n     (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>3;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>2;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>3\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis DJ IntI IN_NODES empty_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p =\n             p\\<^sub>1 @\n             (u\\<^sub>1, v\\<^sub>1) #\n             p\\<^sub>2 @ (u\\<^sub>2, v\\<^sub>2) # p\\<^sub>3;\n     u\\<^sub>1 \\<in> nodes g\\<^sub>1; v\\<^sub>1 \\<notin> nodes g\\<^sub>1;\n     u\\<^sub>2 \\<notin> nodes g\\<^sub>1; v\\<^sub>2 \\<in> nodes g\\<^sub>1;\n     simple p\\<^sub>1;\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<noteq> uedge (u\\<^sub>2, v\\<^sub>2);\n     u\\<^sub>1 = u \\<and> v\\<^sub>1 = v \\<or>\n     u\\<^sub>1 = v \\<and> v\\<^sub>1 = u \\<or>\n     (u\\<^sub>1, v\\<^sub>1) \\<in> edges g\\<^sub>1 \\<or>\n     (u\\<^sub>1, v\\<^sub>1) \\<in> edges g\\<^sub>2;\n     simple p\\<^sub>2;\n     u\\<^sub>2 = u \\<and> v\\<^sub>2 = v \\<or>\n     u\\<^sub>2 = v \\<and> v\\<^sub>2 = u \\<or>\n     (u\\<^sub>2, v\\<^sub>2) \\<in> edges g\\<^sub>1 \\<or>\n     (u\\<^sub>2, v\\<^sub>2) \\<in> edges g\\<^sub>2;\n     simple p\\<^sub>3;\n     uedge ` set p\\<^sub>2 \\<inter> uedge ` set p\\<^sub>3 = {};\n     uedge ` set p\\<^sub>1 \\<inter>\n     uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3) =\n     {};\n     set p\\<^sub>1\n     \\<subseteq> insert (u, v)\n                  (insert (v, u)\n                    (edges g\\<^sub>1 \\<union> edges g\\<^sub>2));\n     set p\\<^sub>2\n     \\<subseteq> insert (u, v)\n                  (insert (v, u)\n                    (edges g\\<^sub>1 \\<union> edges g\\<^sub>2));\n     set p\\<^sub>3\n     \\<subseteq> insert (u, v)\n                  (insert (v, u)\n                    (edges g\\<^sub>1 \\<union> edges g\\<^sub>2));\n     u \\<noteq> v; (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>2;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>3;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>3;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>2;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>2;\n     (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>1;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>1;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>1;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>1;\n     (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>3;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>2;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>3\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis DJ IntI empty_iff nodesI uedge_eq_iff)"], ["proof (state)\nthis:\n  set p \\<subseteq> nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set p \\<subseteq> nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1\n\ngoal (2 subgoals):\n 1. a \\<in> nodes g\\<^sub>1 \\<Longrightarrow> False\n 2. a \\<in> nodes g\\<^sub>2 \\<Longrightarrow> False", "hence \"set p \\<subseteq> edges g\\<^sub>1\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> edges g\\<^sub>1", "using DJ edges_subset path_edges[OF P(1)] IN_NODES"], ["proof (prove)\nusing this:\n  set p \\<subseteq> nodes g\\<^sub>1 \\<times> nodes g\\<^sub>1\n  nodes g\\<^sub>1 \\<inter> nodes g\\<^sub>2 = {}\n  edges ?g \\<subseteq> nodes ?g \\<times> nodes ?g\n  set p \\<subseteq> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\n  u \\<in> nodes g\\<^sub>1\n  v \\<in> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> edges g\\<^sub>1", "by (auto simp: edges_ins_edge split: if_splits; blast)"], ["proof (state)\nthis:\n  set p \\<subseteq> edges g\\<^sub>1\n\ngoal (2 subgoals):\n 1. a \\<in> nodes g\\<^sub>1 \\<Longrightarrow> False\n 2. a \\<in> nodes g\\<^sub>2 \\<Longrightarrow> False", "hence \"path g\\<^sub>1 a p a\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> edges g\\<^sub>1\n\ngoal (1 subgoal):\n 1. path g\\<^sub>1 a p a", "by (meson P(1) path_graph_cong)"], ["proof (state)\nthis:\n  path g\\<^sub>1 a p a\n\ngoal (2 subgoals):\n 1. a \\<in> nodes g\\<^sub>1 \\<Longrightarrow> False\n 2. a \\<in> nodes g\\<^sub>2 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  path g\\<^sub>1 a p a\n\ngoal (1 subgoal):\n 1. False", "using cycle_freeD[OF CYCF(1)] P(2,3)"], ["proof (prove)\nusing this:\n  path g\\<^sub>1 a p a\n  \\<lbrakk>path g\\<^sub>1 ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n  p \\<noteq> []\n  simple p\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. a \\<in> nodes g\\<^sub>2 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> nodes g\\<^sub>2 \\<Longrightarrow> False", "assume N2: \"a\\<in>nodes g\\<^sub>2\""], ["proof (state)\nthis:\n  a \\<in> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. a \\<in> nodes g\\<^sub>2 \\<Longrightarrow> False", "have \"set p \\<subseteq> nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set p \\<subseteq> nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2", "proof (cases \n      rule: find_crossing_edges_on_path[where P=\"\\<lambda>x. x\\<in>nodes g\\<^sub>2\", OF P(1) N2 N2])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(u, v)\\<in>set p.\n       u \\<in> nodes g\\<^sub>2 \\<and>\n       v \\<in> nodes g\\<^sub>2 \\<Longrightarrow>\n    set p \\<subseteq> nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2\n 2. \\<And>u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2\n       p\\<^sub>3.\n       \\<lbrakk>p =\n                p\\<^sub>1 @\n                [(u\\<^sub>1, v\\<^sub>1)] @\n                p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n        u\\<^sub>1 \\<in> nodes g\\<^sub>2; v\\<^sub>1 \\<notin> nodes g\\<^sub>2;\n        u\\<^sub>2 \\<notin> nodes g\\<^sub>2;\n        v\\<^sub>2 \\<in> nodes g\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> set p\n                         \\<subseteq> nodes g\\<^sub>2 \\<times>\n                                     nodes g\\<^sub>2", "case 1"], ["proof (state)\nthis:\n  \\<forall>(u, v)\\<in>set p.\n     u \\<in> nodes g\\<^sub>2 \\<and> v \\<in> nodes g\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<forall>(u, v)\\<in>set p.\n       u \\<in> nodes g\\<^sub>2 \\<and>\n       v \\<in> nodes g\\<^sub>2 \\<Longrightarrow>\n    set p \\<subseteq> nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2\n 2. \\<And>u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2\n       p\\<^sub>3.\n       \\<lbrakk>p =\n                p\\<^sub>1 @\n                [(u\\<^sub>1, v\\<^sub>1)] @\n                p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n        u\\<^sub>1 \\<in> nodes g\\<^sub>2; v\\<^sub>1 \\<notin> nodes g\\<^sub>2;\n        u\\<^sub>2 \\<notin> nodes g\\<^sub>2;\n        v\\<^sub>2 \\<in> nodes g\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> set p\n                         \\<subseteq> nodes g\\<^sub>2 \\<times>\n                                     nodes g\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  \\<forall>(u, v)\\<in>set p.\n     u \\<in> nodes g\\<^sub>2 \\<and> v \\<in> nodes g\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>set p.\n     u \\<in> nodes g\\<^sub>2 \\<and> v \\<in> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  set p \\<subseteq> nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2\n       p\\<^sub>3.\n       \\<lbrakk>p =\n                p\\<^sub>1 @\n                [(u\\<^sub>1, v\\<^sub>1)] @\n                p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n        u\\<^sub>1 \\<in> nodes g\\<^sub>2; v\\<^sub>1 \\<notin> nodes g\\<^sub>2;\n        u\\<^sub>2 \\<notin> nodes g\\<^sub>2;\n        v\\<^sub>2 \\<in> nodes g\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> set p\n                         \\<subseteq> nodes g\\<^sub>2 \\<times>\n                                     nodes g\\<^sub>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2\n       p\\<^sub>3.\n       \\<lbrakk>p =\n                p\\<^sub>1 @\n                [(u\\<^sub>1, v\\<^sub>1)] @\n                p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n        u\\<^sub>1 \\<in> nodes g\\<^sub>2; v\\<^sub>1 \\<notin> nodes g\\<^sub>2;\n        u\\<^sub>2 \\<notin> nodes g\\<^sub>2;\n        v\\<^sub>2 \\<in> nodes g\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> set p\n                         \\<subseteq> nodes g\\<^sub>2 \\<times>\n                                     nodes g\\<^sub>2", "case (2 u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2 p\\<^sub>3)"], ["proof (state)\nthis:\n  p =\n  p\\<^sub>1 @\n  [(u\\<^sub>1, v\\<^sub>1)] @\n  p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3\n  u\\<^sub>1 \\<in> nodes g\\<^sub>2\n  v\\<^sub>1 \\<notin> nodes g\\<^sub>2\n  u\\<^sub>2 \\<notin> nodes g\\<^sub>2\n  v\\<^sub>2 \\<in> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>u\\<^sub>1 v\\<^sub>1 v\\<^sub>2 u\\<^sub>2 p\\<^sub>1 p\\<^sub>2\n       p\\<^sub>3.\n       \\<lbrakk>p =\n                p\\<^sub>1 @\n                [(u\\<^sub>1, v\\<^sub>1)] @\n                p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3;\n        u\\<^sub>1 \\<in> nodes g\\<^sub>2; v\\<^sub>1 \\<notin> nodes g\\<^sub>2;\n        u\\<^sub>2 \\<notin> nodes g\\<^sub>2;\n        v\\<^sub>2 \\<in> nodes g\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> set p\n                         \\<subseteq> nodes g\\<^sub>2 \\<times>\n                                     nodes g\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  p =\n  p\\<^sub>1 @\n  [(u\\<^sub>1, v\\<^sub>1)] @\n  p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3\n  u\\<^sub>1 \\<in> nodes g\\<^sub>2\n  v\\<^sub>1 \\<notin> nodes g\\<^sub>2\n  u\\<^sub>2 \\<notin> nodes g\\<^sub>2\n  v\\<^sub>2 \\<in> nodes g\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  p =\n  p\\<^sub>1 @\n  [(u\\<^sub>1, v\\<^sub>1)] @\n  p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3\n  u\\<^sub>1 \\<in> nodes g\\<^sub>2\n  v\\<^sub>1 \\<notin> nodes g\\<^sub>2\n  u\\<^sub>2 \\<notin> nodes g\\<^sub>2\n  v\\<^sub>2 \\<in> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2", "using \\<open>simple p\\<close> P"], ["proof (prove)\nusing this:\n  p =\n  p\\<^sub>1 @\n  [(u\\<^sub>1, v\\<^sub>1)] @\n  p\\<^sub>2 @ [(u\\<^sub>2, v\\<^sub>2)] @ p\\<^sub>3\n  u\\<^sub>1 \\<in> nodes g\\<^sub>2\n  v\\<^sub>1 \\<notin> nodes g\\<^sub>2\n  u\\<^sub>2 \\<notin> nodes g\\<^sub>2\n  v\\<^sub>2 \\<in> nodes g\\<^sub>2\n  simple p\n  path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) a p a\n  p \\<noteq> []\n  simple p\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p =\n             p\\<^sub>1 @\n             (u\\<^sub>1, v\\<^sub>1) #\n             p\\<^sub>2 @ (u\\<^sub>2, v\\<^sub>2) # p\\<^sub>3;\n     u\\<^sub>1 \\<in> nodes g\\<^sub>2; v\\<^sub>1 \\<notin> nodes g\\<^sub>2;\n     u\\<^sub>2 \\<notin> nodes g\\<^sub>2; v\\<^sub>2 \\<in> nodes g\\<^sub>2;\n     simple p\\<^sub>1;\n     path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) a p\\<^sub>1\n      u\\<^sub>1;\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<noteq> uedge (u\\<^sub>2, v\\<^sub>2);\n     (u\\<^sub>1, v\\<^sub>1)\n     \\<in> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n     uedge (u\\<^sub>1, v\\<^sub>1)\n     \\<notin> uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3);\n     path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) v\\<^sub>1\n      p\\<^sub>2 u\\<^sub>2;\n     simple p\\<^sub>2;\n     (u\\<^sub>2, v\\<^sub>2)\n     \\<in> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n     path (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) v\\<^sub>2\n      p\\<^sub>3 a;\n     uedge (u\\<^sub>2, v\\<^sub>2) \\<notin> uedge ` set p\\<^sub>3;\n     simple p\\<^sub>3;\n     uedge (u\\<^sub>2, v\\<^sub>2) \\<notin> uedge ` set p\\<^sub>2;\n     uedge ` set p\\<^sub>2 \\<inter> uedge ` set p\\<^sub>3 = {};\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<notin> uedge ` set p\\<^sub>1;\n     uedge (u\\<^sub>2, v\\<^sub>2) \\<notin> uedge ` set p\\<^sub>1;\n     uedge ` set p\\<^sub>1 \\<inter>\n     uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule path_edges)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p =\n             p\\<^sub>1 @\n             (u\\<^sub>1, v\\<^sub>1) #\n             p\\<^sub>2 @ (u\\<^sub>2, v\\<^sub>2) # p\\<^sub>3;\n     u\\<^sub>1 \\<in> nodes g\\<^sub>2; v\\<^sub>1 \\<notin> nodes g\\<^sub>2;\n     u\\<^sub>2 \\<notin> nodes g\\<^sub>2; v\\<^sub>2 \\<in> nodes g\\<^sub>2;\n     simple p\\<^sub>1;\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<noteq> uedge (u\\<^sub>2, v\\<^sub>2);\n     (u\\<^sub>1, v\\<^sub>1)\n     \\<in> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n     uedge (u\\<^sub>1, v\\<^sub>1)\n     \\<notin> uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3);\n     simple p\\<^sub>2;\n     (u\\<^sub>2, v\\<^sub>2)\n     \\<in> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n     uedge (u\\<^sub>2, v\\<^sub>2) \\<notin> uedge ` set p\\<^sub>3;\n     simple p\\<^sub>3;\n     uedge (u\\<^sub>2, v\\<^sub>2) \\<notin> uedge ` set p\\<^sub>2;\n     uedge ` set p\\<^sub>2 \\<inter> uedge ` set p\\<^sub>3 = {};\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<notin> uedge ` set p\\<^sub>1;\n     uedge (u\\<^sub>2, v\\<^sub>2) \\<notin> uedge ` set p\\<^sub>1;\n     uedge ` set p\\<^sub>1 \\<inter>\n     uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3) =\n     {};\n     set p\\<^sub>1\n     \\<subseteq> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n     set p\\<^sub>2\n     \\<subseteq> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2));\n     set p\\<^sub>3\n     \\<subseteq> edges\n                  (ins_edge (u, v)\n                    (graph_join g\\<^sub>1 g\\<^sub>2))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases \"u=v\"; clarsimp simp: edges_ins_edge uedge_in_set_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p =\n             p\\<^sub>1 @\n             (u\\<^sub>1, v\\<^sub>1) #\n             p\\<^sub>2 @ (u\\<^sub>2, v\\<^sub>2) # p\\<^sub>3;\n     u\\<^sub>1 \\<in> nodes g\\<^sub>2; v\\<^sub>1 \\<notin> nodes g\\<^sub>2;\n     u\\<^sub>2 \\<notin> nodes g\\<^sub>2; v\\<^sub>2 \\<in> nodes g\\<^sub>2;\n     simple p\\<^sub>1;\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<noteq> uedge (u\\<^sub>2, v\\<^sub>2);\n     (u\\<^sub>1, v\\<^sub>1) \\<in> edges g\\<^sub>1 \\<or>\n     (u\\<^sub>1, v\\<^sub>1) \\<in> edges g\\<^sub>2;\n     simple p\\<^sub>2;\n     (u\\<^sub>2, v\\<^sub>2) \\<in> edges g\\<^sub>1 \\<or>\n     (u\\<^sub>2, v\\<^sub>2) \\<in> edges g\\<^sub>2;\n     simple p\\<^sub>3;\n     uedge ` set p\\<^sub>2 \\<inter> uedge ` set p\\<^sub>3 = {};\n     uedge ` set p\\<^sub>1 \\<inter>\n     uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3) =\n     {};\n     set p\\<^sub>1 \\<subseteq> edges g\\<^sub>1 \\<union> edges g\\<^sub>2;\n     set p\\<^sub>2 \\<subseteq> edges g\\<^sub>1 \\<union> edges g\\<^sub>2;\n     set p\\<^sub>3 \\<subseteq> edges g\\<^sub>1 \\<union> edges g\\<^sub>2;\n     u = v; (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>2;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>3;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>3;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>2;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>2;\n     (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>1;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>1;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>1;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>1;\n     (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>3;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>2;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>3\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>p =\n             p\\<^sub>1 @\n             (u\\<^sub>1, v\\<^sub>1) #\n             p\\<^sub>2 @ (u\\<^sub>2, v\\<^sub>2) # p\\<^sub>3;\n     u\\<^sub>1 \\<in> nodes g\\<^sub>2; v\\<^sub>1 \\<notin> nodes g\\<^sub>2;\n     u\\<^sub>2 \\<notin> nodes g\\<^sub>2; v\\<^sub>2 \\<in> nodes g\\<^sub>2;\n     simple p\\<^sub>1;\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<noteq> uedge (u\\<^sub>2, v\\<^sub>2);\n     u\\<^sub>1 = u \\<and> v\\<^sub>1 = v \\<or>\n     u\\<^sub>1 = v \\<and> v\\<^sub>1 = u \\<or>\n     (u\\<^sub>1, v\\<^sub>1) \\<in> edges g\\<^sub>1 \\<or>\n     (u\\<^sub>1, v\\<^sub>1) \\<in> edges g\\<^sub>2;\n     simple p\\<^sub>2;\n     u\\<^sub>2 = u \\<and> v\\<^sub>2 = v \\<or>\n     u\\<^sub>2 = v \\<and> v\\<^sub>2 = u \\<or>\n     (u\\<^sub>2, v\\<^sub>2) \\<in> edges g\\<^sub>1 \\<or>\n     (u\\<^sub>2, v\\<^sub>2) \\<in> edges g\\<^sub>2;\n     simple p\\<^sub>3;\n     uedge ` set p\\<^sub>2 \\<inter> uedge ` set p\\<^sub>3 = {};\n     uedge ` set p\\<^sub>1 \\<inter>\n     uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3) =\n     {};\n     set p\\<^sub>1\n     \\<subseteq> insert (u, v)\n                  (insert (v, u)\n                    (edges g\\<^sub>1 \\<union> edges g\\<^sub>2));\n     set p\\<^sub>2\n     \\<subseteq> insert (u, v)\n                  (insert (v, u)\n                    (edges g\\<^sub>1 \\<union> edges g\\<^sub>2));\n     set p\\<^sub>3\n     \\<subseteq> insert (u, v)\n                  (insert (v, u)\n                    (edges g\\<^sub>1 \\<union> edges g\\<^sub>2));\n     u \\<noteq> v; (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>2;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>3;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>3;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>2;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>2;\n     (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>1;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>1;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>1;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>1;\n     (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>3;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>2;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>3\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis DJ IntI IN_NODES empty_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p =\n             p\\<^sub>1 @\n             (u\\<^sub>1, v\\<^sub>1) #\n             p\\<^sub>2 @ (u\\<^sub>2, v\\<^sub>2) # p\\<^sub>3;\n     u\\<^sub>1 \\<in> nodes g\\<^sub>2; v\\<^sub>1 \\<notin> nodes g\\<^sub>2;\n     u\\<^sub>2 \\<notin> nodes g\\<^sub>2; v\\<^sub>2 \\<in> nodes g\\<^sub>2;\n     simple p\\<^sub>1;\n     uedge (u\\<^sub>1, v\\<^sub>1) \\<noteq> uedge (u\\<^sub>2, v\\<^sub>2);\n     u\\<^sub>1 = u \\<and> v\\<^sub>1 = v \\<or>\n     u\\<^sub>1 = v \\<and> v\\<^sub>1 = u \\<or>\n     (u\\<^sub>1, v\\<^sub>1) \\<in> edges g\\<^sub>1 \\<or>\n     (u\\<^sub>1, v\\<^sub>1) \\<in> edges g\\<^sub>2;\n     simple p\\<^sub>2;\n     u\\<^sub>2 = u \\<and> v\\<^sub>2 = v \\<or>\n     u\\<^sub>2 = v \\<and> v\\<^sub>2 = u \\<or>\n     (u\\<^sub>2, v\\<^sub>2) \\<in> edges g\\<^sub>1 \\<or>\n     (u\\<^sub>2, v\\<^sub>2) \\<in> edges g\\<^sub>2;\n     simple p\\<^sub>3;\n     uedge ` set p\\<^sub>2 \\<inter> uedge ` set p\\<^sub>3 = {};\n     uedge ` set p\\<^sub>1 \\<inter>\n     uedge ` (set p\\<^sub>2 \\<union> set p\\<^sub>3) =\n     {};\n     set p\\<^sub>1\n     \\<subseteq> insert (u, v)\n                  (insert (v, u)\n                    (edges g\\<^sub>1 \\<union> edges g\\<^sub>2));\n     set p\\<^sub>2\n     \\<subseteq> insert (u, v)\n                  (insert (v, u)\n                    (edges g\\<^sub>1 \\<union> edges g\\<^sub>2));\n     set p\\<^sub>3\n     \\<subseteq> insert (u, v)\n                  (insert (v, u)\n                    (edges g\\<^sub>1 \\<union> edges g\\<^sub>2));\n     u \\<noteq> v; (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>2;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>3;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>3;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>2;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>2;\n     (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>1;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>1;\n     (u\\<^sub>2, v\\<^sub>2) \\<notin> set p\\<^sub>1;\n     (v\\<^sub>2, u\\<^sub>2) \\<notin> set p\\<^sub>1;\n     (u\\<^sub>1, v\\<^sub>1) \\<notin> set p\\<^sub>3;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>2;\n     (v\\<^sub>1, u\\<^sub>1) \\<notin> set p\\<^sub>3\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis DJ IntI empty_iff nodesI uedge_eq_iff)"], ["proof (state)\nthis:\n  set p \\<subseteq> nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set p \\<subseteq> nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. a \\<in> nodes g\\<^sub>2 \\<Longrightarrow> False", "hence \"set p \\<subseteq> edges g\\<^sub>2\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> edges g\\<^sub>2", "using DJ edges_subset path_edges[OF P(1)] IN_NODES"], ["proof (prove)\nusing this:\n  set p \\<subseteq> nodes g\\<^sub>2 \\<times> nodes g\\<^sub>2\n  nodes g\\<^sub>1 \\<inter> nodes g\\<^sub>2 = {}\n  edges ?g \\<subseteq> nodes ?g \\<times> nodes ?g\n  set p \\<subseteq> edges (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))\n  u \\<in> nodes g\\<^sub>1\n  v \\<in> nodes g\\<^sub>2\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> edges g\\<^sub>2", "by (auto simp: edges_ins_edge split: if_splits; blast)"], ["proof (state)\nthis:\n  set p \\<subseteq> edges g\\<^sub>2\n\ngoal (1 subgoal):\n 1. a \\<in> nodes g\\<^sub>2 \\<Longrightarrow> False", "hence \"path g\\<^sub>2 a p a\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> edges g\\<^sub>2\n\ngoal (1 subgoal):\n 1. path g\\<^sub>2 a p a", "by (meson P(1) path_graph_cong)"], ["proof (state)\nthis:\n  path g\\<^sub>2 a p a\n\ngoal (1 subgoal):\n 1. a \\<in> nodes g\\<^sub>2 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  path g\\<^sub>2 a p a\n\ngoal (1 subgoal):\n 1. False", "using cycle_freeD[OF CYCF(2)] P(2,3)"], ["proof (prove)\nusing this:\n  path g\\<^sub>2 a p a\n  \\<lbrakk>path g\\<^sub>2 ?u ?p ?u; ?p \\<noteq> []; simple ?p\\<rbrakk>\n  \\<Longrightarrow> False\n  p \\<noteq> []\n  simple p\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma join_trees:     \n  assumes TREE: \"tree g\\<^sub>1\" \"tree g\\<^sub>2\"\n  assumes DJ: \"nodes g\\<^sub>1 \\<inter> nodes g\\<^sub>2 = {}\"\n  assumes IN_NODES: \"u\\<in>nodes g\\<^sub>1\" \"v\\<in>nodes g\\<^sub>2\"\n  shows \"tree (ins_edge (u,v) (graph_join g\\<^sub>1 g\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))", "using assms join_cycle_free join_connected"], ["proof (prove)\nusing this:\n  tree g\\<^sub>1\n  tree g\\<^sub>2\n  nodes g\\<^sub>1 \\<inter> nodes g\\<^sub>2 = {}\n  u \\<in> nodes g\\<^sub>1\n  v \\<in> nodes g\\<^sub>2\n  \\<lbrakk>cycle_free ?g\\<^sub>1; cycle_free ?g\\<^sub>2;\n   nodes ?g\\<^sub>1 \\<inter> nodes ?g\\<^sub>2 = {};\n   ?u \\<in> nodes ?g\\<^sub>1; ?v \\<in> nodes ?g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> cycle_free\n                     (ins_edge (?u, ?v) (graph_join ?g\\<^sub>1 ?g\\<^sub>2))\n  \\<lbrakk>Undirected_Graph.connected ?g\\<^sub>1;\n   Undirected_Graph.connected ?g\\<^sub>2; ?u \\<in> nodes ?g\\<^sub>1;\n   ?v \\<in> nodes ?g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> Undirected_Graph.connected\n                     (ins_edge (?u, ?v) (graph_join ?g\\<^sub>1 ?g\\<^sub>2))\n\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))", "unfolding tree_def"], ["proof (prove)\nusing this:\n  Undirected_Graph.connected g\\<^sub>1 \\<and> cycle_free g\\<^sub>1\n  Undirected_Graph.connected g\\<^sub>2 \\<and> cycle_free g\\<^sub>2\n  nodes g\\<^sub>1 \\<inter> nodes g\\<^sub>2 = {}\n  u \\<in> nodes g\\<^sub>1\n  v \\<in> nodes g\\<^sub>2\n  \\<lbrakk>cycle_free ?g\\<^sub>1; cycle_free ?g\\<^sub>2;\n   nodes ?g\\<^sub>1 \\<inter> nodes ?g\\<^sub>2 = {};\n   ?u \\<in> nodes ?g\\<^sub>1; ?v \\<in> nodes ?g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> cycle_free\n                     (ins_edge (?u, ?v) (graph_join ?g\\<^sub>1 ?g\\<^sub>2))\n  \\<lbrakk>Undirected_Graph.connected ?g\\<^sub>1;\n   Undirected_Graph.connected ?g\\<^sub>2; ?u \\<in> nodes ?g\\<^sub>1;\n   ?v \\<in> nodes ?g\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> Undirected_Graph.connected\n                     (ins_edge (?u, ?v) (graph_join ?g\\<^sub>1 ?g\\<^sub>2))\n\ngoal (1 subgoal):\n 1. Undirected_Graph.connected\n     (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2)) \\<and>\n    cycle_free (ins_edge (u, v) (graph_join g\\<^sub>1 g\\<^sub>2))", "by metis"], ["", "lemma split_tree:\n  assumes \"tree T\" \"(x,y)\\<in>edges T\"\n  defines \"E' \\<equiv> (edges T - {(x,y),(y,x)})\"\n  obtains T1 T2 where \n    \"tree T1\" \"tree T2\" \n    \"nodes T1 \\<inter> nodes T2 = {}\" \"nodes T = nodes T1 \\<union> nodes T2\"\n    \"edges T1 \\<union> edges T2 = E'\"\n    \"nodes T1 = { u. (x,u)\\<in>E'\\<^sup>*}\" \"nodes T2 = { u. (y,u)\\<in>E'\\<^sup>*}\"\n    \"x\\<in>nodes T1\" \"y\\<in>nodes T2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "(* TODO: Use component_of here! *)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define N1 where \"N1 = { u. (x,u)\\<in>E'\\<^sup>* }\""], ["proof (state)\nthis:\n  N1 = {u. (x, u) \\<in> E'\\<^sup>*}\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define N2 where \"N2 = { u. (y,u)\\<in>E'\\<^sup>* }\""], ["proof (state)\nthis:\n  N2 = {u. (y, u) \\<in> E'\\<^sup>*}\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define T1 where \"T1 = restrict_nodes T N1\""], ["proof (state)\nthis:\n  T1 = restrict_nodes T N1\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define T2 where \"T2 = restrict_nodes T N2\""], ["proof (state)\nthis:\n  T2 = restrict_nodes T N2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have SYME: \"sym (E'\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (E'\\<^sup>*)", "apply (rule sym_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sym E'", "using edges_sym[of T]"], ["proof (prove)\nusing this:\n  sym (edges T)\n\ngoal (1 subgoal):\n 1. sym E'", "by (auto simp: sym_def E'_def)"], ["proof (state)\nthis:\n  sym (E'\\<^sup>*)\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  tree T\n  (x, y) \\<in> edges T\n  E' \\<equiv> edges T - {(x, y), (y, x)}", "have \"connected T\" \"cycle_free T\""], ["proof (prove)\nusing this:\n  tree T\n  (x, y) \\<in> edges T\n  E' \\<equiv> edges T - {(x, y), (y, x)}\n\ngoal (1 subgoal):\n 1. Undirected_Graph.connected T &&& cycle_free T", "unfolding tree_def"], ["proof (prove)\nusing this:\n  Undirected_Graph.connected T \\<and> cycle_free T\n  (x, y) \\<in> edges T\n  E' \\<equiv> edges T - {(x, y), (y, x)}\n\ngoal (1 subgoal):\n 1. Undirected_Graph.connected T &&& cycle_free T", "by auto"], ["proof (state)\nthis:\n  Undirected_Graph.connected T\n  cycle_free T\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>cycle_free T\\<close>"], ["proof (chain)\npicking this:\n  cycle_free T", "have \"cycle_free T1\" \"cycle_free T2\""], ["proof (prove)\nusing this:\n  cycle_free T\n\ngoal (1 subgoal):\n 1. cycle_free T1 &&& cycle_free T2", "unfolding T1_def T2_def"], ["proof (prove)\nusing this:\n  cycle_free T\n\ngoal (1 subgoal):\n 1. cycle_free (restrict_nodes T N1) &&& cycle_free (restrict_nodes T N2)", "using cycle_free_antimono unrestrictn_edges"], ["proof (prove)\nusing this:\n  cycle_free T\n  \\<lbrakk>edges ?g \\<subseteq> edges ?g'; cycle_free ?g'\\<rbrakk>\n  \\<Longrightarrow> cycle_free ?g\n  edges (restrict_nodes ?g ?V) \\<subseteq> edges ?g\n\ngoal (1 subgoal):\n 1. cycle_free (restrict_nodes T N1) &&& cycle_free (restrict_nodes T N2)", "by blast+"], ["proof (state)\nthis:\n  cycle_free T1\n  cycle_free T2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>(x,y) \\<in> edges T\\<close>"], ["proof (chain)\npicking this:\n  (x, y) \\<in> edges T", "have XYN: \"x\\<in>nodes T\" \"y\\<in>nodes T\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> edges T\n\ngoal (1 subgoal):\n 1. x \\<in> nodes T &&& y \\<in> nodes T", "using edges_subset"], ["proof (prove)\nusing this:\n  (x, y) \\<in> edges T\n  edges ?g \\<subseteq> nodes ?g \\<times> nodes ?g\n\ngoal (1 subgoal):\n 1. x \\<in> nodes T &&& y \\<in> nodes T", "by auto"], ["proof (state)\nthis:\n  x \\<in> nodes T\n  y \\<in> nodes T\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from XYN"], ["proof (chain)\npicking this:\n  x \\<in> nodes T\n  y \\<in> nodes T", "have [simp]: \"nodes T1 = N1\" \"nodes T2 = N2\""], ["proof (prove)\nusing this:\n  x \\<in> nodes T\n  y \\<in> nodes T\n\ngoal (1 subgoal):\n 1. nodes T1 = N1 &&& nodes T2 = N2", "unfolding T1_def T2_def N1_def N2_def"], ["proof (prove)\nusing this:\n  x \\<in> nodes T\n  y \\<in> nodes T\n\ngoal (1 subgoal):\n 1. nodes (restrict_nodes T {u. (x, u) \\<in> E'\\<^sup>*}) =\n    {u. (x, u) \\<in> E'\\<^sup>*} &&&\n    nodes (restrict_nodes T {u. (y, u) \\<in> E'\\<^sup>*}) =\n    {u. (y, u) \\<in> E'\\<^sup>*}", "unfolding E'_def"], ["proof (prove)\nusing this:\n  x \\<in> nodes T\n  y \\<in> nodes T\n\ngoal (1 subgoal):\n 1. nodes\n     (restrict_nodes T\n       {u. (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*}) =\n    {u. (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*} &&&\n    nodes\n     (restrict_nodes T\n       {u. (y, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*}) =\n    {u. (y, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*}", "apply (safe)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> nodes T; y \\<in> nodes T;\n        xa \\<in> nodes\n                  (restrict_nodes T\n                    {u. (x, u)\n                        \\<in> (edges T -\n                               {(x, y), (y, x)})\\<^sup>*})\\<rbrakk>\n       \\<Longrightarrow> (x, xa) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\n 2. \\<And>xa.\n       \\<lbrakk>x \\<in> nodes T; y \\<in> nodes T;\n        (x, xa) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nodes\n                                   (restrict_nodes T\n                                     {u.\n(x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*})\n 3. \\<And>xa.\n       \\<lbrakk>x \\<in> nodes T; y \\<in> nodes T;\n        xa \\<in> nodes\n                  (restrict_nodes T\n                    {u. (y, u)\n                        \\<in> (edges T -\n                               {(x, y), (y, x)})\\<^sup>*})\\<rbrakk>\n       \\<Longrightarrow> (y, xa) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\n 4. \\<And>xa.\n       \\<lbrakk>x \\<in> nodes T; y \\<in> nodes T;\n        (y, xa) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nodes\n                                   (restrict_nodes T\n                                     {u.\n(y, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*})", "apply (all \\<open>clarsimp\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> nodes T; y \\<in> nodes T;\n        (x, xa) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nodes T\n 2. \\<And>xa.\n       \\<lbrakk>x \\<in> nodes T; y \\<in> nodes T;\n        (y, xa) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nodes T", "by (metis DiffD1 nodesI(2) rtrancl.simps)+"], ["proof (state)\nthis:\n  nodes T1 = N1\n  nodes T2 = N2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"x\\<in>N1\" \"y\\<in>N2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> N1 &&& y \\<in> N2", "by (auto simp: N1_def N2_def)"], ["proof (state)\nthis:\n  x \\<in> N1\n  y \\<in> N2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"N1 \\<inter> N2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<inter> N2 = {}", "proof (safe;simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> N1; x \\<in> N2\\<rbrakk> \\<Longrightarrow> False", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> N1; x \\<in> N2\\<rbrakk> \\<Longrightarrow> False", "assume \"u\\<in>N1\" \"u\\<in>N2\""], ["proof (state)\nthis:\n  u \\<in> N1\n  u \\<in> N2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> N1; x \\<in> N2\\<rbrakk> \\<Longrightarrow> False", "hence \"(x,u)\\<in>E'\\<^sup>*\" \"(u,y)\\<in>E'\\<^sup>*\""], ["proof (prove)\nusing this:\n  u \\<in> N1\n  u \\<in> N2\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> E'\\<^sup>* &&& (u, y) \\<in> E'\\<^sup>*", "by (auto simp: N1_def N2_def symD[OF SYME])"], ["proof (state)\nthis:\n  (x, u) \\<in> E'\\<^sup>*\n  (u, y) \\<in> E'\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> N1; x \\<in> N2\\<rbrakk> \\<Longrightarrow> False", "with cycle_free_altD[OF \\<open>cycle_free T\\<close> \\<open>(x,y)\\<in>edges T\\<close>]"], ["proof (chain)\npicking this:\n  (x, y) \\<notin> (edges T - {(x, y), (y, x)})\\<^sup>*\n  (x, u) \\<in> E'\\<^sup>*\n  (u, y) \\<in> E'\\<^sup>*", "show False"], ["proof (prove)\nusing this:\n  (x, y) \\<notin> (edges T - {(x, y), (y, x)})\\<^sup>*\n  (x, u) \\<in> E'\\<^sup>*\n  (u, y) \\<in> E'\\<^sup>*\n\ngoal (1 subgoal):\n 1. False", "unfolding E'_def"], ["proof (prove)\nusing this:\n  (x, y) \\<notin> (edges T - {(x, y), (y, x)})\\<^sup>*\n  (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\n  (u, y) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\n\ngoal (1 subgoal):\n 1. False", "by (meson rtrancl_trans)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N1 \\<inter> N2 = {}\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have N1C: \"E'``N1 \\<subseteq> N1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E' `` N1 \\<subseteq> N1", "unfolding N1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E' `` {u. (x, u) \\<in> E'\\<^sup>*}\n    \\<subseteq> {u. (x, u) \\<in> E'\\<^sup>*}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>(xaa, xa) \\<in> E'; (x, xaa) \\<in> E'\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (x, xa) \\<in> E'\\<^sup>*", "by (simp add: rtrancl.rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  E' `` N1 \\<subseteq> N1\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have N2C: \"E'``N2 \\<subseteq> N2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E' `` N2 \\<subseteq> N2", "unfolding N2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E' `` {u. (y, u) \\<in> E'\\<^sup>*}\n    \\<subseteq> {u. (y, u) \\<in> E'\\<^sup>*}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E'; (y, xa) \\<in> E'\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (y, x) \\<in> E'\\<^sup>*", "by (simp add: rtrancl.rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  E' `` N2 \\<subseteq> N2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have XE1: \"(x,u) \\<in> (edges T1)\\<^sup>*\" if \"u\\<in>N1\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, u) \\<in> (edges T1)\\<^sup>*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, u) \\<in> (edges T1)\\<^sup>*", "from that"], ["proof (chain)\npicking this:\n  u \\<in> N1", "have \"(x,u)\\<in>E'\\<^sup>*\""], ["proof (prove)\nusing this:\n  u \\<in> N1\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> E'\\<^sup>*", "by (auto simp: N1_def)"], ["proof (state)\nthis:\n  (x, u) \\<in> E'\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> (edges T1)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (x, u) \\<in> E'\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, u) \\<in> E'\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> (edges T1)\\<^sup>*", "using \\<open>x\\<in>N1\\<close>"], ["proof (prove)\nusing this:\n  (x, u) \\<in> E'\\<^sup>*\n  x \\<in> N1\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> (edges T1)\\<^sup>*", "unfolding T1_def"], ["proof (prove)\nusing this:\n  (x, u) \\<in> E'\\<^sup>*\n  x \\<in> N1\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*", "proof (induction rule: converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> N1 \\<Longrightarrow>\n    (u, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> E'; (z, u) \\<in> E'\\<^sup>*;\n        z \\<in> N1 \\<Longrightarrow>\n        (z, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*;\n        y \\<in> N1\\<rbrakk>\n       \\<Longrightarrow> (y, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*", "case (step y z)"], ["proof (state)\nthis:\n  (y, z) \\<in> E'\n  (z, u) \\<in> E'\\<^sup>*\n  z \\<in> N1 \\<Longrightarrow>\n  (z, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*\n  y \\<in> N1\n\ngoal (2 subgoals):\n 1. u \\<in> N1 \\<Longrightarrow>\n    (u, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> E'; (z, u) \\<in> E'\\<^sup>*;\n        z \\<in> N1 \\<Longrightarrow>\n        (z, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*;\n        y \\<in> N1\\<rbrakk>\n       \\<Longrightarrow> (y, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*", "with N1C"], ["proof (chain)\npicking this:\n  E' `` N1 \\<subseteq> N1\n  (y, z) \\<in> E'\n  (z, u) \\<in> E'\\<^sup>*\n  z \\<in> N1 \\<Longrightarrow>\n  (z, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*\n  y \\<in> N1", "have \"z\\<in>N1\""], ["proof (prove)\nusing this:\n  E' `` N1 \\<subseteq> N1\n  (y, z) \\<in> E'\n  (z, u) \\<in> E'\\<^sup>*\n  z \\<in> N1 \\<Longrightarrow>\n  (z, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*\n  y \\<in> N1\n\ngoal (1 subgoal):\n 1. z \\<in> N1", "by auto"], ["proof (state)\nthis:\n  z \\<in> N1\n\ngoal (2 subgoals):\n 1. u \\<in> N1 \\<Longrightarrow>\n    (u, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> E'; (z, u) \\<in> E'\\<^sup>*;\n        z \\<in> N1 \\<Longrightarrow>\n        (z, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*;\n        y \\<in> N1\\<rbrakk>\n       \\<Longrightarrow> (y, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*", "with step.hyps(1) step.prems"], ["proof (chain)\npicking this:\n  (y, z) \\<in> E'\n  y \\<in> N1\n  z \\<in> N1", "have \"(y,z)\\<in>Restr (edges T) N1\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> E'\n  y \\<in> N1\n  z \\<in> N1\n\ngoal (1 subgoal):\n 1. (y, z) \\<in> Restr (edges T) N1", "unfolding E'_def"], ["proof (prove)\nusing this:\n  (y, z) \\<in> edges T - {(x, y), (y, x)}\n  y \\<in> N1\n  z \\<in> N1\n\ngoal (1 subgoal):\n 1. (y, z) \\<in> Restr (edges T) N1", "by auto"], ["proof (state)\nthis:\n  (y, z) \\<in> Restr (edges T) N1\n\ngoal (2 subgoals):\n 1. u \\<in> N1 \\<Longrightarrow>\n    (u, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> E'; (z, u) \\<in> E'\\<^sup>*;\n        z \\<in> N1 \\<Longrightarrow>\n        (z, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*;\n        y \\<in> N1\\<rbrakk>\n       \\<Longrightarrow> (y, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*", "with step.IH[OF \\<open>z\\<in>N1\\<close>]"], ["proof (chain)\npicking this:\n  (z, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*\n  (y, z) \\<in> Restr (edges T) N1", "show ?case"], ["proof (prove)\nusing this:\n  (z, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*\n  (y, z) \\<in> Restr (edges T) N1\n\ngoal (1 subgoal):\n 1. (y, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*", "by (metis converse_rtrancl_into_rtrancl edges_restrict_nodes)"], ["proof (state)\nthis:\n  (y, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*\n\ngoal (1 subgoal):\n 1. u \\<in> N1 \\<Longrightarrow>\n    (u, u) \\<in> (edges (restrict_nodes T N1))\\<^sup>*", "qed auto"], ["proof (state)\nthis:\n  (x, u) \\<in> (edges T1)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<in> N1 \\<Longrightarrow> (x, ?u) \\<in> (edges T1)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have XE2: \"(y,u) \\<in> (edges T2)\\<^sup>*\" if \"u\\<in>N2\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, u) \\<in> (edges T2)\\<^sup>*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (y, u) \\<in> (edges T2)\\<^sup>*", "from that"], ["proof (chain)\npicking this:\n  u \\<in> N2", "have \"(y,u)\\<in>E'\\<^sup>*\""], ["proof (prove)\nusing this:\n  u \\<in> N2\n\ngoal (1 subgoal):\n 1. (y, u) \\<in> E'\\<^sup>*", "by (auto simp: N2_def)"], ["proof (state)\nthis:\n  (y, u) \\<in> E'\\<^sup>*\n\ngoal (1 subgoal):\n 1. (y, u) \\<in> (edges T2)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (y, u) \\<in> E'\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  (y, u) \\<in> E'\\<^sup>*\n\ngoal (1 subgoal):\n 1. (y, u) \\<in> (edges T2)\\<^sup>*", "using \\<open>y\\<in>N2\\<close>"], ["proof (prove)\nusing this:\n  (y, u) \\<in> E'\\<^sup>*\n  y \\<in> N2\n\ngoal (1 subgoal):\n 1. (y, u) \\<in> (edges T2)\\<^sup>*", "unfolding T2_def"], ["proof (prove)\nusing this:\n  (y, u) \\<in> E'\\<^sup>*\n  y \\<in> N2\n\ngoal (1 subgoal):\n 1. (y, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*", "proof (induction rule: converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> N2 \\<Longrightarrow>\n    (u, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> E'; (z, u) \\<in> E'\\<^sup>*;\n        z \\<in> N2 \\<Longrightarrow>\n        (z, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*;\n        y \\<in> N2\\<rbrakk>\n       \\<Longrightarrow> (y, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*", "case (step y z)"], ["proof (state)\nthis:\n  (y, z) \\<in> E'\n  (z, u) \\<in> E'\\<^sup>*\n  z \\<in> N2 \\<Longrightarrow>\n  (z, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*\n  y \\<in> N2\n\ngoal (2 subgoals):\n 1. u \\<in> N2 \\<Longrightarrow>\n    (u, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> E'; (z, u) \\<in> E'\\<^sup>*;\n        z \\<in> N2 \\<Longrightarrow>\n        (z, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*;\n        y \\<in> N2\\<rbrakk>\n       \\<Longrightarrow> (y, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*", "with N2C"], ["proof (chain)\npicking this:\n  E' `` N2 \\<subseteq> N2\n  (y, z) \\<in> E'\n  (z, u) \\<in> E'\\<^sup>*\n  z \\<in> N2 \\<Longrightarrow>\n  (z, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*\n  y \\<in> N2", "have \"z\\<in>N2\""], ["proof (prove)\nusing this:\n  E' `` N2 \\<subseteq> N2\n  (y, z) \\<in> E'\n  (z, u) \\<in> E'\\<^sup>*\n  z \\<in> N2 \\<Longrightarrow>\n  (z, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*\n  y \\<in> N2\n\ngoal (1 subgoal):\n 1. z \\<in> N2", "by auto"], ["proof (state)\nthis:\n  z \\<in> N2\n\ngoal (2 subgoals):\n 1. u \\<in> N2 \\<Longrightarrow>\n    (u, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> E'; (z, u) \\<in> E'\\<^sup>*;\n        z \\<in> N2 \\<Longrightarrow>\n        (z, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*;\n        y \\<in> N2\\<rbrakk>\n       \\<Longrightarrow> (y, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*", "with step.hyps(1) step.prems"], ["proof (chain)\npicking this:\n  (y, z) \\<in> E'\n  y \\<in> N2\n  z \\<in> N2", "have \"(y,z)\\<in>Restr (edges T) N2\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> E'\n  y \\<in> N2\n  z \\<in> N2\n\ngoal (1 subgoal):\n 1. (y, z) \\<in> Restr (edges T) N2", "unfolding E'_def"], ["proof (prove)\nusing this:\n  (y, z) \\<in> edges T - {(x, y), (y, x)}\n  y \\<in> N2\n  z \\<in> N2\n\ngoal (1 subgoal):\n 1. (y, z) \\<in> Restr (edges T) N2", "by auto"], ["proof (state)\nthis:\n  (y, z) \\<in> Restr (edges T) N2\n\ngoal (2 subgoals):\n 1. u \\<in> N2 \\<Longrightarrow>\n    (u, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> E'; (z, u) \\<in> E'\\<^sup>*;\n        z \\<in> N2 \\<Longrightarrow>\n        (z, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*;\n        y \\<in> N2\\<rbrakk>\n       \\<Longrightarrow> (y, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*", "with step.IH[OF \\<open>z\\<in>N2\\<close>]"], ["proof (chain)\npicking this:\n  (z, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*\n  (y, z) \\<in> Restr (edges T) N2", "show ?case"], ["proof (prove)\nusing this:\n  (z, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*\n  (y, z) \\<in> Restr (edges T) N2\n\ngoal (1 subgoal):\n 1. (y, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*", "by (metis converse_rtrancl_into_rtrancl edges_restrict_nodes)"], ["proof (state)\nthis:\n  (y, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*\n\ngoal (1 subgoal):\n 1. u \\<in> N2 \\<Longrightarrow>\n    (u, u) \\<in> (edges (restrict_nodes T N2))\\<^sup>*", "qed auto"], ["proof (state)\nthis:\n  (y, u) \\<in> (edges T2)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<in> N2 \\<Longrightarrow> (y, ?u) \\<in> (edges T2)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"connected T1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected T1", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> nodes T1; v \\<in> nodes T1\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (edges T1)\\<^sup>*", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> N1; v \\<in> N1\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (edges T1)\\<^sup>*", "apply (drule XE1)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>(x, u) \\<in> (edges T1)\\<^sup>*;\n        (x, v) \\<in> (edges T1)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (edges T1)\\<^sup>*", "by (meson rtrancl_edges_sym' rtrancl_trans)"], ["proof (state)\nthis:\n  Undirected_Graph.connected T1\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"connected T2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected T2", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> nodes T2; v \\<in> nodes T2\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (edges T2)\\<^sup>*", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> N2; v \\<in> N2\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (edges T2)\\<^sup>*", "apply (drule XE2)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>(y, u) \\<in> (edges T2)\\<^sup>*;\n        (y, v) \\<in> (edges T2)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (edges T2)\\<^sup>*", "by (meson rtrancl_edges_sym' rtrancl_trans)"], ["proof (state)\nthis:\n  Undirected_Graph.connected T2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"u\\<in>N1 \\<union> N2\" if \"u\\<in>nodes T\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> N1 \\<union> N2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> N1 \\<union> N2", "from connectedD[OF \\<open>connected T\\<close> \\<open>x\\<in>nodes T\\<close> that ]"], ["proof (chain)\npicking this:\n  (x, u) \\<in> (edges T)\\<^sup>*", "obtain p where P: \"path T x p u\" \"simple p\""], ["proof (prove)\nusing this:\n  (x, u) \\<in> (edges T)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path T x p u; simple p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: rtrancl_edges_iff_path elim: simplify_pathE)"], ["proof (state)\nthis:\n  path T x p u\n  simple p\n\ngoal (1 subgoal):\n 1. u \\<in> N1 \\<union> N2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> N1 \\<union> N2", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u \\<in> N1 \\<union> N2\n 2. \\<not> ?P \\<Longrightarrow> u \\<in> N1 \\<union> N2", "assume \"(x,y)\\<notin>set p \\<and> (y,x)\\<notin>set p\""], ["proof (state)\nthis:\n  (x, y) \\<notin> set p \\<and> (y, x) \\<notin> set p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u \\<in> N1 \\<union> N2\n 2. \\<not> ?P \\<Longrightarrow> u \\<in> N1 \\<union> N2", "with P(1)"], ["proof (chain)\npicking this:\n  path T x p u\n  (x, y) \\<notin> set p \\<and> (y, x) \\<notin> set p", "have \"path (restrict_edges T E') x p u\""], ["proof (prove)\nusing this:\n  path T x p u\n  (x, y) \\<notin> set p \\<and> (y, x) \\<notin> set p\n\ngoal (1 subgoal):\n 1. path (restrict_edges T E') x p u", "unfolding E'_def"], ["proof (prove)\nusing this:\n  path T x p u\n  (x, y) \\<notin> set p \\<and> (y, x) \\<notin> set p\n\ngoal (1 subgoal):\n 1. path (restrict_edges T (edges T - {(x, y), (y, x)})) x p u", "by (erule_tac path_graph_cong) auto"], ["proof (state)\nthis:\n  path (restrict_edges T E') x p u\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u \\<in> N1 \\<union> N2\n 2. \\<not> ?P \\<Longrightarrow> u \\<in> N1 \\<union> N2", "from path_rtrancl_edgesD[OF this]"], ["proof (chain)\npicking this:\n  (x, u) \\<in> (edges (restrict_edges T E'))\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, u) \\<in> (edges (restrict_edges T E'))\\<^sup>*\n\ngoal (1 subgoal):\n 1. u \\<in> N1 \\<union> N2", "unfolding N1_def E'_def"], ["proof (prove)\nusing this:\n  (x, u)\n  \\<in> (edges (restrict_edges T (edges T - {(x, y), (y, x)})))\\<^sup>*\n\ngoal (1 subgoal):\n 1. u \\<in> {u. (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*} \\<union>\n            N2", "by auto"], ["proof (state)\nthis:\n  u \\<in> N1 \\<union> N2\n\ngoal (1 subgoal):\n 1. \\<not> ((x, y) \\<notin> set p \\<and>\n            (y, x) \\<notin> set p) \\<Longrightarrow>\n    u \\<in> N1 \\<union> N2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((x, y) \\<notin> set p \\<and>\n            (y, x) \\<notin> set p) \\<Longrightarrow>\n    u \\<in> N1 \\<union> N2", "assume \"\\<not>((x,y)\\<notin>set p \\<and> (y,x)\\<notin>set p)\""], ["proof (state)\nthis:\n  \\<not> ((x, y) \\<notin> set p \\<and> (y, x) \\<notin> set p)\n\ngoal (1 subgoal):\n 1. \\<not> ((x, y) \\<notin> set p \\<and>\n            (y, x) \\<notin> set p) \\<Longrightarrow>\n    u \\<in> N1 \\<union> N2", "with P"], ["proof (chain)\npicking this:\n  path T x p u\n  simple p\n  \\<not> ((x, y) \\<notin> set p \\<and> (y, x) \\<notin> set p)", "obtain p' where \n        \"uedge (x,y)\\<notin>set (map uedge p')\" \"path T y p' u \\<or> path T x p' u\""], ["proof (prove)\nusing this:\n  path T x p u\n  simple p\n  \\<not> ((x, y) \\<notin> set p \\<and> (y, x) \\<notin> set p)\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>uedge (x, y) \\<notin> set (map uedge p');\n         path T y p' u \\<or> path T x p' u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp uedge_commute)"], ["proof (state)\nthis:\n  uedge (x, y) \\<notin> set (map uedge p')\n  path T y p' u \\<or> path T x p' u\n\ngoal (1 subgoal):\n 1. \\<not> ((x, y) \\<notin> set p \\<and>\n            (y, x) \\<notin> set p) \\<Longrightarrow>\n    u \\<in> N1 \\<union> N2", "hence \"path (restrict_edges T E') y p' u \\<or> path (restrict_edges T E') x p' u\""], ["proof (prove)\nusing this:\n  uedge (x, y) \\<notin> set (map uedge p')\n  path T y p' u \\<or> path T x p' u\n\ngoal (1 subgoal):\n 1. path (restrict_edges T E') y p' u \\<or>\n    path (restrict_edges T E') x p' u", "apply (clarsimp simp: uedge_in_set_eq E'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path T y p' u \\<or> path T x p' u; (x, y) \\<notin> set p';\n     (y, x) \\<notin> set p';\n     \\<not> path (restrict_edges T (edges T - {(x, y), (y, x)})) x p'\n             u\\<rbrakk>\n    \\<Longrightarrow> path (restrict_edges T (edges T - {(x, y), (y, x)})) y\n                       p' u", "by (smt ComplD DiffI Int_iff UnCI edges_restrict_edges insertE \n                path_graph_cong subset_Compl_singleton subset_iff)"], ["proof (state)\nthis:\n  path (restrict_edges T E') y p' u \\<or> path (restrict_edges T E') x p' u\n\ngoal (1 subgoal):\n 1. \\<not> ((x, y) \\<notin> set p \\<and>\n            (y, x) \\<notin> set p) \\<Longrightarrow>\n    u \\<in> N1 \\<union> N2", "then"], ["proof (chain)\npicking this:\n  path (restrict_edges T E') y p' u \\<or> path (restrict_edges T E') x p' u", "show ?thesis"], ["proof (prove)\nusing this:\n  path (restrict_edges T E') y p' u \\<or> path (restrict_edges T E') x p' u\n\ngoal (1 subgoal):\n 1. u \\<in> N1 \\<union> N2", "unfolding N1_def N2_def E'_def"], ["proof (prove)\nusing this:\n  path (restrict_edges T (edges T - {(x, y), (y, x)})) y p' u \\<or>\n  path (restrict_edges T (edges T - {(x, y), (y, x)})) x p' u\n\ngoal (1 subgoal):\n 1. u \\<in> {u. (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*} \\<union>\n            {u. (y, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*}", "by (auto dest: path_rtrancl_edgesD)"], ["proof (state)\nthis:\n  u \\<in> N1 \\<union> N2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<in> N1 \\<union> N2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<in> nodes T \\<Longrightarrow> ?u \\<in> N1 \\<union> N2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  ?u \\<in> nodes T \\<Longrightarrow> ?u \\<in> N1 \\<union> N2", "have \"nodes T = N1 \\<union> N2\""], ["proof (prove)\nusing this:\n  ?u \\<in> nodes T \\<Longrightarrow> ?u \\<in> N1 \\<union> N2\n\ngoal (1 subgoal):\n 1. nodes T = N1 \\<union> N2", "unfolding N1_def N2_def"], ["proof (prove)\nusing this:\n  ?u \\<in> nodes T \\<Longrightarrow>\n  ?u \\<in> {u. (x, u) \\<in> E'\\<^sup>*} \\<union>\n           {u. (y, u) \\<in> E'\\<^sup>*}\n\ngoal (1 subgoal):\n 1. nodes T =\n    {u. (x, u) \\<in> E'\\<^sup>*} \\<union> {u. (y, u) \\<in> E'\\<^sup>*}", "using XYN"], ["proof (prove)\nusing this:\n  ?u \\<in> nodes T \\<Longrightarrow>\n  ?u \\<in> {u. (x, u) \\<in> E'\\<^sup>*} \\<union>\n           {u. (y, u) \\<in> E'\\<^sup>*}\n  x \\<in> nodes T\n  y \\<in> nodes T\n\ngoal (1 subgoal):\n 1. nodes T =\n    {u. (x, u) \\<in> E'\\<^sup>*} \\<union> {u. (y, u) \\<in> E'\\<^sup>*}", "unfolding E'_def"], ["proof (prove)\nusing this:\n  ?u \\<in> nodes T \\<Longrightarrow>\n  ?u \\<in> {u. (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*} \\<union>\n           {u. (y, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*}\n  x \\<in> nodes T\n  y \\<in> nodes T\n\ngoal (1 subgoal):\n 1. nodes T =\n    {u. (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*} \\<union>\n    {u. (y, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*}", "apply (safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>u.\n                   u \\<in> nodes T \\<Longrightarrow>\n                   u \\<in> {u. (x, u)\n                               \\<in> (edges T -\n{(x, y), (y, x)})\\<^sup>*} \\<union>\n                           {u. (y, u)\n                               \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n        x \\<in> nodes T; y \\<in> nodes T; xa \\<in> nodes T;\n        (y, xa) \\<notin> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (x, xa) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\n 2. \\<And>xa.\n       \\<lbrakk>\\<And>u.\n                   u \\<in> nodes T \\<Longrightarrow>\n                   u \\<in> {u. (x, u)\n                               \\<in> (edges T -\n{(x, y), (y, x)})\\<^sup>*} \\<union>\n                           {u. (y, u)\n                               \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n        x \\<in> nodes T; y \\<in> nodes T;\n        (x, xa) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nodes T\n 3. \\<And>xa.\n       \\<lbrakk>\\<And>u.\n                   u \\<in> nodes T \\<Longrightarrow>\n                   u \\<in> {u. (x, u)\n                               \\<in> (edges T -\n{(x, y), (y, x)})\\<^sup>*} \\<union>\n                           {u. (y, u)\n                               \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n        x \\<in> nodes T; y \\<in> nodes T;\n        (y, xa) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nodes T", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u.\n                u \\<in> nodes T \\<Longrightarrow>\n                u \\<in> {u. (x, u)\n                            \\<in> (edges T -\n                                   {(x, y), (y, x)})\\<^sup>*} \\<union>\n                        {u. (y, u)\n                            \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n     x \\<in> nodes T; y \\<in> nodes T; xa_ \\<in> nodes T;\n     (y, xa_) \\<notin> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> (x, xa_) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*", "by auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>u.\n                   u \\<in> nodes T \\<Longrightarrow>\n                   u \\<in> {u. (x, u)\n                               \\<in> (edges T -\n{(x, y), (y, x)})\\<^sup>*} \\<union>\n                           {u. (y, u)\n                               \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n        x \\<in> nodes T; y \\<in> nodes T;\n        (x, xa) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nodes T\n 2. \\<And>xa.\n       \\<lbrakk>\\<And>u.\n                   u \\<in> nodes T \\<Longrightarrow>\n                   u \\<in> {u. (x, u)\n                               \\<in> (edges T -\n{(x, y), (y, x)})\\<^sup>*} \\<union>\n                           {u. (y, u)\n                               \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n        x \\<in> nodes T; y \\<in> nodes T;\n        (y, xa) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nodes T", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u.\n                u \\<in> nodes T \\<Longrightarrow>\n                u \\<in> {u. (x, u)\n                            \\<in> (edges T -\n                                   {(x, y), (y, x)})\\<^sup>*} \\<union>\n                        {u. (y, u)\n                            \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n     x \\<in> nodes T; y \\<in> nodes T;\n     (x, xa_) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> xa_ \\<in> nodes T", "by (metis DiffD1 nodesI(2) rtrancl.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>u.\n                   u \\<in> nodes T \\<Longrightarrow>\n                   u \\<in> {u. (x, u)\n                               \\<in> (edges T -\n{(x, y), (y, x)})\\<^sup>*} \\<union>\n                           {u. (y, u)\n                               \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n        x \\<in> nodes T; y \\<in> nodes T;\n        (y, xa) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> nodes T", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u.\n                u \\<in> nodes T \\<Longrightarrow>\n                u \\<in> {u. (x, u)\n                            \\<in> (edges T -\n                                   {(x, y), (y, x)})\\<^sup>*} \\<union>\n                        {u. (y, u)\n                            \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n     x \\<in> nodes T; y \\<in> nodes T;\n     (y, xa_) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> xa_ \\<in> nodes T", "by (metis DiffD1 nodesI(2) rtrancl.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nodes T = N1 \\<union> N2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"edges T1 \\<union> edges T2 \\<subseteq> E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges T1 \\<union> edges T2 \\<subseteq> E'", "unfolding T1_def T2_def E'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (restrict_nodes T N1) \\<union> edges (restrict_nodes T N2)\n    \\<subseteq> edges T - {(x, y), (y, x)}", "using \\<open>N1 \\<inter> N2 = {}\\<close> \\<open>x \\<in> N1\\<close> \\<open>y \\<in> N2\\<close>"], ["proof (prove)\nusing this:\n  N1 \\<inter> N2 = {}\n  x \\<in> N1\n  y \\<in> N2\n\ngoal (1 subgoal):\n 1. edges (restrict_nodes T N1) \\<union> edges (restrict_nodes T N2)\n    \\<subseteq> edges T - {(x, y), (y, x)}", "by auto"], ["proof (state)\nthis:\n  edges T1 \\<union> edges T2 \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  edges T1 \\<union> edges T2 \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"edges T1 \\<union> edges T2 \\<supseteq> E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E' \\<subseteq> edges T1 \\<union> edges T2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E' \\<subseteq> edges T1 \\<union> edges T2", "note ED1 = nodesI[where g=T, unfolded \\<open>nodes T = N1\\<union>N2\\<close>]"], ["proof (state)\nthis:\n  (?u, ?v) \\<in> edges T \\<Longrightarrow> ?u \\<in> N1 \\<union> N2\n  (?u, ?v) \\<in> edges T \\<Longrightarrow> ?v \\<in> N1 \\<union> N2\n\ngoal (1 subgoal):\n 1. E' \\<subseteq> edges T1 \\<union> edges T2", "have \"E' \\<subseteq> edges T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E' \\<subseteq> edges T", "by (auto simp: E'_def)"], ["proof (state)\nthis:\n  E' \\<subseteq> edges T\n\ngoal (1 subgoal):\n 1. E' \\<subseteq> edges T1 \\<union> edges T2", "thus \"edges T1 \\<union> edges T2 \\<supseteq> E'\""], ["proof (prove)\nusing this:\n  E' \\<subseteq> edges T\n\ngoal (1 subgoal):\n 1. E' \\<subseteq> edges T1 \\<union> edges T2", "unfolding T1_def T2_def"], ["proof (prove)\nusing this:\n  E' \\<subseteq> edges T\n\ngoal (1 subgoal):\n 1. E' \\<subseteq> edges (restrict_nodes T N1) \\<union>\n                   edges (restrict_nodes T N2)", "using ED1 N1C N2C"], ["proof (prove)\nusing this:\n  E' \\<subseteq> edges T\n  (?u, ?v) \\<in> edges T \\<Longrightarrow> ?u \\<in> N1 \\<union> N2\n  (?u, ?v) \\<in> edges T \\<Longrightarrow> ?v \\<in> N1 \\<union> N2\n  E' `` N1 \\<subseteq> N1\n  E' `` N2 \\<subseteq> N2\n\ngoal (1 subgoal):\n 1. E' \\<subseteq> edges (restrict_nodes T N1) \\<union>\n                   edges (restrict_nodes T N2)", "by (auto; blast)"], ["proof (state)\nthis:\n  E' \\<subseteq> edges T1 \\<union> edges T2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E' \\<subseteq> edges T1 \\<union> edges T2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  edges T1 \\<union> edges T2 = E'", "have \"edges T1 \\<union> edges T2 = E'\""], ["proof (prove)\nusing this:\n  edges T1 \\<union> edges T2 = E'\n\ngoal (1 subgoal):\n 1. edges T1 \\<union> edges T2 = E'", "."], ["proof (state)\nthis:\n  edges T1 \\<union> edges T2 = E'\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = E';\n         nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}; x \\<in> nodes T1;\n         y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule that[of T1 T2, unfolded tree_def]; (intro conjI)?; fact?)"], ["proof (prove)\ngoal (6 subgoals):\n 1. nodes T1 \\<inter> nodes T2 = {}\n 2. nodes T = nodes T1 \\<union> nodes T2\n 3. nodes T1 = {u. (x, u) \\<in> E'\\<^sup>*}\n 4. nodes T2 = {u. (y, u) \\<in> E'\\<^sup>*}\n 5. x \\<in> nodes T1\n 6. y \\<in> nodes T2", "apply simp_all"], ["proof (prove)\ngoal (6 subgoals):\n 1. N1 \\<inter> N2 = {}\n 2. nodes T = N1 \\<union> N2\n 3. N1 = {u. (x, u) \\<in> E'\\<^sup>*}\n 4. N2 = {u. (y, u) \\<in> E'\\<^sup>*}\n 5. x \\<in> N1\n 6. y \\<in> N2", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Spanning Trees\\<close>"], ["", "definition \"is_spanning_tree G T \n  \\<equiv> tree T \\<and> nodes T = nodes G \\<and> edges T \\<subseteq> edges G\""], ["", "(* TODO: Move *)"], ["", "lemma connected_singleton[simp]: \"connected (ins_node u graph_empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected (ins_node u graph_empty)", "unfolding connected_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (ins_node u graph_empty) \\<times> nodes (ins_node u graph_empty)\n    \\<subseteq> (edges (ins_node u graph_empty))\\<^sup>*", "by auto"], ["", "lemma path_singleton[simp]: \"path (ins_node u graph_empty) v p w \\<longleftrightarrow> v=w \\<and> p=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (ins_node u graph_empty) v p w = (v = w \\<and> p = [])", "by (cases p) auto"], ["", "lemma tree_singleton[simp]: \"tree (ins_node u graph_empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree (ins_node u graph_empty)", "by (simp add: cycle_free_no_edges tree_def)"], ["", "(* TODO: Move *)"], ["", "lemma tree_add_edge_in_out:\n  assumes \"tree T\"\n  assumes \"u\\<in>nodes T\" \"v\\<notin>nodes T\"\n  shows \"tree (ins_edge (u,v) T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) T)", "from assms"], ["proof (chain)\npicking this:\n  tree T\n  u \\<in> nodes T\n  v \\<notin> nodes T", "have [simp]: \"u\\<noteq>v\""], ["proof (prove)\nusing this:\n  tree T\n  u \\<in> nodes T\n  v \\<notin> nodes T\n\ngoal (1 subgoal):\n 1. u \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) T)", "have \"ins_edge (u,v) T = ins_edge (u,v) (graph_join T (ins_node v graph_empty))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ins_edge (u, v) T =\n    ins_edge (u, v) (graph_join T (ins_node v graph_empty))", "by (auto simp: graph_eq_iff)"], ["proof (state)\nthis:\n  ins_edge (u, v) T =\n  ins_edge (u, v) (graph_join T (ins_node v graph_empty))\n\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) T)", "also"], ["proof (state)\nthis:\n  ins_edge (u, v) T =\n  ins_edge (u, v) (graph_join T (ins_node v graph_empty))\n\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) T)", "have \"tree \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) (graph_join T (ins_node v graph_empty)))", "apply (rule join_trees)"], ["proof (prove)\ngoal (5 subgoals):\n 1. tree T\n 2. tree (ins_node v graph_empty)\n 3. nodes T \\<inter> nodes (ins_node v graph_empty) = {}\n 4. u \\<in> nodes T\n 5. v \\<in> nodes (ins_node v graph_empty)", "using assms"], ["proof (prove)\nusing this:\n  tree T\n  u \\<in> nodes T\n  v \\<notin> nodes T\n\ngoal (5 subgoals):\n 1. tree T\n 2. tree (ins_node v graph_empty)\n 3. nodes T \\<inter> nodes (ins_node v graph_empty) = {}\n 4. u \\<in> nodes T\n 5. v \\<in> nodes (ins_node v graph_empty)", "by auto"], ["proof (state)\nthis:\n  tree (ins_edge (u, v) (graph_join T (ins_node v graph_empty)))\n\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) T)", "finally"], ["proof (chain)\npicking this:\n  tree (ins_edge (u, v) T)", "show ?thesis"], ["proof (prove)\nusing this:\n  tree (ins_edge (u, v) T)\n\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) T)", "."], ["proof (state)\nthis:\n  tree (ins_edge (u, v) T)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Remove edges on cycles until the graph is cycle free\\<close>"], ["", "lemma ex_spanning_tree: \n  \"connected g \\<Longrightarrow> \\<exists>t. is_spanning_tree g t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected g \\<Longrightarrow>\n    \\<exists>t. is_spanning_tree g t", "using edges_finite[of g]"], ["proof (prove)\nusing this:\n  finite (edges g)\n\ngoal (1 subgoal):\n 1. Undirected_Graph.connected g \\<Longrightarrow>\n    \\<exists>t. is_spanning_tree g t", "proof (induction \"edges g\" arbitrary: g rule: finite_psubset_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>finite (edges g);\n        \\<And>ga.\n           \\<lbrakk>edges ga \\<subset> edges g;\n            Undirected_Graph.connected ga\\<rbrakk>\n           \\<Longrightarrow> Ex (is_spanning_tree ga);\n        Undirected_Graph.connected g\\<rbrakk>\n       \\<Longrightarrow> Ex (is_spanning_tree g)", "case psubset"], ["proof (state)\nthis:\n  finite (edges g)\n  \\<lbrakk>edges ?g \\<subset> edges g;\n   Undirected_Graph.connected ?g\\<rbrakk>\n  \\<Longrightarrow> Ex (is_spanning_tree ?g)\n  Undirected_Graph.connected g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>finite (edges g);\n        \\<And>ga.\n           \\<lbrakk>edges ga \\<subset> edges g;\n            Undirected_Graph.connected ga\\<rbrakk>\n           \\<Longrightarrow> Ex (is_spanning_tree ga);\n        Undirected_Graph.connected g\\<rbrakk>\n       \\<Longrightarrow> Ex (is_spanning_tree g)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex (is_spanning_tree g)", "proof (cases \"cycle_free g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)\n 2. \\<not> cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)", "case True"], ["proof (state)\nthis:\n  cycle_free g\n\ngoal (2 subgoals):\n 1. cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)\n 2. \\<not> cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)", "with \\<open>connected g\\<close>"], ["proof (chain)\npicking this:\n  Undirected_Graph.connected g\n  cycle_free g", "show ?thesis"], ["proof (prove)\nusing this:\n  Undirected_Graph.connected g\n  cycle_free g\n\ngoal (1 subgoal):\n 1. Ex (is_spanning_tree g)", "by (auto simp: is_spanning_tree_def tree_def)"], ["proof (state)\nthis:\n  Ex (is_spanning_tree g)\n\ngoal (1 subgoal):\n 1. \\<not> cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)", "case False"], ["proof (state)\nthis:\n  \\<not> cycle_free g\n\ngoal (1 subgoal):\n 1. \\<not> cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)", "then"], ["proof (chain)\npicking this:\n  \\<not> cycle_free g", "obtain u v where \n          EDGE: \"(u,v)\\<in>edges g\" \n      and RED: \"(u,v)\\<in>(edges g - {(u,v),(v,u)})\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<not> cycle_free g\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>(u, v) \\<in> edges g;\n         (u, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cycle_free_altI"], ["proof (prove)\nusing this:\n  \\<not> cycle_free g\n  (\\<And>u v.\n      \\<lbrakk>(u, v) \\<in> edges ?g;\n       (u, v) \\<in> (edges ?g - {(u, v), (v, u)})\\<^sup>*\\<rbrakk>\n      \\<Longrightarrow> False) \\<Longrightarrow>\n  cycle_free ?g\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>(u, v) \\<in> edges g;\n         (u, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (u, v) \\<in> edges g\n  (u, v) \\<in> (edges g - {(u, v), (v, u)})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<not> cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)", "from \\<open>connected g\\<close>"], ["proof (chain)\npicking this:\n  Undirected_Graph.connected g", "have \"connected (restrict_edges g (- {(u,v),(v,u)}))\" (is \"connected ?g'\")"], ["proof (prove)\nusing this:\n  Undirected_Graph.connected g\n\ngoal (1 subgoal):\n 1. Undirected_Graph.connected (restrict_edges g (- {(u, v), (v, u)}))", "unfolding connected_def"], ["proof (prove)\nusing this:\n  nodes g \\<times> nodes g \\<subseteq> (edges g)\\<^sup>*\n\ngoal (1 subgoal):\n 1. nodes (restrict_edges g (- {(u, v), (v, u)})) \\<times>\n    nodes (restrict_edges g (- {(u, v), (v, u)}))\n    \\<subseteq> (edges (restrict_edges g (- {(u, v), (v, u)})))\\<^sup>*", "by (auto simp: remove_redundant_edge[OF RED])"], ["proof (state)\nthis:\n  Undirected_Graph.connected (restrict_edges g (- {(u, v), (v, u)}))\n\ngoal (1 subgoal):\n 1. \\<not> cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)", "moreover"], ["proof (state)\nthis:\n  Undirected_Graph.connected (restrict_edges g (- {(u, v), (v, u)}))\n\ngoal (1 subgoal):\n 1. \\<not> cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)", "have \"edges ?g' \\<subset> edges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (restrict_edges g (- {(u, v), (v, u)})) \\<subset> edges g", "using EDGE"], ["proof (prove)\nusing this:\n  (u, v) \\<in> edges g\n\ngoal (1 subgoal):\n 1. edges (restrict_edges g (- {(u, v), (v, u)})) \\<subset> edges g", "by auto"], ["proof (state)\nthis:\n  edges (restrict_edges g (- {(u, v), (v, u)})) \\<subset> edges g\n\ngoal (1 subgoal):\n 1. \\<not> cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)", "ultimately"], ["proof (chain)\npicking this:\n  Undirected_Graph.connected (restrict_edges g (- {(u, v), (v, u)}))\n  edges (restrict_edges g (- {(u, v), (v, u)})) \\<subset> edges g", "obtain t where \"is_spanning_tree ?g' t\""], ["proof (prove)\nusing this:\n  Undirected_Graph.connected (restrict_edges g (- {(u, v), (v, u)}))\n  edges (restrict_edges g (- {(u, v), (v, u)})) \\<subset> edges g\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        is_spanning_tree (restrict_edges g (- {(u, v), (v, u)}))\n         t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using psubset.hyps(2)[of ?g']"], ["proof (prove)\nusing this:\n  Undirected_Graph.connected (restrict_edges g (- {(u, v), (v, u)}))\n  edges (restrict_edges g (- {(u, v), (v, u)})) \\<subset> edges g\n  \\<lbrakk>edges (restrict_edges g (- {(u, v), (v, u)})) \\<subset> edges g;\n   Undirected_Graph.connected\n    (restrict_edges g (- {(u, v), (v, u)}))\\<rbrakk>\n  \\<Longrightarrow> Ex (is_spanning_tree\n                         (restrict_edges g (- {(u, v), (v, u)})))\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        is_spanning_tree (restrict_edges g (- {(u, v), (v, u)}))\n         t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_spanning_tree (restrict_edges g (- {(u, v), (v, u)})) t\n\ngoal (1 subgoal):\n 1. \\<not> cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)", "hence \"is_spanning_tree g t\""], ["proof (prove)\nusing this:\n  is_spanning_tree (restrict_edges g (- {(u, v), (v, u)})) t\n\ngoal (1 subgoal):\n 1. is_spanning_tree g t", "by (auto simp: is_spanning_tree_def)"], ["proof (state)\nthis:\n  is_spanning_tree g t\n\ngoal (1 subgoal):\n 1. \\<not> cycle_free g \\<Longrightarrow> Ex (is_spanning_tree g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_spanning_tree g t\n\ngoal (1 subgoal):\n 1. Ex (is_spanning_tree g)", ".."], ["proof (state)\nthis:\n  Ex (is_spanning_tree g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ex (is_spanning_tree g)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Weighted Undirected Graphs\\<close>"], ["", "definition weight :: \"('v set \\<Rightarrow> nat) \\<Rightarrow> 'v ugraph \\<Rightarrow> nat\" \n  where \"weight w g \\<equiv> (\\<Sum>e\\<in>edges g. w (uedge e)) div 2\""], ["", "lemma weight_alt: \"weight w g = (\\<Sum>e\\<in>uedge`edges g. w e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "from split_edges_sym[of g]"], ["proof (chain)\npicking this:\n  \\<exists>E.\n     E \\<inter> E\\<inverse> = {} \\<and> edges g = E \\<union> E\\<inverse>", "obtain E where \n    \"edges g = E \\<union> E\\<inverse>\" and \"E\\<inter>E\\<inverse>={}\""], ["proof (prove)\nusing this:\n  \\<exists>E.\n     E \\<inter> E\\<inverse> = {} \\<and> edges g = E \\<union> E\\<inverse>\n\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>edges g = E \\<union> E\\<inverse>;\n         E \\<inter> E\\<inverse> = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  edges g = E \\<union> E\\<inverse>\n  E \\<inter> E\\<inverse> = {}\n\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "hence [simp, intro!]: \"finite E\""], ["proof (prove)\nusing this:\n  edges g = E \\<union> E\\<inverse>\n  E \\<inter> E\\<inverse> = {}\n\ngoal (1 subgoal):\n 1. finite E", "by (metis edges_finite finite_Un)"], ["proof (state)\nthis:\n  finite E\n\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "hence [simp, intro!]: \"finite (E\\<inverse>)\""], ["proof (prove)\nusing this:\n  finite E\n\ngoal (1 subgoal):\n 1. finite (E\\<inverse>)", "by blast"], ["proof (state)\nthis:\n  finite (E\\<inverse>)\n\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "have [simp]: \"(\\<Sum>e\\<in>E\\<inverse>. w (uedge e)) = (\\<Sum>e\\<in>E. w (uedge e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>E\\<inverse>. w (uedge e)) = (\\<Sum>e\\<in>E. w (uedge e))", "apply (rule sum.reindex_cong[where l=prod.swap and A=\"E\\<inverse>\" and B=\"E\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on prod.swap E\n 2. E\\<inverse> = prod.swap ` E\n 3. \\<And>x.\n       x \\<in> E \\<Longrightarrow> w (uedge (prod.swap x)) = w (uedge x)", "by (auto simp: uedge_def insert_commute)"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>E\\<inverse>. w (uedge e)) = (\\<Sum>e\\<in>E. w (uedge e))\n\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "have [simp]: \"inj_on uedge E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on uedge E", "using \\<open>E\\<inter>E\\<inverse>=_\\<close>"], ["proof (prove)\nusing this:\n  E \\<inter> E\\<inverse> = {}\n\ngoal (1 subgoal):\n 1. inj_on uedge E", "by (auto simp: uedge_def inj_on_def doubleton_eq_iff)"], ["proof (state)\nthis:\n  inj_on uedge E\n\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "have \"weight w g = (\\<Sum>e\\<in>E. w (uedge e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight w g = (\\<Sum>e\\<in>E. w (uedge e))", "unfolding weight_def \\<open>edges g = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>E \\<union> E\\<inverse>. w (uedge e)) div 2 =\n    (\\<Sum>e\\<in>E. w (uedge e))", "using \\<open>E\\<inter>E\\<inverse>={}\\<close>"], ["proof (prove)\nusing this:\n  E \\<inter> E\\<inverse> = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>E \\<union> E\\<inverse>. w (uedge e)) div 2 =\n    (\\<Sum>e\\<in>E. w (uedge e))", "by (auto simp: sum.union_disjoint)"], ["proof (state)\nthis:\n  weight w g = (\\<Sum>e\\<in>E. w (uedge e))\n\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "also"], ["proof (state)\nthis:\n  weight w g = (\\<Sum>e\\<in>E. w (uedge e))\n\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "have \"\\<dots> = (\\<Sum>e\\<in>uedge`E. w e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>E. w (uedge e)) = sum w (uedge ` E)", "using sum.reindex[of uedge E w]"], ["proof (prove)\nusing this:\n  inj_on uedge E \\<Longrightarrow>\n  sum w (uedge ` E) = sum (w \\<circ> uedge) E\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>E. w (uedge e)) = sum w (uedge ` E)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>E. w (uedge e)) = sum w (uedge ` E)\n\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "also"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>E. w (uedge e)) = sum w (uedge ` E)\n\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "have \"uedge`E = uedge`(edges g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uedge ` E = uedge ` edges g", "unfolding \\<open>edges g = _\\<close> uedge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). {a, b}) ` E =\n    (\\<lambda>(a, b). {a, b}) ` (E \\<union> E\\<inverse>)", "using \\<open>E\\<inter>E\\<inverse>={}\\<close>"], ["proof (prove)\nusing this:\n  E \\<inter> E\\<inverse> = {}\n\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). {a, b}) ` E =\n    (\\<lambda>(a, b). {a, b}) ` (E \\<union> E\\<inverse>)", "by auto"], ["proof (state)\nthis:\n  uedge ` E = uedge ` edges g\n\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "finally"], ["proof (chain)\npicking this:\n  weight w g = sum w (uedge ` edges g)", "show ?thesis"], ["proof (prove)\nusing this:\n  weight w g = sum w (uedge ` edges g)\n\ngoal (1 subgoal):\n 1. weight w g = sum w (uedge ` edges g)", "."], ["proof (state)\nthis:\n  weight w g = sum w (uedge ` edges g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma weight_empty[simp]: \"weight w graph_empty = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight w graph_empty = 0", "unfolding weight_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>edges graph_empty. w (uedge e)) div 2 = 0", "by auto"], ["", "lemma weight_ins_edge[simp]: \"\\<lbrakk>u\\<noteq>v; (u,v)\\<notin>edges g\\<rbrakk> \n  \\<Longrightarrow> weight w (ins_edge (u,v) g) = w {u,v} + weight w g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<noteq> v; (u, v) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> weight w (ins_edge (u, v) g) = w {u, v} + weight w g", "unfolding weight_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<noteq> v; (u, v) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>e\\<in>edges (ins_edge (u, v) g).\n                         w (uedge e)) div\n                      2 =\n                      w {u, v} + (\\<Sum>e\\<in>edges g. w (uedge e)) div 2", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<noteq> v; (u, v) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> (w (uedge (u, v)) +\n                       (\\<Sum>e\\<in>insert (v, u) (edges g).\n                          w (uedge e))) div\n                      2 =\n                      w {u, v} + (\\<Sum>e\\<in>edges g. w (uedge e)) div 2", "apply (subst sum.insert)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>u \\<noteq> v; (u, v) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> finite (edges g)\n 2. \\<lbrakk>u \\<noteq> v; (u, v) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> (v, u) \\<notin> edges g\n 3. \\<lbrakk>u \\<noteq> v; (u, v) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> (w (uedge (u, v)) +\n                       (w (uedge (v, u)) +\n                        (\\<Sum>e\\<in>edges g. w (uedge e)))) div\n                      2 =\n                      w {u, v} + (\\<Sum>e\\<in>edges g. w (uedge e)) div 2", "by (auto dest: edges_sym' simp: uedge_def insert_commute)"], ["", "lemma uedge_img_disj_iff[simp]: \n  \"uedge`edges g\\<^sub>1 \\<inter> uedge`edges g\\<^sub>2 = {} \\<longleftrightarrow> edges g\\<^sub>1 \\<inter> edges g\\<^sub>2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uedge ` edges g\\<^sub>1 \\<inter> uedge ` edges g\\<^sub>2 = {}) =\n    (edges g\\<^sub>1 \\<inter> edges g\\<^sub>2 = {})", "by (auto simp: uedge_eq_iff dest: edges_sym')+"], ["", "lemma weight_join[simp]: \"edges g\\<^sub>1 \\<inter> edges g\\<^sub>2 = {} \n  \\<Longrightarrow> weight w (graph_join g\\<^sub>1 g\\<^sub>2) = weight w g\\<^sub>1 + weight w g\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges g\\<^sub>1 \\<inter> edges g\\<^sub>2 = {} \\<Longrightarrow>\n    weight w (graph_join g\\<^sub>1 g\\<^sub>2) =\n    weight w g\\<^sub>1 + weight w g\\<^sub>2", "unfolding weight_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges g\\<^sub>1 \\<inter> edges g\\<^sub>2 = {} \\<Longrightarrow>\n    sum w (uedge ` edges (graph_join g\\<^sub>1 g\\<^sub>2)) =\n    sum w (uedge ` edges g\\<^sub>1) + sum w (uedge ` edges g\\<^sub>2)", "by (auto simp: sum.union_disjoint image_Un)"], ["", "lemma weight_cong: \"edges g\\<^sub>1 = edges g\\<^sub>2 \\<Longrightarrow> weight w g\\<^sub>1 = weight w g\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges g\\<^sub>1 = edges g\\<^sub>2 \\<Longrightarrow>\n    weight w g\\<^sub>1 = weight w g\\<^sub>2", "by (auto simp: weight_def)"], ["", "lemma weight_mono: \"edges g \\<subseteq> edges g' \\<Longrightarrow> weight w g \\<le> weight w g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges g \\<subseteq> edges g' \\<Longrightarrow>\n    weight w g \\<le> weight w g'", "unfolding weight_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges g \\<subseteq> edges g' \\<Longrightarrow>\n    sum w (uedge ` edges g) \\<le> sum w (uedge ` edges g')", "by (rule sum_mono2) auto"], ["", "lemma weight_ge_edge:\n  assumes \"(x,y)\\<in>edges T\"\n  shows \"weight w T \\<ge> w {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w {x, y} \\<le> weight w T", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> edges T\n\ngoal (1 subgoal):\n 1. w {x, y} \\<le> weight w T", "unfolding weight_alt"], ["proof (prove)\nusing this:\n  (x, y) \\<in> edges T\n\ngoal (1 subgoal):\n 1. w {x, y} \\<le> sum w (uedge ` edges T)", "by (auto simp: uedge_def intro: member_le_sum)"], ["", "lemma weight_del_edge[simp]: \n  assumes \"(x,y)\\<in>edges T\"  \n  shows \"weight w (restrict_edges T (- {(x, y), (y, x)})) = weight w T - w {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight w (restrict_edges T (- {(x, y), (y, x)})) = weight w T - w {x, y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. weight w (restrict_edges T (- {(x, y), (y, x)})) = weight w T - w {x, y}", "define E where \"E = uedge ` edges T - {{x,y}}\""], ["proof (state)\nthis:\n  E = uedge ` edges T - {{x, y}}\n\ngoal (1 subgoal):\n 1. weight w (restrict_edges T (- {(x, y), (y, x)})) = weight w T - w {x, y}", "have [simp]: \"(uedge ` (edges T - {(x, y), (y, x)})) = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uedge ` (edges T - {(x, y), (y, x)}) = E", "by (safe; simp add: E_def uedge_def doubleton_eq_iff; blast)"], ["proof (state)\nthis:\n  uedge ` (edges T - {(x, y), (y, x)}) = E\n\ngoal (1 subgoal):\n 1. weight w (restrict_edges T (- {(x, y), (y, x)})) = weight w T - w {x, y}", "from assms"], ["proof (chain)\npicking this:\n  (x, y) \\<in> edges T", "have [simp]: \"uedge ` edges T = insert {x,y} E\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> edges T\n\ngoal (1 subgoal):\n 1. uedge ` edges T = insert {x, y} E", "unfolding E_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> edges T\n\ngoal (1 subgoal):\n 1. uedge ` edges T = insert {x, y} (uedge ` edges T - {{x, y}})", "by force"], ["proof (state)\nthis:\n  uedge ` edges T = insert {x, y} E\n\ngoal (1 subgoal):\n 1. weight w (restrict_edges T (- {(x, y), (y, x)})) = weight w T - w {x, y}", "have [simp]: \"{x,y}\\<notin>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<notin> E", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<notin> uedge ` edges T - {{x, y}}", "by blast"], ["proof (state)\nthis:\n  {x, y} \\<notin> E\n\ngoal (1 subgoal):\n 1. weight w (restrict_edges T (- {(x, y), (y, x)})) = weight w T - w {x, y}", "then"], ["proof (chain)\npicking this:\n  {x, y} \\<notin> E", "show ?thesis"], ["proof (prove)\nusing this:\n  {x, y} \\<notin> E\n\ngoal (1 subgoal):\n 1. weight w (restrict_edges T (- {(x, y), (y, x)})) = weight w T - w {x, y}", "unfolding weight_alt"], ["proof (prove)\nusing this:\n  {x, y} \\<notin> E\n\ngoal (1 subgoal):\n 1. sum w (uedge ` edges (restrict_edges T (- {(x, y), (y, x)}))) =\n    sum w (uedge ` edges T) - w {x, y}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum w E = sum w (insert {x, y} E) - w {x, y}", "by (metis E_def \\<open>uedge ` edges T = insert {x, y} E\\<close> insertI1 sum_diff1_nat)"], ["proof (state)\nthis:\n  weight w (restrict_edges T (- {(x, y), (y, x)})) = weight w T - w {x, y}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Minimum Spanning Trees\\<close>"], ["", "definition \"is_MST w g t \\<equiv> is_spanning_tree g t \n  \\<and> (\\<forall>t'. is_spanning_tree g t' \\<longrightarrow> weight w t \\<le> weight w t')\""], ["", "lemma exists_MST: \"connected g \\<Longrightarrow> \\<exists>t. is_MST w g t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected g \\<Longrightarrow> \\<exists>t. is_MST w g t", "using ex_has_least_nat[of \"is_spanning_tree g\"] ex_spanning_tree"], ["proof (prove)\nusing this:\n  is_spanning_tree g ?k \\<Longrightarrow>\n  \\<exists>x.\n     is_spanning_tree g x \\<and>\n     (\\<forall>y. is_spanning_tree g y \\<longrightarrow> ?m x \\<le> ?m y)\n  Undirected_Graph.connected ?g \\<Longrightarrow>\n  \\<exists>t. is_spanning_tree ?g t\n\ngoal (1 subgoal):\n 1. Undirected_Graph.connected g \\<Longrightarrow> \\<exists>t. is_MST w g t", "unfolding is_MST_def"], ["proof (prove)\nusing this:\n  is_spanning_tree g ?k \\<Longrightarrow>\n  \\<exists>x.\n     is_spanning_tree g x \\<and>\n     (\\<forall>y. is_spanning_tree g y \\<longrightarrow> ?m x \\<le> ?m y)\n  Undirected_Graph.connected ?g \\<Longrightarrow>\n  \\<exists>t. is_spanning_tree ?g t\n\ngoal (1 subgoal):\n 1. Undirected_Graph.connected g \\<Longrightarrow>\n    \\<exists>t.\n       is_spanning_tree g t \\<and>\n       (\\<forall>t'.\n           is_spanning_tree g t' \\<longrightarrow>\n           weight w t \\<le> weight w t')", "by blast"], ["", "end"]]}