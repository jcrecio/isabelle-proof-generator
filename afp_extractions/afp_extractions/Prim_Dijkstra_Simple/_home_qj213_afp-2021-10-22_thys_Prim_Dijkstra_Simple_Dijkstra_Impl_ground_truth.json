{"file_name": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple/Dijkstra_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple", "problem_names": ["lemmas [simp] = G.wgraph_specs", "lemmas [simp] = M.map_specs", "lemmas [simp] = Q.prio_map_specs", "lemma map_getminE:\n  assumes \"getmin m = (k,p)\" \"invar m\" \"lookup m \\<noteq> Map.empty\" \n  obtains \"lookup m k = Some p\" \"\\<forall>k' p'. lookup m k' = Some p' \\<longrightarrow> p\\<le>p'\"", "lemma finite_all_dnodes[simp, intro!]: \"finite all_dnodes\"", "lemma finite_unfinished_dnodes[simp, intro!]: \"finite (unfinished_dnodes S)\"", "lemma (in -) fold_refine:\n  assumes \"I s\"\n  assumes \"\\<And>s x. I s \\<Longrightarrow> x\\<in>set l \\<Longrightarrow> I (f x s) \\<and> \\<alpha> (f x s) = f' x (\\<alpha> s)\"\n  shows \"I (fold f l s) \\<and> \\<alpha> (fold f l s) = fold f' l (\\<alpha> s)\"", "lemma Q_relax_outgoing[simp]:\n  assumes [simp]: \"Q_invar Q\"\n  shows \"Q_invar (Q_relax_outgoing u du V Q) \n       \\<and> Q_lookup (Q_relax_outgoing u du V Q) \n          = relax_outgoing' u du (M_lookup V) (Q_lookup Q)\"", "lemma Q_init_Q[simp]:\n  shows \"Q_invar (Q_initQ)\" \"Q_lookup (Q_initQ) = initQ\"", "lemma M_initS[simp]: \"M_invar M_initV\" \"M_lookup M_initV = initV\"", "lemma transfer_preconditions:\n  assumes \"coupling Q V D S\"\n  shows \"Q u = Some du \\<longleftrightarrow> D u = enat du \\<and> u\\<notin>S\"", "lemma dijkstra_loop_invar_and_empty:\n  shows \"case dijkstra_loop of (Q,V) \\<Rightarrow> D_invar_impl Q V \\<and> Q_is_empty Q\"", "lemma dijkstra_correct: \n  \"M_invar dijkstra\" \n  \"M_lookup dijkstra u = Some d \\<longleftrightarrow> \\<delta> s u = enat d\"", "lemmas [code] =    \n  D.dijkstra_def D.dijkstra_loop_def", "lemmas dijkstra_correct = AUX.dijkstra_correct[folded dijkstra_def]", "theorem dijkstra_list_correct:\n  \"case dijkstra_list l s of\n    None \\<Rightarrow> \\<not>valid_graph_rep l\n  | Some D \\<Rightarrow> \n        valid_graph_rep l \n      \\<and> M.invar D \n      \\<and> (\\<forall>u d. lookup D u = Some d \\<longleftrightarrow> WGraph.\\<delta> (wgraph_of_list l) s u = enat d)\""], "translations": [["", "lemmas [simp] = G.wgraph_specs"], ["", "lemmas [simp] = M.map_specs"], ["", "lemmas [simp] = Q.prio_map_specs"], ["", "end"], ["", "context PrioMap begin"], ["", "lemma map_getminE:\n  assumes \"getmin m = (k,p)\" \"invar m\" \"lookup m \\<noteq> Map.empty\" \n  obtains \"lookup m k = Some p\" \"\\<forall>k' p'. lookup m k' = Some p' \\<longrightarrow> p\\<le>p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>lookup m k = Some p;\n      \\<forall>k' p'.\n         lookup m k' = Some p' \\<longrightarrow> p \\<le> p'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using map_getmin[OF assms]"], ["proof (prove)\nusing this:\n  lookup m k = Some p \\<and> (\\<forall>p'\\<in>ran (lookup m). p \\<le> p')\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>lookup m k = Some p;\n      \\<forall>k' p'.\n         lookup m k' = Some p' \\<longrightarrow> p \\<le> p'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: ran_def)"], ["", "end"], ["", "locale Dijkstra_Impl_Defs = Dijkstra_Impl_Adts where G_\\<alpha> = G_\\<alpha>\n  + Dijkstra \\<open>G_\\<alpha> g\\<close> s\n  for G_\\<alpha> :: \"'g \\<Rightarrow> ('v::linorder) wgraph\" and g s"], ["", "locale Dijkstra_Impl = Dijkstra_Impl_Defs where G_\\<alpha> = G_\\<alpha>  \n  for G_\\<alpha> :: \"'g \\<Rightarrow> ('v::linorder) wgraph\" \n  +\n  assumes G_invar[simp]: \"G_invar g\"\nbegin"], ["", "lemma finite_all_dnodes[simp, intro!]: \"finite all_dnodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite all_dnodes", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite all_dnodes", "have \"all_dnodes \\<subseteq> Set.insert s (snd ` edges)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_dnodes \\<subseteq> Set.insert s (snd ` edges)", "by (fastforce simp: all_dnodes_def edges_def image_iff)"], ["proof (state)\nthis:\n  all_dnodes \\<subseteq> Set.insert s (snd ` edges)\n\ngoal (1 subgoal):\n 1. finite all_dnodes", "also"], ["proof (state)\nthis:\n  all_dnodes \\<subseteq> Set.insert s (snd ` edges)\n\ngoal (1 subgoal):\n 1. finite all_dnodes", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Set.insert s (snd ` edges))", "by (auto simp: G.finite)"], ["proof (state)\nthis:\n  finite (Set.insert s (snd ` edges))\n\ngoal (1 subgoal):\n 1. finite all_dnodes", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite all_dnodes", "show ?thesis"], ["proof (prove)\nusing this:\n  finite all_dnodes\n\ngoal (1 subgoal):\n 1. finite all_dnodes", "."], ["proof (state)\nthis:\n  finite all_dnodes\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_unfinished_dnodes[simp, intro!]: \"finite (unfinished_dnodes S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (unfinished_dnodes S)", "using finite_subset[OF unfinished_nodes_subset]"], ["proof (prove)\nusing this:\n  finite all_dnodes \\<Longrightarrow> finite (unfinished_dnodes ?S1)\n\ngoal (1 subgoal):\n 1. finite (unfinished_dnodes S)", "by auto"], ["", "lemma (in -) fold_refine:\n  assumes \"I s\"\n  assumes \"\\<And>s x. I s \\<Longrightarrow> x\\<in>set l \\<Longrightarrow> I (f x s) \\<and> \\<alpha> (f x s) = f' x (\\<alpha> s)\"\n  shows \"I (fold f l s) \\<and> \\<alpha> (fold f l s) = fold f' l (\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (fold f l s) \\<and> \\<alpha> (fold f l s) = fold f' l (\\<alpha> s)", "using assms"], ["proof (prove)\nusing this:\n  I s\n  \\<lbrakk>I ?s; ?x \\<in> set l\\<rbrakk>\n  \\<Longrightarrow> I (f ?x ?s) \\<and>\n                    \\<alpha> (f ?x ?s) = f' ?x (\\<alpha> ?s)\n\ngoal (1 subgoal):\n 1. I (fold f l s) \\<and> \\<alpha> (fold f l s) = fold f' l (\\<alpha> s)", "by (induction l arbitrary: s) auto"], ["", "definition (in Dijkstra_Impl_Defs) \"Q_relax_outgoing u du V Q = fold (\\<lambda>(d,v) Q.\n  case Q_lookup Q v of \n    None \\<Rightarrow> if M_lookup V v \\<noteq> None then Q else Q_update v (du+d) Q\n  | Some d' \\<Rightarrow> Q_update v (min (du+d) d') Q) ((G_succ g u)) Q\""], ["", "lemma Q_relax_outgoing[simp]:\n  assumes [simp]: \"Q_invar Q\"\n  shows \"Q_invar (Q_relax_outgoing u du V Q) \n       \\<and> Q_lookup (Q_relax_outgoing u du V Q) \n          = relax_outgoing' u du (M_lookup V) (Q_lookup Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_invar (Q_relax_outgoing u du V Q) \\<and>\n    Q_lookup (Q_relax_outgoing u du V Q) =\n    relax_outgoing' u du (M_lookup V) (Q_lookup Q)", "apply (subst relax_outgoing''_refine[symmetric, where l=\"G_succ g u\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (G_succ g u) = {(d, v). G_\\<alpha> g (u, v) = enat d}\n 2. Q_invar (Q_relax_outgoing u du V Q) \\<and>\n    Q_lookup (Q_relax_outgoing u du V Q) =\n    relax_outgoing'' (G_succ g u) du (M_lookup V) (Q_lookup Q)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_invar (Q_relax_outgoing u du V Q) \\<and>\n    Q_lookup (Q_relax_outgoing u du V Q) =\n    relax_outgoing'' (G_succ g u) du (M_lookup V) (Q_lookup Q)", "unfolding Q_relax_outgoing_def relax_outgoing''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_invar\n     (fold\n       (\\<lambda>(d, v) Q.\n           case Q_lookup Q v of\n           None \\<Rightarrow>\n             if M_lookup V v \\<noteq> None then Q else Q_update v (du + d) Q\n           | Some d' \\<Rightarrow> Q_update v (min (du + d) d') Q)\n       (G_succ g u) Q) \\<and>\n    Q_lookup\n     (fold\n       (\\<lambda>(d, v) Q.\n           case Q_lookup Q v of\n           None \\<Rightarrow>\n             if M_lookup V v \\<noteq> None then Q else Q_update v (du + d) Q\n           | Some d' \\<Rightarrow> Q_update v (min (du + d) d') Q)\n       (G_succ g u) Q) =\n    fold\n     (\\<lambda>(d, v) Q.\n         case Q v of\n         None \\<Rightarrow>\n           if v \\<in> dom (M_lookup V) then Q else Q(v \\<mapsto> du + d)\n         | Some d' \\<Rightarrow> Q(v \\<mapsto> min (du + d) d'))\n     (G_succ g u) (Q_lookup Q)", "apply (rule fold_refine[where I=Q_invar and \\<alpha>=Q_lookup])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Q_invar Q\n 2. \\<And>s x.\n       \\<lbrakk>Q_invar s; x \\<in> set (G_succ g u)\\<rbrakk>\n       \\<Longrightarrow> Q_invar\n                          ((case x of\n                            (d, v) \\<Rightarrow>\n                              \\<lambda>Q.\n                                 case Q_lookup Q v of\n                                 None \\<Rightarrow>\n                                   if M_lookup V v \\<noteq> None then Q\n                                   else Q_update v (du + d) Q\n                                 | Some d' \\<Rightarrow>\n                                     Q_update v (min (du + d) d') Q)\n                            s) \\<and>\n                         Q_lookup\n                          ((case x of\n                            (d, v) \\<Rightarrow>\n                              \\<lambda>Q.\n                                 case Q_lookup Q v of\n                                 None \\<Rightarrow>\n                                   if M_lookup V v \\<noteq> None then Q\n                                   else Q_update v (du + d) Q\n                                 | Some d' \\<Rightarrow>\n                                     Q_update v (min (du + d) d') Q)\n                            s) =\n                         (case x of\n                          (d, v) \\<Rightarrow>\n                            \\<lambda>Q.\n                               case Q v of\n                               None \\<Rightarrow>\n                                 if v \\<in> dom (M_lookup V) then Q\n                                 else Q(v \\<mapsto> du + d)\n                               | Some d' \\<Rightarrow> Q(v \\<mapsto>\n                                   min (du + d) d'))\n                          (Q_lookup s)", "by (auto split: option.split)"], ["", "definition (in Dijkstra_Impl_Defs) \"D_invar_impl Q V \\<equiv> \n  Q_invar Q \\<and> M_invar V \\<and> D_invar' (Q_lookup Q) (M_lookup V)\""], ["", "definition (in Dijkstra_Impl_Defs)\n  \"Q_initQ \\<equiv> Q_update s 0 Q_empty\""], ["", "lemma Q_init_Q[simp]:\n  shows \"Q_invar (Q_initQ)\" \"Q_lookup (Q_initQ) = initQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_invar Q_initQ &&& Q_lookup Q_initQ = initQ", "by (auto simp: Q_initQ_def initQ_def)"], ["", "definition (in Dijkstra_Impl_Defs)\n  \"M_initV \\<equiv> M_empty\""], ["", "lemma M_initS[simp]: \"M_invar M_initV\" \"M_lookup M_initV = initV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_invar M_initV &&& M_lookup M_initV = initV", "unfolding M_initV_def initV_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M_invar M_empty &&& M_lookup M_empty = Map.empty", "by auto"], ["", "term Q_getmin"], ["", "definition (in Dijkstra_Impl_Defs) \n  \"dijkstra_loop \\<equiv> while (\\<lambda>(Q,V). \\<not> Q_is_empty Q) (\\<lambda>(Q,V). \n    let\n      (u,du) = Q_getmin Q;\n      Q = Q_relax_outgoing u du V Q;\n      Q = Q_delete u Q;\n      V = M_update u du V\n    in\n      (Q,V)\n  ) (Q_initQ,M_initV)\""], ["", "definition (in Dijkstra_Impl_Defs) \"dijkstra \\<equiv> snd dijkstra_loop\""], ["", "lemma transfer_preconditions:\n  assumes \"coupling Q V D S\"\n  shows \"Q u = Some du \\<longleftrightarrow> D u = enat du \\<and> u\\<notin>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q u = Some du) = (D u = enat du \\<and> u \\<notin> S)", "using assms"], ["proof (prove)\nusing this:\n  coupling Q V D S\n\ngoal (1 subgoal):\n 1. (Q u = Some du) = (D u = enat du \\<and> u \\<notin> S)", "by (auto simp: coupling_def)"], ["", "lemma dijkstra_loop_invar_and_empty:\n  shows \"case dijkstra_loop of (Q,V) \\<Rightarrow> D_invar_impl Q V \\<and> Q_is_empty Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case dijkstra_loop of\n    (Q, V) \\<Rightarrow> D_invar_impl Q V \\<and> Q_is_empty Q", "unfolding dijkstra_loop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case while (\\<lambda>(Q, V). \\<not> Q_is_empty Q)\n          (\\<lambda>(Q, V).\n              let (u, du) = Q_getmin Q; Q = Q_relax_outgoing u du V Q;\n                  Q = Q_delete u Q\n              in Let (M_update u du V) (Pair Q))\n          (Q_initQ, M_initV) of\n    (Q, V) \\<Rightarrow> D_invar_impl Q V \\<and> Q_is_empty Q", "apply (rule while_rule[where \n        P=\"case_prod D_invar_impl\" \n    and r=\"inv_image finite_psubset (unfinished_dnodes' o M_lookup o snd)\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. case (Q_initQ, M_initV) of (x, xa) \\<Rightarrow> D_invar_impl x xa\n 2. \\<And>s.\n       \\<lbrakk>case s of (x, xa) \\<Rightarrow> D_invar_impl x xa;\n        case s of (Q, V) \\<Rightarrow> \\<not> Q_is_empty Q\\<rbrakk>\n       \\<Longrightarrow> case case s of\n                              (Q, V) \\<Rightarrow>\n                                let (u, du) = Q_getmin Q;\n                                    Q = Q_relax_outgoing u du V Q;\n                                    Q = Q_delete u Q\n                                in Let (M_update u du V) (Pair Q) of\n                         (x, xa) \\<Rightarrow> D_invar_impl x xa\n 3. \\<And>s.\n       \\<lbrakk>case s of (x, xa) \\<Rightarrow> D_invar_impl x xa;\n        \\<not> (case s of (Q, V) \\<Rightarrow> \\<not> Q_is_empty Q)\\<rbrakk>\n       \\<Longrightarrow> case s of\n                         (Q, V) \\<Rightarrow>\n                           D_invar_impl Q V \\<and> Q_is_empty Q\n 4. wf (inv_image finite_psubset\n         (unfinished_dnodes' \\<circ> M_lookup \\<circ> snd))\n 5. \\<And>s.\n       \\<lbrakk>case s of (x, xa) \\<Rightarrow> D_invar_impl x xa;\n        case s of (Q, V) \\<Rightarrow> \\<not> Q_is_empty Q\\<rbrakk>\n       \\<Longrightarrow> (case s of\n                          (Q, V) \\<Rightarrow>\n                            let (u, du) = Q_getmin Q;\n                                Q = Q_relax_outgoing u du V Q;\n                                Q = Q_delete u Q\n                            in Let (M_update u du V) (Pair Q),\n                          s)\n                         \\<in> inv_image finite_psubset\n                                (unfinished_dnodes' \\<circ> M_lookup \\<circ>\n                                 snd)", "apply (all \\<open>(clarsimp split: prod.splits)?\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. D_invar_impl Q_initQ M_initV\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> D_invar_impl\n                          (Q_delete x1a (Q_relax_outgoing x1a x2a x2 x1))\n                          (M_update x1a x2a x2)\n 3. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> unfinished_dnodes' (M_lookup (M_update x1a x2a x2))\n                         \\<subset> unfinished_dnodes' (M_lookup x2) \\<and>\n                         finite (unfinished_dnodes' (M_lookup x2))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. D_invar_impl Q_initQ M_initV", "apply (simp add: D_invar_impl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. D_invar' initQ initV", "apply (simp add: D_invar'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D S. coupling initQ initV D S \\<and> D_invar D S", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. coupling initQ initV ?D1 ?S2\n 2. D_invar ?D1 ?S2", "apply (rule coupling_init)"], ["proof (prove)\ngoal (1 subgoal):\n 1. D_invar initD initS", "using initD_def initS_def invar_init"], ["proof (prove)\nusing this:\n  initD \\<equiv> (\\<lambda>_. \\<infinity>)(s := 0::?'a)\n  initS \\<equiv> {}\n  D_invar initD initS\n\ngoal (1 subgoal):\n 1. D_invar initD initS", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> D_invar_impl\n                          (Q_delete x1a (Q_relax_outgoing x1a x2a x2 x1))\n                          (M_update x1a x2a x2)\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> unfinished_dnodes' (M_lookup (M_update x1a x2a x2))\n                         \\<subset> unfinished_dnodes' (M_lookup x2) \\<and>\n                         finite (unfinished_dnodes' (M_lookup x2))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> D_invar_impl\n                          (Q_delete x1a (Q_relax_outgoing x1a x2a x2 x1))\n                          (M_update x1a x2a x2)\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> unfinished_dnodes' (M_lookup (M_update x1a x2a x2))\n                         \\<subset> unfinished_dnodes' (M_lookup x2) \\<and>\n                         finite (unfinished_dnodes' (M_lookup x2))", "fix Q V u du"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> D_invar_impl\n                          (Q_delete x1a (Q_relax_outgoing x1a x2a x2 x1))\n                          (M_update x1a x2a x2)\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> unfinished_dnodes' (M_lookup (M_update x1a x2a x2))\n                         \\<subset> unfinished_dnodes' (M_lookup x2) \\<and>\n                         finite (unfinished_dnodes' (M_lookup x2))", "assume \"\\<not> Q_is_empty Q\" \"D_invar_impl Q V\" \"Q_getmin Q = (u, du)\""], ["proof (state)\nthis:\n  \\<not> Q_is_empty Q\n  D_invar_impl Q V\n  Q_getmin Q = (u, du)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> D_invar_impl\n                          (Q_delete x1a (Q_relax_outgoing x1a x2a x2 x1))\n                          (M_update x1a x2a x2)\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> unfinished_dnodes' (M_lookup (M_update x1a x2a x2))\n                         \\<subset> unfinished_dnodes' (M_lookup x2) \\<and>\n                         finite (unfinished_dnodes' (M_lookup x2))", "hence \"Q_lookup Q \\<noteq> Map.empty\" \"D_invar' (Q_lookup Q) (M_lookup V)\"\n    and [simp]: \"Q_invar Q\" \"M_invar V\"\n    and \"Q_lookup Q u = Some du\" \"\\<forall>k' p'. Q_lookup Q k' = Some p' \\<longrightarrow> du \\<le> p'\""], ["proof (prove)\nusing this:\n  \\<not> Q_is_empty Q\n  D_invar_impl Q V\n  Q_getmin Q = (u, du)\n\ngoal (1 subgoal):\n 1. (Q_lookup Q \\<noteq> Map.empty &&&\n     D_invar' (Q_lookup Q) (M_lookup V)) &&&\n    (Q_invar Q &&& M_invar V) &&&\n    Q_lookup Q u = Some du &&&\n    \\<forall>k' p'. Q_lookup Q k' = Some p' \\<longrightarrow> du \\<le> p'", "by (auto simp: D_invar_impl_def elim: Q.map_getminE)"], ["proof (state)\nthis:\n  Q_lookup Q \\<noteq> Map.empty\n  D_invar' (Q_lookup Q) (M_lookup V)\n  Q_invar Q\n  M_invar V\n  Q_lookup Q u = Some du\n  \\<forall>k' p'. Q_lookup Q k' = Some p' \\<longrightarrow> du \\<le> p'\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> D_invar_impl\n                          (Q_delete x1a (Q_relax_outgoing x1a x2a x2 x1))\n                          (M_update x1a x2a x2)\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> unfinished_dnodes' (M_lookup (M_update x1a x2a x2))\n                         \\<subset> unfinished_dnodes' (M_lookup x2) \\<and>\n                         finite (unfinished_dnodes' (M_lookup x2))", "then"], ["proof (chain)\npicking this:\n  Q_lookup Q \\<noteq> Map.empty\n  D_invar' (Q_lookup Q) (M_lookup V)\n  Q_invar Q\n  M_invar V\n  Q_lookup Q u = Some du\n  \\<forall>k' p'. Q_lookup Q k' = Some p' \\<longrightarrow> du \\<le> p'", "obtain D S where \n    \"D_invar D S\" \n    and COUPLING: \"coupling (Q_lookup Q) (M_lookup V) D S\"  \n    and ABS_PRE: \"D u = enat du\" \"u\\<notin>S\" \"\\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\""], ["proof (prove)\nusing this:\n  Q_lookup Q \\<noteq> Map.empty\n  D_invar' (Q_lookup Q) (M_lookup V)\n  Q_invar Q\n  M_invar V\n  Q_lookup Q u = Some du\n  \\<forall>k' p'. Q_lookup Q k' = Some p' \\<longrightarrow> du \\<le> p'\n\ngoal (1 subgoal):\n 1. (\\<And>D S.\n        \\<lbrakk>D_invar D S; coupling (Q_lookup Q) (M_lookup V) D S;\n         D u = enat du; u \\<notin> S;\n         \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto \n          simp: D_invar'_def transfer_preconditions less_eq_enat_def \n          split: enat.splits)"], ["proof (state)\nthis:\n  D_invar D S\n  coupling (Q_lookup Q) (M_lookup V) D S\n  D u = enat du\n  u \\<notin> S\n  \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> D_invar_impl\n                          (Q_delete x1a (Q_relax_outgoing x1a x2a x2 x1))\n                          (M_update x1a x2a x2)\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> unfinished_dnodes' (M_lookup (M_update x1a x2a x2))\n                         \\<subset> unfinished_dnodes' (M_lookup x2) \\<and>\n                         finite (unfinished_dnodes' (M_lookup x2))", "then"], ["proof (chain)\npicking this:\n  D_invar D S\n  coupling (Q_lookup Q) (M_lookup V) D S\n  D u = enat du\n  u \\<notin> S\n  \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v", "interpret Dijkstra_Invar \"G_\\<alpha> g\" s D S"], ["proof (prove)\nusing this:\n  D_invar D S\n  coupling (Q_lookup Q) (M_lookup V) D S\n  D u = enat du\n  u \\<notin> S\n  \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\n\ngoal (1 subgoal):\n 1. D_invar D S", "by simp"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> D_invar_impl\n                          (Q_delete x1a (Q_relax_outgoing x1a x2a x2 x1))\n                          (M_update x1a x2a x2)\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> unfinished_dnodes' (M_lookup (M_update x1a x2a x2))\n                         \\<subset> unfinished_dnodes' (M_lookup x2) \\<and>\n                         finite (unfinished_dnodes' (M_lookup x2))", "have COUPLING': \"coupling \n    ((relax_outgoing' u du (M_lookup V) (Q_lookup Q))(u := None)) \n    (M_lookup V(u \\<mapsto> du)) \n    (relax_outgoing u D) \n    (Set.insert u S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coupling ((relax_outgoing' u du (M_lookup V) (Q_lookup Q))(u := None))\n     (M_lookup V(u \\<mapsto> du)) (relax_outgoing u D) (Set.insert u S)", "using coupling_step[OF COUPLING \\<open>u\\<notin>S\\<close> \\<open>D u = enat du\\<close>]"], ["proof (prove)\nusing this:\n  coupling ((relax_outgoing' u du (M_lookup V) (Q_lookup Q))(u := None))\n   (M_lookup V(u \\<mapsto> du)) (relax_outgoing u D) (Set.insert u S)\n\ngoal (1 subgoal):\n 1. coupling ((relax_outgoing' u du (M_lookup V) (Q_lookup Q))(u := None))\n     (M_lookup V(u \\<mapsto> du)) (relax_outgoing u D) (Set.insert u S)", "by auto"], ["proof (state)\nthis:\n  coupling ((relax_outgoing' u du (M_lookup V) (Q_lookup Q))(u := None))\n   (M_lookup V(u \\<mapsto> du)) (relax_outgoing u D) (Set.insert u S)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> D_invar_impl\n                          (Q_delete x1a (Q_relax_outgoing x1a x2a x2 x1))\n                          (M_update x1a x2a x2)\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> unfinished_dnodes' (M_lookup (M_update x1a x2a x2))\n                         \\<subset> unfinished_dnodes' (M_lookup x2) \\<and>\n                         finite (unfinished_dnodes' (M_lookup x2))", "show \"D_invar_impl (Q_delete u (Q_relax_outgoing u du V Q)) (M_update u du V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D_invar_impl (Q_delete u (Q_relax_outgoing u du V Q)) (M_update u du V)", "using maintain_D_invar[OF \\<open>u\\<notin>S\\<close>] ABS_PRE"], ["proof (prove)\nusing this:\n  \\<lbrakk>D u < \\<infinity>;\n   \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\\<rbrakk>\n  \\<Longrightarrow> D_invar (relax_outgoing u D) (Set.insert u S)\n  D u = enat du\n  u \\<notin> S\n  \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\n\ngoal (1 subgoal):\n 1. D_invar_impl (Q_delete u (Q_relax_outgoing u du V Q)) (M_update u du V)", "using COUPLING'"], ["proof (prove)\nusing this:\n  \\<lbrakk>D u < \\<infinity>;\n   \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\\<rbrakk>\n  \\<Longrightarrow> D_invar (relax_outgoing u D) (Set.insert u S)\n  D u = enat du\n  u \\<notin> S\n  \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\n  coupling ((relax_outgoing' u du (M_lookup V) (Q_lookup Q))(u := None))\n   (M_lookup V(u \\<mapsto> du)) (relax_outgoing u D) (Set.insert u S)\n\ngoal (1 subgoal):\n 1. D_invar_impl (Q_delete u (Q_relax_outgoing u du V Q)) (M_update u du V)", "by (auto simp: D_invar_impl_def D_invar'_def)"], ["proof (state)\nthis:\n  D_invar_impl (Q_delete u (Q_relax_outgoing u du V Q)) (M_update u du V)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> Q_is_empty x1; D_invar_impl x1 x2;\n        Q_getmin x1 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> unfinished_dnodes' (M_lookup (M_update x1a x2a x2))\n                         \\<subset> unfinished_dnodes' (M_lookup x2) \\<and>\n                         finite (unfinished_dnodes' (M_lookup x2))", "show \"unfinished_dnodes' (M_lookup (M_update u du V)) \n        \\<subset> unfinished_dnodes' (M_lookup V) \n      \\<and> finite (unfinished_dnodes' (M_lookup V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfinished_dnodes' (M_lookup (M_update u du V))\n    \\<subset> unfinished_dnodes' (M_lookup V) \\<and>\n    finite (unfinished_dnodes' (M_lookup V))", "using coupling_unfinished[OF COUPLING] coupling_unfinished[OF COUPLING']"], ["proof (prove)\nusing this:\n  unfinished_dnodes' (M_lookup V) = unfinished_dnodes S\n  unfinished_dnodes' (M_lookup V(u \\<mapsto> du)) =\n  unfinished_dnodes (Set.insert u S)\n\ngoal (1 subgoal):\n 1. unfinished_dnodes' (M_lookup (M_update u du V))\n    \\<subset> unfinished_dnodes' (M_lookup V) \\<and>\n    finite (unfinished_dnodes' (M_lookup V))", "using unfinished_nodes_decr[OF \\<open>u\\<notin>S\\<close>] ABS_PRE"], ["proof (prove)\nusing this:\n  unfinished_dnodes' (M_lookup V) = unfinished_dnodes S\n  unfinished_dnodes' (M_lookup V(u \\<mapsto> du)) =\n  unfinished_dnodes (Set.insert u S)\n  D u < \\<infinity> \\<Longrightarrow>\n  unfinished_dnodes (Set.insert u S) \\<subset> unfinished_dnodes S\n  D u = enat du\n  u \\<notin> S\n  \\<forall>v. v \\<notin> S \\<longrightarrow> D u \\<le> D v\n\ngoal (1 subgoal):\n 1. unfinished_dnodes' (M_lookup (M_update u du V))\n    \\<subset> unfinished_dnodes' (M_lookup V) \\<and>\n    finite (unfinished_dnodes' (M_lookup V))", "by simp"], ["proof (state)\nthis:\n  unfinished_dnodes' (M_lookup (M_update u du V))\n  \\<subset> unfinished_dnodes' (M_lookup V) \\<and>\n  finite (unfinished_dnodes' (M_lookup V))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dijkstra_correct: \n  \"M_invar dijkstra\" \n  \"M_lookup dijkstra u = Some d \\<longleftrightarrow> \\<delta> s u = enat d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_invar dijkstra &&&\n    (M_lookup dijkstra u = Some d) = (\\<delta> s u = enat d)", "using dijkstra_loop_invar_and_empty"], ["proof (prove)\nusing this:\n  case dijkstra_loop of\n  (Q, V) \\<Rightarrow> D_invar_impl Q V \\<and> Q_is_empty Q\n\ngoal (1 subgoal):\n 1. M_invar dijkstra &&&\n    (M_lookup dijkstra u = Some d) = (\\<delta> s u = enat d)", "unfolding dijkstra_def"], ["proof (prove)\nusing this:\n  case dijkstra_loop of\n  (Q, V) \\<Rightarrow> D_invar_impl Q V \\<and> Q_is_empty Q\n\ngoal (1 subgoal):\n 1. M_invar (snd dijkstra_loop) &&&\n    (M_lookup (snd dijkstra_loop) u = Some d) = (\\<delta> s u = enat d)", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. case dijkstra_loop of\n    (Q, V) \\<Rightarrow>\n      D_invar_impl Q V \\<and> Q_is_empty Q \\<Longrightarrow>\n    M_invar (snd dijkstra_loop)\n 2. case dijkstra_loop of\n    (Q, V) \\<Rightarrow>\n      D_invar_impl Q V \\<and> Q_is_empty Q \\<Longrightarrow>\n    (M_lookup (snd dijkstra_loop) u = Some d) = (\\<delta> s u = enat d)", "apply (all \\<open>clarsimp simp: D_invar_impl_def\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>dijkstra_loop = (x, y); Q_invar x; M_invar y;\n        D_invar' Map.empty (M_lookup y); Q_lookup x = Map.empty\\<rbrakk>\n       \\<Longrightarrow> (M_lookup y u = Some d) = (\\<delta> s u = enat d)", "apply (clarsimp simp: D_invar'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y D S.\n       \\<lbrakk>dijkstra_loop = (x, y); Q_invar x; M_invar y;\n        Q_lookup x = Map.empty; coupling Map.empty (M_lookup y) D S;\n        D_invar D S\\<rbrakk>\n       \\<Longrightarrow> (M_lookup y u = Some d) = (\\<delta> s u = enat d)", "subgoal for Q V D S"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dijkstra_loop = (Q, V); Q_invar Q; M_invar V;\n     Q_lookup Q = Map.empty; coupling Map.empty (M_lookup V) D S;\n     D_invar D S\\<rbrakk>\n    \\<Longrightarrow> (M_lookup V u = Some d) = (\\<delta> s u = enat d)", "using Dijkstra_Invar.invar_finish_imp_correct[of \"G_\\<alpha> g\" s D S u]"], ["proof (prove)\nusing this:\n  \\<lbrakk>D_invar D S;\n   \\<forall>u. u \\<notin> S \\<longrightarrow> D u = \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> D u = \\<delta> s u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dijkstra_loop = (Q, V); Q_invar Q; M_invar V;\n     Q_lookup Q = Map.empty; coupling Map.empty (M_lookup V) D S;\n     D_invar D S\\<rbrakk>\n    \\<Longrightarrow> (M_lookup V u = Some d) = (\\<delta> s u = enat d)", "apply (clarsimp simp: coupling_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dijkstra_loop = (Q, V); Q_invar Q; M_invar V;\n     Q_lookup Q = Map.empty;\n     D_invar (Dijkstra_Abstract.enat_of_option \\<circ> M_lookup V)\n      (dom (M_lookup V));\n     \\<forall>u.\n        u \\<notin> dom (M_lookup V) \\<longrightarrow>\n        M_lookup V u = None \\<Longrightarrow>\n     Dijkstra_Abstract.enat_of_option (M_lookup V u) = \\<delta> s u;\n     D = Dijkstra_Abstract.enat_of_option \\<circ> M_lookup V;\n     S = dom (M_lookup V)\\<rbrakk>\n    \\<Longrightarrow> (M_lookup V u = Some d) = (\\<delta> s u = enat d)", "by (auto simp: domIff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Instantiation of ADTs and Code Generation\\<close>"], ["", "global_interpretation \n  G: wgraph_by_map RBT_Set.empty RBT_Map.update \n                   RBT_Map.delete Lookup2.lookup RBT_Map.M.invar\n  defines G_empty = G.empty_graph\n      and G_add_edge = G.add_edge\n      and G_succ = G.succ"], ["proof (prove)\ngoal (1 subgoal):\n 1. wgraph_by_map RBT_Set.empty RBT_Map.update RBT_Map.delete lookup M.invar", "by unfold_locales"], ["", "global_interpretation Dijkstra_Impl_Adts\n  G.\\<alpha> G.invar G.succ G.empty_graph G.add_edge\n  \n  RBT_Set.empty RBT_Map.update RBT_Map.delete Lookup2.lookup RBT_Map.M.invar\n  \n  PST_RBT.empty PST_RBT.update PST_RBT.delete PST_RBT.PM.invar \n  Lookup2.lookup PST_RBT.rbt_is_empty pst_getmin"], ["proof (prove)\ngoal (1 subgoal):\n 1. Dijkstra_Impl_Adts G.\\<alpha> G.invar G_succ G_empty G_add_edge\n     RBT_Set.empty RBT_Map.update RBT_Map.delete lookup M.invar\n     PST_RBT.empty PST_RBT.update PST_RBT.delete PM.invar lookup\n     rbt_is_empty pst_getmin", ".."], ["", "global_interpretation D: Dijkstra_Impl_Defs  \n  G.invar G.succ G.empty_graph G.add_edge\n  \n  RBT_Set.empty RBT_Map.update RBT_Map.delete Lookup2.lookup RBT_Map.M.invar\n  \n  PST_RBT.empty PST_RBT.update PST_RBT.delete PST_RBT.PM.invar \n  Lookup2.lookup PST_RBT.rbt_is_empty pst_getmin\n  \n  G.\\<alpha> g s for g and s::\"'v::linorder\"\n  defines dijkstra = D.dijkstra\n      and dijkstra_loop = D.dijkstra_loop\n      and Q_relax_outgoing = D.Q_relax_outgoing\n      and M_initV = D.M_initV\n      and Q_initQ = D.Q_initQ"], ["proof (prove)\ngoal (1 subgoal):\n 1. Dijkstra_Impl_Defs G.invar G_succ G_empty G_add_edge RBT_Set.empty\n     RBT_Map.update RBT_Map.delete lookup M.invar PST_RBT.empty\n     PST_RBT.update PST_RBT.delete PM.invar lookup rbt_is_empty pst_getmin\n     G.\\<alpha>", ".."], ["", "(* TODO: Why is this fix necessary? *)"], ["", "lemmas [code] =    \n  D.dijkstra_def D.dijkstra_loop_def"], ["", "context\n  fixes g\n  assumes [simp]: \"G.invar g\"  \nbegin"], ["", "interpretation AUX: Dijkstra_Impl\n  G.invar G.succ G.empty_graph G.add_edge\n  \n  RBT_Set.empty RBT_Map.update RBT_Map.delete Lookup2.lookup RBT_Map.M.invar\n  \n  PST_RBT.empty PST_RBT.update PST_RBT.delete PST_RBT.PM.invar \n  Lookup2.lookup PST_RBT.rbt_is_empty pst_getmin\n  \n  g s G.\\<alpha> for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. Dijkstra_Impl G.invar G_succ G_empty G_add_edge RBT_Set.empty\n     RBT_Map.update RBT_Map.delete lookup M.invar PST_RBT.empty\n     PST_RBT.update PST_RBT.delete PM.invar lookup rbt_is_empty pst_getmin g\n     G.\\<alpha>", "by unfold_locales simp_all"], ["", "lemmas dijkstra_correct = AUX.dijkstra_correct[folded dijkstra_def]"], ["", "end"], ["", "subsection \\<open>Combination with Graph Parser\\<close>"], ["", "text \\<open>We combine the algorithm with a parser from lists to graphs\\<close>"], ["", "global_interpretation \n  G: wgraph_from_list_algo G.\\<alpha> G.invar G.succ G.empty_graph G.add_edge\n  defines from_list = G.from_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. wgraph_from_list_algo G.\\<alpha> G.invar G_succ G_empty G_add_edge", ".."], ["", "definition \"dijkstra_list l s \\<equiv> \n  if valid_graph_rep l then Some (dijkstra (from_list l) s) else None\""], ["", "theorem dijkstra_list_correct:\n  \"case dijkstra_list l s of\n    None \\<Rightarrow> \\<not>valid_graph_rep l\n  | Some D \\<Rightarrow> \n        valid_graph_rep l \n      \\<and> M.invar D \n      \\<and> (\\<forall>u d. lookup D u = Some d \\<longleftrightarrow> WGraph.\\<delta> (wgraph_of_list l) s u = enat d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case dijkstra_list l s of None \\<Rightarrow> \\<not> valid_graph_rep l\n    | Some D \\<Rightarrow>\n        valid_graph_rep l \\<and>\n        M.invar D \\<and>\n        (\\<forall>u d.\n            (lookup D u = Some d) =\n            (WGraph.\\<delta> (wgraph_of_list l) s u = enat d))", "unfolding dijkstra_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case if valid_graph_rep l then Some (dijkstra (from_list l) s)\n         else None of\n    None \\<Rightarrow> \\<not> valid_graph_rep l\n    | Some D \\<Rightarrow>\n        valid_graph_rep l \\<and>\n        M.invar D \\<and>\n        (\\<forall>u d.\n            (lookup D u = Some d) =\n            (WGraph.\\<delta> (wgraph_of_list l) s u = enat d))", "by (auto simp: dijkstra_correct G.from_list_correct)"], ["", "export_code dijkstra_list checking SML OCaml? Scala Haskell?"], ["", "value \"dijkstra_list [(1::nat,2,7),(1,3,1),(3,2,2)] 1\""], ["", "value \"dijkstra_list [(1::nat,2,7),(1,3,1),(3,2,2)] 3\""], ["", "end"]]}