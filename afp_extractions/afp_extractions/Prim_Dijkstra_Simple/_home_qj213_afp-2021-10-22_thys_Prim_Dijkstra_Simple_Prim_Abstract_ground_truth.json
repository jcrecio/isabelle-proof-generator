{"file_name": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple/Prim_Abstract.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple", "problem_names": ["lemma is_subset_MST_empty[simp]: \"connected g \\<Longrightarrow> is_subset_MST w g {}\"", "lemma reachable_connected[simp, intro!]: \"connected rg\"", "lemma reachable_edges_subset: \"edges rg \\<subseteq> edges g\"", "lemma light_edge_is_safe:\n  fixes A :: \"('v\\<times>'v) set\" and C :: \"'v set\"\n  assumes subset_MST: \"is_subset_MST w rg A\"\n  assumes respects_cut: \"respects_cut A C\"\n  assumes light_edge: \"light_edge C u v\"\n  shows \"is_subset_MST w rg ({(v,u)} \\<union> A)\"", "lemma respects_cut': \"A \\<subseteq> S A \\<times> S A\"", "lemma subset_MST: \"is_subset_MST w rg A\"", "lemma A_connected: \"(u,v)\\<in>A \\<Longrightarrow> (v,r)\\<in>A\\<^sup>*\"", "lemma S_alt_def: \"S A = {r} \\<union> fst`A\"", "lemma finite_rem_nodes[simp,intro!]: \"finite (nodes rg - S A)\"", "lemma A_edges: \"A \\<subseteq> edges g\"", "lemma S_reachable: \"S A \\<subseteq> nodes rg\"", "lemma S_edge_reachable: \"\\<lbrakk>u\\<in>S A; (u,v)\\<in>edges g \\<rbrakk> \\<Longrightarrow> (u,v)\\<in>edges rg\"", "lemma edges_S_rg_edges: \"edges g \\<inter> S A\\<times>-S A = edges rg \\<inter> S A\\<times>-S A\"", "lemma T_measure1_less: \"T_measure1 A < card (nodes rg)\"", "lemma finite_A[simp, intro!]: \"finite A\"", "lemma finite_S[simp, intro!]: \"finite (S A)\"", "lemma S_A_consistent[simp, intro!]: \"nodes_edges_consistent (S A) (A\\<union>A\\<inverse>)\"", "lemma invar1_initial: \"prim_invar1 {}\"", "lemma maintain_invar1:\n  assumes invar: \"prim_invar1 A\"\n  assumes light_edge: \"light_edge (S A) u v\"\n  shows \"prim_invar1 ({(v,u)}\\<union>A) \n       \\<and> T_measure1 ({(v,u)}\\<union>A) < T_measure1 A\" (is \"?G1 \\<and> ?G2\")", "lemma invar1_finish:\n  assumes INV: \"prim_invar1 A\"\n  assumes FIN: \"edges g \\<inter> S A\\<times>-S A = {}\"\n  shows \"is_MST w rg (graph {r} A)\"", "lemma prim_invar2_ctd_alt_aux1: \n  assumes \"prim_invar1 (A Q \\<pi>)\"\n  assumes \"Q u \\<noteq> \\<infinity>\" \"u\\<noteq>r\"  \n  shows \"u\\<notin>S (A Q \\<pi>)\"", "lemma prim_invar2_ctd_alt: \"prim_invar2_ctd Q \\<pi> \\<longleftrightarrow> (\n  let A = A Q \\<pi>; S = S A; cE=edges rg \\<inter> (-S)\\<times>S in\n    prim_invar1 A\n  \\<and> \\<pi> r = None \\<and> Q r = \\<infinity>  \n  \\<and> (\\<forall>(u,v)\\<in>cE. Q u \\<noteq> \\<infinity>)\n  \\<and> (\\<forall>u v. \\<pi> u = Some v \\<longrightarrow> v\\<in>S \\<and> (u,v)\\<in>edges rg)\n  \\<and> (\\<forall>u d. Q u = enat d \n      \\<longrightarrow> (\\<exists>v. \\<pi> u = Some v \\<and> d=w {u,v} \\<and> (\\<forall>v'. (u,v')\\<in>cE \\<longrightarrow> d \\<le> w {u,v'})))\n)\"", "lemma Q'_init_eq: \n  \"Q' initQ init\\<pi> r = (\\<lambda>u. if (u,r)\\<in>edges rg then enat (w {u,r}) else \\<infinity>)\"", "lemma \\<pi>'_init_eq: \n  \"\\<pi>' initQ init\\<pi> r = (\\<lambda>u. if (u,r)\\<in>edges rg then Some r else None)\"", "lemma A_init_eq: \"A initQ init\\<pi> = {}\"", "lemma S_empty: \"S {} = {r}\"", "lemma maintain_invar2_first_step: \n  assumes INV: \"prim_invar2_init Q \\<pi>\"\n  assumes UNS: \"Q u = enat d\"\n  shows \"prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\" (is ?G1)\n    and \"T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\" (is ?G2)", "lemma maintain_invar2_first_step_presentation: \n  assumes INV: \"prim_invar2_init Q \\<pi>\"\n  assumes UNS: \"Q u = enat d\"\n  shows \"prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n       \\<and> T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\"", "lemma \n      invar1: \"Prim.prim_invar1 w g r A\" (is ?G1)\n  and root_contained: \"\\<pi> r = None \\<and> Q r = \\<infinity>\" (is ?G2)\n  and Q_defined: \"\\<forall>(u,v)\\<in>cE. Q u \\<noteq> \\<infinity>\" (is ?G3)\n  and \\<pi>_edges: \"\\<forall>u v. \\<pi> u = Some v \\<longrightarrow> v\\<in>S \\<and> (u,v)\\<in>edges rg\" (is ?G4)\n  and Q_min: \"\\<forall>u d. Q u = enat d \n      \\<longrightarrow> (\\<exists>v. \\<pi> u = Some v \\<and> d=w {u,v} \\<and> (\\<forall>v'. (u,v')\\<in>cE \\<longrightarrow> d \\<le> w {u,v'}))\" \n      (is ?G5)", "lemma (in Prim2) Prim_Invar2_ctd_Presentation_Loc_eq:\n  \"Prim_Invar2_ctd_Presentation_Loc w g r Q \\<pi> \\<longleftrightarrow> prim_invar2_ctd Q \\<pi>\"", "lemma upd_cond_alt: \"upd_cond Q \\<pi> u v' \\<longleftrightarrow> \n  (v',u) \\<in> edges g \\<and> v'\\<notin>S (A Q \\<pi>) \\<and> enat (w {v',u}) < Q v'\"", "lemma \\<pi>_root: \"\\<pi> r = None\"\n  and Q_root: \"Q r = \\<infinity>\" \n  and Q_defined: \"\\<lbrakk> (u,v)\\<in>edges rg; u\\<notin>S (A Q \\<pi>); v\\<in>S (A Q \\<pi>) \\<rbrakk> \\<Longrightarrow> Q u \\<noteq> \\<infinity>\"\n  and \\<pi>_defined: \"\\<lbrakk> Q u \\<noteq> \\<infinity> \\<rbrakk> \\<Longrightarrow> \\<pi> u \\<noteq> None\"\n  and frontier: \"\\<pi> u = Some v \\<Longrightarrow> v\\<in>S (A Q \\<pi>)\"\n  and edges: \"\\<pi> u = Some v \\<Longrightarrow> (u,v)\\<in>edges rg\"\n  and Q_\\<pi>_consistent: \"\\<lbrakk> Q u = enat d; \\<pi> u = Some v \\<rbrakk> \\<Longrightarrow> d = w {u,v}\" \n  and Q_min: \"Q u = enat d \n      \\<Longrightarrow> (\\<forall>v'\\<in>S (A Q \\<pi>). (u,v')\\<in>edges rg \\<longrightarrow> d \\<le> w {u,v'})\"", "lemma \\<pi>_def_on_S: \"\\<lbrakk>u\\<in>S (A Q \\<pi>); u\\<noteq>r\\<rbrakk> \\<Longrightarrow> \\<pi> u \\<noteq> None\"", "lemma \\<pi>_def_on_edges_to_S: \"\\<lbrakk>v\\<in>S (A Q \\<pi>); u\\<noteq>r; (u,v)\\<in>edges rg\\<rbrakk> \\<Longrightarrow> \\<pi> u \\<noteq> None\"", "lemma Q_min_is_light:  \n  assumes UNS: \"Q u = enat d\"\n  assumes MIN: \"\\<forall>v. enat d \\<le> Q v\"\n  obtains v where \"\\<pi> u = Some v\" \"light_edge (S (A Q \\<pi>)) v u\"", "lemma maintain_invar_ctd: \n  assumes UNS: \"Q u = enat d\"\n  assumes MIN: \"\\<forall>v. enat d \\<le> Q v\"\n  shows \"prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\" (is ?G1)\n    and \"T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\" (is ?G2)", "lemma maintain_invar2_ctd: \n  assumes INV: \"prim_invar2_ctd Q \\<pi>\"\n  assumes UNS: \"Q u = enat d\"\n  assumes MIN: \"\\<forall>v. enat d \\<le> Q v\"\n  shows \"prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\" (is ?G1)\n    and \"T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\" (is ?G2)", "lemma Q_min_is_light_presentation:  \n  assumes INV: \"prim_invar2_ctd Q \\<pi>\"\n  assumes UNS: \"Q u = enat d\"\n  assumes MIN: \"\\<forall>v. enat d \\<le> Q v\"\n  obtains v where \"\\<pi> u = Some v\" \"light_edge (S (A Q \\<pi>)) v u\"", "lemma maintain_invar2_ctd_presentation: \n  assumes INV: \"prim_invar2_ctd Q \\<pi>\"\n  assumes UNS: \"Q u = enat d\"\n  assumes MIN: \"\\<forall>v. enat d \\<le> Q v\"\n  shows \"prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n       \\<and> T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\"", "lemma not_invar2_ctd_init: \n  \"prim_invar2_init Q \\<pi> \\<Longrightarrow> \\<not>prim_invar2_ctd Q \\<pi>\"", "lemma invar2_init_init: \"prim_invar2_init initQ init\\<pi>\"", "lemma invar2_init: \"prim_invar2 initQ init\\<pi>\"", "lemma maintain_invar2: \n  assumes A: \"prim_invar2 Q \\<pi>\"  \n  assumes UNS: \"Q u = enat d\"\n  assumes MIN: \"\\<forall>v. enat d \\<le> Q v\"\n  shows \"prim_invar2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\" (is ?G1)\n    and \"T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\" (is ?G2)", "lemma invar2_ctd_finish:  \n  assumes INV: \"prim_invar2_ctd Q \\<pi>\"  \n  assumes FIN: \"Q = (\\<lambda>_. \\<infinity>)\"\n  shows \"is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})\"", "lemma invar2_finish:  \n  assumes INV: \"prim_invar2 Q \\<pi>\"  \n  assumes FIN: \"Q = (\\<lambda>_. \\<infinity>)\"\n  shows \"is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})\"", "lemma foreach_body_alt: \"foreach_body u = (\\<lambda>(v,d) (Q,\\<pi>). \n  if v\\<noteq>r \\<and> (\\<pi> v = None \\<or> Q v \\<noteq> \\<infinity>) \\<and> enat d < Q v then\n    (Q(v:=enat d), \\<pi>(v\\<mapsto>u))\n  else \n    (Q,\\<pi>)\n)\"", "lemma Qc: \n  \"Qigen Q \\<pi> u ((v, w {u, v}) # adjs) x \n  = (if x=v then Qinter Q \\<pi> u v else Qigen Q \\<pi> u adjs x)\" for x", "lemma \\<pi>c: \n  \"\\<pi>'gen Q \\<pi> u ((v, w {u, v}) # adjs) x \n  = (if x=v then \\<pi>' Q \\<pi> u v else \\<pi>'gen Q \\<pi> u adjs x)\" for x", "lemma foreach_refine_gen:\n  assumes \"set adjs \\<subseteq> {(v,d). (u,v)\\<in>edges g \\<and> w {u,v} = d}\"          \n  shows \"foreach u adjs (Q,\\<pi>) = (Qigen Q \\<pi> u adjs,\\<pi>'gen Q \\<pi> u adjs)\"", "lemma foreach_refine:\n  assumes \"set adjs = {(v,d). (u,v)\\<in>edges g \\<and> w {u,v} = d}\"\n  shows \"foreach u adjs (Q,\\<pi>) = (Qinter Q \\<pi> u,\\<pi>' Q \\<pi> u)\""], "translations": [["", "lemma is_subset_MST_empty[simp]: \"connected g \\<Longrightarrow> is_subset_MST w g {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected g \\<Longrightarrow> is_subset_MST w g {}", "using exists_MST"], ["proof (prove)\nusing this:\n  Undirected_Graph.connected ?g \\<Longrightarrow> \\<exists>t. is_MST ?w ?g t\n\ngoal (1 subgoal):\n 1. Undirected_Graph.connected g \\<Longrightarrow> is_subset_MST w g {}", "unfolding is_subset_MST_def"], ["proof (prove)\nusing this:\n  Undirected_Graph.connected ?g \\<Longrightarrow> \\<exists>t. is_MST ?w ?g t\n\ngoal (1 subgoal):\n 1. Undirected_Graph.connected g \\<Longrightarrow>\n    \\<exists>t. is_MST w g t \\<and> {} \\<subseteq> edges t", "by blast"], ["", "text \\<open>We fix a start node and a weighted graph\\<close>"], ["", "locale Prim =\n  fixes w :: \"'v set \\<Rightarrow> nat\" and g :: \"'v ugraph\" and r :: 'v\nbegin"], ["", "text \\<open>Reachable part of the graph\\<close>"], ["", "definition \"rg \\<equiv> component_of g r\""], ["", "lemma reachable_connected[simp, intro!]: \"connected rg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected rg", "unfolding rg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected (component_of g r)", "by auto"], ["", "lemma reachable_edges_subset: \"edges rg \\<subseteq> edges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges rg \\<subseteq> edges g", "unfolding rg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (component_of g r) \\<subseteq> edges g", "by (rule component_edges_subset)"], ["", "definition \"light_edge C u v \n  \\<equiv>   u\\<in>C \\<and> v\\<notin>C \\<and> (u,v)\\<in>edges rg \n    \\<and> (\\<forall>(u',v')\\<in>edges rg \\<inter> C\\<times>-C. w {u,v} \\<le> w {u',v'})\""], ["", "definition \"respects_cut A C \\<equiv> A \\<subseteq> C\\<times>C \\<union> (-C)\\<times>(-C)\""], ["", "lemma light_edge_is_safe:\n  fixes A :: \"('v\\<times>'v) set\" and C :: \"'v set\"\n  assumes subset_MST: \"is_subset_MST w rg A\"\n  assumes respects_cut: \"respects_cut A C\"\n  assumes light_edge: \"light_edge C u v\"\n  shows \"is_subset_MST w rg ({(v,u)} \\<union> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subset_MST w rg ({(v, u)} \\<union> A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_subset_MST w rg ({(v, u)} \\<union> A)", "have crossing_edge: \"u\\<in>C\" \"v\\<notin>C\" \"(u,v)\\<in>edges rg\"\n    and min_edge: \"\\<forall>(u',v')\\<in>edges rg \\<inter> C\\<times>-C. w {u,v} \\<le> w {u',v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<in> C &&& v \\<notin> C &&& (u, v) \\<in> edges rg) &&&\n    \\<forall>(u', v')\\<in>edges rg \\<inter> C \\<times> - C.\n       w {u, v} \\<le> w {u', v'}", "using light_edge"], ["proof (prove)\nusing this:\n  light_edge C u v\n\ngoal (1 subgoal):\n 1. (u \\<in> C &&& v \\<notin> C &&& (u, v) \\<in> edges rg) &&&\n    \\<forall>(u', v')\\<in>edges rg \\<inter> C \\<times> - C.\n       w {u, v} \\<le> w {u', v'}", "unfolding light_edge_def"], ["proof (prove)\nusing this:\n  u \\<in> C \\<and>\n  v \\<notin> C \\<and>\n  (u, v) \\<in> edges rg \\<and>\n  (\\<forall>(u', v')\\<in>edges rg \\<inter> C \\<times> - C.\n      w {u, v} \\<le> w {u', v'})\n\ngoal (1 subgoal):\n 1. (u \\<in> C &&& v \\<notin> C &&& (u, v) \\<in> edges rg) &&&\n    \\<forall>(u', v')\\<in>edges rg \\<inter> C \\<times> - C.\n       w {u, v} \\<le> w {u', v'}", "by auto"], ["proof (state)\nthis:\n  u \\<in> C\n  v \\<notin> C\n  (u, v) \\<in> edges rg\n  \\<forall>(u', v')\\<in>edges rg \\<inter> C \\<times> - C.\n     w {u, v} \\<le> w {u', v'}\n\ngoal (1 subgoal):\n 1. is_subset_MST w rg ({(v, u)} \\<union> A)", "from subset_MST"], ["proof (chain)\npicking this:\n  is_subset_MST w rg A", "obtain T where T: \"is_MST w rg T\" \"A \\<subseteq> edges T\""], ["proof (prove)\nusing this:\n  is_subset_MST w rg A\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>is_MST w rg T; A \\<subseteq> edges T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_subset_MST_def"], ["proof (prove)\nusing this:\n  \\<exists>t. is_MST w rg t \\<and> A \\<subseteq> edges t\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>is_MST w rg T; A \\<subseteq> edges T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_MST w rg T\n  A \\<subseteq> edges T\n\ngoal (1 subgoal):\n 1. is_subset_MST w rg ({(v, u)} \\<union> A)", "hence \"tree T\" \"edges T \\<subseteq> edges rg\" \"nodes T = nodes rg\""], ["proof (prove)\nusing this:\n  is_MST w rg T\n  A \\<subseteq> edges T\n\ngoal (1 subgoal):\n 1. tree T &&& edges T \\<subseteq> edges rg &&& nodes T = nodes rg", "by (simp_all add: is_MST_def is_spanning_tree_def)"], ["proof (state)\nthis:\n  tree T\n  edges T \\<subseteq> edges rg\n  nodes T = nodes rg\n\ngoal (1 subgoal):\n 1. is_subset_MST w rg ({(v, u)} \\<union> A)", "hence \"connected T\""], ["proof (prove)\nusing this:\n  tree T\n  edges T \\<subseteq> edges rg\n  nodes T = nodes rg\n\ngoal (1 subgoal):\n 1. Undirected_Graph.connected T", "by(simp_all add: tree_def)"], ["proof (state)\nthis:\n  Undirected_Graph.connected T\n\ngoal (1 subgoal):\n 1. is_subset_MST w rg ({(v, u)} \\<union> A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subset_MST w rg ({(v, u)} \\<union> A)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> is_subset_MST w rg ({(v, u)} \\<union> A)\n 2. \\<not> ?P \\<Longrightarrow> is_subset_MST w rg ({(v, u)} \\<union> A)", "assume \"(u,v) \\<in> edges T\""], ["proof (state)\nthis:\n  (u, v) \\<in> edges T\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> is_subset_MST w rg ({(v, u)} \\<union> A)\n 2. \\<not> ?P \\<Longrightarrow> is_subset_MST w rg ({(v, u)} \\<union> A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (u, v) \\<in> edges T\n\ngoal (1 subgoal):\n 1. is_subset_MST w rg ({(v, u)} \\<union> A)", "unfolding is_subset_MST_def"], ["proof (prove)\nusing this:\n  (u, v) \\<in> edges T\n\ngoal (1 subgoal):\n 1. \\<exists>t. is_MST w rg t \\<and> {(v, u)} \\<union> A \\<subseteq> edges t", "using T"], ["proof (prove)\nusing this:\n  (u, v) \\<in> edges T\n  is_MST w rg T\n  A \\<subseteq> edges T\n\ngoal (1 subgoal):\n 1. \\<exists>t. is_MST w rg t \\<and> {(v, u)} \\<union> A \\<subseteq> edges t", "by (auto simp: edges_sym')"], ["proof (state)\nthis:\n  is_subset_MST w rg ({(v, u)} \\<union> A)\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "assume \"(u,v) \\<notin> edges T\""], ["proof (state)\nthis:\n  (u, v) \\<notin> edges T\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "hence \"(v,u)\\<notin>edges T\""], ["proof (prove)\nusing this:\n  (u, v) \\<notin> edges T\n\ngoal (1 subgoal):\n 1. (v, u) \\<notin> edges T", "by (auto simp: edges_sym')"], ["proof (state)\nthis:\n  (v, u) \\<notin> edges T\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "from \\<open>(u,v)\\<in>edges rg\\<close>"], ["proof (chain)\npicking this:\n  (u, v) \\<in> edges rg", "obtain p where p: \"path T u p v\" \"simple p\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> edges rg\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path T u p v; simple p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis connectedD \\<open>connected T\\<close> \\<open>nodes T = nodes rg\\<close> nodesI \n          rtrancl_edges_iff_path simplify_pathE)"], ["proof (state)\nthis:\n  path T u p v\n  simple p\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "have [simp]: \"u\\<noteq>v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> v", "using crossing_edge"], ["proof (prove)\nusing this:\n  u \\<in> C\n  v \\<notin> C\n  (u, v) \\<in> edges rg\n\ngoal (1 subgoal):\n 1. u \\<noteq> v", "by blast"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "from find_crossing_edge_on_path[OF p(1), where P=\"\\<lambda>x. x\\<notin>C\"] \n         crossing_edge(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> u \\<notin> C; v \\<notin> C;\n   \\<And>u' v'.\n      \\<lbrakk>(u', v') \\<in> set p; \\<not> u' \\<notin> C;\n       v' \\<notin> C\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  u \\<in> C\n  v \\<notin> C", "obtain x y p1 p2 where xy: \"(x,y) \\<in> set p\" \"x \\<in> C\" \"y \\<notin> C\"\n      and ux: \"path (restrict_edges T (-{(x,y),(y,x)})) u p1 x\" \n      and yv: \"path (restrict_edges T (-{(x,y),(y,x)})) y p2 v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> u \\<notin> C; v \\<notin> C;\n   \\<And>u' v'.\n      \\<lbrakk>(u', v') \\<in> set p; \\<not> u' \\<notin> C;\n       v' \\<notin> C\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  u \\<in> C\n  v \\<notin> C\n\ngoal (1 subgoal):\n 1. (\\<And>x y p1 p2.\n        \\<lbrakk>(x, y) \\<in> set p; x \\<in> C; y \\<notin> C;\n         path (restrict_edges T (- {(x, y), (y, x)})) u p1 x;\n         path (restrict_edges T (- {(x, y), (y, x)})) y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using path_change[OF crossing_edge(1,2) p]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> u \\<notin> C; v \\<notin> C;\n   \\<And>u' v'.\n      \\<lbrakk>(u', v') \\<in> set p; \\<not> u' \\<notin> C;\n       v' \\<notin> C\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  u \\<in> C\n  v \\<notin> C\n  (\\<And>x y p1 p2.\n      \\<lbrakk>(x, y) \\<in> set p; x \\<in> C; y \\<notin> C;\n       path (restrict_edges T (- {(x, y), (y, x)})) u p1 x;\n       path (restrict_edges T (- {(x, y), (y, x)})) y p2 v\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x y p1 p2.\n        \\<lbrakk>(x, y) \\<in> set p; x \\<in> C; y \\<notin> C;\n         path (restrict_edges T (- {(x, y), (y, x)})) u p1 x;\n         path (restrict_edges T (- {(x, y), (y, x)})) y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x, y) \\<in> set p\n  x \\<in> C\n  y \\<notin> C\n  path (restrict_edges T (- {(x, y), (y, x)})) u p1 x\n  path (restrict_edges T (- {(x, y), (y, x)})) y p2 v\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "have \"(x,y) \\<in> edges T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> edges T", "by (meson contra_subsetD p(1) path_edges xy(1))"], ["proof (state)\nthis:\n  (x, y) \\<in> edges T\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "let ?E' = \"edges T - {(x,y),(y,x)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "from split_tree[OF \\<open>tree T\\<close> \\<open>(x,y)\\<in>edges T\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>T1 T2.\n      \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n       nodes T = nodes T1 \\<union> nodes T2;\n       edges T1 \\<union> edges T2 = edges T - {(x, y), (y, x)};\n       nodes T1 = {u. (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n       nodes T2 = {u. (y, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n       x \\<in> nodes T1; y \\<in> nodes T2\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain T1 T2 where T12: \n        \"tree T1\" \"tree T2\" \n        and \"nodes T1 \\<inter> nodes T2 = {}\" \n        and \"nodes T = nodes T1 \\<union> nodes T2\"\n        and \"edges T1 \\<union> edges T2 = ?E'\"\n        and \"nodes T1 = { u . (x,u)\\<in>?E'\\<^sup>*}\"\n        and \"nodes T2 = { u . (y,u)\\<in>?E'\\<^sup>*}\"\n        and \"x\\<in>nodes T1\" \"y\\<in>nodes T2\""], ["proof (prove)\nusing this:\n  (\\<And>T1 T2.\n      \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n       nodes T = nodes T1 \\<union> nodes T2;\n       edges T1 \\<union> edges T2 = edges T - {(x, y), (y, x)};\n       nodes T1 = {u. (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n       nodes T2 = {u. (y, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n       x \\<in> nodes T1; y \\<in> nodes T2\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>tree T1; tree T2; nodes T1 \\<inter> nodes T2 = {};\n         nodes T = nodes T1 \\<union> nodes T2;\n         edges T1 \\<union> edges T2 = edges T - {(x, y), (y, x)};\n         nodes T1 = {u. (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n         nodes T2 = {u. (y, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*};\n         x \\<in> nodes T1; y \\<in> nodes T2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  tree T1\n  tree T2\n  nodes T1 \\<inter> nodes T2 = {}\n  nodes T = nodes T1 \\<union> nodes T2\n  edges T1 \\<union> edges T2 = edges T - {(x, y), (y, x)}\n  nodes T1 = {u. (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*}\n  nodes T2 = {u. (y, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*}\n  x \\<in> nodes T1\n  y \\<in> nodes T2\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "let ?T' = \"ins_edge (u,v) (graph_join T1 T2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "have \"is_spanning_tree rg ?T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))", "have E'_sym: \"sym (?E'\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym ((edges T - {(x, y), (y, x)})\\<^sup>*)", "by (meson edgesT_diff_sng_inv_eq sym_conv_converse_eq sym_rtrancl)"], ["proof (state)\nthis:\n  sym ((edges T - {(x, y), (y, x)})\\<^sup>*)\n\ngoal (1 subgoal):\n 1. is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))", "have \"u\\<in>nodes T1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> nodes T1", "unfolding \\<open>nodes T1 = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> {u. (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*}", "using path_rtrancl_edgesD[OF ux]"], ["proof (prove)\nusing this:\n  (u, x) \\<in> (edges (restrict_edges T (- {(x, y), (y, x)})))\\<^sup>*\n\ngoal (1 subgoal):\n 1. u \\<in> {u. (x, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*}", "by (auto dest: symD[OF E'_sym])"], ["proof (state)\nthis:\n  u \\<in> nodes T1\n\ngoal (1 subgoal):\n 1. is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))", "have \"v\\<in>nodes T2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> nodes T2", "unfolding \\<open>nodes T2 = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> {u. (y, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*}", "using path_rtrancl_edgesD[OF yv]"], ["proof (prove)\nusing this:\n  (y, v) \\<in> (edges (restrict_edges T (- {(x, y), (y, x)})))\\<^sup>*\n\ngoal (1 subgoal):\n 1. v \\<in> {u. (y, u) \\<in> (edges T - {(x, y), (y, x)})\\<^sup>*}", "by auto"], ["proof (state)\nthis:\n  v \\<in> nodes T2\n\ngoal (1 subgoal):\n 1. is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))", "have \"tree ?T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) (graph_join T1 T2))", "by (rule join_trees) fact+"], ["proof (state)\nthis:\n  tree (ins_edge (u, v) (graph_join T1 T2))\n\ngoal (1 subgoal):\n 1. is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))", "show \"is_spanning_tree rg ?T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))", "unfolding is_spanning_tree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) (graph_join T1 T2)) \\<and>\n    nodes (ins_edge (u, v) (graph_join T1 T2)) = nodes rg \\<and>\n    edges (ins_edge (u, v) (graph_join T1 T2)) \\<subseteq> edges rg", "using \\<open>nodes T = nodes rg\\<close> \\<open>nodes T = nodes T1 \\<union> nodes T2\\<close>[symmetric]"], ["proof (prove)\nusing this:\n  nodes T = nodes rg\n  nodes T1 \\<union> nodes T2 = nodes T\n\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) (graph_join T1 T2)) \\<and>\n    nodes (ins_edge (u, v) (graph_join T1 T2)) = nodes rg \\<and>\n    edges (ins_edge (u, v) (graph_join T1 T2)) \\<subseteq> edges rg", "using \\<open>tree ?T'\\<close> \\<open>u\\<noteq>v\\<close>"], ["proof (prove)\nusing this:\n  nodes T = nodes rg\n  nodes T1 \\<union> nodes T2 = nodes T\n  tree (ins_edge (u, v) (graph_join T1 T2))\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) (graph_join T1 T2)) \\<and>\n    nodes (ins_edge (u, v) (graph_join T1 T2)) = nodes rg \\<and>\n    edges (ins_edge (u, v) (graph_join T1 T2)) \\<subseteq> edges rg", "using \\<open>edges T \\<subseteq> edges rg\\<close> \\<open>edges T1 \\<union> edges T2 = ?E'\\<close>"], ["proof (prove)\nusing this:\n  nodes T = nodes rg\n  nodes T1 \\<union> nodes T2 = nodes T\n  tree (ins_edge (u, v) (graph_join T1 T2))\n  u \\<noteq> v\n  edges T \\<subseteq> edges rg\n  edges T1 \\<union> edges T2 = edges T - {(x, y), (y, x)}\n\ngoal (1 subgoal):\n 1. tree (ins_edge (u, v) (graph_join T1 T2)) \\<and>\n    nodes (ins_edge (u, v) (graph_join T1 T2)) = nodes rg \\<and>\n    edges (ins_edge (u, v) (graph_join T1 T2)) \\<subseteq> edges rg", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nodes T = nodes rg; nodes T1 \\<union> nodes T2 = nodes rg;\n     tree (ins_edge (u, v) (graph_join T1 T2));\n     edges T \\<subseteq> edges rg;\n     edges T1 \\<union> edges T2 = edges T - {(x, y), (y, x)}\\<rbrakk>\n    \\<Longrightarrow> insert u (insert v (nodes rg)) = nodes rg \\<and>\n                      (u, v) \\<in> edges rg \\<and>\n                      (v, u) \\<in> edges rg \\<and>\n                      edges T - {(x, y), (y, x)} \\<subseteq> edges rg", "by (metis Diff_subset crossing_edge(3) edges_sym' insert_absorb \n              nodesI(2) subset_trans)"], ["proof (state)\nthis:\n  is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "moreover"], ["proof (state)\nthis:\n  is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "have \"weight w ?T' \\<le> weight w T'\" if \"is_spanning_tree rg T'\" for T'"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w T'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w T'", "have ww: \"w {u,v} \\<le> w{x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w {u, v} \\<le> w {x, y}", "using min_edge \\<open>(x,y)\\<in>edges T\\<close> \\<open>edges T \\<subseteq> edges rg\\<close> \\<open>x\\<in>C\\<close> \\<open>y\\<notin>C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>(u', v')\\<in>edges rg \\<inter> C \\<times> - C.\n     w {u, v} \\<le> w {u', v'}\n  (x, y) \\<in> edges T\n  edges T \\<subseteq> edges rg\n  x \\<in> C\n  y \\<notin> C\n\ngoal (1 subgoal):\n 1. w {u, v} \\<le> w {x, y}", "by blast"], ["proof (state)\nthis:\n  w {u, v} \\<le> w {x, y}\n\ngoal (1 subgoal):\n 1. weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w T'", "have \"weight w ?T' = weight w T - w {x,y} + w{u,v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight w (ins_edge (u, v) (graph_join T1 T2)) =\n    weight w T - w {x, y} + w {u, v}", "using \\<open>(u, v) \\<notin> edges T\\<close> \\<open>(x, y) \\<in> edges T\\<close>"], ["proof (prove)\nusing this:\n  (u, v) \\<notin> edges T\n  (x, y) \\<in> edges T\n\ngoal (1 subgoal):\n 1. weight w (ins_edge (u, v) (graph_join T1 T2)) =\n    weight w T - w {x, y} + w {u, v}", "using \\<open>edges T1 \\<union> edges T2 = edges T - {(x, y), (y, x)}\\<close> \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  (u, v) \\<notin> edges T\n  (x, y) \\<in> edges T\n  edges T1 \\<union> edges T2 = edges T - {(x, y), (y, x)}\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. weight w (ins_edge (u, v) (graph_join T1 T2)) =\n    weight w T - w {x, y} + w {u, v}", "by (smt Diff_eq Diff_subset add.commute contra_subsetD edges_join \n              edges_restrict_edges minus_inv_sym_aux sup.idem weight_cong \n              weight_del_edge weight_ins_edge)"], ["proof (state)\nthis:\n  weight w (ins_edge (u, v) (graph_join T1 T2)) =\n  weight w T - w {x, y} + w {u, v}\n\ngoal (1 subgoal):\n 1. weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w T'", "also"], ["proof (state)\nthis:\n  weight w (ins_edge (u, v) (graph_join T1 T2)) =\n  weight w T - w {x, y} + w {u, v}\n\ngoal (1 subgoal):\n 1. weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w T'", "have \"\\<dots> \\<le> weight w T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight w T - w {x, y} + w {u, v} \\<le> weight w T", "using weight_ge_edge[OF \\<open>(x,y)\\<in>edges T\\<close>, of w] ww"], ["proof (prove)\nusing this:\n  w {x, y} \\<le> weight w T\n  w {u, v} \\<le> w {x, y}\n\ngoal (1 subgoal):\n 1. weight w T - w {x, y} + w {u, v} \\<le> weight w T", "by auto"], ["proof (state)\nthis:\n  weight w T - w {x, y} + w {u, v} \\<le> weight w T\n\ngoal (1 subgoal):\n 1. weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w T'", "also"], ["proof (state)\nthis:\n  weight w T - w {x, y} + w {u, v} \\<le> weight w T\n\ngoal (1 subgoal):\n 1. weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w T'", "have \"weight w T \\<le> weight w T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight w T \\<le> weight w T'", "using T(1) \\<open>is_spanning_tree rg T'\\<close>"], ["proof (prove)\nusing this:\n  is_MST w rg T\n  is_spanning_tree rg T'\n\ngoal (1 subgoal):\n 1. weight w T \\<le> weight w T'", "unfolding is_MST_def"], ["proof (prove)\nusing this:\n  is_spanning_tree rg T \\<and>\n  (\\<forall>t'.\n      is_spanning_tree rg t' \\<longrightarrow> weight w T \\<le> weight w t')\n  is_spanning_tree rg T'\n\ngoal (1 subgoal):\n 1. weight w T \\<le> weight w T'", "by simp"], ["proof (state)\nthis:\n  weight w T \\<le> weight w T'\n\ngoal (1 subgoal):\n 1. weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w T'", "finally"], ["proof (chain)\npicking this:\n  weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w T'", "show ?thesis"], ["proof (prove)\nusing this:\n  weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w T'\n\ngoal (1 subgoal):\n 1. weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w T'", "."], ["proof (state)\nthis:\n  weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w T'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_spanning_tree rg ?T' \\<Longrightarrow>\n  weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w ?T'\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "ultimately"], ["proof (chain)\npicking this:\n  is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))\n  is_spanning_tree rg ?T' \\<Longrightarrow>\n  weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w ?T'", "have \"is_MST w rg ?T'\""], ["proof (prove)\nusing this:\n  is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))\n  is_spanning_tree rg ?T' \\<Longrightarrow>\n  weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w ?T'\n\ngoal (1 subgoal):\n 1. is_MST w rg (ins_edge (u, v) (graph_join T1 T2))", "using is_MST_def"], ["proof (prove)\nusing this:\n  is_spanning_tree rg (ins_edge (u, v) (graph_join T1 T2))\n  is_spanning_tree rg ?T' \\<Longrightarrow>\n  weight w (ins_edge (u, v) (graph_join T1 T2)) \\<le> weight w ?T'\n  is_MST ?w ?g ?t \\<equiv>\n  is_spanning_tree ?g ?t \\<and>\n  (\\<forall>t'.\n      is_spanning_tree ?g t' \\<longrightarrow>\n      weight ?w ?t \\<le> weight ?w t')\n\ngoal (1 subgoal):\n 1. is_MST w rg (ins_edge (u, v) (graph_join T1 T2))", "by blast"], ["proof (state)\nthis:\n  is_MST w rg (ins_edge (u, v) (graph_join T1 T2))\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "have \"{(u,v),(v,u)} \\<union> A \\<subseteq> edges ?T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v), (v, u)} \\<union> A\n    \\<subseteq> edges (ins_edge (u, v) (graph_join T1 T2))", "using T(2) respects_cut xy(2,3) \\<open>edges T1 \\<union> edges T2 = ?E'\\<close>"], ["proof (prove)\nusing this:\n  A \\<subseteq> edges T\n  respects_cut A C\n  x \\<in> C\n  y \\<notin> C\n  edges T1 \\<union> edges T2 = edges T - {(x, y), (y, x)}\n\ngoal (1 subgoal):\n 1. {(u, v), (v, u)} \\<union> A\n    \\<subseteq> edges (ins_edge (u, v) (graph_join T1 T2))", "unfolding respects_cut_def"], ["proof (prove)\nusing this:\n  A \\<subseteq> edges T\n  A \\<subseteq> C \\<times> C \\<union> (- C) \\<times> - C\n  x \\<in> C\n  y \\<notin> C\n  edges T1 \\<union> edges T2 = edges T - {(x, y), (y, x)}\n\ngoal (1 subgoal):\n 1. {(u, v), (v, u)} \\<union> A\n    \\<subseteq> edges (ins_edge (u, v) (graph_join T1 T2))", "by auto"], ["proof (state)\nthis:\n  {(u, v), (v, u)} \\<union> A\n  \\<subseteq> edges (ins_edge (u, v) (graph_join T1 T2))\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> edges T \\<Longrightarrow>\n    is_subset_MST w rg ({(v, u)} \\<union> A)", "with \\<open>is_MST w rg ?T'\\<close>"], ["proof (chain)\npicking this:\n  is_MST w rg (ins_edge (u, v) (graph_join T1 T2))\n  {(u, v), (v, u)} \\<union> A\n  \\<subseteq> edges (ins_edge (u, v) (graph_join T1 T2))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_MST w rg (ins_edge (u, v) (graph_join T1 T2))\n  {(u, v), (v, u)} \\<union> A\n  \\<subseteq> edges (ins_edge (u, v) (graph_join T1 T2))\n\ngoal (1 subgoal):\n 1. is_subset_MST w rg ({(v, u)} \\<union> A)", "unfolding is_subset_MST_def"], ["proof (prove)\nusing this:\n  is_MST w rg (ins_edge (u, v) (graph_join T1 T2))\n  {(u, v), (v, u)} \\<union> A\n  \\<subseteq> edges (ins_edge (u, v) (graph_join T1 T2))\n\ngoal (1 subgoal):\n 1. \\<exists>t. is_MST w rg t \\<and> {(v, u)} \\<union> A \\<subseteq> edges t", "by force"], ["proof (state)\nthis:\n  is_subset_MST w rg ({(v, u)} \\<union> A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_subset_MST w rg ({(v, u)} \\<union> A)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Abstract Prim: Growing a Tree\\label{sec:prim_algo}\\<close>"], ["", "context Prim begin"], ["", "text \\<open>The current nodes\\<close>"], ["", "definition \"S A \\<equiv> {r} \\<union> fst`A \\<union> snd`A\""], ["", "lemma respects_cut': \"A \\<subseteq> S A \\<times> S A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> S A \\<times> S A", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> ({r} \\<union> fst ` A \\<union> snd ` A) \\<times>\n                  ({r} \\<union> fst ` A \\<union> snd ` A)", "by force"], ["", "corollary respects_cut: \"respects_cut A (S A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. respects_cut A (S A)", "unfolding respects_cut_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> S A \\<times> S A \\<union> (- S A) \\<times> - S A", "using respects_cut'"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> S ?A \\<times> S ?A\n\ngoal (1 subgoal):\n 1. A \\<subseteq> S A \\<times> S A \\<union> (- S A) \\<times> - S A", "by auto"], ["", "text \\<open>Refined invariant: Adds connectedness of \\<open>A\\<close>\\<close>"], ["", "definition \"prim_invar1 A \\<equiv> is_subset_MST w rg A \\<and> (\\<forall>(u,v)\\<in>A. (v,r)\\<in>A\\<^sup>*)\""], ["", "text \\<open>Measure: Number of nodes not in tree\\<close>"], ["", "definition \"T_measure1 A = card (nodes rg - S A)\""], ["", "end"], ["", "text \\<open>We use a locale that fixes a state and assumes the invariant\\<close>"], ["", "locale Prim_Invar1_loc = \n  Prim w g r for w g and r :: 'v +\n  fixes A :: \"('v\\<times>'v) set\"\n  assumes invar1: \"prim_invar1 A\"\nbegin"], ["", "lemma subset_MST: \"is_subset_MST w rg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subset_MST w rg A", "using invar1"], ["proof (prove)\nusing this:\n  prim_invar1 A\n\ngoal (1 subgoal):\n 1. is_subset_MST w rg A", "unfolding prim_invar1_def"], ["proof (prove)\nusing this:\n  is_subset_MST w rg A \\<and>\n  (\\<forall>(u, v)\\<in>A. (v, r) \\<in> A\\<^sup>*)\n\ngoal (1 subgoal):\n 1. is_subset_MST w rg A", "by auto"], ["", "lemma A_connected: \"(u,v)\\<in>A \\<Longrightarrow> (v,r)\\<in>A\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> A \\<Longrightarrow> (v, r) \\<in> A\\<^sup>*", "using invar1"], ["proof (prove)\nusing this:\n  prim_invar1 A\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> A \\<Longrightarrow> (v, r) \\<in> A\\<^sup>*", "unfolding prim_invar1_def"], ["proof (prove)\nusing this:\n  is_subset_MST w rg A \\<and>\n  (\\<forall>(u, v)\\<in>A. (v, r) \\<in> A\\<^sup>*)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> A \\<Longrightarrow> (v, r) \\<in> A\\<^sup>*", "by auto"], ["", "lemma S_alt_def: \"S A = {r} \\<union> fst`A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S A = {r} \\<union> fst ` A", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {r} \\<union> fst ` A \\<union> snd ` A = {r} \\<union> fst ` A", "apply (safe;simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<notin> fst ` A; (a, b) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> b = r", "by (metis A_connected Domain_fst Not_Domain_rtrancl)"], ["", "lemma finite_rem_nodes[simp,intro!]: \"finite (nodes rg - S A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes rg - S A)", "by auto"], ["", "lemma A_edges: \"A \\<subseteq> edges g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> edges g", "using subset_MST"], ["proof (prove)\nusing this:\n  is_subset_MST w rg A\n\ngoal (1 subgoal):\n 1. A \\<subseteq> edges g", "by (meson is_MST_def is_spanning_tree_def is_subset_MST_def \n        reachable_edges_subset subset_eq)"], ["", "lemma S_reachable: \"S A \\<subseteq> nodes rg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S A \\<subseteq> nodes rg", "unfolding S_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {r} \\<union> fst ` A \\<subseteq> nodes rg", "by (smt DomainE Un_insert_left fst_eq_Domain insert_subset is_MST_def \n        is_spanning_tree_def is_subset_MST_def nodesI(1) nodes_of_component \n        reachable_nodes_refl rg_def subset_MST subset_iff sup_bot.left_neutral)"], ["", "lemma S_edge_reachable: \"\\<lbrakk>u\\<in>S A; (u,v)\\<in>edges g \\<rbrakk> \\<Longrightarrow> (u,v)\\<in>edges rg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> S A; (u, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> edges rg", "using S_reachable"], ["proof (prove)\nusing this:\n  S A \\<subseteq> nodes rg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> S A; (u, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> edges rg", "unfolding rg_def"], ["proof (prove)\nusing this:\n  S A \\<subseteq> nodes (component_of g r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> S A; (u, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> edges (component_of g r)", "using reachable_nodes_step'(2)"], ["proof (prove)\nusing this:\n  S A \\<subseteq> nodes (component_of g r)\n  \\<lbrakk>?u \\<in> reachable_nodes ?g ?r; (?u, ?v) \\<in> edges ?g\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> edges (component_of ?g ?r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> S A; (u, v) \\<in> edges g\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> edges (component_of g r)", "by fastforce"], ["", "lemma edges_S_rg_edges: \"edges g \\<inter> S A\\<times>-S A = edges rg \\<inter> S A\\<times>-S A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges g \\<inter> S A \\<times> - S A =\n    edges rg \\<inter> S A \\<times> - S A", "using S_edge_reachable reachable_edges_subset"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> S A; (?u, ?v) \\<in> edges g\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> edges rg\n  edges rg \\<subseteq> edges g\n\ngoal (1 subgoal):\n 1. edges g \\<inter> S A \\<times> - S A =\n    edges rg \\<inter> S A \\<times> - S A", "by auto"], ["", "lemma T_measure1_less: \"T_measure1 A < card (nodes rg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T_measure1 A < card (nodes rg)", "unfolding T_measure1_def S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (nodes rg - ({r} \\<union> fst ` A \\<union> snd ` A))\n    < card (nodes rg)", "by (metis Diff_subset S_def S_reachable Un_insert_left le_supE nodes_finite \n        psubsetI psubset_card_mono singletonI subset_Diff_insert)"], ["", "lemma finite_A[simp, intro!]: \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "using A_edges finite_subset"], ["proof (prove)\nusing this:\n  A \\<subseteq> edges g\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite A", "by auto"], ["", "lemma finite_S[simp, intro!]: \"finite (S A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S A)", "using S_reachable rev_finite_subset"], ["proof (prove)\nusing this:\n  S A \\<subseteq> nodes rg\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (S A)", "by blast"], ["", "(* TODO: Used? *)"], ["", "lemma S_A_consistent[simp, intro!]: \"nodes_edges_consistent (S A) (A\\<union>A\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_edges_consistent (S A) (A \\<union> A\\<inverse>)", "unfolding nodes_edges_consistent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S A) \\<and>\n    irrefl (A \\<union> A\\<inverse>) \\<and>\n    sym (A \\<union> A\\<inverse>) \\<and>\n    A \\<union> A\\<inverse> \\<subseteq> S A \\<times> S A", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (S A)\n 2. irrefl (A \\<union> A\\<inverse>)\n 3. sym (A \\<union> A\\<inverse>)\n 4. A \\<union> A\\<inverse> \\<subseteq> S A \\<times> S A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S A)", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. irrefl (A \\<union> A\\<inverse>)\n 2. sym (A \\<union> A\\<inverse>)\n 3. A \\<union> A\\<inverse> \\<subseteq> S A \\<times> S A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl (A \\<union> A\\<inverse>)", "using A_edges irrefl_def"], ["proof (prove)\nusing this:\n  A \\<subseteq> edges g\n  irrefl ?r = (\\<forall>a. (a, a) \\<notin> ?r)\n\ngoal (1 subgoal):\n 1. irrefl (A \\<union> A\\<inverse>)", "by fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. sym (A \\<union> A\\<inverse>)\n 2. A \\<union> A\\<inverse> \\<subseteq> S A \\<times> S A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (A \\<union> A\\<inverse>)", "by (simp add: sym_Un_converse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> A\\<inverse> \\<subseteq> S A \\<times> S A", "using respects_cut'"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> S ?A \\<times> S ?A\n\ngoal (1 subgoal):\n 1. A \\<union> A\\<inverse> \\<subseteq> S A \\<times> S A", "by auto"], ["", "end"], ["", "context Prim begin"], ["", "lemma invar1_initial: \"prim_invar1 {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar1 {}", "by (auto simp: is_subset_MST_def prim_invar1_def exists_MST)"], ["", "lemma maintain_invar1:\n  assumes invar: \"prim_invar1 A\"\n  assumes light_edge: \"light_edge (S A) u v\"\n  shows \"prim_invar1 ({(v,u)}\\<union>A) \n       \\<and> T_measure1 ({(v,u)}\\<union>A) < T_measure1 A\" (is \"?G1 \\<and> ?G2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar1 ({(v, u)} \\<union> A) \\<and>\n    T_measure1 ({(v, u)} \\<union> A) < T_measure1 A", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar1 ({(v, u)} \\<union> A)\n 2. T_measure1 ({(v, u)} \\<union> A) < T_measure1 A", "from invar"], ["proof (chain)\npicking this:\n  prim_invar1 A", "interpret Prim_Invar1_loc w g r A"], ["proof (prove)\nusing this:\n  prim_invar1 A\n\ngoal (1 subgoal):\n 1. Prim_Invar1_loc w g r A", "by unfold_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar1 ({(v, u)} \\<union> A)\n 2. T_measure1 ({(v, u)} \\<union> A) < T_measure1 A", "from light_edge"], ["proof (chain)\npicking this:\n  light_edge (S A) u v", "have \"u\\<in>S A\" \"v\\<notin>S A\""], ["proof (prove)\nusing this:\n  light_edge (S A) u v\n\ngoal (1 subgoal):\n 1. u \\<in> S A &&& v \\<notin> S A", "by (simp_all add: light_edge_def)"], ["proof (state)\nthis:\n  u \\<in> S A\n  v \\<notin> S A\n\ngoal (2 subgoals):\n 1. prim_invar1 ({(v, u)} \\<union> A)\n 2. T_measure1 ({(v, u)} \\<union> A) < T_measure1 A", "show ?G1"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar1 ({(v, u)} \\<union> A)", "unfolding prim_invar1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subset_MST w rg ({(v, u)} \\<union> A) \\<and>\n    (\\<forall>(ua, va)\\<in>{(v, u)} \\<union> A.\n        (va, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*)", "proof (intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_subset_MST w rg ({(v, u)} \\<union> A)\n 2. \\<forall>(ua, va)\\<in>{(v, u)} \\<union> A.\n       (va, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*", "show \"is_subset_MST w rg ({(v, u)} \\<union> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subset_MST w rg ({(v, u)} \\<union> A)", "by (rule light_edge_is_safe[OF subset_MST respects_cut light_edge])"], ["proof (state)\nthis:\n  is_subset_MST w rg ({(v, u)} \\<union> A)\n\ngoal (1 subgoal):\n 1. \\<forall>(ua, va)\\<in>{(v, u)} \\<union> A.\n       (va, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(ua, va)\\<in>{(v, u)} \\<union> A.\n       (va, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*", "show \"\\<forall>(ua, va)\\<in>{(v, u)} \\<union> A. (va, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(ua, va)\\<in>{(v, u)} \\<union> A.\n       (va, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b. (u, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*\n 2. \\<And>a b.\n       (a, b) \\<in> A \\<Longrightarrow>\n       (b, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*", "using A_connected"], ["proof (prove)\nusing this:\n  (?u, ?v) \\<in> A \\<Longrightarrow> (?v, r) \\<in> A\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*", "by (simp add: rtrancl_insert) \n           (metis DomainE S_alt_def converse_rtrancl_into_rtrancl \\<open>u\\<in>S A\\<close> \n                    fst_eq_Domain insertE insert_is_Un rtrancl_eq_or_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> A \\<Longrightarrow>\n       (b, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> A \\<Longrightarrow>\n    (b_, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*", "using A_connected"], ["proof (prove)\nusing this:\n  (?u, ?v) \\<in> A \\<Longrightarrow> (?v, r) \\<in> A\\<^sup>*\n\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> A \\<Longrightarrow>\n    (b_, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*", "by (simp add: rtrancl_insert)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>(ua, va)\\<in>{(v, u)} \\<union> A.\n     (va, r) \\<in> ({(v, u)} \\<union> A)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prim_invar1 ({(v, u)} \\<union> A)\n\ngoal (1 subgoal):\n 1. T_measure1 ({(v, u)} \\<union> A) < T_measure1 A", "then"], ["proof (chain)\npicking this:\n  prim_invar1 ({(v, u)} \\<union> A)", "interpret N: Prim_Invar1_loc w g r \"{(v,u)}\\<union>A\""], ["proof (prove)\nusing this:\n  prim_invar1 ({(v, u)} \\<union> A)\n\ngoal (1 subgoal):\n 1. Prim_Invar1_loc w g r ({(v, u)} \\<union> A)", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. T_measure1 ({(v, u)} \\<union> A) < T_measure1 A", "have \"S A \\<subset> S ({(v,u)}\\<union>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S A \\<subset> S ({(v, u)} \\<union> A)", "using \\<open>v\\<notin>S A\\<close>"], ["proof (prove)\nusing this:\n  v \\<notin> S A\n\ngoal (1 subgoal):\n 1. S A \\<subset> S ({(v, u)} \\<union> A)", "unfolding S_def"], ["proof (prove)\nusing this:\n  v \\<notin> {r} \\<union> fst ` A \\<union> snd ` A\n\ngoal (1 subgoal):\n 1. {r} \\<union> fst ` A \\<union> snd ` A\n    \\<subset> {r} \\<union> fst ` ({(v, u)} \\<union> A) \\<union>\n              snd ` ({(v, u)} \\<union> A)", "by auto"], ["proof (state)\nthis:\n  S A \\<subset> S ({(v, u)} \\<union> A)\n\ngoal (1 subgoal):\n 1. T_measure1 ({(v, u)} \\<union> A) < T_measure1 A", "then"], ["proof (chain)\npicking this:\n  S A \\<subset> S ({(v, u)} \\<union> A)", "show \"?G2\""], ["proof (prove)\nusing this:\n  S A \\<subset> S ({(v, u)} \\<union> A)\n\ngoal (1 subgoal):\n 1. T_measure1 ({(v, u)} \\<union> A) < T_measure1 A", "unfolding T_measure1_def"], ["proof (prove)\nusing this:\n  S A \\<subset> S ({(v, u)} \\<union> A)\n\ngoal (1 subgoal):\n 1. card (nodes rg - S ({(v, u)} \\<union> A)) < card (nodes rg - S A)", "using S_reachable N.S_reachable"], ["proof (prove)\nusing this:\n  S A \\<subset> S ({(v, u)} \\<union> A)\n  S A \\<subseteq> nodes rg\n  S ({(v, u)} \\<union> A) \\<subseteq> nodes rg\n\ngoal (1 subgoal):\n 1. card (nodes rg - S ({(v, u)} \\<union> A)) < card (nodes rg - S A)", "by (auto intro!: psubset_card_mono)"], ["proof (state)\nthis:\n  T_measure1 ({(v, u)} \\<union> A) < T_measure1 A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar1_finish:\n  assumes INV: \"prim_invar1 A\"\n  assumes FIN: \"edges g \\<inter> S A\\<times>-S A = {}\"\n  shows \"is_MST w rg (graph {r} A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "from INV"], ["proof (chain)\npicking this:\n  prim_invar1 A", "interpret Prim_Invar1_loc w g r A"], ["proof (prove)\nusing this:\n  prim_invar1 A\n\ngoal (1 subgoal):\n 1. Prim_Invar1_loc w g r A", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "from subset_MST"], ["proof (chain)\npicking this:\n  is_subset_MST w rg A", "obtain t where MST: \"is_MST w rg t\" and \"A \\<subseteq> edges t\""], ["proof (prove)\nusing this:\n  is_subset_MST w rg A\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>is_MST w rg t; A \\<subseteq> edges t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_subset_MST_def"], ["proof (prove)\nusing this:\n  \\<exists>t. is_MST w rg t \\<and> A \\<subseteq> edges t\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>is_MST w rg t; A \\<subseteq> edges t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_MST w rg t\n  A \\<subseteq> edges t\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "have \"S A = nodes t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S A = nodes t", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> S A \\<Longrightarrow> x \\<in> nodes t\n 2. \\<And>x. x \\<in> nodes t \\<Longrightarrow> x \\<in> S A", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> S A \\<Longrightarrow> x \\<in> nodes t\n 2. \\<And>x. x \\<in> nodes t \\<Longrightarrow> x \\<in> S A", "show \"u\\<in>S A \\<Longrightarrow> u\\<in>nodes t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> S A \\<Longrightarrow> u \\<in> nodes t", "using MST"], ["proof (prove)\nusing this:\n  is_MST w rg t\n\ngoal (1 subgoal):\n 1. u \\<in> S A \\<Longrightarrow> u \\<in> nodes t", "unfolding is_MST_def is_spanning_tree_def"], ["proof (prove)\nusing this:\n  (tree t \\<and>\n   nodes t = nodes rg \\<and> edges t \\<subseteq> edges rg) \\<and>\n  (\\<forall>t'.\n      tree t' \\<and>\n      nodes t' = nodes rg \\<and>\n      edges t' \\<subseteq> edges rg \\<longrightarrow>\n      weight w t \\<le> weight w t')\n\ngoal (1 subgoal):\n 1. u \\<in> S A \\<Longrightarrow> u \\<in> nodes t", "using S_reachable"], ["proof (prove)\nusing this:\n  (tree t \\<and>\n   nodes t = nodes rg \\<and> edges t \\<subseteq> edges rg) \\<and>\n  (\\<forall>t'.\n      tree t' \\<and>\n      nodes t' = nodes rg \\<and>\n      edges t' \\<subseteq> edges rg \\<longrightarrow>\n      weight w t \\<le> weight w t')\n  S A \\<subseteq> nodes rg\n\ngoal (1 subgoal):\n 1. u \\<in> S A \\<Longrightarrow> u \\<in> nodes t", "by auto"], ["proof (state)\nthis:\n  u \\<in> S A \\<Longrightarrow> u \\<in> nodes t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> nodes t \\<Longrightarrow> x \\<in> S A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> nodes t \\<Longrightarrow> x \\<in> S A", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> nodes t \\<Longrightarrow> x \\<in> S A", "assume \"u\\<in>nodes t\""], ["proof (state)\nthis:\n  u \\<in> nodes t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> nodes t \\<Longrightarrow> x \\<in> S A", "hence \"u\\<in>nodes rg\""], ["proof (prove)\nusing this:\n  u \\<in> nodes t\n\ngoal (1 subgoal):\n 1. u \\<in> nodes rg", "using MST is_MST_def is_spanning_tree_def"], ["proof (prove)\nusing this:\n  u \\<in> nodes t\n  is_MST w rg t\n  is_MST ?w ?g ?t \\<equiv>\n  is_spanning_tree ?g ?t \\<and>\n  (\\<forall>t'.\n      is_spanning_tree ?g t' \\<longrightarrow>\n      weight ?w ?t \\<le> weight ?w t')\n  is_spanning_tree ?G ?T \\<equiv>\n  tree ?T \\<and> nodes ?T = nodes ?G \\<and> edges ?T \\<subseteq> edges ?G\n\ngoal (1 subgoal):\n 1. u \\<in> nodes rg", "by force"], ["proof (state)\nthis:\n  u \\<in> nodes rg\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> nodes t \\<Longrightarrow> x \\<in> S A", "hence 1: \"(u,r)\\<in>(edges rg)\\<^sup>*\""], ["proof (prove)\nusing this:\n  u \\<in> nodes rg\n\ngoal (1 subgoal):\n 1. (u, r) \\<in> (edges rg)\\<^sup>*", "by (simp add: connectedD rg_def)"], ["proof (state)\nthis:\n  (u, r) \\<in> (edges rg)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> nodes t \\<Longrightarrow> x \\<in> S A", "have \"r\\<in>S A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> S A", "by (simp add: S_def)"], ["proof (state)\nthis:\n  r \\<in> S A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> nodes t \\<Longrightarrow> x \\<in> S A", "show \"u\\<in>S A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> S A", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> S A \\<Longrightarrow> False", "assume \"u\\<notin>S A\""], ["proof (state)\nthis:\n  u \\<notin> S A\n\ngoal (1 subgoal):\n 1. u \\<notin> S A \\<Longrightarrow> False", "from find_crossing_edge_rtrancl[where P=\"\\<lambda>u. u\\<in>S A\", OF 1 \\<open>u\\<notin>S A\\<close> \\<open>r\\<in>S A\\<close>] \n        FIN reachable_edges_subset"], ["proof (chain)\npicking this:\n  (\\<And>u' v'.\n      \\<lbrakk>(u', v') \\<in> edges rg; u' \\<notin> S A;\n       v' \\<in> S A\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  edges g \\<inter> S A \\<times> - S A = {}\n  edges rg \\<subseteq> edges g", "show False"], ["proof (prove)\nusing this:\n  (\\<And>u' v'.\n      \\<lbrakk>(u', v') \\<in> edges rg; u' \\<notin> S A;\n       v' \\<in> S A\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  edges g \\<inter> S A \\<times> - S A = {}\n  edges rg \\<subseteq> edges g\n\ngoal (1 subgoal):\n 1. False", "by (smt ComplI IntI contra_subsetD edges_sym' emptyE mem_Sigma_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<in> S A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S A = nodes t\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "also"], ["proof (state)\nthis:\n  S A = nodes t\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "have \"nodes t = nodes rg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes t = nodes rg", "using MST"], ["proof (prove)\nusing this:\n  is_MST w rg t\n\ngoal (1 subgoal):\n 1. nodes t = nodes rg", "unfolding is_MST_def is_spanning_tree_def"], ["proof (prove)\nusing this:\n  (tree t \\<and>\n   nodes t = nodes rg \\<and> edges t \\<subseteq> edges rg) \\<and>\n  (\\<forall>t'.\n      tree t' \\<and>\n      nodes t' = nodes rg \\<and>\n      edges t' \\<subseteq> edges rg \\<longrightarrow>\n      weight w t \\<le> weight w t')\n\ngoal (1 subgoal):\n 1. nodes t = nodes rg", "by auto"], ["proof (state)\nthis:\n  nodes t = nodes rg\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "finally"], ["proof (chain)\npicking this:\n  S A = nodes rg", "have S_eq: \"S A = nodes rg\""], ["proof (prove)\nusing this:\n  S A = nodes rg\n\ngoal (1 subgoal):\n 1. S A = nodes rg", "."], ["proof (state)\nthis:\n  S A = nodes rg\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "define t' where \"t' = graph {r} A\""], ["proof (state)\nthis:\n  t' = graph {r} A\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "have [simp]: \"nodes t' = S A\" and Et': \"edges t' = (A\\<union>A\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes t' = S A &&& edges t' = A \\<union> A\\<inverse>", "unfolding t'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (graph {r} A) = S A &&&\n    edges (graph {r} A) = A \\<union> A\\<inverse>", "using A_edges"], ["proof (prove)\nusing this:\n  A \\<subseteq> edges g\n\ngoal (1 subgoal):\n 1. nodes (graph {r} A) = S A &&&\n    edges (graph {r} A) = A \\<union> A\\<inverse>", "by (auto simp: graph_accs S_def)"], ["proof (state)\nthis:\n  nodes t' = S A\n  edges t' = A \\<union> A\\<inverse>\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "hence \"edges t' \\<subseteq> edges t\""], ["proof (prove)\nusing this:\n  nodes t' = S A\n  edges t' = A \\<union> A\\<inverse>\n\ngoal (1 subgoal):\n 1. edges t' \\<subseteq> edges t", "by (smt UnE \\<open>A \\<subseteq> edges t\\<close> converseD edges_sym' subrelI subset_eq)"], ["proof (state)\nthis:\n  edges t' \\<subseteq> edges t\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "have \"is_spanning_tree rg t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_spanning_tree rg t'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_spanning_tree rg t'", "have \"connected t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Undirected_Graph.connected t'", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> nodes t'; v \\<in> nodes t'\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (edges t')\\<^sup>*", "apply (simp add: Et' S_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u = r \\<or> u \\<in> fst ` A \\<or> u \\<in> snd ` A;\n        v = r \\<or> v \\<in> fst ` A \\<or> v \\<in> snd ` A\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (A \\<union> A\\<inverse>)\\<^sup>*", "apply safe"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>u v a b.\n       (a, b) \\<in> A \\<Longrightarrow>\n       (r, fst (a, b)) \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 2. \\<And>u v a b.\n       (a, b) \\<in> A \\<Longrightarrow>\n       (r, snd (a, b)) \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 3. \\<And>u v a b.\n       (a, b) \\<in> A \\<Longrightarrow>\n       (fst (a, b), r) \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 4. \\<And>u v a b.\n       (a, b) \\<in> A \\<Longrightarrow>\n       (snd (a, b), r) \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 5. \\<And>u v a b aa ba.\n       \\<lbrakk>(a, b) \\<in> A; (aa, ba) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (fst (a, b), fst (aa, ba))\n                         \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 6. \\<And>u v a b aa ba.\n       \\<lbrakk>(a, b) \\<in> A; (aa, ba) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (fst (a, b), snd (aa, ba))\n                         \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 7. \\<And>u v a b aa ba.\n       \\<lbrakk>(a, b) \\<in> A; (aa, ba) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (snd (a, b), fst (aa, ba))\n                         \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 8. \\<And>u v a b aa ba.\n       \\<lbrakk>(a, b) \\<in> A; (aa, ba) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (snd (a, b), snd (aa, ba))\n                         \\<in> (A \\<union> A\\<inverse>)\\<^sup>*", "apply ((simp add: A_connected converse_rtrancl_into_rtrancl \n                        in_rtrancl_UnI rtrancl_converse\n             )+\n      ) [4]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u v a b aa ba.\n       \\<lbrakk>(a, b) \\<in> A; (aa, ba) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (fst (a, b), fst (aa, ba))\n                         \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 2. \\<And>u v a b aa ba.\n       \\<lbrakk>(a, b) \\<in> A; (aa, ba) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (fst (a, b), snd (aa, ba))\n                         \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 3. \\<And>u v a b aa ba.\n       \\<lbrakk>(a, b) \\<in> A; (aa, ba) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (snd (a, b), fst (aa, ba))\n                         \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 4. \\<And>u v a b aa ba.\n       \\<lbrakk>(a, b) \\<in> A; (aa, ba) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (snd (a, b), snd (aa, ba))\n                         \\<in> (A \\<union> A\\<inverse>)\\<^sup>*", "apply simp_all [4]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> A; (aa, ba) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (a, aa) \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> A; (aa, ba) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (a, ba) \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 3. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> A; (aa, ba) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (b, aa) \\<in> (A \\<union> A\\<inverse>)\\<^sup>*\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> A; (aa, ba) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (b, ba) \\<in> (A \\<union> A\\<inverse>)\\<^sup>*", "apply ((meson A_connected in_rtrancl_UnI r_into_rtrancl \n                rtrancl_converseI rtrancl_trans\n             )+\n      ) [4]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Undirected_Graph.connected t'\n\ngoal (1 subgoal):\n 1. is_spanning_tree rg t'", "moreover"], ["proof (state)\nthis:\n  Undirected_Graph.connected t'\n\ngoal (1 subgoal):\n 1. is_spanning_tree rg t'", "have \"cycle_free t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle_free t'", "by (meson MST \\<open>edges t' \\<subseteq> edges t\\<close> cycle_free_antimono is_MST_def \n                is_spanning_tree_def tree_def)"], ["proof (state)\nthis:\n  cycle_free t'\n\ngoal (1 subgoal):\n 1. is_spanning_tree rg t'", "moreover"], ["proof (state)\nthis:\n  cycle_free t'\n\ngoal (1 subgoal):\n 1. is_spanning_tree rg t'", "have \"edges t' \\<subseteq> edges rg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges t' \\<subseteq> edges rg", "by (meson MST \\<open>edges t' \\<subseteq> edges t\\<close> dual_order.trans is_MST_def \n            is_spanning_tree_def)"], ["proof (state)\nthis:\n  edges t' \\<subseteq> edges rg\n\ngoal (1 subgoal):\n 1. is_spanning_tree rg t'", "ultimately"], ["proof (chain)\npicking this:\n  Undirected_Graph.connected t'\n  cycle_free t'\n  edges t' \\<subseteq> edges rg", "show ?thesis"], ["proof (prove)\nusing this:\n  Undirected_Graph.connected t'\n  cycle_free t'\n  edges t' \\<subseteq> edges rg\n\ngoal (1 subgoal):\n 1. is_spanning_tree rg t'", "unfolding is_spanning_tree_def tree_def"], ["proof (prove)\nusing this:\n  Undirected_Graph.connected t'\n  cycle_free t'\n  edges t' \\<subseteq> edges rg\n\ngoal (1 subgoal):\n 1. (Undirected_Graph.connected t' \\<and> cycle_free t') \\<and>\n    nodes t' = nodes rg \\<and> edges t' \\<subseteq> edges rg", "by (auto simp: S_eq)"], ["proof (state)\nthis:\n  is_spanning_tree rg t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_spanning_tree rg t'\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "then"], ["proof (chain)\npicking this:\n  is_spanning_tree rg t'", "show ?thesis"], ["proof (prove)\nusing this:\n  is_spanning_tree rg t'\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "using MST weight_mono[OF \\<open>edges t' \\<subseteq> edges t\\<close>]"], ["proof (prove)\nusing this:\n  is_spanning_tree rg t'\n  is_MST w rg t\n  weight ?w t' \\<le> weight ?w t\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} A)", "unfolding t'_def is_MST_def"], ["proof (prove)\nusing this:\n  is_spanning_tree rg (graph {r} A)\n  is_spanning_tree rg t \\<and>\n  (\\<forall>t'.\n      is_spanning_tree rg t' \\<longrightarrow> weight w t \\<le> weight w t')\n  weight ?w (graph {r} A) \\<le> weight ?w t\n\ngoal (1 subgoal):\n 1. is_spanning_tree rg (graph {r} A) \\<and>\n    (\\<forall>t'.\n        is_spanning_tree rg t' \\<longrightarrow>\n        weight w (graph {r} A) \\<le> weight w t')", "using dual_order.trans"], ["proof (prove)\nusing this:\n  is_spanning_tree rg (graph {r} A)\n  is_spanning_tree rg t \\<and>\n  (\\<forall>t'.\n      is_spanning_tree rg t' \\<longrightarrow> weight w t \\<le> weight w t')\n  weight ?w (graph {r} A) \\<le> weight ?w t\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. is_spanning_tree rg (graph {r} A) \\<and>\n    (\\<forall>t'.\n        is_spanning_tree rg t' \\<longrightarrow>\n        weight w (graph {r} A) \\<le> weight w t')", "by blast"], ["proof (state)\nthis:\n  is_MST w rg (graph {r} A)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Prim: Using a Priority Queue\\label{sec:using_pq}\\<close>"], ["", "text \\<open>We define a new locale. Note that we could also reuse @{locale Prim}, however,\n  this would complicate referencing the constants later in the theories from \n  which we generate the paper.\n\\<close>"], ["", "locale Prim2 = Prim w g r for w :: \"'v set \\<Rightarrow> nat\" and g :: \"'v ugraph\" and r :: 'v\nbegin"], ["", "text \\<open>Abstraction to edge set\\<close>"], ["", "definition \"A Q \\<pi> \\<equiv> {(u,v). \\<pi> u = Some v \\<and> Q u = \\<infinity>}\""], ["", "text \\<open>Initialization\\<close>"], ["", "definition initQ :: \"'v \\<Rightarrow> enat\"  where \"initQ \\<equiv> (\\<lambda>_. \\<infinity>)(r := 0)\""], ["", "definition init\\<pi> :: \"'v \\<Rightarrow> 'v option\" where \"init\\<pi> \\<equiv> Map.empty\""], ["", "text \\<open>Step\\<close>"], ["", "definition \"upd_cond Q \\<pi> u v' \\<equiv> \n    (v',u) \\<in> edges g \n  \\<and> v'\\<noteq>r \\<and> (Q v' = \\<infinity> \\<longrightarrow> \\<pi> v' = None)\n  \\<and> enat (w {v',u}) < Q v'\""], ["", "text \\<open>State after inner loop\\<close>"], ["", "definition \"Qinter Q \\<pi> u v' \n  = (if upd_cond Q \\<pi> u v' then enat (w {v',u}) else Q v')\""], ["", "text \\<open>State after one step\\<close>"], ["", "definition \"Q' Q \\<pi> u \\<equiv> (Qinter Q \\<pi> u)(u:=\\<infinity>)\""], ["", "definition \"\\<pi>' Q \\<pi> u v' = (if upd_cond Q \\<pi> u v' then Some u else \\<pi> v')\""], ["", "definition \"prim_invar2_init Q \\<pi> \\<equiv> Q=initQ \\<and> \\<pi>=init\\<pi>\""], ["", "definition \"prim_invar2_ctd Q \\<pi> \\<equiv> let A = A Q \\<pi>; S = S A in\n  prim_invar1 A\n\\<and> \\<pi> r = None \\<and> Q r = \\<infinity>  \n\\<and> (\\<forall>(u,v)\\<in>edges rg \\<inter> (-S)\\<times>S. Q u \\<noteq> \\<infinity>)\n\\<and> (\\<forall>u. Q u \\<noteq> \\<infinity> \\<longrightarrow> \\<pi> u \\<noteq> None)\n\\<and> (\\<forall>u v. \\<pi> u = Some v \\<longrightarrow> v\\<in>S \\<and> (u,v)\\<in>edges rg)\n\\<and> (\\<forall>u v d. Q u = enat d \\<and> \\<pi> u = Some v \n      \\<longrightarrow> d=w {u,v} \\<and> (\\<forall>v'\\<in>S. (u,v')\\<in>edges rg \\<longrightarrow> d \\<le> w {u,v'}))  \n\""], ["", "lemma prim_invar2_ctd_alt_aux1: \n  assumes \"prim_invar1 (A Q \\<pi>)\"\n  assumes \"Q u \\<noteq> \\<infinity>\" \"u\\<noteq>r\"  \n  shows \"u\\<notin>S (A Q \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> S (A Q \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> S (A Q \\<pi>)", "interpret Prim_Invar1_loc w g r \"A Q \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prim_Invar1_loc w g r (A Q \\<pi>)", "by unfold_locales fact"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> S (A Q \\<pi>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> S (A Q \\<pi>)", "unfolding S_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> {r} \\<union> fst ` A Q \\<pi>", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> {r} \\<union>\n               fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>}", "using assms"], ["proof (prove)\nusing this:\n  prim_invar1 (A Q \\<pi>)\n  Q u \\<noteq> \\<infinity>\n  u \\<noteq> r\n\ngoal (1 subgoal):\n 1. u \\<notin> {r} \\<union>\n               fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> S (A Q \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prim_invar2_ctd_alt: \"prim_invar2_ctd Q \\<pi> \\<longleftrightarrow> (\n  let A = A Q \\<pi>; S = S A; cE=edges rg \\<inter> (-S)\\<times>S in\n    prim_invar1 A\n  \\<and> \\<pi> r = None \\<and> Q r = \\<infinity>  \n  \\<and> (\\<forall>(u,v)\\<in>cE. Q u \\<noteq> \\<infinity>)\n  \\<and> (\\<forall>u v. \\<pi> u = Some v \\<longrightarrow> v\\<in>S \\<and> (u,v)\\<in>edges rg)\n  \\<and> (\\<forall>u d. Q u = enat d \n      \\<longrightarrow> (\\<exists>v. \\<pi> u = Some v \\<and> d=w {u,v} \\<and> (\\<forall>v'. (u,v')\\<in>cE \\<longrightarrow> d \\<le> w {u,v'})))\n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2_ctd Q \\<pi> =\n    (let A = A Q \\<pi>; S = S A; cE = edges rg \\<inter> (- S) \\<times> S\n     in prim_invar1 A \\<and>\n        \\<pi> r = None \\<and>\n        Q r = \\<infinity> \\<and>\n        (\\<forall>(u, v)\\<in>cE. Q u \\<noteq> \\<infinity>) \\<and>\n        (\\<forall>u v.\n            \\<pi> u = Some v \\<longrightarrow>\n            v \\<in> S \\<and> (u, v) \\<in> edges rg) \\<and>\n        (\\<forall>u d.\n            Q u = enat d \\<longrightarrow>\n            (\\<exists>v.\n                \\<pi> u = Some v \\<and>\n                d = w {u, v} \\<and>\n                (\\<forall>v'.\n                    (u, v') \\<in> cE \\<longrightarrow> d \\<le> w {u, v'}))))", "unfolding prim_invar2_ctd_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (prim_invar1 (A Q \\<pi>) \\<and>\n     \\<pi> r = None \\<and>\n     Q r = \\<infinity> \\<and>\n     (\\<forall>(u, v)\n               \\<in>edges rg \\<inter>\n                    (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n         Q u \\<noteq> \\<infinity>) \\<and>\n     (\\<forall>u.\n         Q u \\<noteq> \\<infinity> \\<longrightarrow>\n         \\<pi> u \\<noteq> None) \\<and>\n     (\\<forall>u v.\n         \\<pi> u = Some v \\<longrightarrow>\n         v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg) \\<and>\n     (\\<forall>u v d.\n         Q u = enat d \\<and> \\<pi> u = Some v \\<longrightarrow>\n         d = w {u, v} \\<and>\n         (\\<forall>v'\\<in>S (A Q \\<pi>).\n             (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'}))) =\n    (prim_invar1 (A Q \\<pi>) \\<and>\n     \\<pi> r = None \\<and>\n     Q r = \\<infinity> \\<and>\n     (\\<forall>(u, v)\n               \\<in>edges rg \\<inter>\n                    (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n         Q u \\<noteq> \\<infinity>) \\<and>\n     (\\<forall>u v.\n         \\<pi> u = Some v \\<longrightarrow>\n         v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg) \\<and>\n     (\\<forall>u d.\n         Q u = enat d \\<longrightarrow>\n         (\\<exists>v.\n             \\<pi> u = Some v \\<and>\n             d = w {u, v} \\<and>\n             (\\<forall>v'.\n                 (u, v')\n                 \\<in> edges rg \\<inter>\n                       (- S (A Q \\<pi>)) \\<times>\n                       S (A Q \\<pi>) \\<longrightarrow>\n                 d \\<le> w {u, v'}))))", "using prim_invar2_ctd_alt_aux1[of Q \\<pi>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>prim_invar1 (A Q \\<pi>); Q ?u \\<noteq> \\<infinity>;\n   ?u \\<noteq> r\\<rbrakk>\n  \\<Longrightarrow> ?u \\<notin> S (A Q \\<pi>)\n\ngoal (1 subgoal):\n 1. (prim_invar1 (A Q \\<pi>) \\<and>\n     \\<pi> r = None \\<and>\n     Q r = \\<infinity> \\<and>\n     (\\<forall>(u, v)\n               \\<in>edges rg \\<inter>\n                    (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n         Q u \\<noteq> \\<infinity>) \\<and>\n     (\\<forall>u.\n         Q u \\<noteq> \\<infinity> \\<longrightarrow>\n         \\<pi> u \\<noteq> None) \\<and>\n     (\\<forall>u v.\n         \\<pi> u = Some v \\<longrightarrow>\n         v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg) \\<and>\n     (\\<forall>u v d.\n         Q u = enat d \\<and> \\<pi> u = Some v \\<longrightarrow>\n         d = w {u, v} \\<and>\n         (\\<forall>v'\\<in>S (A Q \\<pi>).\n             (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'}))) =\n    (prim_invar1 (A Q \\<pi>) \\<and>\n     \\<pi> r = None \\<and>\n     Q r = \\<infinity> \\<and>\n     (\\<forall>(u, v)\n               \\<in>edges rg \\<inter>\n                    (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n         Q u \\<noteq> \\<infinity>) \\<and>\n     (\\<forall>u v.\n         \\<pi> u = Some v \\<longrightarrow>\n         v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg) \\<and>\n     (\\<forall>u d.\n         Q u = enat d \\<longrightarrow>\n         (\\<exists>v.\n             \\<pi> u = Some v \\<and>\n             d = w {u, v} \\<and>\n             (\\<forall>v'.\n                 (u, v')\n                 \\<in> edges rg \\<inter>\n                       (- S (A Q \\<pi>)) \\<times>\n                       S (A Q \\<pi>) \\<longrightarrow>\n                 d \\<le> w {u, v'}))))", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u d.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>prim_invar1 (A Q \\<pi>);\n                    Q u \\<noteq> \\<infinity>; u \\<noteq> r\\<rbrakk>\n                   \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n        prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n        \\<forall>(u, v)\n                 \\<in>edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n           Q u \\<noteq> \\<infinity>;\n        \\<forall>u.\n           Q u \\<noteq> \\<infinity> \\<longrightarrow> \\<pi> u \\<noteq> None;\n        \\<forall>u v.\n           \\<pi> u = Some v \\<longrightarrow>\n           v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n        \\<forall>u v d.\n           Q u = enat d \\<and> \\<pi> u = Some v \\<longrightarrow>\n           d = w {u, v} \\<and>\n           (\\<forall>v'\\<in>S (A Q \\<pi>).\n               (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'});\n        Q u = enat d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<pi> u = Some v \\<and>\n                            d = w {u, v} \\<and>\n                            (\\<forall>v'.\n                                (u, v')\n                                \\<in> edges rg \\<inter>\n(- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>) \\<longrightarrow>\n                                d \\<le> w {u, v'})\n 2. \\<And>u i.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>prim_invar1 (A Q \\<pi>);\n                    Q u \\<noteq> \\<infinity>; u \\<noteq> r\\<rbrakk>\n                   \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n        prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n        \\<forall>(u, v)\n                 \\<in>edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n           Q u \\<noteq> \\<infinity>;\n        \\<forall>u v.\n           \\<pi> u = Some v \\<longrightarrow>\n           v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n        \\<forall>u d.\n           Q u = enat d \\<longrightarrow>\n           (\\<exists>v.\n               \\<pi> u = Some v \\<and>\n               d = w {u, v} \\<and>\n               (\\<forall>v'.\n                   (u, v')\n                   \\<in> edges rg \\<inter>\n                         (- S (A Q \\<pi>)) \\<times>\n                         S (A Q \\<pi>) \\<longrightarrow>\n                   d \\<le> w {u, v'}));\n        Q u = enat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. \\<pi> u = Some y\n 3. \\<And>u v d.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>prim_invar1 (A Q \\<pi>);\n                    Q u \\<noteq> \\<infinity>; u \\<noteq> r\\<rbrakk>\n                   \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n        prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n        \\<forall>(u, v)\n                 \\<in>edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n           Q u \\<noteq> \\<infinity>;\n        \\<forall>u v.\n           \\<pi> u = Some v \\<longrightarrow>\n           v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n        \\<forall>u d.\n           Q u = enat d \\<longrightarrow>\n           (\\<exists>v.\n               \\<pi> u = Some v \\<and>\n               d = w {u, v} \\<and>\n               (\\<forall>v'.\n                   (u, v')\n                   \\<in> edges rg \\<inter>\n                         (- S (A Q \\<pi>)) \\<times>\n                         S (A Q \\<pi>) \\<longrightarrow>\n                   d \\<le> w {u, v'}));\n        Q u = enat d; \\<pi> u = Some v\\<rbrakk>\n       \\<Longrightarrow> d = w {u, v}\n 4. \\<And>u v d v'.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>prim_invar1 (A Q \\<pi>);\n                    Q u \\<noteq> \\<infinity>; u \\<noteq> r\\<rbrakk>\n                   \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n        prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n        \\<forall>(u, v)\n                 \\<in>edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n           Q u \\<noteq> \\<infinity>;\n        \\<forall>u v.\n           \\<pi> u = Some v \\<longrightarrow>\n           v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n        \\<forall>u d.\n           Q u = enat d \\<longrightarrow>\n           (\\<exists>v.\n               \\<pi> u = Some v \\<and>\n               d = w {u, v} \\<and>\n               (\\<forall>v'.\n                   (u, v')\n                   \\<in> edges rg \\<inter>\n                         (- S (A Q \\<pi>)) \\<times>\n                         S (A Q \\<pi>) \\<longrightarrow>\n                   d \\<le> w {u, v'}));\n        Q u = enat d; \\<pi> u = Some v; v' \\<in> S (A Q \\<pi>);\n        (u, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {u, v'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u.\n                \\<lbrakk>prim_invar1 (A Q \\<pi>); Q u \\<noteq> \\<infinity>;\n                 u \\<noteq> r\\<rbrakk>\n                \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n     prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n     \\<forall>(u, v)\n              \\<in>edges rg \\<inter>\n                   (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n        Q u \\<noteq> \\<infinity>;\n     \\<forall>u.\n        Q u \\<noteq> \\<infinity> \\<longrightarrow> \\<pi> u \\<noteq> None;\n     \\<forall>u v.\n        \\<pi> u = Some v \\<longrightarrow>\n        v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n     \\<forall>u v d.\n        Q u = enat d \\<and> \\<pi> u = Some v \\<longrightarrow>\n        d = w {u, v} \\<and>\n        (\\<forall>v'\\<in>S (A Q \\<pi>).\n            (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'});\n     Q u_ = enat d_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v.\n                         \\<pi> u_ = Some v \\<and>\n                         d_ = w {u_, v} \\<and>\n                         (\\<forall>v'.\n                             (u_, v')\n                             \\<in> edges rg \\<inter>\n                                   (- S (A Q \\<pi>)) \\<times>\n                                   S (A Q \\<pi>) \\<longrightarrow>\n                             d_ \\<le> w {u_, v'})", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u i.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>prim_invar1 (A Q \\<pi>);\n                    Q u \\<noteq> \\<infinity>; u \\<noteq> r\\<rbrakk>\n                   \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n        prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n        \\<forall>(u, v)\n                 \\<in>edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n           Q u \\<noteq> \\<infinity>;\n        \\<forall>u v.\n           \\<pi> u = Some v \\<longrightarrow>\n           v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n        \\<forall>u d.\n           Q u = enat d \\<longrightarrow>\n           (\\<exists>v.\n               \\<pi> u = Some v \\<and>\n               d = w {u, v} \\<and>\n               (\\<forall>v'.\n                   (u, v')\n                   \\<in> edges rg \\<inter>\n                         (- S (A Q \\<pi>)) \\<times>\n                         S (A Q \\<pi>) \\<longrightarrow>\n                   d \\<le> w {u, v'}));\n        Q u = enat i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. \\<pi> u = Some y\n 2. \\<And>u v d.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>prim_invar1 (A Q \\<pi>);\n                    Q u \\<noteq> \\<infinity>; u \\<noteq> r\\<rbrakk>\n                   \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n        prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n        \\<forall>(u, v)\n                 \\<in>edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n           Q u \\<noteq> \\<infinity>;\n        \\<forall>u v.\n           \\<pi> u = Some v \\<longrightarrow>\n           v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n        \\<forall>u d.\n           Q u = enat d \\<longrightarrow>\n           (\\<exists>v.\n               \\<pi> u = Some v \\<and>\n               d = w {u, v} \\<and>\n               (\\<forall>v'.\n                   (u, v')\n                   \\<in> edges rg \\<inter>\n                         (- S (A Q \\<pi>)) \\<times>\n                         S (A Q \\<pi>) \\<longrightarrow>\n                   d \\<le> w {u, v'}));\n        Q u = enat d; \\<pi> u = Some v\\<rbrakk>\n       \\<Longrightarrow> d = w {u, v}\n 3. \\<And>u v d v'.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>prim_invar1 (A Q \\<pi>);\n                    Q u \\<noteq> \\<infinity>; u \\<noteq> r\\<rbrakk>\n                   \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n        prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n        \\<forall>(u, v)\n                 \\<in>edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n           Q u \\<noteq> \\<infinity>;\n        \\<forall>u v.\n           \\<pi> u = Some v \\<longrightarrow>\n           v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n        \\<forall>u d.\n           Q u = enat d \\<longrightarrow>\n           (\\<exists>v.\n               \\<pi> u = Some v \\<and>\n               d = w {u, v} \\<and>\n               (\\<forall>v'.\n                   (u, v')\n                   \\<in> edges rg \\<inter>\n                         (- S (A Q \\<pi>)) \\<times>\n                         S (A Q \\<pi>) \\<longrightarrow>\n                   d \\<le> w {u, v'}));\n        Q u = enat d; \\<pi> u = Some v; v' \\<in> S (A Q \\<pi>);\n        (u, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {u, v'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u.\n                \\<lbrakk>prim_invar1 (A Q \\<pi>); Q u \\<noteq> \\<infinity>;\n                 u \\<noteq> r\\<rbrakk>\n                \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n     prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n     \\<forall>(u, v)\n              \\<in>edges rg \\<inter>\n                   (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n        Q u \\<noteq> \\<infinity>;\n     \\<forall>u v.\n        \\<pi> u = Some v \\<longrightarrow>\n        v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n     \\<forall>u d.\n        Q u = enat d \\<longrightarrow>\n        (\\<exists>v.\n            \\<pi> u = Some v \\<and>\n            d = w {u, v} \\<and>\n            (\\<forall>v'.\n                (u, v')\n                \\<in> edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times>\n                      S (A Q \\<pi>) \\<longrightarrow>\n                d \\<le> w {u, v'}));\n     Q u_ = enat i_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. \\<pi> u_ = Some y", "by (auto 0 3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v d.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>prim_invar1 (A Q \\<pi>);\n                    Q u \\<noteq> \\<infinity>; u \\<noteq> r\\<rbrakk>\n                   \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n        prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n        \\<forall>(u, v)\n                 \\<in>edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n           Q u \\<noteq> \\<infinity>;\n        \\<forall>u v.\n           \\<pi> u = Some v \\<longrightarrow>\n           v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n        \\<forall>u d.\n           Q u = enat d \\<longrightarrow>\n           (\\<exists>v.\n               \\<pi> u = Some v \\<and>\n               d = w {u, v} \\<and>\n               (\\<forall>v'.\n                   (u, v')\n                   \\<in> edges rg \\<inter>\n                         (- S (A Q \\<pi>)) \\<times>\n                         S (A Q \\<pi>) \\<longrightarrow>\n                   d \\<le> w {u, v'}));\n        Q u = enat d; \\<pi> u = Some v\\<rbrakk>\n       \\<Longrightarrow> d = w {u, v}\n 2. \\<And>u v d v'.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>prim_invar1 (A Q \\<pi>);\n                    Q u \\<noteq> \\<infinity>; u \\<noteq> r\\<rbrakk>\n                   \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n        prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n        \\<forall>(u, v)\n                 \\<in>edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n           Q u \\<noteq> \\<infinity>;\n        \\<forall>u v.\n           \\<pi> u = Some v \\<longrightarrow>\n           v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n        \\<forall>u d.\n           Q u = enat d \\<longrightarrow>\n           (\\<exists>v.\n               \\<pi> u = Some v \\<and>\n               d = w {u, v} \\<and>\n               (\\<forall>v'.\n                   (u, v')\n                   \\<in> edges rg \\<inter>\n                         (- S (A Q \\<pi>)) \\<times>\n                         S (A Q \\<pi>) \\<longrightarrow>\n                   d \\<le> w {u, v'}));\n        Q u = enat d; \\<pi> u = Some v; v' \\<in> S (A Q \\<pi>);\n        (u, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {u, v'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u.\n                \\<lbrakk>prim_invar1 (A Q \\<pi>); Q u \\<noteq> \\<infinity>;\n                 u \\<noteq> r\\<rbrakk>\n                \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n     prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n     \\<forall>(u, v)\n              \\<in>edges rg \\<inter>\n                   (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n        Q u \\<noteq> \\<infinity>;\n     \\<forall>u v.\n        \\<pi> u = Some v \\<longrightarrow>\n        v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n     \\<forall>u d.\n        Q u = enat d \\<longrightarrow>\n        (\\<exists>v.\n            \\<pi> u = Some v \\<and>\n            d = w {u, v} \\<and>\n            (\\<forall>v'.\n                (u, v')\n                \\<in> edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times>\n                      S (A Q \\<pi>) \\<longrightarrow>\n                d \\<le> w {u, v'}));\n     Q u_ = enat d_; \\<pi> u_ = Some v_\\<rbrakk>\n    \\<Longrightarrow> d_ = w {u_, v_}", "by (auto 0 3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v d v'.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>prim_invar1 (A Q \\<pi>);\n                    Q u \\<noteq> \\<infinity>; u \\<noteq> r\\<rbrakk>\n                   \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n        prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n        \\<forall>(u, v)\n                 \\<in>edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n           Q u \\<noteq> \\<infinity>;\n        \\<forall>u v.\n           \\<pi> u = Some v \\<longrightarrow>\n           v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n        \\<forall>u d.\n           Q u = enat d \\<longrightarrow>\n           (\\<exists>v.\n               \\<pi> u = Some v \\<and>\n               d = w {u, v} \\<and>\n               (\\<forall>v'.\n                   (u, v')\n                   \\<in> edges rg \\<inter>\n                         (- S (A Q \\<pi>)) \\<times>\n                         S (A Q \\<pi>) \\<longrightarrow>\n                   d \\<le> w {u, v'}));\n        Q u = enat d; \\<pi> u = Some v; v' \\<in> S (A Q \\<pi>);\n        (u, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {u, v'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u.\n                \\<lbrakk>prim_invar1 (A Q \\<pi>); Q u \\<noteq> \\<infinity>;\n                 u \\<noteq> r\\<rbrakk>\n                \\<Longrightarrow> u \\<notin> S (A Q \\<pi>);\n     prim_invar1 (A Q \\<pi>); \\<pi> r = None; Q r = \\<infinity>;\n     \\<forall>(u, v)\n              \\<in>edges rg \\<inter>\n                   (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n        Q u \\<noteq> \\<infinity>;\n     \\<forall>u v.\n        \\<pi> u = Some v \\<longrightarrow>\n        v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg;\n     \\<forall>u d.\n        Q u = enat d \\<longrightarrow>\n        (\\<exists>v.\n            \\<pi> u = Some v \\<and>\n            d = w {u, v} \\<and>\n            (\\<forall>v'.\n                (u, v')\n                \\<in> edges rg \\<inter>\n                      (- S (A Q \\<pi>)) \\<times>\n                      S (A Q \\<pi>) \\<longrightarrow>\n                d \\<le> w {u, v'}));\n     Q u_ = enat d_; \\<pi> u_ = Some v_; v'_ \\<in> S (A Q \\<pi>);\n     (u_, v'_) \\<in> edges rg\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {u_, v'_}", "by clarsimp (metis (no_types,lifting) option.simps(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"prim_invar2 Q \\<pi> \\<equiv> prim_invar2_init Q \\<pi> \\<or> prim_invar2_ctd Q \\<pi>\""], ["", "definition \"T_measure2 Q \\<pi> \n  \\<equiv> if Q r = \\<infinity> then T_measure1 (A Q \\<pi>) else card (nodes rg)\""], ["", "lemma Q'_init_eq: \n  \"Q' initQ init\\<pi> r = (\\<lambda>u. if (u,r)\\<in>edges rg then enat (w {u,r}) else \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q' initQ init\\<pi> r =\n    (\\<lambda>u.\n        if (u, r) \\<in> edges rg then enat (w {u, r}) else \\<infinity>)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       Q' initQ init\\<pi> r u =\n       (if (u, r) \\<in> edges rg then enat (w {u, r}) else \\<infinity>)", "using reachable_edges_subset"], ["proof (prove)\nusing this:\n  edges rg \\<subseteq> edges g\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       Q' initQ init\\<pi> r u =\n       (if (u, r) \\<in> edges rg then enat (w {u, r}) else \\<infinity>)", "apply (simp add: Q'_def Qinter_def upd_cond_def initQ_def init\\<pi>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       edges rg \\<subseteq> edges g \\<Longrightarrow>\n       ((u, r) \\<in> edges g \\<longrightarrow> (u, r) \\<in> edges rg) \\<and>\n       ((u, r) \\<notin> edges g \\<longrightarrow>\n        u \\<noteq> r \\<longrightarrow> (u, r) \\<notin> edges rg)", "by (auto simp: Prim.rg_def edges_sym' reachable_nodes_step'(2))"], ["", "lemma \\<pi>'_init_eq: \n  \"\\<pi>' initQ init\\<pi> r = (\\<lambda>u. if (u,r)\\<in>edges rg then Some r else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>' initQ init\\<pi> r =\n    (\\<lambda>u. if (u, r) \\<in> edges rg then Some r else None)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<pi>' initQ init\\<pi> r u =\n       (if (u, r) \\<in> edges rg then Some r else None)", "using reachable_edges_subset"], ["proof (prove)\nusing this:\n  edges rg \\<subseteq> edges g\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<pi>' initQ init\\<pi> r u =\n       (if (u, r) \\<in> edges rg then Some r else None)", "apply (simp add: \\<pi>'_def upd_cond_def initQ_def init\\<pi>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       edges rg \\<subseteq> edges g \\<Longrightarrow>\n       u \\<noteq> r \\<longrightarrow>\n       ((u, r) \\<in> edges g \\<longrightarrow> (u, r) \\<in> edges rg) \\<and>\n       ((u, r) \\<notin> edges g \\<longrightarrow> (u, r) \\<notin> edges rg)", "by (auto simp: Prim.rg_def edges_sym' reachable_nodes_step'(2))"], ["", "lemma A_init_eq: \"A initQ init\\<pi> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A initQ init\\<pi> = {}", "unfolding A_def init\\<pi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v). None = Some v \\<and> initQ u = \\<infinity>} = {}", "by auto"], ["", "lemma S_empty: \"S {} = {r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S {} = {r}", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {r} \\<union> fst ` {} \\<union> snd ` {} = {r}", "by (auto simp: A_init_eq)"], ["", "lemma maintain_invar2_first_step: \n  assumes INV: \"prim_invar2_init Q \\<pi>\"\n  assumes UNS: \"Q u = enat d\"\n  shows \"prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\" (is ?G1)\n    and \"T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) &&&\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "from INV"], ["proof (chain)\npicking this:\n  prim_invar2_init Q \\<pi>", "have [simp]: \"Q=initQ\" \"\\<pi>=init\\<pi>\""], ["proof (prove)\nusing this:\n  prim_invar2_init Q \\<pi>\n\ngoal (1 subgoal):\n 1. Q = initQ &&& \\<pi> = init\\<pi>", "unfolding prim_invar2_init_def"], ["proof (prove)\nusing this:\n  Q = initQ \\<and> \\<pi> = init\\<pi>\n\ngoal (1 subgoal):\n 1. Q = initQ &&& \\<pi> = init\\<pi>", "by auto"], ["proof (state)\nthis:\n  Q = initQ\n  \\<pi> = init\\<pi>\n\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "from UNS"], ["proof (chain)\npicking this:\n  Q u = enat d", "have [simp]: \"u=r\""], ["proof (prove)\nusing this:\n  Q u = enat d\n\ngoal (1 subgoal):\n 1. u = r", "by (auto simp: initQ_def split: if_splits)"], ["proof (state)\nthis:\n  u = r\n\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "note Q'_init_eq \\<pi>'_init_eq A_init_eq"], ["proof (state)\nthis:\n  Q' initQ init\\<pi> r =\n  (\\<lambda>u.\n      if (u, r) \\<in> edges rg then enat (w {u, r}) else \\<infinity>)\n  \\<pi>' initQ init\\<pi> r =\n  (\\<lambda>u. if (u, r) \\<in> edges rg then Some r else None)\n  A initQ init\\<pi> = {}\n\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "have [simp]: \"(A (Q' initQ init\\<pi> r) (\\<pi>' initQ init\\<pi> r)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (Q' initQ init\\<pi> r) (\\<pi>' initQ init\\<pi> r) = {}", "apply (simp add: Q'_init_eq \\<pi>'_init_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A (\\<lambda>u.\n          if (u, r) \\<in> edges rg then enat (w {u, r}) else \\<infinity>)\n     (\\<lambda>u. if (u, r) \\<in> edges rg then Some r else None) =\n    {}", "by (auto simp: A_def split: if_splits)"], ["proof (state)\nthis:\n  A (Q' initQ init\\<pi> r) (\\<pi>' initQ init\\<pi> r) = {}\n\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "show ?G1"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)", "apply (simp add: prim_invar2_ctd_def Let_def invar1_initial)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>' initQ init\\<pi> r r = None \\<and>\n    Q' initQ init\\<pi> r r = \\<infinity> \\<and>\n    (\\<forall>(u, v)\\<in>edges rg \\<inter> (- S {}) \\<times> S {}.\n        \\<exists>i. Q' initQ init\\<pi> r u = enat i) \\<and>\n    (\\<forall>u.\n        (\\<exists>i. Q' initQ init\\<pi> r u = enat i) \\<longrightarrow>\n        (\\<exists>y. \\<pi>' initQ init\\<pi> r u = Some y)) \\<and>\n    (\\<forall>u v.\n        \\<pi>' initQ init\\<pi> r u = Some v \\<longrightarrow>\n        v \\<in> S {} \\<and> (u, v) \\<in> edges rg) \\<and>\n    (\\<forall>u v d.\n        Q' initQ init\\<pi> r u = enat d \\<and>\n        \\<pi>' initQ init\\<pi> r u = Some v \\<longrightarrow>\n        d = w {u, v} \\<and>\n        (\\<forall>v'\\<in>S {}.\n            (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'}))", "by (auto simp: Q'_init_eq \\<pi>'_init_eq S_empty split: if_splits)"], ["proof (state)\nthis:\n  prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n\ngoal (1 subgoal):\n 1. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "have [simp]: \"Q' initQ init\\<pi> r r = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q' initQ init\\<pi> r r = \\<infinity>", "by (auto simp: Q'_init_eq)"], ["proof (state)\nthis:\n  Q' initQ init\\<pi> r r = \\<infinity>\n\ngoal (1 subgoal):\n 1. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "have [simp]: \"initQ r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initQ r = 0", "by (simp add: initQ_def)"], ["proof (state)\nthis:\n  initQ r = 0\n\ngoal (1 subgoal):\n 1. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "show ?G2"], ["proof (prove)\ngoal (1 subgoal):\n 1. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "unfolding T_measure2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Q' Q \\<pi> u r = \\<infinity>\n     then T_measure1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n     else card (nodes rg))\n    < (if Q r = \\<infinity> then T_measure1 (A Q \\<pi>)\n       else card (nodes rg))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. T_measure1 {} < card (nodes rg)", "apply (simp add: T_measure1_def S_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (nodes rg - {r}) < card (nodes rg)", "by (metis card_Diff1_less nodes_finite nodes_of_component \n          reachable_nodes_refl rg_def)"], ["proof (state)\nthis:\n  T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maintain_invar2_first_step_presentation: \n  assumes INV: \"prim_invar2_init Q \\<pi>\"\n  assumes UNS: \"Q u = enat d\"\n  shows \"prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n       \\<and> T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) \\<and>\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "using maintain_invar2_first_step assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>prim_invar2_init ?Q ?\\<pi>; ?Q ?u = enat ?d\\<rbrakk>\n  \\<Longrightarrow> prim_invar2_ctd (Q' ?Q ?\\<pi> ?u) (\\<pi>' ?Q ?\\<pi> ?u)\n  \\<lbrakk>prim_invar2_init ?Q ?\\<pi>; ?Q ?u = enat ?d\\<rbrakk>\n  \\<Longrightarrow> T_measure2 (Q' ?Q ?\\<pi> ?u) (\\<pi>' ?Q ?\\<pi> ?u)\n                    < T_measure2 ?Q ?\\<pi>\n  prim_invar2_init Q \\<pi>\n  Q u = enat d\n\ngoal (1 subgoal):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) \\<and>\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "by blast"], ["", "end"], ["", "(*<*)\n(*\n  This locale is only used to present the invariant in the paper.\n*)"], ["", "locale Prim_Invar2_ctd_Presentation_Loc =\n  fixes w g and r :: 'v and Q \\<pi> A S rg cE\n  assumes I: \"Prim2.prim_invar2_ctd w g r Q \\<pi>\"\n  defines local_A_def: \"A \\<equiv> Prim2.A Q \\<pi>\"\n  defines local_S_def: \"S \\<equiv> Prim.S r A\"\n  defines local_rg_def: \"rg \\<equiv> Prim.rg g r\"\n  defines local_cE_def: \"cE \\<equiv> edges rg \\<inter> (-S)\\<times>S\"\nbegin"], ["", "lemma \n      invar1: \"Prim.prim_invar1 w g r A\" (is ?G1)\n  and root_contained: \"\\<pi> r = None \\<and> Q r = \\<infinity>\" (is ?G2)\n  and Q_defined: \"\\<forall>(u,v)\\<in>cE. Q u \\<noteq> \\<infinity>\" (is ?G3)\n  and \\<pi>_edges: \"\\<forall>u v. \\<pi> u = Some v \\<longrightarrow> v\\<in>S \\<and> (u,v)\\<in>edges rg\" (is ?G4)\n  and Q_min: \"\\<forall>u d. Q u = enat d \n      \\<longrightarrow> (\\<exists>v. \\<pi> u = Some v \\<and> d=w {u,v} \\<and> (\\<forall>v'. (u,v')\\<in>cE \\<longrightarrow> d \\<le> w {u,v'}))\" \n      (is ?G5)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Prim.prim_invar1 w g r A &&&\n     \\<pi> r = None \\<and> Q r = \\<infinity>) &&&\n    \\<forall>(u, v)\\<in>cE. Q u \\<noteq> \\<infinity> &&&\n    \\<forall>u v.\n       \\<pi> u = Some v \\<longrightarrow>\n       v \\<in> S \\<and> (u, v) \\<in> edges rg &&&\n    \\<forall>u d.\n       Q u = enat d \\<longrightarrow>\n       (\\<exists>v.\n           \\<pi> u = Some v \\<and>\n           d = w {u, v} \\<and>\n           (\\<forall>v'.\n               (u, v') \\<in> cE \\<longrightarrow> d \\<le> w {u, v'}))", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. Prim.prim_invar1 w g r A\n 2. \\<pi> r = None \\<and> Q r = \\<infinity>\n 3. \\<forall>(u, v)\\<in>cE. Q u \\<noteq> \\<infinity>\n 4. \\<forall>u v.\n       \\<pi> u = Some v \\<longrightarrow>\n       v \\<in> S \\<and> (u, v) \\<in> edges rg\n 5. \\<forall>u d.\n       Q u = enat d \\<longrightarrow>\n       (\\<exists>v.\n           \\<pi> u = Some v \\<and>\n           d = w {u, v} \\<and>\n           (\\<forall>v'.\n               (u, v') \\<in> cE \\<longrightarrow> d \\<le> w {u, v'}))", "interpret Prim2 w g r"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (5 subgoals):\n 1. prim_invar1 A\n 2. \\<pi> r = None \\<and> Q r = \\<infinity>\n 3. \\<forall>(u, v)\\<in>cE. Q u \\<noteq> \\<infinity>\n 4. \\<forall>u v.\n       \\<pi> u = Some v \\<longrightarrow>\n       v \\<in> S \\<and> (u, v) \\<in> edges rg\n 5. \\<forall>u d.\n       Q u = enat d \\<longrightarrow>\n       (\\<exists>v.\n           \\<pi> u = Some v \\<and>\n           d = w {u, v} \\<and>\n           (\\<forall>v'.\n               (u, v') \\<in> cE \\<longrightarrow> d \\<le> w {u, v'}))", "show ?G1 ?G2 ?G3 ?G4 ?G5"], ["proof (prove)\ngoal (1 subgoal):\n 1. (prim_invar1 A &&& \\<pi> r = None \\<and> Q r = \\<infinity>) &&&\n    \\<forall>(u, v)\\<in>cE. Q u \\<noteq> \\<infinity> &&&\n    \\<forall>u v.\n       \\<pi> u = Some v \\<longrightarrow>\n       v \\<in> S \\<and> (u, v) \\<in> edges rg &&&\n    \\<forall>u d.\n       Q u = enat d \\<longrightarrow>\n       (\\<exists>v.\n           \\<pi> u = Some v \\<and>\n           d = w {u, v} \\<and>\n           (\\<forall>v'.\n               (u, v') \\<in> cE \\<longrightarrow> d \\<le> w {u, v'}))", "using I"], ["proof (prove)\nusing this:\n  prim_invar2_ctd Q \\<pi>\n\ngoal (1 subgoal):\n 1. (prim_invar1 A &&& \\<pi> r = None \\<and> Q r = \\<infinity>) &&&\n    \\<forall>(u, v)\\<in>cE. Q u \\<noteq> \\<infinity> &&&\n    \\<forall>u v.\n       \\<pi> u = Some v \\<longrightarrow>\n       v \\<in> S \\<and> (u, v) \\<in> edges rg &&&\n    \\<forall>u d.\n       Q u = enat d \\<longrightarrow>\n       (\\<exists>v.\n           \\<pi> u = Some v \\<and>\n           d = w {u, v} \\<and>\n           (\\<forall>v'.\n               (u, v') \\<in> cE \\<longrightarrow> d \\<le> w {u, v'}))", "unfolding local_A_def local_S_def local_rg_def local_cE_def \n              prim_invar2_ctd_alt Let_def"], ["proof (prove)\nusing this:\n  prim_invar1 (A Q \\<pi>) \\<and>\n  \\<pi> r = None \\<and>\n  Q r = \\<infinity> \\<and>\n  (\\<forall>(u, v)\n            \\<in>edges rg \\<inter> (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n      Q u \\<noteq> \\<infinity>) \\<and>\n  (\\<forall>u v.\n      \\<pi> u = Some v \\<longrightarrow>\n      v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg) \\<and>\n  (\\<forall>u d.\n      Q u = enat d \\<longrightarrow>\n      (\\<exists>v.\n          \\<pi> u = Some v \\<and>\n          d = w {u, v} \\<and>\n          (\\<forall>v'.\n              (u, v')\n              \\<in> edges rg \\<inter>\n                    (- S (A Q \\<pi>)) \\<times>\n                    S (A Q \\<pi>) \\<longrightarrow>\n              d \\<le> w {u, v'})))\n\ngoal (1 subgoal):\n 1. (prim_invar1 (A Q \\<pi>) &&&\n     \\<pi> r = None \\<and> Q r = \\<infinity>) &&&\n    \\<forall>(u, v)\n             \\<in>edges rg \\<inter>\n                  (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n       Q u \\<noteq> \\<infinity> &&&\n    \\<forall>u v.\n       \\<pi> u = Some v \\<longrightarrow>\n       v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg &&&\n    \\<forall>u d.\n       Q u = enat d \\<longrightarrow>\n       (\\<exists>v.\n           \\<pi> u = Some v \\<and>\n           d = w {u, v} \\<and>\n           (\\<forall>v'.\n               (u, v')\n               \\<in> edges rg \\<inter>\n                     (- S (A Q \\<pi>)) \\<times>\n                     S (A Q \\<pi>) \\<longrightarrow>\n               d \\<le> w {u, v'}))", "by simp_all"], ["proof (state)\nthis:\n  prim_invar1 A\n  \\<pi> r = None \\<and> Q r = \\<infinity>\n  \\<forall>(u, v)\\<in>cE. Q u \\<noteq> \\<infinity>\n  \\<forall>u v.\n     \\<pi> u = Some v \\<longrightarrow>\n     v \\<in> S \\<and> (u, v) \\<in> edges rg\n  \\<forall>u d.\n     Q u = enat d \\<longrightarrow>\n     (\\<exists>v.\n         \\<pi> u = Some v \\<and>\n         d = w {u, v} \\<and>\n         (\\<forall>v'.\n             (u, v') \\<in> cE \\<longrightarrow> d \\<le> w {u, v'}))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma (in Prim2) Prim_Invar2_ctd_Presentation_Loc_eq:\n  \"Prim_Invar2_ctd_Presentation_Loc w g r Q \\<pi> \\<longleftrightarrow> prim_invar2_ctd Q \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prim_Invar2_ctd_Presentation_Loc w g r Q \\<pi> = prim_invar2_ctd Q \\<pi>", "unfolding Prim_Invar2_ctd_Presentation_Loc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2_ctd Q \\<pi> = prim_invar2_ctd Q \\<pi>", ".."], ["", "(*>*)"], ["", "text \\<open>Again, we define a locale to fix a state and assume the invariant\\<close>"], ["", "locale Prim_Invar2_ctd_loc =   \n  Prim2 w g r for w g and r :: 'v +\n  fixes Q \\<pi>\n  assumes invar2: \"prim_invar2_ctd Q \\<pi>\"\nbegin"], ["", "sublocale Prim_Invar1_loc w g r \"A Q \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prim_Invar1_loc w g r (A Q \\<pi>)", "using invar2"], ["proof (prove)\nusing this:\n  prim_invar2_ctd Q \\<pi>\n\ngoal (1 subgoal):\n 1. Prim_Invar1_loc w g r (A Q \\<pi>)", "unfolding prim_invar2_ctd_def"], ["proof (prove)\nusing this:\n  let A = A Q \\<pi>; S = S A\n  in prim_invar1 A \\<and>\n     \\<pi> r = None \\<and>\n     Q r = \\<infinity> \\<and>\n     (\\<forall>(u, v)\\<in>edges rg \\<inter> (- S) \\<times> S.\n         Q u \\<noteq> \\<infinity>) \\<and>\n     (\\<forall>u.\n         Q u \\<noteq> \\<infinity> \\<longrightarrow>\n         \\<pi> u \\<noteq> None) \\<and>\n     (\\<forall>u v.\n         \\<pi> u = Some v \\<longrightarrow>\n         v \\<in> S \\<and> (u, v) \\<in> edges rg) \\<and>\n     (\\<forall>u v d.\n         Q u = enat d \\<and> \\<pi> u = Some v \\<longrightarrow>\n         d = w {u, v} \\<and>\n         (\\<forall>v'\\<in>S.\n             (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'}))\n\ngoal (1 subgoal):\n 1. Prim_Invar1_loc w g r (A Q \\<pi>)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. let A = A Q \\<pi>; S = S A\n    in prim_invar1 A \\<and>\n       \\<pi> r = None \\<and>\n       Q r = \\<infinity> \\<and>\n       (\\<forall>(u, v)\\<in>edges rg \\<inter> (- S) \\<times> S.\n           Q u \\<noteq> \\<infinity>) \\<and>\n       (\\<forall>u.\n           Q u \\<noteq> \\<infinity> \\<longrightarrow>\n           \\<pi> u \\<noteq> None) \\<and>\n       (\\<forall>u v.\n           \\<pi> u = Some v \\<longrightarrow>\n           v \\<in> S \\<and> (u, v) \\<in> edges rg) \\<and>\n       (\\<forall>u v d.\n           Q u = enat d \\<and> \\<pi> u = Some v \\<longrightarrow>\n           d = w {u, v} \\<and>\n           (\\<forall>v'\\<in>S.\n               (u, v') \\<in> edges rg \\<longrightarrow>\n               d \\<le> w {u, v'})) \\<Longrightarrow>\n    prim_invar1 (A Q \\<pi>)", "by (auto simp: Let_def)"], ["", "lemma upd_cond_alt: \"upd_cond Q \\<pi> u v' \\<longleftrightarrow> \n  (v',u) \\<in> edges g \\<and> v'\\<notin>S (A Q \\<pi>) \\<and> enat (w {v',u}) < Q v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cond Q \\<pi> u v' =\n    ((v', u) \\<in> edges g \\<and>\n     v' \\<notin> S (A Q \\<pi>) \\<and> enat (w {v', u}) < Q v')", "unfolding upd_cond_def S_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v', u) \\<in> edges g \\<and>\n     v' \\<noteq> r \\<and>\n     (Q v' = \\<infinity> \\<longrightarrow> \\<pi> v' = None) \\<and>\n     enat (w {v', u}) < Q v') =\n    ((v', u) \\<in> edges g \\<and>\n     v' \\<notin> {r} \\<union> fst ` A Q \\<pi> \\<and>\n     enat (w {v', u}) < Q v')", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v', u) \\<in> edges g \\<and>\n     v' \\<noteq> r \\<and>\n     (Q v' = \\<infinity> \\<longrightarrow> \\<pi> v' = None) \\<and>\n     enat (w {v', u}) < Q v') =\n    ((v', u) \\<in> edges g \\<and>\n     v' \\<notin> {r} \\<union>\n                 fst `\n                 {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>} \\<and>\n     enat (w {v', u}) < Q v')", "by (auto simp: fst_eq_Domain)"], ["", "lemma \\<pi>_root: \"\\<pi> r = None\"\n  and Q_root: \"Q r = \\<infinity>\" \n  and Q_defined: \"\\<lbrakk> (u,v)\\<in>edges rg; u\\<notin>S (A Q \\<pi>); v\\<in>S (A Q \\<pi>) \\<rbrakk> \\<Longrightarrow> Q u \\<noteq> \\<infinity>\"\n  and \\<pi>_defined: \"\\<lbrakk> Q u \\<noteq> \\<infinity> \\<rbrakk> \\<Longrightarrow> \\<pi> u \\<noteq> None\"\n  and frontier: \"\\<pi> u = Some v \\<Longrightarrow> v\\<in>S (A Q \\<pi>)\"\n  and edges: \"\\<pi> u = Some v \\<Longrightarrow> (u,v)\\<in>edges rg\"\n  and Q_\\<pi>_consistent: \"\\<lbrakk> Q u = enat d; \\<pi> u = Some v \\<rbrakk> \\<Longrightarrow> d = w {u,v}\" \n  and Q_min: \"Q u = enat d \n      \\<Longrightarrow> (\\<forall>v'\\<in>S (A Q \\<pi>). (u,v')\\<in>edges rg \\<longrightarrow> d \\<le> w {u,v'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<pi> r = None &&& Q r = \\<infinity>) &&&\n     (\\<lbrakk>(u, v) \\<in> edges rg; u \\<notin> S (A Q \\<pi>);\n       v \\<in> S (A Q \\<pi>)\\<rbrakk>\n      \\<Longrightarrow> Q u \\<noteq> \\<infinity>) &&&\n     (Q u \\<noteq> \\<infinity> \\<Longrightarrow> \\<pi> u \\<noteq> None)) &&&\n    ((\\<pi> u = Some v \\<Longrightarrow> v \\<in> S (A Q \\<pi>)) &&&\n     (\\<pi> u = Some v \\<Longrightarrow> (u, v) \\<in> edges rg)) &&&\n    (\\<lbrakk>Q u = enat d; \\<pi> u = Some v\\<rbrakk>\n     \\<Longrightarrow> d = w {u, v}) &&&\n    (Q u = enat d \\<Longrightarrow>\n     \\<forall>v'\\<in>S (A Q \\<pi>).\n        (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'})", "using invar2"], ["proof (prove)\nusing this:\n  prim_invar2_ctd Q \\<pi>\n\ngoal (1 subgoal):\n 1. ((\\<pi> r = None &&& Q r = \\<infinity>) &&&\n     (\\<lbrakk>(u, v) \\<in> edges rg; u \\<notin> S (A Q \\<pi>);\n       v \\<in> S (A Q \\<pi>)\\<rbrakk>\n      \\<Longrightarrow> Q u \\<noteq> \\<infinity>) &&&\n     (Q u \\<noteq> \\<infinity> \\<Longrightarrow> \\<pi> u \\<noteq> None)) &&&\n    ((\\<pi> u = Some v \\<Longrightarrow> v \\<in> S (A Q \\<pi>)) &&&\n     (\\<pi> u = Some v \\<Longrightarrow> (u, v) \\<in> edges rg)) &&&\n    (\\<lbrakk>Q u = enat d; \\<pi> u = Some v\\<rbrakk>\n     \\<Longrightarrow> d = w {u, v}) &&&\n    (Q u = enat d \\<Longrightarrow>\n     \\<forall>v'\\<in>S (A Q \\<pi>).\n        (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'})", "unfolding prim_invar2_ctd_def Let_def"], ["proof (prove)\nusing this:\n  prim_invar1 (A Q \\<pi>) \\<and>\n  \\<pi> r = None \\<and>\n  Q r = \\<infinity> \\<and>\n  (\\<forall>(u, v)\n            \\<in>edges rg \\<inter> (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n      Q u \\<noteq> \\<infinity>) \\<and>\n  (\\<forall>u.\n      Q u \\<noteq> \\<infinity> \\<longrightarrow>\n      \\<pi> u \\<noteq> None) \\<and>\n  (\\<forall>u v.\n      \\<pi> u = Some v \\<longrightarrow>\n      v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg) \\<and>\n  (\\<forall>u v d.\n      Q u = enat d \\<and> \\<pi> u = Some v \\<longrightarrow>\n      d = w {u, v} \\<and>\n      (\\<forall>v'\\<in>S (A Q \\<pi>).\n          (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'}))\n\ngoal (1 subgoal):\n 1. ((\\<pi> r = None &&& Q r = \\<infinity>) &&&\n     (\\<lbrakk>(u, v) \\<in> edges rg; u \\<notin> S (A Q \\<pi>);\n       v \\<in> S (A Q \\<pi>)\\<rbrakk>\n      \\<Longrightarrow> Q u \\<noteq> \\<infinity>) &&&\n     (Q u \\<noteq> \\<infinity> \\<Longrightarrow> \\<pi> u \\<noteq> None)) &&&\n    ((\\<pi> u = Some v \\<Longrightarrow> v \\<in> S (A Q \\<pi>)) &&&\n     (\\<pi> u = Some v \\<Longrightarrow> (u, v) \\<in> edges rg)) &&&\n    (\\<lbrakk>Q u = enat d; \\<pi> u = Some v\\<rbrakk>\n     \\<Longrightarrow> d = w {u, v}) &&&\n    (Q u = enat d \\<Longrightarrow>\n     \\<forall>v'\\<in>S (A Q \\<pi>).\n        (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'})", "by auto"], ["", "lemma \\<pi>_def_on_S: \"\\<lbrakk>u\\<in>S (A Q \\<pi>); u\\<noteq>r\\<rbrakk> \\<Longrightarrow> \\<pi> u \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> S (A Q \\<pi>); u \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> \\<pi> u \\<noteq> None", "unfolding S_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> {r} \\<union> fst ` A Q \\<pi>; u \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> \\<pi> u \\<noteq> None", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> {r} \\<union>\n                     fst `\n                     {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     u \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> \\<pi> u \\<noteq> None", "by auto"], ["", "lemma \\<pi>_def_on_edges_to_S: \"\\<lbrakk>v\\<in>S (A Q \\<pi>); u\\<noteq>r; (u,v)\\<in>edges rg\\<rbrakk> \\<Longrightarrow> \\<pi> u \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> S (A Q \\<pi>); u \\<noteq> r;\n     (u, v) \\<in> edges rg\\<rbrakk>\n    \\<Longrightarrow> \\<pi> u \\<noteq> None", "apply (cases \"u\\<in>S (A Q \\<pi>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> S (A Q \\<pi>); u \\<noteq> r; (u, v) \\<in> edges rg;\n     u \\<in> S (A Q \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> \\<pi> u \\<noteq> None\n 2. \\<lbrakk>v \\<in> S (A Q \\<pi>); u \\<noteq> r; (u, v) \\<in> edges rg;\n     u \\<notin> S (A Q \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> \\<pi> u \\<noteq> None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> S (A Q \\<pi>); u \\<noteq> r; (u, v) \\<in> edges rg;\n     u \\<in> S (A Q \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> \\<pi> u \\<noteq> None", "using \\<pi>_def_on_S"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> S (A Q \\<pi>); ?u \\<noteq> r\\<rbrakk>\n  \\<Longrightarrow> \\<pi> ?u \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> S (A Q \\<pi>); u \\<noteq> r; (u, v) \\<in> edges rg;\n     u \\<in> S (A Q \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> \\<pi> u \\<noteq> None", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> S (A Q \\<pi>); u \\<noteq> r; (u, v) \\<in> edges rg;\n     u \\<notin> S (A Q \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> \\<pi> u \\<noteq> None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> S (A Q \\<pi>); u \\<noteq> r; (u, v) \\<in> edges rg;\n     u \\<notin> S (A Q \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> \\<pi> u \\<noteq> None", "by (simp add: Q_defined \\<pi>_defined)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Q_min_is_light:  \n  assumes UNS: \"Q u = enat d\"\n  assumes MIN: \"\\<forall>v. enat d \\<le> Q v\"\n  obtains v where \"\\<pi> u = Some v\" \"light_edge (S (A Q \\<pi>)) v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?A = \"A Q \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?S = \"S ?A\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from UNS"], ["proof (chain)\npicking this:\n  Q u = enat d", "obtain v where \n    S1[simp]: \"\\<pi> u = Some v\" \"d = w {u,v}\""], ["proof (prove)\nusing this:\n  Q u = enat d\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; d = w {u, v}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<pi>_defined Q_\\<pi>_consistent"], ["proof (prove)\nusing this:\n  Q u = enat d\n  Q ?u \\<noteq> \\<infinity> \\<Longrightarrow> \\<pi> ?u \\<noteq> None\n  \\<lbrakk>Q ?u = enat ?d; \\<pi> ?u = Some ?v\\<rbrakk>\n  \\<Longrightarrow> ?d = w {?u, ?v}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; d = w {u, v}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<pi> u = Some v\n  d = w {u, v}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"v\\<in>?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> S (A Q \\<pi>)", "using frontier[of u v]"], ["proof (prove)\nusing this:\n  \\<pi> u = Some v \\<Longrightarrow> v \\<in> S (A Q \\<pi>)\n\ngoal (1 subgoal):\n 1. v \\<in> S (A Q \\<pi>)", "by auto"], ["proof (state)\nthis:\n  v \\<in> S (A Q \\<pi>)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \"u\\<noteq>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> r", "using \\<pi>_root"], ["proof (prove)\nusing this:\n  \\<pi> r = None\n\ngoal (1 subgoal):\n 1. u \\<noteq> r", "using S1"], ["proof (prove)\nusing this:\n  \\<pi> r = None\n  \\<pi> u = Some v\n  d = w {u, v}\n\ngoal (1 subgoal):\n 1. u \\<noteq> r", "by (auto simp del: S1)"], ["proof (state)\nthis:\n  u \\<noteq> r\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"u\\<notin>?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> S (A Q \\<pi>)", "unfolding S_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> {r} \\<union> fst ` A Q \\<pi>", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> {r} \\<union>\n               fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>}", "using UNS"], ["proof (prove)\nusing this:\n  Q u = enat d\n\ngoal (1 subgoal):\n 1. u \\<notin> {r} \\<union>\n               fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> S (A Q \\<pi>)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(v,u)\\<in>edges rg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, u) \\<in> edges rg", "using edges[OF S1(1)]"], ["proof (prove)\nusing this:\n  (u, v) \\<in> edges rg\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> edges rg", "by (meson edges_sym' rev_subsetD)"], ["proof (state)\nthis:\n  (v, u) \\<in> edges rg\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have M: \"\\<forall>(u', v')\\<in>edges rg \\<inter> ?S \\<times> - ?S. w {v, u} \\<le> w {u', v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(u', v')\n             \\<in>edges rg \\<inter> S (A Q \\<pi>) \\<times> - S (A Q \\<pi>).\n       w {v, u} \\<le> w {u', v'}", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> w {v, u} \\<le> w {a, b}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> w {v, u} \\<le> w {a, b}", "assume \"(a,b)\\<in>edges rg\" \"a\\<in>?S\" \"b\\<notin>?S\""], ["proof (state)\nthis:\n  (a, b) \\<in> edges rg\n  a \\<in> S (A Q \\<pi>)\n  b \\<notin> S (A Q \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> w {v, u} \\<le> w {a, b}", "hence \"(b,a)\\<in>edges rg\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> edges rg\n  a \\<in> S (A Q \\<pi>)\n  b \\<notin> S (A Q \\<pi>)\n\ngoal (1 subgoal):\n 1. (b, a) \\<in> edges rg", "by (simp add: edges_sym')"], ["proof (state)\nthis:\n  (b, a) \\<in> edges rg\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> w {v, u} \\<le> w {a, b}", "from Q_defined[OF \\<open>(b,a)\\<in>edges rg\\<close> \\<open>b\\<notin>?S\\<close> \\<open>a\\<in>?S\\<close>]"], ["proof (chain)\npicking this:\n  Q b \\<noteq> \\<infinity>", "obtain d' where 1: \"Q b = enat d'\""], ["proof (prove)\nusing this:\n  Q b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d'. Q b = enat d' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Q b = enat d'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> w {v, u} \\<le> w {a, b}", "with \\<pi>_defined"], ["proof (chain)\npicking this:\n  Q ?u \\<noteq> \\<infinity> \\<Longrightarrow> \\<pi> ?u \\<noteq> None\n  Q b = enat d'", "obtain a' where \"\\<pi> b = Some a'\""], ["proof (prove)\nusing this:\n  Q ?u \\<noteq> \\<infinity> \\<Longrightarrow> \\<pi> ?u \\<noteq> None\n  Q b = enat d'\n\ngoal (1 subgoal):\n 1. (\\<And>a'. \\<pi> b = Some a' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<pi> b = Some a'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> w {v, u} \\<le> w {a, b}", "from MIN 1"], ["proof (chain)\npicking this:\n  \\<forall>v. enat d \\<le> Q v\n  Q b = enat d'", "have \"d\\<le>d'\""], ["proof (prove)\nusing this:\n  \\<forall>v. enat d \\<le> Q v\n  Q b = enat d'\n\ngoal (1 subgoal):\n 1. d \\<le> d'", "by (metis enat_ord_simps(1))"], ["proof (state)\nthis:\n  d \\<le> d'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> w {v, u} \\<le> w {a, b}", "also"], ["proof (state)\nthis:\n  d \\<le> d'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> w {v, u} \\<le> w {a, b}", "from Q_min[OF 1] \\<open>(b,a)\\<in>edges rg\\<close> \\<open>a\\<in>?S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>v'\\<in>S (A Q \\<pi>).\n     (b, v') \\<in> edges rg \\<longrightarrow> d' \\<le> w {b, v'}\n  (b, a) \\<in> edges rg\n  a \\<in> S (A Q \\<pi>)", "have \"d'\\<le>w {b,a}\""], ["proof (prove)\nusing this:\n  \\<forall>v'\\<in>S (A Q \\<pi>).\n     (b, v') \\<in> edges rg \\<longrightarrow> d' \\<le> w {b, v'}\n  (b, a) \\<in> edges rg\n  a \\<in> S (A Q \\<pi>)\n\ngoal (1 subgoal):\n 1. d' \\<le> w {b, a}", "by blast"], ["proof (state)\nthis:\n  d' \\<le> w {b, a}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> w {v, u} \\<le> w {a, b}", "finally"], ["proof (chain)\npicking this:\n  d \\<le> w {b, a}", "show \"w {v,u} \\<le> w {a,b}\""], ["proof (prove)\nusing this:\n  d \\<le> w {b, a}\n\ngoal (1 subgoal):\n 1. w {v, u} \\<le> w {a, b}", "by (simp add: insert_commute)"], ["proof (state)\nthis:\n  w {v, u} \\<le> w {a, b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(u', v')\n           \\<in>edges rg \\<inter> S (A Q \\<pi>) \\<times> - S (A Q \\<pi>).\n     w {v, u} \\<le> w {u', v'}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have LE: \"light_edge ?S v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. light_edge (S (A Q \\<pi>)) v u", "using invar1 \\<open>v\\<in>?S\\<close> \\<open>u\\<notin>?S\\<close> \\<open>(v,u)\\<in>edges rg\\<close> M"], ["proof (prove)\nusing this:\n  prim_invar1 (A Q \\<pi>)\n  v \\<in> S (A Q \\<pi>)\n  u \\<notin> S (A Q \\<pi>)\n  (v, u) \\<in> edges rg\n  \\<forall>(u', v')\n           \\<in>edges rg \\<inter> S (A Q \\<pi>) \\<times> - S (A Q \\<pi>).\n     w {v, u} \\<le> w {u', v'}\n\ngoal (1 subgoal):\n 1. light_edge (S (A Q \\<pi>)) v u", "unfolding light_edge_def"], ["proof (prove)\nusing this:\n  prim_invar1 (A Q \\<pi>)\n  v \\<in> S (A Q \\<pi>)\n  u \\<notin> S (A Q \\<pi>)\n  (v, u) \\<in> edges rg\n  \\<forall>(u', v')\n           \\<in>edges rg \\<inter> S (A Q \\<pi>) \\<times> - S (A Q \\<pi>).\n     w {v, u} \\<le> w {u', v'}\n\ngoal (1 subgoal):\n 1. v \\<in> S (A Q \\<pi>) \\<and>\n    u \\<notin> S (A Q \\<pi>) \\<and>\n    (v, u) \\<in> edges rg \\<and>\n    (\\<forall>(u', v')\n              \\<in>edges rg \\<inter> S (A Q \\<pi>) \\<times> - S (A Q \\<pi>).\n        w {v, u} \\<le> w {u', v'})", "by blast"], ["proof (state)\nthis:\n  light_edge (S (A Q \\<pi>)) v u\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  light_edge (S (A Q \\<pi>)) v u\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  light_edge (S (A Q \\<pi>)) v u\n  \\<lbrakk>\\<pi> u = Some ?v4; light_edge (S (A Q \\<pi>)) ?v4 u\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maintain_invar_ctd: \n  assumes UNS: \"Q u = enat d\"\n  assumes MIN: \"\\<forall>v. enat d \\<le> Q v\"\n  shows \"prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\" (is ?G1)\n    and \"T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) &&&\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "let ?A = \"A Q \\<pi>\""], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "let ?S = \"S ?A\""], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "from Q_min_is_light[OF UNS MIN]"], ["proof (chain)\npicking this:\n  (\\<And>v.\n      \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain v where \n    [simp]: \"\\<pi> u = Some v\" and LE: \"light_edge ?S v u\""], ["proof (prove)\nusing this:\n  (\\<And>v.\n      \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  \\<pi> u = Some v\n  light_edge (S (A Q \\<pi>)) v u\n\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "let ?Q' = \"Q' Q \\<pi> u\""], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "let ?\\<pi>' = \"\\<pi>' Q \\<pi> u\""], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "let ?A' = \"A ?Q' ?\\<pi>'\""], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "let ?S' = \"S ?A'\""], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "have NA: \"?A' = {(u,v)} \\<union> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) = {(u, v)} \\<union> A Q \\<pi>", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(ua, v).\n     \\<pi>' Q \\<pi> u ua = Some v \\<and> Q' Q \\<pi> u ua = \\<infinity>} =\n    {(u, v)} \\<union> {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>}", "unfolding Q'_def \\<pi>'_def upd_cond_def Qinter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(ua, v).\n     (if (ua, u) \\<in> edges g \\<and>\n         ua \\<noteq> r \\<and>\n         (Q ua = \\<infinity> \\<longrightarrow> \\<pi> ua = None) \\<and>\n         enat (w {ua, u}) < Q ua\n      then Some u else \\<pi> ua) =\n     Some v \\<and>\n     ((\\<lambda>v'.\n          if (v', u) \\<in> edges g \\<and>\n             v' \\<noteq> r \\<and>\n             (Q v' = \\<infinity> \\<longrightarrow> \\<pi> v' = None) \\<and>\n             enat (w {v', u}) < Q v'\n          then enat (w {v', u}) else Q v')\n      (u := \\<infinity>))\n      ua =\n     \\<infinity>} =\n    {(u, v)} \\<union> {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>}", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) = {(u, v)} \\<union> A Q \\<pi>\n\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "from maintain_invar1[OF invar1 LE]"], ["proof (chain)\npicking this:\n  prim_invar1 ({(u, v)} \\<union> A Q \\<pi>) \\<and>\n  T_measure1 ({(u, v)} \\<union> A Q \\<pi>) < T_measure1 (A Q \\<pi>)", "have \"prim_invar1 ?A'\" and M1: \"T_measure1 ?A' < T_measure1 ?A\""], ["proof (prove)\nusing this:\n  prim_invar1 ({(u, v)} \\<union> A Q \\<pi>) \\<and>\n  T_measure1 ({(u, v)} \\<union> A Q \\<pi>) < T_measure1 (A Q \\<pi>)\n\ngoal (1 subgoal):\n 1. prim_invar1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)) &&&\n    T_measure1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n    < T_measure1 (A Q \\<pi>)", "by (auto simp: NA)"], ["proof (state)\nthis:\n  prim_invar1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n  T_measure1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)) < T_measure1 (A Q \\<pi>)\n\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "then"], ["proof (chain)\npicking this:\n  prim_invar1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n  T_measure1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)) < T_measure1 (A Q \\<pi>)", "interpret N: Prim_Invar1_loc w g r ?A'"], ["proof (prove)\nusing this:\n  prim_invar1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n  T_measure1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)) < T_measure1 (A Q \\<pi>)\n\ngoal (1 subgoal):\n 1. Prim_Invar1_loc w g r (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))", "by unfold_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "have [simp]: \"?S' = insert u ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)) = insert u (S (A Q \\<pi>))", "unfolding S_alt_def N.S_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {r} \\<union> fst ` A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) =\n    insert u ({r} \\<union> fst ` A Q \\<pi>)", "unfolding Q'_def Qinter_def \\<pi>'_def upd_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {r} \\<union>\n    fst `\n    A ((\\<lambda>v'.\n           if (v', u) \\<in> edges g \\<and>\n              v' \\<noteq> r \\<and>\n              (Q v' = \\<infinity> \\<longrightarrow> \\<pi> v' = None) \\<and>\n              enat (w {v', u}) < Q v'\n           then enat (w {v', u}) else Q v')\n       (u := \\<infinity>))\n     (\\<lambda>v'.\n         if (v', u) \\<in> edges g \\<and>\n            v' \\<noteq> r \\<and>\n            (Q v' = \\<infinity> \\<longrightarrow> \\<pi> v' = None) \\<and>\n            enat (w {v', u}) < Q v'\n         then Some u else \\<pi> v') =\n    insert u ({r} \\<union> fst ` A Q \\<pi>)", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {r} \\<union>\n    fst `\n    {(ua, v).\n     (if (ua, u) \\<in> edges g \\<and>\n         ua \\<noteq> r \\<and>\n         (Q ua = \\<infinity> \\<longrightarrow> \\<pi> ua = None) \\<and>\n         enat (w {ua, u}) < Q ua\n      then Some u else \\<pi> ua) =\n     Some v \\<and>\n     ((\\<lambda>v'.\n          if (v', u) \\<in> edges g \\<and>\n             v' \\<noteq> r \\<and>\n             (Q v' = \\<infinity> \\<longrightarrow> \\<pi> v' = None) \\<and>\n             enat (w {v', u}) < Q v'\n          then enat (w {v', u}) else Q v')\n      (u := \\<infinity>))\n      ua =\n     \\<infinity>} =\n    insert u\n     ({r} \\<union>\n      fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>})", "by (auto split: if_splits simp: image_iff)"], ["proof (state)\nthis:\n  S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)) = insert u (S (A Q \\<pi>))\n\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "show ?G1"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)", "unfolding prim_invar2_ctd_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)) \\<and>\n    \\<pi>' Q \\<pi> u r = None \\<and>\n    Q' Q \\<pi> u r = \\<infinity> \\<and>\n    (\\<forall>(ua, v)\n              \\<in>edges rg \\<inter>\n                   (- S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))) \\<times>\n                   S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)).\n        Q' Q \\<pi> u ua \\<noteq> \\<infinity>) \\<and>\n    (\\<forall>ua.\n        Q' Q \\<pi> u ua \\<noteq> \\<infinity> \\<longrightarrow>\n        \\<pi>' Q \\<pi> u ua \\<noteq> None) \\<and>\n    (\\<forall>ua v.\n        \\<pi>' Q \\<pi> u ua = Some v \\<longrightarrow>\n        v \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)) \\<and>\n        (ua, v) \\<in> edges rg) \\<and>\n    (\\<forall>ua v d.\n        Q' Q \\<pi> u ua = enat d \\<and>\n        \\<pi>' Q \\<pi> u ua = Some v \\<longrightarrow>\n        d = w {ua, v} \\<and>\n        (\\<forall>v'\\<in>S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)).\n            (ua, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {ua, v'}))", "apply safe"], ["proof (prove)\ngoal (9 subgoals):\n 1. prim_invar1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n 2. \\<pi>' Q \\<pi> u r = None\n 3. Q' Q \\<pi> u r = \\<infinity>\n 4. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg;\n        b \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        a \\<notin> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q' Q \\<pi> u a = enat i\n 5. \\<And>ua i.\n       Q' Q \\<pi> u ua = enat i \\<Longrightarrow>\n       \\<exists>y. \\<pi>' Q \\<pi> u ua = Some y\n 6. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow>\n       v \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n 7. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow> (ua, v) \\<in> edges rg\n 8. \\<And>ua v d.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d;\n        \\<pi>' Q \\<pi> u ua = Some v\\<rbrakk>\n       \\<Longrightarrow> d = w {ua, v}\n 9. \\<And>ua v d v'.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d; \\<pi>' Q \\<pi> u ua = Some v;\n        v' \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        (ua, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {ua, v'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))", "by fact"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<pi>' Q \\<pi> u r = None\n 2. Q' Q \\<pi> u r = \\<infinity>\n 3. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg;\n        b \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        a \\<notin> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q' Q \\<pi> u a = enat i\n 4. \\<And>ua i.\n       Q' Q \\<pi> u ua = enat i \\<Longrightarrow>\n       \\<exists>y. \\<pi>' Q \\<pi> u ua = Some y\n 5. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow>\n       v \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n 6. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow> (ua, v) \\<in> edges rg\n 7. \\<And>ua v d.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d;\n        \\<pi>' Q \\<pi> u ua = Some v\\<rbrakk>\n       \\<Longrightarrow> d = w {ua, v}\n 8. \\<And>ua v d v'.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d; \\<pi>' Q \\<pi> u ua = Some v;\n        v' \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        (ua, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {ua, v'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>' Q \\<pi> u r = None", "unfolding \\<pi>'_def upd_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (r, u) \\<in> edges g \\<and>\n        r \\<noteq> r \\<and>\n        (Q r = \\<infinity> \\<longrightarrow> \\<pi> r = None) \\<and>\n        enat (w {r, u}) < Q r\n     then Some u else \\<pi> r) =\n    None", "by (auto simp: \\<pi>_root)"], ["proof (prove)\ngoal (7 subgoals):\n 1. Q' Q \\<pi> u r = \\<infinity>\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg;\n        b \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        a \\<notin> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q' Q \\<pi> u a = enat i\n 3. \\<And>ua i.\n       Q' Q \\<pi> u ua = enat i \\<Longrightarrow>\n       \\<exists>y. \\<pi>' Q \\<pi> u ua = Some y\n 4. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow>\n       v \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n 5. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow> (ua, v) \\<in> edges rg\n 6. \\<And>ua v d.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d;\n        \\<pi>' Q \\<pi> u ua = Some v\\<rbrakk>\n       \\<Longrightarrow> d = w {ua, v}\n 7. \\<And>ua v d v'.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d; \\<pi>' Q \\<pi> u ua = Some v;\n        v' \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        (ua, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {ua, v'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q' Q \\<pi> u r = \\<infinity>", "by (simp add: Prim2.Q'_def Prim2.Qinter_def Prim2.upd_cond_def Q_root)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges rg;\n        b \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        a \\<notin> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q' Q \\<pi> u a = enat i\n 2. \\<And>ua i.\n       Q' Q \\<pi> u ua = enat i \\<Longrightarrow>\n       \\<exists>y. \\<pi>' Q \\<pi> u ua = Some y\n 3. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow>\n       v \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n 4. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow> (ua, v) \\<in> edges rg\n 5. \\<And>ua v d.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d;\n        \\<pi>' Q \\<pi> u ua = Some v\\<rbrakk>\n       \\<Longrightarrow> d = w {ua, v}\n 6. \\<And>ua v d v'.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d; \\<pi>' Q \\<pi> u ua = Some v;\n        v' \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        (ua, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {ua, v'}", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> edges rg;\n     b \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n     a \\<notin> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q' Q \\<pi> u a = enat i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> edges rg; b = u \\<or> b \\<in> S (A Q \\<pi>);\n     a \\<noteq> u \\<and> a \\<notin> S (A Q \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q' Q \\<pi> u a = enat i", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(a, u) \\<in> edges rg; a \\<noteq> u; a \\<notin> S (A Q \\<pi>);\n     b = u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q' Q \\<pi> u a = enat i\n 2. \\<lbrakk>(a, b) \\<in> edges rg; a \\<noteq> u; a \\<notin> S (A Q \\<pi>);\n     b \\<in> S (A Q \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q' Q \\<pi> u a = enat i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, u) \\<in> edges rg; a \\<noteq> u; a \\<notin> S (A Q \\<pi>);\n     b = u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q' Q \\<pi> u a = enat i", "unfolding Q'_def Qinter_def upd_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, u) \\<in> edges rg; a \\<noteq> u; a \\<notin> S (A Q \\<pi>);\n     b = u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         ((\\<lambda>v'.\n                              if (v', u) \\<in> edges g \\<and>\n                                 v' \\<noteq> r \\<and>\n                                 (Q v' = \\<infinity> \\<longrightarrow>\n                                  \\<pi> v' = None) \\<and>\n                                 enat (w {v', u}) < Q v'\n                              then enat (w {v', u}) else Q v')\n                          (u := \\<infinity>))\n                          a =\n                         enat i", "apply (simp add: S_alt_def A_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, u) \\<in> edges rg;\n     a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u\\<rbrakk>\n    \\<Longrightarrow> ((a, u) \\<in> edges g \\<longrightarrow>\n                       a = r \\<or>\n                       Q a = \\<infinity> \\<and>\n                       (\\<exists>y. \\<pi> a = Some y) \\<or>\n                       \\<not> enat (w {a, u}) < Q a) \\<longrightarrow>\n                      (\\<exists>i. Q a = enat i)", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(a, u) \\<in> edges rg;\n     a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; (a, u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i\n 2. \\<lbrakk>(r, u) \\<in> edges rg;\n     r \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; a = r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q r = enat i\n 3. \\<And>y.\n       \\<lbrakk>(a, u) \\<in> edges rg;\n        a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n        b = u; Q a = \\<infinity>; \\<pi> a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q a = enat i\n 4. \\<lbrakk>(a, u) \\<in> edges rg;\n     a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; \\<not> enat (w {a, u}) < Q a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, u) \\<in> edges rg;\n     a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; (a, u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "using reachable_edges_subset"], ["proof (prove)\nusing this:\n  edges rg \\<subseteq> edges g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, u) \\<in> edges rg;\n     a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; (a, u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(r, u) \\<in> edges rg;\n     r \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; a = r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q r = enat i\n 2. \\<And>y.\n       \\<lbrakk>(a, u) \\<in> edges rg;\n        a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n        b = u; Q a = \\<infinity>; \\<pi> a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q a = enat i\n 3. \\<lbrakk>(a, u) \\<in> edges rg;\n     a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; \\<not> enat (w {a, u}) < Q a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(r, u) \\<in> edges rg;\n     r \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; a = r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q r = enat i", "by (simp add: Prim.S_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>(a, u) \\<in> edges rg;\n        a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n        b = u; Q a = \\<infinity>; \\<pi> a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q a = enat i\n 2. \\<lbrakk>(a, u) \\<in> edges rg;\n     a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; \\<not> enat (w {a, u}) < Q a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, u) \\<in> edges rg;\n     a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; Q a = \\<infinity>; \\<pi> a = Some y_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "by (metis (no_types) A_def Q_defined edges frontier)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, u) \\<in> edges rg;\n     a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; \\<not> enat (w {a, u}) < Q a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, u) \\<in> edges rg;\n     a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; \\<not> enat (w {a, u}) < Q a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "using not_infinity_eq"], ["proof (prove)\nusing this:\n  (?x \\<noteq> \\<infinity>) = (\\<exists>i. ?x = enat i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, u) \\<in> edges rg;\n     a \\<notin> S {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = u; \\<not> enat (w {a, u}) < Q a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> edges rg; a \\<noteq> u; a \\<notin> S (A Q \\<pi>);\n     b \\<in> S (A Q \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q' Q \\<pi> u a = enat i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> edges rg; a \\<noteq> u; a \\<notin> S (A Q \\<pi>);\n     b \\<in> S (A Q \\<pi>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q' Q \\<pi> u a = enat i", "unfolding S_alt_def N.S_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> edges rg; a \\<noteq> u;\n     a \\<notin> {r} \\<union> fst ` A Q \\<pi>;\n     b \\<in> {r} \\<union> fst ` A Q \\<pi>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q' Q \\<pi> u a = enat i", "unfolding A_def Q'_def Qinter_def upd_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> edges rg; a \\<noteq> u;\n     a \\<notin> {r} \\<union>\n                fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b \\<in> {r} \\<union>\n             fst `\n             {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         ((\\<lambda>v'.\n                              if (v', u) \\<in> edges g \\<and>\n                                 v' \\<noteq> r \\<and>\n                                 (Q v' = \\<infinity> \\<longrightarrow>\n                                  \\<pi> v' = None) \\<and>\n                                 enat (w {v', u}) < Q v'\n                              then enat (w {v', u}) else Q v')\n                          (u := \\<infinity>))\n                          a =\n                         enat i", "apply (simp; safe; (auto;fail)?)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(a, r) \\<in> edges rg; a \\<noteq> u; a \\<noteq> r;\n     a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = r; (a, u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i\n 2. \\<And>y.\n       \\<lbrakk>(a, r) \\<in> edges rg; a \\<noteq> u; a \\<noteq> r;\n        a \\<notin> fst `\n                   {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n        b = r; Q a = \\<infinity>; \\<pi> a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q a = enat i\n 3. \\<And>aa ba.\n       \\<lbrakk>(a, fst (aa, ba)) \\<in> edges rg; a \\<noteq> u;\n        a \\<noteq> r;\n        a \\<notin> fst `\n                   {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n        b = fst (aa, ba); \\<pi> aa = Some ba; Q aa = \\<infinity>;\n        (a, u) \\<notin> edges g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q a = enat i\n 4. \\<And>aa ba y.\n       \\<lbrakk>(a, fst (aa, ba)) \\<in> edges rg; a \\<noteq> u;\n        a \\<noteq> r;\n        a \\<notin> fst `\n                   {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n        b = fst (aa, ba); \\<pi> aa = Some ba; Q aa = \\<infinity>;\n        Q a = \\<infinity>; \\<pi> a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q a = enat i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, r) \\<in> edges rg; a \\<noteq> u; a \\<noteq> r;\n     a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = r; (a, u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, r) \\<in> edges rg; a \\<noteq> u; a \\<noteq> r;\n     a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = r; (a, u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "assume a1: \"(a, r) \\<in> edges rg\""], ["proof (state)\nthis:\n  (a, r) \\<in> edges rg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, r) \\<in> edges rg; a \\<noteq> u; a \\<noteq> r;\n     a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = r; (a, u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "assume \"a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>}\""], ["proof (state)\nthis:\n  a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, r) \\<in> edges rg; a \\<noteq> u; a \\<noteq> r;\n     a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = r; (a, u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "then"], ["proof (chain)\npicking this:\n  a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>}", "have \"a \\<notin> fst ` A Q \\<pi>\""], ["proof (prove)\nusing this:\n  a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>}\n\ngoal (1 subgoal):\n 1. a \\<notin> fst ` A Q \\<pi>", "by (simp add: A_def)"], ["proof (state)\nthis:\n  a \\<notin> fst ` A Q \\<pi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, r) \\<in> edges rg; a \\<noteq> u; a \\<noteq> r;\n     a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = r; (a, u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "then"], ["proof (chain)\npicking this:\n  a \\<notin> fst ` A Q \\<pi>", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<notin> fst ` A Q \\<pi>\n\ngoal (1 subgoal):\n 1. \\<exists>i. Q a = enat i", "using a1"], ["proof (prove)\nusing this:\n  a \\<notin> fst ` A Q \\<pi>\n  (a, r) \\<in> edges rg\n\ngoal (1 subgoal):\n 1. \\<exists>i. Q a = enat i", "by (metis (no_types) S_alt_def Q_defined Un_insert_left \n                  edges_irrefl' insert_iff not_infinity_eq sup_bot.left_neutral)"], ["proof (state)\nthis:\n  \\<exists>i. Q a = enat i\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>(a, r) \\<in> edges rg; a \\<noteq> u; a \\<noteq> r;\n        a \\<notin> fst `\n                   {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n        b = r; Q a = \\<infinity>; \\<pi> a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q a = enat i\n 2. \\<And>aa ba.\n       \\<lbrakk>(a, fst (aa, ba)) \\<in> edges rg; a \\<noteq> u;\n        a \\<noteq> r;\n        a \\<notin> fst `\n                   {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n        b = fst (aa, ba); \\<pi> aa = Some ba; Q aa = \\<infinity>;\n        (a, u) \\<notin> edges g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q a = enat i\n 3. \\<And>aa ba y.\n       \\<lbrakk>(a, fst (aa, ba)) \\<in> edges rg; a \\<noteq> u;\n        a \\<noteq> r;\n        a \\<notin> fst `\n                   {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n        b = fst (aa, ba); \\<pi> aa = Some ba; Q aa = \\<infinity>;\n        Q a = \\<infinity>; \\<pi> a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q a = enat i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, r) \\<in> edges rg; a \\<noteq> u; a \\<noteq> r;\n     a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = r; Q a = \\<infinity>; \\<pi> a = Some y_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "by (simp add: fst_eq_Domain)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>(a, fst (aa, ba)) \\<in> edges rg; a \\<noteq> u;\n        a \\<noteq> r;\n        a \\<notin> fst `\n                   {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n        b = fst (aa, ba); \\<pi> aa = Some ba; Q aa = \\<infinity>;\n        (a, u) \\<notin> edges g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q a = enat i\n 2. \\<And>aa ba y.\n       \\<lbrakk>(a, fst (aa, ba)) \\<in> edges rg; a \\<noteq> u;\n        a \\<noteq> r;\n        a \\<notin> fst `\n                   {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n        b = fst (aa, ba); \\<pi> aa = Some ba; Q aa = \\<infinity>;\n        Q a = \\<infinity>; \\<pi> a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q a = enat i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, fst (aa_, ba_)) \\<in> edges rg; a \\<noteq> u; a \\<noteq> r;\n     a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = fst (aa_, ba_); \\<pi> aa_ = Some ba_; Q aa_ = \\<infinity>;\n     (a, u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, aa_) \\<in> edges rg; a \\<noteq> u; a \\<noteq> r;\n     a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = aa_; \\<pi> aa_ = Some ba_; Q aa_ = \\<infinity>;\n     (a, u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "by (smt Domain.intros Q_defined \\<pi>_def_on_edges_to_S case_prod_conv \n                edges enat.exhaust frontier fst_eq_Domain mem_Collect_eq \n                option.exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba y.\n       \\<lbrakk>(a, fst (aa, ba)) \\<in> edges rg; a \\<noteq> u;\n        a \\<noteq> r;\n        a \\<notin> fst `\n                   {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n        b = fst (aa, ba); \\<pi> aa = Some ba; Q aa = \\<infinity>;\n        Q a = \\<infinity>; \\<pi> a = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. Q a = enat i", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, fst (aa_, ba_)) \\<in> edges rg; a \\<noteq> u; a \\<noteq> r;\n     a \\<notin> fst ` {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>};\n     b = fst (aa_, ba_); \\<pi> aa_ = Some ba_; Q aa_ = \\<infinity>;\n     Q a = \\<infinity>; \\<pi> a = Some y_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. Q a = enat i", "by (simp add: fst_eq_Domain)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ua i.\n       Q' Q \\<pi> u ua = enat i \\<Longrightarrow>\n       \\<exists>y. \\<pi>' Q \\<pi> u ua = Some y\n 2. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow>\n       v \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n 3. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow> (ua, v) \\<in> edges rg\n 4. \\<And>ua v d.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d;\n        \\<pi>' Q \\<pi> u ua = Some v\\<rbrakk>\n       \\<Longrightarrow> d = w {ua, v}\n 5. \\<And>ua v d v'.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d; \\<pi>' Q \\<pi> u ua = Some v;\n        v' \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        (ua, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {ua, v'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q' Q \\<pi> u ua_ = enat i_ \\<Longrightarrow>\n    \\<exists>y. \\<pi>' Q \\<pi> u ua_ = Some y", "by (metis Q'_def Qinter_def \\<pi>'_def \\<pi>_defined enat.distinct(2) \n            fun_upd_apply not_None_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow>\n       v \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n 2. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow> (ua, v) \\<in> edges rg\n 3. \\<And>ua v d.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d;\n        \\<pi>' Q \\<pi> u ua = Some v\\<rbrakk>\n       \\<Longrightarrow> d = w {ua, v}\n 4. \\<And>ua v d v'.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d; \\<pi>' Q \\<pi> u ua = Some v;\n        v' \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        (ua, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {ua, v'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>' Q \\<pi> u ua_ = Some v_ \\<Longrightarrow>\n    v_ \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))", "by (metis \\<open>S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)) = insert u (S (A Q \\<pi>))\\<close> \\<pi>'_def \n            frontier insertCI option.inject)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ua v.\n       \\<pi>' Q \\<pi> u ua = Some v \\<Longrightarrow> (ua, v) \\<in> edges rg\n 2. \\<And>ua v d.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d;\n        \\<pi>' Q \\<pi> u ua = Some v\\<rbrakk>\n       \\<Longrightarrow> d = w {ua, v}\n 3. \\<And>ua v d v'.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d; \\<pi>' Q \\<pi> u ua = Some v;\n        v' \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        (ua, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {ua, v'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>' Q \\<pi> u ua_ = Some v_ \\<Longrightarrow>\n    (ua_, v_) \\<in> edges rg", "by (metis N.S_edge_reachable upd_cond_def \n          \\<open>S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)) = insert u (S (A Q \\<pi>))\\<close> \\<pi>'_def edges \n          edges_sym' insertI1 option.inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ua v d.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d;\n        \\<pi>' Q \\<pi> u ua = Some v\\<rbrakk>\n       \\<Longrightarrow> d = w {ua, v}\n 2. \\<And>ua v d v'.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d; \\<pi>' Q \\<pi> u ua = Some v;\n        v' \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        (ua, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {ua, v'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q' Q \\<pi> u ua_ = enat d_;\n     \\<pi>' Q \\<pi> u ua_ = Some v_\\<rbrakk>\n    \\<Longrightarrow> d_ = w {ua_, v_}", "by (smt Q'_def \\<pi>'_def Q_\\<pi>_consistent Qinter_def fun_upd_apply \n            insert_absorb not_enat_eq option.inject the_enat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua v d v'.\n       \\<lbrakk>Q' Q \\<pi> u ua = enat d; \\<pi>' Q \\<pi> u ua = Some v;\n        v' \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n        (ua, v') \\<in> edges rg\\<rbrakk>\n       \\<Longrightarrow> d \\<le> w {ua, v'}", "subgoal for v' d'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q' Q \\<pi> u v' = enat d_; \\<pi>' Q \\<pi> u v' = Some d';\n     v'_ \\<in> S (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u));\n     (v', v'_) \\<in> edges rg\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', v'_}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q' Q \\<pi> u v' = enat d_; \\<pi>' Q \\<pi> u v' = Some d';\n     v'_ = u \\<or> v'_ \\<in> S (A Q \\<pi>);\n     (v', v'_) \\<in> edges rg\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', v'_}", "unfolding Q'_def Qinter_def upd_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<lambda>v'.\n                  if (v', u) \\<in> edges g \\<and>\n                     v' \\<noteq> r \\<and>\n                     (Q v' = \\<infinity> \\<longrightarrow>\n                      \\<pi> v' = None) \\<and>\n                     enat (w {v', u}) < Q v'\n                  then enat (w {v', u}) else Q v')\n              (u := \\<infinity>))\n              v' =\n             enat d_;\n     \\<pi>' Q \\<pi> u v' = Some d'; v'_ = u \\<or> v'_ \\<in> S (A Q \\<pi>);\n     (v', v'_) \\<in> edges rg\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', v'_}", "using Q_min"], ["proof (prove)\nusing this:\n  Q ?u = enat ?d \\<Longrightarrow>\n  \\<forall>v'\\<in>S (A Q \\<pi>).\n     (?u, v') \\<in> edges rg \\<longrightarrow> ?d \\<le> w {?u, v'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<lambda>v'.\n                  if (v', u) \\<in> edges g \\<and>\n                     v' \\<noteq> r \\<and>\n                     (Q v' = \\<infinity> \\<longrightarrow>\n                      \\<pi> v' = None) \\<and>\n                     enat (w {v', u}) < Q v'\n                  then enat (w {v', u}) else Q v')\n              (u := \\<infinity>))\n              v' =\n             enat d_;\n     \\<pi>' Q \\<pi> u v' = Some d'; v'_ = u \\<or> v'_ \\<in> S (A Q \\<pi>);\n     (v', v'_) \\<in> edges rg\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', v'_}", "apply (clarsimp split: if_splits; safe)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', v'_) \\<in> edges rg;\n        \\<And>u d.\n           Q u = enat d \\<Longrightarrow>\n           \\<forall>v'\\<in>S (A Q \\<pi>).\n              (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n        (v', u) \\<in> edges g; v' \\<noteq> r; enat (w {v', u}) < Q v';\n        d_ = w {v', u};\n        \\<And>u d.\n           Q u = enat d \\<Longrightarrow>\n           \\<forall>v'\\<in>S (A Q \\<pi>).\n              (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n        v'_ \\<in> S (A Q \\<pi>); Q v' = enat i\\<rbrakk>\n       \\<Longrightarrow> w {v', u} \\<le> w {v', v'_}\n 2. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', v'_) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     (v', u) \\<in> edges g; v' \\<noteq> r; enat (w {v', u}) < Q v';\n     d_ = w {v', u};\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ \\<in> S (A Q \\<pi>); \\<pi> v' = None\\<rbrakk>\n    \\<Longrightarrow> w {v', u} \\<le> w {v', v'_}\n 3. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v' \\<noteq> u; Q v' = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; (v', u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', u}\n 4. \\<lbrakk>\\<pi>' Q \\<pi> u r = Some d'; (r, u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     r \\<noteq> u; Q r = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; v' = r\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {r, u}\n 5. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v' \\<noteq> u; Q v' = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; \\<not> w {v', u} < d_\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', u}\n 6. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', v'_) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v' \\<noteq> u; Q v' = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ \\<in> S (A Q \\<pi>); (v', u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', v'_}\n 7. \\<lbrakk>\\<pi>' Q \\<pi> u r = Some d'; (r, v'_) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     r \\<noteq> u; Q r = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ \\<in> S (A Q \\<pi>); v' = r\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {r, v'_}\n 8. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', v'_) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v' \\<noteq> u; Q v' = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ \\<in> S (A Q \\<pi>); \\<not> w {v', u} < d_\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', v'_}", "apply (all \\<open>(auto;fail)?\\<close>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', v'_) \\<in> edges rg;\n        \\<And>u d.\n           Q u = enat d \\<Longrightarrow>\n           \\<forall>v'\\<in>S (A Q \\<pi>).\n              (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n        (v', u) \\<in> edges g; v' \\<noteq> r; enat (w {v', u}) < Q v';\n        d_ = w {v', u};\n        \\<And>u d.\n           Q u = enat d \\<Longrightarrow>\n           \\<forall>v'\\<in>S (A Q \\<pi>).\n              (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n        v'_ \\<in> S (A Q \\<pi>); Q v' = enat i\\<rbrakk>\n       \\<Longrightarrow> w {v', u} \\<le> w {v', v'_}\n 2. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', v'_) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     (v', u) \\<in> edges g; v' \\<noteq> r; enat (w {v', u}) < Q v';\n     d_ = w {v', u};\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ \\<in> S (A Q \\<pi>); \\<pi> v' = None\\<rbrakk>\n    \\<Longrightarrow> w {v', u} \\<le> w {v', v'_}\n 3. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v' \\<noteq> u; Q v' = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; (v', u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', u}\n 4. \\<lbrakk>\\<pi>' Q \\<pi> u r = Some d'; (r, u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     r \\<noteq> u; Q r = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; v' = r\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {r, u}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', v'_) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     (v', u) \\<in> edges g; v' \\<noteq> r; enat (w {v', u}) < Q v';\n     d_ = w {v', u};\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ \\<in> S (A Q \\<pi>); Q v' = enat i_\\<rbrakk>\n    \\<Longrightarrow> w {v', u} \\<le> w {v', v'_}", "by (simp add: le_less less_le_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', v'_) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     (v', u) \\<in> edges g; v' \\<noteq> r; enat (w {v', u}) < Q v';\n     d_ = w {v', u};\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ \\<in> S (A Q \\<pi>); \\<pi> v' = None\\<rbrakk>\n    \\<Longrightarrow> w {v', u} \\<le> w {v', v'_}\n 2. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v' \\<noteq> u; Q v' = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; (v', u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', u}\n 3. \\<lbrakk>\\<pi>' Q \\<pi> u r = Some d'; (r, u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     r \\<noteq> u; Q r = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; v' = r\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {r, u}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', v'_) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     (v', u) \\<in> edges g; v' \\<noteq> r; enat (w {v', u}) < Q v';\n     d_ = w {v', u};\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ \\<in> S (A Q \\<pi>); \\<pi> v' = None\\<rbrakk>\n    \\<Longrightarrow> w {v', u} \\<le> w {v', v'_}", "using \\<pi>_def_on_edges_to_S"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> S (A Q \\<pi>); ?u \\<noteq> r;\n   (?u, ?v) \\<in> edges rg\\<rbrakk>\n  \\<Longrightarrow> \\<pi> ?u \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', v'_) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     (v', u) \\<in> edges g; v' \\<noteq> r; enat (w {v', u}) < Q v';\n     d_ = w {v', u};\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ \\<in> S (A Q \\<pi>); \\<pi> v' = None\\<rbrakk>\n    \\<Longrightarrow> w {v', u} \\<le> w {v', v'_}", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v' \\<noteq> u; Q v' = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; (v', u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', u}\n 2. \\<lbrakk>\\<pi>' Q \\<pi> u r = Some d'; (r, u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     r \\<noteq> u; Q r = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; v' = r\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {r, u}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v' \\<noteq> u; Q v' = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; (v', u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', u}", "using reachable_edges_subset"], ["proof (prove)\nusing this:\n  edges rg \\<subseteq> edges g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<pi>' Q \\<pi> u v' = Some d'; (v', u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v' \\<noteq> u; Q v' = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; (v', u) \\<notin> edges g\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {v', u}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<pi>' Q \\<pi> u r = Some d'; (r, u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     r \\<noteq> u; Q r = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; v' = r\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {r, u}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<pi>' Q \\<pi> u r = Some d'; (r, u) \\<in> edges rg;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     r \\<noteq> u; Q r = enat d_;\n     \\<And>u d.\n        Q u = enat d \\<Longrightarrow>\n        \\<forall>v'\\<in>S (A Q \\<pi>).\n           (u, v') \\<in> edges rg \\<longrightarrow> d \\<le> w {u, v'};\n     v'_ = u; v' = r\\<rbrakk>\n    \\<Longrightarrow> d_ \\<le> w {r, u}", "by (simp add: Q_root)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n\ngoal (1 subgoal):\n 1. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "then"], ["proof (chain)\npicking this:\n  prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)", "interpret N: Prim_Invar2_ctd_loc w g r ?Q' ?\\<pi>'"], ["proof (prove)\nusing this:\n  prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n\ngoal (1 subgoal):\n 1. Prim_Invar2_ctd_loc w g r (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "show ?G2"], ["proof (prove)\ngoal (1 subgoal):\n 1. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "unfolding T_measure2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Q' Q \\<pi> u r = \\<infinity>\n     then T_measure1 (A (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u))\n     else card (nodes rg))\n    < (if Q r = \\<infinity> then T_measure1 (A Q \\<pi>)\n       else card (nodes rg))", "by (auto simp: Q_root N.Q_root M1)"], ["proof (state)\nthis:\n  T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context Prim2 begin"], ["", "lemma maintain_invar2_ctd: \n  assumes INV: \"prim_invar2_ctd Q \\<pi>\"\n  assumes UNS: \"Q u = enat d\"\n  assumes MIN: \"\\<forall>v. enat d \\<le> Q v\"\n  shows \"prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\" (is ?G1)\n    and \"T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) &&&\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "interpret Prim_Invar2_ctd_loc w g r Q \\<pi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Prim_Invar2_ctd_loc w g r Q \\<pi>", "using INV"], ["proof (prove)\nusing this:\n  prim_invar2_ctd Q \\<pi>\n\ngoal (1 subgoal):\n 1. Prim_Invar2_ctd_loc w g r Q \\<pi>", "by unfold_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n 2. T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "from maintain_invar_ctd[OF UNS MIN]"], ["proof (chain)\npicking this:\n  prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n  T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "show ?G1 ?G2"], ["proof (prove)\nusing this:\n  prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n  T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\n\ngoal (1 subgoal):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) &&&\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "by auto"], ["proof (state)\nthis:\n  prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n  T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Q_min_is_light_presentation:  \n  assumes INV: \"prim_invar2_ctd Q \\<pi>\"\n  assumes UNS: \"Q u = enat d\"\n  assumes MIN: \"\\<forall>v. enat d \\<le> Q v\"\n  obtains v where \"\\<pi> u = Some v\" \"light_edge (S (A Q \\<pi>)) v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "interpret Prim_Invar2_ctd_loc w g r Q \\<pi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Prim_Invar2_ctd_loc w g r Q \\<pi>", "using INV"], ["proof (prove)\nusing this:\n  prim_invar2_ctd Q \\<pi>\n\ngoal (1 subgoal):\n 1. Prim_Invar2_ctd_loc w g r Q \\<pi>", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from Q_min_is_light[OF UNS MIN]"], ["proof (chain)\npicking this:\n  (\\<And>v.\n      \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>v.\n      \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  (\\<And>v.\n      \\<lbrakk>\\<pi> u = Some v; light_edge (S (A Q \\<pi>)) v u\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  \\<lbrakk>\\<pi> u = Some ?v4; light_edge (S (A Q \\<pi>)) ?v4 u\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maintain_invar2_ctd_presentation: \n  assumes INV: \"prim_invar2_ctd Q \\<pi>\"\n  assumes UNS: \"Q u = enat d\"\n  assumes MIN: \"\\<forall>v. enat d \\<le> Q v\"\n  shows \"prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\n       \\<and> T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) \\<and>\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "using maintain_invar2_ctd assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>prim_invar2_ctd ?Q ?\\<pi>; ?Q ?u = enat ?d;\n   \\<forall>v. enat ?d \\<le> ?Q v\\<rbrakk>\n  \\<Longrightarrow> prim_invar2_ctd (Q' ?Q ?\\<pi> ?u) (\\<pi>' ?Q ?\\<pi> ?u)\n  \\<lbrakk>prim_invar2_ctd ?Q ?\\<pi>; ?Q ?u = enat ?d;\n   \\<forall>v. enat ?d \\<le> ?Q v\\<rbrakk>\n  \\<Longrightarrow> T_measure2 (Q' ?Q ?\\<pi> ?u) (\\<pi>' ?Q ?\\<pi> ?u)\n                    < T_measure2 ?Q ?\\<pi>\n  prim_invar2_ctd Q \\<pi>\n  Q u = enat d\n  \\<forall>v. enat d \\<le> Q v\n\ngoal (1 subgoal):\n 1. prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) \\<and>\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "by blast"], ["", "lemma not_invar2_ctd_init: \n  \"prim_invar2_init Q \\<pi> \\<Longrightarrow> \\<not>prim_invar2_ctd Q \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2_init Q \\<pi> \\<Longrightarrow>\n    \\<not> prim_invar2_ctd Q \\<pi>", "unfolding prim_invar2_init_def prim_invar2_ctd_def initQ_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q = (\\<lambda>_. \\<infinity>)(r := 0) \\<and>\n    \\<pi> = init\\<pi> \\<Longrightarrow>\n    \\<not> (prim_invar1 (A Q \\<pi>) \\<and>\n            \\<pi> r = None \\<and>\n            Q r = \\<infinity> \\<and>\n            (\\<forall>(u, v)\n                      \\<in>edges rg \\<inter>\n                           (- S (A Q \\<pi>)) \\<times> S (A Q \\<pi>).\n                Q u \\<noteq> \\<infinity>) \\<and>\n            (\\<forall>u.\n                Q u \\<noteq> \\<infinity> \\<longrightarrow>\n                \\<pi> u \\<noteq> None) \\<and>\n            (\\<forall>u v.\n                \\<pi> u = Some v \\<longrightarrow>\n                v \\<in> S (A Q \\<pi>) \\<and> (u, v) \\<in> edges rg) \\<and>\n            (\\<forall>u v d.\n                Q u = enat d \\<and> \\<pi> u = Some v \\<longrightarrow>\n                d = w {u, v} \\<and>\n                (\\<forall>v'\\<in>S (A Q \\<pi>).\n                    (u, v') \\<in> edges rg \\<longrightarrow>\n                    d \\<le> w {u, v'})))", "by (auto)"], ["", "lemma invar2_init_init: \"prim_invar2_init initQ init\\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2_init initQ init\\<pi>", "unfolding prim_invar2_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. initQ = initQ \\<and> init\\<pi> = init\\<pi>", "by auto"], ["", "lemma invar2_init: \"prim_invar2 initQ init\\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2 initQ init\\<pi>", "unfolding prim_invar2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2_init initQ init\\<pi> \\<or> prim_invar2_ctd initQ init\\<pi>", "using invar2_init_init"], ["proof (prove)\nusing this:\n  prim_invar2_init initQ init\\<pi>\n\ngoal (1 subgoal):\n 1. prim_invar2_init initQ init\\<pi> \\<or> prim_invar2_ctd initQ init\\<pi>", "by auto"], ["", "lemma maintain_invar2: \n  assumes A: \"prim_invar2 Q \\<pi>\"  \n  assumes UNS: \"Q u = enat d\"\n  assumes MIN: \"\\<forall>v. enat d \\<le> Q v\"\n  shows \"prim_invar2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u)\" (is ?G1)\n    and \"T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_invar2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) &&&\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "using A"], ["proof (prove)\nusing this:\n  prim_invar2 Q \\<pi>\n\ngoal (1 subgoal):\n 1. prim_invar2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) &&&\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "unfolding prim_invar2_def"], ["proof (prove)\nusing this:\n  prim_invar2_init Q \\<pi> \\<or> prim_invar2_ctd Q \\<pi>\n\ngoal (1 subgoal):\n 1. prim_invar2_init (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) \\<or>\n    prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) &&&\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "using maintain_invar2_first_step[of Q,OF _ UNS]"], ["proof (prove)\nusing this:\n  prim_invar2_init Q \\<pi> \\<or> prim_invar2_ctd Q \\<pi>\n  prim_invar2_init Q ?\\<pi> \\<Longrightarrow>\n  prim_invar2_ctd (Q' Q ?\\<pi> u) (\\<pi>' Q ?\\<pi> u)\n  prim_invar2_init Q ?\\<pi> \\<Longrightarrow>\n  T_measure2 (Q' Q ?\\<pi> u) (\\<pi>' Q ?\\<pi> u) < T_measure2 Q ?\\<pi>\n\ngoal (1 subgoal):\n 1. prim_invar2_init (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) \\<or>\n    prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) &&&\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "using maintain_invar2_ctd[OF _ UNS MIN]"], ["proof (prove)\nusing this:\n  prim_invar2_init Q \\<pi> \\<or> prim_invar2_ctd Q \\<pi>\n  prim_invar2_init Q ?\\<pi> \\<Longrightarrow>\n  prim_invar2_ctd (Q' Q ?\\<pi> u) (\\<pi>' Q ?\\<pi> u)\n  prim_invar2_init Q ?\\<pi> \\<Longrightarrow>\n  T_measure2 (Q' Q ?\\<pi> u) (\\<pi>' Q ?\\<pi> u) < T_measure2 Q ?\\<pi>\n  prim_invar2_ctd Q ?\\<pi> \\<Longrightarrow>\n  prim_invar2_ctd (Q' Q ?\\<pi> u) (\\<pi>' Q ?\\<pi> u)\n  prim_invar2_ctd Q ?\\<pi> \\<Longrightarrow>\n  T_measure2 (Q' Q ?\\<pi> u) (\\<pi>' Q ?\\<pi> u) < T_measure2 Q ?\\<pi>\n\ngoal (1 subgoal):\n 1. prim_invar2_init (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) \\<or>\n    prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) &&&\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "using not_invar2_ctd_init"], ["proof (prove)\nusing this:\n  prim_invar2_init Q \\<pi> \\<or> prim_invar2_ctd Q \\<pi>\n  prim_invar2_init Q ?\\<pi> \\<Longrightarrow>\n  prim_invar2_ctd (Q' Q ?\\<pi> u) (\\<pi>' Q ?\\<pi> u)\n  prim_invar2_init Q ?\\<pi> \\<Longrightarrow>\n  T_measure2 (Q' Q ?\\<pi> u) (\\<pi>' Q ?\\<pi> u) < T_measure2 Q ?\\<pi>\n  prim_invar2_ctd Q ?\\<pi> \\<Longrightarrow>\n  prim_invar2_ctd (Q' Q ?\\<pi> u) (\\<pi>' Q ?\\<pi> u)\n  prim_invar2_ctd Q ?\\<pi> \\<Longrightarrow>\n  T_measure2 (Q' Q ?\\<pi> u) (\\<pi>' Q ?\\<pi> u) < T_measure2 Q ?\\<pi>\n  prim_invar2_init ?Q ?\\<pi> \\<Longrightarrow>\n  \\<not> prim_invar2_ctd ?Q ?\\<pi>\n\ngoal (1 subgoal):\n 1. prim_invar2_init (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) \\<or>\n    prim_invar2_ctd (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) &&&\n    T_measure2 (Q' Q \\<pi> u) (\\<pi>' Q \\<pi> u) < T_measure2 Q \\<pi>", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invar2_ctd_finish:  \n  assumes INV: \"prim_invar2_ctd Q \\<pi>\"  \n  assumes FIN: \"Q = (\\<lambda>_. \\<infinity>)\"\n  shows \"is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "from INV"], ["proof (chain)\npicking this:\n  prim_invar2_ctd Q \\<pi>", "interpret Prim_Invar2_ctd_loc w g r Q \\<pi>"], ["proof (prove)\nusing this:\n  prim_invar2_ctd Q \\<pi>\n\ngoal (1 subgoal):\n 1. Prim_Invar2_ctd_loc w g r Q \\<pi>", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "let ?A = \"A Q \\<pi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "let ?S=\"S ?A\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "have FC: \"edges g \\<inter> ?S \\<times> - ?S = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges g \\<inter> S (A Q \\<pi>) \\<times> - S (A Q \\<pi>) = {}", "proof (safe; simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges g; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> False", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges g; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(a,b)\\<in>edges g\" \"a\\<in>?S\" \"b\\<notin>?S\""], ["proof (state)\nthis:\n  (a, b) \\<in> edges g\n  a \\<in> S (A Q \\<pi>)\n  b \\<notin> S (A Q \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges g; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> False", "with Q_defined[OF edges_sym'] S_edge_reachable"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?v, ?u) \\<in> edges rg; ?u \\<notin> S (A Q \\<pi>);\n   ?v \\<in> S (A Q \\<pi>)\\<rbrakk>\n  \\<Longrightarrow> Q ?u \\<noteq> \\<infinity>\n  \\<lbrakk>?u \\<in> S (A Q \\<pi>); (?u, ?v) \\<in> edges g\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> edges rg\n  (a, b) \\<in> edges g\n  a \\<in> S (A Q \\<pi>)\n  b \\<notin> S (A Q \\<pi>)", "have \"Q b \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v, ?u) \\<in> edges rg; ?u \\<notin> S (A Q \\<pi>);\n   ?v \\<in> S (A Q \\<pi>)\\<rbrakk>\n  \\<Longrightarrow> Q ?u \\<noteq> \\<infinity>\n  \\<lbrakk>?u \\<in> S (A Q \\<pi>); (?u, ?v) \\<in> edges g\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> edges rg\n  (a, b) \\<in> edges g\n  a \\<in> S (A Q \\<pi>)\n  b \\<notin> S (A Q \\<pi>)\n\ngoal (1 subgoal):\n 1. Q b \\<noteq> \\<infinity>", "by blast"], ["proof (state)\nthis:\n  Q b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> edges g; a \\<in> S (A Q \\<pi>);\n        b \\<notin> S (A Q \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> False", "with FIN"], ["proof (chain)\npicking this:\n  Q = (\\<lambda>_. \\<infinity>)\n  Q b \\<noteq> \\<infinity>", "show False"], ["proof (prove)\nusing this:\n  Q = (\\<lambda>_. \\<infinity>)\n  Q b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  edges g \\<inter> S (A Q \\<pi>) \\<times> - S (A Q \\<pi>) = {}\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "have Aeq: \"?A = {(u, v). \\<pi> u = Some v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A Q \\<pi> = {(u, v). \\<pi> u = Some v}", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>} =\n    {(u, v). \\<pi> u = Some v}", "using FIN"], ["proof (prove)\nusing this:\n  Q = (\\<lambda>_. \\<infinity>)\n\ngoal (1 subgoal):\n 1. {(u, v). \\<pi> u = Some v \\<and> Q u = \\<infinity>} =\n    {(u, v). \\<pi> u = Some v}", "by auto"], ["proof (state)\nthis:\n  A Q \\<pi> = {(u, v). \\<pi> u = Some v}\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "from invar1_finish[OF invar1 FC, unfolded Aeq]"], ["proof (chain)\npicking this:\n  is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "show ?thesis"], ["proof (prove)\nusing this:\n  is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "."], ["proof (state)\nthis:\n  is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar2_finish:  \n  assumes INV: \"prim_invar2 Q \\<pi>\"  \n  assumes FIN: \"Q = (\\<lambda>_. \\<infinity>)\"\n  shows \"is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "from INV"], ["proof (chain)\npicking this:\n  prim_invar2 Q \\<pi>", "have \"prim_invar2_ctd Q \\<pi>\""], ["proof (prove)\nusing this:\n  prim_invar2 Q \\<pi>\n\ngoal (1 subgoal):\n 1. prim_invar2_ctd Q \\<pi>", "unfolding prim_invar2_def prim_invar2_init_def initQ_def"], ["proof (prove)\nusing this:\n  Q = (\\<lambda>_. \\<infinity>)(r := 0) \\<and> \\<pi> = init\\<pi> \\<or>\n  prim_invar2_ctd Q \\<pi>\n\ngoal (1 subgoal):\n 1. prim_invar2_ctd Q \\<pi>", "by (auto simp: fun_eq_iff FIN split: if_splits)"], ["proof (state)\nthis:\n  prim_invar2_ctd Q \\<pi>\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "with FIN invar2_ctd_finish"], ["proof (chain)\npicking this:\n  Q = (\\<lambda>_. \\<infinity>)\n  \\<lbrakk>prim_invar2_ctd ?Q ?\\<pi>;\n   ?Q = (\\<lambda>_. \\<infinity>)\\<rbrakk>\n  \\<Longrightarrow> is_MST w rg (graph {r} {(u, v). ?\\<pi> u = Some v})\n  prim_invar2_ctd Q \\<pi>", "show ?thesis"], ["proof (prove)\nusing this:\n  Q = (\\<lambda>_. \\<infinity>)\n  \\<lbrakk>prim_invar2_ctd ?Q ?\\<pi>;\n   ?Q = (\\<lambda>_. \\<infinity>)\\<rbrakk>\n  \\<Longrightarrow> is_MST w rg (graph {r} {(u, v). ?\\<pi> u = Some v})\n  prim_invar2_ctd Q \\<pi>\n\ngoal (1 subgoal):\n 1. is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})", "by blast"], ["proof (state)\nthis:\n  is_MST w rg (graph {r} {(u, v). \\<pi> u = Some v})\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Refinement of Inner Foreach Loop\\label{sec:using_foreach}\\<close>"], ["", "context Prim2 begin"], ["", "definition \"foreach_body u \\<equiv> \\<lambda>(v,d) (Q,\\<pi>).\n  if v=r then (Q,\\<pi>)\n  else\n    case (Q v, \\<pi> v) of\n      (\\<infinity>,None) \\<Rightarrow> (Q(v:=enat d), \\<pi>(v\\<mapsto>u))\n    | (enat d',_) \\<Rightarrow> if d<d' then (Q(v:=enat d), \\<pi>(v\\<mapsto>u)) else (Q,\\<pi>)\n    | (\\<infinity>,Some _) \\<Rightarrow> (Q,\\<pi>)\n  \""], ["", "lemma foreach_body_alt: \"foreach_body u = (\\<lambda>(v,d) (Q,\\<pi>). \n  if v\\<noteq>r \\<and> (\\<pi> v = None \\<or> Q v \\<noteq> \\<infinity>) \\<and> enat d < Q v then\n    (Q(v:=enat d), \\<pi>(v\\<mapsto>u))\n  else \n    (Q,\\<pi>)\n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foreach_body u =\n    (\\<lambda>(v, d) (Q, \\<pi>).\n        if v \\<noteq> r \\<and>\n           (\\<pi> v = None \\<or> Q v \\<noteq> \\<infinity>) \\<and>\n           enat d < Q v\n        then (Q(v := enat d), \\<pi>(v \\<mapsto> u)) else (Q, \\<pi>))", "unfolding foreach_body_def S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(v, d) (Q, \\<pi>).\n        if v = r then (Q, \\<pi>)\n        else case (Q v, \\<pi> v) of\n             (enat d', x) \\<Rightarrow>\n               if d < d' then (Q(v := enat d), \\<pi>(v \\<mapsto> u))\n               else (Q, \\<pi>)\n             | (\\<infinity>, None) \\<Rightarrow>\n                 (Q(v := enat d), \\<pi>(v \\<mapsto> u))\n             | (\\<infinity>, Some xa) \\<Rightarrow> (Q, \\<pi>)) =\n    (\\<lambda>(v, d) (Q, \\<pi>).\n        if v \\<noteq> r \\<and>\n           (\\<pi> v = None \\<or> Q v \\<noteq> \\<infinity>) \\<and>\n           enat d < Q v\n        then (Q(v := enat d), \\<pi>(v \\<mapsto> u)) else (Q, \\<pi>))", "by (auto split: enat.splits option.splits simp: fst_eq_Domain fun_eq_iff)"], ["", "definition foreach where\n  \"foreach u adjs Q\\<pi> = foldr (foreach_body u) adjs Q\\<pi>\""], ["", "definition \"\\<And>Q V. \n  Qigen Q \\<pi> u adjs v = (if v \\<notin> fst`set adjs then Q v else Qinter Q \\<pi> u v)\""], ["", "definition \"\\<And>Q V \\<pi>. \n  \\<pi>'gen Q \\<pi> u adjs v = (if v \\<notin> fst`set adjs then \\<pi> v else \\<pi>' Q \\<pi> u v)\""], ["", "context begin"], ["", "private"], ["", "lemma Qc: \n  \"Qigen Q \\<pi> u ((v, w {u, v}) # adjs) x \n  = (if x=v then Qinter Q \\<pi> u v else Qigen Q \\<pi> u adjs x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Qigen Q \\<pi> u ((v, w {u, v}) # adjs) x =\n    (if x = v then Qinter Q \\<pi> u v else Qigen Q \\<pi> u adjs x)", "unfolding Qigen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x \\<notin> fst ` set ((v, w {u, v}) # adjs) then Q x\n     else Qinter Q \\<pi> u x) =\n    (if x = v then Qinter Q \\<pi> u v\n     else if x \\<notin> fst ` set adjs then Q x else Qinter Q \\<pi> u x)", "by auto"], ["", "private"], ["", "lemma \\<pi>c: \n  \"\\<pi>'gen Q \\<pi> u ((v, w {u, v}) # adjs) x \n  = (if x=v then \\<pi>' Q \\<pi> u v else \\<pi>'gen Q \\<pi> u adjs x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>'gen Q \\<pi> u ((v, w {u, v}) # adjs) x =\n    (if x = v then \\<pi>' Q \\<pi> u v else \\<pi>'gen Q \\<pi> u adjs x)", "unfolding \\<pi>'gen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x \\<notin> fst ` set ((v, w {u, v}) # adjs) then \\<pi> x\n     else \\<pi>' Q \\<pi> u x) =\n    (if x = v then \\<pi>' Q \\<pi> u v\n     else if x \\<notin> fst ` set adjs then \\<pi> x else \\<pi>' Q \\<pi> u x)", "by auto"], ["", "lemma foreach_refine_gen:\n  assumes \"set adjs \\<subseteq> {(v,d). (u,v)\\<in>edges g \\<and> w {u,v} = d}\"          \n  shows \"foreach u adjs (Q,\\<pi>) = (Qigen Q \\<pi> u adjs,\\<pi>'gen Q \\<pi> u adjs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foreach u adjs (Q, \\<pi>) =\n    (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs)", "using assms"], ["proof (prove)\nusing this:\n  set adjs \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d}\n\ngoal (1 subgoal):\n 1. foreach u adjs (Q, \\<pi>) =\n    (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs)", "unfolding foreach_def"], ["proof (prove)\nusing this:\n  set adjs \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d}\n\ngoal (1 subgoal):\n 1. foldr (foreach_body u) adjs (Q, \\<pi>) =\n    (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs)", "proof (induction adjs arbitrary: Q \\<pi>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q \\<pi>.\n       set []\n       \\<subseteq> {(v, d).\n                    (u, v) \\<in> edges g \\<and>\n                    w {u, v} = d} \\<Longrightarrow>\n       foldr (foreach_body u) [] (Q, \\<pi>) =\n       (Qigen Q \\<pi> u [], \\<pi>'gen Q \\<pi> u [])\n 2. \\<And>a adjs Q \\<pi>.\n       \\<lbrakk>\\<And>Q \\<pi>.\n                   set adjs\n                   \\<subseteq> {(v, d).\n                                (u, v) \\<in> edges g \\<and>\n                                w {u, v} = d} \\<Longrightarrow>\n                   foldr (foreach_body u) adjs (Q, \\<pi>) =\n                   (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs);\n        set (a # adjs)\n        \\<subseteq> {(v, d).\n                     (u, v) \\<in> edges g \\<and> w {u, v} = d}\\<rbrakk>\n       \\<Longrightarrow> foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n                         (Qigen Q \\<pi> u (a # adjs),\n                          \\<pi>'gen Q \\<pi> u (a # adjs))", "case Nil"], ["proof (state)\nthis:\n  set []\n  \\<subseteq> {a. case a of\n                  (v, d) \\<Rightarrow>\n                    (u, v) \\<in> edges g \\<and> w {u, v} = d}\n\ngoal (2 subgoals):\n 1. \\<And>Q \\<pi>.\n       set []\n       \\<subseteq> {(v, d).\n                    (u, v) \\<in> edges g \\<and>\n                    w {u, v} = d} \\<Longrightarrow>\n       foldr (foreach_body u) [] (Q, \\<pi>) =\n       (Qigen Q \\<pi> u [], \\<pi>'gen Q \\<pi> u [])\n 2. \\<And>a adjs Q \\<pi>.\n       \\<lbrakk>\\<And>Q \\<pi>.\n                   set adjs\n                   \\<subseteq> {(v, d).\n                                (u, v) \\<in> edges g \\<and>\n                                w {u, v} = d} \\<Longrightarrow>\n                   foldr (foreach_body u) adjs (Q, \\<pi>) =\n                   (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs);\n        set (a # adjs)\n        \\<subseteq> {(v, d).\n                     (u, v) \\<in> edges g \\<and> w {u, v} = d}\\<rbrakk>\n       \\<Longrightarrow> foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n                         (Qigen Q \\<pi> u (a # adjs),\n                          \\<pi>'gen Q \\<pi> u (a # adjs))", "have INVAR_INIT: \"Qigen Q \\<pi> u [] = Q\" \"\\<pi>'gen Q \\<pi> u [] = \\<pi>\" for Q \\<pi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Qigen Q \\<pi> u [] = Q &&& \\<pi>'gen Q \\<pi> u [] = \\<pi>", "unfolding assms Qigen_def \\<pi>'gen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        if v \\<notin> fst ` set [] then Q v else Qinter Q \\<pi> u v) =\n    Q &&&\n    (\\<lambda>v.\n        if v \\<notin> fst ` set [] then \\<pi> v else \\<pi>' Q \\<pi> u v) =\n    \\<pi>", "by (auto simp: fun_eq_iff image_def Q'_def \\<pi>'_def edges_def)"], ["proof (state)\nthis:\n  Qigen ?Q9 ?\\<pi>9 u [] = ?Q9\n  \\<pi>'gen ?Q9 ?\\<pi>9 u [] = ?\\<pi>9\n\ngoal (2 subgoals):\n 1. \\<And>Q \\<pi>.\n       set []\n       \\<subseteq> {(v, d).\n                    (u, v) \\<in> edges g \\<and>\n                    w {u, v} = d} \\<Longrightarrow>\n       foldr (foreach_body u) [] (Q, \\<pi>) =\n       (Qigen Q \\<pi> u [], \\<pi>'gen Q \\<pi> u [])\n 2. \\<And>a adjs Q \\<pi>.\n       \\<lbrakk>\\<And>Q \\<pi>.\n                   set adjs\n                   \\<subseteq> {(v, d).\n                                (u, v) \\<in> edges g \\<and>\n                                w {u, v} = d} \\<Longrightarrow>\n                   foldr (foreach_body u) adjs (Q, \\<pi>) =\n                   (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs);\n        set (a # adjs)\n        \\<subseteq> {(v, d).\n                     (u, v) \\<in> edges g \\<and> w {u, v} = d}\\<rbrakk>\n       \\<Longrightarrow> foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n                         (Qigen Q \\<pi> u (a # adjs),\n                          \\<pi>'gen Q \\<pi> u (a # adjs))", "with Nil"], ["proof (chain)\npicking this:\n  set []\n  \\<subseteq> {a. case a of\n                  (v, d) \\<Rightarrow>\n                    (u, v) \\<in> edges g \\<and> w {u, v} = d}\n  Qigen ?Q9 ?\\<pi>9 u [] = ?Q9\n  \\<pi>'gen ?Q9 ?\\<pi>9 u [] = ?\\<pi>9", "show ?case"], ["proof (prove)\nusing this:\n  set []\n  \\<subseteq> {a. case a of\n                  (v, d) \\<Rightarrow>\n                    (u, v) \\<in> edges g \\<and> w {u, v} = d}\n  Qigen ?Q9 ?\\<pi>9 u [] = ?Q9\n  \\<pi>'gen ?Q9 ?\\<pi>9 u [] = ?\\<pi>9\n\ngoal (1 subgoal):\n 1. foldr (foreach_body u) [] (Q, \\<pi>) =\n    (Qigen Q \\<pi> u [], \\<pi>'gen Q \\<pi> u [])", "by (simp add: INVAR_INIT)"], ["proof (state)\nthis:\n  foldr (foreach_body u) [] (Q, \\<pi>) =\n  (Qigen Q \\<pi> u [], \\<pi>'gen Q \\<pi> u [])\n\ngoal (1 subgoal):\n 1. \\<And>a adjs Q \\<pi>.\n       \\<lbrakk>\\<And>Q \\<pi>.\n                   set adjs\n                   \\<subseteq> {(v, d).\n                                (u, v) \\<in> edges g \\<and>\n                                w {u, v} = d} \\<Longrightarrow>\n                   foldr (foreach_body u) adjs (Q, \\<pi>) =\n                   (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs);\n        set (a # adjs)\n        \\<subseteq> {(v, d).\n                     (u, v) \\<in> edges g \\<and> w {u, v} = d}\\<rbrakk>\n       \\<Longrightarrow> foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n                         (Qigen Q \\<pi> u (a # adjs),\n                          \\<pi>'gen Q \\<pi> u (a # adjs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a adjs Q \\<pi>.\n       \\<lbrakk>\\<And>Q \\<pi>.\n                   set adjs\n                   \\<subseteq> {(v, d).\n                                (u, v) \\<in> edges g \\<and>\n                                w {u, v} = d} \\<Longrightarrow>\n                   foldr (foreach_body u) adjs (Q, \\<pi>) =\n                   (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs);\n        set (a # adjs)\n        \\<subseteq> {(v, d).\n                     (u, v) \\<in> edges g \\<and> w {u, v} = d}\\<rbrakk>\n       \\<Longrightarrow> foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n                         (Qigen Q \\<pi> u (a # adjs),\n                          \\<pi>'gen Q \\<pi> u (a # adjs))", "case (Cons a adjs)"], ["proof (state)\nthis:\n  set adjs\n  \\<subseteq> {a. case a of\n                  (v, d) \\<Rightarrow>\n                    (u, v) \\<in> edges g \\<and>\n                    w {u, v} = d} \\<Longrightarrow>\n  foldr (foreach_body u) adjs (?Q8, ?\\<pi>8) =\n  (Qigen ?Q8 ?\\<pi>8 u adjs, \\<pi>'gen ?Q8 ?\\<pi>8 u adjs)\n  set (a # adjs)\n  \\<subseteq> {a. case a of\n                  (v, d) \\<Rightarrow>\n                    (u, v) \\<in> edges g \\<and> w {u, v} = d}\n\ngoal (1 subgoal):\n 1. \\<And>a adjs Q \\<pi>.\n       \\<lbrakk>\\<And>Q \\<pi>.\n                   set adjs\n                   \\<subseteq> {(v, d).\n                                (u, v) \\<in> edges g \\<and>\n                                w {u, v} = d} \\<Longrightarrow>\n                   foldr (foreach_body u) adjs (Q, \\<pi>) =\n                   (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs);\n        set (a # adjs)\n        \\<subseteq> {(v, d).\n                     (u, v) \\<in> edges g \\<and> w {u, v} = d}\\<rbrakk>\n       \\<Longrightarrow> foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n                         (Qigen Q \\<pi> u (a # adjs),\n                          \\<pi>'gen Q \\<pi> u (a # adjs))", "obtain v d where [simp]: \"a=(v,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v d. a = (v, d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = (v, d)\n\ngoal (1 subgoal):\n 1. \\<And>a adjs Q \\<pi>.\n       \\<lbrakk>\\<And>Q \\<pi>.\n                   set adjs\n                   \\<subseteq> {(v, d).\n                                (u, v) \\<in> edges g \\<and>\n                                w {u, v} = d} \\<Longrightarrow>\n                   foldr (foreach_body u) adjs (Q, \\<pi>) =\n                   (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs);\n        set (a # adjs)\n        \\<subseteq> {(v, d).\n                     (u, v) \\<in> edges g \\<and> w {u, v} = d}\\<rbrakk>\n       \\<Longrightarrow> foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n                         (Qigen Q \\<pi> u (a # adjs),\n                          \\<pi>'gen Q \\<pi> u (a # adjs))", "have [simp]: \"u\\<noteq>v\" \"v\\<noteq>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> v &&& v \\<noteq> u", "using Cons.prems"], ["proof (prove)\nusing this:\n  set (a # adjs)\n  \\<subseteq> {a. case a of\n                  (v, d) \\<Rightarrow>\n                    (u, v) \\<in> edges g \\<and> w {u, v} = d}\n\ngoal (1 subgoal):\n 1. u \\<noteq> v &&& v \\<noteq> u", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> v\n  v \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<And>a adjs Q \\<pi>.\n       \\<lbrakk>\\<And>Q \\<pi>.\n                   set adjs\n                   \\<subseteq> {(v, d).\n                                (u, v) \\<in> edges g \\<and>\n                                w {u, v} = d} \\<Longrightarrow>\n                   foldr (foreach_body u) adjs (Q, \\<pi>) =\n                   (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs);\n        set (a # adjs)\n        \\<subseteq> {(v, d).\n                     (u, v) \\<in> edges g \\<and> w {u, v} = d}\\<rbrakk>\n       \\<Longrightarrow> foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n                         (Qigen Q \\<pi> u (a # adjs),\n                          \\<pi>'gen Q \\<pi> u (a # adjs))", "have QinfD: \"Qigen Q \\<pi> u adjs v = \\<infinity> \\<Longrightarrow> Q v = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Qigen Q \\<pi> u adjs v = \\<infinity> \\<Longrightarrow> Q v = \\<infinity>", "unfolding Qigen_def Q'_def Qinter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if v \\<notin> fst ` set adjs then Q v\n     else if upd_cond Q \\<pi> u v then enat (w {v, u}) else Q v) =\n    \\<infinity> \\<Longrightarrow>\n    Q v = \\<infinity>", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  Qigen Q \\<pi> u adjs v = \\<infinity> \\<Longrightarrow> Q v = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>a adjs Q \\<pi>.\n       \\<lbrakk>\\<And>Q \\<pi>.\n                   set adjs\n                   \\<subseteq> {(v, d).\n                                (u, v) \\<in> edges g \\<and>\n                                w {u, v} = d} \\<Longrightarrow>\n                   foldr (foreach_body u) adjs (Q, \\<pi>) =\n                   (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs);\n        set (a # adjs)\n        \\<subseteq> {(v, d).\n                     (u, v) \\<in> edges g \\<and> w {u, v} = d}\\<rbrakk>\n       \\<Longrightarrow> foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n                         (Qigen Q \\<pi> u (a # adjs),\n                          \\<pi>'gen Q \\<pi> u (a # adjs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n    (Qigen Q \\<pi> u (a # adjs), \\<pi>'gen Q \\<pi> u (a # adjs))", "using Cons.prems"], ["proof (prove)\nusing this:\n  set (a # adjs)\n  \\<subseteq> {a. case a of\n                  (v, d) \\<Rightarrow>\n                    (u, v) \\<in> edges g \\<and> w {u, v} = d}\n\ngoal (1 subgoal):\n 1. foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n    (Qigen Q \\<pi> u (a # adjs), \\<pi>'gen Q \\<pi> u (a # adjs))", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>set (a # adjs)\n                \\<subseteq> {a. case a of\n                                (v, d) \\<Rightarrow>\n                                  (u, v) \\<in> edges g \\<and> w {u, v} = d};\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n                         (Qigen Q \\<pi> u (a # adjs),\n                          \\<pi>'gen Q \\<pi> u (a # adjs))", "apply (clarsimp simp: Cons.IH)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = w {u, v}; (u, v) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d}\\<rbrakk>\n    \\<Longrightarrow> foreach_body u (v, w {u, v})\n                       (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs) =\n                      (Qigen Q \\<pi> u ((v, w {u, v}) # adjs),\n                       \\<pi>'gen Q \\<pi> u ((v, w {u, v}) # adjs))", "unfolding foreach_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = w {u, v}; (u, v) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d}\\<rbrakk>\n    \\<Longrightarrow> (case (v, w {u, v}) of\n                       (v, d) \\<Rightarrow>\n                         \\<lambda>(Q, \\<pi>).\n                            if v = r then (Q, \\<pi>)\n                            else case (Q v, \\<pi> v) of\n                                 (enat d', x) \\<Rightarrow>\n                                   if d < d'\n                                   then (Q(v := enat d), \\<pi>(v \\<mapsto>\n   u))\n                                   else (Q, \\<pi>)\n                                 | (\\<infinity>, None) \\<Rightarrow>\n                                     (Q(v := enat d), \\<pi>(v \\<mapsto> u))\n                                 | (\\<infinity>, Some xa) \\<Rightarrow>\n                                     (Q, \\<pi>))\n                       (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs) =\n                      (Qigen Q \\<pi> u ((v, w {u, v}) # adjs),\n                       \\<pi>'gen Q \\<pi> u ((v, w {u, v}) # adjs))", "apply (clarsimp; safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>d = w {u, r}; (u, r) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d};\n     v = r\\<rbrakk>\n    \\<Longrightarrow> Qigen Q \\<pi> u adjs =\n                      Qigen Q \\<pi> u ((r, w {u, r}) # adjs)\n 2. \\<lbrakk>d = w {u, r}; (u, r) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d};\n     v = r\\<rbrakk>\n    \\<Longrightarrow> \\<pi>'gen Q \\<pi> u adjs =\n                      \\<pi>'gen Q \\<pi> u ((r, w {u, r}) # adjs)\n 3. \\<lbrakk>d = w {u, v}; (u, v) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d};\n     v \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> (case Qigen Q \\<pi> u adjs v of\n                       enat d' \\<Rightarrow>\n                         if w {u, v} < d'\n                         then ((Qigen Q \\<pi> u adjs)(v := enat (w {u, v})),\n                               \\<pi>'gen Q \\<pi> u adjs(v \\<mapsto> u))\n                         else (Qigen Q \\<pi> u adjs,\n                               \\<pi>'gen Q \\<pi> u adjs)\n                       | \\<infinity> \\<Rightarrow>\n                           case \\<pi>'gen Q \\<pi> u adjs v of\n                           None \\<Rightarrow>\n                             ((Qigen Q \\<pi> u adjs)(v := enat (w {u, v})),\n                              \\<pi>'gen Q \\<pi> u adjs(v \\<mapsto> u))\n                           | Some x \\<Rightarrow>\n                               (Qigen Q \\<pi> u adjs,\n                                \\<pi>'gen Q \\<pi> u adjs)) =\n                      (Qigen Q \\<pi> u ((v, w {u, v}) # adjs),\n                       \\<pi>'gen Q \\<pi> u ((v, w {u, v}) # adjs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = w {u, r}; (u, r) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d};\n     v = r\\<rbrakk>\n    \\<Longrightarrow> Qigen Q \\<pi> u adjs =\n                      Qigen Q \\<pi> u ((r, w {u, r}) # adjs)", "by (auto simp: Qigen_def Qinter_def upd_cond_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>d = w {u, r}; (u, r) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d};\n     v = r\\<rbrakk>\n    \\<Longrightarrow> \\<pi>'gen Q \\<pi> u adjs =\n                      \\<pi>'gen Q \\<pi> u ((r, w {u, r}) # adjs)\n 2. \\<lbrakk>d = w {u, v}; (u, v) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d};\n     v \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> (case Qigen Q \\<pi> u adjs v of\n                       enat d' \\<Rightarrow>\n                         if w {u, v} < d'\n                         then ((Qigen Q \\<pi> u adjs)(v := enat (w {u, v})),\n                               \\<pi>'gen Q \\<pi> u adjs(v \\<mapsto> u))\n                         else (Qigen Q \\<pi> u adjs,\n                               \\<pi>'gen Q \\<pi> u adjs)\n                       | \\<infinity> \\<Rightarrow>\n                           case \\<pi>'gen Q \\<pi> u adjs v of\n                           None \\<Rightarrow>\n                             ((Qigen Q \\<pi> u adjs)(v := enat (w {u, v})),\n                              \\<pi>'gen Q \\<pi> u adjs(v \\<mapsto> u))\n                           | Some x \\<Rightarrow>\n                               (Qigen Q \\<pi> u adjs,\n                                \\<pi>'gen Q \\<pi> u adjs)) =\n                      (Qigen Q \\<pi> u ((v, w {u, v}) # adjs),\n                       \\<pi>'gen Q \\<pi> u ((v, w {u, v}) # adjs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = w {u, r}; (u, r) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d};\n     v = r\\<rbrakk>\n    \\<Longrightarrow> \\<pi>'gen Q \\<pi> u adjs =\n                      \\<pi>'gen Q \\<pi> u ((r, w {u, r}) # adjs)", "by (auto simp: \\<pi>'gen_def \\<pi>'_def upd_cond_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = w {u, v}; (u, v) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d};\n     v \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> (case Qigen Q \\<pi> u adjs v of\n                       enat d' \\<Rightarrow>\n                         if w {u, v} < d'\n                         then ((Qigen Q \\<pi> u adjs)(v := enat (w {u, v})),\n                               \\<pi>'gen Q \\<pi> u adjs(v \\<mapsto> u))\n                         else (Qigen Q \\<pi> u adjs,\n                               \\<pi>'gen Q \\<pi> u adjs)\n                       | \\<infinity> \\<Rightarrow>\n                           case \\<pi>'gen Q \\<pi> u adjs v of\n                           None \\<Rightarrow>\n                             ((Qigen Q \\<pi> u adjs)(v := enat (w {u, v})),\n                              \\<pi>'gen Q \\<pi> u adjs(v \\<mapsto> u))\n                           | Some x \\<Rightarrow>\n                               (Qigen Q \\<pi> u adjs,\n                                \\<pi>'gen Q \\<pi> u adjs)) =\n                      (Qigen Q \\<pi> u ((v, w {u, v}) # adjs),\n                       \\<pi>'gen Q \\<pi> u ((v, w {u, v}) # adjs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = w {u, v}; (u, v) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d};\n     v \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> (case Qigen Q \\<pi> u adjs v of\n                       enat d' \\<Rightarrow>\n                         if w {u, v} < d'\n                         then ((Qigen Q \\<pi> u adjs)(v := enat (w {u, v})),\n                               \\<pi>'gen Q \\<pi> u adjs(v \\<mapsto> u))\n                         else (Qigen Q \\<pi> u adjs,\n                               \\<pi>'gen Q \\<pi> u adjs)\n                       | \\<infinity> \\<Rightarrow>\n                           case \\<pi>'gen Q \\<pi> u adjs v of\n                           None \\<Rightarrow>\n                             ((Qigen Q \\<pi> u adjs)(v := enat (w {u, v})),\n                              \\<pi>'gen Q \\<pi> u adjs(v \\<mapsto> u))\n                           | Some x \\<Rightarrow>\n                               (Qigen Q \\<pi> u adjs,\n                                \\<pi>'gen Q \\<pi> u adjs)) =\n                      (Qigen Q \\<pi> u ((v, w {u, v}) # adjs),\n                       \\<pi>'gen Q \\<pi> u ((v, w {u, v}) # adjs))", "apply (clarsimp split: enat.split option.split simp: \\<pi>c Qc fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = w {u, v}; (u, v) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d};\n     v \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> (\\<pi>'gen Q \\<pi> u adjs v = None \\<longrightarrow>\n                       (\\<forall>nat.\n                           (w {u, v} < nat \\<longrightarrow>\n                            Qigen Q \\<pi> u adjs v =\n                            enat nat \\<longrightarrow>\n                            enat (w {u, v}) = Qinter Q \\<pi> u v \\<and>\n                            Some u = \\<pi>' Q \\<pi> u v) \\<and>\n                           (\\<not> w {u, v} < nat \\<longrightarrow>\n                            Qigen Q \\<pi> u adjs v =\n                            enat nat \\<longrightarrow>\n                            enat nat = Qinter Q \\<pi> u v \\<and>\n                            None = \\<pi>' Q \\<pi> u v)) \\<and>\n                       (Qigen Q \\<pi> u adjs v =\n                        \\<infinity> \\<longrightarrow>\n                        enat (w {u, v}) = Qinter Q \\<pi> u v \\<and>\n                        Some u = \\<pi>' Q \\<pi> u v)) \\<and>\n                      (\\<forall>x2.\n                          \\<pi>'gen Q \\<pi> u adjs v =\n                          Some x2 \\<longrightarrow>\n                          (\\<forall>nat.\n                              (w {u, v} < nat \\<longrightarrow>\n                               Qigen Q \\<pi> u adjs v =\n                               enat nat \\<longrightarrow>\n                               enat (w {u, v}) = Qinter Q \\<pi> u v \\<and>\n                               Some u = \\<pi>' Q \\<pi> u v) \\<and>\n                              (\\<not> w {u, v} < nat \\<longrightarrow>\n                               Qigen Q \\<pi> u adjs v =\n                               enat nat \\<longrightarrow>\n                               enat nat = Qinter Q \\<pi> u v \\<and>\n                               Some x2 = \\<pi>' Q \\<pi> u v)) \\<and>\n                          (Qigen Q \\<pi> u adjs v =\n                           \\<infinity> \\<longrightarrow>\n                           \\<infinity> = Qinter Q \\<pi> u v \\<and>\n                           Some x2 = \\<pi>' Q \\<pi> u v))", "unfolding Qinter_def Qigen_def \\<pi>'_def \\<pi>'gen_def upd_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = w {u, v}; (u, v) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d};\n     v \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> ((if v \\<notin> fst ` set adjs then \\<pi> v\n                        else if (v, u) \\<in> edges g \\<and>\n                                v \\<noteq> r \\<and>\n                                (Q v = \\<infinity> \\<longrightarrow>\n                                 \\<pi> v = None) \\<and>\n                                enat (w {v, u}) < Q v\n                             then Some u else \\<pi> v) =\n                       None \\<longrightarrow>\n                       (\\<forall>nat.\n                           (w {u, v} < nat \\<longrightarrow>\n                            (if v \\<notin> fst ` set adjs then Q v\n                             else if (v, u) \\<in> edges g \\<and>\n                                     v \\<noteq> r \\<and>\n                                     (Q v = \\<infinity> \\<longrightarrow>\n\\<pi> v = None) \\<and>\n                                     enat (w {v, u}) < Q v\n                                  then enat (w {v, u}) else Q v) =\n                            enat nat \\<longrightarrow>\n                            enat (w {u, v}) =\n                            (if (v, u) \\<in> edges g \\<and>\n                                v \\<noteq> r \\<and>\n                                (Q v = \\<infinity> \\<longrightarrow>\n                                 \\<pi> v = None) \\<and>\n                                enat (w {v, u}) < Q v\n                             then enat (w {v, u}) else Q v) \\<and>\n                            Some u =\n                            (if (v, u) \\<in> edges g \\<and>\n                                v \\<noteq> r \\<and>\n                                (Q v = \\<infinity> \\<longrightarrow>\n                                 \\<pi> v = None) \\<and>\n                                enat (w {v, u}) < Q v\n                             then Some u else \\<pi> v)) \\<and>\n                           (\\<not> w {u, v} < nat \\<longrightarrow>\n                            (if v \\<notin> fst ` set adjs then Q v\n                             else if (v, u) \\<in> edges g \\<and>\n                                     v \\<noteq> r \\<and>\n                                     (Q v = \\<infinity> \\<longrightarrow>\n\\<pi> v = None) \\<and>\n                                     enat (w {v, u}) < Q v\n                                  then enat (w {v, u}) else Q v) =\n                            enat nat \\<longrightarrow>\n                            enat nat =\n                            (if (v, u) \\<in> edges g \\<and>\n                                v \\<noteq> r \\<and>\n                                (Q v = \\<infinity> \\<longrightarrow>\n                                 \\<pi> v = None) \\<and>\n                                enat (w {v, u}) < Q v\n                             then enat (w {v, u}) else Q v) \\<and>\n                            None =\n                            (if (v, u) \\<in> edges g \\<and>\n                                v \\<noteq> r \\<and>\n                                (Q v = \\<infinity> \\<longrightarrow>\n                                 \\<pi> v = None) \\<and>\n                                enat (w {v, u}) < Q v\n                             then Some u else \\<pi> v))) \\<and>\n                       ((if v \\<notin> fst ` set adjs then Q v\n                         else if (v, u) \\<in> edges g \\<and>\n                                 v \\<noteq> r \\<and>\n                                 (Q v = \\<infinity> \\<longrightarrow>\n                                  \\<pi> v = None) \\<and>\n                                 enat (w {v, u}) < Q v\n                              then enat (w {v, u}) else Q v) =\n                        \\<infinity> \\<longrightarrow>\n                        enat (w {u, v}) =\n                        (if (v, u) \\<in> edges g \\<and>\n                            v \\<noteq> r \\<and>\n                            (Q v = \\<infinity> \\<longrightarrow>\n                             \\<pi> v = None) \\<and>\n                            enat (w {v, u}) < Q v\n                         then enat (w {v, u}) else Q v) \\<and>\n                        Some u =\n                        (if (v, u) \\<in> edges g \\<and>\n                            v \\<noteq> r \\<and>\n                            (Q v = \\<infinity> \\<longrightarrow>\n                             \\<pi> v = None) \\<and>\n                            enat (w {v, u}) < Q v\n                         then Some u else \\<pi> v))) \\<and>\n                      (\\<forall>x2.\n                          (if v \\<notin> fst ` set adjs then \\<pi> v\n                           else if (v, u) \\<in> edges g \\<and>\n                                   v \\<noteq> r \\<and>\n                                   (Q v = \\<infinity> \\<longrightarrow>\n                                    \\<pi> v = None) \\<and>\n                                   enat (w {v, u}) < Q v\n                                then Some u else \\<pi> v) =\n                          Some x2 \\<longrightarrow>\n                          (\\<forall>nat.\n                              (w {u, v} < nat \\<longrightarrow>\n                               (if v \\<notin> fst ` set adjs then Q v\n                                else if (v, u) \\<in> edges g \\<and>\n  v \\<noteq> r \\<and>\n  (Q v = \\<infinity> \\<longrightarrow> \\<pi> v = None) \\<and>\n  enat (w {v, u}) < Q v\n                                     then enat (w {v, u}) else Q v) =\n                               enat nat \\<longrightarrow>\n                               enat (w {u, v}) =\n                               (if (v, u) \\<in> edges g \\<and>\n                                   v \\<noteq> r \\<and>\n                                   (Q v = \\<infinity> \\<longrightarrow>\n                                    \\<pi> v = None) \\<and>\n                                   enat (w {v, u}) < Q v\n                                then enat (w {v, u}) else Q v) \\<and>\n                               Some u =\n                               (if (v, u) \\<in> edges g \\<and>\n                                   v \\<noteq> r \\<and>\n                                   (Q v = \\<infinity> \\<longrightarrow>\n                                    \\<pi> v = None) \\<and>\n                                   enat (w {v, u}) < Q v\n                                then Some u else \\<pi> v)) \\<and>\n                              (\\<not> w {u, v} < nat \\<longrightarrow>\n                               (if v \\<notin> fst ` set adjs then Q v\n                                else if (v, u) \\<in> edges g \\<and>\n  v \\<noteq> r \\<and>\n  (Q v = \\<infinity> \\<longrightarrow> \\<pi> v = None) \\<and>\n  enat (w {v, u}) < Q v\n                                     then enat (w {v, u}) else Q v) =\n                               enat nat \\<longrightarrow>\n                               enat nat =\n                               (if (v, u) \\<in> edges g \\<and>\n                                   v \\<noteq> r \\<and>\n                                   (Q v = \\<infinity> \\<longrightarrow>\n                                    \\<pi> v = None) \\<and>\n                                   enat (w {v, u}) < Q v\n                                then enat (w {v, u}) else Q v) \\<and>\n                               Some x2 =\n                               (if (v, u) \\<in> edges g \\<and>\n                                   v \\<noteq> r \\<and>\n                                   (Q v = \\<infinity> \\<longrightarrow>\n                                    \\<pi> v = None) \\<and>\n                                   enat (w {v, u}) < Q v\n                                then Some u else \\<pi> v))) \\<and>\n                          ((if v \\<notin> fst ` set adjs then Q v\n                            else if (v, u) \\<in> edges g \\<and>\n                                    v \\<noteq> r \\<and>\n                                    (Q v = \\<infinity> \\<longrightarrow>\n                                     \\<pi> v = None) \\<and>\n                                    enat (w {v, u}) < Q v\n                                 then enat (w {v, u}) else Q v) =\n                           \\<infinity> \\<longrightarrow>\n                           \\<infinity> =\n                           (if (v, u) \\<in> edges g \\<and>\n                               v \\<noteq> r \\<and>\n                               (Q v = \\<infinity> \\<longrightarrow>\n                                \\<pi> v = None) \\<and>\n                               enat (w {v, u}) < Q v\n                            then enat (w {v, u}) else Q v) \\<and>\n                           Some x2 =\n                           (if (v, u) \\<in> edges g \\<and>\n                               v \\<noteq> r \\<and>\n                               (Q v = \\<infinity> \\<longrightarrow>\n                                \\<pi> v = None) \\<and>\n                               enat (w {v, u}) < Q v\n                            then Some u else \\<pi> v)))", "apply (safe; simp split: if_splits add: insert_commute)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>w {u, v} < nat; Q v = enat nat; d = w {u, v};\n        (u, v) \\<in> edges g;\n        set adjs\n        \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {v, u} = d};\n        v \\<noteq> r; v \\<notin> fst ` set adjs; \\<pi> v = None\\<rbrakk>\n       \\<Longrightarrow> (v, u) \\<in> edges g\n 2. \\<And>nat.\n       \\<lbrakk>d = w {u, v}; (u, v) \\<in> edges g;\n        set adjs\n        \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {v, u} = d};\n        v \\<noteq> r; v \\<in> fst ` set adjs; \\<pi> v = None;\n        w {u, v} < nat; (v, u) \\<notin> edges g; Q v = enat nat\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>nat.\n       \\<lbrakk>w {u, v} < nat; Q v = enat nat; d = w {u, v};\n        (u, v) \\<in> edges g;\n        set adjs\n        \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {v, u} = d};\n        v \\<noteq> r; v \\<notin> fst ` set adjs; \\<pi> v = None\\<rbrakk>\n       \\<Longrightarrow> (v, u) \\<in> edges g\n 4. \\<And>nat.\n       \\<lbrakk>d = w {u, v}; (u, v) \\<in> edges g;\n        set adjs\n        \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {v, u} = d};\n        v \\<noteq> r; v \\<in> fst ` set adjs; \\<pi> v = None;\n        w {u, v} < nat; (v, u) \\<notin> edges g; Q v = enat nat\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<lbrakk>Q v = \\<infinity>; d = w {u, v}; (u, v) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {v, u} = d};\n     v \\<noteq> r; v \\<notin> fst ` set adjs; \\<pi> v = None\\<rbrakk>\n    \\<Longrightarrow> (v, u) \\<in> edges g\n 6. \\<lbrakk>(v, u) \\<notin> edges g; Q v = \\<infinity>; d = w {u, v};\n     (u, v) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {v, u} = d};\n     v \\<noteq> r; v \\<in> fst ` set adjs; \\<pi> v = None\\<rbrakk>\n    \\<Longrightarrow> False\n 7. \\<lbrakk>Q v = \\<infinity>; d = w {u, v}; (u, v) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {v, u} = d};\n     v \\<noteq> r; v \\<notin> fst ` set adjs; \\<pi> v = None\\<rbrakk>\n    \\<Longrightarrow> (v, u) \\<in> edges g\n 8. \\<lbrakk>(v, u) \\<notin> edges g; Q v = \\<infinity>; d = w {u, v};\n     (u, v) \\<in> edges g;\n     set adjs\n     \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {v, u} = d};\n     v \\<noteq> r; v \\<in> fst ` set adjs; \\<pi> v = None\\<rbrakk>\n    \\<Longrightarrow> False\n 9. \\<And>x2 nat.\n       \\<lbrakk>w {u, v} < nat; Q v = enat nat; d = w {u, v};\n        (u, v) \\<in> edges g;\n        set adjs\n        \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {v, u} = d};\n        v \\<noteq> r; v \\<notin> fst ` set adjs; \\<pi> v = Some x2\\<rbrakk>\n       \\<Longrightarrow> (v, u) \\<in> edges g\n 10. \\<And>x2 nat.\n        \\<lbrakk>d = w {u, v}; (u, v) \\<in> edges g;\n         set adjs\n         \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {v, u} = d};\n         v \\<noteq> r; v \\<in> fst ` set adjs; \\<pi> v = Some x2;\n         w {u, v} < nat; (v, u) \\<notin> edges g; Q v = enat nat\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 14 subgoals...", "by (auto dest: edges_sym')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  foldr (foreach_body u) (a # adjs) (Q, \\<pi>) =\n  (Qigen Q \\<pi> u (a # adjs), \\<pi>'gen Q \\<pi> u (a # adjs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foreach_refine:\n  assumes \"set adjs = {(v,d). (u,v)\\<in>edges g \\<and> w {u,v} = d}\"\n  shows \"foreach u adjs (Q,\\<pi>) = (Qinter Q \\<pi> u,\\<pi>' Q \\<pi> u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foreach u adjs (Q, \\<pi>) = (Qinter Q \\<pi> u, \\<pi>' Q \\<pi> u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foreach u adjs (Q, \\<pi>) = (Qinter Q \\<pi> u, \\<pi>' Q \\<pi> u)", "have INVAR_INIT: \"Qigen Q \\<pi> u [] = Q\" \"\\<pi>'gen Q \\<pi> u [] = \\<pi>\" for Q \\<pi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Qigen Q \\<pi> u [] = Q &&& \\<pi>'gen Q \\<pi> u [] = \\<pi>", "unfolding assms Qigen_def \\<pi>'gen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        if v \\<notin> fst ` set [] then Q v else Qinter Q \\<pi> u v) =\n    Q &&&\n    (\\<lambda>v.\n        if v \\<notin> fst ` set [] then \\<pi> v else \\<pi>' Q \\<pi> u v) =\n    \\<pi>", "by (auto simp: fun_eq_iff image_def Q'_def \\<pi>'_def edges_def)"], ["proof (state)\nthis:\n  Qigen ?Q9 ?\\<pi>9 u [] = ?Q9\n  \\<pi>'gen ?Q9 ?\\<pi>9 u [] = ?\\<pi>9\n\ngoal (1 subgoal):\n 1. foreach u adjs (Q, \\<pi>) = (Qinter Q \\<pi> u, \\<pi>' Q \\<pi> u)", "from assms"], ["proof (chain)\npicking this:\n  set adjs = {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d}", "have 1: \"set adjs \\<subseteq> {(v,d). (u,v)\\<in>edges g \\<and> w {u,v} = d}\""], ["proof (prove)\nusing this:\n  set adjs = {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d}\n\ngoal (1 subgoal):\n 1. set adjs \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d}", "by simp"], ["proof (state)\nthis:\n  set adjs \\<subseteq> {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d}\n\ngoal (1 subgoal):\n 1. foreach u adjs (Q, \\<pi>) = (Qinter Q \\<pi> u, \\<pi>' Q \\<pi> u)", "have [simp]: \n    \"v \\<in> fst ` {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d} \n    \\<longleftrightarrow> (u,v)\\<in>edges g\" \n    for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> fst ` {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d}) =\n    ((u, v) \\<in> edges g)", "by force"], ["proof (state)\nthis:\n  (?v9 \\<in> fst ` {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d}) =\n  ((u, ?v9) \\<in> edges g)\n\ngoal (1 subgoal):\n 1. foreach u adjs (Q, \\<pi>) = (Qinter Q \\<pi> u, \\<pi>' Q \\<pi> u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. foreach u adjs (Q, \\<pi>) = (Qinter Q \\<pi> u, \\<pi>' Q \\<pi> u)", "unfolding foreach_refine_gen[OF 1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Qigen Q \\<pi> u adjs, \\<pi>'gen Q \\<pi> u adjs) =\n    (Qinter Q \\<pi> u, \\<pi>' Q \\<pi> u)", "unfolding Qigen_def \\<pi>'gen_def assms upd_cond_def Qinter_def \\<pi>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        if v \\<notin> fst `\n                      {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d}\n        then Q v\n        else if (v, u) \\<in> edges g \\<and>\n                v \\<noteq> r \\<and>\n                (Q v = \\<infinity> \\<longrightarrow> \\<pi> v = None) \\<and>\n                enat (w {v, u}) < Q v\n             then enat (w {v, u}) else Q v,\n     \\<lambda>v.\n        if v \\<notin> fst `\n                      {(v, d). (u, v) \\<in> edges g \\<and> w {u, v} = d}\n        then \\<pi> v\n        else if (v, u) \\<in> edges g \\<and>\n                v \\<noteq> r \\<and>\n                (Q v = \\<infinity> \\<longrightarrow> \\<pi> v = None) \\<and>\n                enat (w {v, u}) < Q v\n             then Some u else \\<pi> v) =\n    (\\<lambda>v'.\n        if (v', u) \\<in> edges g \\<and>\n           v' \\<noteq> r \\<and>\n           (Q v' = \\<infinity> \\<longrightarrow> \\<pi> v' = None) \\<and>\n           enat (w {v', u}) < Q v'\n        then enat (w {v', u}) else Q v',\n     \\<lambda>v'.\n        if (v', u) \\<in> edges g \\<and>\n           v' \\<noteq> r \\<and>\n           (Q v' = \\<infinity> \\<longrightarrow> \\<pi> v' = None) \\<and>\n           enat (w {v', u}) < Q v'\n        then Some u else \\<pi> v')", "by (auto simp: fun_eq_iff image_def dest: edges_sym')"], ["proof (state)\nthis:\n  foreach u adjs (Q, \\<pi>) = (Qinter Q \\<pi> u, \\<pi>' Q \\<pi> u)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"]]}