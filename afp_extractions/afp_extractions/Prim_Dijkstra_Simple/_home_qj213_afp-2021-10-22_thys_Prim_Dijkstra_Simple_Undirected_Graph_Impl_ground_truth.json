{"file_name": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple/Undirected_Graph_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple", "problem_names": ["lemma epair_eqD: \"epair e = Some (x,y) \\<Longrightarrow> (x\\<noteq>y \\<and> e={x,y})\"", "lemma epair_not_sng[simp]: \"epair e \\<noteq> Some (x,x)\"", "lemma epair_None[simp]: \"epair {a,b} = None \\<longleftrightarrow> a=b\"", "lemma in_the_default_empty_conv[simp]: \n  \"x\\<in>set (the_default [] m) \\<longleftrightarrow> (\\<exists>xs. m=Some xs \\<and> x\\<in>set xs)\"", "lemma \\<alpha>edges_irrefl: \"invar g \\<Longrightarrow> irrefl (\\<alpha>edges_aux g)\"", "lemma \\<alpha>edges_sym: \"invar g \\<Longrightarrow> sym (\\<alpha>edges_aux g)\"", "lemma \\<alpha>edges_subset: \"invar g \\<Longrightarrow> \\<alpha>edges_aux g \\<subseteq> \\<alpha>nodes_aux g \\<times> \\<alpha>nodes_aux g\"", "lemma \\<alpha>nodes_finite[simp, intro!]: \"invar g \\<Longrightarrow> finite (\\<alpha>nodes_aux g)\"", "lemma \\<alpha>edges_finite[simp, intro!]: \"invar g \\<Longrightarrow> finite (\\<alpha>edges_aux g)\"", "lemma edges_\\<alpha>g_aux: \"invar g \\<Longrightarrow> edges (\\<alpha>g g) = \\<alpha>edges_aux g\"", "lemma nodes_\\<alpha>g_aux: \"invar g \\<Longrightarrow> nodes (\\<alpha>g g) = \\<alpha>nodes_aux g\"", "lemma card_doubleton_eq2[simp]: \"card {a,b} = 2 \\<longleftrightarrow> a\\<noteq>b\"", "lemma the_dflt_Z_eq: \"the_default 0 m = d \\<longleftrightarrow> (m=None \\<and> d=0 \\<or> m=Some d)\"", "lemma adj_correct_aux:\n  \"invar g \\<Longrightarrow> set (adj g u) = {(v, d). (u, v) \\<in> edges (\\<alpha>g g) \\<and> \\<alpha>w g {u, v} = d}\"", "lemma invar_empty_aux: \"invar empty\"", "lemma dist_fst_the_dflt_aux: \"distinct (map fst (the_default [] m)) \n  \\<longleftrightarrow> (\\<forall>xs. m = Some xs \\<longrightarrow> distinct (map fst xs))\"", "lemma invar_add_edge_aux: \n  \"\\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g); u \\<noteq> v\\<rbrakk> \\<Longrightarrow> invar (add_edge (u, v) d g)\""], "translations": [["", "lemma epair_eqD: \"epair e = Some (x,y) \\<Longrightarrow> (x\\<noteq>y \\<and> e={x,y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epair e = Some (x, y) \\<Longrightarrow> x \\<noteq> y \\<and> e = {x, y}", "apply (cases \"card e = 2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>epair e = Some (x, y); card e = 2\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y \\<and> e = {x, y}\n 2. \\<lbrakk>epair e = Some (x, y); card e \\<noteq> 2\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y \\<and> e = {x, y}", "unfolding epair_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if card e = 2 then Some (SOME (u, v). e = {u, v}) else None) =\n             Some (x, y);\n     card e = 2\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y \\<and> e = {x, y}\n 2. \\<lbrakk>(if card e = 2 then Some (SOME (u, v). e = {u, v}) else None) =\n             Some (x, y);\n     card e \\<noteq> 2\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y \\<and> e = {x, y}", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(SOME (u, v). e = {u, v}) = (x, y); card e = 2\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> y \\<and> e = {x, y}", "apply (clarsimp simp: card_Suc_eq eval_nat_numeral doubleton_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b ba.\n       \\<lbrakk>(SOME (u, v).\n                    b = u \\<and> ba = v \\<or> b = v \\<and> ba = u) =\n                (x, y);\n        e = {b, ba};\n        x = y \\<or>\n        (b = x \\<longrightarrow> ba \\<noteq> y) \\<and>\n        (b = y \\<longrightarrow> ba \\<noteq> x)\\<rbrakk>\n       \\<Longrightarrow> b = ba", "by (smt case_prodD case_prodI someI)"], ["", "lemma epair_not_sng[simp]: \"epair e \\<noteq> Some (x,x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epair e \\<noteq> Some (x, x)", "by (auto dest: epair_eqD)"], ["", "lemma epair_None[simp]: \"epair {a,b} = None \\<longleftrightarrow> a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (epair {a, b} = None) = (a = b)", "unfolding epair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if card {a, b} = 2 then Some (SOME (u, v). {a, b} = {u, v})\n      else None) =\n     None) =\n    (a = b)", "by (auto simp: card2_eq)"], ["", "subsection \\<open>Generic Implementation\\<close>"], ["", "text \\<open>\n  When instantiated with a map ADT, this locale provides a weighted graph ADT.\n\\<close>"], ["", "locale wgraph_by_map = \n  M: Map M_empty M_update M_delete M_lookup M_invar \n  \n  for M_empty M_update M_delete \n  and M_lookup :: \"'m \\<Rightarrow> 'v \\<Rightarrow> (('v\\<times>nat) list) option\" \n  and M_invar \nbegin"], ["", "definition \"\\<alpha>nodes_aux g \\<equiv> dom (M_lookup g)\""], ["", "definition \"\\<alpha>edges_aux g \n  \\<equiv> ({(u,v). \\<exists>xs d. M_lookup g u = Some xs \\<and> (v,d)\\<in>set xs })\""], ["", "definition \"\\<alpha>g g \\<equiv> graph (\\<alpha>nodes_aux g) (\\<alpha>edges_aux g)\""], ["", "definition \"\\<alpha>w g e \\<equiv> case epair e of \n  Some (u,v) \\<Rightarrow> (\n    case M_lookup g u of \n      None \\<Rightarrow> 0 \n    | Some xs \\<Rightarrow> the_default 0 (map_of xs v)\n    )\n| None \\<Rightarrow> 0\""], ["", "definition invar :: \"'m \\<Rightarrow> bool\" where\n  \"invar g \\<equiv> \n      M_invar g \\<and> finite (dom (M_lookup g))\n    \\<and> (\\<forall>u xs. M_lookup g u = Some xs \\<longrightarrow> \n          distinct (map fst xs) \n        \\<and> u\\<notin>set (map fst xs)\n        \\<and> (\\<forall>(v,d)\\<in>set xs. (u,d)\\<in>set (the_default [] (M_lookup g v)))\n      )\""], ["", "lemma in_the_default_empty_conv[simp]: \n  \"x\\<in>set (the_default [] m) \\<longleftrightarrow> (\\<exists>xs. m=Some xs \\<and> x\\<in>set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (the_default [] m)) =\n    (\\<exists>xs. m = Some xs \\<and> x \\<in> set xs)", "by (cases m) auto"], ["", "lemma \\<alpha>edges_irrefl: \"invar g \\<Longrightarrow> irrefl (\\<alpha>edges_aux g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow> irrefl (\\<alpha>edges_aux g)", "unfolding invar_def irrefl_def \\<alpha>edges_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M_invar g \\<and>\n    finite (dom (M_lookup g)) \\<and>\n    (\\<forall>u xs.\n        M_lookup g u = Some xs \\<longrightarrow>\n        distinct (map fst xs) \\<and>\n        u \\<notin> set (map fst xs) \\<and>\n        (\\<forall>(v, d)\\<in>set xs.\n            (u, d)\n            \\<in> set (the_default [] (M_lookup g v)))) \\<Longrightarrow>\n    \\<forall>a.\n       (a, a)\n       \\<notin> {(u, v).\n                 \\<exists>xs d.\n                    M_lookup g u = Some xs \\<and> (v, d) \\<in> set xs}", "by (force)"], ["", "lemma \\<alpha>edges_sym: \"invar g \\<Longrightarrow> sym (\\<alpha>edges_aux g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow> sym (\\<alpha>edges_aux g)", "unfolding invar_def sym_def \\<alpha>edges_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M_invar g \\<and>\n    finite (dom (M_lookup g)) \\<and>\n    (\\<forall>u xs.\n        M_lookup g u = Some xs \\<longrightarrow>\n        distinct (map fst xs) \\<and>\n        u \\<notin> set (map fst xs) \\<and>\n        (\\<forall>(v, d)\\<in>set xs.\n            (u, d)\n            \\<in> set (the_default [] (M_lookup g v)))) \\<Longrightarrow>\n    \\<forall>x y.\n       (x, y)\n       \\<in> {(u, v).\n              \\<exists>xs d.\n                 M_lookup g u = Some xs \\<and>\n                 (v, d) \\<in> set xs} \\<longrightarrow>\n       (y, x)\n       \\<in> {(u, v).\n              \\<exists>xs d.\n                 M_lookup g u = Some xs \\<and> (v, d) \\<in> set xs}", "by force"], ["", "lemma \\<alpha>edges_subset: \"invar g \\<Longrightarrow> \\<alpha>edges_aux g \\<subseteq> \\<alpha>nodes_aux g \\<times> \\<alpha>nodes_aux g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    \\<alpha>edges_aux g\n    \\<subseteq> \\<alpha>nodes_aux g \\<times> \\<alpha>nodes_aux g", "unfolding invar_def \\<alpha>nodes_aux_def \\<alpha>edges_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M_invar g \\<and>\n    finite (dom (M_lookup g)) \\<and>\n    (\\<forall>u xs.\n        M_lookup g u = Some xs \\<longrightarrow>\n        distinct (map fst xs) \\<and>\n        u \\<notin> set (map fst xs) \\<and>\n        (\\<forall>(v, d)\\<in>set xs.\n            (u, d)\n            \\<in> set (the_default [] (M_lookup g v)))) \\<Longrightarrow>\n    {(u, v).\n     \\<exists>xs d. M_lookup g u = Some xs \\<and> (v, d) \\<in> set xs}\n    \\<subseteq> dom (M_lookup g) \\<times> dom (M_lookup g)", "by force"], ["", "lemma \\<alpha>nodes_finite[simp, intro!]: \"invar g \\<Longrightarrow> finite (\\<alpha>nodes_aux g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow> finite (\\<alpha>nodes_aux g)", "unfolding invar_def \\<alpha>nodes_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M_invar g \\<and>\n    finite (dom (M_lookup g)) \\<and>\n    (\\<forall>u xs.\n        M_lookup g u = Some xs \\<longrightarrow>\n        distinct (map fst xs) \\<and>\n        u \\<notin> set (map fst xs) \\<and>\n        (\\<forall>(v, d)\\<in>set xs.\n            (u, d)\n            \\<in> set (the_default [] (M_lookup g v)))) \\<Longrightarrow>\n    finite (dom (M_lookup g))", "by simp"], ["", "lemma \\<alpha>edges_finite[simp, intro!]: \"invar g \\<Longrightarrow> finite (\\<alpha>edges_aux g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow> finite (\\<alpha>edges_aux g)", "using finite_subset[OF \\<alpha>edges_subset]"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar ?g1;\n   finite (\\<alpha>nodes_aux ?g1 \\<times> \\<alpha>nodes_aux ?g1)\\<rbrakk>\n  \\<Longrightarrow> finite (\\<alpha>edges_aux ?g1)\n\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow> finite (\\<alpha>edges_aux g)", "by blast"], ["", "definition adj :: \"'m \\<Rightarrow> 'v \\<Rightarrow> ('v\\<times>nat) list\" where\n  \"adj g v = the_default [] (M_lookup g v)\""], ["", "definition empty :: \"'m\" where \"empty = M_empty\""], ["", "definition add_edge1 :: \"'v\\<times>'v \\<Rightarrow> nat \\<Rightarrow> 'm \\<Rightarrow> 'm\" where\n  \"add_edge1 \\<equiv> \\<lambda>(u,v) d g. M_update u ((v,d) # the_default [] (M_lookup g u)) g\""], ["", "definition add_edge :: \"'v\\<times>'v \\<Rightarrow> nat \\<Rightarrow> 'm \\<Rightarrow> 'm\" where\n  \"add_edge \\<equiv> \\<lambda>(u,v) d g. add_edge1 (v,u) d (add_edge1 (u,v) d g)\""], ["", "lemma edges_\\<alpha>g_aux: \"invar g \\<Longrightarrow> edges (\\<alpha>g g) = \\<alpha>edges_aux g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow> edges (\\<alpha>g g) = \\<alpha>edges_aux g", "unfolding \\<alpha>g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    edges (graph (\\<alpha>nodes_aux g) (\\<alpha>edges_aux g)) =\n    \\<alpha>edges_aux g", "using \\<alpha>edges_sym \\<alpha>edges_irrefl"], ["proof (prove)\nusing this:\n  invar ?g \\<Longrightarrow> sym (\\<alpha>edges_aux ?g)\n  invar ?g \\<Longrightarrow> irrefl (\\<alpha>edges_aux ?g)\n\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    edges (graph (\\<alpha>nodes_aux g) (\\<alpha>edges_aux g)) =\n    \\<alpha>edges_aux g", "by (auto simp: irrefl_def graph_accs)"], ["", "lemma nodes_\\<alpha>g_aux: \"invar g \\<Longrightarrow> nodes (\\<alpha>g g) = \\<alpha>nodes_aux g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow> nodes (\\<alpha>g g) = \\<alpha>nodes_aux g", "unfolding \\<alpha>g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    nodes (graph (\\<alpha>nodes_aux g) (\\<alpha>edges_aux g)) =\n    \\<alpha>nodes_aux g", "using \\<alpha>edges_subset"], ["proof (prove)\nusing this:\n  invar ?g \\<Longrightarrow>\n  \\<alpha>edges_aux ?g\n  \\<subseteq> \\<alpha>nodes_aux ?g \\<times> \\<alpha>nodes_aux ?g\n\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    nodes (graph (\\<alpha>nodes_aux g) (\\<alpha>edges_aux g)) =\n    \\<alpha>nodes_aux g", "by (force simp: graph_accs)"], ["", "lemma card_doubleton_eq2[simp]: \"card {a,b} = 2 \\<longleftrightarrow> a\\<noteq>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card {a, b} = 2) = (a \\<noteq> b)", "by auto"], ["", "lemma the_dflt_Z_eq: \"the_default 0 m = d \\<longleftrightarrow> (m=None \\<and> d=0 \\<or> m=Some d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the_default (0::'a) m = d) =\n    (m = None \\<and> d = (0::'a) \\<or> m = Some d)", "by (cases m) auto"], ["", "lemma adj_correct_aux:\n  \"invar g \\<Longrightarrow> set (adj g u) = {(v, d). (u, v) \\<in> edges (\\<alpha>g g) \\<and> \\<alpha>w g {u, v} = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    set (adj g u) =\n    {(v, d). (u, v) \\<in> edges (\\<alpha>g g) \\<and> \\<alpha>w g {u, v} = d}", "apply (simp add: edges_\\<alpha>g_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    set (adj g u) =\n    {(v, d). (u, v) \\<in> \\<alpha>edges_aux g \\<and> \\<alpha>w g {u, v} = d}", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>invar g; (a, b) \\<in> set (adj g u)\\<rbrakk>\n       \\<Longrightarrow> (u, a) \\<in> \\<alpha>edges_aux g\n 2. \\<And>a b.\n       \\<lbrakk>invar g; (a, b) \\<in> set (adj g u)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>w g {u, a} = b\n 3. \\<And>a b.\n       \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g\\<rbrakk>\n       \\<Longrightarrow> (a, \\<alpha>w g {u, a}) \\<in> set (adj g u)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (a_, b_) \\<in> set (adj g u)\\<rbrakk>\n    \\<Longrightarrow> (u, a_) \\<in> \\<alpha>edges_aux g", "unfolding adj_def \\<alpha>edges_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g;\n     (a_, b_) \\<in> set (the_default [] (M_lookup g u))\\<rbrakk>\n    \\<Longrightarrow> (u, a_)\n                      \\<in> {(u, v).\n                             \\<exists>xs d.\n                                M_lookup g u = Some xs \\<and>\n                                (v, d) \\<in> set xs}", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>invar g; (a, b) \\<in> set (adj g u)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>w g {u, a} = b\n 2. \\<And>a b.\n       \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g\\<rbrakk>\n       \\<Longrightarrow> (a, \\<alpha>w g {u, a}) \\<in> set (adj g u)", "subgoal for a d"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (a, d) \\<in> set (adj g u)\\<rbrakk>\n    \\<Longrightarrow> \\<alpha>w g {u, a} = d", "unfolding adj_def \\<alpha>w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g;\n     (a, d) \\<in> set (the_default [] (M_lookup g u))\\<rbrakk>\n    \\<Longrightarrow> (case epair {u, a} of None \\<Rightarrow> 0\n                       | Some (u, v) \\<Rightarrow>\n                           case M_lookup g u of None \\<Rightarrow> 0\n                           | Some xs \\<Rightarrow>\n                               the_default 0 (Map.map_of xs v)) =\n                      d", "apply (clarsimp split: prod.splits option.splits simp: the_dflt_Z_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>invar g; M_lookup g u = Some xs;\n        (a, d) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> (u = a \\<longrightarrow> d = 0) \\<and>\n                         (\\<forall>aa b.\n                             (M_lookup g aa = None \\<longrightarrow>\n                              epair {u, a} = Some (aa, b) \\<longrightarrow>\n                              d = 0) \\<and>\n                             (\\<forall>x2.\n                                 M_lookup g aa = Some x2 \\<longrightarrow>\n                                 epair {u, a} =\n                                 Some (aa, b) \\<longrightarrow>\n                                 Map.map_of x2 b = None \\<and> d = 0 \\<or>\n                                 Map.map_of x2 b = Some d))", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>M_invar g \\<and>\n                finite (dom (M_lookup g)) \\<and>\n                (\\<forall>u xs.\n                    M_lookup g u = Some xs \\<longrightarrow>\n                    distinct (map fst xs) \\<and>\n                    u \\<notin> set (map fst xs) \\<and>\n                    (\\<forall>(v, d)\\<in>set xs.\n                        (u, d) \\<in> set (the_default [] (M_lookup g v))));\n        M_lookup g u = Some xs; (a, d) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> (u = a \\<longrightarrow> d = 0) \\<and>\n                         (\\<forall>aa b.\n                             (M_lookup g aa = None \\<longrightarrow>\n                              epair {u, a} = Some (aa, b) \\<longrightarrow>\n                              d = 0) \\<and>\n                             (\\<forall>x2.\n                                 M_lookup g aa = Some x2 \\<longrightarrow>\n                                 epair {u, a} =\n                                 Some (aa, b) \\<longrightarrow>\n                                 Map.map_of x2 b = None \\<and> d = 0 \\<or>\n                                 Map.map_of x2 b = Some d))", "by (force dest!: epair_eqD simp: doubleton_eq_iff)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g\\<rbrakk>\n       \\<Longrightarrow> (a, \\<alpha>w g {u, a}) \\<in> set (adj g u)", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g\\<rbrakk>\n    \\<Longrightarrow> (a, \\<alpha>w g {u, a}) \\<in> set (adj g u)", "unfolding adj_def \\<alpha>w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g\\<rbrakk>\n    \\<Longrightarrow> (a, case epair {u, a} of None \\<Rightarrow> 0\n                          | Some (u, v) \\<Rightarrow>\n                              case M_lookup g u of None \\<Rightarrow> 0\n                              | Some xs \\<Rightarrow>\n                                  the_default 0 (Map.map_of xs v))\n                      \\<in> set (the_default [] (M_lookup g u))", "using \\<alpha>edges_irrefl[of g]"], ["proof (prove)\nusing this:\n  invar g \\<Longrightarrow> irrefl (\\<alpha>edges_aux g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g\\<rbrakk>\n    \\<Longrightarrow> (a, case epair {u, a} of None \\<Rightarrow> 0\n                          | Some (u, v) \\<Rightarrow>\n                              case M_lookup g u of None \\<Rightarrow> 0\n                              | Some xs \\<Rightarrow>\n                                  the_default 0 (Map.map_of xs v))\n                      \\<in> set (the_default [] (M_lookup g u))", "apply (clarsimp split: prod.splits option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g;\n     irrefl (\\<alpha>edges_aux g)\\<rbrakk>\n    \\<Longrightarrow> (u = a \\<longrightarrow>\n                       (\\<exists>xs.\n                           M_lookup g a = Some xs \\<and>\n                           (a, 0) \\<in> set xs)) \\<and>\n                      (\\<forall>aa b.\n                          (M_lookup g aa = None \\<longrightarrow>\n                           epair {u, a} = Some (aa, b) \\<longrightarrow>\n                           (\\<exists>xs.\n                               M_lookup g u = Some xs \\<and>\n                               (a, 0) \\<in> set xs)) \\<and>\n                          (\\<forall>x2.\n                              M_lookup g aa = Some x2 \\<longrightarrow>\n                              epair {u, a} = Some (aa, b) \\<longrightarrow>\n                              (\\<exists>xs.\n                                  M_lookup g u = Some xs \\<and>\n                                  (a, the_default 0 (Map.map_of x2 b))\n                                  \\<in> set xs)))", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>invar g; (a, a) \\<in> \\<alpha>edges_aux g;\n     irrefl (\\<alpha>edges_aux g); u = a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         M_lookup g a = Some xs \\<and> (a, 0) \\<in> set xs\n 2. \\<And>aa b.\n       \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g;\n        irrefl (\\<alpha>edges_aux g); M_lookup g aa = None;\n        epair {u, a} = Some (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            M_lookup g u = Some xs \\<and>\n                            (a, 0) \\<in> set xs\n 3. \\<And>aa b x2.\n       \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g;\n        irrefl (\\<alpha>edges_aux g); M_lookup g aa = Some x2;\n        epair {u, a} = Some (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            M_lookup g u = Some xs \\<and>\n                            (a, the_default 0 (Map.map_of x2 b))\n                            \\<in> set xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (a, a) \\<in> \\<alpha>edges_aux g;\n     irrefl (\\<alpha>edges_aux g); u = a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         M_lookup g a = Some xs \\<and> (a, 0) \\<in> set xs", "by (auto simp: irrefl_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g;\n        irrefl (\\<alpha>edges_aux g); M_lookup g aa = None;\n        epair {u, a} = Some (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            M_lookup g u = Some xs \\<and>\n                            (a, 0) \\<in> set xs\n 2. \\<And>aa b x2.\n       \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g;\n        irrefl (\\<alpha>edges_aux g); M_lookup g aa = Some x2;\n        epair {u, a} = Some (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            M_lookup g u = Some xs \\<and>\n                            (a, the_default 0 (Map.map_of x2 b))\n                            \\<in> set xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g;\n     irrefl (\\<alpha>edges_aux g); M_lookup g aa_ = None;\n     epair {u, a} = Some (aa_, b_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         M_lookup g u = Some xs \\<and> (a, 0) \\<in> set xs", "apply (clarsimp dest!: epair_eqD simp: doubleton_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g;\n     irrefl (\\<alpha>edges_aux g); M_lookup g aa_ = None; aa_ \\<noteq> b_;\n     u = aa_ \\<and> a = b_ \\<or> u = b_ \\<and> a = aa_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         M_lookup g u = Some xs \\<and> (a, 0) \\<in> set xs", "unfolding invar_def \\<alpha>edges_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M_invar g \\<and>\n             finite (dom (M_lookup g)) \\<and>\n             (\\<forall>u xs.\n                 M_lookup g u = Some xs \\<longrightarrow>\n                 distinct (map fst xs) \\<and>\n                 u \\<notin> set (map fst xs) \\<and>\n                 (\\<forall>(v, d)\\<in>set xs.\n                     (u, d) \\<in> set (the_default [] (M_lookup g v))));\n     (u, a)\n     \\<in> {(u, v).\n            \\<exists>xs d.\n               M_lookup g u = Some xs \\<and> (v, d) \\<in> set xs};\n     irrefl\n      {(u, v).\n       \\<exists>xs d. M_lookup g u = Some xs \\<and> (v, d) \\<in> set xs};\n     M_lookup g aa_ = None; aa_ \\<noteq> b_;\n     u = aa_ \\<and> a = b_ \\<or> u = b_ \\<and> a = aa_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         M_lookup g u = Some xs \\<and> (a, 0) \\<in> set xs", "by force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b x2.\n       \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g;\n        irrefl (\\<alpha>edges_aux g); M_lookup g aa = Some x2;\n        epair {u, a} = Some (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            M_lookup g u = Some xs \\<and>\n                            (a, the_default 0 (Map.map_of x2 b))\n                            \\<in> set xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g;\n     irrefl (\\<alpha>edges_aux g); M_lookup g aa_ = Some x2_;\n     epair {u, a} = Some (aa_, b_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         M_lookup g u = Some xs \\<and>\n                         (a, the_default 0 (Map.map_of x2_ b_)) \\<in> set xs", "apply (clarsimp dest!: epair_eqD simp: doubleton_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, a) \\<in> \\<alpha>edges_aux g;\n     irrefl (\\<alpha>edges_aux g); M_lookup g aa_ = Some x2_;\n     aa_ \\<noteq> b_;\n     u = aa_ \\<and> a = b_ \\<or> u = b_ \\<and> a = aa_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         M_lookup g u = Some xs \\<and>\n                         (a, the_default 0 (Map.map_of x2_ b_)) \\<in> set xs", "unfolding invar_def \\<alpha>edges_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M_invar g \\<and>\n             finite (dom (M_lookup g)) \\<and>\n             (\\<forall>u xs.\n                 M_lookup g u = Some xs \\<longrightarrow>\n                 distinct (map fst xs) \\<and>\n                 u \\<notin> set (map fst xs) \\<and>\n                 (\\<forall>(v, d)\\<in>set xs.\n                     (u, d) \\<in> set (the_default [] (M_lookup g v))));\n     (u, a)\n     \\<in> {(u, v).\n            \\<exists>xs d.\n               M_lookup g u = Some xs \\<and> (v, d) \\<in> set xs};\n     irrefl\n      {(u, v).\n       \\<exists>xs d. M_lookup g u = Some xs \\<and> (v, d) \\<in> set xs};\n     M_lookup g aa_ = Some x2_; aa_ \\<noteq> b_;\n     u = aa_ \\<and> a = b_ \\<or> u = b_ \\<and> a = aa_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         M_lookup g u = Some xs \\<and>\n                         (a, the_default 0 (Map.map_of x2_ b_)) \\<in> set xs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs d.\n       \\<lbrakk>irrefl\n                 {(u, v).\n                  \\<exists>xs.\n                     M_lookup g u = Some xs \\<and>\n                     (\\<exists>d. (v, d) \\<in> set xs)};\n        M_lookup g aa_ = Some x2_; aa_ \\<noteq> b_;\n        u = aa_ \\<and> a = b_ \\<or> u = b_ \\<and> a = aa_; M_invar g;\n        M_lookup g u = Some xs; (a, d) \\<in> set xs;\n        finite (dom (M_lookup g));\n        \\<forall>u xs.\n           M_lookup g u = Some xs \\<longrightarrow>\n           distinct (map fst xs) \\<and>\n           u \\<notin> fst ` set xs \\<and>\n           (\\<forall>x\\<in>set xs.\n               case x of\n               (v, d) \\<Rightarrow>\n                 \\<exists>xs.\n                    M_lookup g v = Some xs \\<and>\n                    (u, d) \\<in> set xs)\\<rbrakk>\n       \\<Longrightarrow> (a, the_default 0 (Map.map_of x2_ b_)) \\<in> set xs", "by (smt case_prod_conv map_of_is_SomeI the_default.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invar_empty_aux: \"invar empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar local.empty", "by (simp add: invar_def empty_def M.map_specs)"], ["", "lemma dist_fst_the_dflt_aux: \"distinct (map fst (the_default [] m)) \n  \\<longleftrightarrow> (\\<forall>xs. m = Some xs \\<longrightarrow> distinct (map fst xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (the_default [] m)) =\n    (\\<forall>xs. m = Some xs \\<longrightarrow> distinct (map fst xs))", "by (cases m; auto)"], ["", "lemma invar_add_edge_aux: \n  \"\\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g); u \\<noteq> v\\<rbrakk> \\<Longrightarrow> invar (add_edge (u, v) d g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> invar (add_edge (u, v) d g)", "apply (simp add: edges_\\<alpha>g_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, v) \\<notin> \\<alpha>edges_aux g;\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> invar (add_edge (u, v) d g)", "unfolding add_edge_def add_edge1_def invar_def \\<alpha>edges_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M_invar g \\<and>\n             finite (dom (M_lookup g)) \\<and>\n             (\\<forall>u xs.\n                 M_lookup g u = Some xs \\<longrightarrow>\n                 distinct (map fst xs) \\<and>\n                 u \\<notin> set (map fst xs) \\<and>\n                 (\\<forall>(v, d)\\<in>set xs.\n                     (u, d) \\<in> set (the_default [] (M_lookup g v))));\n     (u, v)\n     \\<notin> {(u, v).\n               \\<exists>xs d.\n                  M_lookup g u = Some xs \\<and> (v, d) \\<in> set xs};\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> M_invar\n                       ((case (u, v) of\n                         (u, v) \\<Rightarrow>\n                           \\<lambda>d g.\n                              (case (v, u) of\n                               (u, v) \\<Rightarrow>\n                                 \\<lambda>d g.\n                                    M_update u\n                                     ((v, d) #\nthe_default [] (M_lookup g u))\n                                     g)\n                               d ((case (u, v) of\n                                   (u, v) \\<Rightarrow>\n                                     \\<lambda>d g.\n  M_update u ((v, d) # the_default [] (M_lookup g u)) g)\n                                   d g))\n                         d g) \\<and>\n                      finite\n                       (dom (M_lookup\n                              ((case (u, v) of\n                                (u, v) \\<Rightarrow>\n                                  \\<lambda>d g.\n                                     (case (v, u) of\n(u, v) \\<Rightarrow>\n  \\<lambda>d g. M_update u ((v, d) # the_default [] (M_lookup g u)) g)\nd ((case (u, v) of\n    (u, v) \\<Rightarrow>\n      \\<lambda>d g. M_update u ((v, d) # the_default [] (M_lookup g u)) g)\n    d g))\n                                d g))) \\<and>\n                      (\\<forall>ua xs.\n                          M_lookup\n                           ((case (u, v) of\n                             (u, v) \\<Rightarrow>\n                               \\<lambda>d g.\n                                  (case (v, u) of\n                                   (u, v) \\<Rightarrow>\n                                     \\<lambda>d g.\n  M_update u ((v, d) # the_default [] (M_lookup g u)) g)\n                                   d ((case (u, v) of\n (u, v) \\<Rightarrow>\n   \\<lambda>d g. M_update u ((v, d) # the_default [] (M_lookup g u)) g)\n d g))\n                             d g)\n                           ua =\n                          Some xs \\<longrightarrow>\n                          distinct (map fst xs) \\<and>\n                          ua \\<notin> set (map fst xs) \\<and>\n                          (\\<forall>(va, da)\\<in>set xs.\n                              (ua, da)\n                              \\<in> set (the_default []\n    (M_lookup\n      ((case (u, v) of\n        (u, v) \\<Rightarrow>\n          \\<lambda>d g.\n             (case (v, u) of\n              (u, v) \\<Rightarrow>\n                \\<lambda>d g.\n                   M_update u ((v, d) # the_default [] (M_lookup g u)) g)\n              d ((case (u, v) of\n                  (u, v) \\<Rightarrow>\n                    \\<lambda>d g.\n                       M_update u ((v, d) # the_default [] (M_lookup g u))\n                        g)\n                  d g))\n        d g)\n      va))))", "by (auto simp:  M.map_specs dist_fst_the_dflt_aux; force)"], ["", "sublocale adt_wgraph \\<alpha>w \\<alpha>g invar adj empty add_edge"], ["proof (prove)\ngoal (1 subgoal):\n 1. adt_wgraph \\<alpha>w \\<alpha>g invar adj local.empty add_edge", "apply unfold_locales"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>g u.\n       invar g \\<Longrightarrow>\n       set (adj g u) =\n       {(v, d).\n        (u, v) \\<in> edges (\\<alpha>g g) \\<and> \\<alpha>w g {u, v} = d}\n 2. invar local.empty\n 3. \\<alpha>g local.empty = graph_empty\n 4. \\<alpha>w local.empty = (\\<lambda>_. 0)\n 5. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> invar (add_edge (u, v) d g)\n 6. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>g (add_edge (u, v) d g) =\n                         ins_edge (u, v) (\\<alpha>g g)\n 7. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>w (add_edge (u, v) d g) = (\\<alpha>w g)\n                         ({u, v} := d)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g_ \\<Longrightarrow>\n    set (adj g_ u_) =\n    {(v, d).\n     (u_, v) \\<in> edges (\\<alpha>g g_) \\<and> \\<alpha>w g_ {u_, v} = d}", "by (simp add: adj_correct_aux)"], ["proof (prove)\ngoal (6 subgoals):\n 1. invar local.empty\n 2. \\<alpha>g local.empty = graph_empty\n 3. \\<alpha>w local.empty = (\\<lambda>_. 0)\n 4. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> invar (add_edge (u, v) d g)\n 5. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>g (add_edge (u, v) d g) =\n                         ins_edge (u, v) (\\<alpha>g g)\n 6. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>w (add_edge (u, v) d g) = (\\<alpha>w g)\n                         ({u, v} := d)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar local.empty", "by (simp add: invar_empty_aux)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<alpha>g local.empty = graph_empty\n 2. \\<alpha>w local.empty = (\\<lambda>_. 0)\n 3. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> invar (add_edge (u, v) d g)\n 4. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>g (add_edge (u, v) d g) =\n                         ins_edge (u, v) (\\<alpha>g g)\n 5. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>w (add_edge (u, v) d g) = (\\<alpha>w g)\n                         ({u, v} := d)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>g local.empty = graph_empty", "apply (simp \n        add: graph_eq_iff nodes_\\<alpha>g_aux invar_empty_aux edges_\\<alpha>g_aux\n        add: \\<alpha>nodes_aux_def \\<alpha>edges_aux_def\n        )"], ["proof (prove)\ngoal (1 subgoal):\n 1. M_lookup local.empty = Map.empty \\<and>\n    (\\<forall>a b xs.\n        M_lookup local.empty a = Some xs \\<longrightarrow>\n        (\\<forall>d. (b, d) \\<notin> set xs))", "apply (simp add: empty_def M.map_specs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<alpha>w local.empty = (\\<lambda>_. 0)\n 2. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> invar (add_edge (u, v) d g)\n 3. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>g (add_edge (u, v) d g) =\n                         ins_edge (u, v) (\\<alpha>g g)\n 4. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>w (add_edge (u, v) d g) = (\\<alpha>w g)\n                         ({u, v} := d)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>w local.empty = (\\<lambda>_. 0)", "unfolding \\<alpha>w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>e.\n        case epair e of None \\<Rightarrow> 0\n        | Some (u, v) \\<Rightarrow>\n            case M_lookup local.empty u of None \\<Rightarrow> 0\n            | Some xs \\<Rightarrow> the_default 0 (Map.map_of xs v)) =\n    (\\<lambda>_. 0)", "by (auto simp: empty_def M.map_specs fun_eq_iff split: option.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> invar (add_edge (u, v) d g)\n 2. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>g (add_edge (u, v) d g) =\n                         ins_edge (u, v) (\\<alpha>g g)\n 3. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>w (add_edge (u, v) d g) = (\\<alpha>w g)\n                         ({u, v} := d)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g_; (u_, v_) \\<notin> edges (\\<alpha>g g_);\n     u_ \\<noteq> v_\\<rbrakk>\n    \\<Longrightarrow> invar (add_edge (u_, v_) d_ g_)", "by (simp add: invar_add_edge_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>g (add_edge (u, v) d g) =\n                         ins_edge (u, v) (\\<alpha>g g)\n 2. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>w (add_edge (u, v) d g) = (\\<alpha>w g)\n                         ({u, v} := d)", "subgoal for g u v d"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<alpha>g (add_edge (u, v) d g) =\n                      ins_edge (u, v) (\\<alpha>g g)", "apply (simp add: edges_\\<alpha>g_aux nodes_\\<alpha>g_aux graph_eq_iff invar_add_edge_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, v) \\<notin> \\<alpha>edges_aux g;\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<alpha>nodes_aux (add_edge (u, v) d g) =\n                      insert u (insert v (\\<alpha>nodes_aux g)) \\<and>\n                      \\<alpha>edges_aux (add_edge (u, v) d g) =\n                      insert (u, v) (insert (v, u) (\\<alpha>edges_aux g))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar g; (u, v) \\<notin> \\<alpha>edges_aux g;\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<alpha>nodes_aux (add_edge (u, v) d g) =\n                      insert u (insert v (\\<alpha>nodes_aux g))\n 2. \\<lbrakk>invar g; (u, v) \\<notin> \\<alpha>edges_aux g;\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<alpha>edges_aux (add_edge (u, v) d g) =\n                      insert (u, v) (insert (v, u) (\\<alpha>edges_aux g))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, v) \\<notin> \\<alpha>edges_aux g;\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<alpha>nodes_aux (add_edge (u, v) d g) =\n                      insert u (insert v (\\<alpha>nodes_aux g))", "unfolding add_edge_def add_edge1_def invar_def \\<alpha>nodes_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M_invar g \\<and>\n             finite (dom (M_lookup g)) \\<and>\n             (\\<forall>u xs.\n                 M_lookup g u = Some xs \\<longrightarrow>\n                 distinct (map fst xs) \\<and>\n                 u \\<notin> set (map fst xs) \\<and>\n                 (\\<forall>(v, d)\\<in>set xs.\n                     (u, d) \\<in> set (the_default [] (M_lookup g v))));\n     (u, v) \\<notin> \\<alpha>edges_aux g; u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> dom (M_lookup\n                            ((case (u, v) of\n                              (u, v) \\<Rightarrow>\n                                \\<lambda>d g.\n                                   (case (v, u) of\n                                    (u, v) \\<Rightarrow>\n\\<lambda>d g. M_update u ((v, d) # the_default [] (M_lookup g u)) g)\n                                    d ((case (u, v) of\n  (u, v) \\<Rightarrow>\n    \\<lambda>d g. M_update u ((v, d) # the_default [] (M_lookup g u)) g)\n  d g))\n                              d g)) =\n                      insert u (insert v (dom (M_lookup g)))", "by (auto simp: M.map_specs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, v) \\<notin> \\<alpha>edges_aux g;\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<alpha>edges_aux (add_edge (u, v) d g) =\n                      insert (u, v) (insert (v, u) (\\<alpha>edges_aux g))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, v) \\<notin> \\<alpha>edges_aux g;\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<alpha>edges_aux (add_edge (u, v) d g) =\n                      insert (u, v) (insert (v, u) (\\<alpha>edges_aux g))", "unfolding add_edge_def add_edge1_def invar_def \\<alpha>edges_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M_invar g \\<and>\n             finite (dom (M_lookup g)) \\<and>\n             (\\<forall>u xs.\n                 M_lookup g u = Some xs \\<longrightarrow>\n                 distinct (map fst xs) \\<and>\n                 u \\<notin> set (map fst xs) \\<and>\n                 (\\<forall>(v, d)\\<in>set xs.\n                     (u, d) \\<in> set (the_default [] (M_lookup g v))));\n     (u, v)\n     \\<notin> {(u, v).\n               \\<exists>xs d.\n                  M_lookup g u = Some xs \\<and> (v, d) \\<in> set xs};\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> {(ua, va).\n                       \\<exists>xs da.\n                          M_lookup\n                           ((case (u, v) of\n                             (u, v) \\<Rightarrow>\n                               \\<lambda>d g.\n                                  (case (v, u) of\n                                   (u, v) \\<Rightarrow>\n                                     \\<lambda>d g.\n  M_update u ((v, d) # the_default [] (M_lookup g u)) g)\n                                   d ((case (u, v) of\n (u, v) \\<Rightarrow>\n   \\<lambda>d g. M_update u ((v, d) # the_default [] (M_lookup g u)) g)\n d g))\n                             d g)\n                           ua =\n                          Some xs \\<and>\n                          (va, da) \\<in> set xs} =\n                      insert (u, v)\n                       (insert (v, u)\n                         {(u, v).\n                          \\<exists>xs d.\n                             M_lookup g u = Some xs \\<and>\n                             (v, d) \\<in> set xs})", "by (fastforce simp: M.map_specs split!: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g u v d.\n       \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n        u \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>w (add_edge (u, v) d g) = (\\<alpha>w g)\n                         ({u, v} := d)", "subgoal for g u v d"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, v) \\<notin> edges (\\<alpha>g g);\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<alpha>w (add_edge (u, v) d g) = (\\<alpha>w g)\n                      ({u, v} := d)", "apply (simp add: edges_\\<alpha>g_aux invar_add_edge_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar g; (u, v) \\<notin> \\<alpha>edges_aux g;\n     u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<alpha>w (add_edge (u, v) d g) = (\\<alpha>w g)\n                      ({u, v} := d)", "unfolding invar_def \\<alpha>w_def add_edge_def add_edge1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M_invar g \\<and>\n             finite (dom (M_lookup g)) \\<and>\n             (\\<forall>u xs.\n                 M_lookup g u = Some xs \\<longrightarrow>\n                 distinct (map fst xs) \\<and>\n                 u \\<notin> set (map fst xs) \\<and>\n                 (\\<forall>(v, d)\\<in>set xs.\n                     (u, d) \\<in> set (the_default [] (M_lookup g v))));\n     (u, v) \\<notin> \\<alpha>edges_aux g; u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>e.\n                          case epair e of None \\<Rightarrow> 0\n                          | Some (ua, va) \\<Rightarrow>\n                              case M_lookup\n                                    ((case (u, v) of\n(u, v) \\<Rightarrow>\n  \\<lambda>d g.\n     (case (v, u) of\n      (u, v) \\<Rightarrow>\n        \\<lambda>d g. M_update u ((v, d) # the_default [] (M_lookup g u)) g)\n      d ((case (u, v) of\n          (u, v) \\<Rightarrow>\n            \\<lambda>d g.\n               M_update u ((v, d) # the_default [] (M_lookup g u)) g)\n          d g))\nd g)\n                                    ua of\n                              None \\<Rightarrow> 0\n                              | Some xs \\<Rightarrow>\n                                  the_default 0 (Map.map_of xs va)) =\n                      (\\<lambda>e.\n                          case epair e of None \\<Rightarrow> 0\n                          | Some (u, v) \\<Rightarrow>\n                              case M_lookup g u of None \\<Rightarrow> 0\n                              | Some xs \\<Rightarrow>\n                                  the_default 0 (Map.map_of xs v))\n                      ({u, v} := d)", "by (auto \n      dest: epair_eqD \n      simp: fun_eq_iff M.map_specs \n      split!: prod.splits option.splits if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}