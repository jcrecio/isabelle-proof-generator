{"file_name": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple/Common.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple", "problem_names": ["lemma split_sym_rel: \n  fixes G :: \"'a rel\"\n  assumes \"sym G\" \"irrefl G\"\n  obtains E where \"E\\<inter>E\\<inverse> = {}\" \"G = E \\<union> E\\<inverse>\"", "lemma least_antimono: \"X\\<noteq>{} \\<Longrightarrow> X\\<subseteq>Y \\<Longrightarrow> (LEAST y::_::wellorder. y\\<in>Y) \\<le> (LEAST x. x\\<in>X)\"", "lemma distinct_map_snd_inj: \"distinct (map snd l) \\<Longrightarrow> (a,b)\\<in>set l \\<Longrightarrow> (a',b)\\<in>set l \\<Longrightarrow> a=a'\"", "lemma map_add_apply: \"(m\\<^sub>1 ++ m\\<^sub>2) k = (case m\\<^sub>2 k of None \\<Rightarrow> m\\<^sub>1 k | Some x \\<Rightarrow> Some x)\"", "lemma map_eq_append_conv: \"map f xs = ys\\<^sub>1@ys\\<^sub>2 \n  \\<longleftrightarrow> (\\<exists>xs\\<^sub>1 xs\\<^sub>2. xs = xs\\<^sub>1@xs\\<^sub>2 \\<and> map f xs\\<^sub>1 = ys\\<^sub>1 \\<and> map f xs\\<^sub>2 = ys\\<^sub>2)\"", "lemma prod_case_const[simp]: \"case_prod (\\<lambda>_ _. c) = (\\<lambda>_. c)\"", "lemma card2_eq: \"card e = 2 \\<longleftrightarrow> (\\<exists>u v. u\\<noteq>v \\<and> e={u,v})\"", "lemma in_ranE:\n  assumes \"v \\<in> ran m\"  \n  obtains k where \"m k = Some v\"", "lemma Inf_in:\n  fixes A :: \"'a::{linorder,complete_lattice} set\"\n  assumes \"finite A\" \"A\\<noteq>{}\" \n  shows \"Inf A \\<in> A\"", "lemma INF_of_enat_infty_iff1: \"(INF x \\<in> A. enat (f x)) = \\<infinity> \\<longleftrightarrow> A={}\"", "lemma INF_of_enat_infty_iff2: \n  \"\\<infinity> = (INF x \\<in> A. enat (f x)) \\<longleftrightarrow> A={}\"", "lemmas INF_of_enat_infty_iff[simp] = INF_of_enat_infty_iff1 INF_of_enat_infty_iff2", "lemma INF_of_enat_nat_conv1: \n  assumes \"finite A\"  \n  shows \"(INF x \\<in> A. enat (f x)) = enat d \\<longleftrightarrow> (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))\"", "lemma INF_of_enat_nat_conv2: \n  assumes \"finite A\"  \n  shows \"enat d = (INF x \\<in> A. enat (f x)) \\<longleftrightarrow> (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))\"", "lemmas INF_of_enat_nat_conv = INF_of_enat_nat_conv1 INF_of_enat_nat_conv2", "lemma finite_inf_linorder_ne_ex:\n  fixes f :: \"_ \\<Rightarrow> _::{complete_lattice,linorder}\"\n  assumes \"finite S\"\n  assumes \"S\\<noteq>{}\"\n  shows \"\\<exists>x\\<in>S. (INF x \\<in> S. f x) = f x\"", "lemma finite_linorder_eq_INF_conv: \"finite S \n  \\<Longrightarrow> a = (INF x \\<in> S. f x) \\<longleftrightarrow> (if S={} then a=top else \\<exists>x\\<in>S. a=f x \\<and> (\\<forall>y\\<in>S. a \\<le> f y))\"\n  for a :: \"_::{complete_lattice,linorder}\"", "lemma sym_inv_eq[simp]: \"sym E \\<Longrightarrow> E\\<inverse> = E\"", "lemma insert_inv[simp]: \"(insert e E)\\<inverse> = insert (prod.swap e) (E\\<inverse>)\"", "lemma inter_compl_eq_diff[simp]: \"x \\<inter> - s = x - s\"", "lemma inter_same_diff[simp]: \"A\\<inter>(A-S) = A-S\"", "lemma minus_inv_sym_aux[simp]: \"(- {(a, b), (b, a)})\\<inverse> = -{(a,b),(b,a)}\"", "lemma the_default_alt: \"the_default d x = (case x of None \\<Rightarrow> d | Some v \\<Rightarrow> v)\"", "lemma enat_of_option_inj[simp]: \"enat_of_option x = enat_of_option y \\<longleftrightarrow> x=y\"", "lemma enat_of_option_simps[simp]:\n  \"enat_of_option x = enat n \\<longleftrightarrow> x = Some n\"\n  \"enat_of_option x = \\<infinity> \\<longleftrightarrow> x = None\"\n  \"enat n = enat_of_option x \\<longleftrightarrow> x = Some n\"\n  \"\\<infinity> = enat_of_option x \\<longleftrightarrow> x = None\"", "lemma enat_of_option_le_conv: \"enat_of_option m \\<le> enat_of_option n \\<longleftrightarrow> (case (m,n) of \n    (_,None) \\<Rightarrow> True\n  | (Some a, Some b) \\<Rightarrow> a\\<le>b\n  | (_, _) \\<Rightarrow> False\n)\"", "lemma foldr_refine:\n  assumes \"I s\"\n  assumes \"\\<And>s x. I s \\<Longrightarrow> x\\<in>set l \\<Longrightarrow> I (f x s) \\<and> \\<alpha> (f x s) = f' x (\\<alpha> s)\"\n  shows \"I (foldr f l s) \\<and> \\<alpha> (foldr f l s) = foldr f' l (\\<alpha> s)\""], "translations": [["", "lemma split_sym_rel: \n  fixes G :: \"'a rel\"\n  assumes \"sym G\" \"irrefl G\"\n  obtains E where \"E\\<inter>E\\<inverse> = {}\" \"G = E \\<union> E\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<inter> E\\<inverse> = {};\n         G = E \\<union> E\\<inverse>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<inter> E\\<inverse> = {};\n         G = E \\<union> E\\<inverse>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain R :: \"'a rel\" \n  where WO: \"well_order_on UNIV R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R. well_order R \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Zorn.well_order_on"], ["proof (prove)\nusing this:\n  \\<exists>r. well_order_on ?A r\n\ngoal (1 subgoal):\n 1. (\\<And>R. well_order R \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  well_order R\n\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<inter> E\\<inverse> = {};\n         G = E \\<union> E\\<inverse>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?E = \"G \\<inter> R\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<inter> E\\<inverse> = {};\n         G = E \\<union> E\\<inverse>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>irrefl G\\<close>"], ["proof (chain)\npicking this:\n  irrefl G", "have [simp, intro!]: \"(x,x)\\<notin>G\" for x"], ["proof (prove)\nusing this:\n  irrefl G\n\ngoal (1 subgoal):\n 1. (x, x) \\<notin> G", "by (auto simp: irrefl_def)"], ["proof (state)\nthis:\n  (?x, ?x) \\<notin> G\n\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<inter> E\\<inverse> = {};\n         G = E \\<union> E\\<inverse>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"?E \\<inter> ?E\\<inverse> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<inter> R \\<inter> (G \\<inter> R)\\<inverse> = {}", "using WO"], ["proof (prove)\nusing this:\n  well_order R\n\ngoal (1 subgoal):\n 1. G \\<inter> R \\<inter> (G \\<inter> R)\\<inverse> = {}", "unfolding well_order_on_def linear_order_on_def \n      partial_order_on_def antisym_def"], ["proof (prove)\nusing this:\n  ((preorder_on UNIV R \\<and>\n    (\\<forall>x y.\n        (x, y) \\<in> R \\<longrightarrow>\n        (y, x) \\<in> R \\<longrightarrow> x = y)) \\<and>\n   total R) \\<and>\n  wf (R - Id)\n\ngoal (1 subgoal):\n 1. G \\<inter> R \\<inter> (G \\<inter> R)\\<inverse> = {}", "by fastforce"], ["proof (state)\nthis:\n  G \\<inter> R \\<inter> (G \\<inter> R)\\<inverse> = {}\n\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<inter> E\\<inverse> = {};\n         G = E \\<union> E\\<inverse>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  G \\<inter> R \\<inter> (G \\<inter> R)\\<inverse> = {}\n\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<inter> E\\<inverse> = {};\n         G = E \\<union> E\\<inverse>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"G = ?E \\<union> ?E\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G = G \\<inter> R \\<union> (G \\<inter> R)\\<inverse>", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> G; (a, b) \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> (b, a) \\<in> G\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> G; (a, b) \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> (b, a) \\<in> R\n 3. \\<And>a b.\n       \\<lbrakk>(b, a) \\<in> G; (b, a) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> G", "apply (simp_all add: symD[OF \\<open>sym G\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> G; (a, b) \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> (b, a) \\<in> R", "using WO"], ["proof (prove)\nusing this:\n  well_order R\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> G; (a, b) \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> (b, a) \\<in> R", "unfolding well_order_on_def linear_order_on_def total_on_def"], ["proof (prove)\nusing this:\n  (partial_order_on UNIV R \\<and>\n   (\\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          x \\<noteq> y \\<longrightarrow>\n          (x, y) \\<in> R \\<or> (y, x) \\<in> R)) \\<and>\n  wf (R - Id)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> G; (a, b) \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> (b, a) \\<in> R", "by force"], ["proof (state)\nthis:\n  G = G \\<inter> R \\<union> (G \\<inter> R)\\<inverse>\n\ngoal (1 subgoal):\n 1. (\\<And>E.\n        \\<lbrakk>E \\<inter> E\\<inverse> = {};\n         G = E \\<union> E\\<inverse>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  G \\<inter> R \\<inter> (G \\<inter> R)\\<inverse> = {}\n  G = G \\<inter> R \\<union> (G \\<inter> R)\\<inverse>", "show ?thesis"], ["proof (prove)\nusing this:\n  G \\<inter> R \\<inter> (G \\<inter> R)\\<inverse> = {}\n  G = G \\<inter> R \\<union> (G \\<inter> R)\\<inverse>\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma least_antimono: \"X\\<noteq>{} \\<Longrightarrow> X\\<subseteq>Y \\<Longrightarrow> (LEAST y::_::wellorder. y\\<in>Y) \\<le> (LEAST x. x\\<in>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {}; X \\<subseteq> Y\\<rbrakk>\n    \\<Longrightarrow> (LEAST y. y \\<in> Y) \\<le> (LEAST x. x \\<in> X)", "by (metis LeastI_ex Least_le equals0I rev_subsetD)"], ["", "lemma distinct_map_snd_inj: \"distinct (map snd l) \\<Longrightarrow> (a,b)\\<in>set l \\<Longrightarrow> (a',b)\\<in>set l \\<Longrightarrow> a=a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map snd l); (a, b) \\<in> set l;\n     (a', b) \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> a = a'", "by (metis distinct_map inj_onD prod.sel(2) prod.simps(1))"], ["", "lemma map_add_apply: \"(m\\<^sub>1 ++ m\\<^sub>2) k = (case m\\<^sub>2 k of None \\<Rightarrow> m\\<^sub>1 k | Some x \\<Rightarrow> Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m\\<^sub>1 ++ m\\<^sub>2) k =\n    (case m\\<^sub>2 k of None \\<Rightarrow> m\\<^sub>1 k\n     | Some x \\<Rightarrow> Some x)", "by (auto simp: map_add_def)"], ["", "lemma map_eq_append_conv: \"map f xs = ys\\<^sub>1@ys\\<^sub>2 \n  \\<longleftrightarrow> (\\<exists>xs\\<^sub>1 xs\\<^sub>2. xs = xs\\<^sub>1@xs\\<^sub>2 \\<and> map f xs\\<^sub>1 = ys\\<^sub>1 \\<and> map f xs\\<^sub>2 = ys\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map f xs = ys\\<^sub>1 @ ys\\<^sub>2) =\n    (\\<exists>xs\\<^sub>1 xs\\<^sub>2.\n        xs = xs\\<^sub>1 @ xs\\<^sub>2 \\<and>\n        map f xs\\<^sub>1 = ys\\<^sub>1 \\<and> map f xs\\<^sub>2 = ys\\<^sub>2)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. map f xs = ys\\<^sub>1 @ ys\\<^sub>2 \\<Longrightarrow>\n    \\<exists>xs\\<^sub>1 xs\\<^sub>2.\n       xs = xs\\<^sub>1 @ xs\\<^sub>2 \\<and>\n       map f xs\\<^sub>1 = ys\\<^sub>1 \\<and> map f xs\\<^sub>2 = ys\\<^sub>2\n 2. \\<exists>xs\\<^sub>1 xs\\<^sub>2.\n       xs = xs\\<^sub>1 @ xs\\<^sub>2 \\<and>\n       map f xs\\<^sub>1 = ys\\<^sub>1 \\<and>\n       map f xs\\<^sub>2 = ys\\<^sub>2 \\<Longrightarrow>\n    map f xs = ys\\<^sub>1 @ ys\\<^sub>2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f xs = ys\\<^sub>1 @ ys\\<^sub>2 \\<Longrightarrow>\n    \\<exists>xs\\<^sub>1 xs\\<^sub>2.\n       xs = xs\\<^sub>1 @ xs\\<^sub>2 \\<and>\n       map f xs\\<^sub>1 = ys\\<^sub>1 \\<and> map f xs\\<^sub>2 = ys\\<^sub>2", "apply (rule exI[where x=\"take (length ys\\<^sub>1) xs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f xs = ys\\<^sub>1 @ ys\\<^sub>2 \\<Longrightarrow>\n    \\<exists>xs\\<^sub>2.\n       xs = take (length ys\\<^sub>1) xs @ xs\\<^sub>2 \\<and>\n       map f (take (length ys\\<^sub>1) xs) = ys\\<^sub>1 \\<and>\n       map f xs\\<^sub>2 = ys\\<^sub>2", "apply (rule exI[where x=\"drop (length ys\\<^sub>1) xs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f xs = ys\\<^sub>1 @ ys\\<^sub>2 \\<Longrightarrow>\n    xs = take (length ys\\<^sub>1) xs @ drop (length ys\\<^sub>1) xs \\<and>\n    map f (take (length ys\\<^sub>1) xs) = ys\\<^sub>1 \\<and>\n    map f (drop (length ys\\<^sub>1) xs) = ys\\<^sub>2", "apply (drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ys\\<^sub>1 @ ys\\<^sub>2 = map f xs \\<Longrightarrow>\n    xs = take (length ys\\<^sub>1) xs @ drop (length ys\\<^sub>1) xs \\<and>\n    map f (take (length ys\\<^sub>1) xs) = ys\\<^sub>1 \\<and>\n    map f (drop (length ys\\<^sub>1) xs) = ys\\<^sub>2", "by (auto simp: append_eq_conv_conj take_map drop_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs\\<^sub>1 xs\\<^sub>2.\n       xs = xs\\<^sub>1 @ xs\\<^sub>2 \\<and>\n       map f xs\\<^sub>1 = ys\\<^sub>1 \\<and>\n       map f xs\\<^sub>2 = ys\\<^sub>2 \\<Longrightarrow>\n    map f xs = ys\\<^sub>1 @ ys\\<^sub>2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs\\<^sub>1 xs\\<^sub>2.\n       xs = xs\\<^sub>1 @ xs\\<^sub>2 \\<and>\n       map f xs\\<^sub>1 = ys\\<^sub>1 \\<and>\n       map f xs\\<^sub>2 = ys\\<^sub>2 \\<Longrightarrow>\n    map f xs = ys\\<^sub>1 @ ys\\<^sub>2", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prod_case_const[simp]: \"case_prod (\\<lambda>_ _. c) = (\\<lambda>_. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(uu_, uu_). c) = (\\<lambda>_. c)", "by auto"], ["", "lemma card2_eq: \"card e = 2 \\<longleftrightarrow> (\\<exists>u v. u\\<noteq>v \\<and> e={u,v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card e = 2) = (\\<exists>u v. u \\<noteq> v \\<and> e = {u, v})", "by (auto simp: eval_nat_numeral card_Suc_eq)"], ["", "lemma in_ranE:\n  assumes \"v \\<in> ran m\"  \n  obtains k where \"m k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. m k = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> ran m\n\ngoal (1 subgoal):\n 1. (\\<And>k. m k = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ran_def"], ["proof (prove)\nusing this:\n  v \\<in> {b. \\<exists>a. m a = Some b}\n\ngoal (1 subgoal):\n 1. (\\<And>k. m k = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma Inf_in:\n  fixes A :: \"'a::{linorder,complete_lattice} set\"\n  assumes \"finite A\" \"A\\<noteq>{}\" \n  shows \"Inf A \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf A \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Inf A \\<in> A", "proof (induction A rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> Inf {} \\<in> {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Inf F \\<in> F;\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Inf (insert x F) \\<in> insert x F", "case empty"], ["proof (state)\nthis:\n  {} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> Inf {} \\<in> {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Inf F \\<in> F;\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Inf (insert x F) \\<in> insert x F", "then"], ["proof (chain)\npicking this:\n  {} \\<noteq> {}", "show ?case"], ["proof (prove)\nusing this:\n  {} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Inf {} \\<in> {}", "by simp"], ["proof (state)\nthis:\n  Inf {} \\<in> {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Inf F \\<in> F;\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Inf (insert x F) \\<in> insert x F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Inf F \\<in> F;\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Inf (insert x F) \\<in> insert x F", "have [simp]: \"inf a b = (if a\\<le>b then a else b)\" for a b :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. inf a b = (if a \\<le> b then a else b)", "by (meson inf_absorb2 le_iff_inf linear)"], ["proof (state)\nthis:\n  inf ?a ?b = (if ?a \\<le> ?b then ?a else ?b)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Inf F \\<in> F;\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Inf (insert x F) \\<in> insert x F", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  F \\<noteq> {} \\<Longrightarrow> Inf F \\<in> F\n  insert x F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Inf F \\<in> F;\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Inf (insert x F) \\<in> insert x F", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf (insert x F) \\<in> insert x F", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> Inf (insert x F) \\<in> insert x F\n 2. \\<not> ?P \\<Longrightarrow> Inf (insert x F) \\<in> insert x F", "assume \"F={}\""], ["proof (state)\nthis:\n  F = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> Inf (insert x F) \\<in> insert x F\n 2. \\<not> ?P \\<Longrightarrow> Inf (insert x F) \\<in> insert x F", "thus ?thesis"], ["proof (prove)\nusing this:\n  F = {}\n\ngoal (1 subgoal):\n 1. Inf (insert x F) \\<in> insert x F", "by auto"], ["proof (state)\nthis:\n  Inf (insert x F) \\<in> insert x F\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> Inf (insert x F) \\<in> insert x F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> Inf (insert x F) \\<in> insert x F", "assume \"F\\<noteq>{}\""], ["proof (state)\nthis:\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> Inf (insert x F) \\<in> insert x F", "with insert.IH"], ["proof (chain)\npicking this:\n  F \\<noteq> {} \\<Longrightarrow> Inf F \\<in> F\n  F \\<noteq> {}", "have \"Inf F \\<in> F\""], ["proof (prove)\nusing this:\n  F \\<noteq> {} \\<Longrightarrow> Inf F \\<in> F\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Inf F \\<in> F", "."], ["proof (state)\nthis:\n  Inf F \\<in> F\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> Inf (insert x F) \\<in> insert x F", "then"], ["proof (chain)\npicking this:\n  Inf F \\<in> F", "show ?thesis"], ["proof (prove)\nusing this:\n  Inf F \\<in> F\n\ngoal (1 subgoal):\n 1. Inf (insert x F) \\<in> insert x F", "using le_less_linear[of x \"Inf F\"]"], ["proof (prove)\nusing this:\n  Inf F \\<in> F\n  x \\<le> Inf F \\<or> Inf F < x\n\ngoal (1 subgoal):\n 1. Inf (insert x F) \\<in> insert x F", "by auto"], ["proof (state)\nthis:\n  Inf (insert x F) \\<in> insert x F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Inf (insert x F) \\<in> insert x F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma INF_of_enat_infty_iff1: \"(INF x \\<in> A. enat (f x)) = \\<infinity> \\<longleftrightarrow> A={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((INF x\\<in>A. enat (f x)) = \\<infinity>) = (A = {})", "apply (cases \"A={}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = \\<infinity>) = (A = {})\n 2. A \\<noteq> {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = \\<infinity>) = (A = {})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = \\<infinity>) = (A = {})", "by (simp add: top_enat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = \\<infinity>) = (A = {})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = \\<infinity>) = (A = {})", "by safe (metis INF_top_conv(2) enat.distinct(1) top_enat_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma INF_of_enat_infty_iff2: \n  \"\\<infinity> = (INF x \\<in> A. enat (f x)) \\<longleftrightarrow> A={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<infinity> = (INF x\\<in>A. enat (f x))) = (A = {})", "by (metis INF_of_enat_infty_iff1)"], ["", "lemmas INF_of_enat_infty_iff[simp] = INF_of_enat_infty_iff1 INF_of_enat_infty_iff2"], ["", "lemma INF_of_enat_nat_conv1: \n  assumes \"finite A\"  \n  shows \"(INF x \\<in> A. enat (f x)) = enat d \\<longleftrightarrow> (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "from assms"], ["proof (chain)\npicking this:\n  finite A", "have F: \"finite (enat`f`A)\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (enat ` f ` A)", "by auto"], ["proof (state)\nthis:\n  finite (enat ` f ` A)\n\ngoal (1 subgoal):\n 1. ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "proof (cases \"A={}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "case True"], ["proof (state)\nthis:\n  A = {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))\n 2. A \\<noteq> {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "thus ?thesis"], ["proof (prove)\nusing this:\n  A = {}\n\ngoal (1 subgoal):\n 1. ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "by (auto simp: top_enat_def)"], ["proof (state)\nthis:\n  ((INF x\\<in>A. enat (f x)) = enat d) =\n  (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "case [simp]: False"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "note * = Inf_in[OF F, simplified]"], ["proof (state)\nthis:\n  Inf (enat ` f ` A) \\<in> enat ` f ` A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((INF x\\<in>A. enat (f x)) = enat d) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (INF x\\<in>A. enat (f x)) = enat d \\<Longrightarrow>\n    \\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y)\n 2. \\<exists>x\\<in>A.\n       d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y) \\<Longrightarrow>\n    (INF x\\<in>A. enat (f x)) = enat d", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF x\\<in>A. enat (f x)) = enat d \\<Longrightarrow>\n    \\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y)", "by (smt False Inf_in assms enat.inject enat_ord_simps(1) finite_imageI imageE image_is_empty le_INF_iff order_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>A.\n       d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y) \\<Longrightarrow>\n    (INF x\\<in>A. enat (f x)) = enat d", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>A.\n       d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y) \\<Longrightarrow>\n    (INF x\\<in>A. enat (f x)) = enat d", "by clarsimp (meson INF_greatest INF_lower antisym enat_ord_simps(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((INF x\\<in>A. enat (f x)) = enat d) =\n  (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((INF x\\<in>A. enat (f x)) = enat d) =\n  (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma INF_of_enat_nat_conv2: \n  assumes \"finite A\"  \n  shows \"enat d = (INF x \\<in> A. enat (f x)) \\<longleftrightarrow> (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat d = (INF x\\<in>A. enat (f x))) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "using INF_of_enat_nat_conv1[OF assms]"], ["proof (prove)\nusing this:\n  ((INF x\\<in>A. enat (?f x)) = enat ?d) =\n  (\\<exists>x\\<in>A. ?d = ?f x \\<and> (\\<forall>y\\<in>A. ?f x \\<le> ?f y))\n\ngoal (1 subgoal):\n 1. (enat d = (INF x\\<in>A. enat (f x))) =\n    (\\<exists>x\\<in>A. d = f x \\<and> (\\<forall>y\\<in>A. f x \\<le> f y))", "by metis"], ["", "lemmas INF_of_enat_nat_conv = INF_of_enat_nat_conv1 INF_of_enat_nat_conv2"], ["", "lemma finite_inf_linorder_ne_ex:\n  fixes f :: \"_ \\<Rightarrow> _::{complete_lattice,linorder}\"\n  assumes \"finite S\"\n  assumes \"S\\<noteq>{}\"\n  shows \"\\<exists>x\\<in>S. (INF x \\<in> S. f x) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Inf (f ` S) = f x", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Inf (f ` S) = f x", "by (meson Inf_in finite_imageI imageE image_is_empty)"], ["", "lemma finite_linorder_eq_INF_conv: \"finite S \n  \\<Longrightarrow> a = (INF x \\<in> S. f x) \\<longleftrightarrow> (if S={} then a=top else \\<exists>x\\<in>S. a=f x \\<and> (\\<forall>y\\<in>S. a \\<le> f y))\"\n  for a :: \"_::{complete_lattice,linorder}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    (a = Inf (f ` S)) =\n    (if S = {} then a = top\n     else \\<exists>x\\<in>S. a = f x \\<and> (\\<forall>y\\<in>S. a \\<le> f y))", "by (auto \n    simp: INF_greatest INF_lower  \n    intro: finite_inf_linorder_ne_ex antisym)"], ["", "lemma sym_inv_eq[simp]: \"sym E \\<Longrightarrow> E\\<inverse> = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym E \\<Longrightarrow> E\\<inverse> = E", "unfolding sym_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y) \\<in> E \\<longrightarrow> (y, x) \\<in> E \\<Longrightarrow>\n    E\\<inverse> = E", "by auto"], ["", "lemma insert_inv[simp]: \"(insert e E)\\<inverse> = insert (prod.swap e) (E\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (insert e E)\\<inverse> = insert (prod.swap e) (E\\<inverse>)", "by (cases e) auto"], ["", "lemma inter_compl_eq_diff[simp]: \"x \\<inter> - s = x - s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<inter> - s = x - s", "by auto"], ["", "lemma inter_same_diff[simp]: \"A\\<inter>(A-S) = A-S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> (A - S) = A - S", "by blast"], ["", "lemma minus_inv_sym_aux[simp]: \"(- {(a, b), (b, a)})\\<inverse> = -{(a,b),(b,a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- {(a, b), (b, a)})\\<inverse> = - {(a, b), (b, a)}", "by auto"], ["", "subsection \\<open>The-Default\\<close>"], ["", "fun the_default :: \"'a \\<Rightarrow> 'a option \\<Rightarrow> 'a\" where\n  \"the_default d None = d\"\n| \"the_default _ (Some x) = x\""], ["", "lemma the_default_alt: \"the_default d x = (case x of None \\<Rightarrow> d | Some v \\<Rightarrow> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_default d x =\n    (case x of None \\<Rightarrow> d | Some v \\<Rightarrow> v)", "by (auto split: option.split)"], ["", "subsection \\<open>Implementing \\<open>enat\\<close> by Option\\<close>"], ["", "text \\<open>Our maps are functions to \\<open>nat option\\<close>,which are interpreted as \\<open>enat\\<close>,\n  \\<open>None\\<close> being \\<open>\\<infinity>\\<close>\\<close>"], ["", "fun enat_of_option :: \"nat option \\<Rightarrow> enat\" where\n  \"enat_of_option None = \\<infinity>\" \n| \"enat_of_option (Some n) = enat n\""], ["", "lemma enat_of_option_inj[simp]: \"enat_of_option x = enat_of_option y \\<longleftrightarrow> x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat_of_option x = enat_of_option y) = (x = y)", "by (cases x; cases y; simp)"], ["", "lemma enat_of_option_simps[simp]:\n  \"enat_of_option x = enat n \\<longleftrightarrow> x = Some n\"\n  \"enat_of_option x = \\<infinity> \\<longleftrightarrow> x = None\"\n  \"enat n = enat_of_option x \\<longleftrightarrow> x = Some n\"\n  \"\\<infinity> = enat_of_option x \\<longleftrightarrow> x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((enat_of_option x = enat n) = (x = Some n) &&&\n     (enat_of_option x = \\<infinity>) = (x = None)) &&&\n    (enat n = enat_of_option x) = (x = Some n) &&&\n    (\\<infinity> = enat_of_option x) = (x = None)", "by (cases x; auto; fail)+"], ["", "lemma enat_of_option_le_conv: \"enat_of_option m \\<le> enat_of_option n \\<longleftrightarrow> (case (m,n) of \n    (_,None) \\<Rightarrow> True\n  | (Some a, Some b) \\<Rightarrow> a\\<le>b\n  | (_, _) \\<Rightarrow> False\n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat_of_option m \\<le> enat_of_option n) =\n    (case (m, n) of (None, None) \\<Rightarrow> True\n     | (None, Some aa) \\<Rightarrow> False\n     | (Some aa, None) \\<Rightarrow> True\n     | (Some aa, Some b) \\<Rightarrow> aa \\<le> b)", "by (auto split: option.split)"], ["", "subsection \\<open>Foldr-Refine\\<close>"], ["", "lemma foldr_refine:\n  assumes \"I s\"\n  assumes \"\\<And>s x. I s \\<Longrightarrow> x\\<in>set l \\<Longrightarrow> I (f x s) \\<and> \\<alpha> (f x s) = f' x (\\<alpha> s)\"\n  shows \"I (foldr f l s) \\<and> \\<alpha> (foldr f l s) = foldr f' l (\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (foldr f l s) \\<and> \\<alpha> (foldr f l s) = foldr f' l (\\<alpha> s)", "using assms"], ["proof (prove)\nusing this:\n  I s\n  \\<lbrakk>I ?s; ?x \\<in> set l\\<rbrakk>\n  \\<Longrightarrow> I (f ?x ?s) \\<and>\n                    \\<alpha> (f ?x ?s) = f' ?x (\\<alpha> ?s)\n\ngoal (1 subgoal):\n 1. I (foldr f l s) \\<and> \\<alpha> (foldr f l s) = foldr f' l (\\<alpha> s)", "by (induction l arbitrary: s) auto"], ["", "end"]]}