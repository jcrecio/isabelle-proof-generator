{"file_name": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple/Directed_Graph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prim_Dijkstra_Simple", "problem_names": ["lemma path_append[simp]: \n  \"path u (ls1@ls2) v \\<longleftrightarrow> (\\<exists>w. path u ls1 w \\<and> path w ls2 v)\"", "lemma triv_path: \"path u [w (u,v)] v\"", "lemma paths_ne: \"paths u v \\<noteq> {}\"", "lemma find_leave_edgeE:\n  assumes \"path u p v\"\n  assumes \"u\\<in>S\" \"v\\<notin>S\"\n  obtains p1 x y p2 \n    where \"p = p1@w (x,y)#p2\" \"x\\<in>S\" \"y\\<notin>S\" \"path u p1 x\" \"path y p2 v\"", "lemma obtain_shortest_path: \n  obtains p where \"path s p u\" \"\\<delta> s u = sum_list p\"", "lemma shortest_path_least:  \n  \"path s p u \\<Longrightarrow> \\<delta> s u \\<le> sum_list p\"", "lemma distance_refl[simp]: \"\\<delta> s s = 0\"", "lemma distance_direct: \"\\<delta> s u \\<le> w (s, u)\"", "lemma triangle: \"\\<delta> s v \\<le> \\<delta> s u + w (u,v)\"", "lemma shortest_path_prefix:\n  assumes \"path s p\\<^sub>1 x\" \"path x p\\<^sub>2 u\" \n  and DSU: \"\\<delta> s u = sum_list p\\<^sub>1 + sum_list p\\<^sub>2\" \"\\<delta> s u < \\<infinity>\"\n  shows \"\\<delta> s x = sum_list p\\<^sub>1\" \"\\<delta> s x < \\<infinity>\""], "translations": [["", "lemma path_append[simp]: \n  \"path u (ls1@ls2) v \\<longleftrightarrow> (\\<exists>w. path u ls1 w \\<and> path w ls2 v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path u (ls1 @ ls2) v = (\\<exists>w. path u ls1 w \\<and> path w ls2 v)", "by (induction ls1 arbitrary: u) auto"], ["", "text \\<open>There is a singleton path between every two nodes \n  (it's weight might be \\<open>\\<infinity>\\<close>).\\<close>"], ["", "lemma triv_path: \"path u [w (u,v)] v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path u [w (u, v)] v", "by auto"], ["", "text \\<open>Shortcut for the set of all paths between two nodes\\<close>"], ["", "definition \"paths u v \\<equiv> {p . path u p v}\""], ["", "lemma paths_ne: \"paths u v \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. paths u v \\<noteq> {}", "using triv_path"], ["proof (prove)\nusing this:\n  path ?u [w (?u, ?v)] ?v\n\ngoal (1 subgoal):\n 1. paths u v \\<noteq> {}", "unfolding paths_def"], ["proof (prove)\nusing this:\n  path ?u [w (?u, ?v)] ?v\n\ngoal (1 subgoal):\n 1. {p. path u p v} \\<noteq> {}", "by blast"], ["", "text \\<open>If there is a path from a node inside a set \\<open>S\\<close>, to a node outside \n  a set \\<open>S\\<close>, this path must contain an edge from inside \\<open>S\\<close> to outside \\<open>S\\<close>.\n\\<close>"], ["", "lemma find_leave_edgeE:\n  assumes \"path u p v\"\n  assumes \"u\\<in>S\" \"v\\<notin>S\"\n  obtains p1 x y p2 \n    where \"p = p1@w (x,y)#p2\" \"x\\<in>S\" \"y\\<notin>S\" \"path u p1 x\" \"path y p2 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 x y p2.\n        \\<lbrakk>p = p1 @ w (x, y) # p2; x \\<in> S; y \\<notin> S;\n         path u p1 x; path y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p1 x y p2.\n        \\<lbrakk>p = p1 @ w (x, y) # p2; x \\<in> S; y \\<notin> S;\n         path u p1 x; path y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>p1 x y p2. p = p1@w (x,y)#p2 \\<and> x\\<in>S \\<and> y\\<notin>S \\<and> path u p1 x \\<and> path y p2 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p1 x y p2.\n       p = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v", "using assms"], ["proof (prove)\nusing this:\n  path u p v\n  u \\<in> S\n  v \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<exists>p1 x y p2.\n       p = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v", "proof (induction p arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>path u [] v; u \\<in> S; v \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p1 x y p2.\n                            [] = p1 @ w (x, y) # p2 \\<and>\n                            x \\<in> S \\<and>\n                            y \\<notin> S \\<and>\n                            path u p1 x \\<and> path y p2 v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>path u p v; u \\<in> S; v \\<notin> S\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p1 x y p2.\n  p = p1 @ w (x, y) # p2 \\<and>\n  x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v;\n        path u (a # p) v; u \\<in> S; v \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p1 x y p2.\n                            a # p = p1 @ w (x, y) # p2 \\<and>\n                            x \\<in> S \\<and>\n                            y \\<notin> S \\<and>\n                            path u p1 x \\<and> path y p2 v", "case Nil"], ["proof (state)\nthis:\n  path u [] v\n  u \\<in> S\n  v \\<notin> S\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>path u [] v; u \\<in> S; v \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p1 x y p2.\n                            [] = p1 @ w (x, y) # p2 \\<and>\n                            x \\<in> S \\<and>\n                            y \\<notin> S \\<and>\n                            path u p1 x \\<and> path y p2 v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>path u p v; u \\<in> S; v \\<notin> S\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p1 x y p2.\n  p = p1 @ w (x, y) # p2 \\<and>\n  x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v;\n        path u (a # p) v; u \\<in> S; v \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p1 x y p2.\n                            a # p = p1 @ w (x, y) # p2 \\<and>\n                            x \\<in> S \\<and>\n                            y \\<notin> S \\<and>\n                            path u p1 x \\<and> path y p2 v", "then"], ["proof (chain)\npicking this:\n  path u [] v\n  u \\<in> S\n  v \\<notin> S", "show ?case"], ["proof (prove)\nusing this:\n  path u [] v\n  u \\<in> S\n  v \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<exists>p1 x y p2.\n       [] = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v", "by auto"], ["proof (state)\nthis:\n  \\<exists>p1 x y p2.\n     [] = p1 @ w (x, y) # p2 \\<and>\n     x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>path u p v; u \\<in> S; v \\<notin> S\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p1 x y p2.\n  p = p1 @ w (x, y) # p2 \\<and>\n  x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v;\n        path u (a # p) v; u \\<in> S; v \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p1 x y p2.\n                            a # p = p1 @ w (x, y) # p2 \\<and>\n                            x \\<in> S \\<and>\n                            y \\<notin> S \\<and>\n                            path u p1 x \\<and> path y p2 v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>path u p v; u \\<in> S; v \\<notin> S\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p1 x y p2.\n  p = p1 @ w (x, y) # p2 \\<and>\n  x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v;\n        path u (a # p) v; u \\<in> S; v \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p1 x y p2.\n                            a # p = p1 @ w (x, y) # p2 \\<and>\n                            x \\<in> S \\<and>\n                            y \\<notin> S \\<and>\n                            path u p1 x \\<and> path y p2 v", "case (Cons a p)"], ["proof (state)\nthis:\n  \\<lbrakk>path ?u p v; ?u \\<in> S; v \\<notin> S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p1 x y p2.\n                       p = p1 @ w (x, y) # p2 \\<and>\n                       x \\<in> S \\<and>\n                       y \\<notin> S \\<and> path ?u p1 x \\<and> path y p2 v\n  path u (a # p) v\n  u \\<in> S\n  v \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>path u p v; u \\<in> S; v \\<notin> S\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p1 x y p2.\n  p = p1 @ w (x, y) # p2 \\<and>\n  x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v;\n        path u (a # p) v; u \\<in> S; v \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p1 x y p2.\n                            a # p = p1 @ w (x, y) # p2 \\<and>\n                            x \\<in> S \\<and>\n                            y \\<notin> S \\<and>\n                            path u p1 x \\<and> path y p2 v", "from Cons.prems"], ["proof (chain)\npicking this:\n  path u (a # p) v\n  u \\<in> S\n  v \\<notin> S", "obtain x where [simp]: \"a=w (u,x)\" and PX: \"path x p v\""], ["proof (prove)\nusing this:\n  path u (a # p) v\n  u \\<in> S\n  v \\<notin> S\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>a = w (u, x); path x p v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a = w (u, x)\n  path x p v\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>path u p v; u \\<in> S; v \\<notin> S\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>p1 x y p2.\n  p = p1 @ w (x, y) # p2 \\<and>\n  x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v;\n        path u (a # p) v; u \\<in> S; v \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p1 x y p2.\n                            a # p = p1 @ w (x, y) # p2 \\<and>\n                            x \\<in> S \\<and>\n                            y \\<notin> S \\<and>\n                            path u p1 x \\<and> path y p2 v", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p1 x y p2.\n       a # p = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v", "proof (cases \"x\\<in>S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    \\<exists>p1 x y p2.\n       a # p = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v\n 2. x \\<notin> S \\<Longrightarrow>\n    \\<exists>p1 x y p2.\n       a # p = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v", "case False"], ["proof (state)\nthis:\n  x \\<notin> S\n\ngoal (2 subgoals):\n 1. x \\<in> S \\<Longrightarrow>\n    \\<exists>p1 x y p2.\n       a # p = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v\n 2. x \\<notin> S \\<Longrightarrow>\n    \\<exists>p1 x y p2.\n       a # p = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v", "with PX \\<open>u\\<in>S\\<close>"], ["proof (chain)\npicking this:\n  path x p v\n  u \\<in> S\n  x \\<notin> S", "show ?thesis"], ["proof (prove)\nusing this:\n  path x p v\n  u \\<in> S\n  x \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<exists>p1 x y p2.\n       a # p = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>p1 x y p2.\n     a # p = p1 @ w (x, y) # p2 \\<and>\n     x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v\n\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow>\n    \\<exists>p1 x y p2.\n       a # p = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow>\n    \\<exists>p1 x y p2.\n       a # p = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v", "case True"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow>\n    \\<exists>p1 x y p2.\n       a # p = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v", "from Cons.IH[OF PX True \\<open>v\\<notin>S\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>p1 xa y p2.\n     p = p1 @ w (xa, y) # p2 \\<and>\n     xa \\<in> S \\<and> y \\<notin> S \\<and> path x p1 xa \\<and> path y p2 v", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>p1 xa y p2.\n     p = p1 @ w (xa, y) # p2 \\<and>\n     xa \\<in> S \\<and> y \\<notin> S \\<and> path x p1 xa \\<and> path y p2 v\n\ngoal (1 subgoal):\n 1. \\<exists>p1 x y p2.\n       a # p = p1 @ w (x, y) # p2 \\<and>\n       x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v", "by clarsimp (metis WGraph.path.simps(2) append_Cons)"], ["proof (state)\nthis:\n  \\<exists>p1 x y p2.\n     a # p = p1 @ w (x, y) # p2 \\<and>\n     x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p1 x y p2.\n     a # p = p1 @ w (x, y) # p2 \\<and>\n     x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p1 x y p2.\n     p = p1 @ w (x, y) # p2 \\<and>\n     x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v\n\ngoal (1 subgoal):\n 1. (\\<And>p1 x y p2.\n        \\<lbrakk>p = p1 @ w (x, y) # p2; x \\<in> S; y \\<notin> S;\n         path u p1 x; path y p2 v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>p1 x y p2.\n     p = p1 @ w (x, y) # p2 \\<and>\n     x \\<in> S \\<and> y \\<notin> S \\<and> path u p1 x \\<and> path y p2 v\n\ngoal (1 subgoal):\n 1. thesis", "by (fast intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Distance\\<close>"], ["", "text \\<open>The (minimum) distance between two nodes \\<open>u\\<close> and \\<open>v\\<close> is called \\<open>\\<delta> u v\\<close>.\\<close>"], ["", "definition \"\\<delta> u v \\<equiv> LEAST w::enat. w\\<in>sum_list`paths u v\""], ["", "lemma obtain_shortest_path: \n  obtains p where \"path s p u\" \"\\<delta> s u = sum_list p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path s p u; \\<delta> s u = sum_list p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<delta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path s p u;\n         (LEAST w. w \\<in> sum_list ` paths s u) = sum_list p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using paths_ne"], ["proof (prove)\nusing this:\n  paths ?u ?v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path s p u;\n         (LEAST w. w \\<in> sum_list ` paths s u) = sum_list p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (smt Collect_empty_eq LeastI_ex WGraph.paths_def imageI image_iff \n          mem_Collect_eq paths_def)"], ["", "lemma shortest_path_least:  \n  \"path s p u \\<Longrightarrow> \\<delta> s u \\<le> sum_list p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path s p u \\<Longrightarrow> \\<delta> s u \\<le> sum_list p", "unfolding \\<delta>_def paths_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. path s p u \\<Longrightarrow>\n    (LEAST w. w \\<in> sum_list ` {p. path s p u}) \\<le> sum_list p", "by (simp add: Least_le)"], ["", "lemma distance_refl[simp]: \"\\<delta> s s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s s = 0", "using shortest_path_least[of s \"[]\" s]"], ["proof (prove)\nusing this:\n  path s [] s \\<Longrightarrow> \\<delta> s s \\<le> sum_list []\n\ngoal (1 subgoal):\n 1. \\<delta> s s = 0", "by auto"], ["", "lemma distance_direct: \"\\<delta> s u \\<le> w (s, u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s u \\<le> w (s, u)", "using shortest_path_least[of s \"[w (s,u)]\" u]"], ["proof (prove)\nusing this:\n  path s [w (s, u)] u \\<Longrightarrow>\n  \\<delta> s u \\<le> sum_list [w (s, u)]\n\ngoal (1 subgoal):\n 1. \\<delta> s u \\<le> w (s, u)", "by auto"], ["", "text \\<open>Triangle inequality: The distance from \\<open>s\\<close> to \\<open>v\\<close> is shorter than \n  the distance from \\<open>s\\<close> to \\<open>u\\<close> and the edge weight from \\<open>u\\<close> to \\<open>v\\<close>. \\<close>"], ["", "lemma triangle: \"\\<delta> s v \\<le> \\<delta> s u + w (u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s v \\<le> \\<delta> s u + w (u, v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta> s v \\<le> \\<delta> s u + w (u, v)", "have \"path s (p@[w (u,v)]) v\" if \"path s p u\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. path s (p @ [w (u, v)]) v", "using that"], ["proof (prove)\nusing this:\n  path s p u\n\ngoal (1 subgoal):\n 1. path s (p @ [w (u, v)]) v", "by auto"], ["proof (state)\nthis:\n  path s ?p u \\<Longrightarrow> path s (?p @ [w (u, v)]) v\n\ngoal (1 subgoal):\n 1. \\<delta> s v \\<le> \\<delta> s u + w (u, v)", "then"], ["proof (chain)\npicking this:\n  path s ?p u \\<Longrightarrow> path s (?p @ [w (u, v)]) v", "have \"(+) (w (u,v)) ` sum_list ` paths s u \\<subseteq> sum_list ` paths s v\""], ["proof (prove)\nusing this:\n  path s ?p u \\<Longrightarrow> path s (?p @ [w (u, v)]) v\n\ngoal (1 subgoal):\n 1. (+) (w (u, v)) ` sum_list ` paths s u \\<subseteq> sum_list ` paths s v", "by (fastforce simp: paths_def image_iff simp del: path.simps path_append)"], ["proof (state)\nthis:\n  (+) (w (u, v)) ` sum_list ` paths s u \\<subseteq> sum_list ` paths s v\n\ngoal (1 subgoal):\n 1. \\<delta> s v \\<le> \\<delta> s u + w (u, v)", "from least_antimono[OF _ this] paths_ne"], ["proof (chain)\npicking this:\n  (+) (w (u, v)) ` sum_list ` paths s u \\<noteq> {} \\<Longrightarrow>\n  (LEAST y. y \\<in> sum_list ` paths s v)\n  \\<le> (LEAST x. x \\<in> (+) (w (u, v)) ` sum_list ` paths s u)\n  paths ?u ?v \\<noteq> {}", "have \n    \"(LEAST y::enat. y \\<in> sum_list ` paths s v) \n    \\<le> (LEAST x::enat. x \\<in> (+) (w (u,v)) ` sum_list ` paths s u)\""], ["proof (prove)\nusing this:\n  (+) (w (u, v)) ` sum_list ` paths s u \\<noteq> {} \\<Longrightarrow>\n  (LEAST y. y \\<in> sum_list ` paths s v)\n  \\<le> (LEAST x. x \\<in> (+) (w (u, v)) ` sum_list ` paths s u)\n  paths ?u ?v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (LEAST y. y \\<in> sum_list ` paths s v)\n    \\<le> (LEAST x. x \\<in> (+) (w (u, v)) ` sum_list ` paths s u)", "by (auto simp: paths_def)"], ["proof (state)\nthis:\n  (LEAST y. y \\<in> sum_list ` paths s v)\n  \\<le> (LEAST x. x \\<in> (+) (w (u, v)) ` sum_list ` paths s u)\n\ngoal (1 subgoal):\n 1. \\<delta> s v \\<le> \\<delta> s u + w (u, v)", "also"], ["proof (state)\nthis:\n  (LEAST y. y \\<in> sum_list ` paths s v)\n  \\<le> (LEAST x. x \\<in> (+) (w (u, v)) ` sum_list ` paths s u)\n\ngoal (1 subgoal):\n 1. \\<delta> s v \\<le> \\<delta> s u + w (u, v)", "have \"\\<dots> = (LEAST x. x \\<in> sum_list ` paths s u) + w (u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST x. x \\<in> (+) (w (u, v)) ` sum_list ` paths s u) =\n    (LEAST x. x \\<in> sum_list ` paths s u) + w (u, v)", "apply (subst Least_mono[of \"(+) (w (u,v))\" \"sum_list`paths s u\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. mono ((+) (w (u, v)))\n 2. \\<exists>x\\<in>sum_list ` paths s u.\n       Ball (sum_list ` paths s u) ((\\<le>) x)\n 3. w (u, v) + (LEAST x. x \\<in> sum_list ` paths s u) =\n    (LEAST x. x \\<in> sum_list ` paths s u) + w (u, v)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ((+) (w (u, v)))", "by (auto simp: mono_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>sum_list ` paths s u.\n       Ball (sum_list ` paths s u) ((\\<le>) x)\n 2. w (u, v) + (LEAST x. x \\<in> sum_list ` paths s u) =\n    (LEAST x. x \\<in> sum_list ` paths s u) + w (u, v)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>sum_list ` paths s u.\n       Ball (sum_list ` paths s u) ((\\<le>) x)", "by simp (metis paths_def mem_Collect_eq \n                          obtain_shortest_path shortest_path_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. w (u, v) + (LEAST x. x \\<in> sum_list ` paths s u) =\n    (LEAST x. x \\<in> sum_list ` paths s u) + w (u, v)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. w (u, v) + (LEAST x. x \\<in> sum_list ` paths s u) =\n    (LEAST x. x \\<in> sum_list ` paths s u) + w (u, v)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (LEAST x. x \\<in> (+) (w (u, v)) ` sum_list ` paths s u) =\n  (LEAST x. x \\<in> sum_list ` paths s u) + w (u, v)\n\ngoal (1 subgoal):\n 1. \\<delta> s v \\<le> \\<delta> s u + w (u, v)", "finally"], ["proof (chain)\npicking this:\n  (LEAST y. y \\<in> sum_list ` paths s v)\n  \\<le> (LEAST x. x \\<in> sum_list ` paths s u) + w (u, v)", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST y. y \\<in> sum_list ` paths s v)\n  \\<le> (LEAST x. x \\<in> sum_list ` paths s u) + w (u, v)\n\ngoal (1 subgoal):\n 1. \\<delta> s v \\<le> \\<delta> s u + w (u, v)", "unfolding \\<delta>_def"], ["proof (prove)\nusing this:\n  (LEAST y. y \\<in> sum_list ` paths s v)\n  \\<le> (LEAST x. x \\<in> sum_list ` paths s u) + w (u, v)\n\ngoal (1 subgoal):\n 1. (LEAST w. w \\<in> sum_list ` paths s v)\n    \\<le> (LEAST w. w \\<in> sum_list ` paths s u) + w (u, v)", "."], ["proof (state)\nthis:\n  \\<delta> s v \\<le> \\<delta> s u + w (u, v)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Any prefix of a shortest path is a shortest path itself.\n  Note: The \\<open>< \\<infinity>\\<close> conditions are required to avoid saturation in adding to \\<open>\\<infinity>\\<close>!\n\\<close>"], ["", "lemma shortest_path_prefix:\n  assumes \"path s p\\<^sub>1 x\" \"path x p\\<^sub>2 u\" \n  and DSU: \"\\<delta> s u = sum_list p\\<^sub>1 + sum_list p\\<^sub>2\" \"\\<delta> s u < \\<infinity>\"\n  shows \"\\<delta> s x = sum_list p\\<^sub>1\" \"\\<delta> s x < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s x = sum_list p\\<^sub>1 &&& \\<delta> s x < \\<infinity>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta> s x = sum_list p\\<^sub>1\n 2. \\<delta> s x < \\<infinity>", "have \"\\<delta> s x \\<le> sum_list p\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> s x \\<le> sum_list p\\<^sub>1", "using assms shortest_path_least"], ["proof (prove)\nusing this:\n  path s p\\<^sub>1 x\n  path x p\\<^sub>2 u\n  \\<delta> s u = sum_list p\\<^sub>1 + sum_list p\\<^sub>2\n  \\<delta> s u < \\<infinity>\n  path ?s ?p ?u \\<Longrightarrow> \\<delta> ?s ?u \\<le> sum_list ?p\n\ngoal (1 subgoal):\n 1. \\<delta> s x \\<le> sum_list p\\<^sub>1", "by blast"], ["proof (state)\nthis:\n  \\<delta> s x \\<le> sum_list p\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<delta> s x = sum_list p\\<^sub>1\n 2. \\<delta> s x < \\<infinity>", "moreover"], ["proof (state)\nthis:\n  \\<delta> s x \\<le> sum_list p\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<delta> s x = sum_list p\\<^sub>1\n 2. \\<delta> s x < \\<infinity>", "have \"\\<not>\\<delta> s x < sum_list p\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<delta> s x < sum_list p\\<^sub>1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta> s x < sum_list p\\<^sub>1 \\<Longrightarrow> False", "assume \"\\<delta> s x < sum_list p\\<^sub>1\""], ["proof (state)\nthis:\n  \\<delta> s x < sum_list p\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<delta> s x < sum_list p\\<^sub>1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<delta> s x < sum_list p\\<^sub>1", "obtain p\\<^sub>1' where \"path s p\\<^sub>1' x\" \"sum_list p\\<^sub>1' < sum_list p\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<delta> s x < sum_list p\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>p\\<^sub>1'.\n        \\<lbrakk>path s p\\<^sub>1' x;\n         sum_list p\\<^sub>1' < sum_list p\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: obtain_shortest_path[of s x])"], ["proof (state)\nthis:\n  path s p\\<^sub>1' x\n  sum_list p\\<^sub>1' < sum_list p\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<delta> s x < sum_list p\\<^sub>1 \\<Longrightarrow> False", "with \\<open>path x p\\<^sub>2 u\\<close> shortest_path_least[of s \"p\\<^sub>1'@p\\<^sub>2\" u] DSU"], ["proof (chain)\npicking this:\n  path x p\\<^sub>2 u\n  path s (p\\<^sub>1' @ p\\<^sub>2) u \\<Longrightarrow>\n  \\<delta> s u \\<le> sum_list (p\\<^sub>1' @ p\\<^sub>2)\n  \\<delta> s u = sum_list p\\<^sub>1 + sum_list p\\<^sub>2\n  \\<delta> s u < \\<infinity>\n  path s p\\<^sub>1' x\n  sum_list p\\<^sub>1' < sum_list p\\<^sub>1", "show False"], ["proof (prove)\nusing this:\n  path x p\\<^sub>2 u\n  path s (p\\<^sub>1' @ p\\<^sub>2) u \\<Longrightarrow>\n  \\<delta> s u \\<le> sum_list (p\\<^sub>1' @ p\\<^sub>2)\n  \\<delta> s u = sum_list p\\<^sub>1 + sum_list p\\<^sub>2\n  \\<delta> s u < \\<infinity>\n  path s p\\<^sub>1' x\n  sum_list p\\<^sub>1' < sum_list p\\<^sub>1\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> \\<delta> s x < sum_list p\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<delta> s x = sum_list p\\<^sub>1\n 2. \\<delta> s x < \\<infinity>", "ultimately"], ["proof (chain)\npicking this:\n  \\<delta> s x \\<le> sum_list p\\<^sub>1\n  \\<not> \\<delta> s x < sum_list p\\<^sub>1", "show \"\\<delta> s x = sum_list p\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<delta> s x \\<le> sum_list p\\<^sub>1\n  \\<not> \\<delta> s x < sum_list p\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<delta> s x = sum_list p\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  \\<delta> s x = sum_list p\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<infinity>", "with DSU"], ["proof (chain)\npicking this:\n  \\<delta> s u = sum_list p\\<^sub>1 + sum_list p\\<^sub>2\n  \\<delta> s u < \\<infinity>\n  \\<delta> s x = sum_list p\\<^sub>1", "show \"\\<delta> s x < \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<delta> s u = sum_list p\\<^sub>1 + sum_list p\\<^sub>2\n  \\<delta> s u < \\<infinity>\n  \\<delta> s x = sum_list p\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<infinity>", "using le_iff_add"], ["proof (prove)\nusing this:\n  \\<delta> s u = sum_list p\\<^sub>1 + sum_list p\\<^sub>2\n  \\<delta> s u < \\<infinity>\n  \\<delta> s x = sum_list p\\<^sub>1\n  (?a \\<le> ?b) = (\\<exists>c. ?b = ?a + c)\n\ngoal (1 subgoal):\n 1. \\<delta> s x < \\<infinity>", "by fastforce"], ["proof (state)\nthis:\n  \\<delta> s x < \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}