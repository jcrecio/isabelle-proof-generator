{"file_name": "/home/qj213/afp-2021-10-22/thys/FeatherweightJava/FJDefs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FeatherweightJava", "problem_names": ["lemma typing_induct:\n  assumes \"CT;\\<Gamma> \\<turnstile> e : C\" (is ?T)\n  and \"\\<And>C CT \\<Gamma> x. \\<Gamma> x = Some C \\<Longrightarrow> P CT \\<Gamma> (Var x) C\" \n  and \"\\<And>C0 CT Cf Ci \\<Gamma> e0 fDef fi. \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0; fields(CT,C0) = Cf; lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef; vdType fDef = Ci\\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\" \n  and \"\\<And>C C0 CT Cs Ds \\<Gamma> e0 es m. \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0; mtype(CT,m,C0) = Ds \\<rightarrow> C; CT;\\<Gamma> \\<turnstile>+ es : Cs; \\<And>i . \\<lbrakk> i < length es \\<rbrakk> \\<Longrightarrow>  P CT \\<Gamma> (es!i) (Cs!i); CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\"\n  and \"\\<And>C CT Cs Df Ds \\<Gamma> es. \\<lbrakk>fields(CT,C) = Df; length es = length Df; varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs; \\<And>i. \\<lbrakk> i < length es \\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (es!i) (Cs!i); CT \\<turnstile>+ Cs <: Ds\\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (New C es) C\"\n  and \"\\<And>C CT D \\<Gamma> e0. \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D; CT \\<turnstile> D <: C\\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\" \n  and \"\\<And>C CT D \\<Gamma> e0. \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D; CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\"\n  and \"\\<And>C CT D \\<Gamma> e0. \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D; CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\" \n shows \"P CT \\<Gamma> e C\" (is ?P)"], "translations": [["", "lemma typing_induct:\n  assumes \"CT;\\<Gamma> \\<turnstile> e : C\" (is ?T)\n  and \"\\<And>C CT \\<Gamma> x. \\<Gamma> x = Some C \\<Longrightarrow> P CT \\<Gamma> (Var x) C\" \n  and \"\\<And>C0 CT Cf Ci \\<Gamma> e0 fDef fi. \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0; fields(CT,C0) = Cf; lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef; vdType fDef = Ci\\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\" \n  and \"\\<And>C C0 CT Cs Ds \\<Gamma> e0 es m. \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0; mtype(CT,m,C0) = Ds \\<rightarrow> C; CT;\\<Gamma> \\<turnstile>+ es : Cs; \\<And>i . \\<lbrakk> i < length es \\<rbrakk> \\<Longrightarrow>  P CT \\<Gamma> (es!i) (Cs!i); CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\"\n  and \"\\<And>C CT Cs Df Ds \\<Gamma> es. \\<lbrakk>fields(CT,C) = Df; length es = length Df; varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs; \\<And>i. \\<lbrakk> i < length es \\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (es!i) (Cs!i); CT \\<turnstile>+ Cs <: Ds\\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (New C es) C\"\n  and \"\\<And>C CT D \\<Gamma> e0. \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D; CT \\<turnstile> D <: C\\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\" \n  and \"\\<And>C CT D \\<Gamma> e0. \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D; CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\"\n  and \"\\<And>C CT D \\<Gamma> e0. \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D; CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk> \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\" \n shows \"P CT \\<Gamma> e C\" (is ?P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P CT \\<Gamma> e C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P CT \\<Gamma> e C", "fix es Cs"], ["proof (state)\ngoal (1 subgoal):\n 1. P CT \\<Gamma> e C", "let ?IH=\"CT;\\<Gamma> \\<turnstile>+ es : Cs \\<longrightarrow> (\\<forall>i < length es.  P CT \\<Gamma> (es!i) (Cs!i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. P CT \\<Gamma> e C", "have \"?IH \\<and> (?T \\<longrightarrow> ?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CT;\\<Gamma> \\<turnstile>+ es : Cs \\<longrightarrow>\n     (\\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i))) \\<and>\n    (CT;\\<Gamma> \\<turnstile> e : C \\<longrightarrow> P CT \\<Gamma> e C)", "proof(induct rule:typings_typing.induct)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>CT \\<Gamma>. \\<forall>i<length []. P CT \\<Gamma> ([] ! i) ([] ! i)\n 2. \\<And>CT \\<Gamma> e0 C0 es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (e0 # es).\n                            P CT \\<Gamma> ((e0 # es) ! i) ((C0 # Cs) ! i)\n 3. \\<And>\\<Gamma> x C CT.\n       \\<Gamma> x = Some C \\<Longrightarrow> P CT \\<Gamma> (Var x) C\n 4. \\<And>CT \\<Gamma> e0 C0 Cf fi fDef Ci.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        fields(CT,C0) = Cf;\n        lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef;\n        vdType fDef = Ci\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\n 5. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 6. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 7. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 8. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 9. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "case (ts_nil CT \\<Gamma>)"], ["proof (state)\nthis:\n  \n\ngoal (9 subgoals):\n 1. \\<And>CT \\<Gamma>. \\<forall>i<length []. P CT \\<Gamma> ([] ! i) ([] ! i)\n 2. \\<And>CT \\<Gamma> e0 C0 es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (e0 # es).\n                            P CT \\<Gamma> ((e0 # es) ! i) ((C0 # Cs) ! i)\n 3. \\<And>\\<Gamma> x C CT.\n       \\<Gamma> x = Some C \\<Longrightarrow> P CT \\<Gamma> (Var x) C\n 4. \\<And>CT \\<Gamma> e0 C0 Cf fi fDef Ci.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        fields(CT,C0) = Cf;\n        lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef;\n        vdType fDef = Ci\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\n 5. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 6. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 7. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 8. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 9. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length []. P CT \\<Gamma> ([] ! i) ([] ! i)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length []. P CT \\<Gamma> ([] ! i) ([] ! i)\n\ngoal (8 subgoals):\n 1. \\<And>CT \\<Gamma> e0 C0 es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (e0 # es).\n                            P CT \\<Gamma> ((e0 # es) ! i) ((C0 # Cs) ! i)\n 2. \\<And>\\<Gamma> x C CT.\n       \\<Gamma> x = Some C \\<Longrightarrow> P CT \\<Gamma> (Var x) C\n 3. \\<And>CT \\<Gamma> e0 C0 Cf fi fDef Ci.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        fields(CT,C0) = Cf;\n        lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef;\n        vdType fDef = Ci\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\n 4. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 5. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 6. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 7. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 8. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>CT \\<Gamma> e0 C0 es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (e0 # es).\n                            P CT \\<Gamma> ((e0 # es) ! i) ((C0 # Cs) ! i)\n 2. \\<And>\\<Gamma> x C CT.\n       \\<Gamma> x = Some C \\<Longrightarrow> P CT \\<Gamma> (Var x) C\n 3. \\<And>CT \\<Gamma> e0 C0 Cf fi fDef Ci.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        fields(CT,C0) = Cf;\n        lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef;\n        vdType fDef = Ci\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\n 4. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 5. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 6. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 7. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 8. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "case (ts_cons CT \\<Gamma> e0 C0 es Cs)"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile> e0 : C0\n  P CT \\<Gamma> e0 C0\n  CT;\\<Gamma> \\<turnstile>+ es : Cs\n  \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i)\n\ngoal (8 subgoals):\n 1. \\<And>CT \\<Gamma> e0 C0 es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (e0 # es).\n                            P CT \\<Gamma> ((e0 # es) ! i) ((C0 # Cs) ! i)\n 2. \\<And>\\<Gamma> x C CT.\n       \\<Gamma> x = Some C \\<Longrightarrow> P CT \\<Gamma> (Var x) C\n 3. \\<And>CT \\<Gamma> e0 C0 Cf fi fDef Ci.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        fields(CT,C0) = Cf;\n        lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef;\n        vdType fDef = Ci\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\n 4. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 5. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 6. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 7. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 8. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (e0 # es).\n       P CT \\<Gamma> ((e0 # es) ! i) ((C0 # Cs) ! i)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (e0 # es) \\<longrightarrow>\n       P CT \\<Gamma> ((e0 # es) ! i) ((C0 # Cs) ! i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (e0 # es) \\<longrightarrow>\n       P CT \\<Gamma> ((e0 # es) ! i) ((C0 # Cs) ! i)", "show \"i < length (e0#es) \\<longrightarrow> P CT \\<Gamma> ((e0#es)!i) ((C0#Cs)!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (e0 # es) \\<longrightarrow>\n    P CT \\<Gamma> ((e0 # es) ! i) ((C0 # Cs) ! i)", "using ts_cons"], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile> e0 : C0\n  P CT \\<Gamma> e0 C0\n  CT;\\<Gamma> \\<turnstile>+ es : Cs\n  \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i)\n\ngoal (1 subgoal):\n 1. i < length (e0 # es) \\<longrightarrow>\n    P CT \\<Gamma> ((e0 # es) ! i) ((C0 # Cs) ! i)", "by(cases i, auto)"], ["proof (state)\nthis:\n  i < length (e0 # es) \\<longrightarrow>\n  P CT \\<Gamma> ((e0 # es) ! i) ((C0 # Cs) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length (e0 # es). P CT \\<Gamma> ((e0 # es) ! i) ((C0 # Cs) ! i)\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> x C CT.\n       \\<Gamma> x = Some C \\<Longrightarrow> P CT \\<Gamma> (Var x) C\n 2. \\<And>CT \\<Gamma> e0 C0 Cf fi fDef Ci.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        fields(CT,C0) = Cf;\n        lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef;\n        vdType fDef = Ci\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\n 3. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 4. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 5. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 6. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 7. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> x C CT.\n       \\<Gamma> x = Some C \\<Longrightarrow> P CT \\<Gamma> (Var x) C\n 2. \\<And>CT \\<Gamma> e0 C0 Cf fi fDef Ci.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        fields(CT,C0) = Cf;\n        lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef;\n        vdType fDef = Ci\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\n 3. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 4. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 5. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 6. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 7. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "case t_var"], ["proof (state)\nthis:\n  \\<Gamma>_ x_ = Some C_\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> x C CT.\n       \\<Gamma> x = Some C \\<Longrightarrow> P CT \\<Gamma> (Var x) C\n 2. \\<And>CT \\<Gamma> e0 C0 Cf fi fDef Ci.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        fields(CT,C0) = Cf;\n        lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef;\n        vdType fDef = Ci\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\n 3. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 4. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 5. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 6. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 7. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "then"], ["proof (chain)\npicking this:\n  \\<Gamma>_ x_ = Some C_", "show ?case"], ["proof (prove)\nusing this:\n  \\<Gamma>_ x_ = Some C_\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (Var x_) C_", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma>_ x_ = Some C_\n  CT;\\<Gamma> \\<turnstile> e : C\n  ?\\<Gamma> ?x = Some ?C \\<Longrightarrow> P ?CT ?\\<Gamma> (Var ?x) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; fields(?CT,?C0.0) = ?Cf;\n   lookup ?Cf (\\<lambda>fd. vdName fd = ?fi) = Some ?fDef;\n   vdType ?fDef = ?Ci\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (FieldProj ?e0.0 ?fi) ?Ci\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; mtype(?CT,?m,?C0.0) = ?Ds \\<rightarrow> ?C;\n   ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds; length ?es = length ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (MethodInvk ?e0.0 ?m ?es) ?C\n  \\<lbrakk>fields(?CT,?C) = ?Df; length ?es = length ?Df;\n   varDefs_types ?Df = ?Ds; ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (New ?C ?es) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?D <: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C <: ?D; ?C \\<noteq> ?D\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C \\<not><: ?D; ?CT \\<turnstile> ?D \\<not><: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (Var x_) C_", "by auto"], ["proof (state)\nthis:\n  P CT_ \\<Gamma>_ (Var x_) C_\n\ngoal (6 subgoals):\n 1. \\<And>CT \\<Gamma> e0 C0 Cf fi fDef Ci.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        fields(CT,C0) = Cf;\n        lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef;\n        vdType fDef = Ci\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\n 2. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 3. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 4. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 5. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 6. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>CT \\<Gamma> e0 C0 Cf fi fDef Ci.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        fields(CT,C0) = Cf;\n        lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef;\n        vdType fDef = Ci\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\n 2. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 3. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 4. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 5. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 6. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "case t_field"], ["proof (state)\nthis:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : C0_\n  P CT_ \\<Gamma>_ e0_ C0_\n  fields(CT_,C0_) = Cf_\n  lookup Cf_ (\\<lambda>fd. vdName fd = fi_) = Some fDef_\n  vdType fDef_ = Ci_\n\ngoal (6 subgoals):\n 1. \\<And>CT \\<Gamma> e0 C0 Cf fi fDef Ci.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        fields(CT,C0) = Cf;\n        lookup Cf (\\<lambda>fd. vdName fd = fi) = Some fDef;\n        vdType fDef = Ci\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (FieldProj e0 fi) Ci\n 2. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 3. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 4. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 5. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 6. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "then"], ["proof (chain)\npicking this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : C0_\n  P CT_ \\<Gamma>_ e0_ C0_\n  fields(CT_,C0_) = Cf_\n  lookup Cf_ (\\<lambda>fd. vdName fd = fi_) = Some fDef_\n  vdType fDef_ = Ci_", "show ?case"], ["proof (prove)\nusing this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : C0_\n  P CT_ \\<Gamma>_ e0_ C0_\n  fields(CT_,C0_) = Cf_\n  lookup Cf_ (\\<lambda>fd. vdName fd = fi_) = Some fDef_\n  vdType fDef_ = Ci_\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (FieldProj e0_ fi_) Ci_", "using assms"], ["proof (prove)\nusing this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : C0_\n  P CT_ \\<Gamma>_ e0_ C0_\n  fields(CT_,C0_) = Cf_\n  lookup Cf_ (\\<lambda>fd. vdName fd = fi_) = Some fDef_\n  vdType fDef_ = Ci_\n  CT;\\<Gamma> \\<turnstile> e : C\n  ?\\<Gamma> ?x = Some ?C \\<Longrightarrow> P ?CT ?\\<Gamma> (Var ?x) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; fields(?CT,?C0.0) = ?Cf;\n   lookup ?Cf (\\<lambda>fd. vdName fd = ?fi) = Some ?fDef;\n   vdType ?fDef = ?Ci\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (FieldProj ?e0.0 ?fi) ?Ci\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; mtype(?CT,?m,?C0.0) = ?Ds \\<rightarrow> ?C;\n   ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds; length ?es = length ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (MethodInvk ?e0.0 ?m ?es) ?C\n  \\<lbrakk>fields(?CT,?C) = ?Df; length ?es = length ?Df;\n   varDefs_types ?Df = ?Ds; ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (New ?C ?es) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?D <: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C <: ?D; ?C \\<noteq> ?D\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C \\<not><: ?D; ?CT \\<turnstile> ?D \\<not><: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (FieldProj e0_ fi_) Ci_", "by auto"], ["proof (state)\nthis:\n  P CT_ \\<Gamma>_ (FieldProj e0_ fi_) Ci_\n\ngoal (5 subgoals):\n 1. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 2. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 3. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 4. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 5. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 2. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 3. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 4. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 5. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "case t_invk"], ["proof (state)\nthis:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : C0_\n  P CT_ \\<Gamma>_ e0_ C0_\n  mtype(CT_,m_,C0_) = Ds_ \\<rightarrow> C_\n  CT_;\\<Gamma>_ \\<turnstile>+ es_ : Cs_\n  \\<forall>i<length es_. P CT_ \\<Gamma>_ (es_ ! i) (Cs_ ! i)\n  CT_ \\<turnstile>+ Cs_ <: Ds_\n  length es_ = length Ds_\n\ngoal (5 subgoals):\n 1. \\<And>CT \\<Gamma> e0 C0 m Ds C es Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : C0; P CT \\<Gamma> e0 C0;\n        mtype(CT,m,C0) = Ds \\<rightarrow> C;\n        CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds; length es = length Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (MethodInvk e0 m es) C\n 2. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 3. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 4. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 5. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "then"], ["proof (chain)\npicking this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : C0_\n  P CT_ \\<Gamma>_ e0_ C0_\n  mtype(CT_,m_,C0_) = Ds_ \\<rightarrow> C_\n  CT_;\\<Gamma>_ \\<turnstile>+ es_ : Cs_\n  \\<forall>i<length es_. P CT_ \\<Gamma>_ (es_ ! i) (Cs_ ! i)\n  CT_ \\<turnstile>+ Cs_ <: Ds_\n  length es_ = length Ds_", "show ?case"], ["proof (prove)\nusing this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : C0_\n  P CT_ \\<Gamma>_ e0_ C0_\n  mtype(CT_,m_,C0_) = Ds_ \\<rightarrow> C_\n  CT_;\\<Gamma>_ \\<turnstile>+ es_ : Cs_\n  \\<forall>i<length es_. P CT_ \\<Gamma>_ (es_ ! i) (Cs_ ! i)\n  CT_ \\<turnstile>+ Cs_ <: Ds_\n  length es_ = length Ds_\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (MethodInvk e0_ m_ es_) C_", "using assms"], ["proof (prove)\nusing this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : C0_\n  P CT_ \\<Gamma>_ e0_ C0_\n  mtype(CT_,m_,C0_) = Ds_ \\<rightarrow> C_\n  CT_;\\<Gamma>_ \\<turnstile>+ es_ : Cs_\n  \\<forall>i<length es_. P CT_ \\<Gamma>_ (es_ ! i) (Cs_ ! i)\n  CT_ \\<turnstile>+ Cs_ <: Ds_\n  length es_ = length Ds_\n  CT;\\<Gamma> \\<turnstile> e : C\n  ?\\<Gamma> ?x = Some ?C \\<Longrightarrow> P ?CT ?\\<Gamma> (Var ?x) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; fields(?CT,?C0.0) = ?Cf;\n   lookup ?Cf (\\<lambda>fd. vdName fd = ?fi) = Some ?fDef;\n   vdType ?fDef = ?Ci\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (FieldProj ?e0.0 ?fi) ?Ci\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; mtype(?CT,?m,?C0.0) = ?Ds \\<rightarrow> ?C;\n   ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds; length ?es = length ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (MethodInvk ?e0.0 ?m ?es) ?C\n  \\<lbrakk>fields(?CT,?C) = ?Df; length ?es = length ?Df;\n   varDefs_types ?Df = ?Ds; ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (New ?C ?es) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?D <: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C <: ?D; ?C \\<noteq> ?D\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C \\<not><: ?D; ?CT \\<turnstile> ?D \\<not><: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (MethodInvk e0_ m_ es_) C_", "by auto"], ["proof (state)\nthis:\n  P CT_ \\<Gamma>_ (MethodInvk e0_ m_ es_) C_\n\ngoal (4 subgoals):\n 1. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 2. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 3. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 4. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 2. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 3. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 4. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "case t_new"], ["proof (state)\nthis:\n  fields(CT_,C_) = Df_\n  length es_ = length Df_\n  varDefs_types Df_ = Ds_\n  CT_;\\<Gamma>_ \\<turnstile>+ es_ : Cs_\n  \\<forall>i<length es_. P CT_ \\<Gamma>_ (es_ ! i) (Cs_ ! i)\n  CT_ \\<turnstile>+ Cs_ <: Ds_\n\ngoal (4 subgoals):\n 1. \\<And>CT C Df es Ds \\<Gamma> Cs.\n       \\<lbrakk>fields(CT,C) = Df; length es = length Df;\n        varDefs_types Df = Ds; CT;\\<Gamma> \\<turnstile>+ es : Cs;\n        \\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i);\n        CT \\<turnstile>+ Cs <: Ds\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (New C es) C\n 2. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 3. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 4. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "then"], ["proof (chain)\npicking this:\n  fields(CT_,C_) = Df_\n  length es_ = length Df_\n  varDefs_types Df_ = Ds_\n  CT_;\\<Gamma>_ \\<turnstile>+ es_ : Cs_\n  \\<forall>i<length es_. P CT_ \\<Gamma>_ (es_ ! i) (Cs_ ! i)\n  CT_ \\<turnstile>+ Cs_ <: Ds_", "show ?case"], ["proof (prove)\nusing this:\n  fields(CT_,C_) = Df_\n  length es_ = length Df_\n  varDefs_types Df_ = Ds_\n  CT_;\\<Gamma>_ \\<turnstile>+ es_ : Cs_\n  \\<forall>i<length es_. P CT_ \\<Gamma>_ (es_ ! i) (Cs_ ! i)\n  CT_ \\<turnstile>+ Cs_ <: Ds_\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (New C_ es_) C_", "using assms"], ["proof (prove)\nusing this:\n  fields(CT_,C_) = Df_\n  length es_ = length Df_\n  varDefs_types Df_ = Ds_\n  CT_;\\<Gamma>_ \\<turnstile>+ es_ : Cs_\n  \\<forall>i<length es_. P CT_ \\<Gamma>_ (es_ ! i) (Cs_ ! i)\n  CT_ \\<turnstile>+ Cs_ <: Ds_\n  CT;\\<Gamma> \\<turnstile> e : C\n  ?\\<Gamma> ?x = Some ?C \\<Longrightarrow> P ?CT ?\\<Gamma> (Var ?x) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; fields(?CT,?C0.0) = ?Cf;\n   lookup ?Cf (\\<lambda>fd. vdName fd = ?fi) = Some ?fDef;\n   vdType ?fDef = ?Ci\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (FieldProj ?e0.0 ?fi) ?Ci\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; mtype(?CT,?m,?C0.0) = ?Ds \\<rightarrow> ?C;\n   ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds; length ?es = length ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (MethodInvk ?e0.0 ?m ?es) ?C\n  \\<lbrakk>fields(?CT,?C) = ?Df; length ?es = length ?Df;\n   varDefs_types ?Df = ?Ds; ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (New ?C ?es) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?D <: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C <: ?D; ?C \\<noteq> ?D\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C \\<not><: ?D; ?CT \\<turnstile> ?D \\<not><: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (New C_ es_) C_", "by auto"], ["proof (state)\nthis:\n  P CT_ \\<Gamma>_ (New C_ es_) C_\n\ngoal (3 subgoals):\n 1. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 2. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 3. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 2. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 3. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "case t_ucast"], ["proof (state)\nthis:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : D_\n  P CT_ \\<Gamma>_ e0_ D_\n  CT_ \\<turnstile> D_ <: C_\n\ngoal (3 subgoals):\n 1. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> D <: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 2. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 3. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "then"], ["proof (chain)\npicking this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : D_\n  P CT_ \\<Gamma>_ e0_ D_\n  CT_ \\<turnstile> D_ <: C_", "show ?case"], ["proof (prove)\nusing this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : D_\n  P CT_ \\<Gamma>_ e0_ D_\n  CT_ \\<turnstile> D_ <: C_\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (Cast C_ e0_) C_", "using assms"], ["proof (prove)\nusing this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : D_\n  P CT_ \\<Gamma>_ e0_ D_\n  CT_ \\<turnstile> D_ <: C_\n  CT;\\<Gamma> \\<turnstile> e : C\n  ?\\<Gamma> ?x = Some ?C \\<Longrightarrow> P ?CT ?\\<Gamma> (Var ?x) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; fields(?CT,?C0.0) = ?Cf;\n   lookup ?Cf (\\<lambda>fd. vdName fd = ?fi) = Some ?fDef;\n   vdType ?fDef = ?Ci\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (FieldProj ?e0.0 ?fi) ?Ci\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; mtype(?CT,?m,?C0.0) = ?Ds \\<rightarrow> ?C;\n   ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds; length ?es = length ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (MethodInvk ?e0.0 ?m ?es) ?C\n  \\<lbrakk>fields(?CT,?C) = ?Df; length ?es = length ?Df;\n   varDefs_types ?Df = ?Ds; ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (New ?C ?es) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?D <: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C <: ?D; ?C \\<noteq> ?D\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C \\<not><: ?D; ?CT \\<turnstile> ?D \\<not><: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (Cast C_ e0_) C_", "by auto"], ["proof (state)\nthis:\n  P CT_ \\<Gamma>_ (Cast C_ e0_) C_\n\ngoal (2 subgoals):\n 1. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 2. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 2. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "case t_dcast"], ["proof (state)\nthis:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : D_\n  P CT_ \\<Gamma>_ e0_ D_\n  CT_ \\<turnstile> C_ <: D_\n  C_ \\<noteq> D_\n\ngoal (2 subgoals):\n 1. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C <: D; C \\<noteq> D\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C\n 2. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "then"], ["proof (chain)\npicking this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : D_\n  P CT_ \\<Gamma>_ e0_ D_\n  CT_ \\<turnstile> C_ <: D_\n  C_ \\<noteq> D_", "show ?case"], ["proof (prove)\nusing this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : D_\n  P CT_ \\<Gamma>_ e0_ D_\n  CT_ \\<turnstile> C_ <: D_\n  C_ \\<noteq> D_\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (Cast C_ e0_) C_", "using assms"], ["proof (prove)\nusing this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : D_\n  P CT_ \\<Gamma>_ e0_ D_\n  CT_ \\<turnstile> C_ <: D_\n  C_ \\<noteq> D_\n  CT;\\<Gamma> \\<turnstile> e : C\n  ?\\<Gamma> ?x = Some ?C \\<Longrightarrow> P ?CT ?\\<Gamma> (Var ?x) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; fields(?CT,?C0.0) = ?Cf;\n   lookup ?Cf (\\<lambda>fd. vdName fd = ?fi) = Some ?fDef;\n   vdType ?fDef = ?Ci\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (FieldProj ?e0.0 ?fi) ?Ci\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; mtype(?CT,?m,?C0.0) = ?Ds \\<rightarrow> ?C;\n   ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds; length ?es = length ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (MethodInvk ?e0.0 ?m ?es) ?C\n  \\<lbrakk>fields(?CT,?C) = ?Df; length ?es = length ?Df;\n   varDefs_types ?Df = ?Ds; ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (New ?C ?es) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?D <: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C <: ?D; ?C \\<noteq> ?D\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C \\<not><: ?D; ?CT \\<turnstile> ?D \\<not><: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (Cast C_ e0_) C_", "by auto"], ["proof (state)\nthis:\n  P CT_ \\<Gamma>_ (Cast C_ e0_) C_\n\ngoal (1 subgoal):\n 1. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "case t_scast"], ["proof (state)\nthis:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : D_\n  P CT_ \\<Gamma>_ e0_ D_\n  CT_ \\<turnstile> C_ \\<not><: D_\n  CT_ \\<turnstile> D_ \\<not><: C_\n\ngoal (1 subgoal):\n 1. \\<And>CT \\<Gamma> e0 D C.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile> e0 : D; P CT \\<Gamma> e0 D;\n        CT \\<turnstile> C \\<not><: D; CT \\<turnstile> D \\<not><: C\\<rbrakk>\n       \\<Longrightarrow> P CT \\<Gamma> (Cast C e0) C", "then"], ["proof (chain)\npicking this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : D_\n  P CT_ \\<Gamma>_ e0_ D_\n  CT_ \\<turnstile> C_ \\<not><: D_\n  CT_ \\<turnstile> D_ \\<not><: C_", "show ?case"], ["proof (prove)\nusing this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : D_\n  P CT_ \\<Gamma>_ e0_ D_\n  CT_ \\<turnstile> C_ \\<not><: D_\n  CT_ \\<turnstile> D_ \\<not><: C_\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (Cast C_ e0_) C_", "using assms"], ["proof (prove)\nusing this:\n  CT_;\\<Gamma>_ \\<turnstile> e0_ : D_\n  P CT_ \\<Gamma>_ e0_ D_\n  CT_ \\<turnstile> C_ \\<not><: D_\n  CT_ \\<turnstile> D_ \\<not><: C_\n  CT;\\<Gamma> \\<turnstile> e : C\n  ?\\<Gamma> ?x = Some ?C \\<Longrightarrow> P ?CT ?\\<Gamma> (Var ?x) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; fields(?CT,?C0.0) = ?Cf;\n   lookup ?Cf (\\<lambda>fd. vdName fd = ?fi) = Some ?fDef;\n   vdType ?fDef = ?Ci\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (FieldProj ?e0.0 ?fi) ?Ci\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; mtype(?CT,?m,?C0.0) = ?Ds \\<rightarrow> ?C;\n   ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds; length ?es = length ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (MethodInvk ?e0.0 ?m ?es) ?C\n  \\<lbrakk>fields(?CT,?C) = ?Df; length ?es = length ?Df;\n   varDefs_types ?Df = ?Ds; ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (New ?C ?es) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?D <: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C <: ?D; ?C \\<noteq> ?D\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C \\<not><: ?D; ?CT \\<turnstile> ?D \\<not><: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n\ngoal (1 subgoal):\n 1. P CT_ \\<Gamma>_ (Cast C_ e0_) C_", "by auto"], ["proof (state)\nthis:\n  P CT_ \\<Gamma>_ (Cast C_ e0_) C_\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (CT;\\<Gamma> \\<turnstile>+ es : Cs \\<longrightarrow>\n   (\\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i))) \\<and>\n  (CT;\\<Gamma> \\<turnstile> e : C \\<longrightarrow> P CT \\<Gamma> e C)\n\ngoal (1 subgoal):\n 1. P CT \\<Gamma> e C", "thus ?thesis"], ["proof (prove)\nusing this:\n  (CT;\\<Gamma> \\<turnstile>+ es : Cs \\<longrightarrow>\n   (\\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i))) \\<and>\n  (CT;\\<Gamma> \\<turnstile> e : C \\<longrightarrow> P CT \\<Gamma> e C)\n\ngoal (1 subgoal):\n 1. P CT \\<Gamma> e C", "using assms"], ["proof (prove)\nusing this:\n  (CT;\\<Gamma> \\<turnstile>+ es : Cs \\<longrightarrow>\n   (\\<forall>i<length es. P CT \\<Gamma> (es ! i) (Cs ! i))) \\<and>\n  (CT;\\<Gamma> \\<turnstile> e : C \\<longrightarrow> P CT \\<Gamma> e C)\n  CT;\\<Gamma> \\<turnstile> e : C\n  ?\\<Gamma> ?x = Some ?C \\<Longrightarrow> P ?CT ?\\<Gamma> (Var ?x) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; fields(?CT,?C0.0) = ?Cf;\n   lookup ?Cf (\\<lambda>fd. vdName fd = ?fi) = Some ?fDef;\n   vdType ?fDef = ?Ci\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (FieldProj ?e0.0 ?fi) ?Ci\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?C0.0;\n   P ?CT ?\\<Gamma> ?e0.0 ?C0.0; mtype(?CT,?m,?C0.0) = ?Ds \\<rightarrow> ?C;\n   ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds; length ?es = length ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (MethodInvk ?e0.0 ?m ?es) ?C\n  \\<lbrakk>fields(?CT,?C) = ?Df; length ?es = length ?Df;\n   varDefs_types ?Df = ?Ds; ?CT;?\\<Gamma> \\<turnstile>+ ?es : ?Cs;\n   \\<And>i.\n      i < length ?es \\<Longrightarrow> P ?CT ?\\<Gamma> (?es ! i) (?Cs ! i);\n   ?CT \\<turnstile>+ ?Cs <: ?Ds\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (New ?C ?es) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?D <: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C <: ?D; ?C \\<noteq> ?D\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n  \\<lbrakk>?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?D; P ?CT ?\\<Gamma> ?e0.0 ?D;\n   ?CT \\<turnstile> ?C \\<not><: ?D; ?CT \\<turnstile> ?D \\<not><: ?C\\<rbrakk>\n  \\<Longrightarrow> P ?CT ?\\<Gamma> (Cast ?C ?e0.0) ?C\n\ngoal (1 subgoal):\n 1. P CT \\<Gamma> e C", "by auto"], ["proof (state)\nthis:\n  P CT \\<Gamma> e C\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Method Typing Relation\\<close>"], ["", "text \\<open>A method definition $\\mathit{md}$, declared in a class $C$, is\nwell-typed, written $\\mathit{CT} \\vdash \\mathit{md} \\texttt{OK IN}\\ C$\nif its body is well-typed and it has the same type (i.e., overrides)\nany method with the same name declared in the superclass of $C$.\\<close>"], ["", "inductive\n  method_typing :: \"[classTable, methodDef, className] \\<Rightarrow> bool\" (\"_ \\<turnstile> _ OK IN _\" [80,80,80] 80)\nwhere\nm_typing:\n  \"\\<lbrakk> CT(C) = Some(CDef);\n     cName CDef = C;\n     cSuper CDef = D;\n     mName mDef = m;\n     lookup (cMethods CDef) (\\<lambda>md.(mName md = m)) = Some(mDef);\n     mReturn mDef = C0; mParams mDef = Cxs; mBody mDef = e0;\n     varDefs_types Cxs = Cs;\n     varDefs_names Cxs = xs;\n     \\<Gamma> = (map_upds Map.empty xs Cs)(this \\<mapsto> C); \n     CT;\\<Gamma> \\<turnstile> e0 : E0;\n     CT \\<turnstile> E0 <: C0;\n     \\<forall>Ds D0. (mtype(CT,m,D) = Ds \\<rightarrow> D0) \\<longrightarrow> (Cs=Ds \\<and> C0=D0) \\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> mDef OK IN C\""], ["", "inductive\n  method_typings :: \"[classTable, methodDef list, className] \\<Rightarrow> bool\" (\"_ \\<turnstile>+ _ OK IN _\" [80,80,80] 80)\nwhere\n  ms_nil : \n  \"CT \\<turnstile>+ [] OK IN C\"\n\n| ms_cons : \n  \"\\<lbrakk> CT \\<turnstile> m OK IN C; \n     CT \\<turnstile>+ ms OK IN C \\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile>+ (m # ms) OK IN C\""], ["", "subsection \\<open>Class Typing Relation\\<close>"], ["", "text \\<open>A class definition $\\mathit{cd}$ is well-typed, written\n$\\mathit{CT}\\vdash \\mathit{cd} \\texttt{OK}$ if its constructor\ninitializes each field, and all of its methods are well-typed.\\<close>"], ["", "inductive\n  class_typing :: \"[classTable, classDef] \\<Rightarrow> bool\" (\"_ \\<turnstile> _ OK\" [80,80] 80)\nwhere\nt_class: \"\\<lbrakk> cName CDef = C;            \n            cSuper CDef = D;\n            cConstructor CDef = KDef;\n            cMethods CDef = M;\n            kName KDef = C;\n            kParams KDef = (Dg@Cf);\n            kSuper KDef = varDefs_names Dg;\n            kInits KDef = varDefs_names Cf;\n            fields(CT,D) = Dg;\n            CT \\<turnstile>+ M OK IN C \\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> CDef OK\""], ["", "subsection \\<open>Class Table Typing Relation\\<close>"], ["", "text \\<open>A class table is well-typed, written $\\mathit{CT}\\\n\\texttt{OK}$ if for every class name $C$, the class definition mapped\nto by $\\mathit{CT}$ is is well-typed and has name $C$.\\<close>"], ["", "inductive\n  ct_typing :: \"classTable \\<Rightarrow> bool\" (\"_ OK\" 80)\nwhere\nct_all_ok: \n  \"\\<lbrakk> Object \\<notin> dom(CT); \n     \\<forall>C CDef. CT(C) = Some(CDef) \\<longrightarrow> (CT \\<turnstile> CDef OK) \\<and> (cName CDef = C) \\<rbrakk>\n  \\<Longrightarrow> CT OK\""], ["", "subsection \\<open>Evaluation Relation\\<close>"], ["", "text \\<open>The single-step and multi-step evaluation relations are\nwritten $\\mathit{CT} \\vdash e \\rightarrow e'$ and $\\mathit{CT} \\vdash\ne \\rightarrow^* e'$ respectively.\\<close>"], ["", "inductive\n  reduction :: \"[classTable, exp, exp] \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<rightarrow> _\" [80,80,80] 80)\nwhere\n\n  r_field: \n  \"\\<lbrakk> fields(CT,C) = Cf;                   \n     lookup2 Cf es (\\<lambda>fd.(vdName fd = fi)) = Some(ei) \\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> FieldProj (New C es) fi \\<rightarrow> ei\"\n\n| r_invk: \n  \"\\<lbrakk> mbody(CT,m,C) = xs . e0;\n     substs ((map_upds Map.empty xs ds)(this \\<mapsto> (New C es))) e0 = e0' \\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> MethodInvk (New C es) m ds \\<rightarrow> e0'\"\n\n| r_cast: \n  \"\\<lbrakk> CT \\<turnstile> C <: D \\<rbrakk> \n  \\<Longrightarrow> CT \\<turnstile> Cast D (New C es) \\<rightarrow> New C es\"\n\n| rc_field: \n  \"\\<lbrakk> CT \\<turnstile> e0 \\<rightarrow> e0' \\<rbrakk> \n  \\<Longrightarrow> CT \\<turnstile> FieldProj e0 f \\<rightarrow> FieldProj e0' f\"\n\n| rc_invk_recv: \n  \"\\<lbrakk> CT \\<turnstile> e0 \\<rightarrow> e0' \\<rbrakk> \n  \\<Longrightarrow> CT \\<turnstile> MethodInvk e0 m es \\<rightarrow> MethodInvk e0' m es\"\n\n| rc_invk_arg: \n  \"\\<lbrakk> CT \\<turnstile> ei \\<rightarrow> ei' \\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> MethodInvk e0 m (el@ei#er) \\<rightarrow> MethodInvk e0 m (el@ei'#er)\"\n\n| rc_new_arg: \n  \"\\<lbrakk> CT \\<turnstile> ei \\<rightarrow> ei' \\<rbrakk> \n  \\<Longrightarrow> CT \\<turnstile> New C (el@ei#er) \\<rightarrow> New C (el@ei'#er)\"\n\n| rc_cast: \n  \"\\<lbrakk> CT \\<turnstile> e0 \\<rightarrow> e0' \\<rbrakk> \n  \\<Longrightarrow> CT \\<turnstile> Cast C e0 \\<rightarrow> Cast C e0'\""], ["", "inductive\n  reductions :: \"[classTable, exp, exp] \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<rightarrow>* _\" [80,80,80] 80)\nwhere\n  rs_refl: \"CT \\<turnstile> e \\<rightarrow>* e\" \n| rs_trans: \"\\<lbrakk> CT \\<turnstile> e \\<rightarrow> e'; CT \\<turnstile> e' \\<rightarrow>* e'' \\<rbrakk> \\<Longrightarrow>  CT \\<turnstile> e \\<rightarrow>* e''\""], ["", "end"]]}