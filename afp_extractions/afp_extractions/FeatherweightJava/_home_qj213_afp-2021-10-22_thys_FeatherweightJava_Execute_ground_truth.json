{"file_name": "/home/qj213/afp-2021-10-22/thys/FeatherweightJava/Execute.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FeatherweightJava", "problem_names": ["lemma [code_pred_intro]: \"append [] xs xs\"", "lemma [code_pred_intro]: \"append xs ys zs \\<Longrightarrow> append (x#xs) ys (x#zs)\"", "lemma rc_invk_arg': \"CT \\<turnstile> ei \\<rightarrow> ei' \\<Longrightarrow> append el (ei # er) e' \\<Longrightarrow> append el (ei' # er) e'' \\<Longrightarrow>\nCT \\<turnstile> MethodInvk e m e' \\<rightarrow> MethodInvk e m e''\"", "lemma rc_new_arg': \"CT \\<turnstile> ei \\<rightarrow> ei' \\<Longrightarrow> append el (ei # er) e \\<Longrightarrow> append el (ei' # er) e'\n   ==> CT \\<turnstile> New C e \\<rightarrow> New C e'\"", "lemmas [code_pred_intro] = reduction.intros(1-5)\n  rc_invk_arg' rc_new_arg' reduction.intros(8)", "lemma method_typing_aux:\n  \"(\\<forall>Ds D0. mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<longrightarrow> Cs = Ds \\<and> C = D0) = (\\<not> method_typing_aux CT m D Cs C)\"", "lemma [code_pred_intro]:\n  \"mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<Longrightarrow> Cs \\<noteq> Ds \\<Longrightarrow> method_typing_aux CT m D Cs C\"", "lemma [code_pred_intro]:\n  \"mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<Longrightarrow> C \\<noteq> D0 \\<Longrightarrow> method_typing_aux CT m D Cs C\""], "translations": [["", "lemma [code_pred_intro]: \"append [] xs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Execute.append [] xs xs", "unfolding append_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [] @ xs", "by simp"], ["", "lemma [code_pred_intro]: \"append xs ys zs \\<Longrightarrow> append (x#xs) ys (x#zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Execute.append xs ys zs \\<Longrightarrow>\n    Execute.append (x # xs) ys (x # zs)", "unfolding append_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. zs = xs @ ys \\<Longrightarrow> x # zs = (x # xs) @ ys", "by simp"], ["", "text \\<open>With this at hand, we derive new introduction rules for the reduction relation:\\<close>"], ["", "lemma rc_invk_arg': \"CT \\<turnstile> ei \\<rightarrow> ei' \\<Longrightarrow> append el (ei # er) e' \\<Longrightarrow> append el (ei' # er) e'' \\<Longrightarrow>\nCT \\<turnstile> MethodInvk e m e' \\<rightarrow> MethodInvk e m e''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CT \\<turnstile> ei \\<rightarrow> ei';\n     Execute.append el (ei # er) e';\n     Execute.append el (ei' # er) e''\\<rbrakk>\n    \\<Longrightarrow> CT \\<turnstile> MethodInvk e m\n e' \\<rightarrow> MethodInvk e m e''", "unfolding append_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CT \\<turnstile> ei \\<rightarrow> ei'; e' = el @ ei # er;\n     e'' = el @ ei' # er\\<rbrakk>\n    \\<Longrightarrow> CT \\<turnstile> MethodInvk e m\n e' \\<rightarrow> MethodInvk e m e''", "by simp (rule reduction.intros(6))"], ["", "lemma rc_new_arg': \"CT \\<turnstile> ei \\<rightarrow> ei' \\<Longrightarrow> append el (ei # er) e \\<Longrightarrow> append el (ei' # er) e'\n   ==> CT \\<turnstile> New C e \\<rightarrow> New C e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CT \\<turnstile> ei \\<rightarrow> ei';\n     Execute.append el (ei # er) e; Execute.append el (ei' # er) e'\\<rbrakk>\n    \\<Longrightarrow> CT \\<turnstile> New C e \\<rightarrow> New C e'", "unfolding append_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CT \\<turnstile> ei \\<rightarrow> ei'; e = el @ ei # er;\n     e' = el @ ei' # er\\<rbrakk>\n    \\<Longrightarrow> CT \\<turnstile> New C e \\<rightarrow> New C e'", "by simp (rule reduction.intros(7))"], ["", "lemmas [code_pred_intro] = reduction.intros(1-5)\n  rc_invk_arg' rc_new_arg' reduction.intros(8)"], ["", "code_pred (modes: i => i => i => bool, i => i => o => bool as reduce) reduction"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>x \\<turnstile> xa \\<rightarrow> xb;\n      \\<And>CT C es fi ei Cf.\n         \\<lbrakk>x = CT; xa = FieldProj (New C es) fi; xb = ei;\n          fields(CT,C) = Cf;\n          lookup2 Cf es (\\<lambda>fd. vdName fd = fi) = Some ei\\<rbrakk>\n         \\<Longrightarrow> thesis;\n      \\<And>CTa_ Ca_ esa_ m_ ds_ e0'_ xs_ e0_.\n         \\<lbrakk>x = CTa_; xa = MethodInvk (New Ca_ esa_) m_ ds_;\n          xb = e0'_; mbody(CTa_,m_,Ca_) = xs_ . e0_;\n          substs [xs_ [\\<mapsto>] ds_, this \\<mapsto> New Ca_ esa_] e0_ =\n          e0'_\\<rbrakk>\n         \\<Longrightarrow> thesis;\n      \\<And>CTa_ D_ Ca_ esa_.\n         \\<lbrakk>x = CTa_; xa = Cast D_ (New Ca_ esa_); xb = New Ca_ esa_;\n          CTa_ \\<turnstile> Ca_ <: D_\\<rbrakk>\n         \\<Longrightarrow> thesis;\n      \\<And>CTa_ e0_ f_ e0'_.\n         \\<lbrakk>x = CTa_; xa = FieldProj e0_ f_; xb = FieldProj e0'_ f_;\n          CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n         \\<Longrightarrow> thesis;\n      \\<And>CTa_ e0_ m_ esa_ e0'_.\n         \\<lbrakk>x = CTa_; xa = MethodInvk e0_ m_ esa_;\n          xb = MethodInvk e0'_ m_ esa_;\n          CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n         \\<Longrightarrow> thesis;\n      \\<And>CTa_ e_ m_ e'_ e''_ eia_ ei'_ el_ er_.\n         \\<lbrakk>x = CTa_; xa = MethodInvk e_ m_ e'_;\n          xb = MethodInvk e_ m_ e''_;\n          CTa_ \\<turnstile> eia_ \\<rightarrow> ei'_;\n          Execute.append el_ (eia_ # er_) e'_;\n          Execute.append el_ (ei'_ # er_) e''_\\<rbrakk>\n         \\<Longrightarrow> thesis;\n      \\<And>CTa_ Ca_ ea_ e'_ eia_ ei'_ el_ er_.\n         \\<lbrakk>x = CTa_; xa = New Ca_ ea_; xb = New Ca_ e'_;\n          CTa_ \\<turnstile> eia_ \\<rightarrow> ei'_;\n          Execute.append el_ (eia_ # er_) ea_;\n          Execute.append el_ (ei'_ # er_) e'_\\<rbrakk>\n         \\<Longrightarrow> thesis;\n      \\<And>CTa_ Ca_ e0_ e0'_.\n         \\<lbrakk>x = CTa_; xa = Cast Ca_ e0_; xb = Cast Ca_ e0'_;\n          CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n         \\<Longrightarrow> thesis\\<rbrakk>\n     \\<Longrightarrow> thesis) &&&\n    (\\<lbrakk>Execute.append xa xb xc;\n      \\<And>xs.\n         \\<lbrakk>xa = []; xb = xs; xc = xs\\<rbrakk>\n         \\<Longrightarrow> thesis;\n      \\<And>x_ xsa_ ys_ zs_.\n         \\<lbrakk>xa = x_ # xsa_; xb = ys_; xc = x_ # zs_;\n          Execute.append xsa_ ys_ zs_\\<rbrakk>\n         \\<Longrightarrow> thesis\\<rbrakk>\n     \\<Longrightarrow> thesis)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<turnstile> xa \\<rightarrow> xb;\n     \\<And>CT C es fi ei Cf.\n        \\<lbrakk>x = CT; xa = FieldProj (New C es) fi; xb = ei;\n         fields(CT,C) = Cf;\n         lookup2 Cf es (\\<lambda>fd. vdName fd = fi) = Some ei\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ esa_ m_ ds_ e0'_ xs_ e0_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk (New Ca_ esa_) m_ ds_; xb = e0'_;\n         mbody(CTa_,m_,Ca_) = xs_ . e0_;\n         substs [xs_ [\\<mapsto>] ds_, this \\<mapsto> New Ca_ esa_] e0_ =\n         e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ D_ Ca_ esa_.\n        \\<lbrakk>x = CTa_; xa = Cast D_ (New Ca_ esa_); xb = New Ca_ esa_;\n         CTa_ \\<turnstile> Ca_ <: D_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e0_ f_ e0'_.\n        \\<lbrakk>x = CTa_; xa = FieldProj e0_ f_; xb = FieldProj e0'_ f_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e0_ m_ esa_ e0'_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk e0_ m_ esa_;\n         xb = MethodInvk e0'_ m_ esa_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e_ m_ e'_ e''_ eia_ ei'_ el_ er_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk e_ m_ e'_;\n         xb = MethodInvk e_ m_ e''_;\n         CTa_ \\<turnstile> eia_ \\<rightarrow> ei'_;\n         Execute.append el_ (eia_ # er_) e'_;\n         Execute.append el_ (ei'_ # er_) e''_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ ea_ e'_ eia_ ei'_ el_ er_.\n        \\<lbrakk>x = CTa_; xa = New Ca_ ea_; xb = New Ca_ e'_;\n         CTa_ \\<turnstile> eia_ \\<rightarrow> ei'_;\n         Execute.append el_ (eia_ # er_) ea_;\n         Execute.append el_ (ei'_ # er_) e'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ e0_ e0'_.\n        \\<lbrakk>x = CTa_; xa = Cast Ca_ e0_; xb = Cast Ca_ e0'_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>Execute.append xa xb xc;\n     \\<And>xs.\n        \\<lbrakk>xa = []; xb = xs; xc = xs\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>x_ xsa_ ys_ zs_.\n        \\<lbrakk>xa = x_ # xsa_; xb = ys_; xc = x_ # zs_;\n         Execute.append xsa_ ys_ zs_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "case append"], ["proof (state)\nthis:\n  \\<lbrakk>xa = []; xb = ?xs; xc = ?xs\\<rbrakk> \\<Longrightarrow> thesis\n  \\<lbrakk>xa = ?x # ?xsa; xb = ?ys; xc = ?x # ?zs;\n   Execute.append ?xsa ?ys ?zs\\<rbrakk>\n  \\<Longrightarrow> thesis\n  Execute.append xa xb xc\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<turnstile> xa \\<rightarrow> xb;\n     \\<And>CT C es fi ei Cf.\n        \\<lbrakk>x = CT; xa = FieldProj (New C es) fi; xb = ei;\n         fields(CT,C) = Cf;\n         lookup2 Cf es (\\<lambda>fd. vdName fd = fi) = Some ei\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ esa_ m_ ds_ e0'_ xs_ e0_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk (New Ca_ esa_) m_ ds_; xb = e0'_;\n         mbody(CTa_,m_,Ca_) = xs_ . e0_;\n         substs [xs_ [\\<mapsto>] ds_, this \\<mapsto> New Ca_ esa_] e0_ =\n         e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ D_ Ca_ esa_.\n        \\<lbrakk>x = CTa_; xa = Cast D_ (New Ca_ esa_); xb = New Ca_ esa_;\n         CTa_ \\<turnstile> Ca_ <: D_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e0_ f_ e0'_.\n        \\<lbrakk>x = CTa_; xa = FieldProj e0_ f_; xb = FieldProj e0'_ f_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e0_ m_ esa_ e0'_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk e0_ m_ esa_;\n         xb = MethodInvk e0'_ m_ esa_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e_ m_ e'_ e''_ eia_ ei'_ el_ er_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk e_ m_ e'_;\n         xb = MethodInvk e_ m_ e''_;\n         CTa_ \\<turnstile> eia_ \\<rightarrow> ei'_;\n         Execute.append el_ (eia_ # er_) e'_;\n         Execute.append el_ (ei'_ # er_) e''_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ ea_ e'_ eia_ ei'_ el_ er_.\n        \\<lbrakk>x = CTa_; xa = New Ca_ ea_; xb = New Ca_ e'_;\n         CTa_ \\<turnstile> eia_ \\<rightarrow> ei'_;\n         Execute.append el_ (eia_ # er_) ea_;\n         Execute.append el_ (ei'_ # er_) e'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ e0_ e0'_.\n        \\<lbrakk>x = CTa_; xa = Cast Ca_ e0_; xb = Cast Ca_ e0'_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>Execute.append xa xb xc;\n     \\<And>xs.\n        \\<lbrakk>xa = []; xb = xs; xc = xs\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>x_ xsa_ ys_ zs_.\n        \\<lbrakk>xa = x_ # xsa_; xb = ys_; xc = x_ # zs_;\n         Execute.append xsa_ ys_ zs_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>xa = []; xb = ?xs; xc = ?xs\\<rbrakk> \\<Longrightarrow> thesis\n  \\<lbrakk>xa = ?x # ?xsa; xb = ?ys; xc = ?x # ?zs;\n   Execute.append ?xsa ?ys ?zs\\<rbrakk>\n  \\<Longrightarrow> thesis\n  Execute.append xa xb xc", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>xa = []; xb = ?xs; xc = ?xs\\<rbrakk> \\<Longrightarrow> thesis\n  \\<lbrakk>xa = ?x # ?xsa; xb = ?ys; xc = ?x # ?zs;\n   Execute.append ?xsa ?ys ?zs\\<rbrakk>\n  \\<Longrightarrow> thesis\n  Execute.append xa xb xc\n\ngoal (1 subgoal):\n 1. thesis", "unfolding append_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>xa = []; xb = ?xs; xc = ?xs\\<rbrakk> \\<Longrightarrow> thesis\n  \\<lbrakk>xa = ?x # ?xsa; xb = ?ys; xc = ?x # ?zs;\n   ?zs = ?xsa @ ?ys\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xc = xa @ xb\n\ngoal (1 subgoal):\n 1. thesis", "by (cases xa) fastforce+"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<turnstile> xa \\<rightarrow> xb;\n     \\<And>CT C es fi ei Cf.\n        \\<lbrakk>x = CT; xa = FieldProj (New C es) fi; xb = ei;\n         fields(CT,C) = Cf;\n         lookup2 Cf es (\\<lambda>fd. vdName fd = fi) = Some ei\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ esa_ m_ ds_ e0'_ xs_ e0_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk (New Ca_ esa_) m_ ds_; xb = e0'_;\n         mbody(CTa_,m_,Ca_) = xs_ . e0_;\n         substs [xs_ [\\<mapsto>] ds_, this \\<mapsto> New Ca_ esa_] e0_ =\n         e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ D_ Ca_ esa_.\n        \\<lbrakk>x = CTa_; xa = Cast D_ (New Ca_ esa_); xb = New Ca_ esa_;\n         CTa_ \\<turnstile> Ca_ <: D_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e0_ f_ e0'_.\n        \\<lbrakk>x = CTa_; xa = FieldProj e0_ f_; xb = FieldProj e0'_ f_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e0_ m_ esa_ e0'_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk e0_ m_ esa_;\n         xb = MethodInvk e0'_ m_ esa_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e_ m_ e'_ e''_ eia_ ei'_ el_ er_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk e_ m_ e'_;\n         xb = MethodInvk e_ m_ e''_;\n         CTa_ \\<turnstile> eia_ \\<rightarrow> ei'_;\n         Execute.append el_ (eia_ # er_) e'_;\n         Execute.append el_ (ei'_ # er_) e''_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ ea_ e'_ eia_ ei'_ el_ er_.\n        \\<lbrakk>x = CTa_; xa = New Ca_ ea_; xb = New Ca_ e'_;\n         CTa_ \\<turnstile> eia_ \\<rightarrow> ei'_;\n         Execute.append el_ (eia_ # er_) ea_;\n         Execute.append el_ (ei'_ # er_) e'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ e0_ e0'_.\n        \\<lbrakk>x = CTa_; xa = Cast Ca_ e0_; xb = Cast Ca_ e0'_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<turnstile> xa \\<rightarrow> xb;\n     \\<And>CT C es fi ei Cf.\n        \\<lbrakk>x = CT; xa = FieldProj (New C es) fi; xb = ei;\n         fields(CT,C) = Cf;\n         lookup2 Cf es (\\<lambda>fd. vdName fd = fi) = Some ei\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ esa_ m_ ds_ e0'_ xs_ e0_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk (New Ca_ esa_) m_ ds_; xb = e0'_;\n         mbody(CTa_,m_,Ca_) = xs_ . e0_;\n         substs [xs_ [\\<mapsto>] ds_, this \\<mapsto> New Ca_ esa_] e0_ =\n         e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ D_ Ca_ esa_.\n        \\<lbrakk>x = CTa_; xa = Cast D_ (New Ca_ esa_); xb = New Ca_ esa_;\n         CTa_ \\<turnstile> Ca_ <: D_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e0_ f_ e0'_.\n        \\<lbrakk>x = CTa_; xa = FieldProj e0_ f_; xb = FieldProj e0'_ f_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e0_ m_ esa_ e0'_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk e0_ m_ esa_;\n         xb = MethodInvk e0'_ m_ esa_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e_ m_ e'_ e''_ eia_ ei'_ el_ er_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk e_ m_ e'_;\n         xb = MethodInvk e_ m_ e''_;\n         CTa_ \\<turnstile> eia_ \\<rightarrow> ei'_;\n         Execute.append el_ (eia_ # er_) e'_;\n         Execute.append el_ (ei'_ # er_) e''_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ ea_ e'_ eia_ ei'_ el_ er_.\n        \\<lbrakk>x = CTa_; xa = New Ca_ ea_; xb = New Ca_ e'_;\n         CTa_ \\<turnstile> eia_ \\<rightarrow> ei'_;\n         Execute.append el_ (eia_ # er_) ea_;\n         Execute.append el_ (ei'_ # er_) e'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ e0_ e0'_.\n        \\<lbrakk>x = CTa_; xa = Cast Ca_ e0_; xb = Cast Ca_ e0'_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "case reduction"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?CT; xa = FieldProj (New ?C ?es) ?fi; xb = ?ei;\n   fields(?CT,?C) = ?Cf;\n   lookup2 ?Cf ?es (\\<lambda>fd. vdName fd = ?fi) = Some ?ei\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?CTa; xa = MethodInvk (New ?Ca ?esa) ?m ?ds; xb = ?e0';\n   mbody(?CTa,?m,?Ca) = ?xs . ?e0.0;\n   substs [?xs [\\<mapsto>] ?ds, this \\<mapsto> New ?Ca ?esa] ?e0.0 =\n   ?e0'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?CTa; xa = Cast ?D (New ?Ca ?esa); xb = New ?Ca ?esa;\n   ?CTa \\<turnstile> ?Ca <: ?D\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?CTa; xa = FieldProj ?e0.0 ?f; xb = FieldProj ?e0' ?f;\n   ?CTa \\<turnstile> ?e0.0 \\<rightarrow> ?e0'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?CTa; xa = MethodInvk ?e0.0 ?m ?esa;\n   xb = MethodInvk ?e0' ?m ?esa;\n   ?CTa \\<turnstile> ?e0.0 \\<rightarrow> ?e0'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?CTa; xa = MethodInvk ?e ?m ?e'; xb = MethodInvk ?e ?m ?e'';\n   ?CTa \\<turnstile> ?eia \\<rightarrow> ?ei';\n   Execute.append ?el (?eia # ?er) ?e';\n   Execute.append ?el (?ei' # ?er) ?e''\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?CTa; xa = New ?Ca ?ea; xb = New ?Ca ?e';\n   ?CTa \\<turnstile> ?eia \\<rightarrow> ?ei';\n   Execute.append ?el (?eia # ?er) ?ea;\n   Execute.append ?el (?ei' # ?er) ?e'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?CTa; xa = Cast ?Ca ?e0.0; xb = Cast ?Ca ?e0';\n   ?CTa \\<turnstile> ?e0.0 \\<rightarrow> ?e0'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  x \\<turnstile> xa \\<rightarrow> xb\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<turnstile> xa \\<rightarrow> xb;\n     \\<And>CT C es fi ei Cf.\n        \\<lbrakk>x = CT; xa = FieldProj (New C es) fi; xb = ei;\n         fields(CT,C) = Cf;\n         lookup2 Cf es (\\<lambda>fd. vdName fd = fi) = Some ei\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ esa_ m_ ds_ e0'_ xs_ e0_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk (New Ca_ esa_) m_ ds_; xb = e0'_;\n         mbody(CTa_,m_,Ca_) = xs_ . e0_;\n         substs [xs_ [\\<mapsto>] ds_, this \\<mapsto> New Ca_ esa_] e0_ =\n         e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ D_ Ca_ esa_.\n        \\<lbrakk>x = CTa_; xa = Cast D_ (New Ca_ esa_); xb = New Ca_ esa_;\n         CTa_ \\<turnstile> Ca_ <: D_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e0_ f_ e0'_.\n        \\<lbrakk>x = CTa_; xa = FieldProj e0_ f_; xb = FieldProj e0'_ f_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e0_ m_ esa_ e0'_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk e0_ m_ esa_;\n         xb = MethodInvk e0'_ m_ esa_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ e_ m_ e'_ e''_ eia_ ei'_ el_ er_.\n        \\<lbrakk>x = CTa_; xa = MethodInvk e_ m_ e'_;\n         xb = MethodInvk e_ m_ e''_;\n         CTa_ \\<turnstile> eia_ \\<rightarrow> ei'_;\n         Execute.append el_ (eia_ # er_) e'_;\n         Execute.append el_ (ei'_ # er_) e''_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ ea_ e'_ eia_ ei'_ el_ er_.\n        \\<lbrakk>x = CTa_; xa = New Ca_ ea_; xb = New Ca_ e'_;\n         CTa_ \\<turnstile> eia_ \\<rightarrow> ei'_;\n         Execute.append el_ (eia_ # er_) ea_;\n         Execute.append el_ (ei'_ # er_) e'_\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ Ca_ e0_ e0'_.\n        \\<lbrakk>x = CTa_; xa = Cast Ca_ e0_; xb = Cast Ca_ e0'_;\n         CTa_ \\<turnstile> e0_ \\<rightarrow> e0'_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "from reduction.prems"], ["proof (chain)\npicking this:\n  x \\<turnstile> xa \\<rightarrow> xb", "show thesis"], ["proof (prove)\nusing this:\n  x \\<turnstile> xa \\<rightarrow> xb\n\ngoal (1 subgoal):\n 1. thesis", "proof (cases rule: reduction.cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>C Cf es fi.\n       \\<lbrakk>xa = FieldProj (New C es) fi; fields(x,C) = Cf;\n        lookup2 Cf es (\\<lambda>fd. vdName fd = fi) = Some xb\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>m C xs e0 ds es.\n       \\<lbrakk>xa = MethodInvk (New C es) m ds; mbody(x,m,C) = xs . e0;\n        substs [xs [\\<mapsto>] ds, this \\<mapsto> New C es] e0 = xb\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>C D es.\n       \\<lbrakk>xa = Cast D (New C es); xb = New C es;\n        x \\<turnstile> C <: D\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>e0 e0' f.\n       \\<lbrakk>xa = FieldProj e0 f; xb = FieldProj e0' f;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case r_field"], ["proof (state)\nthis:\n  xa = FieldProj (New C_ es_) fi_\n  fields(x,C_) = Cf_\n  lookup2 Cf_ es_ (\\<lambda>fd. vdName fd = fi_) = Some xb\n\ngoal (8 subgoals):\n 1. \\<And>C Cf es fi.\n       \\<lbrakk>xa = FieldProj (New C es) fi; fields(x,C) = Cf;\n        lookup2 Cf es (\\<lambda>fd. vdName fd = fi) = Some xb\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>m C xs e0 ds es.\n       \\<lbrakk>xa = MethodInvk (New C es) m ds; mbody(x,m,C) = xs . e0;\n        substs [xs [\\<mapsto>] ds, this \\<mapsto> New C es] e0 = xb\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>C D es.\n       \\<lbrakk>xa = Cast D (New C es); xb = New C es;\n        x \\<turnstile> C <: D\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>e0 e0' f.\n       \\<lbrakk>xa = FieldProj e0 f; xb = FieldProj e0' f;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "with reduction(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = ?CT; xa = FieldProj (New ?C ?es) ?fi; xb = ?ei;\n   fields(?CT,?C) = ?Cf;\n   lookup2 ?Cf ?es (\\<lambda>fd. vdName fd = ?fi) = Some ?ei\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = FieldProj (New C_ es_) fi_\n  fields(x,C_) = Cf_\n  lookup2 Cf_ es_ (\\<lambda>fd. vdName fd = fi_) = Some xb", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?CT; xa = FieldProj (New ?C ?es) ?fi; xb = ?ei;\n   fields(?CT,?C) = ?Cf;\n   lookup2 ?Cf ?es (\\<lambda>fd. vdName fd = ?fi) = Some ?ei\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = FieldProj (New C_ es_) fi_\n  fields(x,C_) = Cf_\n  lookup2 Cf_ es_ (\\<lambda>fd. vdName fd = fi_) = Some xb\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal (7 subgoals):\n 1. \\<And>m C xs e0 ds es.\n       \\<lbrakk>xa = MethodInvk (New C es) m ds; mbody(x,m,C) = xs . e0;\n        substs [xs [\\<mapsto>] ds, this \\<mapsto> New C es] e0 = xb\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>C D es.\n       \\<lbrakk>xa = Cast D (New C es); xb = New C es;\n        x \\<turnstile> C <: D\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>e0 e0' f.\n       \\<lbrakk>xa = FieldProj e0 f; xb = FieldProj e0' f;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>m C xs e0 ds es.\n       \\<lbrakk>xa = MethodInvk (New C es) m ds; mbody(x,m,C) = xs . e0;\n        substs [xs [\\<mapsto>] ds, this \\<mapsto> New C es] e0 = xb\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>C D es.\n       \\<lbrakk>xa = Cast D (New C es); xb = New C es;\n        x \\<turnstile> C <: D\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>e0 e0' f.\n       \\<lbrakk>xa = FieldProj e0 f; xb = FieldProj e0' f;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case r_invk"], ["proof (state)\nthis:\n  xa = MethodInvk (New C_ es_) m_ ds_\n  mbody(x,m_,C_) = xs_ . e0_\n  substs [xs_ [\\<mapsto>] ds_, this \\<mapsto> New C_ es_] e0_ = xb\n\ngoal (7 subgoals):\n 1. \\<And>m C xs e0 ds es.\n       \\<lbrakk>xa = MethodInvk (New C es) m ds; mbody(x,m,C) = xs . e0;\n        substs [xs [\\<mapsto>] ds, this \\<mapsto> New C es] e0 = xb\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>C D es.\n       \\<lbrakk>xa = Cast D (New C es); xb = New C es;\n        x \\<turnstile> C <: D\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>e0 e0' f.\n       \\<lbrakk>xa = FieldProj e0 f; xb = FieldProj e0' f;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "with reduction(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = ?CTa; xa = MethodInvk (New ?Ca ?esa) ?m ?ds; xb = ?e0';\n   mbody(?CTa,?m,?Ca) = ?xs . ?e0.0;\n   substs [?xs [\\<mapsto>] ?ds, this \\<mapsto> New ?Ca ?esa] ?e0.0 =\n   ?e0'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = MethodInvk (New C_ es_) m_ ds_\n  mbody(x,m_,C_) = xs_ . e0_\n  substs [xs_ [\\<mapsto>] ds_, this \\<mapsto> New C_ es_] e0_ = xb", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?CTa; xa = MethodInvk (New ?Ca ?esa) ?m ?ds; xb = ?e0';\n   mbody(?CTa,?m,?Ca) = ?xs . ?e0.0;\n   substs [?xs [\\<mapsto>] ?ds, this \\<mapsto> New ?Ca ?esa] ?e0.0 =\n   ?e0'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = MethodInvk (New C_ es_) m_ ds_\n  mbody(x,m_,C_) = xs_ . e0_\n  substs [xs_ [\\<mapsto>] ds_, this \\<mapsto> New C_ es_] e0_ = xb\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal (6 subgoals):\n 1. \\<And>C D es.\n       \\<lbrakk>xa = Cast D (New C es); xb = New C es;\n        x \\<turnstile> C <: D\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>e0 e0' f.\n       \\<lbrakk>xa = FieldProj e0 f; xb = FieldProj e0' f;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>C D es.\n       \\<lbrakk>xa = Cast D (New C es); xb = New C es;\n        x \\<turnstile> C <: D\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>e0 e0' f.\n       \\<lbrakk>xa = FieldProj e0 f; xb = FieldProj e0' f;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case r_cast"], ["proof (state)\nthis:\n  xa = Cast D_ (New C_ es_)\n  xb = New C_ es_\n  x \\<turnstile> C_ <: D_\n\ngoal (6 subgoals):\n 1. \\<And>C D es.\n       \\<lbrakk>xa = Cast D (New C es); xb = New C es;\n        x \\<turnstile> C <: D\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>e0 e0' f.\n       \\<lbrakk>xa = FieldProj e0 f; xb = FieldProj e0' f;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "with reduction(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = ?CTa; xa = Cast ?D (New ?Ca ?esa); xb = New ?Ca ?esa;\n   ?CTa \\<turnstile> ?Ca <: ?D\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = Cast D_ (New C_ es_)\n  xb = New C_ es_\n  x \\<turnstile> C_ <: D_", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?CTa; xa = Cast ?D (New ?Ca ?esa); xb = New ?Ca ?esa;\n   ?CTa \\<turnstile> ?Ca <: ?D\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = Cast D_ (New C_ es_)\n  xb = New C_ es_\n  x \\<turnstile> C_ <: D_\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal (5 subgoals):\n 1. \\<And>e0 e0' f.\n       \\<lbrakk>xa = FieldProj e0 f; xb = FieldProj e0' f;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e0 e0' f.\n       \\<lbrakk>xa = FieldProj e0 f; xb = FieldProj e0' f;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case rc_field"], ["proof (state)\nthis:\n  xa = FieldProj e0_ f_\n  xb = FieldProj e0'_ f_\n  x \\<turnstile> e0_ \\<rightarrow> e0'_\n\ngoal (5 subgoals):\n 1. \\<And>e0 e0' f.\n       \\<lbrakk>xa = FieldProj e0 f; xb = FieldProj e0' f;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "with reduction(4)"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = ?CTa; xa = FieldProj ?e0.0 ?f; xb = FieldProj ?e0' ?f;\n   ?CTa \\<turnstile> ?e0.0 \\<rightarrow> ?e0'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = FieldProj e0_ f_\n  xb = FieldProj e0'_ f_\n  x \\<turnstile> e0_ \\<rightarrow> e0'_", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?CTa; xa = FieldProj ?e0.0 ?f; xb = FieldProj ?e0' ?f;\n   ?CTa \\<turnstile> ?e0.0 \\<rightarrow> ?e0'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = FieldProj e0_ f_\n  xb = FieldProj e0'_ f_\n  x \\<turnstile> e0_ \\<rightarrow> e0'_\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal (4 subgoals):\n 1. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case rc_invk_recv"], ["proof (state)\nthis:\n  xa = MethodInvk e0_ m_ es_\n  xb = MethodInvk e0'_ m_ es_\n  x \\<turnstile> e0_ \\<rightarrow> e0'_\n\ngoal (4 subgoals):\n 1. \\<And>e0 e0' m es.\n       \\<lbrakk>xa = MethodInvk e0 m es; xb = MethodInvk e0' m es;\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "with reduction(5)"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = ?CTa; xa = MethodInvk ?e0.0 ?m ?esa;\n   xb = MethodInvk ?e0' ?m ?esa;\n   ?CTa \\<turnstile> ?e0.0 \\<rightarrow> ?e0'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = MethodInvk e0_ m_ es_\n  xb = MethodInvk e0'_ m_ es_\n  x \\<turnstile> e0_ \\<rightarrow> e0'_", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?CTa; xa = MethodInvk ?e0.0 ?m ?esa;\n   xb = MethodInvk ?e0' ?m ?esa;\n   ?CTa \\<turnstile> ?e0.0 \\<rightarrow> ?e0'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = MethodInvk e0_ m_ es_\n  xb = MethodInvk e0'_ m_ es_\n  x \\<turnstile> e0_ \\<rightarrow> e0'_\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal (3 subgoals):\n 1. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case rc_invk_arg"], ["proof (state)\nthis:\n  xa = MethodInvk e0_ m_ (el_ @ ei_ # er_)\n  xb = MethodInvk e0_ m_ (el_ @ ei'_ # er_)\n  x \\<turnstile> ei_ \\<rightarrow> ei'_\n\ngoal (3 subgoals):\n 1. \\<And>ei ei' e0 m el er.\n       \\<lbrakk>xa = MethodInvk e0 m (el @ ei # er);\n        xb = MethodInvk e0 m (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "with reduction(6)"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = ?CTa; xa = MethodInvk ?e ?m ?e'; xb = MethodInvk ?e ?m ?e'';\n   ?CTa \\<turnstile> ?eia \\<rightarrow> ?ei';\n   Execute.append ?el (?eia # ?er) ?e';\n   Execute.append ?el (?ei' # ?er) ?e''\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = MethodInvk e0_ m_ (el_ @ ei_ # er_)\n  xb = MethodInvk e0_ m_ (el_ @ ei'_ # er_)\n  x \\<turnstile> ei_ \\<rightarrow> ei'_", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?CTa; xa = MethodInvk ?e ?m ?e'; xb = MethodInvk ?e ?m ?e'';\n   ?CTa \\<turnstile> ?eia \\<rightarrow> ?ei';\n   Execute.append ?el (?eia # ?er) ?e';\n   Execute.append ?el (?ei' # ?er) ?e''\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = MethodInvk e0_ m_ (el_ @ ei_ # er_)\n  xb = MethodInvk e0_ m_ (el_ @ ei'_ # er_)\n  x \\<turnstile> ei_ \\<rightarrow> ei'_\n\ngoal (1 subgoal):\n 1. thesis", "unfolding append_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?CTa; xa = MethodInvk ?e ?m ?e'; xb = MethodInvk ?e ?m ?e'';\n   ?CTa \\<turnstile> ?eia \\<rightarrow> ?ei'; ?e' = ?el @ ?eia # ?er;\n   ?e'' = ?el @ ?ei' # ?er\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = MethodInvk e0_ m_ (el_ @ ei_ # er_)\n  xb = MethodInvk e0_ m_ (el_ @ ei'_ # er_)\n  x \\<turnstile> ei_ \\<rightarrow> ei'_\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case rc_new_arg"], ["proof (state)\nthis:\n  xa = New C_ (el_ @ ei_ # er_)\n  xb = New C_ (el_ @ ei'_ # er_)\n  x \\<turnstile> ei_ \\<rightarrow> ei'_\n\ngoal (2 subgoals):\n 1. \\<And>ei ei' C el er.\n       \\<lbrakk>xa = New C (el @ ei # er); xb = New C (el @ ei' # er);\n        x \\<turnstile> ei \\<rightarrow> ei'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "with reduction(7)"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = ?CTa; xa = New ?Ca ?ea; xb = New ?Ca ?e';\n   ?CTa \\<turnstile> ?eia \\<rightarrow> ?ei';\n   Execute.append ?el (?eia # ?er) ?ea;\n   Execute.append ?el (?ei' # ?er) ?e'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = New C_ (el_ @ ei_ # er_)\n  xb = New C_ (el_ @ ei'_ # er_)\n  x \\<turnstile> ei_ \\<rightarrow> ei'_", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?CTa; xa = New ?Ca ?ea; xb = New ?Ca ?e';\n   ?CTa \\<turnstile> ?eia \\<rightarrow> ?ei';\n   Execute.append ?el (?eia # ?er) ?ea;\n   Execute.append ?el (?ei' # ?er) ?e'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = New C_ (el_ @ ei_ # er_)\n  xb = New C_ (el_ @ ei'_ # er_)\n  x \\<turnstile> ei_ \\<rightarrow> ei'_\n\ngoal (1 subgoal):\n 1. thesis", "unfolding append_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?CTa; xa = New ?Ca ?ea; xb = New ?Ca ?e';\n   ?CTa \\<turnstile> ?eia \\<rightarrow> ?ei'; ?ea = ?el @ ?eia # ?er;\n   ?e' = ?el @ ?ei' # ?er\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = New C_ (el_ @ ei_ # er_)\n  xb = New C_ (el_ @ ei'_ # er_)\n  x \\<turnstile> ei_ \\<rightarrow> ei'_\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case rc_cast"], ["proof (state)\nthis:\n  xa = Cast C_ e0_\n  xb = Cast C_ e0'_\n  x \\<turnstile> e0_ \\<rightarrow> e0'_\n\ngoal (1 subgoal):\n 1. \\<And>e0 e0' C.\n       \\<lbrakk>xa = Cast C e0; xb = Cast C e0';\n        x \\<turnstile> e0 \\<rightarrow> e0'\\<rbrakk>\n       \\<Longrightarrow> thesis", "with reduction(8)"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = ?CTa; xa = Cast ?Ca ?e0.0; xb = Cast ?Ca ?e0';\n   ?CTa \\<turnstile> ?e0.0 \\<rightarrow> ?e0'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = Cast C_ e0_\n  xb = Cast C_ e0'_\n  x \\<turnstile> e0_ \\<rightarrow> e0'_", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?CTa; xa = Cast ?Ca ?e0.0; xb = Cast ?Ca ?e0';\n   ?CTa \\<turnstile> ?e0.0 \\<rightarrow> ?e0'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  xa = Cast C_ e0_\n  xb = Cast C_ e0'_\n  x \\<turnstile> e0_ \\<rightarrow> e0'_\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "thm reduction.equation"], ["", "code_pred reductions"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "thm reductions.equation"], ["", "text \\<open>We also make the class typing executable: this requires that\n  we derive rules for @{term \"method_typing\"}.\\<close>"], ["", "definition method_typing_aux\nwhere\n  \"method_typing_aux CT m D Cs C = (\\<not> (\\<forall>Ds D0. mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<longrightarrow> Cs = Ds \\<and> C = D0))\""], ["", "lemma method_typing_aux:\n  \"(\\<forall>Ds D0. mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<longrightarrow> Cs = Ds \\<and> C = D0) = (\\<not> method_typing_aux CT m D Cs C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>Ds D0.\n        mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<longrightarrow>\n        Cs = Ds \\<and> C = D0) =\n    (\\<not> method_typing_aux CT m D Cs C)", "unfolding method_typing_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>Ds D0.\n        mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<longrightarrow>\n        Cs = Ds \\<and> C = D0) =\n    (\\<not> \\<not> (\\<forall>Ds D0.\n                       mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<longrightarrow>\n                       Cs = Ds \\<and> C = D0))", "by auto"], ["", "lemma [code_pred_intro]:\n  \"mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<Longrightarrow> Cs \\<noteq> Ds \\<Longrightarrow> method_typing_aux CT m D Cs C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mtype(CT,m,D) = Ds \\<rightarrow> D0; Cs \\<noteq> Ds\\<rbrakk>\n    \\<Longrightarrow> method_typing_aux CT m D Cs C", "unfolding method_typing_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mtype(CT,m,D) = Ds \\<rightarrow> D0; Cs \\<noteq> Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<forall>Ds D0.\n                                 mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<longrightarrow>\n                                 Cs = Ds \\<and> C = D0)", "by auto"], ["", "lemma [code_pred_intro]:\n  \"mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<Longrightarrow> C \\<noteq> D0 \\<Longrightarrow> method_typing_aux CT m D Cs C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mtype(CT,m,D) = Ds \\<rightarrow> D0; C \\<noteq> D0\\<rbrakk>\n    \\<Longrightarrow> method_typing_aux CT m D Cs C", "unfolding method_typing_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mtype(CT,m,D) = Ds \\<rightarrow> D0; C \\<noteq> D0\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<forall>Ds D0.\n                                 mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<longrightarrow>\n                                 Cs = Ds \\<and> C = D0)", "by auto"], ["", "declare method_typing.intros[unfolded method_typing_aux, code_pred_intro]"], ["", "declare class_typing.intros[unfolded append_def[symmetric], code_pred_intro]"], ["", "code_pred (modes: i => i => bool) class_typing"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>x \\<turnstile> xa OK;\n      \\<And>CT CDef C D KDef M Dg Cf.\n         \\<lbrakk>x = CT; xa = CDef; cName CDef = C; cSuper CDef = D;\n          cConstructor CDef = KDef; cMethods CDef = M; kName KDef = C;\n          Execute.append Dg Cf (kParams KDef);\n          kSuper KDef = varDefs_names Dg; kInits KDef = varDefs_names Cf;\n          fields(CT,D) = Dg; CT \\<turnstile>+ M OK IN C\\<rbrakk>\n         \\<Longrightarrow> thesis\\<rbrakk>\n     \\<Longrightarrow> thesis) &&&\n    (\\<lbrakk>x \\<turnstile> xa OK IN xb;\n      \\<And>CT mDef C CDef D m C0 Cxs e0 Cs xs \\<Gamma> E0.\n         \\<lbrakk>x = CT; xa = mDef; xb = C; CT C = Some CDef;\n          cName CDef = C; cSuper CDef = D; mName mDef = m;\n          lookup (cMethods CDef) (\\<lambda>md. mName md = m) = Some mDef;\n          mReturn mDef = C0; mParams mDef = Cxs; mBody mDef = e0;\n          varDefs_types Cxs = Cs; varDefs_names Cxs = xs;\n          \\<Gamma> = [xs [\\<mapsto>] Cs, this \\<mapsto> C];\n          CT;\\<Gamma> \\<turnstile> e0 : E0; CT \\<turnstile> E0 <: C0;\n          \\<not> method_typing_aux CT m D Cs C0\\<rbrakk>\n         \\<Longrightarrow> thesis\\<rbrakk>\n     \\<Longrightarrow> thesis) &&&\n    (\\<lbrakk>method_typing_aux x xa xb xc xd;\n      \\<And>CT m D Cs C Ds D0.\n         \\<lbrakk>x = CT; xa = m; xb = D; xc = Cs; xd = C;\n          mtype(CT,m,D) = Ds \\<rightarrow> D0; Cs \\<noteq> Ds\\<rbrakk>\n         \\<Longrightarrow> thesis;\n      \\<And>CTa_ ma_ Da_ Csa_ Ca_ Dsa_ D0a_.\n         \\<lbrakk>x = CTa_; xa = ma_; xb = Da_; xc = Csa_; xd = Ca_;\n          mtype(CTa_,ma_,Da_) = Dsa_ \\<rightarrow> D0a_;\n          Ca_ \\<noteq> D0a_\\<rbrakk>\n         \\<Longrightarrow> thesis\\<rbrakk>\n     \\<Longrightarrow> thesis)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<turnstile> xa OK;\n     \\<And>CT CDef C D KDef M Dg Cf.\n        \\<lbrakk>x = CT; xa = CDef; cName CDef = C; cSuper CDef = D;\n         cConstructor CDef = KDef; cMethods CDef = M; kName KDef = C;\n         Execute.append Dg Cf (kParams KDef);\n         kSuper KDef = varDefs_names Dg; kInits KDef = varDefs_names Cf;\n         fields(CT,D) = Dg; CT \\<turnstile>+ M OK IN C\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>x \\<turnstile> xa OK IN xb;\n     \\<And>CT mDef C CDef D m C0 Cxs e0 Cs xs \\<Gamma> E0.\n        \\<lbrakk>x = CT; xa = mDef; xb = C; CT C = Some CDef;\n         cName CDef = C; cSuper CDef = D; mName mDef = m;\n         lookup (cMethods CDef) (\\<lambda>md. mName md = m) = Some mDef;\n         mReturn mDef = C0; mParams mDef = Cxs; mBody mDef = e0;\n         varDefs_types Cxs = Cs; varDefs_names Cxs = xs;\n         \\<Gamma> = [xs [\\<mapsto>] Cs, this \\<mapsto> C];\n         CT;\\<Gamma> \\<turnstile> e0 : E0; CT \\<turnstile> E0 <: C0;\n         \\<not> method_typing_aux CT m D Cs C0\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>method_typing_aux x xa xb xc xd;\n     \\<And>CT m D Cs C Ds D0.\n        \\<lbrakk>x = CT; xa = m; xb = D; xc = Cs; xd = C;\n         mtype(CT,m,D) = Ds \\<rightarrow> D0; Cs \\<noteq> Ds\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ ma_ Da_ Csa_ Ca_ Dsa_ D0a_.\n        \\<lbrakk>x = CTa_; xa = ma_; xb = Da_; xc = Csa_; xd = Ca_;\n         mtype(CTa_,ma_,Da_) = Dsa_ \\<rightarrow> D0a_;\n         Ca_ \\<noteq> D0a_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "case class_typing"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?CT; xa = ?CDef; cName ?CDef = ?C; cSuper ?CDef = ?D;\n   cConstructor ?CDef = ?KDef; cMethods ?CDef = ?M; kName ?KDef = ?C;\n   Execute.append ?Dg ?Cf (kParams ?KDef); kSuper ?KDef = varDefs_names ?Dg;\n   kInits ?KDef = varDefs_names ?Cf; fields(?CT,?D) = ?Dg;\n   ?CT \\<turnstile>+ ?M OK IN ?C\\<rbrakk>\n  \\<Longrightarrow> thesis\n  x \\<turnstile> xa OK\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<turnstile> xa OK;\n     \\<And>CT CDef C D KDef M Dg Cf.\n        \\<lbrakk>x = CT; xa = CDef; cName CDef = C; cSuper CDef = D;\n         cConstructor CDef = KDef; cMethods CDef = M; kName KDef = C;\n         Execute.append Dg Cf (kParams KDef);\n         kSuper KDef = varDefs_names Dg; kInits KDef = varDefs_names Cf;\n         fields(CT,D) = Dg; CT \\<turnstile>+ M OK IN C\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>x \\<turnstile> xa OK IN xb;\n     \\<And>CT mDef C CDef D m C0 Cxs e0 Cs xs \\<Gamma> E0.\n        \\<lbrakk>x = CT; xa = mDef; xb = C; CT C = Some CDef;\n         cName CDef = C; cSuper CDef = D; mName mDef = m;\n         lookup (cMethods CDef) (\\<lambda>md. mName md = m) = Some mDef;\n         mReturn mDef = C0; mParams mDef = Cxs; mBody mDef = e0;\n         varDefs_types Cxs = Cs; varDefs_names Cxs = xs;\n         \\<Gamma> = [xs [\\<mapsto>] Cs, this \\<mapsto> C];\n         CT;\\<Gamma> \\<turnstile> e0 : E0; CT \\<turnstile> E0 <: C0;\n         \\<not> method_typing_aux CT m D Cs C0\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>method_typing_aux x xa xb xc xd;\n     \\<And>CT m D Cs C Ds D0.\n        \\<lbrakk>x = CT; xa = m; xb = D; xc = Cs; xd = C;\n         mtype(CT,m,D) = Ds \\<rightarrow> D0; Cs \\<noteq> Ds\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ ma_ Da_ Csa_ Ca_ Dsa_ D0a_.\n        \\<lbrakk>x = CTa_; xa = ma_; xb = Da_; xc = Csa_; xd = Ca_;\n         mtype(CTa_,ma_,Da_) = Dsa_ \\<rightarrow> D0a_;\n         Ca_ \\<noteq> D0a_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "from class_typing.cases[OF class_typing.prems, of thesis] this(1)"], ["proof (chain)\npicking this:\n  (\\<And>CDef C D KDef M Dg Cf CT.\n      \\<lbrakk>x = CT; xa = CDef; cName CDef = C; cSuper CDef = D;\n       cConstructor CDef = KDef; cMethods CDef = M; kName KDef = C;\n       kParams KDef = Dg @ Cf; kSuper KDef = varDefs_names Dg;\n       kInits KDef = varDefs_names Cf; fields(CT,D) = Dg;\n       CT \\<turnstile>+ M OK IN C\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n  \\<lbrakk>x = ?CT; xa = ?CDef; cName ?CDef = ?C; cSuper ?CDef = ?D;\n   cConstructor ?CDef = ?KDef; cMethods ?CDef = ?M; kName ?KDef = ?C;\n   Execute.append ?Dg ?Cf (kParams ?KDef); kSuper ?KDef = varDefs_names ?Dg;\n   kInits ?KDef = varDefs_names ?Cf; fields(?CT,?D) = ?Dg;\n   ?CT \\<turnstile>+ ?M OK IN ?C\\<rbrakk>\n  \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\nusing this:\n  (\\<And>CDef C D KDef M Dg Cf CT.\n      \\<lbrakk>x = CT; xa = CDef; cName CDef = C; cSuper CDef = D;\n       cConstructor CDef = KDef; cMethods CDef = M; kName KDef = C;\n       kParams KDef = Dg @ Cf; kSuper KDef = varDefs_names Dg;\n       kInits KDef = varDefs_names Cf; fields(CT,D) = Dg;\n       CT \\<turnstile>+ M OK IN C\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n  \\<lbrakk>x = ?CT; xa = ?CDef; cName ?CDef = ?C; cSuper ?CDef = ?D;\n   cConstructor ?CDef = ?KDef; cMethods ?CDef = ?M; kName ?KDef = ?C;\n   Execute.append ?Dg ?Cf (kParams ?KDef); kSuper ?KDef = varDefs_names ?Dg;\n   kInits ?KDef = varDefs_names ?Cf; fields(?CT,?D) = ?Dg;\n   ?CT \\<turnstile>+ ?M OK IN ?C\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "unfolding append_def"], ["proof (prove)\nusing this:\n  (\\<And>CDef C D KDef M Dg Cf CT.\n      \\<lbrakk>x = CT; xa = CDef; cName CDef = C; cSuper CDef = D;\n       cConstructor CDef = KDef; cMethods CDef = M; kName KDef = C;\n       kParams KDef = Dg @ Cf; kSuper KDef = varDefs_names Dg;\n       kInits KDef = varDefs_names Cf; fields(CT,D) = Dg;\n       CT \\<turnstile>+ M OK IN C\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n  \\<lbrakk>x = ?CT; xa = ?CDef; cName ?CDef = ?C; cSuper ?CDef = ?D;\n   cConstructor ?CDef = ?KDef; cMethods ?CDef = ?M; kName ?KDef = ?C;\n   kParams ?KDef = ?Dg @ ?Cf; kSuper ?KDef = varDefs_names ?Dg;\n   kInits ?KDef = varDefs_names ?Cf; fields(?CT,?D) = ?Dg;\n   ?CT \\<turnstile>+ ?M OK IN ?C\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<turnstile> xa OK IN xb;\n     \\<And>CT mDef C CDef D m C0 Cxs e0 Cs xs \\<Gamma> E0.\n        \\<lbrakk>x = CT; xa = mDef; xb = C; CT C = Some CDef;\n         cName CDef = C; cSuper CDef = D; mName mDef = m;\n         lookup (cMethods CDef) (\\<lambda>md. mName md = m) = Some mDef;\n         mReturn mDef = C0; mParams mDef = Cxs; mBody mDef = e0;\n         varDefs_types Cxs = Cs; varDefs_names Cxs = xs;\n         \\<Gamma> = [xs [\\<mapsto>] Cs, this \\<mapsto> C];\n         CT;\\<Gamma> \\<turnstile> e0 : E0; CT \\<turnstile> E0 <: C0;\n         \\<not> method_typing_aux CT m D Cs C0\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>method_typing_aux x xa xb xc xd;\n     \\<And>CT m D Cs C Ds D0.\n        \\<lbrakk>x = CT; xa = m; xb = D; xc = Cs; xd = C;\n         mtype(CT,m,D) = Ds \\<rightarrow> D0; Cs \\<noteq> Ds\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ ma_ Da_ Csa_ Ca_ Dsa_ D0a_.\n        \\<lbrakk>x = CTa_; xa = ma_; xb = Da_; xc = Csa_; xd = Ca_;\n         mtype(CTa_,ma_,Da_) = Dsa_ \\<rightarrow> D0a_;\n         Ca_ \\<noteq> D0a_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<turnstile> xa OK IN xb;\n     \\<And>CT mDef C CDef D m C0 Cxs e0 Cs xs \\<Gamma> E0.\n        \\<lbrakk>x = CT; xa = mDef; xb = C; CT C = Some CDef;\n         cName CDef = C; cSuper CDef = D; mName mDef = m;\n         lookup (cMethods CDef) (\\<lambda>md. mName md = m) = Some mDef;\n         mReturn mDef = C0; mParams mDef = Cxs; mBody mDef = e0;\n         varDefs_types Cxs = Cs; varDefs_names Cxs = xs;\n         \\<Gamma> = [xs [\\<mapsto>] Cs, this \\<mapsto> C];\n         CT;\\<Gamma> \\<turnstile> e0 : E0; CT \\<turnstile> E0 <: C0;\n         \\<not> method_typing_aux CT m D Cs C0\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>method_typing_aux x xa xb xc xd;\n     \\<And>CT m D Cs C Ds D0.\n        \\<lbrakk>x = CT; xa = m; xb = D; xc = Cs; xd = C;\n         mtype(CT,m,D) = Ds \\<rightarrow> D0; Cs \\<noteq> Ds\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ ma_ Da_ Csa_ Ca_ Dsa_ D0a_.\n        \\<lbrakk>x = CTa_; xa = ma_; xb = Da_; xc = Csa_; xd = Ca_;\n         mtype(CTa_,ma_,Da_) = Dsa_ \\<rightarrow> D0a_;\n         Ca_ \\<noteq> D0a_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "case method_typing"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?CT; xa = ?mDef; xb = ?C; ?CT ?C = Some ?CDef;\n   cName ?CDef = ?C; cSuper ?CDef = ?D; mName ?mDef = ?m;\n   lookup (cMethods ?CDef) (\\<lambda>md. mName md = ?m) = Some ?mDef;\n   mReturn ?mDef = ?C0.0; mParams ?mDef = ?Cxs; mBody ?mDef = ?e0.0;\n   varDefs_types ?Cxs = ?Cs; varDefs_names ?Cxs = ?xs;\n   ?\\<Gamma> = [?xs [\\<mapsto>] ?Cs, this \\<mapsto> ?C];\n   ?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?E0.0;\n   ?CT \\<turnstile> ?E0.0 <: ?C0.0;\n   \\<not> method_typing_aux ?CT ?m ?D ?Cs ?C0.0\\<rbrakk>\n  \\<Longrightarrow> thesis\n  x \\<turnstile> xa OK IN xb\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<turnstile> xa OK IN xb;\n     \\<And>CT mDef C CDef D m C0 Cxs e0 Cs xs \\<Gamma> E0.\n        \\<lbrakk>x = CT; xa = mDef; xb = C; CT C = Some CDef;\n         cName CDef = C; cSuper CDef = D; mName mDef = m;\n         lookup (cMethods CDef) (\\<lambda>md. mName md = m) = Some mDef;\n         mReturn mDef = C0; mParams mDef = Cxs; mBody mDef = e0;\n         varDefs_types Cxs = Cs; varDefs_names Cxs = xs;\n         \\<Gamma> = [xs [\\<mapsto>] Cs, this \\<mapsto> C];\n         CT;\\<Gamma> \\<turnstile> e0 : E0; CT \\<turnstile> E0 <: C0;\n         \\<not> method_typing_aux CT m D Cs C0\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>method_typing_aux x xa xb xc xd;\n     \\<And>CT m D Cs C Ds D0.\n        \\<lbrakk>x = CT; xa = m; xb = D; xc = Cs; xd = C;\n         mtype(CT,m,D) = Ds \\<rightarrow> D0; Cs \\<noteq> Ds\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ ma_ Da_ Csa_ Ca_ Dsa_ D0a_.\n        \\<lbrakk>x = CTa_; xa = ma_; xb = Da_; xc = Csa_; xd = Ca_;\n         mtype(CTa_,ma_,Da_) = Dsa_ \\<rightarrow> D0a_;\n         Ca_ \\<noteq> D0a_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "from method_typing.cases[OF method_typing.prems, of thesis] this(1)"], ["proof (chain)\npicking this:\n  (\\<And>CT C CDef D mDef m C0 Cxs e0 Cs xs \\<Gamma> E0.\n      \\<lbrakk>x = CT; xa = mDef; xb = C; CT C = Some CDef; cName CDef = C;\n       cSuper CDef = D; mName mDef = m;\n       lookup (cMethods CDef) (\\<lambda>md. mName md = m) = Some mDef;\n       mReturn mDef = C0; mParams mDef = Cxs; mBody mDef = e0;\n       varDefs_types Cxs = Cs; varDefs_names Cxs = xs;\n       \\<Gamma> = [xs [\\<mapsto>] Cs, this \\<mapsto> C];\n       CT;\\<Gamma> \\<turnstile> e0 : E0; CT \\<turnstile> E0 <: C0;\n       \\<forall>Ds D0.\n          mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<longrightarrow>\n          Cs = Ds \\<and> C0 = D0\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n  \\<lbrakk>x = ?CT; xa = ?mDef; xb = ?C; ?CT ?C = Some ?CDef;\n   cName ?CDef = ?C; cSuper ?CDef = ?D; mName ?mDef = ?m;\n   lookup (cMethods ?CDef) (\\<lambda>md. mName md = ?m) = Some ?mDef;\n   mReturn ?mDef = ?C0.0; mParams ?mDef = ?Cxs; mBody ?mDef = ?e0.0;\n   varDefs_types ?Cxs = ?Cs; varDefs_names ?Cxs = ?xs;\n   ?\\<Gamma> = [?xs [\\<mapsto>] ?Cs, this \\<mapsto> ?C];\n   ?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?E0.0;\n   ?CT \\<turnstile> ?E0.0 <: ?C0.0;\n   \\<not> method_typing_aux ?CT ?m ?D ?Cs ?C0.0\\<rbrakk>\n  \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\nusing this:\n  (\\<And>CT C CDef D mDef m C0 Cxs e0 Cs xs \\<Gamma> E0.\n      \\<lbrakk>x = CT; xa = mDef; xb = C; CT C = Some CDef; cName CDef = C;\n       cSuper CDef = D; mName mDef = m;\n       lookup (cMethods CDef) (\\<lambda>md. mName md = m) = Some mDef;\n       mReturn mDef = C0; mParams mDef = Cxs; mBody mDef = e0;\n       varDefs_types Cxs = Cs; varDefs_names Cxs = xs;\n       \\<Gamma> = [xs [\\<mapsto>] Cs, this \\<mapsto> C];\n       CT;\\<Gamma> \\<turnstile> e0 : E0; CT \\<turnstile> E0 <: C0;\n       \\<forall>Ds D0.\n          mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<longrightarrow>\n          Cs = Ds \\<and> C0 = D0\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n  \\<lbrakk>x = ?CT; xa = ?mDef; xb = ?C; ?CT ?C = Some ?CDef;\n   cName ?CDef = ?C; cSuper ?CDef = ?D; mName ?mDef = ?m;\n   lookup (cMethods ?CDef) (\\<lambda>md. mName md = ?m) = Some ?mDef;\n   mReturn ?mDef = ?C0.0; mParams ?mDef = ?Cxs; mBody ?mDef = ?e0.0;\n   varDefs_types ?Cxs = ?Cs; varDefs_names ?Cxs = ?xs;\n   ?\\<Gamma> = [?xs [\\<mapsto>] ?Cs, this \\<mapsto> ?C];\n   ?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?E0.0;\n   ?CT \\<turnstile> ?E0.0 <: ?C0.0;\n   \\<not> method_typing_aux ?CT ?m ?D ?Cs ?C0.0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "unfolding append_def method_typing_aux_def"], ["proof (prove)\nusing this:\n  (\\<And>CT C CDef D mDef m C0 Cxs e0 Cs xs \\<Gamma> E0.\n      \\<lbrakk>x = CT; xa = mDef; xb = C; CT C = Some CDef; cName CDef = C;\n       cSuper CDef = D; mName mDef = m;\n       lookup (cMethods CDef) (\\<lambda>md. mName md = m) = Some mDef;\n       mReturn mDef = C0; mParams mDef = Cxs; mBody mDef = e0;\n       varDefs_types Cxs = Cs; varDefs_names Cxs = xs;\n       \\<Gamma> = [xs [\\<mapsto>] Cs, this \\<mapsto> C];\n       CT;\\<Gamma> \\<turnstile> e0 : E0; CT \\<turnstile> E0 <: C0;\n       \\<forall>Ds D0.\n          mtype(CT,m,D) = Ds \\<rightarrow> D0 \\<longrightarrow>\n          Cs = Ds \\<and> C0 = D0\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n  \\<lbrakk>x = ?CT; xa = ?mDef; xb = ?C; ?CT ?C = Some ?CDef;\n   cName ?CDef = ?C; cSuper ?CDef = ?D; mName ?mDef = ?m;\n   lookup (cMethods ?CDef) (\\<lambda>md. mName md = ?m) = Some ?mDef;\n   mReturn ?mDef = ?C0.0; mParams ?mDef = ?Cxs; mBody ?mDef = ?e0.0;\n   varDefs_types ?Cxs = ?Cs; varDefs_names ?Cxs = ?xs;\n   ?\\<Gamma> = [?xs [\\<mapsto>] ?Cs, this \\<mapsto> ?C];\n   ?CT;?\\<Gamma> \\<turnstile> ?e0.0 : ?E0.0;\n   ?CT \\<turnstile> ?E0.0 <: ?C0.0;\n   \\<not> \\<not> (\\<forall>Ds D0.\n                     mtype(?CT,?m,?D) = Ds \\<rightarrow> D0 \\<longrightarrow>\n                     ?Cs = Ds \\<and> ?C0.0 = D0)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>method_typing_aux x xa xb xc xd;\n     \\<And>CT m D Cs C Ds D0.\n        \\<lbrakk>x = CT; xa = m; xb = D; xc = Cs; xd = C;\n         mtype(CT,m,D) = Ds \\<rightarrow> D0; Cs \\<noteq> Ds\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ ma_ Da_ Csa_ Ca_ Dsa_ D0a_.\n        \\<lbrakk>x = CTa_; xa = ma_; xb = Da_; xc = Csa_; xd = Ca_;\n         mtype(CTa_,ma_,Da_) = Dsa_ \\<rightarrow> D0a_;\n         Ca_ \\<noteq> D0a_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>method_typing_aux x xa xb xc xd;\n     \\<And>CT m D Cs C Ds D0.\n        \\<lbrakk>x = CT; xa = m; xb = D; xc = Cs; xd = C;\n         mtype(CT,m,D) = Ds \\<rightarrow> D0; Cs \\<noteq> Ds\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ ma_ Da_ Csa_ Ca_ Dsa_ D0a_.\n        \\<lbrakk>x = CTa_; xa = ma_; xb = Da_; xc = Csa_; xd = Ca_;\n         mtype(CTa_,ma_,Da_) = Dsa_ \\<rightarrow> D0a_;\n         Ca_ \\<noteq> D0a_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "case method_typing_aux"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?CT; xa = ?m; xb = ?D; xc = ?Cs; xd = ?C;\n   mtype(?CT,?m,?D) = ?Ds \\<rightarrow> ?D0.0; ?Cs \\<noteq> ?Ds\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?CTa; xa = ?ma; xb = ?Da; xc = ?Csa; xd = ?Ca;\n   mtype(?CTa,?ma,?Da) = ?Dsa \\<rightarrow> ?D0a; ?Ca \\<noteq> ?D0a\\<rbrakk>\n  \\<Longrightarrow> thesis\n  method_typing_aux x xa xb xc xd\n\ngoal (1 subgoal):\n 1. \\<lbrakk>method_typing_aux x xa xb xc xd;\n     \\<And>CT m D Cs C Ds D0.\n        \\<lbrakk>x = CT; xa = m; xb = D; xc = Cs; xd = C;\n         mtype(CT,m,D) = Ds \\<rightarrow> D0; Cs \\<noteq> Ds\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>CTa_ ma_ Da_ Csa_ Ca_ Dsa_ D0a_.\n        \\<lbrakk>x = CTa_; xa = ma_; xb = Da_; xc = Csa_; xd = Ca_;\n         mtype(CTa_,ma_,Da_) = Dsa_ \\<rightarrow> D0a_;\n         Ca_ \\<noteq> D0a_\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = ?CT; xa = ?m; xb = ?D; xc = ?Cs; xd = ?C;\n   mtype(?CT,?m,?D) = ?Ds \\<rightarrow> ?D0.0; ?Cs \\<noteq> ?Ds\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?CTa; xa = ?ma; xb = ?Da; xc = ?Csa; xd = ?Ca;\n   mtype(?CTa,?ma,?Da) = ?Dsa \\<rightarrow> ?D0a; ?Ca \\<noteq> ?D0a\\<rbrakk>\n  \\<Longrightarrow> thesis\n  method_typing_aux x xa xb xc xd", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?CT; xa = ?m; xb = ?D; xc = ?Cs; xd = ?C;\n   mtype(?CT,?m,?D) = ?Ds \\<rightarrow> ?D0.0; ?Cs \\<noteq> ?Ds\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?CTa; xa = ?ma; xb = ?Da; xc = ?Csa; xd = ?Ca;\n   mtype(?CTa,?ma,?Da) = ?Dsa \\<rightarrow> ?D0a; ?Ca \\<noteq> ?D0a\\<rbrakk>\n  \\<Longrightarrow> thesis\n  method_typing_aux x xa xb xc xd\n\ngoal (1 subgoal):\n 1. thesis", "unfolding method_typing_aux_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?CT; xa = ?m; xb = ?D; xc = ?Cs; xd = ?C;\n   mtype(?CT,?m,?D) = ?Ds \\<rightarrow> ?D0.0; ?Cs \\<noteq> ?Ds\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>x = ?CTa; xa = ?ma; xb = ?Da; xc = ?Csa; xd = ?Ca;\n   mtype(?CTa,?ma,?Da) = ?Dsa \\<rightarrow> ?D0a; ?Ca \\<noteq> ?D0a\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> (\\<forall>Ds D0.\n             mtype(x,xa,xb) = Ds \\<rightarrow> D0 \\<longrightarrow>\n             xc = Ds \\<and> xd = D0)\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>A simple example\\<close>"], ["", "text \\<open>We now execute a simple FJ example program:\\<close>"], ["", "abbreviation A :: className\nwhere \"A == Suc 0\""], ["", "abbreviation B :: className\nwhere \"B == 2\""], ["", "abbreviation cPair :: className\nwhere \"cPair == 3\""], ["", "definition classA_Def :: classDef\nwhere\n  \"classA_Def = \\<lparr> cName = A, cSuper = Object, cFields = [], cConstructor = \\<lparr>kName = A, kParams = [], kSuper = [], kInits = []\\<rparr>, cMethods = []\\<rparr>\""], ["", "definition\n  \"classB_Def = \\<lparr> cName = B, cSuper = Object, cFields = [], cConstructor = \\<lparr>kName = B, kParams = [], kSuper = [], kInits = []\\<rparr>, cMethods = []\\<rparr>\""], ["", "abbreviation ffst :: varName\nwhere\n  \"ffst == 4\""], ["", "abbreviation fsnd :: varName\nwhere\n  \"fsnd == 5\""], ["", "abbreviation setfst :: methodName\nwhere\n  \"setfst == 6\""], ["", "abbreviation newfst :: varName\nwhere\n  \"newfst == 7\""], ["", "definition classPair_Def :: classDef\nwhere\n  \"classPair_Def = \\<lparr> cName = cPair, cSuper = Object,\n    cFields = [\\<lparr> vdName = ffst, vdType = Object \\<rparr>, \\<lparr> vdName = fsnd, vdType = Object \\<rparr>],\n    cConstructor = \\<lparr> kName = cPair, kParams = [\\<lparr> vdName = ffst, vdType = Object \\<rparr>, \\<lparr> vdName = fsnd, vdType = Object \\<rparr>], kSuper = [], kInits = [ffst, fsnd]\\<rparr> ,\n    cMethods = [\\<lparr> mReturn = cPair, mName = setfst, mParams = [\\<lparr>vdName = newfst, vdType = Object \\<rparr>],\n      mBody = New cPair [Var newfst, FieldProj (Var this) fsnd]  \\<rparr>]\\<rparr>\""], ["", "definition exampleProg :: classTable\n  where \"exampleProg = (((%x. None)(A := Some classA_Def))(B := Some classB_Def))(cPair := Some classPair_Def)\""], ["", "value \"exampleProg \\<turnstile> classA_Def OK\""], ["", "value \"exampleProg \\<turnstile> classB_Def OK\""], ["", "value \"exampleProg \\<turnstile> classPair_Def OK\""], ["", "values \"{x. exampleProg \\<turnstile> MethodInvk (New cPair [New A [], New B []]) setfst [New B []] \\<rightarrow>* x}\""], ["", "values \"{x. exampleProg \\<turnstile> FieldProj (FieldProj (New cPair [New cPair [New A [], New B []], New A []]) ffst) fsnd \\<rightarrow>* x}\""], ["", "end"]]}