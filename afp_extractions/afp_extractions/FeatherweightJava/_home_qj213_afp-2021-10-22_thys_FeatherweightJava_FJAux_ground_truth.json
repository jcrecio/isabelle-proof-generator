{"file_name": "/home/qj213/afp-2021-10-22/thys/FeatherweightJava/FJAux.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FeatherweightJava", "problem_names": ["lemma mem_ith: \n  assumes \"ei \\<in> set es\" \n  shows \"\\<exists> el er. es = el@ei#er\"", "lemma ith_mem: \"\\<And>i. \\<lbrakk> i < length es \\<rbrakk> \\<Longrightarrow> es!i \\<in> set es\"", "lemma map_shuffle: \n  assumes \"length xs = length ys\"\n  shows \"[xs[\\<mapsto>]ys,x\\<mapsto>y] = [(xs@[x])[\\<mapsto>](ys@[y])]\"", "lemma map_upds_index: \n  assumes \"length xs = length As\"\n  and \"[xs[\\<mapsto>]As]x = Some Ai\"\n  shows \"\\<exists>i.(As!i = Ai) \n         \\<and> (i < length As) \n         \\<and> (\\<forall>(Bs::'c list).((length Bs = length As) \n                            \\<longrightarrow> ([xs[\\<mapsto>]Bs] x = Some (Bs !i))))\" \n  (is \"\\<exists>i. ?P i xs As\" \n   is \"\\<exists>i.(?P1 i As) \\<and> (?P2 i As) \\<and> (\\<forall>Bs::('c list).(?P3 i xs As Bs))\")", "lemma subst_list1_eq_map_substs : \n  \"\\<forall>\\<sigma>. subst_list1 \\<sigma> l = map (substs \\<sigma>) l\"", "lemma subst_list2_eq_map_substs : \n  \"\\<forall>\\<sigma>. subst_list2 \\<sigma> l = map (substs \\<sigma>) l\"", "lemma lookup_functional:\n  assumes \"lookup l f = o1\"\n  and \"lookup l f = o2\"\n  shows \"o1 = o2\"", "lemma lookup_true:\n  \"lookup l f = Some r \\<Longrightarrow> f r\"", "lemma lookup_hd:\n  \"\\<lbrakk> length l > 0; f (l!0) \\<rbrakk> \\<Longrightarrow> lookup l f = Some (l!0)\"", "lemma lookup_split: \"lookup l f = None \\<or> (\\<exists>h. lookup l f = Some h)\"", "lemma lookup_index:\n  assumes \"lookup l1 f = Some e\" \n  shows \" \\<And>l2. \\<exists>i < (length l1). e = l1!i \\<and> ((length l1 = length l2) \\<longrightarrow> lookup2 l1 l2 f = Some (l2!i))\"", "lemma lookup2_index:\n  \"\\<And>l2. \\<lbrakk> lookup2 l1 l2 f = Some e; \n  length l1 = length l2 \\<rbrakk> \\<Longrightarrow> \\<exists>i < (length l2). e = (l2!i) \\<and> lookup l1 f = Some (l1!i)\"", "lemma lookup_append:\n  assumes \"lookup l f = Some r\"\n  shows \"lookup (l@l') f = Some r\"", "lemma method_typings_lookup:\n  assumes lookup_eq_Some: \"lookup M f = Some mDef\"\n  and M_ok: \"CT \\<turnstile>+ M OK IN C\"\n  shows \"CT \\<turnstile> mDef OK IN C\"", "lemma mtype_functional:\n  assumes \"mtype(CT,m,C) = Cs \\<rightarrow> C0\"\n  and     \"mtype(CT,m,C) = Ds \\<rightarrow> D0\"\n  shows \"Ds=Cs \\<and> D0=C0\"", "lemma mbody_functional:\n  assumes mb1: \"mbody(CT,m,C) = xs . e0\"\n  and     mb2: \"mbody(CT,m,C) = ys . d0\"\n  shows \"xs = ys \\<and> e0 = d0\"", "lemma fields_functional:\n  assumes \"fields(CT,C) = Cf\" \n  and \"CT OK\" \n  shows \"\\<And>Cf'. \\<lbrakk> fields(CT,C) = Cf'\\<rbrakk> \\<Longrightarrow> Cf = Cf'\"", "lemma typings_lengths: assumes \"CT;\\<Gamma> \\<turnstile>+ es:Cs\" shows \"length es = length Cs\"", "lemma typings_index:\n  assumes \"CT;\\<Gamma> \\<turnstile>+ es:Cs\" \n  shows \"\\<And>i. \\<lbrakk> i < length es \\<rbrakk> \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> (es!i) : (Cs!i)\"", "lemma subtypings_index:\n  assumes \"CT \\<turnstile>+ Cs <: Ds\"\n  shows \"\\<And>i. \\<lbrakk> i < length Cs \\<rbrakk> \\<Longrightarrow> CT \\<turnstile> (Cs!i) <: (Ds!i)\"", "lemma subtyping_append:\n  assumes \"CT \\<turnstile>+ Cs <: Ds\"\n  and \"CT \\<turnstile> C <: D\"\n  shows \"CT \\<turnstile>+ (Cs@[C]) <: (Ds@[D])\"", "lemma typings_append: \n  assumes \"CT;\\<Gamma> \\<turnstile>+ es : Cs\"\n  and \"CT;\\<Gamma> \\<turnstile> e : C\"\n  shows \"CT;\\<Gamma> \\<turnstile>+ (es@[e]) : (Cs@[C])\"", "lemma ith_typing: \"\\<And>Cs. \\<lbrakk> CT;\\<Gamma> \\<turnstile>+ (es@(h#t)) : Cs \\<rbrakk> \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> h : (Cs!(length es))\"", "lemma ith_subtyping: \"\\<And>Ds. \\<lbrakk> CT \\<turnstile>+ (Cs@(h#t)) <: Ds \\<rbrakk> \\<Longrightarrow> CT \\<turnstile> h <: (Ds!(length Cs))\"", "lemma subtypings_refl: \"CT \\<turnstile>+ Cs <: Cs\"", "lemma subtypings_trans: \"\\<And>Ds Es. \\<lbrakk> CT \\<turnstile>+ Cs <: Ds;  CT \\<turnstile>+ Ds <: Es \\<rbrakk> \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es\"", "lemma ith_typing_sub: \n  \"\\<And>Cs. \\<lbrakk> CT;\\<Gamma> \\<turnstile>+ (es@(h#t)) : Cs; \n     CT;\\<Gamma> \\<turnstile> h' : Ci'; \n     CT \\<turnstile> Ci' <: (Cs!(length es)) \\<rbrakk>\n  \\<Longrightarrow> \\<exists>Cs'. (CT;\\<Gamma> \\<turnstile>+ (es@(h'#t)) : Cs' \\<and> CT \\<turnstile>+ Cs' <: Cs)\"", "lemma mem_typings: \n  \"\\<And>Cs. \\<lbrakk> CT;\\<Gamma> \\<turnstile>+ es:Cs; ei \\<in> set es\\<rbrakk> \\<Longrightarrow> \\<exists>Ci. CT;\\<Gamma> \\<turnstile> ei:Ci\"", "lemma typings_proj: \n  assumes \"CT;\\<Gamma> \\<turnstile>+ ds : As\"\n      and \"CT \\<turnstile>+ As <: Bs\" \n      and \"length ds = length As\" \n      and \"length ds = length Bs\" \n      and \"i < length ds\" \n    shows \"CT;\\<Gamma> \\<turnstile> ds!i : As!i\" and \"CT \\<turnstile> As!i <: Bs!i\"", "lemma subtypings_length: \n  \"CT \\<turnstile>+ As <: Bs \\<Longrightarrow> length As = length Bs\"", "lemma not_subtypes_aux: \n  assumes \"CT \\<turnstile> C <: Da\" \n  and \"C \\<noteq> Da\" \n  and \"CT C = Some CDef\" \n  and \"cSuper CDef = D\"\n  shows \"CT \\<turnstile> D <: Da\"", "lemma not_subtypes:\n  assumes \"CT \\<turnstile> A <: C\"\n  shows \"\\<And>D. \\<lbrakk> CT \\<turnstile> D \\<not><: C;  CT \\<turnstile> C \\<not><: D\\<rbrakk> \\<Longrightarrow> CT \\<turnstile> A \\<not><: D\"", "lemma isubexpr_typing: \n  assumes \"e1 \\<in> isubexprs(e0)\"\n  shows \"\\<And>C. \\<lbrakk> CT;Map.empty \\<turnstile> e0 : C \\<rbrakk> \\<Longrightarrow> \\<exists>D. CT;Map.empty \\<turnstile> e1 : D\"", "lemma subexpr_typing: \n  assumes \"e1 \\<in> subexprs(e0)\"\n  shows \"\\<And>C. \\<lbrakk> CT;Map.empty \\<turnstile> e0 : C \\<rbrakk> \\<Longrightarrow> \\<exists>D. CT;Map.empty \\<turnstile> e1 : D\"", "lemma isubexpr_reduct: \n  assumes \"d1 \\<in> isubexprs(e1)\"\n  shows \"\\<And>d2. \\<lbrakk> CT \\<turnstile> d1 \\<rightarrow> d2 \\<rbrakk> \\<Longrightarrow> \\<exists>e2. CT \\<turnstile> e1 \\<rightarrow> e2\"", "lemma subexpr_reduct: \n  assumes \"d1 \\<in> subexprs(e1)\"\n  shows \"\\<And>d2. \\<lbrakk> CT \\<turnstile> d1 \\<rightarrow> d2 \\<rbrakk> \\<Longrightarrow> \\<exists>e2. CT \\<turnstile> e1 \\<rightarrow> e2\""], "translations": [["", "lemma mem_ith: \n  assumes \"ei \\<in> set es\" \n  shows \"\\<exists> el er. es = el@ei#er\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>el er. es = el @ ei # er", "using assms"], ["proof (prove)\nusing this:\n  ei \\<in> set es\n\ngoal (1 subgoal):\n 1. \\<exists>el er. es = el @ ei # er", "proof(induct es)"], ["proof (state)\ngoal (2 subgoals):\n 1. ei \\<in> set [] \\<Longrightarrow> \\<exists>el er. [] = el @ ei # er\n 2. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "case Nil"], ["proof (state)\nthis:\n  ei \\<in> set []\n\ngoal (2 subgoals):\n 1. ei \\<in> set [] \\<Longrightarrow> \\<exists>el er. [] = el @ ei # er\n 2. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "thus ?case"], ["proof (prove)\nusing this:\n  ei \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<exists>el er. [] = el @ ei # er", "by auto"], ["proof (state)\nthis:\n  \\<exists>el er. [] = el @ ei # er\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "case (Cons esh est)"], ["proof (state)\nthis:\n  ei \\<in> set est \\<Longrightarrow> \\<exists>el er. est = el @ ei # er\n  ei \\<in> set (esh # est)\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "{"], ["proof (state)\nthis:\n  ei \\<in> set est \\<Longrightarrow> \\<exists>el er. est = el @ ei # er\n  ei \\<in> set (esh # est)\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "assume \"esh = ei\""], ["proof (state)\nthis:\n  esh = ei\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "with Cons"], ["proof (chain)\npicking this:\n  ei \\<in> set est \\<Longrightarrow> \\<exists>el er. est = el @ ei # er\n  ei \\<in> set (esh # est)\n  esh = ei", "have ?case"], ["proof (prove)\nusing this:\n  ei \\<in> set est \\<Longrightarrow> \\<exists>el er. est = el @ ei # er\n  ei \\<in> set (esh # est)\n  esh = ei\n\ngoal (1 subgoal):\n 1. \\<exists>el er. esh # est = el @ ei # er", "by blast"], ["proof (state)\nthis:\n  \\<exists>el er. esh # est = el @ ei # er\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "}"], ["proof (state)\nthis:\n  esh = ei \\<Longrightarrow> \\<exists>el er. esh # est = el @ ei # er\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "moreover"], ["proof (state)\nthis:\n  esh = ei \\<Longrightarrow> \\<exists>el er. esh # est = el @ ei # er\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "{"], ["proof (state)\nthis:\n  esh = ei \\<Longrightarrow> \\<exists>el er. esh # est = el @ ei # er\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "assume \"esh \\<noteq> ei\""], ["proof (state)\nthis:\n  esh \\<noteq> ei\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "with Cons"], ["proof (chain)\npicking this:\n  ei \\<in> set est \\<Longrightarrow> \\<exists>el er. est = el @ ei # er\n  ei \\<in> set (esh # est)\n  esh \\<noteq> ei", "have \"ei \\<in> set est\""], ["proof (prove)\nusing this:\n  ei \\<in> set est \\<Longrightarrow> \\<exists>el er. est = el @ ei # er\n  ei \\<in> set (esh # est)\n  esh \\<noteq> ei\n\ngoal (1 subgoal):\n 1. ei \\<in> set est", "by auto"], ["proof (state)\nthis:\n  ei \\<in> set est\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "with Cons"], ["proof (chain)\npicking this:\n  ei \\<in> set est \\<Longrightarrow> \\<exists>el er. est = el @ ei # er\n  ei \\<in> set (esh # est)\n  ei \\<in> set est", "obtain el er where \"esh # est = (esh#el) @ (ei#er)\""], ["proof (prove)\nusing this:\n  ei \\<in> set est \\<Longrightarrow> \\<exists>el er. est = el @ ei # er\n  ei \\<in> set (esh # est)\n  ei \\<in> set est\n\ngoal (1 subgoal):\n 1. (\\<And>el er.\n        esh # est = (esh # el) @ ei # er \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  esh # est = (esh # el) @ ei # er\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "hence ?case"], ["proof (prove)\nusing this:\n  esh # est = (esh # el) @ ei # er\n\ngoal (1 subgoal):\n 1. \\<exists>el er. esh # est = el @ ei # er", "by blast"], ["proof (state)\nthis:\n  \\<exists>el er. esh # est = el @ ei # er\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "}"], ["proof (state)\nthis:\n  esh \\<noteq> ei \\<Longrightarrow> \\<exists>el er. esh # est = el @ ei # er\n\ngoal (1 subgoal):\n 1. \\<And>a es.\n       \\<lbrakk>ei \\<in> set es \\<Longrightarrow>\n                \\<exists>el er. es = el @ ei # er;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>el er. a # es = el @ ei # er", "ultimately"], ["proof (chain)\npicking this:\n  esh = ei \\<Longrightarrow> \\<exists>el er. esh # est = el @ ei # er\n  esh \\<noteq> ei \\<Longrightarrow> \\<exists>el er. esh # est = el @ ei # er", "show ?case"], ["proof (prove)\nusing this:\n  esh = ei \\<Longrightarrow> \\<exists>el er. esh # est = el @ ei # er\n  esh \\<noteq> ei \\<Longrightarrow> \\<exists>el er. esh # est = el @ ei # er\n\ngoal (1 subgoal):\n 1. \\<exists>el er. esh # est = el @ ei # er", "by blast"], ["proof (state)\nthis:\n  \\<exists>el er. esh # est = el @ ei # er\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ith_mem: \"\\<And>i. \\<lbrakk> i < length es \\<rbrakk> \\<Longrightarrow> es!i \\<in> set es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < length es \\<Longrightarrow> es ! i \\<in> set es", "proof(induct es)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i < length [] \\<Longrightarrow> [] ! i \\<in> set []\n 2. \\<And>a es i.\n       \\<lbrakk>\\<And>i.\n                   i < length es \\<Longrightarrow> es ! i \\<in> set es;\n        i < length (a # es)\\<rbrakk>\n       \\<Longrightarrow> (a # es) ! i \\<in> set (a # es)", "case Nil"], ["proof (state)\nthis:\n  i < length []\n\ngoal (2 subgoals):\n 1. \\<And>i. i < length [] \\<Longrightarrow> [] ! i \\<in> set []\n 2. \\<And>a es i.\n       \\<lbrakk>\\<And>i.\n                   i < length es \\<Longrightarrow> es ! i \\<in> set es;\n        i < length (a # es)\\<rbrakk>\n       \\<Longrightarrow> (a # es) ! i \\<in> set (a # es)", "thus ?case"], ["proof (prove)\nusing this:\n  i < length []\n\ngoal (1 subgoal):\n 1. [] ! i \\<in> set []", "by auto"], ["proof (state)\nthis:\n  [] ! i \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<And>a es i.\n       \\<lbrakk>\\<And>i.\n                   i < length es \\<Longrightarrow> es ! i \\<in> set es;\n        i < length (a # es)\\<rbrakk>\n       \\<Longrightarrow> (a # es) ! i \\<in> set (a # es)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es i.\n       \\<lbrakk>\\<And>i.\n                   i < length es \\<Longrightarrow> es ! i \\<in> set es;\n        i < length (a # es)\\<rbrakk>\n       \\<Longrightarrow> (a # es) ! i \\<in> set (a # es)", "case (Cons h t)"], ["proof (state)\nthis:\n  ?i < length t \\<Longrightarrow> t ! ?i \\<in> set t\n  i < length (h # t)\n\ngoal (1 subgoal):\n 1. \\<And>a es i.\n       \\<lbrakk>\\<And>i.\n                   i < length es \\<Longrightarrow> es ! i \\<in> set es;\n        i < length (a # es)\\<rbrakk>\n       \\<Longrightarrow> (a # es) ! i \\<in> set (a # es)", "thus ?case"], ["proof (prove)\nusing this:\n  ?i < length t \\<Longrightarrow> t ! ?i \\<in> set t\n  i < length (h # t)\n\ngoal (1 subgoal):\n 1. (h # t) ! i \\<in> set (h # t)", "by(cases \"i\", auto)"], ["proof (state)\nthis:\n  (h # t) ! i \\<in> set (h # t)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Maps\\<close>"], ["", "lemma map_shuffle: \n  assumes \"length xs = length ys\"\n  shows \"[xs[\\<mapsto>]ys,x\\<mapsto>y] = [(xs@[x])[\\<mapsto>](ys@[y])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys, x \\<mapsto> y] = [xs @ [x] [\\<mapsto>] ys @ [y]]", "using assms"], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys, x \\<mapsto> y] = [xs @ [x] [\\<mapsto>] ys @ [y]]", "by (induct \"xs\" \"ys\" rule:list_induct2) (auto simp add:map_upds_append1)"], ["", "lemma map_upds_index: \n  assumes \"length xs = length As\"\n  and \"[xs[\\<mapsto>]As]x = Some Ai\"\n  shows \"\\<exists>i.(As!i = Ai) \n         \\<and> (i < length As) \n         \\<and> (\\<forall>(Bs::'c list).((length Bs = length As) \n                            \\<longrightarrow> ([xs[\\<mapsto>]Bs] x = Some (Bs !i))))\" \n  (is \"\\<exists>i. ?P i xs As\" \n   is \"\\<exists>i.(?P1 i As) \\<and> (?P2 i As) \\<and> (\\<forall>Bs::('c list).(?P3 i xs As Bs))\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       As ! i = Ai \\<and>\n       i < length As \\<and>\n       (\\<forall>Bs.\n           length Bs = length As \\<longrightarrow>\n           [xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "using assms"], ["proof (prove)\nusing this:\n  length xs = length As\n  [xs [\\<mapsto>] As] x = Some Ai\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       As ! i = Ai \\<and>\n       i < length As \\<and>\n       (\\<forall>Bs.\n           length Bs = length As \\<longrightarrow>\n           [xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "proof(induct \"xs\" \"As\" rule:list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. [[] [\\<mapsto>] []] x = Some Ai \\<Longrightarrow>\n    \\<exists>i.\n       [] ! i = Ai \\<and>\n       i < length [] \\<and>\n       (\\<forall>Bs.\n           length Bs = length [] \\<longrightarrow>\n           [[] [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>xa xs y ys.\n       \\<lbrakk>length xs = length ys;\n        [xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow>\n        \\<exists>i.\n           ys ! i = Ai \\<and>\n           i < length ys \\<and>\n           (\\<forall>Bs.\n               length Bs = length ys \\<longrightarrow>\n               [xs [\\<mapsto>] Bs] x = Some (Bs ! i));\n        [xa # xs [\\<mapsto>] y # ys] x = Some Ai\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (y # ys) ! i = Ai \\<and>\n                            i < length (y # ys) \\<and>\n                            (\\<forall>Bs.\n                                length Bs =\n                                length (y # ys) \\<longrightarrow>\n                                [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "assume \"[[][\\<mapsto>][]] x = Some Ai\""], ["proof (state)\nthis:\n  [[] [\\<mapsto>] []] x = Some Ai\n\ngoal (2 subgoals):\n 1. [[] [\\<mapsto>] []] x = Some Ai \\<Longrightarrow>\n    \\<exists>i.\n       [] ! i = Ai \\<and>\n       i < length [] \\<and>\n       (\\<forall>Bs.\n           length Bs = length [] \\<longrightarrow>\n           [[] [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>xa xs y ys.\n       \\<lbrakk>length xs = length ys;\n        [xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow>\n        \\<exists>i.\n           ys ! i = Ai \\<and>\n           i < length ys \\<and>\n           (\\<forall>Bs.\n               length Bs = length ys \\<longrightarrow>\n               [xs [\\<mapsto>] Bs] x = Some (Bs ! i));\n        [xa # xs [\\<mapsto>] y # ys] x = Some Ai\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (y # ys) ! i = Ai \\<and>\n                            i < length (y # ys) \\<and>\n                            (\\<forall>Bs.\n                                length Bs =\n                                length (y # ys) \\<longrightarrow>\n                                [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "moreover"], ["proof (state)\nthis:\n  [[] [\\<mapsto>] []] x = Some Ai\n\ngoal (2 subgoals):\n 1. [[] [\\<mapsto>] []] x = Some Ai \\<Longrightarrow>\n    \\<exists>i.\n       [] ! i = Ai \\<and>\n       i < length [] \\<and>\n       (\\<forall>Bs.\n           length Bs = length [] \\<longrightarrow>\n           [[] [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>xa xs y ys.\n       \\<lbrakk>length xs = length ys;\n        [xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow>\n        \\<exists>i.\n           ys ! i = Ai \\<and>\n           i < length ys \\<and>\n           (\\<forall>Bs.\n               length Bs = length ys \\<longrightarrow>\n               [xs [\\<mapsto>] Bs] x = Some (Bs ! i));\n        [xa # xs [\\<mapsto>] y # ys] x = Some Ai\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (y # ys) ! i = Ai \\<and>\n                            i < length (y # ys) \\<and>\n                            (\\<forall>Bs.\n                                length Bs =\n                                length (y # ys) \\<longrightarrow>\n                                [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "have \"\\<not>[[][\\<mapsto>][]] x = Some Ai\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [[] [\\<mapsto>] []] x \\<noteq> Some Ai", "by auto"], ["proof (state)\nthis:\n  [[] [\\<mapsto>] []] x \\<noteq> Some Ai\n\ngoal (2 subgoals):\n 1. [[] [\\<mapsto>] []] x = Some Ai \\<Longrightarrow>\n    \\<exists>i.\n       [] ! i = Ai \\<and>\n       i < length [] \\<and>\n       (\\<forall>Bs.\n           length Bs = length [] \\<longrightarrow>\n           [[] [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>xa xs y ys.\n       \\<lbrakk>length xs = length ys;\n        [xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow>\n        \\<exists>i.\n           ys ! i = Ai \\<and>\n           i < length ys \\<and>\n           (\\<forall>Bs.\n               length Bs = length ys \\<longrightarrow>\n               [xs [\\<mapsto>] Bs] x = Some (Bs ! i));\n        [xa # xs [\\<mapsto>] y # ys] x = Some Ai\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (y # ys) ! i = Ai \\<and>\n                            i < length (y # ys) \\<and>\n                            (\\<forall>Bs.\n                                length Bs =\n                                length (y # ys) \\<longrightarrow>\n                                [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "ultimately"], ["proof (chain)\npicking this:\n  [[] [\\<mapsto>] []] x = Some Ai\n  [[] [\\<mapsto>] []] x \\<noteq> Some Ai", "show \"\\<exists>i. ?P i [] []\""], ["proof (prove)\nusing this:\n  [[] [\\<mapsto>] []] x = Some Ai\n  [[] [\\<mapsto>] []] x \\<noteq> Some Ai\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       [] ! i = Ai \\<and>\n       i < length [] \\<and>\n       (\\<forall>Bs.\n           length Bs = length [] \\<longrightarrow>\n           [[] [\\<mapsto>] Bs] x = Some (Bs ! i))", "by contradiction"], ["proof (state)\nthis:\n  \\<exists>i.\n     [] ! i = Ai \\<and>\n     i < length [] \\<and>\n     (\\<forall>Bs.\n         length Bs = length [] \\<longrightarrow>\n         [[] [\\<mapsto>] Bs] x = Some (Bs ! i))\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y ys.\n       \\<lbrakk>length xs = length ys;\n        [xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow>\n        \\<exists>i.\n           ys ! i = Ai \\<and>\n           i < length ys \\<and>\n           (\\<forall>Bs.\n               length Bs = length ys \\<longrightarrow>\n               [xs [\\<mapsto>] Bs] x = Some (Bs ! i));\n        [xa # xs [\\<mapsto>] y # ys] x = Some Ai\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (y # ys) ! i = Ai \\<and>\n                            i < length (y # ys) \\<and>\n                            (\\<forall>Bs.\n                                length Bs =\n                                length (y # ys) \\<longrightarrow>\n                                [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs y ys.\n       \\<lbrakk>length xs = length ys;\n        [xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow>\n        \\<exists>i.\n           ys ! i = Ai \\<and>\n           i < length ys \\<and>\n           (\\<forall>Bs.\n               length Bs = length ys \\<longrightarrow>\n               [xs [\\<mapsto>] Bs] x = Some (Bs ! i));\n        [xa # xs [\\<mapsto>] y # ys] x = Some Ai\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (y # ys) ! i = Ai \\<and>\n                            i < length (y # ys) \\<and>\n                            (\\<forall>Bs.\n                                length Bs =\n                                length (y # ys) \\<longrightarrow>\n                                [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "fix xa xs y ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs y ys.\n       \\<lbrakk>length xs = length ys;\n        [xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow>\n        \\<exists>i.\n           ys ! i = Ai \\<and>\n           i < length ys \\<and>\n           (\\<forall>Bs.\n               length Bs = length ys \\<longrightarrow>\n               [xs [\\<mapsto>] Bs] x = Some (Bs ! i));\n        [xa # xs [\\<mapsto>] y # ys] x = Some Ai\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (y # ys) ! i = Ai \\<and>\n                            i < length (y # ys) \\<and>\n                            (\\<forall>Bs.\n                                length Bs =\n                                length (y # ys) \\<longrightarrow>\n                                [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "assume length_xs_ys: \"length xs = length ys\"\n    and IH: \"[xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow> \\<exists>i. ?P i xs ys\"\n    and map_eq_Some: \"[xa # xs [\\<mapsto>] y # ys] x = Some Ai\""], ["proof (state)\nthis:\n  length xs = length ys\n  [xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow>\n  \\<exists>i.\n     ys ! i = Ai \\<and>\n     i < length ys \\<and>\n     (\\<forall>Bs.\n         length Bs = length ys \\<longrightarrow>\n         [xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n  [xa # xs [\\<mapsto>] y # ys] x = Some Ai\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y ys.\n       \\<lbrakk>length xs = length ys;\n        [xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow>\n        \\<exists>i.\n           ys ! i = Ai \\<and>\n           i < length ys \\<and>\n           (\\<forall>Bs.\n               length Bs = length ys \\<longrightarrow>\n               [xs [\\<mapsto>] Bs] x = Some (Bs ! i));\n        [xa # xs [\\<mapsto>] y # ys] x = Some Ai\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (y # ys) ! i = Ai \\<and>\n                            i < length (y # ys) \\<and>\n                            (\\<forall>Bs.\n                                length Bs =\n                                length (y # ys) \\<longrightarrow>\n                                [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "then"], ["proof (chain)\npicking this:\n  length xs = length ys\n  [xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow>\n  \\<exists>i.\n     ys ! i = Ai \\<and>\n     i < length ys \\<and>\n     (\\<forall>Bs.\n         length Bs = length ys \\<longrightarrow>\n         [xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n  [xa # xs [\\<mapsto>] y # ys] x = Some Ai", "have map_decomp: \"[xa#xs [\\<mapsto>] y#ys] = [xa\\<mapsto>y] ++ [xs[\\<mapsto>]ys]\""], ["proof (prove)\nusing this:\n  length xs = length ys\n  [xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow>\n  \\<exists>i.\n     ys ! i = Ai \\<and>\n     i < length ys \\<and>\n     (\\<forall>Bs.\n         length Bs = length ys \\<longrightarrow>\n         [xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n  [xa # xs [\\<mapsto>] y # ys] x = Some Ai\n\ngoal (1 subgoal):\n 1. [xa # xs [\\<mapsto>] y # ys] = [xa \\<mapsto> y] ++ [xs [\\<mapsto>] ys]", "by fastforce"], ["proof (state)\nthis:\n  [xa # xs [\\<mapsto>] y # ys] = [xa \\<mapsto> y] ++ [xs [\\<mapsto>] ys]\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y ys.\n       \\<lbrakk>length xs = length ys;\n        [xs [\\<mapsto>] ys] x = Some Ai \\<Longrightarrow>\n        \\<exists>i.\n           ys ! i = Ai \\<and>\n           i < length ys \\<and>\n           (\\<forall>Bs.\n               length Bs = length ys \\<longrightarrow>\n               [xs [\\<mapsto>] Bs] x = Some (Bs ! i));\n        [xa # xs [\\<mapsto>] y # ys] x = Some Ai\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (y # ys) ! i = Ai \\<and>\n                            i < length (y # ys) \\<and>\n                            (\\<forall>Bs.\n                                length Bs =\n                                length (y # ys) \\<longrightarrow>\n                                [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "show \"\\<exists>i. ?P i (xa#xs) (y # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "proof(cases \"[xs[\\<mapsto>]ys]x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "case(Some Ai')"], ["proof (state)\nthis:\n  [xs [\\<mapsto>] ys] x = Some Ai'\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "hence \"([xa \\<mapsto>y] ++ [xs[\\<mapsto>]ys]) x = Some Ai'\""], ["proof (prove)\nusing this:\n  [xs [\\<mapsto>] ys] x = Some Ai'\n\ngoal (1 subgoal):\n 1. ([xa \\<mapsto> y] ++ [xs [\\<mapsto>] ys]) x = Some Ai'", "by(rule map_add_find_right)"], ["proof (state)\nthis:\n  ([xa \\<mapsto> y] ++ [xs [\\<mapsto>] ys]) x = Some Ai'\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "hence P: \"[xs[\\<mapsto>]ys] x = Some Ai\""], ["proof (prove)\nusing this:\n  ([xa \\<mapsto> y] ++ [xs [\\<mapsto>] ys]) x = Some Ai'\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = Some Ai", "using map_eq_Some Some"], ["proof (prove)\nusing this:\n  ([xa \\<mapsto> y] ++ [xs [\\<mapsto>] ys]) x = Some Ai'\n  [xa # xs [\\<mapsto>] y # ys] x = Some Ai\n  [xs [\\<mapsto>] ys] x = Some Ai'\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = Some Ai", "by simp"], ["proof (state)\nthis:\n  [xs [\\<mapsto>] ys] x = Some Ai\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "from IH[OF P]"], ["proof (chain)\npicking this:\n  \\<exists>i.\n     ys ! i = Ai \\<and>\n     i < length ys \\<and>\n     (\\<forall>Bs.\n         length Bs = length ys \\<longrightarrow>\n         [xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "obtain i where \n      R1: \"ys ! i = Ai\" \n      and R2: \"i < length ys\" \n      and pre_r3: \"\\<forall>(Bs::'c list). ?P3 i xs ys Bs\""], ["proof (prove)\nusing this:\n  \\<exists>i.\n     ys ! i = Ai \\<and>\n     i < length ys \\<and>\n     (\\<forall>Bs.\n         length Bs = length ys \\<longrightarrow>\n         [xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>ys ! i = Ai; i < length ys;\n         \\<forall>Bs.\n            length Bs = length ys \\<longrightarrow>\n            [xs [\\<mapsto>] Bs] x = Some (Bs ! i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ys ! i = Ai\n  i < length ys\n  \\<forall>Bs.\n     length Bs = length ys \\<longrightarrow>\n     [xs [\\<mapsto>] Bs] x = Some (Bs ! i)\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "{"], ["proof (state)\nthis:\n  ys ! i = Ai\n  i < length ys\n  \\<forall>Bs.\n     length Bs = length ys \\<longrightarrow>\n     [xs [\\<mapsto>] Bs] x = Some (Bs ! i)\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "fix Bs::\"'c list\""], ["proof (state)\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "assume length_Bs: \"length Bs = length (y#ys)\""], ["proof (state)\nthis:\n  length Bs = length (y # ys)\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "then"], ["proof (chain)\npicking this:\n  length Bs = length (y # ys)", "obtain n where \"length (y#ys) = Suc n\""], ["proof (prove)\nusing this:\n  length Bs = length (y # ys)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        length (y # ys) = Suc n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length (y # ys) = Suc n\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "with length_Bs"], ["proof (chain)\npicking this:\n  length Bs = length (y # ys)\n  length (y # ys) = Suc n", "obtain b bs where Bs_def: \"Bs = b#bs\""], ["proof (prove)\nusing this:\n  length Bs = length (y # ys)\n  length (y # ys) = Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>b bs. Bs = b # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:length_Suc_conv)"], ["proof (state)\nthis:\n  Bs = b # bs\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "with length_Bs"], ["proof (chain)\npicking this:\n  length Bs = length (y # ys)\n  Bs = b # bs", "have \"length ys = length bs\""], ["proof (prove)\nusing this:\n  length Bs = length (y # ys)\n  Bs = b # bs\n\ngoal (1 subgoal):\n 1. length ys = length bs", "by simp"], ["proof (state)\nthis:\n  length ys = length bs\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "with pre_r3"], ["proof (chain)\npicking this:\n  \\<forall>Bs.\n     length Bs = length ys \\<longrightarrow>\n     [xs [\\<mapsto>] Bs] x = Some (Bs ! i)\n  length ys = length bs", "have \"([xa\\<mapsto>b] ++ [xs[\\<mapsto>]bs]) x = Some (bs!i)\""], ["proof (prove)\nusing this:\n  \\<forall>Bs.\n     length Bs = length ys \\<longrightarrow>\n     [xs [\\<mapsto>] Bs] x = Some (Bs ! i)\n  length ys = length bs\n\ngoal (1 subgoal):\n 1. ([xa \\<mapsto> b] ++ [xs [\\<mapsto>] bs]) x = Some (bs ! i)", "by(auto simp only:map_add_find_right)"], ["proof (state)\nthis:\n  ([xa \\<mapsto> b] ++ [xs [\\<mapsto>] bs]) x = Some (bs ! i)\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "with pre_r3 Bs_def length_Bs"], ["proof (chain)\npicking this:\n  \\<forall>Bs.\n     length Bs = length ys \\<longrightarrow>\n     [xs [\\<mapsto>] Bs] x = Some (Bs ! i)\n  Bs = b # bs\n  length Bs = length (y # ys)\n  ([xa \\<mapsto> b] ++ [xs [\\<mapsto>] bs]) x = Some (bs ! i)", "have \"?P3 (i+1) (xa#xs) (y#ys) Bs\""], ["proof (prove)\nusing this:\n  \\<forall>Bs.\n     length Bs = length ys \\<longrightarrow>\n     [xs [\\<mapsto>] Bs] x = Some (Bs ! i)\n  Bs = b # bs\n  length Bs = length (y # ys)\n  ([xa \\<mapsto> b] ++ [xs [\\<mapsto>] bs]) x = Some (bs ! i)\n\ngoal (1 subgoal):\n 1. length Bs = length (y # ys) \\<longrightarrow>\n    [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! (i + 1))", "by simp"], ["proof (state)\nthis:\n  length Bs = length (y # ys) \\<longrightarrow>\n  [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! (i + 1))\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "}"], ["proof (state)\nthis:\n  length ?Bs2 = length (y # ys) \\<Longrightarrow>\n  length ?Bs2 = length (y # ys) \\<longrightarrow>\n  [xa # xs [\\<mapsto>] ?Bs2] x = Some (?Bs2 ! (i + 1))\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "with R1 R2"], ["proof (chain)\npicking this:\n  ys ! i = Ai\n  i < length ys\n  length ?Bs2 = length (y # ys) \\<Longrightarrow>\n  length ?Bs2 = length (y # ys) \\<longrightarrow>\n  [xa # xs [\\<mapsto>] ?Bs2] x = Some (?Bs2 ! (i + 1))", "have \"?P (i+1) (xa#xs) (y#ys)\""], ["proof (prove)\nusing this:\n  ys ! i = Ai\n  i < length ys\n  length ?Bs2 = length (y # ys) \\<Longrightarrow>\n  length ?Bs2 = length (y # ys) \\<longrightarrow>\n  [xa # xs [\\<mapsto>] ?Bs2] x = Some (?Bs2 ! (i + 1))\n\ngoal (1 subgoal):\n 1. (y # ys) ! (i + 1) = Ai \\<and>\n    i + 1 < length (y # ys) \\<and>\n    (\\<forall>Bs.\n        length Bs = length (y # ys) \\<longrightarrow>\n        [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! (i + 1)))", "by auto"], ["proof (state)\nthis:\n  (y # ys) ! (i + 1) = Ai \\<and>\n  i + 1 < length (y # ys) \\<and>\n  (\\<forall>Bs.\n      length Bs = length (y # ys) \\<longrightarrow>\n      [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! (i + 1)))\n\ngoal (2 subgoals):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n 2. \\<And>a.\n       [xs [\\<mapsto>] ys] x = Some a \\<Longrightarrow>\n       \\<exists>i.\n          (y # ys) ! i = Ai \\<and>\n          i < length (y # ys) \\<and>\n          (\\<forall>Bs.\n              length Bs = length (y # ys) \\<longrightarrow>\n              [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (y # ys) ! (i + 1) = Ai \\<and>\n  i + 1 < length (y # ys) \\<and>\n  (\\<forall>Bs.\n      length Bs = length (y # ys) \\<longrightarrow>\n      [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! (i + 1)))\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", ".."], ["proof (state)\nthis:\n  \\<exists>i.\n     (y # ys) ! i = Ai \\<and>\n     i < length (y # ys) \\<and>\n     (\\<forall>Bs.\n         length Bs = length (y # ys) \\<longrightarrow>\n         [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "case None"], ["proof (state)\nthis:\n  [xs [\\<mapsto>] ys] x = None\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "with map_decomp map_eq_Some"], ["proof (chain)\npicking this:\n  [xa # xs [\\<mapsto>] y # ys] = [xa \\<mapsto> y] ++ [xs [\\<mapsto>] ys]\n  [xa # xs [\\<mapsto>] y # ys] x = Some Ai\n  [xs [\\<mapsto>] ys] x = None", "have \"[xa\\<mapsto>y] x = Some Ai\""], ["proof (prove)\nusing this:\n  [xa # xs [\\<mapsto>] y # ys] = [xa \\<mapsto> y] ++ [xs [\\<mapsto>] ys]\n  [xa # xs [\\<mapsto>] y # ys] x = Some Ai\n  [xs [\\<mapsto>] ys] x = None\n\ngoal (1 subgoal):\n 1. [xa \\<mapsto> y] x = Some Ai", "by (auto simp only:map_add_SomeD)"], ["proof (state)\nthis:\n  [xa \\<mapsto> y] x = Some Ai\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "hence ai_def: \"y = Ai\" and x_eq_xa:\"x=xa\""], ["proof (prove)\nusing this:\n  [xa \\<mapsto> y] x = Some Ai\n\ngoal (1 subgoal):\n 1. y = Ai &&& x = xa", "by (auto simp only:map_upd_Some_unfold)"], ["proof (state)\nthis:\n  y = Ai\n  x = xa\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "{"], ["proof (state)\nthis:\n  y = Ai\n  x = xa\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "fix Bs::\"'c list\""], ["proof (state)\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "assume length_Bs: \"length Bs = length (y#ys)\""], ["proof (state)\nthis:\n  length Bs = length (y # ys)\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "then"], ["proof (chain)\npicking this:\n  length Bs = length (y # ys)", "obtain n where \"length (y#ys) = Suc n\""], ["proof (prove)\nusing this:\n  length Bs = length (y # ys)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        length (y # ys) = Suc n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length (y # ys) = Suc n\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "with length_Bs"], ["proof (chain)\npicking this:\n  length Bs = length (y # ys)\n  length (y # ys) = Suc n", "obtain b bs where Bs_def: \"Bs = b#bs\""], ["proof (prove)\nusing this:\n  length Bs = length (y # ys)\n  length (y # ys) = Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>b bs. Bs = b # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:length_Suc_conv)"], ["proof (state)\nthis:\n  Bs = b # bs\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "with length_Bs"], ["proof (chain)\npicking this:\n  length Bs = length (y # ys)\n  Bs = b # bs", "have \"length ys = length bs\""], ["proof (prove)\nusing this:\n  length Bs = length (y # ys)\n  Bs = b # bs\n\ngoal (1 subgoal):\n 1. length ys = length bs", "by simp"], ["proof (state)\nthis:\n  length ys = length bs\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "hence \"dom([xs[\\<mapsto>]ys]) = dom([xs[\\<mapsto>]bs])\""], ["proof (prove)\nusing this:\n  length ys = length bs\n\ngoal (1 subgoal):\n 1. dom [xs [\\<mapsto>] ys] = dom [xs [\\<mapsto>] bs]", "by auto"], ["proof (state)\nthis:\n  dom [xs [\\<mapsto>] ys] = dom [xs [\\<mapsto>] bs]\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "with None"], ["proof (chain)\npicking this:\n  [xs [\\<mapsto>] ys] x = None\n  dom [xs [\\<mapsto>] ys] = dom [xs [\\<mapsto>] bs]", "have \"[xs[\\<mapsto>]bs] x = None\""], ["proof (prove)\nusing this:\n  [xs [\\<mapsto>] ys] x = None\n  dom [xs [\\<mapsto>] ys] = dom [xs [\\<mapsto>] bs]\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] bs] x = None", "by (auto simp only:domIff)"], ["proof (state)\nthis:\n  [xs [\\<mapsto>] bs] x = None\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "moreover"], ["proof (state)\nthis:\n  [xs [\\<mapsto>] bs] x = None\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "from x_eq_xa"], ["proof (chain)\npicking this:\n  x = xa", "have sing_map: \"[xa\\<mapsto>b] x = Some b\""], ["proof (prove)\nusing this:\n  x = xa\n\ngoal (1 subgoal):\n 1. [xa \\<mapsto> b] x = Some b", "by (auto simp only:map_upd_Some_unfold)"], ["proof (state)\nthis:\n  [xa \\<mapsto> b] x = Some b\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "ultimately"], ["proof (chain)\npicking this:\n  [xs [\\<mapsto>] bs] x = None\n  [xa \\<mapsto> b] x = Some b", "have \"([xa\\<mapsto>b] ++ [xs[\\<mapsto>]bs]) x = Some b\""], ["proof (prove)\nusing this:\n  [xs [\\<mapsto>] bs] x = None\n  [xa \\<mapsto> b] x = Some b\n\ngoal (1 subgoal):\n 1. ([xa \\<mapsto> b] ++ [xs [\\<mapsto>] bs]) x = Some b", "by (auto simp only:map_add_Some_iff)"], ["proof (state)\nthis:\n  ([xa \\<mapsto> b] ++ [xs [\\<mapsto>] bs]) x = Some b\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "with Bs_def"], ["proof (chain)\npicking this:\n  Bs = b # bs\n  ([xa \\<mapsto> b] ++ [xs [\\<mapsto>] bs]) x = Some b", "have \"?P3 0 (xa#xs) (y#ys) Bs\""], ["proof (prove)\nusing this:\n  Bs = b # bs\n  ([xa \\<mapsto> b] ++ [xs [\\<mapsto>] bs]) x = Some b\n\ngoal (1 subgoal):\n 1. length Bs = length (y # ys) \\<longrightarrow>\n    [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! 0)", "by simp"], ["proof (state)\nthis:\n  length Bs = length (y # ys) \\<longrightarrow>\n  [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! 0)\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "}"], ["proof (state)\nthis:\n  length ?Bs2 = length (y # ys) \\<Longrightarrow>\n  length ?Bs2 = length (y # ys) \\<longrightarrow>\n  [xa # xs [\\<mapsto>] ?Bs2] x = Some (?Bs2 ! 0)\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "with ai_def"], ["proof (chain)\npicking this:\n  y = Ai\n  length ?Bs2 = length (y # ys) \\<Longrightarrow>\n  length ?Bs2 = length (y # ys) \\<longrightarrow>\n  [xa # xs [\\<mapsto>] ?Bs2] x = Some (?Bs2 ! 0)", "have \"?P 0 (xa#xs) (y#ys)\""], ["proof (prove)\nusing this:\n  y = Ai\n  length ?Bs2 = length (y # ys) \\<Longrightarrow>\n  length ?Bs2 = length (y # ys) \\<longrightarrow>\n  [xa # xs [\\<mapsto>] ?Bs2] x = Some (?Bs2 ! 0)\n\ngoal (1 subgoal):\n 1. (y # ys) ! 0 = Ai \\<and>\n    0 < length (y # ys) \\<and>\n    (\\<forall>Bs.\n        length Bs = length (y # ys) \\<longrightarrow>\n        [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! 0))", "by auto"], ["proof (state)\nthis:\n  (y # ys) ! 0 = Ai \\<and>\n  0 < length (y # ys) \\<and>\n  (\\<forall>Bs.\n      length Bs = length (y # ys) \\<longrightarrow>\n      [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! 0))\n\ngoal (1 subgoal):\n 1. [xs [\\<mapsto>] ys] x = None \\<Longrightarrow>\n    \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (y # ys) ! 0 = Ai \\<and>\n  0 < length (y # ys) \\<and>\n  (\\<forall>Bs.\n      length Bs = length (y # ys) \\<longrightarrow>\n      [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! 0))\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       (y # ys) ! i = Ai \\<and>\n       i < length (y # ys) \\<and>\n       (\\<forall>Bs.\n           length Bs = length (y # ys) \\<longrightarrow>\n           [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))", ".."], ["proof (state)\nthis:\n  \\<exists>i.\n     (y # ys) ! i = Ai \\<and>\n     i < length (y # ys) \\<and>\n     (\\<forall>Bs.\n         length Bs = length (y # ys) \\<longrightarrow>\n         [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i.\n     (y # ys) ! i = Ai \\<and>\n     i < length (y # ys) \\<and>\n     (\\<forall>Bs.\n         length Bs = length (y # ys) \\<longrightarrow>\n         [xa # xs [\\<mapsto>] Bs] x = Some (Bs ! i))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>FJ Lemmas\\<close>"], ["", "subsubsection\\<open>Substitution\\<close>"], ["", "lemma subst_list1_eq_map_substs : \n  \"\\<forall>\\<sigma>. subst_list1 \\<sigma> l = map (substs \\<sigma>) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>. subst_list1 \\<sigma> l = map (substs \\<sigma>) l", "by (induct l, simp_all)"], ["", "lemma subst_list2_eq_map_substs : \n  \"\\<forall>\\<sigma>. subst_list2 \\<sigma> l = map (substs \\<sigma>) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>. subst_list2 \\<sigma> l = map (substs \\<sigma>) l", "by (induct l, simp_all)"], ["", "subsubsection\\<open>Lookup\\<close>"], ["", "lemma lookup_functional:\n  assumes \"lookup l f = o1\"\n  and \"lookup l f = o2\"\n  shows \"o1 = o2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. o1 = o2", "using assms"], ["proof (prove)\nusing this:\n  lookup l f = o1\n  lookup l f = o2\n\ngoal (1 subgoal):\n 1. o1 = o2", "by (induct l) auto"], ["", "lemma lookup_true:\n  \"lookup l f = Some r \\<Longrightarrow> f r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup l f = Some r \\<Longrightarrow> f r", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup [] f = Some r \\<Longrightarrow> f r\n 2. \\<And>a l.\n       \\<lbrakk>lookup l f = Some r \\<Longrightarrow> f r;\n        lookup (a # l) f = Some r\\<rbrakk>\n       \\<Longrightarrow> f r", "case Nil"], ["proof (state)\nthis:\n  lookup [] f = Some r\n\ngoal (2 subgoals):\n 1. lookup [] f = Some r \\<Longrightarrow> f r\n 2. \\<And>a l.\n       \\<lbrakk>lookup l f = Some r \\<Longrightarrow> f r;\n        lookup (a # l) f = Some r\\<rbrakk>\n       \\<Longrightarrow> f r", "thus ?case"], ["proof (prove)\nusing this:\n  lookup [] f = Some r\n\ngoal (1 subgoal):\n 1. f r", "by simp"], ["proof (state)\nthis:\n  f r\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>lookup l f = Some r \\<Longrightarrow> f r;\n        lookup (a # l) f = Some r\\<rbrakk>\n       \\<Longrightarrow> f r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>lookup l f = Some r \\<Longrightarrow> f r;\n        lookup (a # l) f = Some r\\<rbrakk>\n       \\<Longrightarrow> f r", "case(Cons h t)"], ["proof (state)\nthis:\n  lookup t f = Some r \\<Longrightarrow> f r\n  lookup (h # t) f = Some r\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>lookup l f = Some r \\<Longrightarrow> f r;\n        lookup (a # l) f = Some r\\<rbrakk>\n       \\<Longrightarrow> f r", "thus ?case"], ["proof (prove)\nusing this:\n  lookup t f = Some r \\<Longrightarrow> f r\n  lookup (h # t) f = Some r\n\ngoal (1 subgoal):\n 1. f r", "by(cases \"f h\") (auto simp add:lookup.simps)"], ["proof (state)\nthis:\n  f r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_hd:\n  \"\\<lbrakk> length l > 0; f (l!0) \\<rbrakk> \\<Longrightarrow> lookup l f = Some (l!0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < length l; f (l ! 0)\\<rbrakk>\n    \\<Longrightarrow> lookup l f = Some (l ! 0)", "by (induct l) auto"], ["", "lemma lookup_split: \"lookup l f = None \\<or> (\\<exists>h. lookup l f = Some h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup l f = None \\<or> (\\<exists>h. lookup l f = Some h)", "by (induct l) simp_all"], ["", "lemma lookup_index:\n  assumes \"lookup l1 f = Some e\" \n  shows \" \\<And>l2. \\<exists>i < (length l1). e = l1!i \\<and> ((length l1 = length l2) \\<longrightarrow> lookup2 l1 l2 f = Some (l2!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l2.\n       \\<exists>i<length l1.\n          e = l1 ! i \\<and>\n          (length l1 = length l2 \\<longrightarrow>\n           lookup2 l1 l2 f = Some (l2 ! i))", "using assms"], ["proof (prove)\nusing this:\n  lookup l1 f = Some e\n\ngoal (1 subgoal):\n 1. \\<And>l2.\n       \\<exists>i<length l1.\n          e = l1 ! i \\<and>\n          (length l1 = length l2 \\<longrightarrow>\n           lookup2 l1 l2 f = Some (l2 ! i))", "proof(induct l1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l2.\n       lookup [] f = Some e \\<Longrightarrow>\n       \\<exists>i<length [].\n          e = [] ! i \\<and>\n          (length [] = length l2 \\<longrightarrow>\n           lookup2 [] l2 f = Some (l2 ! i))\n 2. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "case Nil"], ["proof (state)\nthis:\n  lookup [] f = Some e\n\ngoal (2 subgoals):\n 1. \\<And>l2.\n       lookup [] f = Some e \\<Longrightarrow>\n       \\<exists>i<length [].\n          e = [] ! i \\<and>\n          (length [] = length l2 \\<longrightarrow>\n           lookup2 [] l2 f = Some (l2 ! i))\n 2. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "thus ?case"], ["proof (prove)\nusing this:\n  lookup [] f = Some e\n\ngoal (1 subgoal):\n 1. \\<exists>i<length [].\n       e = [] ! i \\<and>\n       (length [] = length l2 \\<longrightarrow>\n        lookup2 [] l2 f = Some (l2 ! i))", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length [].\n     e = [] ! i \\<and>\n     (length [] = length l2 \\<longrightarrow>\n      lookup2 [] l2 f = Some (l2 ! i))\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "case (Cons h1 t1)"], ["proof (state)\nthis:\n  lookup t1 f = Some e \\<Longrightarrow>\n  \\<exists>i<length t1.\n     e = t1 ! i \\<and>\n     (length t1 = length ?l2.0 \\<longrightarrow>\n      lookup2 t1 ?l2.0 f = Some (?l2.0 ! i))\n  lookup (h1 # t1) f = Some e\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "{"], ["proof (state)\nthis:\n  lookup t1 f = Some e \\<Longrightarrow>\n  \\<exists>i<length t1.\n     e = t1 ! i \\<and>\n     (length t1 = length ?l2.0 \\<longrightarrow>\n      lookup2 t1 ?l2.0 f = Some (?l2.0 ! i))\n  lookup (h1 # t1) f = Some e\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "assume asm:\"f h1\""], ["proof (state)\nthis:\n  f h1\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "hence \"0<length (h1 # t1) \\<and> e = (h1 # t1) ! 0\""], ["proof (prove)\nusing this:\n  f h1\n\ngoal (1 subgoal):\n 1. 0 < length (h1 # t1) \\<and> e = (h1 # t1) ! 0", "using Cons"], ["proof (prove)\nusing this:\n  f h1\n  lookup t1 f = Some e \\<Longrightarrow>\n  \\<exists>i<length t1.\n     e = t1 ! i \\<and>\n     (length t1 = length ?l2.0 \\<longrightarrow>\n      lookup2 t1 ?l2.0 f = Some (?l2.0 ! i))\n  lookup (h1 # t1) f = Some e\n\ngoal (1 subgoal):\n 1. 0 < length (h1 # t1) \\<and> e = (h1 # t1) ! 0", "by (auto simp add:lookup.simps)"], ["proof (state)\nthis:\n  0 < length (h1 # t1) \\<and> e = (h1 # t1) ! 0\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "moreover"], ["proof (state)\nthis:\n  0 < length (h1 # t1) \\<and> e = (h1 # t1) ! 0\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "{"], ["proof (state)\nthis:\n  0 < length (h1 # t1) \\<and> e = (h1 # t1) ! 0\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "assume \"length (h1 # t1) = length l2\""], ["proof (state)\nthis:\n  length (h1 # t1) = length l2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "hence \"length l2 = Suc (length t1)\""], ["proof (prove)\nusing this:\n  length (h1 # t1) = length l2\n\ngoal (1 subgoal):\n 1. length l2 = Suc (length t1)", "by auto"], ["proof (state)\nthis:\n  length l2 = Suc (length t1)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "then"], ["proof (chain)\npicking this:\n  length l2 = Suc (length t1)", "obtain h2 t2 where l2_def:\"l2 = h2#t2\""], ["proof (prove)\nusing this:\n  length l2 = Suc (length t1)\n\ngoal (1 subgoal):\n 1. (\\<And>h2 t2. l2 = h2 # t2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: length_Suc_conv)"], ["proof (state)\nthis:\n  l2 = h2 # t2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "hence \"lookup2 (h1 # t1) l2 f = Some (l2 ! 0)\""], ["proof (prove)\nusing this:\n  l2 = h2 # t2\n\ngoal (1 subgoal):\n 1. lookup2 (h1 # t1) l2 f = Some (l2 ! 0)", "using asm"], ["proof (prove)\nusing this:\n  l2 = h2 # t2\n  f h1\n\ngoal (1 subgoal):\n 1. lookup2 (h1 # t1) l2 f = Some (l2 ! 0)", "by(auto simp add: lookup2.simps)"], ["proof (state)\nthis:\n  lookup2 (h1 # t1) l2 f = Some (l2 ! 0)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "}"], ["proof (state)\nthis:\n  length (h1 # t1) = length l2 \\<Longrightarrow>\n  lookup2 (h1 # t1) l2 f = Some (l2 ! 0)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "ultimately"], ["proof (chain)\npicking this:\n  0 < length (h1 # t1) \\<and> e = (h1 # t1) ! 0\n  length (h1 # t1) = length l2 \\<Longrightarrow>\n  lookup2 (h1 # t1) l2 f = Some (l2 ! 0)", "have ?case"], ["proof (prove)\nusing this:\n  0 < length (h1 # t1) \\<and> e = (h1 # t1) ! 0\n  length (h1 # t1) = length l2 \\<Longrightarrow>\n  lookup2 (h1 # t1) l2 f = Some (l2 ! 0)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length (h1 # t1).\n       e = (h1 # t1) ! i \\<and>\n       (length (h1 # t1) = length l2 \\<longrightarrow>\n        lookup2 (h1 # t1) l2 f = Some (l2 ! i))", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length (h1 # t1).\n     e = (h1 # t1) ! i \\<and>\n     (length (h1 # t1) = length l2 \\<longrightarrow>\n      lookup2 (h1 # t1) l2 f = Some (l2 ! i))\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "}"], ["proof (state)\nthis:\n  f h1 \\<Longrightarrow>\n  \\<exists>i<length (h1 # t1).\n     e = (h1 # t1) ! i \\<and>\n     (length (h1 # t1) = length l2 \\<longrightarrow>\n      lookup2 (h1 # t1) l2 f = Some (l2 ! i))\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "moreover"], ["proof (state)\nthis:\n  f h1 \\<Longrightarrow>\n  \\<exists>i<length (h1 # t1).\n     e = (h1 # t1) ! i \\<and>\n     (length (h1 # t1) = length l2 \\<longrightarrow>\n      lookup2 (h1 # t1) l2 f = Some (l2 ! i))\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "{"], ["proof (state)\nthis:\n  f h1 \\<Longrightarrow>\n  \\<exists>i<length (h1 # t1).\n     e = (h1 # t1) ! i \\<and>\n     (length (h1 # t1) = length l2 \\<longrightarrow>\n      lookup2 (h1 # t1) l2 f = Some (l2 ! i))\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "assume asm:\"\\<not> (f h1)\""], ["proof (state)\nthis:\n  \\<not> f h1\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "hence \"lookup t1 f = Some e\""], ["proof (prove)\nusing this:\n  \\<not> f h1\n\ngoal (1 subgoal):\n 1. lookup t1 f = Some e", "using Cons"], ["proof (prove)\nusing this:\n  \\<not> f h1\n  lookup t1 f = Some e \\<Longrightarrow>\n  \\<exists>i<length t1.\n     e = t1 ! i \\<and>\n     (length t1 = length ?l2.0 \\<longrightarrow>\n      lookup2 t1 ?l2.0 f = Some (?l2.0 ! i))\n  lookup (h1 # t1) f = Some e\n\ngoal (1 subgoal):\n 1. lookup t1 f = Some e", "by (auto simp add:lookup.simps)"], ["proof (state)\nthis:\n  lookup t1 f = Some e\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "then"], ["proof (chain)\npicking this:\n  lookup t1 f = Some e", "obtain i where \n      \"i<length t1\" \n      and \"e = t1 ! i\" \n      and  ih:\"(length t1 = length (tl l2) \\<longrightarrow> lookup2 t1 (tl l2) f = Some ((tl l2) ! i))\""], ["proof (prove)\nusing this:\n  lookup t1 f = Some e\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length t1; e = t1 ! i;\n         length t1 = length (tl l2) \\<longrightarrow>\n         lookup2 t1 (tl l2) f = Some (tl l2 ! i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons"], ["proof (prove)\nusing this:\n  lookup t1 f = Some e\n  lookup t1 f = Some e \\<Longrightarrow>\n  \\<exists>i<length t1.\n     e = t1 ! i \\<and>\n     (length t1 = length ?l2.0 \\<longrightarrow>\n      lookup2 t1 ?l2.0 f = Some (?l2.0 ! i))\n  lookup (h1 # t1) f = Some e\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length t1; e = t1 ! i;\n         length t1 = length (tl l2) \\<longrightarrow>\n         lookup2 t1 (tl l2) f = Some (tl l2 ! i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < length t1\n  e = t1 ! i\n  length t1 = length (tl l2) \\<longrightarrow>\n  lookup2 t1 (tl l2) f = Some (tl l2 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "hence \"Suc i < length (h1#t1) \\<and> e = (h1#t1)!(Suc i)\""], ["proof (prove)\nusing this:\n  i < length t1\n  e = t1 ! i\n  length t1 = length (tl l2) \\<longrightarrow>\n  lookup2 t1 (tl l2) f = Some (tl l2 ! i)\n\ngoal (1 subgoal):\n 1. Suc i < length (h1 # t1) \\<and> e = (h1 # t1) ! Suc i", "using Cons"], ["proof (prove)\nusing this:\n  i < length t1\n  e = t1 ! i\n  length t1 = length (tl l2) \\<longrightarrow>\n  lookup2 t1 (tl l2) f = Some (tl l2 ! i)\n  lookup t1 f = Some e \\<Longrightarrow>\n  \\<exists>i<length t1.\n     e = t1 ! i \\<and>\n     (length t1 = length ?l2.0 \\<longrightarrow>\n      lookup2 t1 ?l2.0 f = Some (?l2.0 ! i))\n  lookup (h1 # t1) f = Some e\n\ngoal (1 subgoal):\n 1. Suc i < length (h1 # t1) \\<and> e = (h1 # t1) ! Suc i", "by auto"], ["proof (state)\nthis:\n  Suc i < length (h1 # t1) \\<and> e = (h1 # t1) ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "moreover"], ["proof (state)\nthis:\n  Suc i < length (h1 # t1) \\<and> e = (h1 # t1) ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "{"], ["proof (state)\nthis:\n  Suc i < length (h1 # t1) \\<and> e = (h1 # t1) ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "assume \"length (h1 # t1) = length l2\""], ["proof (state)\nthis:\n  length (h1 # t1) = length l2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "hence lens:\"length l2 = Suc (length t1)\""], ["proof (prove)\nusing this:\n  length (h1 # t1) = length l2\n\ngoal (1 subgoal):\n 1. length l2 = Suc (length t1)", "by auto"], ["proof (state)\nthis:\n  length l2 = Suc (length t1)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "then"], ["proof (chain)\npicking this:\n  length l2 = Suc (length t1)", "obtain h2 t2 where l2_def:\"l2 = h2#t2\""], ["proof (prove)\nusing this:\n  length l2 = Suc (length t1)\n\ngoal (1 subgoal):\n 1. (\\<And>h2 t2. l2 = h2 # t2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: length_Suc_conv)"], ["proof (state)\nthis:\n  l2 = h2 # t2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "hence \"lookup2 t1 t2 f = Some (t2 ! i)\""], ["proof (prove)\nusing this:\n  l2 = h2 # t2\n\ngoal (1 subgoal):\n 1. lookup2 t1 t2 f = Some (t2 ! i)", "using ih l2_def lens"], ["proof (prove)\nusing this:\n  l2 = h2 # t2\n  length t1 = length (tl l2) \\<longrightarrow>\n  lookup2 t1 (tl l2) f = Some (tl l2 ! i)\n  l2 = h2 # t2\n  length l2 = Suc (length t1)\n\ngoal (1 subgoal):\n 1. lookup2 t1 t2 f = Some (t2 ! i)", "by auto"], ["proof (state)\nthis:\n  lookup2 t1 t2 f = Some (t2 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "hence \"lookup2 (h1 # t1) l2 f = Some (l2!(Suc i))\""], ["proof (prove)\nusing this:\n  lookup2 t1 t2 f = Some (t2 ! i)\n\ngoal (1 subgoal):\n 1. lookup2 (h1 # t1) l2 f = Some (l2 ! Suc i)", "using asm l2_def"], ["proof (prove)\nusing this:\n  lookup2 t1 t2 f = Some (t2 ! i)\n  \\<not> f h1\n  l2 = h2 # t2\n\ngoal (1 subgoal):\n 1. lookup2 (h1 # t1) l2 f = Some (l2 ! Suc i)", "by(auto simp add: lookup2.simps)"], ["proof (state)\nthis:\n  lookup2 (h1 # t1) l2 f = Some (l2 ! Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "}"], ["proof (state)\nthis:\n  length (h1 # t1) = length l2 \\<Longrightarrow>\n  lookup2 (h1 # t1) l2 f = Some (l2 ! Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "ultimately"], ["proof (chain)\npicking this:\n  Suc i < length (h1 # t1) \\<and> e = (h1 # t1) ! Suc i\n  length (h1 # t1) = length l2 \\<Longrightarrow>\n  lookup2 (h1 # t1) l2 f = Some (l2 ! Suc i)", "have ?case"], ["proof (prove)\nusing this:\n  Suc i < length (h1 # t1) \\<and> e = (h1 # t1) ! Suc i\n  length (h1 # t1) = length l2 \\<Longrightarrow>\n  lookup2 (h1 # t1) l2 f = Some (l2 ! Suc i)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length (h1 # t1).\n       e = (h1 # t1) ! i \\<and>\n       (length (h1 # t1) = length l2 \\<longrightarrow>\n        lookup2 (h1 # t1) l2 f = Some (l2 ! i))", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length (h1 # t1).\n     e = (h1 # t1) ! i \\<and>\n     (length (h1 # t1) = length l2 \\<longrightarrow>\n      lookup2 (h1 # t1) l2 f = Some (l2 ! i))\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "}"], ["proof (state)\nthis:\n  \\<not> f h1 \\<Longrightarrow>\n  \\<exists>i<length (h1 # t1).\n     e = (h1 # t1) ! i \\<and>\n     (length (h1 # t1) = length l2 \\<longrightarrow>\n      lookup2 (h1 # t1) l2 f = Some (l2 ! i))\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   lookup l1 f = Some e \\<Longrightarrow>\n                   \\<exists>i<length l1.\n                      e = l1 ! i \\<and>\n                      (length l1 = length l2 \\<longrightarrow>\n                       lookup2 l1 l2 f = Some (l2 ! i));\n        lookup (a # l1) f = Some e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # l1).\n                            e = (a # l1) ! i \\<and>\n                            (length (a # l1) = length l2 \\<longrightarrow>\n                             lookup2 (a # l1) l2 f = Some (l2 ! i))", "ultimately"], ["proof (chain)\npicking this:\n  f h1 \\<Longrightarrow>\n  \\<exists>i<length (h1 # t1).\n     e = (h1 # t1) ! i \\<and>\n     (length (h1 # t1) = length l2 \\<longrightarrow>\n      lookup2 (h1 # t1) l2 f = Some (l2 ! i))\n  \\<not> f h1 \\<Longrightarrow>\n  \\<exists>i<length (h1 # t1).\n     e = (h1 # t1) ! i \\<and>\n     (length (h1 # t1) = length l2 \\<longrightarrow>\n      lookup2 (h1 # t1) l2 f = Some (l2 ! i))", "show ?case"], ["proof (prove)\nusing this:\n  f h1 \\<Longrightarrow>\n  \\<exists>i<length (h1 # t1).\n     e = (h1 # t1) ! i \\<and>\n     (length (h1 # t1) = length l2 \\<longrightarrow>\n      lookup2 (h1 # t1) l2 f = Some (l2 ! i))\n  \\<not> f h1 \\<Longrightarrow>\n  \\<exists>i<length (h1 # t1).\n     e = (h1 # t1) ! i \\<and>\n     (length (h1 # t1) = length l2 \\<longrightarrow>\n      lookup2 (h1 # t1) l2 f = Some (l2 ! i))\n\ngoal (1 subgoal):\n 1. \\<exists>i<length (h1 # t1).\n       e = (h1 # t1) ! i \\<and>\n       (length (h1 # t1) = length l2 \\<longrightarrow>\n        lookup2 (h1 # t1) l2 f = Some (l2 ! i))", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length (h1 # t1).\n     e = (h1 # t1) ! i \\<and>\n     (length (h1 # t1) = length l2 \\<longrightarrow>\n      lookup2 (h1 # t1) l2 f = Some (l2 ! i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup2_index:\n  \"\\<And>l2. \\<lbrakk> lookup2 l1 l2 f = Some e; \n  length l1 = length l2 \\<rbrakk> \\<Longrightarrow> \\<exists>i < (length l2). e = (l2!i) \\<and> lookup l1 f = Some (l1!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l2.\n       \\<lbrakk>lookup2 l1 l2 f = Some e; length l1 = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i)", "proof(induct l1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l2.\n       \\<lbrakk>lookup2 [] l2 f = Some e; length [] = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and> lookup [] f = Some ([] ! i)\n 2. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "case Nil"], ["proof (state)\nthis:\n  lookup2 [] l2 f = Some e\n  length [] = length l2\n\ngoal (2 subgoals):\n 1. \\<And>l2.\n       \\<lbrakk>lookup2 [] l2 f = Some e; length [] = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and> lookup [] f = Some ([] ! i)\n 2. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "thus ?case"], ["proof (prove)\nusing this:\n  lookup2 [] l2 f = Some e\n  length [] = length l2\n\ngoal (1 subgoal):\n 1. \\<exists>i<length l2. e = l2 ! i \\<and> lookup [] f = Some ([] ! i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length l2. e = l2 ! i \\<and> lookup [] f = Some ([] ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "case (Cons h1 t1)"], ["proof (state)\nthis:\n  \\<lbrakk>lookup2 t1 ?l2.0 f = Some e; length t1 = length ?l2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<length ?l2.0.\n                       e = ?l2.0 ! i \\<and> lookup t1 f = Some (t1 ! i)\n  lookup2 (h1 # t1) l2 f = Some e\n  length (h1 # t1) = length l2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "hence \"length l2 = Suc (length t1)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>lookup2 t1 ?l2.0 f = Some e; length t1 = length ?l2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<length ?l2.0.\n                       e = ?l2.0 ! i \\<and> lookup t1 f = Some (t1 ! i)\n  lookup2 (h1 # t1) l2 f = Some e\n  length (h1 # t1) = length l2\n\ngoal (1 subgoal):\n 1. length l2 = Suc (length t1)", "by auto"], ["proof (state)\nthis:\n  length l2 = Suc (length t1)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "then"], ["proof (chain)\npicking this:\n  length l2 = Suc (length t1)", "obtain h2 t2 where l2_def:\"l2 = h2#t2\""], ["proof (prove)\nusing this:\n  length l2 = Suc (length t1)\n\ngoal (1 subgoal):\n 1. (\\<And>h2 t2. l2 = h2 # t2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: length_Suc_conv)"], ["proof (state)\nthis:\n  l2 = h2 # t2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "{"], ["proof (state)\nthis:\n  l2 = h2 # t2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "assume asm:\"f h1\""], ["proof (state)\nthis:\n  f h1\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "hence \"e = h2\""], ["proof (prove)\nusing this:\n  f h1\n\ngoal (1 subgoal):\n 1. e = h2", "using Cons l2_def"], ["proof (prove)\nusing this:\n  f h1\n  \\<lbrakk>lookup2 t1 ?l2.0 f = Some e; length t1 = length ?l2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<length ?l2.0.\n                       e = ?l2.0 ! i \\<and> lookup t1 f = Some (t1 ! i)\n  lookup2 (h1 # t1) l2 f = Some e\n  length (h1 # t1) = length l2\n  l2 = h2 # t2\n\ngoal (1 subgoal):\n 1. e = h2", "by (auto simp add:lookup2.simps)"], ["proof (state)\nthis:\n  e = h2\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "hence \"0<length (h2#t2) \\<and> e = (h2#t2) ! 0 \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! 0)\""], ["proof (prove)\nusing this:\n  e = h2\n\ngoal (1 subgoal):\n 1. 0 < length (h2 # t2) \\<and>\n    e = (h2 # t2) ! 0 \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! 0)", "using asm"], ["proof (prove)\nusing this:\n  e = h2\n  f h1\n\ngoal (1 subgoal):\n 1. 0 < length (h2 # t2) \\<and>\n    e = (h2 # t2) ! 0 \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! 0)", "by (auto simp add:lookup.simps)"], ["proof (state)\nthis:\n  0 < length (h2 # t2) \\<and>\n  e = (h2 # t2) ! 0 \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! 0)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "hence ?case"], ["proof (prove)\nusing this:\n  0 < length (h2 # t2) \\<and>\n  e = (h2 # t2) ! 0 \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! 0)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length l2.\n       e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)", "using l2_def"], ["proof (prove)\nusing this:\n  0 < length (h2 # t2) \\<and>\n  e = (h2 # t2) ! 0 \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! 0)\n  l2 = h2 # t2\n\ngoal (1 subgoal):\n 1. \\<exists>i<length l2.\n       e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length l2.\n     e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "}"], ["proof (state)\nthis:\n  f h1 \\<Longrightarrow>\n  \\<exists>i<length l2.\n     e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "moreover"], ["proof (state)\nthis:\n  f h1 \\<Longrightarrow>\n  \\<exists>i<length l2.\n     e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "{"], ["proof (state)\nthis:\n  f h1 \\<Longrightarrow>\n  \\<exists>i<length l2.\n     e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "assume asm:\"\\<not> (f h1)\""], ["proof (state)\nthis:\n  \\<not> f h1\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "hence \"\\<exists>i<length t2. e = t2 ! i \\<and> lookup t1 f = Some (t1 ! i)\""], ["proof (prove)\nusing this:\n  \\<not> f h1\n\ngoal (1 subgoal):\n 1. \\<exists>i<length t2. e = t2 ! i \\<and> lookup t1 f = Some (t1 ! i)", "using Cons l2_def"], ["proof (prove)\nusing this:\n  \\<not> f h1\n  \\<lbrakk>lookup2 t1 ?l2.0 f = Some e; length t1 = length ?l2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<length ?l2.0.\n                       e = ?l2.0 ! i \\<and> lookup t1 f = Some (t1 ! i)\n  lookup2 (h1 # t1) l2 f = Some e\n  length (h1 # t1) = length l2\n  l2 = h2 # t2\n\ngoal (1 subgoal):\n 1. \\<exists>i<length t2. e = t2 ! i \\<and> lookup t1 f = Some (t1 ! i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length t2. e = t2 ! i \\<and> lookup t1 f = Some (t1 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i<length t2. e = t2 ! i \\<and> lookup t1 f = Some (t1 ! i)", "obtain i where \"i<length t2 \\<and>  e = t2 ! i \\<and> lookup t1 f = Some (t1 ! i)\""], ["proof (prove)\nusing this:\n  \\<exists>i<length t2. e = t2 ! i \\<and> lookup t1 f = Some (t1 ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length t2 \\<and>\n        e = t2 ! i \\<and> lookup t1 f = Some (t1 ! i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length t2 \\<and> e = t2 ! i \\<and> lookup t1 f = Some (t1 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "hence \"(Suc i) < length(h2#t2) \\<and> e = ((h2#t2) ! (Suc i)) \\<and> lookup (h1#t1) f = Some ((h1#t1) ! (Suc i))\""], ["proof (prove)\nusing this:\n  i < length t2 \\<and> e = t2 ! i \\<and> lookup t1 f = Some (t1 ! i)\n\ngoal (1 subgoal):\n 1. Suc i < length (h2 # t2) \\<and>\n    e = (h2 # t2) ! Suc i \\<and>\n    lookup (h1 # t1) f = Some ((h1 # t1) ! Suc i)", "using asm"], ["proof (prove)\nusing this:\n  i < length t2 \\<and> e = t2 ! i \\<and> lookup t1 f = Some (t1 ! i)\n  \\<not> f h1\n\ngoal (1 subgoal):\n 1. Suc i < length (h2 # t2) \\<and>\n    e = (h2 # t2) ! Suc i \\<and>\n    lookup (h1 # t1) f = Some ((h1 # t1) ! Suc i)", "by (force simp add: lookup.simps)"], ["proof (state)\nthis:\n  Suc i < length (h2 # t2) \\<and>\n  e = (h2 # t2) ! Suc i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "hence ?case"], ["proof (prove)\nusing this:\n  Suc i < length (h2 # t2) \\<and>\n  e = (h2 # t2) ! Suc i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! Suc i)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length l2.\n       e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)", "using l2_def"], ["proof (prove)\nusing this:\n  Suc i < length (h2 # t2) \\<and>\n  e = (h2 # t2) ! Suc i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! Suc i)\n  l2 = h2 # t2\n\ngoal (1 subgoal):\n 1. \\<exists>i<length l2.\n       e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length l2.\n     e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "}"], ["proof (state)\nthis:\n  \\<not> f h1 \\<Longrightarrow>\n  \\<exists>i<length l2.\n     e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 l2.\n       \\<lbrakk>\\<And>l2.\n                   \\<lbrakk>lookup2 l1 l2 f = Some e;\n                    length l1 = length l2\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i<length l2.\n  e = l2 ! i \\<and> lookup l1 f = Some (l1 ! i);\n        lookup2 (a # l1) l2 f = Some e; length (a # l1) = length l2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length l2.\n                            e = l2 ! i \\<and>\n                            lookup (a # l1) f = Some ((a # l1) ! i)", "ultimately"], ["proof (chain)\npicking this:\n  f h1 \\<Longrightarrow>\n  \\<exists>i<length l2.\n     e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)\n  \\<not> f h1 \\<Longrightarrow>\n  \\<exists>i<length l2.\n     e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)", "show ?case"], ["proof (prove)\nusing this:\n  f h1 \\<Longrightarrow>\n  \\<exists>i<length l2.\n     e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)\n  \\<not> f h1 \\<Longrightarrow>\n  \\<exists>i<length l2.\n     e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length l2.\n       e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length l2.\n     e = l2 ! i \\<and> lookup (h1 # t1) f = Some ((h1 # t1) ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_append:\n  assumes \"lookup l f = Some r\"\n  shows \"lookup (l@l') f = Some r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (l @ l') f = Some r", "using assms"], ["proof (prove)\nusing this:\n  lookup l f = Some r\n\ngoal (1 subgoal):\n 1. lookup (l @ l') f = Some r", "by(induct l) auto"], ["", "lemma method_typings_lookup:\n  assumes lookup_eq_Some: \"lookup M f = Some mDef\"\n  and M_ok: \"CT \\<turnstile>+ M OK IN C\"\n  shows \"CT \\<turnstile> mDef OK IN C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CT \\<turnstile> mDef OK IN C", "using lookup_eq_Some M_ok"], ["proof (prove)\nusing this:\n  lookup M f = Some mDef\n  CT \\<turnstile>+ M OK IN C\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> mDef OK IN C", "proof(induct M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>lookup [] f = Some mDef; CT \\<turnstile>+ [] OK IN C\\<rbrakk>\n    \\<Longrightarrow> CT \\<turnstile> mDef OK IN C\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>lookup M f = Some mDef;\n                 CT \\<turnstile>+ M OK IN C\\<rbrakk>\n                \\<Longrightarrow> CT \\<turnstile> mDef OK IN C;\n        lookup (a # M) f = Some mDef;\n        CT \\<turnstile>+ (a # M) OK IN C\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> mDef OK IN C", "case Nil"], ["proof (state)\nthis:\n  lookup [] f = Some mDef\n  CT \\<turnstile>+ [] OK IN C\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lookup [] f = Some mDef; CT \\<turnstile>+ [] OK IN C\\<rbrakk>\n    \\<Longrightarrow> CT \\<turnstile> mDef OK IN C\n 2. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>lookup M f = Some mDef;\n                 CT \\<turnstile>+ M OK IN C\\<rbrakk>\n                \\<Longrightarrow> CT \\<turnstile> mDef OK IN C;\n        lookup (a # M) f = Some mDef;\n        CT \\<turnstile>+ (a # M) OK IN C\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> mDef OK IN C", "thus ?case"], ["proof (prove)\nusing this:\n  lookup [] f = Some mDef\n  CT \\<turnstile>+ [] OK IN C\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> mDef OK IN C", "by fastforce"], ["proof (state)\nthis:\n  CT \\<turnstile> mDef OK IN C\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>lookup M f = Some mDef;\n                 CT \\<turnstile>+ M OK IN C\\<rbrakk>\n                \\<Longrightarrow> CT \\<turnstile> mDef OK IN C;\n        lookup (a # M) f = Some mDef;\n        CT \\<turnstile>+ (a # M) OK IN C\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> mDef OK IN C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>lookup M f = Some mDef;\n                 CT \\<turnstile>+ M OK IN C\\<rbrakk>\n                \\<Longrightarrow> CT \\<turnstile> mDef OK IN C;\n        lookup (a # M) f = Some mDef;\n        CT \\<turnstile>+ (a # M) OK IN C\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> mDef OK IN C", "case (Cons h t)"], ["proof (state)\nthis:\n  \\<lbrakk>lookup t f = Some mDef; CT \\<turnstile>+ t OK IN C\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> mDef OK IN C\n  lookup (h # t) f = Some mDef\n  CT \\<turnstile>+ (h # t) OK IN C\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<lbrakk>\\<lbrakk>lookup M f = Some mDef;\n                 CT \\<turnstile>+ M OK IN C\\<rbrakk>\n                \\<Longrightarrow> CT \\<turnstile> mDef OK IN C;\n        lookup (a # M) f = Some mDef;\n        CT \\<turnstile>+ (a # M) OK IN C\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> mDef OK IN C", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>lookup t f = Some mDef; CT \\<turnstile>+ t OK IN C\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> mDef OK IN C\n  lookup (h # t) f = Some mDef\n  CT \\<turnstile>+ (h # t) OK IN C\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> mDef OK IN C", "by(cases \"f h\", auto elim:method_typings.cases simp add:lookup.simps)"], ["proof (state)\nthis:\n  CT \\<turnstile> mDef OK IN C\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Functional\\<close>"], ["", "text \\<open>These lemmas prove that several relations are actually functions\\<close>"], ["", "lemma mtype_functional:\n  assumes \"mtype(CT,m,C) = Cs \\<rightarrow> C0\"\n  and     \"mtype(CT,m,C) = Ds \\<rightarrow> D0\"\n  shows \"Ds=Cs \\<and> D0=C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ds = Cs \\<and> D0 = C0", "using assms"], ["proof (prove)\nusing this:\n  mtype(CT,m,C) = Cs \\<rightarrow> C0\n  mtype(CT,m,C) = Ds \\<rightarrow> D0\n\ngoal (1 subgoal):\n 1. Ds = Cs \\<and> D0 = C0", "by induct (auto elim:mtype.cases)"], ["", "lemma mbody_functional:\n  assumes mb1: \"mbody(CT,m,C) = xs . e0\"\n  and     mb2: \"mbody(CT,m,C) = ys . d0\"\n  shows \"xs = ys \\<and> e0 = d0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys \\<and> e0 = d0", "using assms"], ["proof (prove)\nusing this:\n  mbody(CT,m,C) = xs . e0\n  mbody(CT,m,C) = ys . d0\n\ngoal (1 subgoal):\n 1. xs = ys \\<and> e0 = d0", "by induct (auto elim:mbody.cases)"], ["", "lemma fields_functional:\n  assumes \"fields(CT,C) = Cf\" \n  and \"CT OK\" \n  shows \"\\<And>Cf'. \\<lbrakk> fields(CT,C) = Cf'\\<rbrakk> \\<Longrightarrow> Cf = Cf'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Cf'. fields(CT,C) = Cf' \\<Longrightarrow> Cf = Cf'", "using assms"], ["proof (prove)\nusing this:\n  fields(CT,C) = Cf\n  CT OK\n\ngoal (1 subgoal):\n 1. \\<And>Cf'. fields(CT,C) = Cf' \\<Longrightarrow> Cf = Cf'", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>CT Cf'.\n       \\<lbrakk>fields(CT,Object) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> [] = Cf'\n 2. \\<And>CT C CDef D Cf Dg DgCf Cf'.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D; cFields CDef = Cf;\n        fields(CT,D) = Dg;\n        \\<And>Cf'.\n           \\<lbrakk>fields(CT,D) = Cf'; CT OK\\<rbrakk>\n           \\<Longrightarrow> Dg = Cf';\n        DgCf = Dg @ Cf; fields(CT,C) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> DgCf = Cf'", "case (f_obj CT)"], ["proof (state)\nthis:\n  fields(CT,Object) = Cf'\n  CT OK\n\ngoal (2 subgoals):\n 1. \\<And>CT Cf'.\n       \\<lbrakk>fields(CT,Object) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> [] = Cf'\n 2. \\<And>CT C CDef D Cf Dg DgCf Cf'.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D; cFields CDef = Cf;\n        fields(CT,D) = Dg;\n        \\<And>Cf'.\n           \\<lbrakk>fields(CT,D) = Cf'; CT OK\\<rbrakk>\n           \\<Longrightarrow> Dg = Cf';\n        DgCf = Dg @ Cf; fields(CT,C) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> DgCf = Cf'", "hence \"CT(Object) = None\""], ["proof (prove)\nusing this:\n  fields(CT,Object) = Cf'\n  CT OK\n\ngoal (1 subgoal):\n 1. CT Object = None", "by (auto elim: ct_typing.cases)"], ["proof (state)\nthis:\n  CT Object = None\n\ngoal (2 subgoals):\n 1. \\<And>CT Cf'.\n       \\<lbrakk>fields(CT,Object) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> [] = Cf'\n 2. \\<And>CT C CDef D Cf Dg DgCf Cf'.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D; cFields CDef = Cf;\n        fields(CT,D) = Dg;\n        \\<And>Cf'.\n           \\<lbrakk>fields(CT,D) = Cf'; CT OK\\<rbrakk>\n           \\<Longrightarrow> Dg = Cf';\n        DgCf = Dg @ Cf; fields(CT,C) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> DgCf = Cf'", "thus ?case"], ["proof (prove)\nusing this:\n  CT Object = None\n\ngoal (1 subgoal):\n 1. [] = Cf'", "using f_obj"], ["proof (prove)\nusing this:\n  CT Object = None\n  fields(CT,Object) = Cf'\n  CT OK\n\ngoal (1 subgoal):\n 1. [] = Cf'", "by (auto elim: fields.cases)"], ["proof (state)\nthis:\n  [] = Cf'\n\ngoal (1 subgoal):\n 1. \\<And>CT C CDef D Cf Dg DgCf Cf'.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D; cFields CDef = Cf;\n        fields(CT,D) = Dg;\n        \\<And>Cf'.\n           \\<lbrakk>fields(CT,D) = Cf'; CT OK\\<rbrakk>\n           \\<Longrightarrow> Dg = Cf';\n        DgCf = Dg @ Cf; fields(CT,C) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> DgCf = Cf'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>CT C CDef D Cf Dg DgCf Cf'.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D; cFields CDef = Cf;\n        fields(CT,D) = Dg;\n        \\<And>Cf'.\n           \\<lbrakk>fields(CT,D) = Cf'; CT OK\\<rbrakk>\n           \\<Longrightarrow> Dg = Cf';\n        DgCf = Dg @ Cf; fields(CT,C) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> DgCf = Cf'", "case (f_class CT C CDef D Cf Dg DgCf DgCf')"], ["proof (state)\nthis:\n  CT C = Some CDef\n  cSuper CDef = D\n  cFields CDef = Cf\n  fields(CT,D) = Dg\n  \\<lbrakk>fields(CT,D) = ?Cf'; CT OK\\<rbrakk> \\<Longrightarrow> Dg = ?Cf'\n  DgCf = Dg @ Cf\n  fields(CT,C) = DgCf'\n  CT OK\n\ngoal (1 subgoal):\n 1. \\<And>CT C CDef D Cf Dg DgCf Cf'.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D; cFields CDef = Cf;\n        fields(CT,D) = Dg;\n        \\<And>Cf'.\n           \\<lbrakk>fields(CT,D) = Cf'; CT OK\\<rbrakk>\n           \\<Longrightarrow> Dg = Cf';\n        DgCf = Dg @ Cf; fields(CT,C) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> DgCf = Cf'", "hence f_class_inv: \n    \"(CT C = Some CDef) \\<and> (cSuper CDef = D) \\<and> (cFields CDef = Cf)\" \n    and \"CT OK\""], ["proof (prove)\nusing this:\n  CT C = Some CDef\n  cSuper CDef = D\n  cFields CDef = Cf\n  fields(CT,D) = Dg\n  \\<lbrakk>fields(CT,D) = ?Cf'; CT OK\\<rbrakk> \\<Longrightarrow> Dg = ?Cf'\n  DgCf = Dg @ Cf\n  fields(CT,C) = DgCf'\n  CT OK\n\ngoal (1 subgoal):\n 1. CT C = Some CDef \\<and> cSuper CDef = D \\<and> cFields CDef = Cf &&&\n    CT OK", "by fastforce+"], ["proof (state)\nthis:\n  CT C = Some CDef \\<and> cSuper CDef = D \\<and> cFields CDef = Cf\n  CT OK\n\ngoal (1 subgoal):\n 1. \\<And>CT C CDef D Cf Dg DgCf Cf'.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D; cFields CDef = Cf;\n        fields(CT,D) = Dg;\n        \\<And>Cf'.\n           \\<lbrakk>fields(CT,D) = Cf'; CT OK\\<rbrakk>\n           \\<Longrightarrow> Dg = Cf';\n        DgCf = Dg @ Cf; fields(CT,C) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> DgCf = Cf'", "hence c_not_obj:\"C \\<noteq> Object\""], ["proof (prove)\nusing this:\n  CT C = Some CDef \\<and> cSuper CDef = D \\<and> cFields CDef = Cf\n  CT OK\n\ngoal (1 subgoal):\n 1. C \\<noteq> Object", "by (force elim:ct_typing.cases)"], ["proof (state)\nthis:\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. \\<And>CT C CDef D Cf Dg DgCf Cf'.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D; cFields CDef = Cf;\n        fields(CT,D) = Dg;\n        \\<And>Cf'.\n           \\<lbrakk>fields(CT,D) = Cf'; CT OK\\<rbrakk>\n           \\<Longrightarrow> Dg = Cf';\n        DgCf = Dg @ Cf; fields(CT,C) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> DgCf = Cf'", "from f_class"], ["proof (chain)\npicking this:\n  CT C = Some CDef\n  cSuper CDef = D\n  cFields CDef = Cf\n  fields(CT,D) = Dg\n  \\<lbrakk>fields(CT,D) = ?Cf'; CT OK\\<rbrakk> \\<Longrightarrow> Dg = ?Cf'\n  DgCf = Dg @ Cf\n  fields(CT,C) = DgCf'\n  CT OK", "have flds:\"fields(CT,C) = DgCf'\""], ["proof (prove)\nusing this:\n  CT C = Some CDef\n  cSuper CDef = D\n  cFields CDef = Cf\n  fields(CT,D) = Dg\n  \\<lbrakk>fields(CT,D) = ?Cf'; CT OK\\<rbrakk> \\<Longrightarrow> Dg = ?Cf'\n  DgCf = Dg @ Cf\n  fields(CT,C) = DgCf'\n  CT OK\n\ngoal (1 subgoal):\n 1. fields(CT,C) = DgCf'", "by fastforce"], ["proof (state)\nthis:\n  fields(CT,C) = DgCf'\n\ngoal (1 subgoal):\n 1. \\<And>CT C CDef D Cf Dg DgCf Cf'.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D; cFields CDef = Cf;\n        fields(CT,D) = Dg;\n        \\<And>Cf'.\n           \\<lbrakk>fields(CT,D) = Cf'; CT OK\\<rbrakk>\n           \\<Longrightarrow> Dg = Cf';\n        DgCf = Dg @ Cf; fields(CT,C) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> DgCf = Cf'", "then"], ["proof (chain)\npicking this:\n  fields(CT,C) = DgCf'", "obtain Dg' where \n    \"fields(CT,D) = Dg'\"\n    and \"DgCf' = Dg' @ Cf\""], ["proof (prove)\nusing this:\n  fields(CT,C) = DgCf'\n\ngoal (1 subgoal):\n 1. (\\<And>Dg'.\n        \\<lbrakk>fields(CT,D) = Dg'; DgCf' = Dg' @ Cf\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using f_class_inv c_not_obj"], ["proof (prove)\nusing this:\n  fields(CT,C) = DgCf'\n  CT C = Some CDef \\<and> cSuper CDef = D \\<and> cFields CDef = Cf\n  C \\<noteq> Object\n\ngoal (1 subgoal):\n 1. (\\<And>Dg'.\n        \\<lbrakk>fields(CT,D) = Dg'; DgCf' = Dg' @ Cf\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim:fields.cases)"], ["proof (state)\nthis:\n  fields(CT,D) = Dg'\n  DgCf' = Dg' @ Cf\n\ngoal (1 subgoal):\n 1. \\<And>CT C CDef D Cf Dg DgCf Cf'.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D; cFields CDef = Cf;\n        fields(CT,D) = Dg;\n        \\<And>Cf'.\n           \\<lbrakk>fields(CT,D) = Cf'; CT OK\\<rbrakk>\n           \\<Longrightarrow> Dg = Cf';\n        DgCf = Dg @ Cf; fields(CT,C) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> DgCf = Cf'", "hence \"Dg' = Dg\""], ["proof (prove)\nusing this:\n  fields(CT,D) = Dg'\n  DgCf' = Dg' @ Cf\n\ngoal (1 subgoal):\n 1. Dg' = Dg", "using f_class"], ["proof (prove)\nusing this:\n  fields(CT,D) = Dg'\n  DgCf' = Dg' @ Cf\n  CT C = Some CDef\n  cSuper CDef = D\n  cFields CDef = Cf\n  fields(CT,D) = Dg\n  \\<lbrakk>fields(CT,D) = ?Cf'; CT OK\\<rbrakk> \\<Longrightarrow> Dg = ?Cf'\n  DgCf = Dg @ Cf\n  fields(CT,C) = DgCf'\n  CT OK\n\ngoal (1 subgoal):\n 1. Dg' = Dg", "by auto"], ["proof (state)\nthis:\n  Dg' = Dg\n\ngoal (1 subgoal):\n 1. \\<And>CT C CDef D Cf Dg DgCf Cf'.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D; cFields CDef = Cf;\n        fields(CT,D) = Dg;\n        \\<And>Cf'.\n           \\<lbrakk>fields(CT,D) = Cf'; CT OK\\<rbrakk>\n           \\<Longrightarrow> Dg = Cf';\n        DgCf = Dg @ Cf; fields(CT,C) = Cf'; CT OK\\<rbrakk>\n       \\<Longrightarrow> DgCf = Cf'", "thus ?case"], ["proof (prove)\nusing this:\n  Dg' = Dg\n\ngoal (1 subgoal):\n 1. DgCf = DgCf'", "using \\<open>DgCf = Dg @ Cf\\<close> and \\<open>DgCf' = Dg' @ Cf\\<close>"], ["proof (prove)\nusing this:\n  Dg' = Dg\n  DgCf = Dg @ Cf\n  DgCf' = Dg' @ Cf\n\ngoal (1 subgoal):\n 1. DgCf = DgCf'", "by force"], ["proof (state)\nthis:\n  DgCf = DgCf'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Subtyping and Typing\\<close>"], ["", "lemma typings_lengths: assumes \"CT;\\<Gamma> \\<turnstile>+ es:Cs\" shows \"length es = length Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length es = length Cs", "using assms"], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile>+ es : Cs\n\ngoal (1 subgoal):\n 1. length es = length Cs", "by(induct \"es\" \"Cs\") (auto elim:typings.cases)"], ["", "lemma typings_index:\n  assumes \"CT;\\<Gamma> \\<turnstile>+ es:Cs\" \n  shows \"\\<And>i. \\<lbrakk> i < length es \\<rbrakk> \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> (es!i) : (Cs!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length es \\<Longrightarrow>\n       CT;\\<Gamma> \\<turnstile> es ! i : Cs ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length es \\<Longrightarrow>\n       CT;\\<Gamma> \\<turnstile> es ! i : Cs ! i", "have \"length es = length Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length es = length Cs", "using assms"], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile>+ es : Cs\n\ngoal (1 subgoal):\n 1. length es = length Cs", "by (auto simp: typings_lengths)"], ["proof (state)\nthis:\n  length es = length Cs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length es \\<Longrightarrow>\n       CT;\\<Gamma> \\<turnstile> es ! i : Cs ! i", "thus \"\\<And>i. \\<lbrakk> i < length es \\<rbrakk> \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> (es!i) : (Cs!i)\""], ["proof (prove)\nusing this:\n  length es = length Cs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length es \\<Longrightarrow>\n       CT;\\<Gamma> \\<turnstile> es ! i : Cs ! i", "using assms"], ["proof (prove)\nusing this:\n  length es = length Cs\n  CT;\\<Gamma> \\<turnstile>+ es : Cs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length es \\<Longrightarrow>\n       CT;\\<Gamma> \\<turnstile> es ! i : Cs ! i", "proof(induct es Cs rule:list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length []; CT;\\<Gamma> \\<turnstile>+ [] : []\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> [] ! i : [] ! i\n 2. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<And>i.\n           \\<lbrakk>i < length xs;\n            CT;\\<Gamma> \\<turnstile>+ xs : ys\\<rbrakk>\n           \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> xs ! i : ys ! i;\n        i < length (x # xs);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys)\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> (x # xs) !\n            i : (y # ys) ! i", "case Nil"], ["proof (state)\nthis:\n  i < length []\n  CT;\\<Gamma> \\<turnstile>+ [] : []\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length []; CT;\\<Gamma> \\<turnstile>+ [] : []\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> [] ! i : [] ! i\n 2. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<And>i.\n           \\<lbrakk>i < length xs;\n            CT;\\<Gamma> \\<turnstile>+ xs : ys\\<rbrakk>\n           \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> xs ! i : ys ! i;\n        i < length (x # xs);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys)\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> (x # xs) !\n            i : (y # ys) ! i", "thus ?case"], ["proof (prove)\nusing this:\n  i < length []\n  CT;\\<Gamma> \\<turnstile>+ [] : []\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile> [] ! i : [] ! i", "by auto"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile> [] ! i : [] ! i\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<And>i.\n           \\<lbrakk>i < length xs;\n            CT;\\<Gamma> \\<turnstile>+ xs : ys\\<rbrakk>\n           \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> xs ! i : ys ! i;\n        i < length (x # xs);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys)\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> (x # xs) !\n            i : (y # ys) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<And>i.\n           \\<lbrakk>i < length xs;\n            CT;\\<Gamma> \\<turnstile>+ xs : ys\\<rbrakk>\n           \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> xs ! i : ys ! i;\n        i < length (x # xs);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys)\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> (x # xs) !\n            i : (y # ys) ! i", "case (Cons esh est hCs tCs i)"], ["proof (state)\nthis:\n  length est = length tCs\n  \\<lbrakk>?i < length est; CT;\\<Gamma> \\<turnstile>+ est : tCs\\<rbrakk>\n  \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> est ! ?i : tCs ! ?i\n  i < length (esh # est)\n  CT;\\<Gamma> \\<turnstile>+ (esh # est) : (hCs # tCs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys i.\n       \\<lbrakk>length xs = length ys;\n        \\<And>i.\n           \\<lbrakk>i < length xs;\n            CT;\\<Gamma> \\<turnstile>+ xs : ys\\<rbrakk>\n           \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> xs ! i : ys ! i;\n        i < length (x # xs);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys)\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> (x # xs) !\n            i : (y # ys) ! i", "thus ?case"], ["proof (prove)\nusing this:\n  length est = length tCs\n  \\<lbrakk>?i < length est; CT;\\<Gamma> \\<turnstile>+ est : tCs\\<rbrakk>\n  \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> est ! ?i : tCs ! ?i\n  i < length (esh # est)\n  CT;\\<Gamma> \\<turnstile>+ (esh # est) : (hCs # tCs)\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile> (esh # est) ! i : (hCs # tCs) ! i", "by(cases i) (auto elim:typings.cases)"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile> (esh # est) ! i : (hCs # tCs) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length es \\<Longrightarrow>\n  CT;\\<Gamma> \\<turnstile> es ! ?i : Cs ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subtypings_index:\n  assumes \"CT \\<turnstile>+ Cs <: Ds\"\n  shows \"\\<And>i. \\<lbrakk> i < length Cs \\<rbrakk> \\<Longrightarrow> CT \\<turnstile> (Cs!i) <: (Ds!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length Cs \\<Longrightarrow> CT \\<turnstile> Cs ! i <: Ds ! i", "using assms"], ["proof (prove)\nusing this:\n  CT \\<turnstile>+ Cs <: Ds\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length Cs \\<Longrightarrow> CT \\<turnstile> Cs ! i <: Ds ! i", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>CT i.\n       i < length [] \\<Longrightarrow> CT \\<turnstile> [] ! i <: [] ! i\n 2. \\<And>CT C0 D0 Cs Ds i.\n       \\<lbrakk>CT \\<turnstile> C0 <: D0; CT \\<turnstile>+ Cs <: Ds;\n        \\<And>i.\n           i < length Cs \\<Longrightarrow> CT \\<turnstile> Cs ! i <: Ds ! i;\n        i < length (C0 # Cs)\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> (C0 # Cs) ! i <: (D0 # Ds) ! i", "case ss_nil"], ["proof (state)\nthis:\n  i < length []\n\ngoal (2 subgoals):\n 1. \\<And>CT i.\n       i < length [] \\<Longrightarrow> CT \\<turnstile> [] ! i <: [] ! i\n 2. \\<And>CT C0 D0 Cs Ds i.\n       \\<lbrakk>CT \\<turnstile> C0 <: D0; CT \\<turnstile>+ Cs <: Ds;\n        \\<And>i.\n           i < length Cs \\<Longrightarrow> CT \\<turnstile> Cs ! i <: Ds ! i;\n        i < length (C0 # Cs)\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> (C0 # Cs) ! i <: (D0 # Ds) ! i", "thus ?case"], ["proof (prove)\nusing this:\n  i < length []\n\ngoal (1 subgoal):\n 1. CT_ \\<turnstile> [] ! i <: [] ! i", "by auto"], ["proof (state)\nthis:\n  CT_ \\<turnstile> [] ! i <: [] ! i\n\ngoal (1 subgoal):\n 1. \\<And>CT C0 D0 Cs Ds i.\n       \\<lbrakk>CT \\<turnstile> C0 <: D0; CT \\<turnstile>+ Cs <: Ds;\n        \\<And>i.\n           i < length Cs \\<Longrightarrow> CT \\<turnstile> Cs ! i <: Ds ! i;\n        i < length (C0 # Cs)\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> (C0 # Cs) ! i <: (D0 # Ds) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>CT C0 D0 Cs Ds i.\n       \\<lbrakk>CT \\<turnstile> C0 <: D0; CT \\<turnstile>+ Cs <: Ds;\n        \\<And>i.\n           i < length Cs \\<Longrightarrow> CT \\<turnstile> Cs ! i <: Ds ! i;\n        i < length (C0 # Cs)\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> (C0 # Cs) ! i <: (D0 # Ds) ! i", "case (ss_cons hCs CT tCs hDs tDs i)"], ["proof (state)\nthis:\n  hCs \\<turnstile> CT <: tCs\n  hCs \\<turnstile>+ hDs <: tDs\n  ?i < length hDs \\<Longrightarrow> hCs \\<turnstile> hDs ! ?i <: tDs ! ?i\n  i < length (CT # hDs)\n\ngoal (1 subgoal):\n 1. \\<And>CT C0 D0 Cs Ds i.\n       \\<lbrakk>CT \\<turnstile> C0 <: D0; CT \\<turnstile>+ Cs <: Ds;\n        \\<And>i.\n           i < length Cs \\<Longrightarrow> CT \\<turnstile> Cs ! i <: Ds ! i;\n        i < length (C0 # Cs)\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> (C0 # Cs) ! i <: (D0 # Ds) ! i", "thus ?case"], ["proof (prove)\nusing this:\n  hCs \\<turnstile> CT <: tCs\n  hCs \\<turnstile>+ hDs <: tDs\n  ?i < length hDs \\<Longrightarrow> hCs \\<turnstile> hDs ! ?i <: tDs ! ?i\n  i < length (CT # hDs)\n\ngoal (1 subgoal):\n 1. hCs \\<turnstile> (CT # hDs) ! i <: (tCs # tDs) ! i", "by(cases \"i\", auto)"], ["proof (state)\nthis:\n  hCs \\<turnstile> (CT # hDs) ! i <: (tCs # tDs) ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subtyping_append:\n  assumes \"CT \\<turnstile>+ Cs <: Ds\"\n  and \"CT \\<turnstile> C <: D\"\n  shows \"CT \\<turnstile>+ (Cs@[C]) <: (Ds@[D])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CT \\<turnstile>+ (Cs @ [C]) <: (Ds @ [D])", "using assms"], ["proof (prove)\nusing this:\n  CT \\<turnstile>+ Cs <: Ds\n  CT \\<turnstile> C <: D\n\ngoal (1 subgoal):\n 1. CT \\<turnstile>+ (Cs @ [C]) <: (Ds @ [D])", "by (induct rule:subtypings.induct) (auto simp add:subtypings.intros elim:subtypings.cases)"], ["", "lemma typings_append: \n  assumes \"CT;\\<Gamma> \\<turnstile>+ es : Cs\"\n  and \"CT;\\<Gamma> \\<turnstile> e : C\"\n  shows \"CT;\\<Gamma> \\<turnstile>+ (es@[e]) : (Cs@[C])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile>+ (es @ [e]) : (Cs @ [C])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile>+ (es @ [e]) : (Cs @ [C])", "have \"length es = length Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length es = length Cs", "using assms"], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile>+ es : Cs\n  CT;\\<Gamma> \\<turnstile> e : C\n\ngoal (1 subgoal):\n 1. length es = length Cs", "by(simp_all add:typings_lengths)"], ["proof (state)\nthis:\n  length es = length Cs\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile>+ (es @ [e]) : (Cs @ [C])", "thus \"CT;\\<Gamma> \\<turnstile>+ (es@[e]) : (Cs@[C])\""], ["proof (prove)\nusing this:\n  length es = length Cs\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile>+ (es @ [e]) : (Cs @ [C])", "using assms"], ["proof (prove)\nusing this:\n  length es = length Cs\n  CT;\\<Gamma> \\<turnstile>+ es : Cs\n  CT;\\<Gamma> \\<turnstile> e : C\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile>+ (es @ [e]) : (Cs @ [C])", "proof(induct \"es\" \"Cs\" rule:list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ [] : [];\n     CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n    \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ([] @ [e]) : ([] @ [C])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n         CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n        \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C]);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys);\n        CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ((x # xs) @\n              [e]) : ((y # ys) @ [C])", "have \"CT;\\<Gamma> \\<turnstile>+ []:[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile>+ [] : []", "by(simp add:typings_typing.ts_nil)"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ [] : []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ [] : [];\n     CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n    \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ([] @ [e]) : ([] @ [C])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n         CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n        \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C]);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys);\n        CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ((x # xs) @\n              [e]) : ((y # ys) @ [C])", "moreover"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ [] : []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ [] : [];\n     CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n    \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ([] @ [e]) : ([] @ [C])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n         CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n        \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C]);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys);\n        CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ((x # xs) @\n              [e]) : ((y # ys) @ [C])", "from assms"], ["proof (chain)\npicking this:\n  CT;\\<Gamma> \\<turnstile>+ es : Cs\n  CT;\\<Gamma> \\<turnstile> e : C", "have \"CT;\\<Gamma> \\<turnstile> e : C\""], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile>+ es : Cs\n  CT;\\<Gamma> \\<turnstile> e : C\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile> e : C", "by simp"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile> e : C\n\ngoal (2 subgoals):\n 1. \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ [] : [];\n     CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n    \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ([] @ [e]) : ([] @ [C])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n         CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n        \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C]);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys);\n        CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ((x # xs) @\n              [e]) : ((y # ys) @ [C])", "ultimately"], ["proof (chain)\npicking this:\n  CT;\\<Gamma> \\<turnstile>+ [] : []\n  CT;\\<Gamma> \\<turnstile> e : C", "show \"CT;\\<Gamma> \\<turnstile>+ ([]@[e]) : ([]@[C])\""], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile>+ [] : []\n  CT;\\<Gamma> \\<turnstile> e : C\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile>+ ([] @ [e]) : ([] @ [C])", "by (auto simp add:typings_typing.ts_cons)"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ ([] @ [e]) : ([] @ [C])\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n         CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n        \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C]);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys);\n        CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ((x # xs) @\n              [e]) : ((y # ys) @ [C])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n         CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n        \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C]);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys);\n        CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ((x # xs) @\n              [e]) : ((y # ys) @ [C])", "fix x xs y ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n         CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n        \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C]);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys);\n        CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ((x # xs) @\n              [e]) : ((y # ys) @ [C])", "assume \"length xs = length ys\" \n      and IH: \"\\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys; CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk> \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C])\"\n      and x_xs_typs: \"CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys)\"\n      and e_typ: \"CT;\\<Gamma> \\<turnstile> e : C\""], ["proof (state)\nthis:\n  length xs = length ys\n  \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n   CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n  \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C])\n  CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys)\n  CT;\\<Gamma> \\<turnstile> e : C\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n         CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n        \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C]);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys);\n        CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ((x # xs) @\n              [e]) : ((y # ys) @ [C])", "from x_xs_typs"], ["proof (chain)\npicking this:\n  CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys)", "have x_typ: \"CT;\\<Gamma> \\<turnstile> x : y\" and \"CT;\\<Gamma> \\<turnstile>+ xs : ys\""], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys)\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile> x : y &&& CT;\\<Gamma> \\<turnstile>+ xs : ys", "by(auto elim:typings.cases)"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile> x : y\n  CT;\\<Gamma> \\<turnstile>+ xs : ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n         CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n        \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C]);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys);\n        CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ((x # xs) @\n              [e]) : ((y # ys) @ [C])", "with IH e_typ"], ["proof (chain)\npicking this:\n  \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n   CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n  \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C])\n  CT;\\<Gamma> \\<turnstile> e : C\n  CT;\\<Gamma> \\<turnstile> x : y\n  CT;\\<Gamma> \\<turnstile>+ xs : ys", "have \"CT;\\<Gamma> \\<turnstile>+ (xs@[e]) : (ys@[C])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n   CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n  \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C])\n  CT;\\<Gamma> \\<turnstile> e : C\n  CT;\\<Gamma> \\<turnstile> x : y\n  CT;\\<Gamma> \\<turnstile>+ xs : ys\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C])", "by simp"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C])\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n         CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n        \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C]);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys);\n        CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ((x # xs) @\n              [e]) : ((y # ys) @ [C])", "with x_typ"], ["proof (chain)\npicking this:\n  CT;\\<Gamma> \\<turnstile> x : y\n  CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C])", "have \"CT;\\<Gamma> \\<turnstile>+ ((x#xs)@[e]) : ((y#ys)@[C])\""], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile> x : y\n  CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C])\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile>+ ((x # xs) @ [e]) : ((y # ys) @ [C])", "by (auto simp add:typings_typing.ts_cons)"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ ((x # xs) @ [e]) : ((y # ys) @ [C])\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ xs : ys;\n         CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n        \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ (xs @ [e]) : (ys @ [C]);\n        CT;\\<Gamma> \\<turnstile>+ (x # xs) : (y # ys);\n        CT;\\<Gamma> \\<turnstile> e : C\\<rbrakk>\n       \\<Longrightarrow> CT;\\<Gamma> \\<turnstile>+ ((x # xs) @\n              [e]) : ((y # ys) @ [C])", "thus \"CT;\\<Gamma> \\<turnstile>+ ((x # xs) @ [e]) : ((y # ys) @ [C])\""], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile>+ ((x # xs) @ [e]) : ((y # ys) @ [C])\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile>+ ((x # xs) @ [e]) : ((y # ys) @ [C])", "by(auto simp add:typings_typing.ts_cons)"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ ((x # xs) @ [e]) : ((y # ys) @ [C])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ (es @ [e]) : (Cs @ [C])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ith_typing: \"\\<And>Cs. \\<lbrakk> CT;\\<Gamma> \\<turnstile>+ (es@(h#t)) : Cs \\<rbrakk> \\<Longrightarrow> CT;\\<Gamma> \\<turnstile> h : (Cs!(length es))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Cs.\n       CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs \\<Longrightarrow>\n       CT;\\<Gamma> \\<turnstile> h : Cs ! length es", "proof(induct \"es\", auto elim:typings.cases)"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "lemma ith_subtyping: \"\\<And>Ds. \\<lbrakk> CT \\<turnstile>+ (Cs@(h#t)) <: Ds \\<rbrakk> \\<Longrightarrow> CT \\<turnstile> h <: (Ds!(length Cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ds.\n       CT \\<turnstile>+ (Cs @ h # t) <: Ds \\<Longrightarrow>\n       CT \\<turnstile> h <: Ds ! length Cs", "proof(induct \"Cs\", auto elim:subtypings.cases)"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "lemma subtypings_refl: \"CT \\<turnstile>+ Cs <: Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CT \\<turnstile>+ Cs <: Cs", "by(induct \"Cs\", auto simp add: subtyping.s_refl subtypings.intros)"], ["", "lemma subtypings_trans: \"\\<And>Ds Es. \\<lbrakk> CT \\<turnstile>+ Cs <: Ds;  CT \\<turnstile>+ Ds <: Es \\<rbrakk> \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ds Es.\n       \\<lbrakk>CT \\<turnstile>+ Cs <: Ds;\n        CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es", "proof(induct \"Cs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ds Es.\n       \\<lbrakk>CT \\<turnstile>+ [] <: Ds;\n        CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ [] <: Es\n 2. \\<And>a Cs Ds Es.\n       \\<lbrakk>\\<And>Ds Es.\n                   \\<lbrakk>CT \\<turnstile>+ Cs <: Ds;\n                    CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n                   \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es;\n        CT \\<turnstile>+ (a # Cs) <: Ds; CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ (a # Cs) <: Es", "case Nil"], ["proof (state)\nthis:\n  CT \\<turnstile>+ [] <: Ds\n  CT \\<turnstile>+ Ds <: Es\n\ngoal (2 subgoals):\n 1. \\<And>Ds Es.\n       \\<lbrakk>CT \\<turnstile>+ [] <: Ds;\n        CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ [] <: Es\n 2. \\<And>a Cs Ds Es.\n       \\<lbrakk>\\<And>Ds Es.\n                   \\<lbrakk>CT \\<turnstile>+ Cs <: Ds;\n                    CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n                   \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es;\n        CT \\<turnstile>+ (a # Cs) <: Ds; CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ (a # Cs) <: Es", "thus ?case"], ["proof (prove)\nusing this:\n  CT \\<turnstile>+ [] <: Ds\n  CT \\<turnstile>+ Ds <: Es\n\ngoal (1 subgoal):\n 1. CT \\<turnstile>+ [] <: Es", "by (auto elim:subtypings.cases simp add:subtypings.ss_nil)"], ["proof (state)\nthis:\n  CT \\<turnstile>+ [] <: Es\n\ngoal (1 subgoal):\n 1. \\<And>a Cs Ds Es.\n       \\<lbrakk>\\<And>Ds Es.\n                   \\<lbrakk>CT \\<turnstile>+ Cs <: Ds;\n                    CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n                   \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es;\n        CT \\<turnstile>+ (a # Cs) <: Ds; CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ (a # Cs) <: Es", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Cs Ds Es.\n       \\<lbrakk>\\<And>Ds Es.\n                   \\<lbrakk>CT \\<turnstile>+ Cs <: Ds;\n                    CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n                   \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es;\n        CT \\<turnstile>+ (a # Cs) <: Ds; CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ (a # Cs) <: Es", "case (Cons hCs tCs)"], ["proof (state)\nthis:\n  \\<lbrakk>CT \\<turnstile>+ tCs <: ?Ds; CT \\<turnstile>+ ?Ds <: ?Es\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile>+ tCs <: ?Es\n  CT \\<turnstile>+ (hCs # tCs) <: Ds\n  CT \\<turnstile>+ Ds <: Es\n\ngoal (1 subgoal):\n 1. \\<And>a Cs Ds Es.\n       \\<lbrakk>\\<And>Ds Es.\n                   \\<lbrakk>CT \\<turnstile>+ Cs <: Ds;\n                    CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n                   \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es;\n        CT \\<turnstile>+ (a # Cs) <: Ds; CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ (a # Cs) <: Es", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>CT \\<turnstile>+ tCs <: ?Ds; CT \\<turnstile>+ ?Ds <: ?Es\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile>+ tCs <: ?Es\n  CT \\<turnstile>+ (hCs # tCs) <: Ds\n  CT \\<turnstile>+ Ds <: Es", "obtain hDs tDs\n    where h1:\"CT \\<turnstile> hCs <: hDs\" and t1:\"CT \\<turnstile>+ tCs <: tDs\" and \"Ds = hDs#tDs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>CT \\<turnstile>+ tCs <: ?Ds; CT \\<turnstile>+ ?Ds <: ?Es\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile>+ tCs <: ?Es\n  CT \\<turnstile>+ (hCs # tCs) <: Ds\n  CT \\<turnstile>+ Ds <: Es\n\ngoal (1 subgoal):\n 1. (\\<And>hDs tDs.\n        \\<lbrakk>CT \\<turnstile> hCs <: hDs; CT \\<turnstile>+ tCs <: tDs;\n         Ds = hDs # tDs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim:subtypings.cases)"], ["proof (state)\nthis:\n  CT \\<turnstile> hCs <: hDs\n  CT \\<turnstile>+ tCs <: tDs\n  Ds = hDs # tDs\n\ngoal (1 subgoal):\n 1. \\<And>a Cs Ds Es.\n       \\<lbrakk>\\<And>Ds Es.\n                   \\<lbrakk>CT \\<turnstile>+ Cs <: Ds;\n                    CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n                   \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es;\n        CT \\<turnstile>+ (a # Cs) <: Ds; CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ (a # Cs) <: Es", "then"], ["proof (chain)\npicking this:\n  CT \\<turnstile> hCs <: hDs\n  CT \\<turnstile>+ tCs <: tDs\n  Ds = hDs # tDs", "obtain hEs tEs\n    where h2:\"CT \\<turnstile> hDs <: hEs\" and t2:\"CT \\<turnstile>+ tDs <: tEs\" and \"Es = hEs#tEs\""], ["proof (prove)\nusing this:\n  CT \\<turnstile> hCs <: hDs\n  CT \\<turnstile>+ tCs <: tDs\n  Ds = hDs # tDs\n\ngoal (1 subgoal):\n 1. (\\<And>hEs tEs.\n        \\<lbrakk>CT \\<turnstile> hDs <: hEs; CT \\<turnstile>+ tDs <: tEs;\n         Es = hEs # tEs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons"], ["proof (prove)\nusing this:\n  CT \\<turnstile> hCs <: hDs\n  CT \\<turnstile>+ tCs <: tDs\n  Ds = hDs # tDs\n  \\<lbrakk>CT \\<turnstile>+ tCs <: ?Ds; CT \\<turnstile>+ ?Ds <: ?Es\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile>+ tCs <: ?Es\n  CT \\<turnstile>+ (hCs # tCs) <: Ds\n  CT \\<turnstile>+ Ds <: Es\n\ngoal (1 subgoal):\n 1. (\\<And>hEs tEs.\n        \\<lbrakk>CT \\<turnstile> hDs <: hEs; CT \\<turnstile>+ tDs <: tEs;\n         Es = hEs # tEs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim:subtypings.cases)"], ["proof (state)\nthis:\n  CT \\<turnstile> hDs <: hEs\n  CT \\<turnstile>+ tDs <: tEs\n  Es = hEs # tEs\n\ngoal (1 subgoal):\n 1. \\<And>a Cs Ds Es.\n       \\<lbrakk>\\<And>Ds Es.\n                   \\<lbrakk>CT \\<turnstile>+ Cs <: Ds;\n                    CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n                   \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es;\n        CT \\<turnstile>+ (a # Cs) <: Ds; CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ (a # Cs) <: Es", "moreover"], ["proof (state)\nthis:\n  CT \\<turnstile> hDs <: hEs\n  CT \\<turnstile>+ tDs <: tEs\n  Es = hEs # tEs\n\ngoal (1 subgoal):\n 1. \\<And>a Cs Ds Es.\n       \\<lbrakk>\\<And>Ds Es.\n                   \\<lbrakk>CT \\<turnstile>+ Cs <: Ds;\n                    CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n                   \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es;\n        CT \\<turnstile>+ (a # Cs) <: Ds; CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ (a # Cs) <: Es", "from subtyping.s_trans[OF h1 h2]"], ["proof (chain)\npicking this:\n  CT \\<turnstile> hCs <: hEs", "have \"CT \\<turnstile> hCs <: hEs\""], ["proof (prove)\nusing this:\n  CT \\<turnstile> hCs <: hEs\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> hCs <: hEs", "by fastforce"], ["proof (state)\nthis:\n  CT \\<turnstile> hCs <: hEs\n\ngoal (1 subgoal):\n 1. \\<And>a Cs Ds Es.\n       \\<lbrakk>\\<And>Ds Es.\n                   \\<lbrakk>CT \\<turnstile>+ Cs <: Ds;\n                    CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n                   \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es;\n        CT \\<turnstile>+ (a # Cs) <: Ds; CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ (a # Cs) <: Es", "moreover"], ["proof (state)\nthis:\n  CT \\<turnstile> hCs <: hEs\n\ngoal (1 subgoal):\n 1. \\<And>a Cs Ds Es.\n       \\<lbrakk>\\<And>Ds Es.\n                   \\<lbrakk>CT \\<turnstile>+ Cs <: Ds;\n                    CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n                   \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es;\n        CT \\<turnstile>+ (a # Cs) <: Ds; CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ (a # Cs) <: Es", "with t1 t2"], ["proof (chain)\npicking this:\n  CT \\<turnstile>+ tCs <: tDs\n  CT \\<turnstile>+ tDs <: tEs\n  CT \\<turnstile> hCs <: hEs", "have \"CT \\<turnstile>+ tCs <: tEs\""], ["proof (prove)\nusing this:\n  CT \\<turnstile>+ tCs <: tDs\n  CT \\<turnstile>+ tDs <: tEs\n  CT \\<turnstile> hCs <: hEs\n\ngoal (1 subgoal):\n 1. CT \\<turnstile>+ tCs <: tEs", "using Cons"], ["proof (prove)\nusing this:\n  CT \\<turnstile>+ tCs <: tDs\n  CT \\<turnstile>+ tDs <: tEs\n  CT \\<turnstile> hCs <: hEs\n  \\<lbrakk>CT \\<turnstile>+ tCs <: ?Ds; CT \\<turnstile>+ ?Ds <: ?Es\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile>+ tCs <: ?Es\n  CT \\<turnstile>+ (hCs # tCs) <: Ds\n  CT \\<turnstile>+ Ds <: Es\n\ngoal (1 subgoal):\n 1. CT \\<turnstile>+ tCs <: tEs", "by simp_all"], ["proof (state)\nthis:\n  CT \\<turnstile>+ tCs <: tEs\n\ngoal (1 subgoal):\n 1. \\<And>a Cs Ds Es.\n       \\<lbrakk>\\<And>Ds Es.\n                   \\<lbrakk>CT \\<turnstile>+ Cs <: Ds;\n                    CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n                   \\<Longrightarrow> CT \\<turnstile>+ Cs <: Es;\n        CT \\<turnstile>+ (a # Cs) <: Ds; CT \\<turnstile>+ Ds <: Es\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile>+ (a # Cs) <: Es", "ultimately"], ["proof (chain)\npicking this:\n  CT \\<turnstile> hDs <: hEs\n  CT \\<turnstile>+ tDs <: tEs\n  Es = hEs # tEs\n  CT \\<turnstile> hCs <: hEs\n  CT \\<turnstile>+ tCs <: tEs", "show ?case"], ["proof (prove)\nusing this:\n  CT \\<turnstile> hDs <: hEs\n  CT \\<turnstile>+ tDs <: tEs\n  Es = hEs # tEs\n  CT \\<turnstile> hCs <: hEs\n  CT \\<turnstile>+ tCs <: tEs\n\ngoal (1 subgoal):\n 1. CT \\<turnstile>+ (hCs # tCs) <: Es", "by (auto simp add:subtypings.intros)"], ["proof (state)\nthis:\n  CT \\<turnstile>+ (hCs # tCs) <: Es\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ith_typing_sub: \n  \"\\<And>Cs. \\<lbrakk> CT;\\<Gamma> \\<turnstile>+ (es@(h#t)) : Cs; \n     CT;\\<Gamma> \\<turnstile> h' : Ci'; \n     CT \\<turnstile> Ci' <: (Cs!(length es)) \\<rbrakk>\n  \\<Longrightarrow> \\<exists>Cs'. (CT;\\<Gamma> \\<turnstile>+ (es@(h'#t)) : Cs' \\<and> CT \\<turnstile>+ Cs' <: Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ (es @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "proof(induct es)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ([] @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs\n 2. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "case Nil"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs\n  CT;\\<Gamma> \\<turnstile> h' : Ci'\n  CT \\<turnstile> Ci' <: Cs ! length []\n\ngoal (2 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ([] @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs\n 2. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "then"], ["proof (chain)\npicking this:\n  CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs\n  CT;\\<Gamma> \\<turnstile> h' : Ci'\n  CT \\<turnstile> Ci' <: Cs ! length []", "obtain hCs tCs \n   where ts: \"CT;\\<Gamma> \\<turnstile>+ t : tCs\"\n   and Cs_def: \"Cs = hCs # tCs\""], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs\n  CT;\\<Gamma> \\<turnstile> h' : Ci'\n  CT \\<turnstile> Ci' <: Cs ! length []\n\ngoal (1 subgoal):\n 1. (\\<And>tCs hCs.\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ t : tCs; Cs = hCs # tCs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:typings.cases)"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ t : tCs\n  Cs = hCs # tCs\n\ngoal (2 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ([] @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs\n 2. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "from Cs_def Nil"], ["proof (chain)\npicking this:\n  Cs = hCs # tCs\n  CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs\n  CT;\\<Gamma> \\<turnstile> h' : Ci'\n  CT \\<turnstile> Ci' <: Cs ! length []", "have \"CT \\<turnstile> Ci' <: hCs\""], ["proof (prove)\nusing this:\n  Cs = hCs # tCs\n  CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs\n  CT;\\<Gamma> \\<turnstile> h' : Ci'\n  CT \\<turnstile> Ci' <: Cs ! length []\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> Ci' <: hCs", "by auto"], ["proof (state)\nthis:\n  CT \\<turnstile> Ci' <: hCs\n\ngoal (2 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ([] @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs\n 2. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "with Cs_def"], ["proof (chain)\npicking this:\n  Cs = hCs # tCs\n  CT \\<turnstile> Ci' <: hCs", "have \"CT \\<turnstile>+ (Ci'#tCs) <: Cs\""], ["proof (prove)\nusing this:\n  Cs = hCs # tCs\n  CT \\<turnstile> Ci' <: hCs\n\ngoal (1 subgoal):\n 1. CT \\<turnstile>+ (Ci' # tCs) <: Cs", "by(auto simp add:subtypings.ss_cons subtypings_refl)"], ["proof (state)\nthis:\n  CT \\<turnstile>+ (Ci' # tCs) <: Cs\n\ngoal (2 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ([] @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs\n 2. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "moreover"], ["proof (state)\nthis:\n  CT \\<turnstile>+ (Ci' # tCs) <: Cs\n\ngoal (2 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ([] @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs\n 2. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "from ts Nil"], ["proof (chain)\npicking this:\n  CT;\\<Gamma> \\<turnstile>+ t : tCs\n  CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs\n  CT;\\<Gamma> \\<turnstile> h' : Ci'\n  CT \\<turnstile> Ci' <: Cs ! length []", "have \"CT;\\<Gamma> \\<turnstile>+ (h'#t) : (Ci'#tCs)\""], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile>+ t : tCs\n  CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs\n  CT;\\<Gamma> \\<turnstile> h' : Ci'\n  CT \\<turnstile> Ci' <: Cs ! length []\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile>+ (h' # t) : (Ci' # tCs)", "by(auto simp add:typings_typing.ts_cons)"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ (h' # t) : (Ci' # tCs)\n\ngoal (2 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ ([] @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ([] @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs\n 2. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "ultimately"], ["proof (chain)\npicking this:\n  CT \\<turnstile>+ (Ci' # tCs) <: Cs\n  CT;\\<Gamma> \\<turnstile>+ (h' # t) : (Ci' # tCs)", "show ?case"], ["proof (prove)\nusing this:\n  CT \\<turnstile>+ (Ci' # tCs) <: Cs\n  CT;\\<Gamma> \\<turnstile>+ (h' # t) : (Ci' # tCs)\n\ngoal (1 subgoal):\n 1. \\<exists>Cs'.\n       CT;\\<Gamma> \\<turnstile>+ ([] @ h' # t) : Cs' \\<and>\n       CT \\<turnstile>+ Cs' <: Cs", "by auto"], ["proof (state)\nthis:\n  \\<exists>Cs'.\n     CT;\\<Gamma> \\<turnstile>+ ([] @ h' # t) : Cs' \\<and>\n     CT \\<turnstile>+ Cs' <: Cs\n\ngoal (1 subgoal):\n 1. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "case (Cons eh et)"], ["proof (state)\nthis:\n  \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (et @ h # t) : ?Cs;\n   CT;\\<Gamma> \\<turnstile> h' : Ci';\n   CT \\<turnstile> Ci' <: ?Cs ! length et\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Cs'.\n                       CT;\\<Gamma> \\<turnstile>+ (et @ h' # t) : Cs' \\<and>\n                       CT \\<turnstile>+ Cs' <: ?Cs\n  CT;\\<Gamma> \\<turnstile>+ ((eh # et) @ h # t) : Cs\n  CT;\\<Gamma> \\<turnstile> h' : Ci'\n  CT \\<turnstile> Ci' <: Cs ! length (eh # et)\n\ngoal (1 subgoal):\n 1. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (et @ h # t) : ?Cs;\n   CT;\\<Gamma> \\<turnstile> h' : Ci';\n   CT \\<turnstile> Ci' <: ?Cs ! length et\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Cs'.\n                       CT;\\<Gamma> \\<turnstile>+ (et @ h' # t) : Cs' \\<and>\n                       CT \\<turnstile>+ Cs' <: ?Cs\n  CT;\\<Gamma> \\<turnstile>+ ((eh # et) @ h # t) : Cs\n  CT;\\<Gamma> \\<turnstile> h' : Ci'\n  CT \\<turnstile> Ci' <: Cs ! length (eh # et)", "obtain hCs tCs\n  where \"CT;\\<Gamma> \\<turnstile> eh : hCs\" \n  and \"CT;\\<Gamma> \\<turnstile>+ (et@(h#t)) : tCs\"\n  and Cs_def: \"Cs = hCs # tCs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (et @ h # t) : ?Cs;\n   CT;\\<Gamma> \\<turnstile> h' : Ci';\n   CT \\<turnstile> Ci' <: ?Cs ! length et\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Cs'.\n                       CT;\\<Gamma> \\<turnstile>+ (et @ h' # t) : Cs' \\<and>\n                       CT \\<turnstile>+ Cs' <: ?Cs\n  CT;\\<Gamma> \\<turnstile>+ ((eh # et) @ h # t) : Cs\n  CT;\\<Gamma> \\<turnstile> h' : Ci'\n  CT \\<turnstile> Ci' <: Cs ! length (eh # et)\n\ngoal (1 subgoal):\n 1. (\\<And>hCs tCs.\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile> eh : hCs;\n         CT;\\<Gamma> \\<turnstile>+ (et @ h # t) : tCs;\n         Cs = hCs # tCs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:typings.cases)"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile> eh : hCs\n  CT;\\<Gamma> \\<turnstile>+ (et @ h # t) : tCs\n  Cs = hCs # tCs\n\ngoal (1 subgoal):\n 1. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "moreover"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile> eh : hCs\n  CT;\\<Gamma> \\<turnstile>+ (et @ h # t) : tCs\n  Cs = hCs # tCs\n\ngoal (1 subgoal):\n 1. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (et @ h # t) : ?Cs;\n   CT;\\<Gamma> \\<turnstile> h' : Ci';\n   CT \\<turnstile> Ci' <: ?Cs ! length et\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Cs'.\n                       CT;\\<Gamma> \\<turnstile>+ (et @ h' # t) : Cs' \\<and>\n                       CT \\<turnstile>+ Cs' <: ?Cs\n  CT;\\<Gamma> \\<turnstile>+ ((eh # et) @ h # t) : Cs\n  CT;\\<Gamma> \\<turnstile> h' : Ci'\n  CT \\<turnstile> Ci' <: Cs ! length (eh # et)\n  CT;\\<Gamma> \\<turnstile> eh : hCs\n  CT;\\<Gamma> \\<turnstile>+ (et @ h # t) : tCs\n  Cs = hCs # tCs", "obtain tCs'\n  where \"CT;\\<Gamma> \\<turnstile>+ (et@(h'#t)) : tCs'\"\n  and \"CT \\<turnstile>+ tCs' <: tCs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (et @ h # t) : ?Cs;\n   CT;\\<Gamma> \\<turnstile> h' : Ci';\n   CT \\<turnstile> Ci' <: ?Cs ! length et\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Cs'.\n                       CT;\\<Gamma> \\<turnstile>+ (et @ h' # t) : Cs' \\<and>\n                       CT \\<turnstile>+ Cs' <: ?Cs\n  CT;\\<Gamma> \\<turnstile>+ ((eh # et) @ h # t) : Cs\n  CT;\\<Gamma> \\<turnstile> h' : Ci'\n  CT \\<turnstile> Ci' <: Cs ! length (eh # et)\n  CT;\\<Gamma> \\<turnstile> eh : hCs\n  CT;\\<Gamma> \\<turnstile>+ (et @ h # t) : tCs\n  Cs = hCs # tCs\n\ngoal (1 subgoal):\n 1. (\\<And>tCs'.\n        \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (et @ h' # t) : tCs';\n         CT \\<turnstile>+ tCs' <: tCs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ (et @ h' # t) : tCs'\n  CT \\<turnstile>+ tCs' <: tCs\n\ngoal (1 subgoal):\n 1. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "ultimately"], ["proof (chain)\npicking this:\n  CT;\\<Gamma> \\<turnstile> eh : hCs\n  CT;\\<Gamma> \\<turnstile>+ (et @ h # t) : tCs\n  Cs = hCs # tCs\n  CT;\\<Gamma> \\<turnstile>+ (et @ h' # t) : tCs'\n  CT \\<turnstile>+ tCs' <: tCs", "have \n  \"CT;\\<Gamma> \\<turnstile>+ (eh#(et@(h'#t))) : (hCs#tCs')\" \n  and \"CT \\<turnstile>+ (hCs#tCs') <: Cs\""], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile> eh : hCs\n  CT;\\<Gamma> \\<turnstile>+ (et @ h # t) : tCs\n  Cs = hCs # tCs\n  CT;\\<Gamma> \\<turnstile>+ (et @ h' # t) : tCs'\n  CT \\<turnstile>+ tCs' <: tCs\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile>+ (eh # et @ h' # t) : (hCs # tCs') &&&\n    CT \\<turnstile>+ (hCs # tCs') <: Cs", "by(auto simp add:typings_typing.ts_cons subtypings.ss_cons subtyping.s_refl)"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ (eh # et @ h' # t) : (hCs # tCs')\n  CT \\<turnstile>+ (hCs # tCs') <: Cs\n\ngoal (1 subgoal):\n 1. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ (es @ h # t) : Cs;\n                    CT;\\<Gamma> \\<turnstile> h' : Ci';\n                    CT \\<turnstile> Ci' <: Cs ! length es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>Cs'.\n  CT;\\<Gamma> \\<turnstile>+ (es @ h' # t) : Cs' \\<and>\n  CT \\<turnstile>+ Cs' <: Cs;\n        CT;\\<Gamma> \\<turnstile>+ ((a # es) @ h # t) : Cs;\n        CT;\\<Gamma> \\<turnstile> h' : Ci';\n        CT \\<turnstile> Ci' <: Cs ! length (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs'.\n                            CT;\\<Gamma> \\<turnstile>+ ((a # es) @\n                 h' # t) : Cs' \\<and>\n                            CT \\<turnstile>+ Cs' <: Cs", "thus ?case"], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile>+ (eh # et @ h' # t) : (hCs # tCs')\n  CT \\<turnstile>+ (hCs # tCs') <: Cs\n\ngoal (1 subgoal):\n 1. \\<exists>Cs'.\n       CT;\\<Gamma> \\<turnstile>+ ((eh # et) @ h' # t) : Cs' \\<and>\n       CT \\<turnstile>+ Cs' <: Cs", "by auto"], ["proof (state)\nthis:\n  \\<exists>Cs'.\n     CT;\\<Gamma> \\<turnstile>+ ((eh # et) @ h' # t) : Cs' \\<and>\n     CT \\<turnstile>+ Cs' <: Cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mem_typings: \n  \"\\<And>Cs. \\<lbrakk> CT;\\<Gamma> \\<turnstile>+ es:Cs; ei \\<in> set es\\<rbrakk> \\<Longrightarrow> \\<exists>Ci. CT;\\<Gamma> \\<turnstile> ei:Ci\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ es : Cs; ei \\<in> set es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ci. CT;\\<Gamma> \\<turnstile> ei : Ci", "proof(induct es)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ [] : Cs; ei \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> Ex (typing CT \\<Gamma> ei)\n 2. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ es : Cs;\n                    ei \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> Ex (typing CT \\<Gamma> ei);\n        CT;\\<Gamma> \\<turnstile>+ (a # es) : Cs;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> Ex (typing CT \\<Gamma> ei)", "case Nil"], ["proof (state)\nthis:\n  CT;\\<Gamma> \\<turnstile>+ [] : Cs\n  ei \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ [] : Cs; ei \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> Ex (typing CT \\<Gamma> ei)\n 2. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ es : Cs;\n                    ei \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> Ex (typing CT \\<Gamma> ei);\n        CT;\\<Gamma> \\<turnstile>+ (a # es) : Cs;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> Ex (typing CT \\<Gamma> ei)", "thus ?case"], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile>+ [] : Cs\n  ei \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<exists>a. CT;\\<Gamma> \\<turnstile> ei : a", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. CT;\\<Gamma> \\<turnstile> ei : a\n\ngoal (1 subgoal):\n 1. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ es : Cs;\n                    ei \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> Ex (typing CT \\<Gamma> ei);\n        CT;\\<Gamma> \\<turnstile>+ (a # es) : Cs;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> Ex (typing CT \\<Gamma> ei)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ es : Cs;\n                    ei \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> Ex (typing CT \\<Gamma> ei);\n        CT;\\<Gamma> \\<turnstile>+ (a # es) : Cs;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> Ex (typing CT \\<Gamma> ei)", "case (Cons eh et)"], ["proof (state)\nthis:\n  \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ et : ?Cs; ei \\<in> set et\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. CT;\\<Gamma> \\<turnstile> ei : a\n  CT;\\<Gamma> \\<turnstile>+ (eh # et) : Cs\n  ei \\<in> set (eh # et)\n\ngoal (1 subgoal):\n 1. \\<And>a es Cs.\n       \\<lbrakk>\\<And>Cs.\n                   \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ es : Cs;\n                    ei \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> Ex (typing CT \\<Gamma> ei);\n        CT;\\<Gamma> \\<turnstile>+ (a # es) : Cs;\n        ei \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> Ex (typing CT \\<Gamma> ei)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>CT;\\<Gamma> \\<turnstile>+ et : ?Cs; ei \\<in> set et\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. CT;\\<Gamma> \\<turnstile> ei : a\n  CT;\\<Gamma> \\<turnstile>+ (eh # et) : Cs\n  ei \\<in> set (eh # et)\n\ngoal (1 subgoal):\n 1. \\<exists>a. CT;\\<Gamma> \\<turnstile> ei : a", "by(cases \"ei=eh\", auto elim:typings.cases)"], ["proof (state)\nthis:\n  \\<exists>a. CT;\\<Gamma> \\<turnstile> ei : a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma typings_proj: \n  assumes \"CT;\\<Gamma> \\<turnstile>+ ds : As\"\n      and \"CT \\<turnstile>+ As <: Bs\" \n      and \"length ds = length As\" \n      and \"length ds = length Bs\" \n      and \"i < length ds\" \n    shows \"CT;\\<Gamma> \\<turnstile> ds!i : As!i\" and \"CT \\<turnstile> As!i <: Bs!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile> ds ! i : As ! i &&&\n    CT \\<turnstile> As ! i <: Bs ! i", "using assms"], ["proof (prove)\nusing this:\n  CT;\\<Gamma> \\<turnstile>+ ds : As\n  CT \\<turnstile>+ As <: Bs\n  length ds = length As\n  length ds = length Bs\n  i < length ds\n\ngoal (1 subgoal):\n 1. CT;\\<Gamma> \\<turnstile> ds ! i : As ! i &&&\n    CT \\<turnstile> As ! i <: Bs ! i", "by (auto simp add:typings_index subtypings_index)"], ["", "lemma subtypings_length: \n  \"CT \\<turnstile>+ As <: Bs \\<Longrightarrow> length As = length Bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CT \\<turnstile>+ As <: Bs \\<Longrightarrow> length As = length Bs", "by(induct rule:subtypings.induct) simp_all"], ["", "lemma not_subtypes_aux: \n  assumes \"CT \\<turnstile> C <: Da\" \n  and \"C \\<noteq> Da\" \n  and \"CT C = Some CDef\" \n  and \"cSuper CDef = D\"\n  shows \"CT \\<turnstile> D <: Da\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CT \\<turnstile> D <: Da", "using assms"], ["proof (prove)\nusing this:\n  CT \\<turnstile> C <: Da\n  C \\<noteq> Da\n  CT C = Some CDef\n  cSuper CDef = D\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> D <: Da", "by (induct rule:subtyping.induct) (auto intro:subtyping.intros)"], ["", "lemma not_subtypes:\n  assumes \"CT \\<turnstile> A <: C\"\n  shows \"\\<And>D. \\<lbrakk> CT \\<turnstile> D \\<not><: C;  CT \\<turnstile> C \\<not><: D\\<rbrakk> \\<Longrightarrow> CT \\<turnstile> A \\<not><: D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D.\n       \\<lbrakk>CT \\<turnstile> D \\<not><: C;\n        CT \\<turnstile> C \\<not><: D\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> A \\<not><: D", "using assms"], ["proof (prove)\nusing this:\n  CT \\<turnstile> A <: C\n\ngoal (1 subgoal):\n 1. \\<And>D.\n       \\<lbrakk>CT \\<turnstile> D \\<not><: C;\n        CT \\<turnstile> C \\<not><: D\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> A \\<not><: D", "proof(induct rule:subtyping.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>CT C D.\n       \\<lbrakk>CT \\<turnstile> D \\<not><: C;\n        CT \\<turnstile> C \\<not><: D\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: D\n 2. \\<And>CT C D E Da.\n       \\<lbrakk>CT \\<turnstile> C <: D;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: D;\n            CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da;\n        CT \\<turnstile> D <: E;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: E;\n            CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> D \\<not><: Da;\n        CT \\<turnstile> Da \\<not><: E;\n        CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da\n 3. \\<And>CT C CDef D Da.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D;\n        CT \\<turnstile> Da \\<not><: D;\n        CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da", "case s_refl"], ["proof (state)\nthis:\n  CT_ \\<turnstile> D \\<not><: C_\n  CT_ \\<turnstile> C_ \\<not><: D\n\ngoal (3 subgoals):\n 1. \\<And>CT C D.\n       \\<lbrakk>CT \\<turnstile> D \\<not><: C;\n        CT \\<turnstile> C \\<not><: D\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: D\n 2. \\<And>CT C D E Da.\n       \\<lbrakk>CT \\<turnstile> C <: D;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: D;\n            CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da;\n        CT \\<turnstile> D <: E;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: E;\n            CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> D \\<not><: Da;\n        CT \\<turnstile> Da \\<not><: E;\n        CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da\n 3. \\<And>CT C CDef D Da.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D;\n        CT \\<turnstile> Da \\<not><: D;\n        CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da", "thus ?case"], ["proof (prove)\nusing this:\n  CT_ \\<turnstile> D \\<not><: C_\n  CT_ \\<turnstile> C_ \\<not><: D\n\ngoal (1 subgoal):\n 1. CT_ \\<turnstile> C_ \\<not><: D", "by auto"], ["proof (state)\nthis:\n  CT_ \\<turnstile> C_ \\<not><: D\n\ngoal (2 subgoals):\n 1. \\<And>CT C D E Da.\n       \\<lbrakk>CT \\<turnstile> C <: D;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: D;\n            CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da;\n        CT \\<turnstile> D <: E;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: E;\n            CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> D \\<not><: Da;\n        CT \\<turnstile> Da \\<not><: E;\n        CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da\n 2. \\<And>CT C CDef D Da.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D;\n        CT \\<turnstile> Da \\<not><: D;\n        CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>CT C D E Da.\n       \\<lbrakk>CT \\<turnstile> C <: D;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: D;\n            CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da;\n        CT \\<turnstile> D <: E;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: E;\n            CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> D \\<not><: Da;\n        CT \\<turnstile> Da \\<not><: E;\n        CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da\n 2. \\<And>CT C CDef D Da.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D;\n        CT \\<turnstile> Da \\<not><: D;\n        CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da", "case (s_trans CT C D E Da)"], ["proof (state)\nthis:\n  CT \\<turnstile> C <: D\n  \\<lbrakk>CT \\<turnstile> ?D \\<not><: D;\n   CT \\<turnstile> D \\<not><: ?D\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> C \\<not><: ?D\n  CT \\<turnstile> D <: E\n  \\<lbrakk>CT \\<turnstile> ?D \\<not><: E;\n   CT \\<turnstile> E \\<not><: ?D\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> D \\<not><: ?D\n  CT \\<turnstile> Da \\<not><: E\n  CT \\<turnstile> E \\<not><: Da\n\ngoal (2 subgoals):\n 1. \\<And>CT C D E Da.\n       \\<lbrakk>CT \\<turnstile> C <: D;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: D;\n            CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da;\n        CT \\<turnstile> D <: E;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: E;\n            CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> D \\<not><: Da;\n        CT \\<turnstile> Da \\<not><: E;\n        CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da\n 2. \\<And>CT C CDef D Da.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D;\n        CT \\<turnstile> Da \\<not><: D;\n        CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da", "have da_nsub_d:\"CT \\<turnstile> Da \\<not><: D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CT \\<turnstile> Da \\<not><: D", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> CT \\<turnstile> Da \\<not><: D \\<Longrightarrow> False", "assume \"\\<not> CT \\<turnstile> Da \\<not><: D\""], ["proof (state)\nthis:\n  \\<not> CT \\<turnstile> Da \\<not><: D\n\ngoal (1 subgoal):\n 1. \\<not> CT \\<turnstile> Da \\<not><: D \\<Longrightarrow> False", "hence da_sub_d:\"CT \\<turnstile> Da <: D\""], ["proof (prove)\nusing this:\n  \\<not> CT \\<turnstile> Da \\<not><: D\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> Da <: D", "by auto"], ["proof (state)\nthis:\n  CT \\<turnstile> Da <: D\n\ngoal (1 subgoal):\n 1. \\<not> CT \\<turnstile> Da \\<not><: D \\<Longrightarrow> False", "have d_sub_e:\"CT \\<turnstile> D <: E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CT \\<turnstile> D <: E", "using s_trans"], ["proof (prove)\nusing this:\n  CT \\<turnstile> C <: D\n  \\<lbrakk>CT \\<turnstile> ?D \\<not><: D;\n   CT \\<turnstile> D \\<not><: ?D\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> C \\<not><: ?D\n  CT \\<turnstile> D <: E\n  \\<lbrakk>CT \\<turnstile> ?D \\<not><: E;\n   CT \\<turnstile> E \\<not><: ?D\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> D \\<not><: ?D\n  CT \\<turnstile> Da \\<not><: E\n  CT \\<turnstile> E \\<not><: Da\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> D <: E", "by fastforce"], ["proof (state)\nthis:\n  CT \\<turnstile> D <: E\n\ngoal (1 subgoal):\n 1. \\<not> CT \\<turnstile> Da \\<not><: D \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  CT \\<turnstile> D <: E\n\ngoal (1 subgoal):\n 1. False", "using s_trans"], ["proof (prove)\nusing this:\n  CT \\<turnstile> D <: E\n  CT \\<turnstile> C <: D\n  \\<lbrakk>CT \\<turnstile> ?D \\<not><: D;\n   CT \\<turnstile> D \\<not><: ?D\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> C \\<not><: ?D\n  CT \\<turnstile> D <: E\n  \\<lbrakk>CT \\<turnstile> ?D \\<not><: E;\n   CT \\<turnstile> E \\<not><: ?D\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> D \\<not><: ?D\n  CT \\<turnstile> Da \\<not><: E\n  CT \\<turnstile> E \\<not><: Da\n\ngoal (1 subgoal):\n 1. False", "by (force simp add:subtyping.s_trans[OF da_sub_d d_sub_e])"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CT \\<turnstile> Da \\<not><: D\n\ngoal (2 subgoals):\n 1. \\<And>CT C D E Da.\n       \\<lbrakk>CT \\<turnstile> C <: D;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: D;\n            CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da;\n        CT \\<turnstile> D <: E;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: E;\n            CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> D \\<not><: Da;\n        CT \\<turnstile> Da \\<not><: E;\n        CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da\n 2. \\<And>CT C CDef D Da.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D;\n        CT \\<turnstile> Da \\<not><: D;\n        CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da", "have d_nsub_da:\"CT \\<turnstile> D \\<not><: Da\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CT \\<turnstile> D \\<not><: Da", "using s_trans"], ["proof (prove)\nusing this:\n  CT \\<turnstile> C <: D\n  \\<lbrakk>CT \\<turnstile> ?D \\<not><: D;\n   CT \\<turnstile> D \\<not><: ?D\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> C \\<not><: ?D\n  CT \\<turnstile> D <: E\n  \\<lbrakk>CT \\<turnstile> ?D \\<not><: E;\n   CT \\<turnstile> E \\<not><: ?D\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> D \\<not><: ?D\n  CT \\<turnstile> Da \\<not><: E\n  CT \\<turnstile> E \\<not><: Da\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> D \\<not><: Da", "by auto"], ["proof (state)\nthis:\n  CT \\<turnstile> D \\<not><: Da\n\ngoal (2 subgoals):\n 1. \\<And>CT C D E Da.\n       \\<lbrakk>CT \\<turnstile> C <: D;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: D;\n            CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da;\n        CT \\<turnstile> D <: E;\n        \\<And>Da.\n           \\<lbrakk>CT \\<turnstile> Da \\<not><: E;\n            CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n           \\<Longrightarrow> CT \\<turnstile> D \\<not><: Da;\n        CT \\<turnstile> Da \\<not><: E;\n        CT \\<turnstile> E \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da\n 2. \\<And>CT C CDef D Da.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D;\n        CT \\<turnstile> Da \\<not><: D;\n        CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da", "from da_nsub_d d_nsub_da s_trans"], ["proof (chain)\npicking this:\n  CT \\<turnstile> Da \\<not><: D\n  CT \\<turnstile> D \\<not><: Da\n  CT \\<turnstile> C <: D\n  \\<lbrakk>CT \\<turnstile> ?D \\<not><: D;\n   CT \\<turnstile> D \\<not><: ?D\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> C \\<not><: ?D\n  CT \\<turnstile> D <: E\n  \\<lbrakk>CT \\<turnstile> ?D \\<not><: E;\n   CT \\<turnstile> E \\<not><: ?D\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> D \\<not><: ?D\n  CT \\<turnstile> Da \\<not><: E\n  CT \\<turnstile> E \\<not><: Da", "show \"CT \\<turnstile> C \\<not><: Da\""], ["proof (prove)\nusing this:\n  CT \\<turnstile> Da \\<not><: D\n  CT \\<turnstile> D \\<not><: Da\n  CT \\<turnstile> C <: D\n  \\<lbrakk>CT \\<turnstile> ?D \\<not><: D;\n   CT \\<turnstile> D \\<not><: ?D\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> C \\<not><: ?D\n  CT \\<turnstile> D <: E\n  \\<lbrakk>CT \\<turnstile> ?D \\<not><: E;\n   CT \\<turnstile> E \\<not><: ?D\\<rbrakk>\n  \\<Longrightarrow> CT \\<turnstile> D \\<not><: ?D\n  CT \\<turnstile> Da \\<not><: E\n  CT \\<turnstile> E \\<not><: Da\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> C \\<not><: Da", "by auto"], ["proof (state)\nthis:\n  CT \\<turnstile> C \\<not><: Da\n\ngoal (1 subgoal):\n 1. \\<And>CT C CDef D Da.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D;\n        CT \\<turnstile> Da \\<not><: D;\n        CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>CT C CDef D Da.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D;\n        CT \\<turnstile> Da \\<not><: D;\n        CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da", "case (s_super CT C CDef D Da)"], ["proof (state)\nthis:\n  CT C = Some CDef\n  cSuper CDef = D\n  CT \\<turnstile> Da \\<not><: D\n  CT \\<turnstile> D \\<not><: Da\n\ngoal (1 subgoal):\n 1. \\<And>CT C CDef D Da.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D;\n        CT \\<turnstile> Da \\<not><: D;\n        CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da", "have \"C \\<noteq> Da\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> Da", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> C \\<noteq> Da \\<Longrightarrow> False", "assume \"\\<not> C \\<noteq> Da\""], ["proof (state)\nthis:\n  \\<not> C \\<noteq> Da\n\ngoal (1 subgoal):\n 1. \\<not> C \\<noteq> Da \\<Longrightarrow> False", "hence \"C = Da\""], ["proof (prove)\nusing this:\n  \\<not> C \\<noteq> Da\n\ngoal (1 subgoal):\n 1. C = Da", "by auto"], ["proof (state)\nthis:\n  C = Da\n\ngoal (1 subgoal):\n 1. \\<not> C \\<noteq> Da \\<Longrightarrow> False", "hence \"CT \\<turnstile> Da <: D\""], ["proof (prove)\nusing this:\n  C = Da\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> Da <: D", "using s_super"], ["proof (prove)\nusing this:\n  C = Da\n  CT C = Some CDef\n  cSuper CDef = D\n  CT \\<turnstile> Da \\<not><: D\n  CT \\<turnstile> D \\<not><: Da\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> Da <: D", "by(auto simp add: subtyping.s_super)"], ["proof (state)\nthis:\n  CT \\<turnstile> Da <: D\n\ngoal (1 subgoal):\n 1. \\<not> C \\<noteq> Da \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  CT \\<turnstile> Da <: D\n\ngoal (1 subgoal):\n 1. False", "using s_super"], ["proof (prove)\nusing this:\n  CT \\<turnstile> Da <: D\n  CT C = Some CDef\n  cSuper CDef = D\n  CT \\<turnstile> Da \\<not><: D\n  CT \\<turnstile> D \\<not><: Da\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C \\<noteq> Da\n\ngoal (1 subgoal):\n 1. \\<And>CT C CDef D Da.\n       \\<lbrakk>CT C = Some CDef; cSuper CDef = D;\n        CT \\<turnstile> Da \\<not><: D;\n        CT \\<turnstile> D \\<not><: Da\\<rbrakk>\n       \\<Longrightarrow> CT \\<turnstile> C \\<not><: Da", "thus ?case"], ["proof (prove)\nusing this:\n  C \\<noteq> Da\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> C \\<not><: Da", "using s_super"], ["proof (prove)\nusing this:\n  C \\<noteq> Da\n  CT C = Some CDef\n  cSuper CDef = D\n  CT \\<turnstile> Da \\<not><: D\n  CT \\<turnstile> D \\<not><: Da\n\ngoal (1 subgoal):\n 1. CT \\<turnstile> C \\<not><: Da", "by (auto simp add: not_subtypes_aux)"], ["proof (state)\nthis:\n  CT \\<turnstile> C \\<not><: Da\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Sub-Expressions\\<close>"], ["", "lemma isubexpr_typing: \n  assumes \"e1 \\<in> isubexprs(e0)\"\n  shows \"\\<And>C. \\<lbrakk> CT;Map.empty \\<turnstile> e0 : C \\<rbrakk> \\<Longrightarrow> \\<exists>D. CT;Map.empty \\<turnstile> e1 : D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       CT;Map.empty \\<turnstile> e0 : C \\<Longrightarrow>\n       \\<exists>D. CT;Map.empty \\<turnstile> e1 : D", "using assms"], ["proof (prove)\nusing this:\n  e1 \\<in> isubexprs(e0)\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       CT;Map.empty \\<turnstile> e0 : C \\<Longrightarrow>\n       \\<exists>D. CT;Map.empty \\<turnstile> e1 : D", "by (induct rule:isubexprs.induct) (auto elim:typing.cases simp add:mem_typings)"], ["", "lemma subexpr_typing: \n  assumes \"e1 \\<in> subexprs(e0)\"\n  shows \"\\<And>C. \\<lbrakk> CT;Map.empty \\<turnstile> e0 : C \\<rbrakk> \\<Longrightarrow> \\<exists>D. CT;Map.empty \\<turnstile> e1 : D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C.\n       CT;Map.empty \\<turnstile> e0 : C \\<Longrightarrow>\n       \\<exists>D. CT;Map.empty \\<turnstile> e1 : D", "using assms"], ["proof (prove)\nusing this:\n  e1 \\<in> subexprs(e0)\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       CT;Map.empty \\<turnstile> e0 : C \\<Longrightarrow>\n       \\<exists>D. CT;Map.empty \\<turnstile> e1 : D", "by (induct rule:rtrancl.induct) (auto, force simp add:isubexpr_typing)"], ["", "lemma isubexpr_reduct: \n  assumes \"d1 \\<in> isubexprs(e1)\"\n  shows \"\\<And>d2. \\<lbrakk> CT \\<turnstile> d1 \\<rightarrow> d2 \\<rbrakk> \\<Longrightarrow> \\<exists>e2. CT \\<turnstile> e1 \\<rightarrow> e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d2.\n       CT \\<turnstile> d1 \\<rightarrow> d2 \\<Longrightarrow>\n       \\<exists>e2. CT \\<turnstile> e1 \\<rightarrow> e2", "using assms mem_ith"], ["proof (prove)\nusing this:\n  d1 \\<in> isubexprs(e1)\n  ?ei \\<in> set ?es \\<Longrightarrow> \\<exists>el er. ?es = el @ ?ei # er\n\ngoal (1 subgoal):\n 1. \\<And>d2.\n       CT \\<turnstile> d1 \\<rightarrow> d2 \\<Longrightarrow>\n       \\<exists>e2. CT \\<turnstile> e1 \\<rightarrow> e2", "by induct\n    (auto elim:isubexprs.cases intro:reduction.intros,\n      force intro:reduction.intros, \n      force intro:reduction.intros)"], ["", "lemma subexpr_reduct: \n  assumes \"d1 \\<in> subexprs(e1)\"\n  shows \"\\<And>d2. \\<lbrakk> CT \\<turnstile> d1 \\<rightarrow> d2 \\<rbrakk> \\<Longrightarrow> \\<exists>e2. CT \\<turnstile> e1 \\<rightarrow> e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d2.\n       CT \\<turnstile> d1 \\<rightarrow> d2 \\<Longrightarrow>\n       \\<exists>e2. CT \\<turnstile> e1 \\<rightarrow> e2", "using assms"], ["proof (prove)\nusing this:\n  d1 \\<in> subexprs(e1)\n\ngoal (1 subgoal):\n 1. \\<And>d2.\n       CT \\<turnstile> d1 \\<rightarrow> d2 \\<Longrightarrow>\n       \\<exists>e2. CT \\<turnstile> e1 \\<rightarrow> e2", "by (induct rule:rtrancl.induct) (auto, force simp add: isubexpr_reduct)"], ["", "end"]]}