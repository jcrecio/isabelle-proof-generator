{"file_name": "/home/qj213/afp-2021-10-22/thys/Interval_Arithmetic_Word32/Finite_String.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Interval_Arithmetic_Word32", "problem_names": ["lemmas list_induct2'[case_names BothNil LeftCons RightCons BothCons] = List.list_induct2'", "lemma card_prod_finite:\n  fixes C:: \"char set\" and S::\"string set\"\n  assumes C:\"card C \\<ge> 1\" and S:\"card S \\<ge> 0\"\n  shows \"card C * card S \\<ge> card S\"", "lemma lleq_head:\n  fixes L1 L2 x\n  assumes a:\n  \"(\\<And>z. lleq_charlist L2 z \\<Longrightarrow> lleq_charlist L1 z)\"\n  \"lleq_charlist L1 L2\"\n  \"lleq_charlist (x # L2) w\"\n  shows \"lleq_charlist (x # L1) w\"", "lemma lleq_less:\n  fixes x y\n  shows \"(less_charlist x y) = (lleq_charlist x y \\<and> \\<not> lleq_charlist y  x)\"", "lemma lleq_refl:\n  fixes x\n  shows \"lleq_charlist x x\"", "lemma lleq_trans:\n  fixes x y z\n  shows \"lleq_charlist x y \\<Longrightarrow> lleq_charlist y z \\<Longrightarrow> lleq_charlist x z\"", "lemma lleq_antisym:\n  fixes x y\n  shows \"lleq_charlist x y \\<Longrightarrow> lleq_charlist y x \\<Longrightarrow> x = y\"", "lemma lleq_dichotomy:\n  fixes x y\n  shows \"lleq_charlist x y \\<or> lleq_charlist y x\"", "lemma mem_appL:\"List.member L1 x \\<Longrightarrow> List.member (L1 @ L2) x\"", "lemma mem_appR:\"List.member L2 x \\<Longrightarrow> List.member (L1 @ L2) x\"", "lemma mem_app_or:\"List.member (L1 @ L2) x = List.member L1 x \\<or> List.member L2 x\"", "lemma fin_string_nil:\n  fixes n\n  shows \"List.member (fin_string_upto n) fin_string_empty\"", "lemma length_induct:\n  fixes P\n  assumes len:\"length L \\<le> MAX_STR\"\n  assumes BC:\"P [] 0\"\n  assumes IS:\"(\\<And>k x xs.  P xs k \\<Longrightarrow> P ((x # xs)) (Suc k))\"\n  shows \"P L (length L)\"", "lemma ilength_induct:\n  fixes P\n  assumes BC:\"P fin_string_empty 0\"\n  assumes IS:\"(\\<And>k x xs.  P xs k \\<Longrightarrow> P (Abs_fin_string (x # Rep_fin_string xs)) (Suc k))\"\n  shows  \"P L (ilength L)\"", "lemma enum_chars:\"set (enum_class.enum::char list)= UNIV\"", "lemma member_concat:\"List.member (concat LL) x = (\\<exists>L. List.member LL L \\<and> List.member L x)\"", "lemma fin_string_length:\n  fixes L::string\n  assumes len:\"length L \\<le> k\"\n  assumes Len:\"length L \\<le> MAX_STR\"\n  shows \"List.member (fin_string_upto k) (Abs_fin_string L)\"", "lemma fin_string_upto_length:\n  shows \"List.member (fin_string_upto n) L \\<Longrightarrow> ilength L \\<le> n\"", "lemma distinct_upto:\n  shows \"i \\<le> MAX_STR \\<Longrightarrow> distinct (fin_string_upto i)\"", "lemma enum_ALL:\"(UNIV::fin_string set) = set enum_class.enum\"", "lemma vals_ALL:\"set (vals::fin_string list) = UNIV\"", "lemma setA:\n  assumes set:\"\\<And>y. y \\<in> set L \\<Longrightarrow> P y\"\n  shows \"list_all P L\"", "lemma setE:\n  assumes set:\" y \\<in> set L\"\n  assumes P:\"P y\"\n  shows \"list_ex P L\""], "translations": [["", "lemmas list_induct2'[case_names BothNil LeftCons RightCons BothCons] = List.list_induct2'"], ["", "text\\<open>Set a hard-coded global maximum string length\\<close>"], ["", "definition max_str:\"MAX_STR = 20\""], ["", "text\\<open>Finite strings are strings whose size is within the maximum\\<close>"], ["", "typedef fin_string = \"{s::string. size s \\<le> MAX_STR}\"\n  morphisms Rep_fin_string Abs_fin_string"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {s. length s \\<le> MAX_STR}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. length x \\<le> MAX_STR", "apply(rule exI[where x=Nil])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [] \\<le> MAX_STR", "by(auto simp add: max_str)"], ["", "text\\<open>Lift definition of string length\\<close>"], ["", "setup_lifting  Finite_String.fin_string.type_definition_fin_string"], ["", "lift_definition ilength::\"fin_string \\<Rightarrow> nat\" is length"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Product of types never decreases cardinality\\<close>"], ["", "lemma card_prod_finite:\n  fixes C:: \"char set\" and S::\"string set\"\n  assumes C:\"card C \\<ge> 1\" and S:\"card S \\<ge> 0\"\n  shows \"card C * card S \\<ge> card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card S \\<le> card C * card S", "using C S"], ["proof (prove)\nusing this:\n  1 \\<le> card C\n  0 \\<le> card S\n\ngoal (1 subgoal):\n 1. card S \\<le> card C * card S", "by auto"], ["", "fun cons :: \"('a * 'a list) \\<Rightarrow> 'a list\" \n  where \"cons (x,y) = x # y\""], ["", "text\\<open>Finite strings are finite\\<close>"], ["", "instantiation fin_string :: finite begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fin_string, finite_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV", "have any:\"\\<forall>i::nat. card {s::string. length s \\<le> i} > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. 0 < card {s. length s \\<le> i}", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. 0 < card {s. length s \\<le> i}", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card {s. length s \\<le> i}", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < card {s. length s \\<le> 0}\n 2. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 < card {s. length s \\<le> 0}\n 2. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card {s. length s \\<le> 0}", "by auto"], ["proof (state)\nthis:\n  0 < card {s. length s \\<le> 0}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "case (Suc k)"], ["proof (state)\nthis:\n  0 < card {s. length s \\<le> k}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "assume IH:\"card {s::string. length s \\<le> k} > 0\""], ["proof (state)\nthis:\n  0 < card {s. length s \\<le> k}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "let ?c = \"(UNIV::char set)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "let ?ih = \"{s::string. length s \\<le> k}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "let ?prod = \"(?c \\<times> ?ih)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "let ?b = \"(cons ` ?prod)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "let ?A = \"{s::string. length s \\<le> Suc k}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "let ?B = \"insert [] ?b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "have IHfin:\"finite ?ih\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {s. length s \\<le> k}", "using IH card_ge_0_finite"], ["proof (prove)\nusing this:\n  0 < card {s. length s \\<le> k}\n  0 < card ?A \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite {s. length s \\<le> k}", "by blast"], ["proof (state)\nthis:\n  finite {s. length s \\<le> k}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "have finChar:\"finite ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "using card_ge_0_finite finite_code"], ["proof (prove)\nusing this:\n  0 < card ?A \\<Longrightarrow> finite ?A\n  finite ?A = True\n\ngoal (1 subgoal):\n 1. finite UNIV", "by blast"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "have finiteProd:\"finite ?prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (UNIV \\<times> {s. length s \\<le> k})", "using Groups_Big.card_cartesian_product IHfin finChar"], ["proof (prove)\nusing this:\n  card (?A \\<times> ?B) = card ?A * card ?B\n  finite {s. length s \\<le> k}\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite (UNIV \\<times> {s. length s \\<le> k})", "by auto"], ["proof (state)\nthis:\n  finite (UNIV \\<times> {s. length s \\<le> k})\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "have cardCons:\"card ?b = card ?prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (cons ` (UNIV \\<times> {s. length s \\<le> k})) =\n    card (UNIV \\<times> {s. length s \\<le> k})", "apply(rule Finite_Set.card_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on cons (UNIV \\<times> {s. length s \\<le> k})", "by(auto simp add: inj_on_def)"], ["proof (state)\nthis:\n  card (cons ` (UNIV \\<times> {s. length s \\<le> k})) =\n  card (UNIV \\<times> {s. length s \\<le> k})\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "have finiteCons:\"finite ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (cons ` (UNIV \\<times> {s. length s \\<le> k}))", "using cardCons finiteProd card_ge_0_finite"], ["proof (prove)\nusing this:\n  card (cons ` (UNIV \\<times> {s. length s \\<le> k})) =\n  card (UNIV \\<times> {s. length s \\<le> k})\n  finite (UNIV \\<times> {s. length s \\<le> k})\n  0 < card ?A \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (cons ` (UNIV \\<times> {s. length s \\<le> k}))", "by blast"], ["proof (state)\nthis:\n  finite (cons ` (UNIV \\<times> {s. length s \\<le> k}))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "have finiteB:\"finite ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (insert [] (cons ` (UNIV \\<times> {s. length s \\<le> k})))", "using finite_insert finiteCons"], ["proof (prove)\nusing this:\n  finite (insert ?a ?A) = finite ?A\n  finite (cons ` (UNIV \\<times> {s. length s \\<le> k}))\n\ngoal (1 subgoal):\n 1. finite (insert [] (cons ` (UNIV \\<times> {s. length s \\<le> k})))", "by auto"], ["proof (state)\nthis:\n  finite (insert [] (cons ` (UNIV \\<times> {s. length s \\<le> k})))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "have lr:\"\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<in> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {s. length s \\<le> Suc k} \\<Longrightarrow>\n       x \\<in> insert [] (cons ` (UNIV \\<times> {s. length s \\<le> k}))", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {s. length s \\<le> Suc k} \\<Longrightarrow>\n    x \\<in> insert [] (cons ` (UNIV \\<times> {s. length s \\<le> k}))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length x \\<le> Suc k;\n     x \\<notin> cons ` (UNIV \\<times> {s. length s \\<le> k})\\<rbrakk>\n    \\<Longrightarrow> x = []", "apply(cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length x \\<le> Suc k;\n     x \\<notin> cons ` (UNIV \\<times> {s. length s \\<le> k});\n     x = []\\<rbrakk>\n    \\<Longrightarrow> x = []\n 2. \\<And>a list.\n       \\<lbrakk>length x \\<le> Suc k;\n        x \\<notin> cons ` (UNIV \\<times> {s. length s \\<le> k});\n        x = a # list\\<rbrakk>\n       \\<Longrightarrow> x = []", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length list \\<le> k;\n        a # list \\<notin> cons ` (UNIV \\<times> {s. length s \\<le> k});\n        x = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis UNIV_I cons.simps image_eqI mem_Collect_eq mem_Sigma_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x \\<in> {s. length s \\<le> Suc k} \\<Longrightarrow>\n  ?x \\<in> insert [] (cons ` (UNIV \\<times> {s. length s \\<le> k}))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "have rl:\"\\<And>x. x \\<in> ?B \\<Longrightarrow> x \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> insert []\n                (cons `\n                 (UNIV \\<times> {s. length s \\<le> k})) \\<Longrightarrow>\n       x \\<in> {s. length s \\<le> Suc k}", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> insert []\n             (cons `\n              (UNIV \\<times> {s. length s \\<le> k})) \\<Longrightarrow>\n    x \\<in> {s. length s \\<le> Suc k}", "by(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x \\<in> insert []\n            (cons ` (UNIV \\<times> {s. length s \\<le> k})) \\<Longrightarrow>\n  ?x \\<in> {s. length s \\<le> Suc k}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "have isCons:\"?A = ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. length s \\<le> Suc k} =\n    insert [] (cons ` (UNIV \\<times> {s. length s \\<le> k}))", "using lr rl"], ["proof (prove)\nusing this:\n  ?x \\<in> {s. length s \\<le> Suc k} \\<Longrightarrow>\n  ?x \\<in> insert [] (cons ` (UNIV \\<times> {s. length s \\<le> k}))\n  ?x \\<in> insert []\n            (cons ` (UNIV \\<times> {s. length s \\<le> k})) \\<Longrightarrow>\n  ?x \\<in> {s. length s \\<le> Suc k}\n\ngoal (1 subgoal):\n 1. {s. length s \\<le> Suc k} =\n    insert [] (cons ` (UNIV \\<times> {s. length s \\<le> k}))", "by auto"], ["proof (state)\nthis:\n  {s. length s \\<le> Suc k} =\n  insert [] (cons ` (UNIV \\<times> {s. length s \\<le> k}))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 < card {s. length s \\<le> i} \\<Longrightarrow>\n       0 < card {s. length s \\<le> Suc i}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card {s. length s \\<le> Suc k}", "using finiteB isCons IH"], ["proof (prove)\nusing this:\n  finite (insert [] (cons ` (UNIV \\<times> {s. length s \\<le> k})))\n  {s. length s \\<le> Suc k} =\n  insert [] (cons ` (UNIV \\<times> {s. length s \\<le> k}))\n  0 < card {s. length s \\<le> k}\n\ngoal (1 subgoal):\n 1. 0 < card {s. length s \\<le> Suc k}", "by (simp add: card.insert_remove)"], ["proof (state)\nthis:\n  0 < card {s. length s \\<le> Suc k}\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>i. 0 < card {s. length s \\<le> i}\n\ngoal (1 subgoal):\n 1. finite UNIV", "note finMax = card_ge_0_finite[OF spec[OF any, of MAX_STR]]"], ["proof (state)\nthis:\n  finite {s. length s \\<le> MAX_STR}\n\ngoal (1 subgoal):\n 1. finite UNIV", "have fin:\"finite {x | x y . x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>x y.\n         uu_ = x \\<and>\n         x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}", "using Abs_fin_string_cases finMax"], ["proof (prove)\nusing this:\n  (\\<And>y.\n      \\<lbrakk>?x = Abs_fin_string y;\n       y \\<in> {s. length s \\<le> MAX_STR}\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n  finite {s. length s \\<le> MAX_STR}\n\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>x y.\n         uu_ = x \\<and>\n         x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}", "by auto"], ["proof (state)\nthis:\n  finite\n   {uu_.\n    \\<exists>x y.\n       uu_ = x \\<and>\n       x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}\n\ngoal (1 subgoal):\n 1. finite UNIV", "have univEq:\"UNIV = {x | x y . x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV =\n    {uu_.\n     \\<exists>x y.\n        uu_ = x \\<and>\n        x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}", "using Abs_fin_string_cases"], ["proof (prove)\nusing this:\n  (\\<And>y.\n      \\<lbrakk>?x = Abs_fin_string y;\n       y \\<in> {s. length s \\<le> MAX_STR}\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. UNIV =\n    {uu_.\n     \\<exists>x y.\n        uu_ = x \\<and>\n        x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}", "by (metis (mono_tags, lifting) Collect_cong UNIV_I top_empty_eq top_set_def)"], ["proof (state)\nthis:\n  UNIV =\n  {uu_.\n   \\<exists>x y.\n      uu_ = x \\<and>\n      x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}\n\ngoal (1 subgoal):\n 1. finite UNIV", "then"], ["proof (chain)\npicking this:\n  UNIV =\n  {uu_.\n   \\<exists>x y.\n      uu_ = x \\<and>\n      x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}", "have \"finite (UNIV :: fin_string set)\""], ["proof (prove)\nusing this:\n  UNIV =\n  {uu_.\n   \\<exists>x y.\n      uu_ = x \\<and>\n      x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}\n\ngoal (1 subgoal):\n 1. finite UNIV", "using univEq fin"], ["proof (prove)\nusing this:\n  UNIV =\n  {uu_.\n   \\<exists>x y.\n      uu_ = x \\<and>\n      x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}\n  UNIV =\n  {uu_.\n   \\<exists>x y.\n      uu_ = x \\<and>\n      x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}\n  finite\n   {uu_.\n    \\<exists>x y.\n       uu_ = x \\<and>\n       x = Abs_fin_string y \\<and> y \\<in> {s. length s \\<le> MAX_STR}}\n\ngoal (1 subgoal):\n 1. finite UNIV", "by auto"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV", "then"], ["proof (chain)\npicking this:\n  finite UNIV", "show \"finite (UNIV::fin_string set)\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV", "by auto"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>Characters are linearly ordered by their code value\\<close>"], ["", "instantiation char :: linorder begin"], ["", "definition less_eq_char where\nless_eq_char[code]:\"less_eq_char x  y \\<equiv> int_of_char x \\<le> int_of_char y\""], ["", "definition less_char where\nless_char[code]:\"less_char x y \\<equiv> int_of_char x < int_of_char y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(char, linorder_class)", "by(standard, auto simp add: less_char less_eq_char int_of_char_def)+"], ["", "end"], ["", "text\\<open>Finite strings are linearly ordered, lexicographically\\<close>"], ["", "instantiation fin_string :: linorder begin"], ["", "fun lleq_charlist :: \"char list \\<Rightarrow> char list \\<Rightarrow> bool\"\n  where \n  \"lleq_charlist Nil Nil = True\"\n| \"lleq_charlist Nil _ = True\"\n| \"lleq_charlist _ Nil = False\"\n| \"lleq_charlist (x # xs)(y # ys) = \n   (if x = y then lleq_charlist xs ys else x < y)\""], ["", "fun less_charlist :: \"char list \\<Rightarrow> char list \\<Rightarrow> bool\"\n  where \n  \"less_charlist Nil Nil = False\"\n| \"less_charlist Nil _ = True\"\n| \"less_charlist _ Nil = False\"\n| \"less_charlist (x # xs)(y # ys) = \n   (if x = y then less_charlist xs ys else x < y)\""], ["", "lift_definition less_eq_fin_string::\"fin_string \\<Rightarrow> fin_string \\<Rightarrow> bool\" is lleq_charlist"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lift_definition less_fin_string::\"fin_string \\<Rightarrow> fin_string \\<Rightarrow> bool\" is less_charlist"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lleq_head:\n  fixes L1 L2 x\n  assumes a:\n  \"(\\<And>z. lleq_charlist L2 z \\<Longrightarrow> lleq_charlist L1 z)\"\n  \"lleq_charlist L1 L2\"\n  \"lleq_charlist (x # L2) w\"\n  shows \"lleq_charlist (x # L1) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lleq_charlist (x # L1) w", "using a"], ["proof (prove)\nusing this:\n  lleq_charlist L2 ?z \\<Longrightarrow> lleq_charlist L1 ?z\n  lleq_charlist L1 L2\n  lleq_charlist (x # L2) w\n\ngoal (1 subgoal):\n 1. lleq_charlist (x # L1) w", "by(induction arbitrary: x rule: List.list_induct2', auto)"], ["", "lemma lleq_less:\n  fixes x y\n  shows \"(less_charlist x y) = (lleq_charlist x y \\<and> \\<not> lleq_charlist y  x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. less_charlist x y = (lleq_charlist x y \\<and> \\<not> lleq_charlist y x)", "by(induction rule: List.list_induct2', auto)"], ["", "lemma lleq_refl:\n  fixes x\n  shows \"lleq_charlist x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lleq_charlist x x", "by(induction x, auto)"], ["", "lemma lleq_trans:\n  fixes x y z\n  shows \"lleq_charlist x y \\<Longrightarrow> lleq_charlist y z \\<Longrightarrow> lleq_charlist x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lleq_charlist x y; lleq_charlist y z\\<rbrakk>\n    \\<Longrightarrow> lleq_charlist x z", "proof(induction arbitrary: z rule: list_induct2')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>z.\n       \\<lbrakk>lleq_charlist [] []; lleq_charlist [] z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist [] z\n 2. \\<And>x xs z.\n       \\<lbrakk>lleq_charlist [] (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist [] z\n 3. \\<And>y ys z.\n       \\<lbrakk>lleq_charlist (y # ys) []; lleq_charlist [] z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z\n 4. \\<And>x xs y ys z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n                   \\<Longrightarrow> lleq_charlist ys z;\n        lleq_charlist (y # ys) (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z", "case BothNil"], ["proof (state)\nthis:\n  lleq_charlist [] []\n  lleq_charlist [] z\n\ngoal (4 subgoals):\n 1. \\<And>z.\n       \\<lbrakk>lleq_charlist [] []; lleq_charlist [] z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist [] z\n 2. \\<And>x xs z.\n       \\<lbrakk>lleq_charlist [] (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist [] z\n 3. \\<And>y ys z.\n       \\<lbrakk>lleq_charlist (y # ys) []; lleq_charlist [] z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z\n 4. \\<And>x xs y ys z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n                   \\<Longrightarrow> lleq_charlist ys z;\n        lleq_charlist (y # ys) (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z", "then"], ["proof (chain)\npicking this:\n  lleq_charlist [] []\n  lleq_charlist [] z", "show ?case"], ["proof (prove)\nusing this:\n  lleq_charlist [] []\n  lleq_charlist [] z\n\ngoal (1 subgoal):\n 1. lleq_charlist [] z", "by auto"], ["proof (state)\nthis:\n  lleq_charlist [] z\n\ngoal (3 subgoals):\n 1. \\<And>x xs z.\n       \\<lbrakk>lleq_charlist [] (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist [] z\n 2. \\<And>y ys z.\n       \\<lbrakk>lleq_charlist (y # ys) []; lleq_charlist [] z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z\n 3. \\<And>x xs y ys z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n                   \\<Longrightarrow> lleq_charlist ys z;\n        lleq_charlist (y # ys) (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs z.\n       \\<lbrakk>lleq_charlist [] (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist [] z\n 2. \\<And>y ys z.\n       \\<lbrakk>lleq_charlist (y # ys) []; lleq_charlist [] z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z\n 3. \\<And>x xs y ys z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n                   \\<Longrightarrow> lleq_charlist ys z;\n        lleq_charlist (y # ys) (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z", "case (LeftCons x xs)"], ["proof (state)\nthis:\n  lleq_charlist [] (x # xs)\n  lleq_charlist (x # xs) z\n\ngoal (3 subgoals):\n 1. \\<And>x xs z.\n       \\<lbrakk>lleq_charlist [] (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist [] z\n 2. \\<And>y ys z.\n       \\<lbrakk>lleq_charlist (y # ys) []; lleq_charlist [] z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z\n 3. \\<And>x xs y ys z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n                   \\<Longrightarrow> lleq_charlist ys z;\n        lleq_charlist (y # ys) (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z", "then"], ["proof (chain)\npicking this:\n  lleq_charlist [] (x # xs)\n  lleq_charlist (x # xs) z", "show ?case"], ["proof (prove)\nusing this:\n  lleq_charlist [] (x # xs)\n  lleq_charlist (x # xs) z\n\ngoal (1 subgoal):\n 1. lleq_charlist [] z", "apply(induction y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lleq_charlist [] (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n    \\<Longrightarrow> lleq_charlist [] z\n 2. \\<And>a y.\n       \\<lbrakk>\\<lbrakk>lleq_charlist [] (x # xs);\n                 lleq_charlist (x # xs) z\\<rbrakk>\n                \\<Longrightarrow> lleq_charlist [] z;\n        lleq_charlist [] (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist [] z", "using lleq_charlist.elims(2) lleq_charlist.simps(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>lleq_charlist ?x ?xa;\n   \\<lbrakk>?x = []; ?xa = []\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v va. \\<lbrakk>?x = []; ?xa = v # va\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>x xs y ys.\n      \\<lbrakk>?x = x # xs; ?xa = y # ys;\n       if x = y then lleq_charlist xs ys else x < y\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  lleq_charlist [] (?v # ?va) = True\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lleq_charlist [] (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n    \\<Longrightarrow> lleq_charlist [] z\n 2. \\<And>a y.\n       \\<lbrakk>\\<lbrakk>lleq_charlist [] (x # xs);\n                 lleq_charlist (x # xs) z\\<rbrakk>\n                \\<Longrightarrow> lleq_charlist [] z;\n        lleq_charlist [] (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist [] z", "by blast+"], ["proof (state)\nthis:\n  lleq_charlist [] z\n\ngoal (2 subgoals):\n 1. \\<And>y ys z.\n       \\<lbrakk>lleq_charlist (y # ys) []; lleq_charlist [] z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z\n 2. \\<And>x xs y ys z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n                   \\<Longrightarrow> lleq_charlist ys z;\n        lleq_charlist (y # ys) (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y ys z.\n       \\<lbrakk>lleq_charlist (y # ys) []; lleq_charlist [] z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z\n 2. \\<And>x xs y ys z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n                   \\<Longrightarrow> lleq_charlist ys z;\n        lleq_charlist (y # ys) (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z", "case (RightCons y ys)"], ["proof (state)\nthis:\n  lleq_charlist (y # ys) []\n  lleq_charlist [] z\n\ngoal (2 subgoals):\n 1. \\<And>y ys z.\n       \\<lbrakk>lleq_charlist (y # ys) []; lleq_charlist [] z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z\n 2. \\<And>x xs y ys z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n                   \\<Longrightarrow> lleq_charlist ys z;\n        lleq_charlist (y # ys) (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z", "then"], ["proof (chain)\npicking this:\n  lleq_charlist (y # ys) []\n  lleq_charlist [] z", "show ?case"], ["proof (prove)\nusing this:\n  lleq_charlist (y # ys) []\n  lleq_charlist [] z\n\ngoal (1 subgoal):\n 1. lleq_charlist (y # ys) z", "by auto"], ["proof (state)\nthis:\n  lleq_charlist (y # ys) z\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n                   \\<Longrightarrow> lleq_charlist ys z;\n        lleq_charlist (y # ys) (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n                   \\<Longrightarrow> lleq_charlist ys z;\n        lleq_charlist (y # ys) (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z", "case (BothCons x xs y ys z)"], ["proof (state)\nthis:\n  \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs ?z\\<rbrakk>\n  \\<Longrightarrow> lleq_charlist ys ?z\n  lleq_charlist (y # ys) (x # xs)\n  lleq_charlist (x # xs) z\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z.\n       \\<lbrakk>\\<And>z.\n                   \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n                   \\<Longrightarrow> lleq_charlist ys z;\n        lleq_charlist (y # ys) (x # xs); lleq_charlist (x # xs) z\\<rbrakk>\n       \\<Longrightarrow> lleq_charlist (y # ys) z", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs ?z\\<rbrakk>\n  \\<Longrightarrow> lleq_charlist ys ?z\n  lleq_charlist (y # ys) (x # xs)\n  lleq_charlist (x # xs) z", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs ?z\\<rbrakk>\n  \\<Longrightarrow> lleq_charlist ys ?z\n  lleq_charlist (y # ys) (x # xs)\n  lleq_charlist (x # xs) z\n\ngoal (1 subgoal):\n 1. lleq_charlist (y # ys) z", "using lleq_head[of xs ys x z]"], ["proof (prove)\nusing this:\n  \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs ?z\\<rbrakk>\n  \\<Longrightarrow> lleq_charlist ys ?z\n  lleq_charlist (y # ys) (x # xs)\n  lleq_charlist (x # xs) z\n  \\<lbrakk>\\<And>z. lleq_charlist xs z \\<Longrightarrow> lleq_charlist ys z;\n   lleq_charlist ys xs; lleq_charlist (x # xs) z\\<rbrakk>\n  \\<Longrightarrow> lleq_charlist (x # ys) z\n\ngoal (1 subgoal):\n 1. lleq_charlist (y # ys) z", "apply(cases \"x = y\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < x; x \\<noteq> y;\n     \\<And>z.\n        \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n        \\<Longrightarrow> lleq_charlist ys z;\n     lleq_charlist (x # xs) z;\n     lleq_charlist ys xs \\<Longrightarrow> lleq_charlist (x # ys) z\\<rbrakk>\n    \\<Longrightarrow> lleq_charlist (y # ys) z", "apply(cases z, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>y < x; x \\<noteq> y;\n        \\<And>z.\n           \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n           \\<Longrightarrow> lleq_charlist ys z;\n        if x = a then lleq_charlist xs list else x < a;\n        lleq_charlist ys xs \\<Longrightarrow>\n        if x = a then lleq_charlist ys list else x < a;\n        z = a # list; y \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> y < a", "subgoal for a list"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < x; x \\<noteq> y;\n     \\<And>z.\n        \\<lbrakk>lleq_charlist ys xs; lleq_charlist xs z\\<rbrakk>\n        \\<Longrightarrow> lleq_charlist ys z;\n     if x = a then lleq_charlist xs list else x < a;\n     lleq_charlist ys xs \\<Longrightarrow>\n     if x = a then lleq_charlist ys list else x < a;\n     z = a # list; y \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> y < a", "by(cases \"x = a\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lleq_charlist (y # ys) z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lleq_antisym:\n  fixes x y\n  shows \"lleq_charlist x y \\<Longrightarrow> lleq_charlist y x \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lleq_charlist x y; lleq_charlist y x\\<rbrakk>\n    \\<Longrightarrow> x = y", "proof(induction rule: list_induct2')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>lleq_charlist [] []; lleq_charlist [] []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>lleq_charlist (x # xs) [];\n        lleq_charlist [] (x # xs)\\<rbrakk>\n       \\<Longrightarrow> x # xs = []\n 3. \\<And>y ys.\n       \\<lbrakk>lleq_charlist [] (y # ys);\n        lleq_charlist (y # ys) []\\<rbrakk>\n       \\<Longrightarrow> [] = y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>lleq_charlist xs ys; lleq_charlist ys xs\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        lleq_charlist (x # xs) (y # ys);\n        lleq_charlist (y # ys) (x # xs)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (LeftCons x xs)"], ["proof (state)\nthis:\n  lleq_charlist (x # xs) []\n  lleq_charlist [] (x # xs)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>lleq_charlist [] []; lleq_charlist [] []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>lleq_charlist (x # xs) [];\n        lleq_charlist [] (x # xs)\\<rbrakk>\n       \\<Longrightarrow> x # xs = []\n 3. \\<And>y ys.\n       \\<lbrakk>lleq_charlist [] (y # ys);\n        lleq_charlist (y # ys) []\\<rbrakk>\n       \\<Longrightarrow> [] = y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>lleq_charlist xs ys; lleq_charlist ys xs\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        lleq_charlist (x # xs) (y # ys);\n        lleq_charlist (y # ys) (x # xs)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "then"], ["proof (chain)\npicking this:\n  lleq_charlist (x # xs) []\n  lleq_charlist [] (x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  lleq_charlist (x # xs) []\n  lleq_charlist [] (x # xs)\n\ngoal (1 subgoal):\n 1. x # xs = []", "by(cases \"xs=y\",auto)"], ["proof (state)\nthis:\n  x # xs = []\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lleq_charlist [] []; lleq_charlist [] []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>y ys.\n       \\<lbrakk>lleq_charlist [] (y # ys);\n        lleq_charlist (y # ys) []\\<rbrakk>\n       \\<Longrightarrow> [] = y # ys\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>lleq_charlist xs ys; lleq_charlist ys xs\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        lleq_charlist (x # xs) (y # ys);\n        lleq_charlist (y # ys) (x # xs)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>lleq_charlist [] []; lleq_charlist [] []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>y ys.\n       \\<lbrakk>lleq_charlist [] (y # ys);\n        lleq_charlist (y # ys) []\\<rbrakk>\n       \\<Longrightarrow> [] = y # ys\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>lleq_charlist xs ys; lleq_charlist ys xs\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        lleq_charlist (x # xs) (y # ys);\n        lleq_charlist (y # ys) (x # xs)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (RightCons y ys)"], ["proof (state)\nthis:\n  lleq_charlist [] (y # ys)\n  lleq_charlist (y # ys) []\n\ngoal (3 subgoals):\n 1. \\<lbrakk>lleq_charlist [] []; lleq_charlist [] []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>y ys.\n       \\<lbrakk>lleq_charlist [] (y # ys);\n        lleq_charlist (y # ys) []\\<rbrakk>\n       \\<Longrightarrow> [] = y # ys\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>lleq_charlist xs ys; lleq_charlist ys xs\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        lleq_charlist (x # xs) (y # ys);\n        lleq_charlist (y # ys) (x # xs)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "then"], ["proof (chain)\npicking this:\n  lleq_charlist [] (y # ys)\n  lleq_charlist (y # ys) []", "show ?case"], ["proof (prove)\nusing this:\n  lleq_charlist [] (y # ys)\n  lleq_charlist (y # ys) []\n\ngoal (1 subgoal):\n 1. [] = y # ys", "by(cases \"x=ys\",auto)"], ["proof (state)\nthis:\n  [] = y # ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lleq_charlist [] []; lleq_charlist [] []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>lleq_charlist xs ys; lleq_charlist ys xs\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        lleq_charlist (x # xs) (y # ys);\n        lleq_charlist (y # ys) (x # xs)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>lleq_charlist [] []; lleq_charlist [] []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>lleq_charlist xs ys; lleq_charlist ys xs\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        lleq_charlist (x # xs) (y # ys);\n        lleq_charlist (y # ys) (x # xs)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (BothCons x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>lleq_charlist xs ys; lleq_charlist ys xs\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  lleq_charlist (x # xs) (y # ys)\n  lleq_charlist (y # ys) (x # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lleq_charlist [] []; lleq_charlist [] []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>lleq_charlist xs ys; lleq_charlist ys xs\\<rbrakk>\n                \\<Longrightarrow> xs = ys;\n        lleq_charlist (x # xs) (y # ys);\n        lleq_charlist (y # ys) (x # xs)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>lleq_charlist xs ys; lleq_charlist ys xs\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  lleq_charlist (x # xs) (y # ys)\n  lleq_charlist (y # ys) (x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>lleq_charlist xs ys; lleq_charlist ys xs\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  lleq_charlist (x # xs) (y # ys)\n  lleq_charlist (y # ys) (x # xs)\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "by(cases \"x=y\", auto)"], ["proof (state)\nthis:\n  x # xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lleq_charlist [] []; lleq_charlist [] []\\<rbrakk>\n    \\<Longrightarrow> [] = []", "qed (auto)"], ["", "lemma lleq_dichotomy:\n  fixes x y\n  shows \"lleq_charlist x y \\<or> lleq_charlist y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lleq_charlist x y \\<or> lleq_charlist y x", "by(induction rule: List.list_induct2',auto)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fin_string, linorder_class)", "apply(standard)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "unfolding less_eq_fin_string_def less_fin_string_def"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       map_fun Rep_fin_string (map_fun Rep_fin_string id) less_charlist x\n        y =\n       (map_fun Rep_fin_string (map_fun Rep_fin_string id) lleq_charlist x\n         y \\<and>\n        \\<not> map_fun Rep_fin_string (map_fun Rep_fin_string id)\n                lleq_charlist y x)\n 2. \\<And>x.\n       map_fun Rep_fin_string (map_fun Rep_fin_string id) lleq_charlist x x\n 3. \\<And>x y z.\n       \\<lbrakk>map_fun Rep_fin_string (map_fun Rep_fin_string id)\n                 lleq_charlist x y;\n        map_fun Rep_fin_string (map_fun Rep_fin_string id) lleq_charlist y\n         z\\<rbrakk>\n       \\<Longrightarrow> map_fun Rep_fin_string (map_fun Rep_fin_string id)\n                          lleq_charlist x z\n 4. \\<And>x y.\n       \\<lbrakk>map_fun Rep_fin_string (map_fun Rep_fin_string id)\n                 lleq_charlist x y;\n        map_fun Rep_fin_string (map_fun Rep_fin_string id) lleq_charlist y\n         x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y.\n       map_fun Rep_fin_string (map_fun Rep_fin_string id) lleq_charlist x\n        y \\<or>\n       map_fun Rep_fin_string (map_fun Rep_fin_string id) lleq_charlist y x", "apply (auto simp add: lleq_less lleq_refl lleq_trans lleq_dichotomy)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>lleq_charlist (Rep_fin_string x) (Rep_fin_string y);\n        lleq_charlist (Rep_fin_string y) (Rep_fin_string x)\\<rbrakk>\n       \\<Longrightarrow> x = y", "using lleq_antisym less_eq_fin_string_def less_fin_string_def Rep_fin_string_inject"], ["proof (prove)\nusing this:\n  \\<lbrakk>lleq_charlist ?x ?y; lleq_charlist ?y ?x\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  (\\<le>) \\<equiv>\n  map_fun Rep_fin_string (map_fun Rep_fin_string id) lleq_charlist\n  (<) \\<equiv>\n  map_fun Rep_fin_string (map_fun Rep_fin_string id) less_charlist\n  (Rep_fin_string ?x = Rep_fin_string ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>lleq_charlist (Rep_fin_string x) (Rep_fin_string y);\n        lleq_charlist (Rep_fin_string y) (Rep_fin_string x)\\<rbrakk>\n       \\<Longrightarrow> x = y", "by blast"], ["", "end"], ["", "fun string_expose::\"string \\<Rightarrow> (unit + (char * string))\"\n  where \"string_expose Nil = Inl ()\"\n  | \"string_expose (c#cs) = Inr(c,cs)\""], ["", "fun string_cons::\"char \\<Rightarrow> string \\<Rightarrow> string\"\n  where \"string_cons c s = (if length s \\<ge> MAX_STR then s else c # s)\""], ["", "lift_definition fin_string_empty::fin_string is \"''''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [] \\<le> MAX_STR", "by(auto simp add: max_str)"], ["", "lift_definition fin_string_cons::\"char \\<Rightarrow> fin_string \\<Rightarrow> fin_string\" is \"string_cons\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>char list.\n       length list \\<le> MAX_STR \\<Longrightarrow>\n       length (string_cons char list) \\<le> MAX_STR", "by auto"], ["", "lift_definition fin_string_expose::\"fin_string \\<Rightarrow> (unit + (char*fin_string))\" is string_expose"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       length list \\<le> MAX_STR \\<Longrightarrow>\n       pred_sum top (pred_prod top (\\<lambda>s. length s \\<le> MAX_STR))\n        (string_expose list)", "apply(auto simp add: dual_order.trans less_imp_le pred_sum.simps string_expose.elims)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       \\<lbrakk>length list \\<le> MAX_STR;\n        \\<forall>a b.\n           string_expose list = Inr (a, b) \\<longrightarrow>\n           \\<not> length b \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> string_expose list = Inl ()", "by (metis dual_order.trans impossible_Cons le_cases string_expose.elims)"], ["", "text\\<open>Helper functions for enum typeclass instance\\<close>"], ["", "fun fin_string_upto :: \"nat \\<Rightarrow> fin_string list\"\n  where \n  \"fin_string_upto 0 = [fin_string_empty]\"\n| \"fin_string_upto (Suc k) = \n (let r = fin_string_upto k in\n  let ab =  (enum_class.enum::char list) in\n  fin_string_empty # concat (map (\\<lambda> c. map (\\<lambda>s. fin_string_cons c  s) r) ab))\""], ["", "lemma mem_appL:\"List.member L1 x \\<Longrightarrow> List.member (L1 @ L2) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member L1 x \\<Longrightarrow> List.member (L1 @ L2) x", "apply(induction L1 arbitrary: L2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>L2. List.member [] x \\<Longrightarrow> List.member ([] @ L2) x\n 2. \\<And>a L1 L2.\n       \\<lbrakk>\\<And>L2.\n                   List.member L1 x \\<Longrightarrow>\n                   List.member (L1 @ L2) x;\n        List.member (a # L1) x\\<rbrakk>\n       \\<Longrightarrow> List.member ((a # L1) @ L2) x", "by(auto simp add: member_rec)"], ["", "lemma mem_appR:\"List.member L2 x \\<Longrightarrow> List.member (L1 @ L2) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member L2 x \\<Longrightarrow> List.member (L1 @ L2) x", "apply(induction L1 arbitrary: L2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>L2. List.member L2 x \\<Longrightarrow> List.member ([] @ L2) x\n 2. \\<And>a L1 L2.\n       \\<lbrakk>\\<And>L2.\n                   List.member L2 x \\<Longrightarrow>\n                   List.member (L1 @ L2) x;\n        List.member L2 x\\<rbrakk>\n       \\<Longrightarrow> List.member ((a # L1) @ L2) x", "by(auto simp add: member_rec)"], ["", "lemma mem_app_or:\"List.member (L1 @ L2) x = List.member L1 x \\<or> List.member L2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member (L1 @ L2) x = List.member L1 x \\<or> List.member L2 x", "unfolding member_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (L1 @ L2)) = (x \\<in> set L1) \\<or> x \\<in> set L2", "by auto"], ["", "lemma fin_string_nil:\n  fixes n\n  shows \"List.member (fin_string_upto n) fin_string_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member (fin_string_upto n) fin_string_empty", "by(induction n, auto simp add: member_rec Let_def fin_string_empty_def)"], ["", "text\\<open>List of every string. Not practical for code generation but used to show strings are an enum\\<close>"], ["", "definition vals_def[code]:\"vals \\<equiv> fin_string_upto MAX_STR\""], ["", "definition fin_string_enum :: \"fin_string list\" \n  where \"fin_string_enum = vals\""], ["", "definition fin_string_enum_all :: \"(fin_string \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  where \"fin_string_enum_all = (\\<lambda> f. list_all f vals)\""], ["", "definition fin_string_enum_ex :: \"(fin_string \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  where \"fin_string_enum_ex = (\\<lambda> f. list_ex f vals)\""], ["", "text\\<open>Induct on the length of a bounded list, with access to index of element\\<close>"], ["", "lemma length_induct:\n  fixes P\n  assumes len:\"length L \\<le> MAX_STR\"\n  assumes BC:\"P [] 0\"\n  assumes IS:\"(\\<And>k x xs.  P xs k \\<Longrightarrow> P ((x # xs)) (Suc k))\"\n  shows \"P L (length L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P L (length L)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P L (length L)", "have \"\\<And>k.  length L = k \\<Longrightarrow> k \\<le> MAX_STR \\<Longrightarrow> P L (length L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>length L = k; k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P L (length L)", "proof (induction L)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>length [] = k; k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P [] (length [])\n 2. \\<And>a L k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>length L = k; k \\<le> MAX_STR\\<rbrakk>\n                   \\<Longrightarrow> P L (length L);\n        length (a # L) = k; k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P (a # L) (length (a # L))", "case Nil"], ["proof (state)\nthis:\n  length [] = k\n  k \\<le> MAX_STR\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>length [] = k; k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P [] (length [])\n 2. \\<And>a L k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>length L = k; k \\<le> MAX_STR\\<rbrakk>\n                   \\<Longrightarrow> P L (length L);\n        length (a # L) = k; k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P (a # L) (length (a # L))", "then"], ["proof (chain)\npicking this:\n  length [] = k\n  k \\<le> MAX_STR", "show ?case"], ["proof (prove)\nusing this:\n  length [] = k\n  k \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. P [] (length [])", "using BC"], ["proof (prove)\nusing this:\n  length [] = k\n  k \\<le> MAX_STR\n  P [] 0\n\ngoal (1 subgoal):\n 1. P [] (length [])", "by auto"], ["proof (state)\nthis:\n  P [] (length [])\n\ngoal (1 subgoal):\n 1. \\<And>a L k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>length L = k; k \\<le> MAX_STR\\<rbrakk>\n                   \\<Longrightarrow> P L (length L);\n        length (a # L) = k; k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P (a # L) (length (a # L))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>length L = k; k \\<le> MAX_STR\\<rbrakk>\n                   \\<Longrightarrow> P L (length L);\n        length (a # L) = k; k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P (a # L) (length (a # L))", "case (Cons a L)"], ["proof (state)\nthis:\n  \\<lbrakk>length L = ?k; ?k \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> P L (length L)\n  length (a # L) = k\n  k \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. \\<And>a L k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>length L = k; k \\<le> MAX_STR\\<rbrakk>\n                   \\<Longrightarrow> P L (length L);\n        length (a # L) = k; k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P (a # L) (length (a # L))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length L = ?k; ?k \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> P L (length L)\n  length (a # L) = k\n  k \\<le> MAX_STR", "have it:\"P (L) (length L)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length L = ?k; ?k \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> P L (length L)\n  length (a # L) = k\n  k \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. P L (length L)", "using less_imp_le"], ["proof (prove)\nusing this:\n  \\<lbrakk>length L = ?k; ?k \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> P L (length L)\n  length (a # L) = k\n  k \\<le> MAX_STR\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. P L (length L)", "by fastforce"], ["proof (state)\nthis:\n  P L (length L)\n\ngoal (1 subgoal):\n 1. \\<And>a L k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>length L = k; k \\<le> MAX_STR\\<rbrakk>\n                   \\<Longrightarrow> P L (length L);\n        length (a # L) = k; k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P (a # L) (length (a # L))", "then"], ["proof (chain)\npicking this:\n  P L (length L)", "show ?case"], ["proof (prove)\nusing this:\n  P L (length L)\n\ngoal (1 subgoal):\n 1. P (a # L) (length (a # L))", "using IS[OF it, of a]"], ["proof (prove)\nusing this:\n  P L (length L)\n  P (a # L) (Suc (length L))\n\ngoal (1 subgoal):\n 1. P (a # L) (length (a # L))", "by (auto)"], ["proof (state)\nthis:\n  P (a # L) (length (a # L))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>length L = ?k; ?k \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> P L (length L)\n\ngoal (1 subgoal):\n 1. P L (length L)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length L = ?k; ?k \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> P L (length L)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length L = ?k; ?k \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> P L (length L)\n\ngoal (1 subgoal):\n 1. P L (length L)", "using BC IS len"], ["proof (prove)\nusing this:\n  \\<lbrakk>length L = ?k; ?k \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> P L (length L)\n  P [] 0\n  P ?xs ?k \\<Longrightarrow> P (?x # ?xs) (Suc ?k)\n  length L \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. P L (length L)", "by auto"], ["proof (state)\nthis:\n  P L (length L)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Induct on length of fin-string\\<close>"], ["", "lemma ilength_induct:\n  fixes P\n  assumes BC:\"P fin_string_empty 0\"\n  assumes IS:\"(\\<And>k x xs.  P xs k \\<Longrightarrow> P (Abs_fin_string (x # Rep_fin_string xs)) (Suc k))\"\n  shows  \"P L (ilength L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P L (ilength L)", "apply(cases L)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>L = Abs_fin_string y;\n        y \\<in> {s. length s \\<le> MAX_STR}\\<rbrakk>\n       \\<Longrightarrow> P L (ilength L)", "apply(unfold ilength_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>L = Abs_fin_string y;\n        y \\<in> {s. length s \\<le> MAX_STR}\\<rbrakk>\n       \\<Longrightarrow> P L (map_fun Rep_fin_string id length L)", "apply(auto simp add: Abs_fin_string_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>L = Abs_fin_string y; length y \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P (Abs_fin_string y) (length y)", "subgoal for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L = Abs_fin_string y; length y \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string y) (length y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>L = Abs_fin_string y; length y \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string y) (length y)", "assume a1:\"L = Abs_fin_string y\""], ["proof (state)\nthis:\n  L = Abs_fin_string y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L = Abs_fin_string y; length y \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string y) (length y)", "assume a2:\" length y \\<le> MAX_STR \""], ["proof (state)\nthis:\n  length y \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L = Abs_fin_string y; length y \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string y) (length y)", "have main:\"\\<And>k. L = Abs_fin_string y \\<Longrightarrow> length y = k \\<Longrightarrow> k \\<le> MAX_STR \n        \\<Longrightarrow> P (Abs_fin_string y) (length y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>L = Abs_fin_string y; length y = k; k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P (Abs_fin_string y) (length y)", "subgoal for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L = Abs_fin_string y; length y = k; k \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string y) (length y)", "apply(induction y arbitrary: k L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k L.\n       \\<lbrakk>L = Abs_fin_string []; length [] = k;\n        k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P (Abs_fin_string []) (length [])\n 2. \\<And>a y k L.\n       \\<lbrakk>\\<And>k L.\n                   \\<lbrakk>L = Abs_fin_string y; length y = k;\n                    k \\<le> MAX_STR\\<rbrakk>\n                   \\<Longrightarrow> P (Abs_fin_string y) (length y);\n        L = Abs_fin_string (a # y); length (a # y) = k;\n        k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P (Abs_fin_string (a # y)) (length (a # y))", "subgoal for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L_ = Abs_fin_string []; length [] = k; k \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string []) (length [])", "using BC"], ["proof (prove)\nusing this:\n  P fin_string_empty 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L_ = Abs_fin_string []; length [] = k; k \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string []) (length [])", "unfolding fin_string_empty_def"], ["proof (prove)\nusing this:\n  P (Abs_fin_string []) 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L_ = Abs_fin_string []; length [] = k; k \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string []) (length [])", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y k L.\n       \\<lbrakk>\\<And>k L.\n                   \\<lbrakk>L = Abs_fin_string y; length y = k;\n                    k \\<le> MAX_STR\\<rbrakk>\n                   \\<Longrightarrow> P (Abs_fin_string y) (length y);\n        L = Abs_fin_string (a # y); length (a # y) = k;\n        k \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> P (Abs_fin_string (a # y)) (length (a # y))", "subgoal for a y k L"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k L.\n                \\<lbrakk>L = Abs_fin_string y; length y = k;\n                 k \\<le> MAX_STR\\<rbrakk>\n                \\<Longrightarrow> P (Abs_fin_string y) (length y);\n     L = Abs_fin_string (a # y); length (a # y) = k;\n     k \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string (a # y)) (length (a # y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k L.\n                \\<lbrakk>L = Abs_fin_string y; length y = k;\n                 k \\<le> MAX_STR\\<rbrakk>\n                \\<Longrightarrow> P (Abs_fin_string y) (length y);\n     L = Abs_fin_string (a # y); length (a # y) = k;\n     k \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string (a # y)) (length (a # y))", "assume IH:\"(\\<And>k L. L = Abs_fin_string y \\<Longrightarrow> length y = k \\<Longrightarrow> k \\<le> MAX_STR \n            \\<Longrightarrow> P (Abs_fin_string y) (length y))\""], ["proof (state)\nthis:\n  \\<lbrakk>?L = Abs_fin_string y; length y = ?k; ?k \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> P (Abs_fin_string y) (length y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k L.\n                \\<lbrakk>L = Abs_fin_string y; length y = k;\n                 k \\<le> MAX_STR\\<rbrakk>\n                \\<Longrightarrow> P (Abs_fin_string y) (length y);\n     L = Abs_fin_string (a # y); length (a # y) = k;\n     k \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string (a # y)) (length (a # y))", "assume L:\"L = Abs_fin_string (a # y)\""], ["proof (state)\nthis:\n  L = Abs_fin_string (a # y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k L.\n                \\<lbrakk>L = Abs_fin_string y; length y = k;\n                 k \\<le> MAX_STR\\<rbrakk>\n                \\<Longrightarrow> P (Abs_fin_string y) (length y);\n     L = Abs_fin_string (a # y); length (a # y) = k;\n     k \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string (a # y)) (length (a # y))", "assume l:\"length (a # y) = k\""], ["proof (state)\nthis:\n  length (a # y) = k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k L.\n                \\<lbrakk>L = Abs_fin_string y; length y = k;\n                 k \\<le> MAX_STR\\<rbrakk>\n                \\<Longrightarrow> P (Abs_fin_string y) (length y);\n     L = Abs_fin_string (a # y); length (a # y) = k;\n     k \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string (a # y)) (length (a # y))", "assume str:\"k \\<le> MAX_STR\""], ["proof (state)\nthis:\n  k \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k L.\n                \\<lbrakk>L = Abs_fin_string y; length y = k;\n                 k \\<le> MAX_STR\\<rbrakk>\n                \\<Longrightarrow> P (Abs_fin_string y) (length y);\n     L = Abs_fin_string (a # y); length (a # y) = k;\n     k \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string (a # y)) (length (a # y))", "have yLen:\"length y < MAX_STR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length y < MAX_STR", "using l str"], ["proof (prove)\nusing this:\n  length (a # y) = k\n  k \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. length y < MAX_STR", "by auto"], ["proof (state)\nthis:\n  length y < MAX_STR\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k L.\n                \\<lbrakk>L = Abs_fin_string y; length y = k;\n                 k \\<le> MAX_STR\\<rbrakk>\n                \\<Longrightarrow> P (Abs_fin_string y) (length y);\n     L = Abs_fin_string (a # y); length (a # y) = k;\n     k \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string (a # y)) (length (a # y))", "have it:\"P (Abs_fin_string y) (length y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (Abs_fin_string y) (length y)", "using IH[of \"Abs_fin_string y\" \"k-1\", OF refl]"], ["proof (prove)\nusing this:\n  \\<lbrakk>length y = k - 1; k - 1 \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> P (Abs_fin_string y) (length y)\n\ngoal (1 subgoal):\n 1. P (Abs_fin_string y) (length y)", "using L l str"], ["proof (prove)\nusing this:\n  \\<lbrakk>length y = k - 1; k - 1 \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> P (Abs_fin_string y) (length y)\n  L = Abs_fin_string (a # y)\n  length (a # y) = k\n  k \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. P (Abs_fin_string y) (length y)", "by auto"], ["proof (state)\nthis:\n  P (Abs_fin_string y) (length y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k L.\n                \\<lbrakk>L = Abs_fin_string y; length y = k;\n                 k \\<le> MAX_STR\\<rbrakk>\n                \\<Longrightarrow> P (Abs_fin_string y) (length y);\n     L = Abs_fin_string (a # y); length (a # y) = k;\n     k \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string (a # y)) (length (a # y))", "show  \"P (Abs_fin_string (a # y)) (length (a # y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (Abs_fin_string (a # y)) (length (a # y))", "using IS[OF it, of a]"], ["proof (prove)\nusing this:\n  P (Abs_fin_string (a # Rep_fin_string (Abs_fin_string y)))\n   (Suc (length y))\n\ngoal (1 subgoal):\n 1. P (Abs_fin_string (a # y)) (length (a # y))", "apply (auto simp add: fin_string_cons_def Abs_fin_string_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (Abs_fin_string (a # Rep_fin_string (Abs_fin_string y)))\n     (Suc (length y)) \\<Longrightarrow>\n    P (Abs_fin_string (a # y)) (Suc (length y))", "apply(cases \"MAX_STR \\<le> length (Rep_fin_string (Abs_fin_string y))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P (Abs_fin_string (a # Rep_fin_string (Abs_fin_string y)))\n              (Suc (length y));\n     MAX_STR \\<le> length (Rep_fin_string (Abs_fin_string y))\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string (a # y)) (Suc (length y))\n 2. \\<lbrakk>P (Abs_fin_string (a # Rep_fin_string (Abs_fin_string y)))\n              (Suc (length y));\n     \\<not> MAX_STR\n            \\<le> length (Rep_fin_string (Abs_fin_string y))\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string (a # y)) (Suc (length y))", "using yLen"], ["proof (prove)\nusing this:\n  length y < MAX_STR\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P (Abs_fin_string (a # Rep_fin_string (Abs_fin_string y)))\n              (Suc (length y));\n     MAX_STR \\<le> length (Rep_fin_string (Abs_fin_string y))\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string (a # y)) (Suc (length y))\n 2. \\<lbrakk>P (Abs_fin_string (a # Rep_fin_string (Abs_fin_string y)))\n              (Suc (length y));\n     \\<not> MAX_STR\n            \\<le> length (Rep_fin_string (Abs_fin_string y))\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string (a # y)) (Suc (length y))", "by(auto simp add: l yLen Abs_fin_string_inverse)"], ["proof (state)\nthis:\n  P (Abs_fin_string (a # y)) (length (a # y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>L = Abs_fin_string y; length y = ?k; ?k \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> P (Abs_fin_string y) (length y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L = Abs_fin_string y; length y \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> P (Abs_fin_string y) (length y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (Abs_fin_string y) (length y)", "apply(rule main)"], ["proof (prove)\ngoal (3 subgoals):\n 1. L = Abs_fin_string y\n 2. length y = ?k\n 3. ?k \\<le> MAX_STR", "using BC IS a1 a2"], ["proof (prove)\nusing this:\n  P fin_string_empty 0\n  P ?xs ?k \\<Longrightarrow>\n  P (Abs_fin_string (?x # Rep_fin_string ?xs)) (Suc ?k)\n  L = Abs_fin_string y\n  length y \\<le> MAX_STR\n\ngoal (3 subgoals):\n 1. L = Abs_fin_string y\n 2. length y = ?k\n 3. ?k \\<le> MAX_STR", "by auto"], ["proof (state)\nthis:\n  P (Abs_fin_string y) (length y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma enum_chars:\"set (enum_class.enum::char list)= UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set enum_class.enum = UNIV", "using Enum.enum_class.enum_UNIV"], ["proof (prove)\nusing this:\n  set enum_class.enum = UNIV\n\ngoal (1 subgoal):\n 1. set enum_class.enum = UNIV", "by auto"], ["", "lemma member_concat:\"List.member (concat LL) x = (\\<exists>L. List.member LL L \\<and> List.member L x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member (concat LL) x =\n    (\\<exists>L. List.member LL L \\<and> List.member L x)", "by(auto simp add: member_def)"], ["", "text\\<open>fin-string-upto k enumerates all strings up to length $min(k,MAX\\_STR)$\\<close>"], ["", "lemma fin_string_length:\n  fixes L::string\n  assumes len:\"length L \\<le> k\"\n  assumes Len:\"length L \\<le> MAX_STR\"\n  shows \"List.member (fin_string_upto k) (Abs_fin_string L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member (fin_string_upto k) (Abs_fin_string L)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. List.member (fin_string_upto k) (Abs_fin_string L)", "have BC:\"\\<forall>j\\<ge>0. 0 \\<le> MAX_STR \\<longrightarrow> length [] = 0 \\<longrightarrow> \n    List.member (fin_string_upto j) (Abs_fin_string [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>0.\n       (0::'a) \\<le> MAX_STR \\<longrightarrow>\n       length [] = 0 \\<longrightarrow>\n       List.member (fin_string_upto j) (Abs_fin_string [])", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       (0::'a) \\<le> MAX_STR \\<Longrightarrow>\n       List.member (fin_string_upto j) (Abs_fin_string [])", "subgoal for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> MAX_STR \\<Longrightarrow>\n    List.member (fin_string_upto j) (Abs_fin_string [])", "apply(cases j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> MAX_STR; j = 0\\<rbrakk>\n    \\<Longrightarrow> List.member (fin_string_upto j) (Abs_fin_string [])\n 2. \\<And>nat.\n       \\<lbrakk>(0::'a) \\<le> MAX_STR; j = Suc nat\\<rbrakk>\n       \\<Longrightarrow> List.member (fin_string_upto j) (Abs_fin_string [])", "by (auto simp add: fin_string_empty_def member_rec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>0.\n     (0::?'a1) \\<le> MAX_STR \\<longrightarrow>\n     length [] = 0 \\<longrightarrow>\n     List.member (fin_string_upto j) (Abs_fin_string [])\n\ngoal (1 subgoal):\n 1. List.member (fin_string_upto k) (Abs_fin_string L)", "have IS:\"(\\<And>k x xs.\n      \\<forall>j\\<ge>k. k\\<le>MAX_STR \\<longrightarrow> length xs=k \\<longrightarrow> List.member (fin_string_upto j) (Abs_fin_string xs)\\<Longrightarrow>\n      \\<forall>j\\<ge>Suc k. Suc k \\<le> MAX_STR \\<longrightarrow> length (x # xs) = Suc k \n        \\<longrightarrow> List.member (fin_string_upto j) (Abs_fin_string (x # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k x xs.\n       \\<forall>j\\<ge>k.\n          k \\<le> MAX_STR \\<longrightarrow>\n          length xs = k \\<longrightarrow>\n          List.member (fin_string_upto j)\n           (Abs_fin_string xs) \\<Longrightarrow>\n       \\<forall>j\\<ge>Suc k.\n          Suc k \\<le> MAX_STR \\<longrightarrow>\n          length (x # xs) = Suc k \\<longrightarrow>\n          List.member (fin_string_upto j) (Abs_fin_string (x # xs))", "subgoal for k x xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>k.\n       k \\<le> MAX_STR \\<longrightarrow>\n       length xs = k \\<longrightarrow>\n       List.member (fin_string_upto j) (Abs_fin_string xs) \\<Longrightarrow>\n    \\<forall>j\\<ge>Suc k.\n       Suc k \\<le> MAX_STR \\<longrightarrow>\n       length (x # xs) = Suc k \\<longrightarrow>\n       List.member (fin_string_upto j) (Abs_fin_string (x # xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>k.\n       k \\<le> MAX_STR \\<longrightarrow>\n       length xs = k \\<longrightarrow>\n       List.member (fin_string_upto j) (Abs_fin_string xs) \\<Longrightarrow>\n    \\<forall>j\\<ge>Suc k.\n       Suc k \\<le> MAX_STR \\<longrightarrow>\n       length (x # xs) = Suc k \\<longrightarrow>\n       List.member (fin_string_upto j) (Abs_fin_string (x # xs))", "assume \"\\<forall>j\\<ge>k. k \\<le> MAX_STR \\<longrightarrow> length xs = k \n        \\<longrightarrow> List.member (fin_string_upto j) (Abs_fin_string xs)\""], ["proof (state)\nthis:\n  \\<forall>j\\<ge>k.\n     k \\<le> MAX_STR \\<longrightarrow>\n     length xs = k \\<longrightarrow>\n     List.member (fin_string_upto j) (Abs_fin_string xs)\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>k.\n       k \\<le> MAX_STR \\<longrightarrow>\n       length xs = k \\<longrightarrow>\n       List.member (fin_string_upto j) (Abs_fin_string xs) \\<Longrightarrow>\n    \\<forall>j\\<ge>Suc k.\n       Suc k \\<le> MAX_STR \\<longrightarrow>\n       length (x # xs) = Suc k \\<longrightarrow>\n       List.member (fin_string_upto j) (Abs_fin_string (x # xs))", "then"], ["proof (chain)\npicking this:\n  \\<forall>j\\<ge>k.\n     k \\<le> MAX_STR \\<longrightarrow>\n     length xs = k \\<longrightarrow>\n     List.member (fin_string_upto j) (Abs_fin_string xs)", "have IH:\"\\<And>j. j\\<ge> k \\<Longrightarrow> k \\<le> MAX_STR \\<Longrightarrow> length xs = k \n        \\<Longrightarrow> List.member (fin_string_upto j) (Abs_fin_string xs)\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<ge>k.\n     k \\<le> MAX_STR \\<longrightarrow>\n     length xs = k \\<longrightarrow>\n     List.member (fin_string_upto j) (Abs_fin_string xs)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>k \\<le> j; k \\<le> MAX_STR; length xs = k\\<rbrakk>\n       \\<Longrightarrow> List.member (fin_string_upto j) (Abs_fin_string xs)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>k \\<le> ?j1; k \\<le> MAX_STR; length xs = k\\<rbrakk>\n  \\<Longrightarrow> List.member (fin_string_upto ?j1) (Abs_fin_string xs)\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>k.\n       k \\<le> MAX_STR \\<longrightarrow>\n       length xs = k \\<longrightarrow>\n       List.member (fin_string_upto j) (Abs_fin_string xs) \\<Longrightarrow>\n    \\<forall>j\\<ge>Suc k.\n       Suc k \\<le> MAX_STR \\<longrightarrow>\n       length (x # xs) = Suc k \\<longrightarrow>\n       List.member (fin_string_upto j) (Abs_fin_string (x # xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>Suc k.\n       Suc k \\<le> MAX_STR \\<longrightarrow>\n       length (x # xs) = Suc k \\<longrightarrow>\n       List.member (fin_string_upto j) (Abs_fin_string (x # xs))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>Suc (length xs) \\<le> j; Suc (length xs) \\<le> MAX_STR;\n        k = length xs\\<rbrakk>\n       \\<Longrightarrow> List.member (fin_string_upto j)\n                          (Abs_fin_string (x # xs))", "subgoal for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length xs) \\<le> j; Suc (length xs) \\<le> MAX_STR;\n     k = length xs\\<rbrakk>\n    \\<Longrightarrow> List.member (fin_string_upto j)\n                       (Abs_fin_string (x # xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length xs) \\<le> j; Suc (length xs) \\<le> MAX_STR;\n     k = length xs\\<rbrakk>\n    \\<Longrightarrow> List.member (fin_string_upto j)\n                       (Abs_fin_string (x # xs))", "assume kj:\"Suc (length xs) \\<le> j\""], ["proof (state)\nthis:\n  Suc (length xs) \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length xs) \\<le> j; Suc (length xs) \\<le> MAX_STR;\n     k = length xs\\<rbrakk>\n    \\<Longrightarrow> List.member (fin_string_upto j)\n                       (Abs_fin_string (x # xs))", "assume sucMax:\"Suc (length xs) \\<le> MAX_STR\""], ["proof (state)\nthis:\n  Suc (length xs) \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length xs) \\<le> j; Suc (length xs) \\<le> MAX_STR;\n     k = length xs\\<rbrakk>\n    \\<Longrightarrow> List.member (fin_string_upto j)\n                       (Abs_fin_string (x # xs))", "assume ilen:\" k = length xs\""], ["proof (state)\nthis:\n  k = length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length xs) \\<le> j; Suc (length xs) \\<le> MAX_STR;\n     k = length xs\\<rbrakk>\n    \\<Longrightarrow> List.member (fin_string_upto j)\n                       (Abs_fin_string (x # xs))", "obtain jj where jj[simp]:\"j = Suc jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>jj. j = Suc jj \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using kj Suc_le_D"], ["proof (prove)\nusing this:\n  Suc (length xs) \\<le> j\n  Suc ?n \\<le> ?m' \\<Longrightarrow> \\<exists>m. ?m' = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>jj. j = Suc jj \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  j = Suc jj\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length xs) \\<le> j; Suc (length xs) \\<le> MAX_STR;\n     k = length xs\\<rbrakk>\n    \\<Longrightarrow> List.member (fin_string_upto j)\n                       (Abs_fin_string (x # xs))", "then"], ["proof (chain)\npicking this:\n  j = Suc jj", "have kMax:\"k < MAX_STR\""], ["proof (prove)\nusing this:\n  j = Suc jj\n\ngoal (1 subgoal):\n 1. k < MAX_STR", "using jj kj Suc_le_D ilen"], ["proof (prove)\nusing this:\n  j = Suc jj\n  j = Suc jj\n  Suc (length xs) \\<le> j\n  Suc ?n \\<le> ?m' \\<Longrightarrow> \\<exists>m. ?m' = Suc m\n  k = length xs\n\ngoal (1 subgoal):\n 1. k < MAX_STR", "by (simp add: less_eq_Suc_le sucMax)"], ["proof (state)\nthis:\n  k < MAX_STR\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length xs) \\<le> j; Suc (length xs) \\<le> MAX_STR;\n     k = length xs\\<rbrakk>\n    \\<Longrightarrow> List.member (fin_string_upto j)\n                       (Abs_fin_string (x # xs))", "have res:\"List.member (fin_string_upto (jj)) (Abs_fin_string xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member (fin_string_upto jj) (Abs_fin_string xs)", "using IH[of \"jj\"] kj jj ilen  Suc_leD sucMax"], ["proof (prove)\nusing this:\n  \\<lbrakk>k \\<le> jj; k \\<le> MAX_STR; length xs = k\\<rbrakk>\n  \\<Longrightarrow> List.member (fin_string_upto jj) (Abs_fin_string xs)\n  Suc (length xs) \\<le> j\n  j = Suc jj\n  k = length xs\n  Suc ?m \\<le> ?n \\<Longrightarrow> ?m \\<le> ?n\n  Suc (length xs) \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. List.member (fin_string_upto jj) (Abs_fin_string xs)", "by blast"], ["proof (state)\nthis:\n  List.member (fin_string_upto jj) (Abs_fin_string xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length xs) \\<le> j; Suc (length xs) \\<le> MAX_STR;\n     k = length xs\\<rbrakk>\n    \\<Longrightarrow> List.member (fin_string_upto j)\n                       (Abs_fin_string (x # xs))", "have neq:\"Abs_fin_string [] \\<noteq> Abs_fin_string (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_fin_string [] \\<noteq> Abs_fin_string (x # xs)", "using Abs_fin_string_inverse fin_string_empty.abs_eq fin_string_empty.rep_eq \n              len length_Cons list.distinct(1) mem_Collect_eq"], ["proof (prove)\nusing this:\n  ?y \\<in> {s. length s \\<le> MAX_STR} \\<Longrightarrow>\n  Rep_fin_string (Abs_fin_string ?y) = ?y\n  fin_string_empty = Abs_fin_string []\n  Rep_fin_string fin_string_empty = []\n  length L \\<le> k\n  length (?x # ?xs) = Suc (length ?xs)\n  [] \\<noteq> ?x21.0 # ?x22.0\n  (?a \\<in> Collect ?P) = ?P ?a\n\ngoal (1 subgoal):\n 1. Abs_fin_string [] \\<noteq> Abs_fin_string (x # xs)", "by (metis ilen sucMax)"], ["proof (state)\nthis:\n  Abs_fin_string [] \\<noteq> Abs_fin_string (x # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length xs) \\<le> j; Suc (length xs) \\<le> MAX_STR;\n     k = length xs\\<rbrakk>\n    \\<Longrightarrow> List.member (fin_string_upto j)\n                       (Abs_fin_string (x # xs))", "have univ:\" set enum_class.enum  = (UNIV::char set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set enum_class.enum = UNIV", "using enum_chars"], ["proof (prove)\nusing this:\n  set enum_class.enum = UNIV\n\ngoal (1 subgoal):\n 1. set enum_class.enum = UNIV", "by auto"], ["proof (state)\nthis:\n  set enum_class.enum = UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length xs) \\<le> j; Suc (length xs) \\<le> MAX_STR;\n     k = length xs\\<rbrakk>\n    \\<Longrightarrow> List.member (fin_string_upto j)\n                       (Abs_fin_string (x # xs))", "have \"List.member (fin_string_upto j) (Abs_fin_string (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member (fin_string_upto j) (Abs_fin_string (x # xs))", "apply(auto simp add: member_rec(2) fin_string_empty_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member\n     (Abs_fin_string [] #\n      concat\n       (map (\\<lambda>c. map (fin_string_cons c) (fin_string_upto jj))\n         enum_class.enum))\n     (Abs_fin_string (x # xs))", "using len sucMax"], ["proof (prove)\nusing this:\n  length L \\<le> k\n  Suc (length xs) \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. List.member\n     (Abs_fin_string [] #\n      concat\n       (map (\\<lambda>c. map (fin_string_cons c) (fin_string_upto jj))\n         enum_class.enum))\n     (Abs_fin_string (x # xs))", "apply(auto simp add: member_rec fin_string_empty_def fin_string_cons_def\n                Abs_fin_string_inverse Rep_fin_string_inverse neq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length L \\<le> k; Suc (length xs) \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> List.member\n                       (concat\n                         (map (\\<lambda>c.\n                                  map (map_fun Rep_fin_string Abs_fin_string\n  (string_cons c))\n                                   (fin_string_upto jj))\n                           enum_class.enum))\n                       (Abs_fin_string (x # xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length L \\<le> k; Suc (length xs) \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> List.member\n                       (concat\n                         (map (\\<lambda>c.\n                                  map (map_fun Rep_fin_string Abs_fin_string\n  (string_cons c))\n                                   (fin_string_upto jj))\n                           enum_class.enum))\n                       (Abs_fin_string (x # xs))", "let ?witLL = \"(\\<lambda> x. map (map_fun Rep_fin_string Abs_fin_string (string_cons x)) \n                            (fin_string_upto jj))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length L \\<le> k; Suc (length xs) \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> List.member\n                       (concat\n                         (map (\\<lambda>c.\n                                  map (map_fun Rep_fin_string Abs_fin_string\n  (string_cons c))\n                                   (fin_string_upto jj))\n                           enum_class.enum))\n                       (Abs_fin_string (x # xs))", "have f1: \"Abs_fin_string xs \\<in> set (fin_string_upto jj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_fin_string xs \\<in> set (fin_string_upto jj)", "by (metis member_def res)"], ["proof (state)\nthis:\n  Abs_fin_string xs \\<in> set (fin_string_upto jj)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length L \\<le> k; Suc (length xs) \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> List.member\n                       (concat\n                         (map (\\<lambda>c.\n                                  map (map_fun Rep_fin_string Abs_fin_string\n  (string_cons c))\n                                   (fin_string_upto jj))\n                           enum_class.enum))\n                       (Abs_fin_string (x # xs))", "have f2:\"Abs_fin_string (x # xs) = Abs_fin_string \n                      (if MAX_STR \\<le> length (Rep_fin_string (Abs_fin_string xs)) \n                       then Rep_fin_string (Abs_fin_string xs)\n                       else x # Rep_fin_string (Abs_fin_string xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_fin_string (x # xs) =\n    Abs_fin_string\n     (if MAX_STR \\<le> length (Rep_fin_string (Abs_fin_string xs))\n      then Rep_fin_string (Abs_fin_string xs)\n      else x # Rep_fin_string (Abs_fin_string xs))", "using Abs_fin_string_inverse ilen kMax"], ["proof (prove)\nusing this:\n  ?y \\<in> {s. length s \\<le> MAX_STR} \\<Longrightarrow>\n  Rep_fin_string (Abs_fin_string ?y) = ?y\n  k = length xs\n  k < MAX_STR\n\ngoal (1 subgoal):\n 1. Abs_fin_string (x # xs) =\n    Abs_fin_string\n     (if MAX_STR \\<le> length (Rep_fin_string (Abs_fin_string xs))\n      then Rep_fin_string (Abs_fin_string xs)\n      else x # Rep_fin_string (Abs_fin_string xs))", "by auto"], ["proof (state)\nthis:\n  Abs_fin_string (x # xs) =\n  Abs_fin_string\n   (if MAX_STR \\<le> length (Rep_fin_string (Abs_fin_string xs))\n    then Rep_fin_string (Abs_fin_string xs)\n    else x # Rep_fin_string (Abs_fin_string xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length L \\<le> k; Suc (length xs) \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> List.member\n                       (concat\n                         (map (\\<lambda>c.\n                                  map (map_fun Rep_fin_string Abs_fin_string\n  (string_cons c))\n                                   (fin_string_upto jj))\n                           enum_class.enum))\n                       (Abs_fin_string (x # xs))", "have ex:\"\\<exists> LL. (List.member (map ?witLL enum_class.enum) LL) \n                          \\<and> List.member LL (Abs_fin_string (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>LL.\n       List.member\n        (map (\\<lambda>x.\n                 map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n                  (fin_string_upto jj))\n          enum_class.enum)\n        LL \\<and>\n       List.member LL (Abs_fin_string (x # xs))", "apply(rule exI[where x=\"?witLL x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member\n     (map (\\<lambda>x.\n              map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n               (fin_string_upto jj))\n       enum_class.enum)\n     (map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n       (fin_string_upto jj)) \\<and>\n    List.member\n     (map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n       (fin_string_upto jj))\n     (Abs_fin_string (x # xs))", "apply(auto simp add: member_def univ)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_fin_string (x # xs)\n    \\<in> (\\<lambda>xa.\n              Abs_fin_string\n               (if MAX_STR \\<le> length (Rep_fin_string xa)\n                then Rep_fin_string xa else x # Rep_fin_string xa)) `\n          set (fin_string_upto jj)", "using f1 f2"], ["proof (prove)\nusing this:\n  Abs_fin_string xs \\<in> set (fin_string_upto jj)\n  Abs_fin_string (x # xs) =\n  Abs_fin_string\n   (if MAX_STR \\<le> length (Rep_fin_string (Abs_fin_string xs))\n    then Rep_fin_string (Abs_fin_string xs)\n    else x # Rep_fin_string (Abs_fin_string xs))\n\ngoal (1 subgoal):\n 1. Abs_fin_string (x # xs)\n    \\<in> (\\<lambda>xa.\n              Abs_fin_string\n               (if MAX_STR \\<le> length (Rep_fin_string xa)\n                then Rep_fin_string xa else x # Rep_fin_string xa)) `\n          set (fin_string_upto jj)", "by blast"], ["proof (state)\nthis:\n  \\<exists>LL.\n     List.member\n      (map (\\<lambda>x.\n               map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n                (fin_string_upto jj))\n        enum_class.enum)\n      LL \\<and>\n     List.member LL (Abs_fin_string (x # xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length L \\<le> k; Suc (length xs) \\<le> MAX_STR\\<rbrakk>\n    \\<Longrightarrow> List.member\n                       (concat\n                         (map (\\<lambda>c.\n                                  map (map_fun Rep_fin_string Abs_fin_string\n  (string_cons c))\n                                   (fin_string_upto jj))\n                           enum_class.enum))\n                       (Abs_fin_string (x # xs))", "show \"List.member (concat (map ?witLL enum_class.enum))\n                    (Abs_fin_string (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member\n     (concat\n       (map (\\<lambda>x.\n                map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n                 (fin_string_upto jj))\n         enum_class.enum))\n     (Abs_fin_string (x # xs))", "using member_concat ex"], ["proof (prove)\nusing this:\n  List.member (concat ?LL) ?x =\n  (\\<exists>L. List.member ?LL L \\<and> List.member L ?x)\n  \\<exists>LL.\n     List.member\n      (map (\\<lambda>x.\n               map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n                (fin_string_upto jj))\n        enum_class.enum)\n      LL \\<and>\n     List.member LL (Abs_fin_string (x # xs))\n\ngoal (1 subgoal):\n 1. List.member\n     (concat\n       (map (\\<lambda>x.\n                map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n                 (fin_string_upto jj))\n         enum_class.enum))\n     (Abs_fin_string (x # xs))", "by fastforce"], ["proof (state)\nthis:\n  List.member\n   (concat\n     (map (\\<lambda>x.\n              map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n               (fin_string_upto jj))\n       enum_class.enum))\n   (Abs_fin_string (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  List.member (fin_string_upto j) (Abs_fin_string (x # xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length xs) \\<le> j; Suc (length xs) \\<le> MAX_STR;\n     k = length xs\\<rbrakk>\n    \\<Longrightarrow> List.member (fin_string_upto j)\n                       (Abs_fin_string (x # xs))", "then"], ["proof (chain)\npicking this:\n  List.member (fin_string_upto j) (Abs_fin_string (x # xs))", "show \"List.member (fin_string_upto j) (Abs_fin_string (x # xs))\""], ["proof (prove)\nusing this:\n  List.member (fin_string_upto j) (Abs_fin_string (x # xs))\n\ngoal (1 subgoal):\n 1. List.member (fin_string_upto j) (Abs_fin_string (x # xs))", "by auto"], ["proof (state)\nthis:\n  List.member (fin_string_upto j) (Abs_fin_string (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>Suc k.\n     Suc k \\<le> MAX_STR \\<longrightarrow>\n     length (x # xs) = Suc k \\<longrightarrow>\n     List.member (fin_string_upto j) (Abs_fin_string (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>?k1.\n     ?k1 \\<le> MAX_STR \\<longrightarrow>\n     length ?xs1 = ?k1 \\<longrightarrow>\n     List.member (fin_string_upto j) (Abs_fin_string ?xs1) \\<Longrightarrow>\n  \\<forall>j\\<ge>Suc ?k1.\n     Suc ?k1 \\<le> MAX_STR \\<longrightarrow>\n     length (?x1 # ?xs1) = Suc ?k1 \\<longrightarrow>\n     List.member (fin_string_upto j) (Abs_fin_string (?x1 # ?xs1))\n\ngoal (1 subgoal):\n 1. List.member (fin_string_upto k) (Abs_fin_string L)", "have impl:\"length L \\<le> k \\<Longrightarrow> List.member (fin_string_upto k) (Abs_fin_string L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length L \\<le> k \\<Longrightarrow>\n    List.member (fin_string_upto k) (Abs_fin_string L)", "using len Len \n    length_induct[where P = \"(\\<lambda> L k. \\<forall> j \\<ge> k. k \\<le> MAX_STR \\<longrightarrow> length L = k \n        \\<longrightarrow> List.member (fin_string_upto j) (Abs_fin_string L))\"\n      , OF Len BC IS]"], ["proof (prove)\nusing this:\n  length L \\<le> k\n  length L \\<le> MAX_STR\n  (\\<And>k x xs.\n      \\<forall>j\\<ge>k.\n         k \\<le> MAX_STR \\<longrightarrow>\n         length xs = k \\<longrightarrow>\n         List.member (fin_string_upto j)\n          (Abs_fin_string xs) \\<Longrightarrow>\n      \\<forall>j\\<ge>k.\n         k \\<le> MAX_STR \\<longrightarrow>\n         length xs = k \\<longrightarrow>\n         List.member (fin_string_upto j)\n          (Abs_fin_string xs)) \\<Longrightarrow>\n  \\<forall>j\\<ge>length L.\n     length L \\<le> MAX_STR \\<longrightarrow>\n     length L = length L \\<longrightarrow>\n     List.member (fin_string_upto j) (Abs_fin_string L)\n\ngoal (1 subgoal):\n 1. length L \\<le> k \\<Longrightarrow>\n    List.member (fin_string_upto k) (Abs_fin_string L)", "by auto"], ["proof (state)\nthis:\n  length L \\<le> k \\<Longrightarrow>\n  List.member (fin_string_upto k) (Abs_fin_string L)\n\ngoal (1 subgoal):\n 1. List.member (fin_string_upto k) (Abs_fin_string L)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member (fin_string_upto k) (Abs_fin_string L)", "using impl len"], ["proof (prove)\nusing this:\n  length L \\<le> k \\<Longrightarrow>\n  List.member (fin_string_upto k) (Abs_fin_string L)\n  length L \\<le> k\n\ngoal (1 subgoal):\n 1. List.member (fin_string_upto k) (Abs_fin_string L)", "by auto"], ["proof (state)\nthis:\n  List.member (fin_string_upto k) (Abs_fin_string L)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fin_string_upto_length:\n  shows \"List.member (fin_string_upto n) L \\<Longrightarrow> ilength L \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member (fin_string_upto n) L \\<Longrightarrow> ilength L \\<le> n", "apply(induction n arbitrary: L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>L.\n       List.member (fin_string_upto 0) L \\<Longrightarrow> ilength L \\<le> 0\n 2. \\<And>n L.\n       \\<lbrakk>\\<And>L.\n                   List.member (fin_string_upto n) L \\<Longrightarrow>\n                   ilength L \\<le> n;\n        List.member (fin_string_upto (Suc n)) L\\<rbrakk>\n       \\<Longrightarrow> ilength L \\<le> Suc n", "apply(auto simp add: fin_string_empty_def Let_def ilength_def fin_string_cons_def \n     Rep_fin_string_inverse Abs_fin_string_inverse member_rec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n L.\n       \\<lbrakk>\\<And>L.\n                   List.member (fin_string_upto n) L \\<Longrightarrow>\n                   length (Rep_fin_string L) \\<le> n;\n        List.member\n         (concat\n           (map (\\<lambda>c.\n                    map (map_fun Rep_fin_string Abs_fin_string\n                          (string_cons c))\n                     (fin_string_upto n))\n             enum_class.enum))\n         L\\<rbrakk>\n       \\<Longrightarrow> length (Rep_fin_string L) \\<le> Suc n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n L.\n       \\<lbrakk>\\<And>L.\n                   List.member (fin_string_upto n) L \\<Longrightarrow>\n                   length (Rep_fin_string L) \\<le> n;\n        List.member\n         (concat\n           (map (\\<lambda>c.\n                    map (map_fun Rep_fin_string Abs_fin_string\n                          (string_cons c))\n                     (fin_string_upto n))\n             enum_class.enum))\n         L\\<rbrakk>\n       \\<Longrightarrow> length (Rep_fin_string L) \\<le> Suc n", "fix n L"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n L.\n       \\<lbrakk>\\<And>L.\n                   List.member (fin_string_upto n) L \\<Longrightarrow>\n                   length (Rep_fin_string L) \\<le> n;\n        List.member\n         (concat\n           (map (\\<lambda>c.\n                    map (map_fun Rep_fin_string Abs_fin_string\n                          (string_cons c))\n                     (fin_string_upto n))\n             enum_class.enum))\n         L\\<rbrakk>\n       \\<Longrightarrow> length (Rep_fin_string L) \\<le> Suc n", "let ?witLL = \"(\\<lambda>x. map(map_fun Rep_fin_string Abs_fin_string(string_cons x))(fin_string_upto n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n L.\n       \\<lbrakk>\\<And>L.\n                   List.member (fin_string_upto n) L \\<Longrightarrow>\n                   length (Rep_fin_string L) \\<le> n;\n        List.member\n         (concat\n           (map (\\<lambda>c.\n                    map (map_fun Rep_fin_string Abs_fin_string\n                          (string_cons c))\n                     (fin_string_upto n))\n             enum_class.enum))\n         L\\<rbrakk>\n       \\<Longrightarrow> length (Rep_fin_string L) \\<le> Suc n", "assume len:\"(\\<And>L. List.member (fin_string_upto n) L \\<Longrightarrow> length (Rep_fin_string L) \\<le> n)\""], ["proof (state)\nthis:\n  List.member (fin_string_upto n) ?L \\<Longrightarrow>\n  length (Rep_fin_string ?L) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>n L.\n       \\<lbrakk>\\<And>L.\n                   List.member (fin_string_upto n) L \\<Longrightarrow>\n                   length (Rep_fin_string L) \\<le> n;\n        List.member\n         (concat\n           (map (\\<lambda>c.\n                    map (map_fun Rep_fin_string Abs_fin_string\n                          (string_cons c))\n                     (fin_string_upto n))\n             enum_class.enum))\n         L\\<rbrakk>\n       \\<Longrightarrow> length (Rep_fin_string L) \\<le> Suc n", "assume mem:\"List.member (concat (map ?witLL enum_class.enum)) L\""], ["proof (state)\nthis:\n  List.member\n   (concat\n     (map (\\<lambda>x.\n              map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n               (fin_string_upto n))\n       enum_class.enum))\n   L\n\ngoal (1 subgoal):\n 1. \\<And>n L.\n       \\<lbrakk>\\<And>L.\n                   List.member (fin_string_upto n) L \\<Longrightarrow>\n                   length (Rep_fin_string L) \\<le> n;\n        List.member\n         (concat\n           (map (\\<lambda>c.\n                    map (map_fun Rep_fin_string Abs_fin_string\n                          (string_cons c))\n                     (fin_string_upto n))\n             enum_class.enum))\n         L\\<rbrakk>\n       \\<Longrightarrow> length (Rep_fin_string L) \\<le> Suc n", "have L:\"List.member (fin_string_upto n) L \\<Longrightarrow> length (Rep_fin_string L) \\<le> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member (fin_string_upto n) L \\<Longrightarrow>\n    length (Rep_fin_string L) \\<le> Suc n", "using len[of L]"], ["proof (prove)\nusing this:\n  List.member (fin_string_upto n) L \\<Longrightarrow>\n  length (Rep_fin_string L) \\<le> n\n\ngoal (1 subgoal):\n 1. List.member (fin_string_upto n) L \\<Longrightarrow>\n    length (Rep_fin_string L) \\<le> Suc n", "by auto"], ["proof (state)\nthis:\n  List.member (fin_string_upto n) L \\<Longrightarrow>\n  length (Rep_fin_string L) \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n L.\n       \\<lbrakk>\\<And>L.\n                   List.member (fin_string_upto n) L \\<Longrightarrow>\n                   length (Rep_fin_string L) \\<le> n;\n        List.member\n         (concat\n           (map (\\<lambda>c.\n                    map (map_fun Rep_fin_string Abs_fin_string\n                          (string_cons c))\n                     (fin_string_upto n))\n             enum_class.enum))\n         L\\<rbrakk>\n       \\<Longrightarrow> length (Rep_fin_string L) \\<le> Suc n", "assume a:\"List.member (concat (map ?witLL enum_class.enum)) L\""], ["proof (state)\nthis:\n  List.member\n   (concat\n     (map (\\<lambda>x.\n              map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n               (fin_string_upto n))\n       enum_class.enum))\n   L\n\ngoal (1 subgoal):\n 1. \\<And>n L.\n       \\<lbrakk>\\<And>L.\n                   List.member (fin_string_upto n) L \\<Longrightarrow>\n                   length (Rep_fin_string L) \\<le> n;\n        List.member\n         (concat\n           (map (\\<lambda>c.\n                    map (map_fun Rep_fin_string Abs_fin_string\n                          (string_cons c))\n                     (fin_string_upto n))\n             enum_class.enum))\n         L\\<rbrakk>\n       \\<Longrightarrow> length (Rep_fin_string L) \\<le> Suc n", "obtain LL where conc:\"List.member (map ?witLL enum_class.enum) LL\"\n    and concmem:\"List.member LL L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>LL.\n        \\<lbrakk>List.member\n                  (map (\\<lambda>x.\n                           map (map_fun Rep_fin_string Abs_fin_string\n                                 (string_cons x))\n                            (fin_string_upto n))\n                    enum_class.enum)\n                  LL;\n         List.member LL L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using member_concat a"], ["proof (prove)\nusing this:\n  List.member (concat ?LL) ?x =\n  (\\<exists>L. List.member ?LL L \\<and> List.member L ?x)\n  List.member\n   (concat\n     (map (\\<lambda>x.\n              map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n               (fin_string_upto n))\n       enum_class.enum))\n   L\n\ngoal (1 subgoal):\n 1. (\\<And>LL.\n        \\<lbrakk>List.member\n                  (map (\\<lambda>x.\n                           map (map_fun Rep_fin_string Abs_fin_string\n                                 (string_cons x))\n                            (fin_string_upto n))\n                    enum_class.enum)\n                  LL;\n         List.member LL L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  List.member\n   (map (\\<lambda>x.\n            map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n             (fin_string_upto n))\n     enum_class.enum)\n   LL\n  List.member LL L\n\ngoal (1 subgoal):\n 1. \\<And>n L.\n       \\<lbrakk>\\<And>L.\n                   List.member (fin_string_upto n) L \\<Longrightarrow>\n                   length (Rep_fin_string L) \\<le> n;\n        List.member\n         (concat\n           (map (\\<lambda>c.\n                    map (map_fun Rep_fin_string Abs_fin_string\n                          (string_cons c))\n                     (fin_string_upto n))\n             enum_class.enum))\n         L\\<rbrakk>\n       \\<Longrightarrow> length (Rep_fin_string L) \\<le> Suc n", "obtain c cs where c:\"L = fin_string_cons c cs\" and cs:\"List.member (fin_string_upto n) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c cs.\n        \\<lbrakk>L = fin_string_cons c cs;\n         List.member (fin_string_upto n) cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a conc"], ["proof (prove)\nusing this:\n  List.member\n   (concat\n     (map (\\<lambda>x.\n              map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n               (fin_string_upto n))\n       enum_class.enum))\n   L\n  List.member\n   (map (\\<lambda>x.\n            map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n             (fin_string_upto n))\n     enum_class.enum)\n   LL\n\ngoal (1 subgoal):\n 1. (\\<And>c cs.\n        \\<lbrakk>L = fin_string_cons c cs;\n         List.member (fin_string_upto n) cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding member_def"], ["proof (prove)\nusing this:\n  L \\<in> set (concat\n                (map (\\<lambda>x.\n                         map (map_fun Rep_fin_string Abs_fin_string\n                               (string_cons x))\n                          (fin_string_upto n))\n                  enum_class.enum))\n  LL \\<in> set (map (\\<lambda>x.\n                        map (map_fun Rep_fin_string Abs_fin_string\n                              (string_cons x))\n                         (fin_string_upto n))\n                 enum_class.enum)\n\ngoal (1 subgoal):\n 1. (\\<And>c cs.\n        \\<lbrakk>L = fin_string_cons c cs;\n         cs \\<in> set (fin_string_upto n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>\\<And>c cs.\n                   \\<lbrakk>Abs_fin_string\n                             (if MAX_STR \\<le> length (Rep_fin_string xb)\n                              then Rep_fin_string xb\n                              else xa # Rep_fin_string xb) =\n                            fin_string_cons c cs;\n                    cs \\<in> set (fin_string_upto n)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        LL =\n        map (map_fun Rep_fin_string Abs_fin_string (string_cons x))\n         (fin_string_upto n);\n        x \\<in> set enum_class.enum; xa \\<in> set enum_class.enum;\n        xb \\<in> set (fin_string_upto n);\n        L =\n        Abs_fin_string\n         (if MAX_STR \\<le> length (Rep_fin_string xb) then Rep_fin_string xb\n          else xa # Rep_fin_string xb)\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal for c d cs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c csa.\n                \\<lbrakk>Abs_fin_string\n                          (if MAX_STR \\<le> length (Rep_fin_string cs)\n                           then Rep_fin_string cs\n                           else d # Rep_fin_string cs) =\n                         fin_string_cons c csa;\n                 csa \\<in> set (fin_string_upto n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     LL =\n     map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n      (fin_string_upto n);\n     c \\<in> set enum_class.enum; d \\<in> set enum_class.enum;\n     cs \\<in> set (fin_string_upto n);\n     L =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string cs) then Rep_fin_string cs\n       else d # Rep_fin_string cs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(cases \"MAX_STR \\<le> length (Rep_fin_string cs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c csa.\n                \\<lbrakk>Abs_fin_string\n                          (if MAX_STR \\<le> length (Rep_fin_string cs)\n                           then Rep_fin_string cs\n                           else d # Rep_fin_string cs) =\n                         fin_string_cons c csa;\n                 csa \\<in> set (fin_string_upto n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     LL =\n     map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n      (fin_string_upto n);\n     c \\<in> set enum_class.enum; d \\<in> set enum_class.enum;\n     cs \\<in> set (fin_string_upto n);\n     L =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string cs) then Rep_fin_string cs\n       else d # Rep_fin_string cs);\n     MAX_STR \\<le> length (Rep_fin_string cs)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>c csa.\n                \\<lbrakk>Abs_fin_string\n                          (if MAX_STR \\<le> length (Rep_fin_string cs)\n                           then Rep_fin_string cs\n                           else d # Rep_fin_string cs) =\n                         fin_string_cons c csa;\n                 csa \\<in> set (fin_string_upto n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     LL =\n     map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n      (fin_string_upto n);\n     c \\<in> set enum_class.enum; d \\<in> set enum_class.enum;\n     cs \\<in> set (fin_string_upto n);\n     L =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string cs) then Rep_fin_string cs\n       else d # Rep_fin_string cs);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string cs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(auto simp add: Rep_fin_string_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c csa.\n                \\<lbrakk>cs = fin_string_cons c csa;\n                 csa \\<in> set (fin_string_upto n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     LL =\n     map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n      (fin_string_upto n);\n     c \\<in> set enum_class.enum; d \\<in> set enum_class.enum;\n     cs \\<in> set (fin_string_upto n); L = cs;\n     MAX_STR \\<le> length (Rep_fin_string cs)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>c csa.\n                \\<lbrakk>Abs_fin_string (d # Rep_fin_string cs) =\n                         fin_string_cons c csa;\n                 csa \\<in> set (fin_string_upto n)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     LL =\n     map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n      (fin_string_upto n);\n     c \\<in> set enum_class.enum; d \\<in> set enum_class.enum;\n     cs \\<in> set (fin_string_upto n);\n     L = Abs_fin_string (d # Rep_fin_string cs);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string cs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis (full_types) Rep_fin_string_inverse fin_string_cons.rep_eq string_cons.simps)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  L = fin_string_cons c cs\n  List.member (fin_string_upto n) cs\n\ngoal (1 subgoal):\n 1. \\<And>n L.\n       \\<lbrakk>\\<And>L.\n                   List.member (fin_string_upto n) L \\<Longrightarrow>\n                   length (Rep_fin_string L) \\<le> n;\n        List.member\n         (concat\n           (map (\\<lambda>c.\n                    map (map_fun Rep_fin_string Abs_fin_string\n                          (string_cons c))\n                     (fin_string_upto n))\n             enum_class.enum))\n         L\\<rbrakk>\n       \\<Longrightarrow> length (Rep_fin_string L) \\<le> Suc n", "then"], ["proof (chain)\npicking this:\n  L = fin_string_cons c cs\n  List.member (fin_string_upto n) cs", "have \"ilength (fin_string_cons c cs) \\<le> (Suc n)\""], ["proof (prove)\nusing this:\n  L = fin_string_cons c cs\n  List.member (fin_string_upto n) cs\n\ngoal (1 subgoal):\n 1. ilength (fin_string_cons c cs) \\<le> Suc n", "using len[of cs]"], ["proof (prove)\nusing this:\n  L = fin_string_cons c cs\n  List.member (fin_string_upto n) cs\n  List.member (fin_string_upto n) cs \\<Longrightarrow>\n  length (Rep_fin_string cs) \\<le> n\n\ngoal (1 subgoal):\n 1. ilength (fin_string_cons c cs) \\<le> Suc n", "unfolding ilength_def fin_string_cons_def"], ["proof (prove)\nusing this:\n  L = map_fun id (map_fun Rep_fin_string Abs_fin_string) string_cons c cs\n  List.member (fin_string_upto n) cs\n  List.member (fin_string_upto n) cs \\<Longrightarrow>\n  length (Rep_fin_string cs) \\<le> n\n\ngoal (1 subgoal):\n 1. map_fun Rep_fin_string id length\n     (map_fun id (map_fun Rep_fin_string Abs_fin_string) string_cons c cs)\n    \\<le> Suc n", "apply (auto simp add: Rep_fin_string_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L = Abs_fin_string (c # Rep_fin_string cs);\n     List.member (fin_string_upto n) cs; length (Rep_fin_string cs) \\<le> n;\n     \\<not> MAX_STR \\<le> length (Rep_fin_string cs)\\<rbrakk>\n    \\<Longrightarrow> length\n                       (Rep_fin_string\n                         (Abs_fin_string (c # Rep_fin_string cs)))\n                      \\<le> Suc n", "using c fin_string_cons.rep_eq"], ["proof (prove)\nusing this:\n  L = fin_string_cons c cs\n  Rep_fin_string (fin_string_cons ?x ?xa) =\n  string_cons ?x (Rep_fin_string ?xa)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L = Abs_fin_string (c # Rep_fin_string cs);\n     List.member (fin_string_upto n) cs; length (Rep_fin_string cs) \\<le> n;\n     \\<not> MAX_STR \\<le> length (Rep_fin_string cs)\\<rbrakk>\n    \\<Longrightarrow> length\n                       (Rep_fin_string\n                         (Abs_fin_string (c # Rep_fin_string cs)))\n                      \\<le> Suc n", "by force"], ["proof (state)\nthis:\n  ilength (fin_string_cons c cs) \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n L.\n       \\<lbrakk>\\<And>L.\n                   List.member (fin_string_upto n) L \\<Longrightarrow>\n                   length (Rep_fin_string L) \\<le> n;\n        List.member\n         (concat\n           (map (\\<lambda>c.\n                    map (map_fun Rep_fin_string Abs_fin_string\n                          (string_cons c))\n                     (fin_string_upto n))\n             enum_class.enum))\n         L\\<rbrakk>\n       \\<Longrightarrow> length (Rep_fin_string L) \\<le> Suc n", "then"], ["proof (chain)\npicking this:\n  ilength (fin_string_cons c cs) \\<le> Suc n", "show \"length (Rep_fin_string L) \\<le> Suc n\""], ["proof (prove)\nusing this:\n  ilength (fin_string_cons c cs) \\<le> Suc n\n\ngoal (1 subgoal):\n 1. length (Rep_fin_string L) \\<le> Suc n", "using c ilength.rep_eq"], ["proof (prove)\nusing this:\n  ilength (fin_string_cons c cs) \\<le> Suc n\n  L = fin_string_cons c cs\n  ilength ?x = length (Rep_fin_string ?x)\n\ngoal (1 subgoal):\n 1. length (Rep_fin_string L) \\<le> Suc n", "by auto"], ["proof (state)\nthis:\n  length (Rep_fin_string L) \\<le> Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>fin-string-upto produces no duplicate identifiers\\<close>"], ["", "lemma distinct_upto:\n  shows \"i \\<le> MAX_STR \\<Longrightarrow> distinct (fin_string_upto i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> MAX_STR \\<Longrightarrow> distinct (fin_string_upto i)", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> MAX_STR \\<Longrightarrow> distinct (fin_string_upto 0)\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> MAX_STR \\<Longrightarrow>\n                distinct (fin_string_upto i);\n        Suc i \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> distinct (fin_string_upto (Suc i))", "case 0"], ["proof (state)\nthis:\n  0 \\<le> MAX_STR\n\ngoal (2 subgoals):\n 1. 0 \\<le> MAX_STR \\<Longrightarrow> distinct (fin_string_upto 0)\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> MAX_STR \\<Longrightarrow>\n                distinct (fin_string_upto i);\n        Suc i \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> distinct (fin_string_upto (Suc i))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> MAX_STR", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. distinct (fin_string_upto 0)", "by(auto)"], ["proof (state)\nthis:\n  distinct (fin_string_upto 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> MAX_STR \\<Longrightarrow>\n                distinct (fin_string_upto i);\n        Suc i \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> distinct (fin_string_upto (Suc i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> MAX_STR \\<Longrightarrow>\n                distinct (fin_string_upto i);\n        Suc i \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> distinct (fin_string_upto (Suc i))", "case (Suc j)"], ["proof (state)\nthis:\n  j \\<le> MAX_STR \\<Longrightarrow> distinct (fin_string_upto j)\n  Suc j \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> MAX_STR \\<Longrightarrow>\n                distinct (fin_string_upto i);\n        Suc i \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> distinct (fin_string_upto (Suc i))", "then"], ["proof (chain)\npicking this:\n  j \\<le> MAX_STR \\<Longrightarrow> distinct (fin_string_upto j)\n  Suc j \\<le> MAX_STR", "have jLen:\"Suc j \\<le> MAX_STR\"\n    and IH:\"distinct (fin_string_upto j)\""], ["proof (prove)\nusing this:\n  j \\<le> MAX_STR \\<Longrightarrow> distinct (fin_string_upto j)\n  Suc j \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. Suc j \\<le> MAX_STR &&& distinct (fin_string_upto j)", "by auto"], ["proof (state)\nthis:\n  Suc j \\<le> MAX_STR\n  distinct (fin_string_upto j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> MAX_STR \\<Longrightarrow>\n                distinct (fin_string_upto i);\n        Suc i \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> distinct (fin_string_upto (Suc i))", "have distinct_char:\"distinct (enum_class.enum:: char list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct enum_class.enum", "by (auto simp add: distinct_map enum_char_unfold)"], ["proof (state)\nthis:\n  distinct enum_class.enum\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> MAX_STR \\<Longrightarrow>\n                distinct (fin_string_upto i);\n        Suc i \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> distinct (fin_string_upto (Suc i))", "have diseq:\"\\<And> x y. y \\<in> set (fin_string_upto j) \\<Longrightarrow>  fin_string_empty \\<noteq> fin_string_cons x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       y \\<in> set (fin_string_upto j) \\<Longrightarrow>\n       fin_string_empty \\<noteq> fin_string_cons x y", "using Rep_fin_string_inverse jLen"], ["proof (prove)\nusing this:\n  Abs_fin_string (Rep_fin_string ?x) = ?x\n  Suc j \\<le> MAX_STR\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       y \\<in> set (fin_string_upto j) \\<Longrightarrow>\n       fin_string_empty \\<noteq> fin_string_cons x y", "apply(auto simp add: fin_string_empty_def fin_string_cons_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Abs_fin_string [] \\<in> set (fin_string_upto j);\n     \\<And>x. Abs_fin_string (Rep_fin_string x) = x; Suc j \\<le> MAX_STR;\n     MAX_STR \\<le> length (Rep_fin_string (Abs_fin_string []))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x y.\n       \\<lbrakk>y \\<in> set (fin_string_upto j);\n        \\<And>x. Abs_fin_string (Rep_fin_string x) = x; Suc j \\<le> MAX_STR;\n        \\<not> MAX_STR \\<le> length (Rep_fin_string y);\n        Abs_fin_string [] = Abs_fin_string (x # Rep_fin_string y)\\<rbrakk>\n       \\<Longrightarrow> False", "using fin_string_empty.rep_eq le_zero_eq list.size not_less_eq_eq zero_le Abs_fin_string_inject"], ["proof (prove)\nusing this:\n  Rep_fin_string fin_string_empty = []\n  (?n \\<le> (0::?'a)) = (?n = (0::?'a))\n  size_list ?x [] = 0\n  size_list ?x (?x21.0 # ?x22.0) = ?x ?x21.0 + size_list ?x ?x22.0 + Suc 0\n  length [] = 0\n  length (?x21.0 # ?x22.0) = length ?x22.0 + Suc 0\n  (\\<not> ?m \\<le> ?n) = (Suc ?n \\<le> ?m)\n  (0::?'a) \\<le> ?x\n  \\<lbrakk>?x \\<in> {s. length s \\<le> MAX_STR};\n   ?y \\<in> {s. length s \\<le> MAX_STR}\\<rbrakk>\n  \\<Longrightarrow> (Abs_fin_string ?x = Abs_fin_string ?y) = (?x = ?y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Abs_fin_string [] \\<in> set (fin_string_upto j);\n     \\<And>x. Abs_fin_string (Rep_fin_string x) = x; Suc j \\<le> MAX_STR;\n     MAX_STR \\<le> length (Rep_fin_string (Abs_fin_string []))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x y.\n       \\<lbrakk>y \\<in> set (fin_string_upto j);\n        \\<And>x. Abs_fin_string (Rep_fin_string x) = x; Suc j \\<le> MAX_STR;\n        \\<not> MAX_STR \\<le> length (Rep_fin_string y);\n        Abs_fin_string [] = Abs_fin_string (x # Rep_fin_string y)\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis,auto)"], ["proof (state)\nthis:\n  ?y \\<in> set (fin_string_upto j) \\<Longrightarrow>\n  fin_string_empty \\<noteq> fin_string_cons ?x ?y\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> MAX_STR \\<Longrightarrow>\n                distinct (fin_string_upto i);\n        Suc i \\<le> MAX_STR\\<rbrakk>\n       \\<Longrightarrow> distinct (fin_string_upto (Suc i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (fin_string_upto (Suc j))", "apply(auto simp add: Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set enum_class.enum;\n        fin_string_empty = fin_string_cons x xa;\n        xa \\<in> set (fin_string_upto j)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. distinct\n     (concat\n       (map (\\<lambda>c. map (fin_string_cons c) (fin_string_upto j))\n         enum_class.enum))", "subgoal for x xa"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set enum_class.enum;\n     fin_string_empty = fin_string_cons x xa;\n     xa \\<in> set (fin_string_upto j)\\<rbrakk>\n    \\<Longrightarrow> False", "using diseq"], ["proof (prove)\nusing this:\n  ?y \\<in> set (fin_string_upto j) \\<Longrightarrow>\n  fin_string_empty \\<noteq> fin_string_cons ?x ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set enum_class.enum;\n     fin_string_empty = fin_string_cons x xa;\n     xa \\<in> set (fin_string_upto j)\\<rbrakk>\n    \\<Longrightarrow> False", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (concat\n       (map (\\<lambda>c. map (fin_string_cons c) (fin_string_upto j))\n         enum_class.enum))", "apply(rule distinct_concat)"], ["proof (prove)\ngoal (3 subgoals):\n 1. distinct\n     (map (\\<lambda>c. map (fin_string_cons c) (fin_string_upto j))\n       enum_class.enum)\n 2. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>c.\n                             map (fin_string_cons c) (fin_string_upto j))\n                      enum_class.enum) \\<Longrightarrow>\n       distinct ys\n 3. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>c.\nmap (fin_string_cons c) (fin_string_upto j))\n                               enum_class.enum);\n        zs \\<in> set (map (\\<lambda>c.\n                              map (fin_string_cons c) (fin_string_upto j))\n                       enum_class.enum);\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>c. map (fin_string_cons c) (fin_string_upto j))\n       enum_class.enum)", "apply(auto simp add: distinct_map)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct enum_class.enum\n 2. inj_on (\\<lambda>c. map (fin_string_cons c) (fin_string_upto j))\n     (set enum_class.enum)", "apply(rule distinct_char)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>c. map (fin_string_cons c) (fin_string_upto j))\n     (set enum_class.enum)", "apply(rule subset_inj_on[where B=UNIV])"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj (\\<lambda>c. map (fin_string_cons c) (fin_string_upto j))\n 2. set enum_class.enum \\<subseteq> UNIV", "apply(rule injI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       map (fin_string_cons x) (fin_string_upto j) =\n       map (fin_string_cons y) (fin_string_upto j) \\<Longrightarrow>\n       x = y\n 2. set enum_class.enum \\<subseteq> UNIV", "apply(auto simp add: fin_string_cons_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<forall>xa\\<in>set (fin_string_upto j).\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa else x # Rep_fin_string xa) =\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa\n            else y # Rep_fin_string xa) \\<Longrightarrow>\n       x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<forall>xa\\<in>set (fin_string_upto j).\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa else x # Rep_fin_string xa) =\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa\n            else y # Rep_fin_string xa) \\<Longrightarrow>\n       x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<forall>xa\\<in>set (fin_string_upto j).\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa else x # Rep_fin_string xa) =\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa\n            else y # Rep_fin_string xa) \\<Longrightarrow>\n       x = y", "let ?l = \"(\\<lambda>xa x. Abs_fin_string \n        (if MAX_STR \\<le> length (Rep_fin_string xa) \n         then Rep_fin_string xa \n         else x # Rep_fin_string xa))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<forall>xa\\<in>set (fin_string_upto j).\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa else x # Rep_fin_string xa) =\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa\n            else y # Rep_fin_string xa) \\<Longrightarrow>\n       x = y", "assume a1:\"\\<forall>xa\\<in>set (fin_string_upto j). ?l xa x = ?l xa y\""], ["proof (state)\nthis:\n  \\<forall>xa\\<in>set (fin_string_upto j).\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else x # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else y # Rep_fin_string xa)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<forall>xa\\<in>set (fin_string_upto j).\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa else x # Rep_fin_string xa) =\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa\n            else y # Rep_fin_string xa) \\<Longrightarrow>\n       x = y", "then"], ["proof (chain)\npicking this:\n  \\<forall>xa\\<in>set (fin_string_upto j).\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else x # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else y # Rep_fin_string xa)", "have a2:\"\\<And>xa. (List.member (fin_string_upto j) xa) \\<Longrightarrow> ?l xa x = ?l xa y\""], ["proof (prove)\nusing this:\n  \\<forall>xa\\<in>set (fin_string_upto j).\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else x # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else y # Rep_fin_string xa)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       List.member (fin_string_upto j) xa \\<Longrightarrow>\n       Abs_fin_string\n        (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n         else x # Rep_fin_string xa) =\n       Abs_fin_string\n        (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n         else y # Rep_fin_string xa)", "using  member_def"], ["proof (prove)\nusing this:\n  \\<forall>xa\\<in>set (fin_string_upto j).\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else x # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else y # Rep_fin_string xa)\n  List.member ?xs ?x = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       List.member (fin_string_upto j) xa \\<Longrightarrow>\n       Abs_fin_string\n        (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n         else x # Rep_fin_string xa) =\n       Abs_fin_string\n        (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n         else y # Rep_fin_string xa)", "by force"], ["proof (state)\nthis:\n  List.member (fin_string_upto j) ?xa \\<Longrightarrow>\n  Abs_fin_string\n   (if MAX_STR \\<le> length (Rep_fin_string ?xa) then Rep_fin_string ?xa\n    else x # Rep_fin_string ?xa) =\n  Abs_fin_string\n   (if MAX_STR \\<le> length (Rep_fin_string ?xa) then Rep_fin_string ?xa\n    else y # Rep_fin_string ?xa)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<forall>xa\\<in>set (fin_string_upto j).\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa else x # Rep_fin_string xa) =\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa\n            else y # Rep_fin_string xa) \\<Longrightarrow>\n       x = y", "then"], ["proof (chain)\npicking this:\n  List.member (fin_string_upto j) ?xa \\<Longrightarrow>\n  Abs_fin_string\n   (if MAX_STR \\<le> length (Rep_fin_string ?xa) then Rep_fin_string ?xa\n    else x # Rep_fin_string ?xa) =\n  Abs_fin_string\n   (if MAX_STR \\<le> length (Rep_fin_string ?xa) then Rep_fin_string ?xa\n    else y # Rep_fin_string ?xa)", "have \"Abs_fin_string [x] = Abs_fin_string [y] \\<or> (MAX_STR::nat) = 0\""], ["proof (prove)\nusing this:\n  List.member (fin_string_upto j) ?xa \\<Longrightarrow>\n  Abs_fin_string\n   (if MAX_STR \\<le> length (Rep_fin_string ?xa) then Rep_fin_string ?xa\n    else x # Rep_fin_string ?xa) =\n  Abs_fin_string\n   (if MAX_STR \\<le> length (Rep_fin_string ?xa) then Rep_fin_string ?xa\n    else y # Rep_fin_string ?xa)\n\ngoal (1 subgoal):\n 1. Abs_fin_string [x] = Abs_fin_string [y] \\<or> MAX_STR = 0", "using a2 fin_string_empty.rep_eq fin_string_nil"], ["proof (prove)\nusing this:\n  List.member (fin_string_upto j) ?xa \\<Longrightarrow>\n  Abs_fin_string\n   (if MAX_STR \\<le> length (Rep_fin_string ?xa) then Rep_fin_string ?xa\n    else x # Rep_fin_string ?xa) =\n  Abs_fin_string\n   (if MAX_STR \\<le> length (Rep_fin_string ?xa) then Rep_fin_string ?xa\n    else y # Rep_fin_string ?xa)\n  List.member (fin_string_upto j) ?xa \\<Longrightarrow>\n  Abs_fin_string\n   (if MAX_STR \\<le> length (Rep_fin_string ?xa) then Rep_fin_string ?xa\n    else x # Rep_fin_string ?xa) =\n  Abs_fin_string\n   (if MAX_STR \\<le> length (Rep_fin_string ?xa) then Rep_fin_string ?xa\n    else y # Rep_fin_string ?xa)\n  Rep_fin_string fin_string_empty = []\n  List.member (fin_string_upto ?n) fin_string_empty\n\ngoal (1 subgoal):\n 1. Abs_fin_string [x] = Abs_fin_string [y] \\<or> MAX_STR = 0", "by force"], ["proof (state)\nthis:\n  Abs_fin_string [x] = Abs_fin_string [y] \\<or> MAX_STR = 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<forall>xa\\<in>set (fin_string_upto j).\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa else x # Rep_fin_string xa) =\n          Abs_fin_string\n           (if MAX_STR \\<le> length (Rep_fin_string xa)\n            then Rep_fin_string xa\n            else y # Rep_fin_string xa) \\<Longrightarrow>\n       x = y", "then"], ["proof (chain)\npicking this:\n  Abs_fin_string [x] = Abs_fin_string [y] \\<or> MAX_STR = 0", "show \"x = y\""], ["proof (prove)\nusing this:\n  Abs_fin_string [x] = Abs_fin_string [y] \\<or> MAX_STR = 0\n\ngoal (1 subgoal):\n 1. x = y", "by (metis Abs_fin_string_inverse jLen le_zero_eq length_Cons list.inject list.size(3) \n            mem_Collect_eq nat.distinct(1) not_less_eq_eq)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>c.\n                             map (fin_string_cons c) (fin_string_upto j))\n                      enum_class.enum) \\<Longrightarrow>\n       distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>c.\nmap (fin_string_cons c) (fin_string_upto j))\n                               enum_class.enum);\n        zs \\<in> set (map (\\<lambda>c.\n                              map (fin_string_cons c) (fin_string_upto j))\n                       enum_class.enum);\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "subgoal for ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> set (map (\\<lambda>c.\n                          map (fin_string_cons c) (fin_string_upto j))\n                   enum_class.enum) \\<Longrightarrow>\n    distinct ys", "apply(auto simp add: fin_string_cons_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c \\<in> set enum_class.enum;\n        ys =\n        map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n         (fin_string_upto j)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (map_fun Rep_fin_string Abs_fin_string\n                                 (string_cons c))\n                            (fin_string_upto j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c \\<in> set enum_class.enum;\n        ys =\n        map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n         (fin_string_upto j)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (map_fun Rep_fin_string Abs_fin_string\n                                 (string_cons c))\n                            (fin_string_upto j))", "fix c :: char"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c \\<in> set enum_class.enum;\n        ys =\n        map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n         (fin_string_upto j)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (map_fun Rep_fin_string Abs_fin_string\n                                 (string_cons c))\n                            (fin_string_upto j))", "assume c:\"c \\<in> set enum_class.enum\""], ["proof (state)\nthis:\n  c \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c \\<in> set enum_class.enum;\n        ys =\n        map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n         (fin_string_upto j)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (map_fun Rep_fin_string Abs_fin_string\n                                 (string_cons c))\n                            (fin_string_upto j))", "assume ys:\"ys=map(map_fun Rep_fin_string Abs_fin_string (string_cons c)) (fin_string_upto j)\""], ["proof (state)\nthis:\n  ys =\n  map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n   (fin_string_upto j)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c \\<in> set enum_class.enum;\n        ys =\n        map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n         (fin_string_upto j)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (map_fun Rep_fin_string Abs_fin_string\n                                 (string_cons c))\n                            (fin_string_upto j))", "show\"distinct(map(map_fun Rep_fin_string Abs_fin_string (string_cons c)) (fin_string_upto j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n       (fin_string_upto j))", "unfolding distinct_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (fin_string_upto j) \\<and>\n    inj_on (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n     (set (fin_string_upto j))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (fin_string_upto j)\n 2. inj_on (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n     (set (fin_string_upto j))", "apply(rule IH)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n     (set (fin_string_upto j))", "apply(rule inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (fin_string_upto j);\n        y \\<in> set (fin_string_upto j);\n        map_fun Rep_fin_string Abs_fin_string (string_cons c) x =\n        map_fun Rep_fin_string Abs_fin_string (string_cons c) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (fin_string_upto j);\n        y \\<in> set (fin_string_upto j);\n        Abs_fin_string\n         (if MAX_STR \\<le> length (Rep_fin_string x) then Rep_fin_string x\n          else c # Rep_fin_string x) =\n        Abs_fin_string\n         (if MAX_STR \\<le> length (Rep_fin_string y) then Rep_fin_string y\n          else c # Rep_fin_string y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (fin_string_upto j);\n     y \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string x) then Rep_fin_string x\n       else c # Rep_fin_string x) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string y) then Rep_fin_string y\n       else c # Rep_fin_string y)\\<rbrakk>\n    \\<Longrightarrow> x = y", "using jLen fin_string_upto_length[of j x] fin_string_upto_length[of j y]"], ["proof (prove)\nusing this:\n  Suc j \\<le> MAX_STR\n  List.member (fin_string_upto j) x \\<Longrightarrow> ilength x \\<le> j\n  List.member (fin_string_upto j) y \\<Longrightarrow> ilength y \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (fin_string_upto j);\n     y \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string x) then Rep_fin_string x\n       else c # Rep_fin_string x) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string y) then Rep_fin_string y\n       else c # Rep_fin_string y)\\<rbrakk>\n    \\<Longrightarrow> x = y", "unfolding List.member_def ilength_def"], ["proof (prove)\nusing this:\n  Suc j \\<le> MAX_STR\n  x \\<in> set (fin_string_upto j) \\<Longrightarrow>\n  map_fun Rep_fin_string id length x \\<le> j\n  y \\<in> set (fin_string_upto j) \\<Longrightarrow>\n  map_fun Rep_fin_string id length y \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (fin_string_upto j);\n     y \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string x) then Rep_fin_string x\n       else c # Rep_fin_string x) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string y) then Rep_fin_string y\n       else c # Rep_fin_string y)\\<rbrakk>\n    \\<Longrightarrow> x = y", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (fin_string_upto j);\n     y \\<in> set (fin_string_upto j);\n     Abs_fin_string (c # Rep_fin_string x) =\n     Abs_fin_string (c # Rep_fin_string y);\n     Suc j \\<le> MAX_STR; length (Rep_fin_string x) \\<le> j;\n     length (Rep_fin_string y) \\<le> j\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (metis (mono_tags, hide_lams) Rep_fin_string_inverse fin_string_cons.rep_eq le_trans\n              list.inject not_less_eq_eq string_cons.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct\n   (map (map_fun Rep_fin_string Abs_fin_string (string_cons c))\n     (fin_string_upto j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>c.\nmap (fin_string_cons c) (fin_string_upto j))\n                               enum_class.enum);\n        zs \\<in> set (map (\\<lambda>c.\n                              map (fin_string_cons c) (fin_string_upto j))\n                       enum_class.enum);\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "apply(auto simp add: fin_string_cons_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c ca xa xb xc.\n       \\<lbrakk>c \\<in> set enum_class.enum; ca \\<in> set enum_class.enum;\n        xa \\<in> set (fin_string_upto j);\n        Abs_fin_string\n         (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n          else c # Rep_fin_string xa) =\n        Abs_fin_string\n         (if MAX_STR \\<le> length (Rep_fin_string xb) then Rep_fin_string xb\n          else ca # Rep_fin_string xb);\n        xb \\<in> set (fin_string_upto j); xc \\<in> set (fin_string_upto j);\n        Abs_fin_string\n         (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n          else c # Rep_fin_string xc) \\<noteq>\n        Abs_fin_string\n         (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n          else ca # Rep_fin_string xc)\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for c ca xa xb xc"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in> set enum_class.enum; ca \\<in> set enum_class.enum;\n     xa \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else c # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xb) then Rep_fin_string xb\n       else ca # Rep_fin_string xb);\n     xb \\<in> set (fin_string_upto j); xc \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else c # Rep_fin_string xc) \\<noteq>\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else ca # Rep_fin_string xc)\\<rbrakk>\n    \\<Longrightarrow> False", "apply(cases \"MAX_STR \\<le> length (Rep_fin_string xa)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c \\<in> set enum_class.enum; ca \\<in> set enum_class.enum;\n     xa \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else c # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xb) then Rep_fin_string xb\n       else ca # Rep_fin_string xb);\n     xb \\<in> set (fin_string_upto j); xc \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else c # Rep_fin_string xc) \\<noteq>\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else ca # Rep_fin_string xc);\n     MAX_STR \\<le> length (Rep_fin_string xa)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>c \\<in> set enum_class.enum; ca \\<in> set enum_class.enum;\n     xa \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else c # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xb) then Rep_fin_string xb\n       else ca # Rep_fin_string xb);\n     xb \\<in> set (fin_string_upto j); xc \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else c # Rep_fin_string xc) \\<noteq>\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else ca # Rep_fin_string xc);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string xa)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis fin_string_upto_length jLen ilength.rep_eq le_trans member_def not_less_eq_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in> set enum_class.enum; ca \\<in> set enum_class.enum;\n     xa \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else c # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xb) then Rep_fin_string xb\n       else ca # Rep_fin_string xb);\n     xb \\<in> set (fin_string_upto j); xc \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else c # Rep_fin_string xc) \\<noteq>\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else ca # Rep_fin_string xc);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string xa)\\<rbrakk>\n    \\<Longrightarrow> False", "apply(cases \"MAX_STR \\<le> length (Rep_fin_string xb)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c \\<in> set enum_class.enum; ca \\<in> set enum_class.enum;\n     xa \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else c # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xb) then Rep_fin_string xb\n       else ca # Rep_fin_string xb);\n     xb \\<in> set (fin_string_upto j); xc \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else c # Rep_fin_string xc) \\<noteq>\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else ca # Rep_fin_string xc);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string xa);\n     MAX_STR \\<le> length (Rep_fin_string xb)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>c \\<in> set enum_class.enum; ca \\<in> set enum_class.enum;\n     xa \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else c # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xb) then Rep_fin_string xb\n       else ca # Rep_fin_string xb);\n     xb \\<in> set (fin_string_upto j); xc \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else c # Rep_fin_string xc) \\<noteq>\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else ca # Rep_fin_string xc);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string xa);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string xb)\\<rbrakk>\n    \\<Longrightarrow> False", "apply(metis fin_string_upto_length jLen ilength.rep_eq le_trans member_def not_less_eq_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in> set enum_class.enum; ca \\<in> set enum_class.enum;\n     xa \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else c # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xb) then Rep_fin_string xb\n       else ca # Rep_fin_string xb);\n     xb \\<in> set (fin_string_upto j); xc \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else c # Rep_fin_string xc) \\<noteq>\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else ca # Rep_fin_string xc);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string xa);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string xb)\\<rbrakk>\n    \\<Longrightarrow> False", "apply(cases \"MAX_STR \\<le> length (Rep_fin_string xc)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c \\<in> set enum_class.enum; ca \\<in> set enum_class.enum;\n     xa \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else c # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xb) then Rep_fin_string xb\n       else ca # Rep_fin_string xb);\n     xb \\<in> set (fin_string_upto j); xc \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else c # Rep_fin_string xc) \\<noteq>\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else ca # Rep_fin_string xc);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string xa);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string xb);\n     MAX_STR \\<le> length (Rep_fin_string xc)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>c \\<in> set enum_class.enum; ca \\<in> set enum_class.enum;\n     xa \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xa) then Rep_fin_string xa\n       else c # Rep_fin_string xa) =\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xb) then Rep_fin_string xb\n       else ca # Rep_fin_string xb);\n     xb \\<in> set (fin_string_upto j); xc \\<in> set (fin_string_upto j);\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else c # Rep_fin_string xc) \\<noteq>\n     Abs_fin_string\n      (if MAX_STR \\<le> length (Rep_fin_string xc) then Rep_fin_string xc\n       else ca # Rep_fin_string xc);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string xa);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string xb);\n     \\<not> MAX_STR \\<le> length (Rep_fin_string xc)\\<rbrakk>\n    \\<Longrightarrow> False", "by(auto,metis Rep_fin_string_inverse fin_string_cons.rep_eq list.inject string_cons.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (fin_string_upto (Suc j))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Finite strings are an enumeration type\\<close>"], ["", "instantiation fin_string :: enum begin"], ["", "definition enum_fin_string \n  where enum_fin_string_def[code]:\"enum_fin_string \\<equiv> fin_string_enum\""], ["", "definition enum_all_fin_string\n  where enum_all_fin_string[code]:\"enum_all_fin_string \\<equiv> fin_string_enum_all\""], ["", "definition enum_ex_fin_string\n  where enum_ex_fin_string[code]:\"enum_ex_fin_string \\<equiv> fin_string_enum_ex\""], ["", "lemma enum_ALL:\"(UNIV::fin_string set) = set enum_class.enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = set enum_class.enum", "apply(auto simp add:enum_fin_string_def fin_string_enum_def vals_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (fin_string_upto MAX_STR)", "by(metis fin_string_length List.member_def mem_Collect_eq Abs_fin_string_cases)"], ["", "lemma vals_ALL:\"set (vals::fin_string list) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set vals = UNIV", "using enum_ALL vals_def Rep_fin_string fin_string_length ilength.rep_eq member_def"], ["proof (prove)\nusing this:\n  UNIV = set enum_class.enum\n  vals \\<equiv> fin_string_upto MAX_STR\n  Rep_fin_string ?x \\<in> {s. length s \\<le> MAX_STR}\n  \\<lbrakk>length ?L \\<le> ?k; length ?L \\<le> MAX_STR\\<rbrakk>\n  \\<Longrightarrow> List.member (fin_string_upto ?k) (Abs_fin_string ?L)\n  ilength ?x = length (Rep_fin_string ?x)\n  List.member ?xs ?x = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. set vals = UNIV", "by(metis (mono_tags) Rep_fin_string_inverse UNIV_eq_I mem_Collect_eq)"], ["", "lemma setA:\n  assumes set:\"\\<And>y. y \\<in> set L \\<Longrightarrow> P y\"\n  shows \"list_all P L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P L", "using set"], ["proof (prove)\nusing this:\n  ?y \\<in> set L \\<Longrightarrow> P ?y\n\ngoal (1 subgoal):\n 1. list_all P L", "by (simp add: list.pred_set)"], ["", "lemma setE:\n  assumes set:\" y \\<in> set L\"\n  assumes P:\"P y\"\n  shows \"list_ex P L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ex P L", "using set P  list_ex_iff"], ["proof (prove)\nusing this:\n  y \\<in> set L\n  P y\n  list_ex ?P ?xs = Bex (set ?xs) ?P\n\ngoal (1 subgoal):\n 1. list_ex P L", "by auto"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fin_string, enum_class)", "apply(standard)"], ["proof (prove)\ngoal (4 subgoals):\n 1. UNIV = set enum_class.enum\n 2. distinct enum_class.enum\n 3. \\<And>P. enum_class.enum_all P = Ball UNIV P\n 4. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "apply(rule enum_ALL)"], ["proof (prove)\ngoal (3 subgoals):\n 1. distinct enum_class.enum\n 2. \\<And>P. enum_class.enum_all P = Ball UNIV P\n 3. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "by (auto simp add: fin_string_enum_all_def list_all_iff vals_ALL setA setE enum_all_fin_string\n      enum_ALL fin_string_enum_def vals_def enum_fin_string_def distinct_upto list_ex_iff \n      enum_ex_fin_string fin_string_enum_ex_def)"], ["", "end"], ["", "instantiation fin_string :: equal begin"], ["", "definition equal_fin_string :: \"fin_string \\<Rightarrow> fin_string \\<Rightarrow> bool\"\n  where [code]:\"equal_fin_string X Y = (X \\<le> Y \\<and> Y \\<le> X)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fin_string, equal_class)", "apply(standard)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "by(auto simp add: equal_fin_string_def)"], ["", "end"], ["", "end"]]}