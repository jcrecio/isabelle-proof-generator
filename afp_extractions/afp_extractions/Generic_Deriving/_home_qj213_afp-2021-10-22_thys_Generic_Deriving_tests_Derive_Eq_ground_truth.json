{"file_name": "/home/qj213/afp-2021-10-22/thys/Generic_Deriving/tests/Derive_Eq.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Generic_Deriving", "problem_names": ["lemma \"eq (A 4) (A 4)\"", "lemma \"eq (A 6) (A 4) \\<longleftrightarrow> False\"", "lemma \"eq C C\"", "lemma \"eq (B 4 5) (B 4 5)\"", "lemma \"eq (B 4 4) (A 3) \\<longleftrightarrow> False\"", "lemma \"eq C (A 4) \\<longleftrightarrow> False\"", "lemma \"eq (L (3::nat)) (R 3) \\<longleftrightarrow> False\"", "lemma \"eq (L (3::nat)) (L 3)\"", "lemma \"eq (L (3::nat)) (L 4) \\<longleftrightarrow> False\"", "lemma \"eq ([]::(nat list)) []\"", "lemma \"eq ([1,2,3]:: (nat list)) [1,2,3]\"", "lemma \"eq [(1::nat)] [1,2] \\<longleftrightarrow> False\"", "lemma \"eq Leaf Leaf\"", "lemma \"eq (Node (1::nat) Leaf Leaf) Leaf \\<longleftrightarrow> False\"", "lemma \"eq (Node (1::nat) Leaf Leaf) (Node (1::nat) Leaf Leaf)\"", "lemma \"eq (Node (1::nat) (Node 2 Leaf Leaf) (Node 3 Leaf Leaf)) (Node (1::nat) (Node 2 Leaf Leaf) (Node 4 Leaf Leaf)) \n    \\<longleftrightarrow> False\"", "lemma \"eq Even_Zero Even_Zero\"", "lemma \"eq Even_Zero (Even_Succ (Odd_Succ Even_Zero)) \\<longleftrightarrow> False\"", "lemma \"eq (Odd_Succ (Even_Succ (Odd_Succ Even_Zero))) (Odd_Succ (Even_Succ (Odd_Succ Even_Zero)))\"", "lemma \"eq (Odd_Succ (Even_Succ (Odd_Succ Even_Zero))) (Odd_Succ (Even_Succ (Odd_Succ (Even_Succ (Odd_Succ Even_Zero)))))\n    \\<longleftrightarrow> False\"", "lemma \"eq (Const (1::nat)) (Const (1::nat))\"", "lemma \"eq (Const (1::nat)) (Var (1::nat)) \\<longleftrightarrow> False\"", "lemma \"eq (Term (Prod (Const (1::nat)) (Factor (Const (2::nat))))) (Term (Prod (Const (1::nat)) (Factor (Const (2::nat)))))\"", "lemma \"eq (Term (Prod (Const (1::nat)) (Factor (Const (2::nat))))) (Term (Prod (Const (1::nat)) (Factor (Const (3::nat)))))\n    \\<longleftrightarrow> False\""], "translations": [["", "lemma \"eq (A 4) (A 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (A 4) (A 4)", "by eval"], ["", "lemma \"eq (A 6) (A 4) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (A 6) (A 4) = False", "by eval"], ["", "lemma \"eq C C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq C C", "by eval"], ["", "lemma \"eq (B 4 5) (B 4 5)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (B 4 5) (B 4 5)", "by eval"], ["", "lemma \"eq (B 4 4) (A 3) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (B 4 4) (A 3) = False", "by eval"], ["", "lemma \"eq C (A 4) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq C (A 4) = False", "by eval"], ["", "(* type with parameter *)"], ["", "derive_generic eq either"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma \"eq (L (3::nat)) (R 3) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (L 3) (R (3::'a)) = False", "by code_simp"], ["", "lemma \"eq (L (3::nat)) (L 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (L 3) (L 3)", "by code_simp"], ["", "lemma \"eq (L (3::nat)) (L 4) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (L 3) (L 4) = False", "by code_simp"], ["", "(* recursive types *)"], ["", "derive_generic eq list"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma \"eq ([]::(nat list)) []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq [] []", "by eval"], ["", "lemma \"eq ([1,2,3]:: (nat list)) [1,2,3]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq [1, 2, 3] [1, 2, 3]", "by eval"], ["", "lemma \"eq [(1::nat)] [1,2] \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq [1] [1, 2] = False", "by eval"], ["", "derive_generic eq tree"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma \"eq Leaf Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq Leaf Leaf", "by code_simp"], ["", "lemma \"eq (Node (1::nat) Leaf Leaf) Leaf \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (Node 1 Leaf Leaf) Leaf = False", "by eval"], ["", "lemma \"eq (Node (1::nat) Leaf Leaf) (Node (1::nat) Leaf Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (Node 1 Leaf Leaf) (Node 1 Leaf Leaf)", "by eval"], ["", "lemma \"eq (Node (1::nat) (Node 2 Leaf Leaf) (Node 3 Leaf Leaf)) (Node (1::nat) (Node 2 Leaf Leaf) (Node 4 Leaf Leaf)) \n    \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (Node 1 (Node 2 Leaf Leaf) (Node 3 Leaf Leaf))\n     (Node 1 (Node 2 Leaf Leaf) (Node 4 Leaf Leaf)) =\n    False", "by eval"], ["", "(* mutually recursive types *)"], ["", "derive_generic eq even_nat"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "derive_generic eq exp"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma \"eq Even_Zero Even_Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq Even_Zero Even_Zero", "by eval"], ["", "lemma \"eq Even_Zero (Even_Succ (Odd_Succ Even_Zero)) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq Even_Zero (Even_Succ (Odd_Succ Even_Zero)) = False", "by eval"], ["", "lemma \"eq (Odd_Succ (Even_Succ (Odd_Succ Even_Zero))) (Odd_Succ (Even_Succ (Odd_Succ Even_Zero)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (Odd_Succ (Even_Succ (Odd_Succ Even_Zero)))\n     (Odd_Succ (Even_Succ (Odd_Succ Even_Zero)))", "by eval"], ["", "lemma \"eq (Odd_Succ (Even_Succ (Odd_Succ Even_Zero))) (Odd_Succ (Even_Succ (Odd_Succ (Even_Succ (Odd_Succ Even_Zero)))))\n    \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (Odd_Succ (Even_Succ (Odd_Succ Even_Zero)))\n     (Odd_Succ (Even_Succ (Odd_Succ (Even_Succ (Odd_Succ Even_Zero))))) =\n    False", "by eval"], ["", "lemma \"eq (Const (1::nat)) (Const (1::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (Const 1) (Const 1)", "by code_simp"], ["", "lemma \"eq (Const (1::nat)) (Var (1::nat)) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (Const 1) (Var 1) = False", "by eval"], ["", "lemma \"eq (Term (Prod (Const (1::nat)) (Factor (Const (2::nat))))) (Term (Prod (Const (1::nat)) (Factor (Const (2::nat)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (Term (trm.Prod (Const 1) (Factor (Const 2))))\n     (Term (trm.Prod (Const 1) (Factor (Const 2))))", "by code_simp"], ["", "lemma \"eq (Term (Prod (Const (1::nat)) (Factor (Const (2::nat))))) (Term (Prod (Const (1::nat)) (Factor (Const (3::nat)))))\n    \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq (Term (trm.Prod (Const 1) (Factor (Const 2))))\n     (Term (trm.Prod (Const 1) (Factor (Const 3)))) =\n    False", "by code_simp"], ["", "end"]]}