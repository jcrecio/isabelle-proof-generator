{"file_name": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP/util/Tracing.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monad_Memo_DP", "problem_names": ["lemma trace_alt_def[simp]:\n  \"trace s x = (\\<lambda> _. x) (writeln s)\"", "lemma (in heap_mem_defs) checkmem_checkmem_trace:\n  \"checkmem param calc = checkmem_trace trace_key param (\\<lambda>_. calc)\"", "lemmas [code] =\n  heap_mem_defs.checkmem_trace_def", "lemmas [code_unfold] =\n  heap_mem_defs.checkmem_checkmem_trace[where trace_key = nat_to_string]\n  heap_mem_defs.checkmem_checkmem_trace[where trace_key = nat_pair_to_string]"], "translations": [["", "lemma trace_alt_def[simp]:\n  \"trace s x = (\\<lambda> _. x) (writeln s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace s x = x", "unfolding trace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let a = writeln s in x) = x", "by simp"], ["", "definition (in heap_mem_defs) checkmem_trace ::\n  \"('k \\<Rightarrow> String.literal) \\<Rightarrow> 'k \\<Rightarrow> (unit \\<Rightarrow> 'v Heap) \\<Rightarrow> 'v Heap\"\n  where\n  \"checkmem_trace trace_key param calc \\<equiv>\n    Heap_Monad.bind (lookup param) (\\<lambda> x.\n    case x of\n      Some x \\<Rightarrow> trace (STR ''Hit '' + trace_key param) (return x)\n    | None \\<Rightarrow> trace (STR ''Miss ''  + trace_key param)\n       Heap_Monad.bind (calc ()) (\\<lambda> x.\n        Heap_Monad.bind (update param x) (\\<lambda> _.\n        return x\n      )\n    )\n  )\n  \""], ["", "lemma (in heap_mem_defs) checkmem_checkmem_trace:\n  \"checkmem param calc = checkmem_trace trace_key param (\\<lambda>_. calc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checkmem param calc = checkmem_trace trace_key param (\\<lambda>_. calc)", "unfolding checkmem_trace_def checkmem_def trace_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup param \\<bind>\n    (\\<lambda>x.\n        case x of\n        None \\<Rightarrow>\n          calc \\<bind>\n          (\\<lambda>x. update param x \\<bind> (\\<lambda>_. return x))\n        | Some x \\<Rightarrow> return x) =\n    lookup param \\<bind>\n    (\\<lambda>x.\n        case x of\n        None \\<Rightarrow>\n          calc \\<bind>\n          (\\<lambda>x. update param x \\<bind> (\\<lambda>_. return x))\n        | Some x \\<Rightarrow> return x)", ".."], ["", "definition nat_to_string :: \"nat \\<Rightarrow> String.literal\" where\n  \"nat_to_string x = String.implode (show x)\""], ["", "definition nat_pair_to_string :: \"nat \\<times> nat \\<Rightarrow> String.literal\" where\n  \"nat_pair_to_string x = String.implode (show x)\""], ["", "value \"show (3 :: nat)\""], ["", "paragraph \\<open>Code Setup\\<close>"], ["", "lemmas [code] =\n  heap_mem_defs.checkmem_trace_def"], ["", "lemmas [code_unfold] =\n  heap_mem_defs.checkmem_checkmem_trace[where trace_key = nat_to_string]\n  heap_mem_defs.checkmem_checkmem_trace[where trace_key = nat_pair_to_string]"], ["", "end"]]}